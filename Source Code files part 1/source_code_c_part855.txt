C_BACK_COLORPICKER            0x7566
#define IDC_BACK_DISPLAY                0x7567
#define IDC_BACK_SELECT                 0x7568
#define IDC_BACK_COLORPICKERLABEL       0x7569

// Desktop Items Dialog
#define IDC_COMP_LIST                   0x7570
#define IDC_COMP_NEW                    0x7571
#define IDC_COMP_DELETE                 0x7572
#define IDC_COMP_PROPERTIES             0x7573
#define IDC_DESKTOP_ICONS               0x7574
#define IDC_COMP_PREVIEW                0x7575
#define IDC_CHANGEICON2                 0x7576
#define IDC_ICONDEFAULT                 0x7577
#define IDC_COMP_DESKCLNR               0x7578
#define IDC_COMP_SYNCHRONIZE            0x7579

#define IDC_CPROP_COMPLIST              0x7579
#define IDC_CPROP_SOURCE                0x757a
#define IDC_CPROP_BROWSE                0x757b
#define IDC_GOTO_GALLERY                0x757c

#define IDC_DESKTOP_ICON_MYDOCS         0x757d
#define IDC_DESKTOP_ICON_MYCOMP         0x757e
#define IDC_DESKTOP_ICON_MYNET          0x7580
#define IDC_DESKTOP_ICON_IE             0x7581

#define IDC_CPDLG_16COLORS              0x7584
#define IDC_CPDLG_COLORETCH             0x7585
#define IDC_CPDLG_COLOROTHER            0x7586
#define IDC_CPDLG_COLORCUST             0x7587

#define IDC_KBSTART                     0x857c

// ids for IDD_FOLDEROPTIONS
// Warning: Do not change the order and sequence of the following IDs.
// The code assumes and asserts if it changes.
#define IDC_FCUS_WHENEVER_POSSIBLE      0x7592
#define IDC_FCUS_WHEN_CHOOSE            (IDC_FCUS_WHENEVER_POSSIBLE + 1)// 0x7593
#define IDC_FCUS_SAME_WINDOW            (IDC_FCUS_WHEN_CHOOSE + 1)      // 0x7594
#define IDC_FCUS_SEPARATE_WINDOWS       (IDC_FCUS_SAME_WINDOW + 1)      // 0x7595
#define IDC_FCUS_SINGLECLICK            (IDC_FCUS_SEPARATE_WINDOWS + 1) // 0x7596
#define IDC_FCUS_DOUBLECLICK            (IDC_FCUS_SINGLECLICK + 1)      // 0x7597
#define IDC_FCUS_ICON_IE                (IDC_FCUS_DOUBLECLICK + 1)      // 0x7598
#define IDC_FCUS_ICON_HOVER             (IDC_FCUS_ICON_IE + 1)          // 0x7599
#define IDC_FCUS_ICON_MAX               (IDC_FCUS_ICON_HOVER + 1)
// End of Warning: Do not change the order and sequence of the above IDC_FCUS_* id values.

#define IDC_FCUS_RESTORE_DEFAULTS       0x759B

// Warning: Do not change the order and sequence of the following IDs.
#define IDC_FCUS_ICON_WEBVIEW           0x759D
#define IDC_FCUS_ICON_WINDOW            (IDC_FCUS_ICON_WEBVIEW + 1)        // 0x759E           
#define IDC_FCUS_ICON_CLICKS            (IDC_FCUS_ICON_WINDOW + 1)         // 0x759F
// End of Warning: Do not change the order and sequence of the above IDC_FOCUS_* 

#define IDC_FCUS_WEBVIEW_GROUP_STATIC   0x7580

#define IDC_COMP_DESKTOPICONS_GROUP       0x7588
#define IDC_COMP_CHANGEDESKTOPICON_LABEL  0x7589
#define IDC_COMP_DESKTOPWEBPAGES_LABEL    0x7590
#define IDC_COMP_DESKTOPWEBPAGES_TITLE1   0x7591
#define IDC_COMP_DESKTOPWEBPAGES_TITLE2   0x7592
#define IDC_COMP_DESKTOPWEBPAGES_CHECK    0x7593

// ids for IDD_CHECKSINGLECLICK
#define IDC_SC_YES                      0x75A0
#define IDC_SC_NO                       0x75A1
#define IDC_SC_MOREINFO                 0x75A2

// ids for IDD_ADVANCEDOPTIONS
#define IDC_ADVO_ADVANCEDTREE           0x75A8
#define IDC_ADVO_ADV_RESTORE_DEF        0x75A9
#define IDC_ADVO_RESETTOORIGINAL        0x75AA
#define IDC_ADVO_USECURRENTFOLDER       0x75AB
#define IDC_ADVO_IMAGEFOLDER            0x75AC
#define IDC_ADVO_ADVANCEDTEXT           0x75AD
#define IDC_ADVO_GROUPBOX               0x75AE
#define IDC_ADVO_STATICTEXT             0x75AF




//
// The constants below came from DESKHTML.DLL
//
#define IDS_SUBSCRIBEDURL               0x7600
#define IDS_RESIZEABLE                  0x7601
#define IDS_BASE_TAG                    0x7602
#define IDS_COMMENT_BEGIN               0x7603
#define IDS_COMMENT1                    0x7604
#define IDS_COMMENT_END                 0x7605
#define IDS_HEADER_BEGIN                0x7606
#define IDS_BODY_BEGIN                  0x7607
#define IDS_DIV_START                   0x7608
#define IDS_DIV_SIZE                    0x7609
#define IDS_IMAGE_BEGIN                 0x760a
#define IDS_IMAGE_LOCATION              0x760b
#define IDS_IMAGE_SIZE                  0x760c
#define IDS_DIV_END                     0x760d
#define IDS_IFRAME_BEGIN                0x760e
#define IDS_IFRAME_SIZE                 0x760f
#define IDS_BODY_END                    0x7610
#define IDS_CONTROL_1                   0x7611
#define IDS_CONTROL_2                   0x7612
#define IDS_CONTROL_3                   0x7613
#define IDS_DIV_START2                  0x7614
#define IDS_DIV_START2W                 0x7615
#define IDS_IMAGE_BEGIN2                0x7616
#define IDS_IFRAME_BEGIN2               0x7617
#define IDS_BODY_BEGIN2                 0x7618
#define IDS_BODY_CENTER_WP              0x7619
#define IDS_BODY_PATTERN_AND_WP         0x761a
#define IDS_STRETCH_WALLPAPER           0x761b
#define IDS_WPSTYLE                     0x761c    // first style string
#define IDS_WPSTYLE_CENTER              (IDS_WPSTYLE)
#define IDS_WPSTYLE_TILE                (IDS_WPSTYLE+1)
#define IDS_WPSTYLE_STRETCH             (IDS_WPSTYLE+2)
#define IDS_COMP_BADURL                 0x7626
#define IDS_COMP_TITLE                  0x7627
#define IDS_COMP_EXISTS                 0x7628
#define IDS_COMP_SUBSCRIBED             0x7629
#define IDS_COMP_BADSUBSCRIBE           0x762a
#define IDS_SAMPLE_COMPONENT            0x762b
#define IDS_CHANNEL_BAR                 0x762c
#define IDS_COMP_CONFIRMDEL             0x762d
#define IDS_VALIDFN_FMT                 0x762e
#define IDS_VALIDFN_TITLE               0x762f
#define IDS_BACK_TYPE1                  0x7630
#define IDS_BACK_TYPE2                  0x7631
#define IDS_COMP_TYPE1                  0x7632
#define IDS_COMP_TYPE2                  0x7633
#define IDS_VISIT_URL                   0x7634
#define IDS_COMP_CONFIRMRESET           0x7635
#define IDS_BACK_FILETYPES              0x7636
#define IDS_COMP_FILETYPES              0x7637
#define IDS_ADDCOMP_ERROR_CDFNODTI      0x7638
#define IDS_ADDCOMP_ERROR_CDFINALID     0x7639
#define IDS_VISITGALLERY_TEXT           0x763a
#define IDS_VISITGALLERY_TITLE          0x763b
#define IDS_CONFIRM_ADI_REINSTALL       0x763d
#define IDS_ADDRBAND_ACCELLERATOR       0x763e
#define IDS_FOLDEROPT_TEXT              0x763f
#define IDS_FOLDEROPT_TITLE             0x7640
#define IDS_FOLDERVIEWS                 0x7643
#define IDS_LIKECURRENT_TEXT            0x7644
#define IDS_RESETALL_TEXT               0x7645
#define IDS_DIV_START3                  0x7646
#define IDS_BODY_PATTERN_AND_WP2        0x7647
#define IDS_BODY_CENTER_WP2             0x7648
#define IDS_BODY_END2                   0x7649
#define IDS_COMP_EXISTS_2               0x764a

#define IDS_HTMLDOCUMENT                0x764b
#define IDS_PICTURE                     0x764c
#define IDS_WEBSITE                     0x764d
#define IDS_ADDTODESKTOP                0x764e
#define IDS_EDITDESKTOPCOMP             0x764f
#define IDS_CDF_FILTER                  0x7650
#define IDS_URL_FILTER                  0x7651
#define IDS_TYPETHENAMESTRING           0x7652
#define IDS_IMAGES_FILTER               0x7653
#define IDS_HTMLDOC_FILTER              0x7654
#define IDS_CONFIRM_ADD                 0x7655
#define IDS_INTERNET_EXPLORER           0x7656
#define IDS_MHTML_FILTER                0x7657

#define IDS_NOHTML_SELECTED             0x7658
#define IDS_URL_EXTENSION               0x7659
#define IDS_CONFIRM_OVERWRITE_SUBSCR    0x765a
#define IDS_CONFIRM_RESET_SAFEMODE      0x765b
#define IDS_WPNONE                      0x765c
#define IDS_CONFIRM_TURNINGON_AD        0x765d // Not for the confirm close dialogs!
#define IDS_MENU_SUBSCRIBE_DESKCOMP     0x765e
#define IDS_YOULOSE                     0x765f

#define IDS_CMTF_COPYTO                 0x7660
#define IDS_CMTF_MOVETO                 0x7661
#define IDS_CMTF_COPY_DLG_TITLE         0x7662 //cmtf <=> CopyMoveToFolder
#define IDS_CMTF_MOVE_DLG_TITLE         0x7663
//#define IDS_CMTF_COPYORMOVE_DLG_TITLE 0x7677
#define IDS_CMTF_ERRORMSG               0x7664

#define IDS_CABINET                     0x7665
#define IDS_CANTFINDDIR                 0x7666

#define ACCEL_DESKTOP           3
#define IDS_MENU_RESET                  0x7667

#define IDS_SENDLINKTO                  0x7668
#define IDS_SENDPAGETO                  0x7669
#define IDS_SENDTO_ERRORMSG             0x766a

#define IDS_NEWMENU             0x766b
#define IDS_NEWFILEPREFIX       0x766c
#define IDS_NEWFOLDER           0x766d
#define IDS_NEWLINK             0x766e
#define IDS_FOLDERTEMPLATE      0x766f
#define IDS_FOLDERLONGPLATE     0x7670
#define IDS_NEWLINKTEMPLATE     0x7671
#define IDS_NEWFILE_ERROR_TITLE 0x7672
#define IDS_MY_CURRENT_HOMEPAGE 0x7673
#define IDS_FIND_MNEMONIC       0x7674  // Old Accelerator -- warning! used by explorer.exe directly
#define IDS_CONNECTING          0x7675 
#define IDS_INFOTIP             0x7676  // Used by the shell automation object
#define IDS_CMTF_COPYORMOVE_DLG_TITLE   0x7677

#define IDS_COMP_ICW_ADD                0x7678
#define IDS_COMP_ICW_DISABLE            0x7679
#define IDS_COMP_ICW_TOGGLE             0x767A
#define IDS_COMP_ICW_TITLE              0x767B

#define IDS_NEWHELP_FIRST       0x767C
#define IDS_NEWHELP_FOLDER      0x767C
#define IDS_NEWHELP_LINK        0x767D


// Start Menu Info Tips.
#define IDS_PROGRAMS_TIP        0x7680
#define IDS_FAVORITES_TIP       0x7681
#define IDS_RECENT_TIP          0x7682
#define IDS_SETTINGS_TIP        0x7683
#define IDS_FIND_TIP            0x7684
#define IDS_HELP_TIP            0x7685
#define IDS_RUN_TIP             0x7686
#define IDS_LOGOFF_TIP          0x7687
#define IDS_EJECT_TIP           0x7688
#define IDS_SHUTDOWN_TIP        0x7689
#define IDS_CONTROL_TIP         0x768A
#define IDS_PRINTERS_TIP        0x768B
#define IDS_TRAYPROP_TIP        0x768C
#define IDS_MYDOCS_TIP          0x768D
#define IDS_NETCONNECT_TIP      0x768E
#define IDS_CHEVRONTIPTITLE     0x768F
#define IDS_CHEVRONTIP          0x7690
#define IDS_ALL_PICTURES        0x76A0
#define IDS_ALL_HTML            0x76A1
#define IDS_HTMLDOC             0x76A2
#define IDS_PROPSHEET_TITLE     0x76A3
//#define UNUSED - RECYCLE ME   0x76A4
#define IDS_MYPICS_TIP          0x76A5
#define IDS_THEMES_SUBDIR       0x76A6

#define IDS_CMTF_COPY_DLG_TITLE2 0x76a7
#define IDS_CMTF_MOVE_DLG_TITLE2 0x76a8
#define IDS_CMTF_COPY_MULTIPLE_DLG_TITLE2 0x76a9
#define IDS_CMTF_MOVE_MULTIPLE_DLG_TITLE2 0x76aa
#define IDS_CMTF_CAPTION_COPY    0x76ab
#define IDS_CMTF_CAPTION_MOVE    0x76ac

#define IDS_FULL                 0x76b0
#define IDS_EMPTY2               0x76b1
#define IDS_MYCOMPUTER           0x76b2
#define IDS_NETNEIGHBOUR         0x76b3
#define IDS_TRASHFULL            0x76b4
#define IDS_TRASHEMPTY           0x76b5
#define IDS_TRASHDEFAULT         0x76b6
#define IDS_MYDOCUMENTS2         0x76b7

#define IDC_COMP_CLEANUP_GROUP   0x7700

// Still more constants moved (and renumbered) from shdocvw\resource.h

//#define IDS_COMPSETTINGS              xxxxxx // already in shell32\resource.h

// More constants moved (and renumbered) from shdocvw\resource.h

#define MENU_DESKCOMP_CONTEXTMENU       400
#define MENU_STARTMENU_MYDOCS           401
#define MENU_STARTMENU_OPENFOLDER       402
// NOTE: raymondc - This used to be at FCIDM_BROWSER_EXPLORE+0x240.
// What does that mean?  Is that number special?  I just gave it a new
// number.
#define IDM_DCCM_FIRST          0xA100
#define DCCM_MENUITEMS          20  //  reserved space for Desktop Component Menu items
#define IDM_DCCM_OPEN           (IDM_DCCM_FIRST+0x01)
#define IDM_DCCM_OFFLINE        (IDM_DCCM_FIRST+0x02)
#define IDM_DCCM_SYNCHRONIZE    (IDM_DCCM_FIRST+0x03)
#define IDM_DCCM_PROPERTIES     (IDM_DCCM_FIRST+0x04)
#define IDM_DCCM_CUSTOMIZE      (IDM_DCCM_FIRST+0x08)
#define IDM_DCCM_CLOSE          (IDM_DCCM_FIRST+0x09)
#define IDM_DCCM_FULLSCREEN     (IDM_DCCM_FIRST+0x0a)
#define IDM_DCCM_SPLIT          (IDM_DCCM_FIRST+0x0b)
#define IDM_DCCM_RESTORE        (IDM_DCCM_FIRST+0x0c)
#define IDM_DCCM_LASTCOMPITEM   (IDM_DCCM_FIRST+DCCM_MENUITEMS)

#define IDM_MYDOCUMENTS         516
#define IDM_OPEN_FOLDER         517
#define IDM_MYPICTURES          518


// Bitmap IDs

#define IDB_MONITOR             0x135
#define IDB_WIZARD              0x136

// These numbers are for CShellDispatch (sdmain.cpp) to send
// messages to the tray.

//The following value is taken from  shdocvw\rcids.h
#ifndef FCIDM_REFRESH
#define FCIDM_REFRESH  0xA220
#endif // FCIDM_REFRESH

#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST+0x0060)
#define FCIDM_BROWSER_TOOLS     (FCIDM_BROWSERFIRST+0x0080)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)        
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)

#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_SELECTALL         (FCIDM_BROWSER_EDIT+0x0004)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut
#define FCIDM_EDITPAGE          (FCIDM_BROWSER_EDIT+0x0006)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\options.cpp ===
#include "stdafx.h"
#include <trayp.h>
#include "utils.h"
#include "..\deskfldr.h"
#pragma hdrstop

#define SZ_FOLDEROPTSTUBCLASS TEXT("MSGlobalFolderOptionsStub")

void Cabinet_StateChanged(CABINETSTATE *pcs);

const static DWORD aFolderOptsHelpIDs[] = {  // Context Help IDs
    IDC_FCUS_SAME_WINDOW,        IDH_BROWSE_SAME_WINDOW,
    IDC_FCUS_SEPARATE_WINDOWS,   IDH_BROWSE_SEPARATE_WINDOWS,
    IDC_FCUS_WHENEVER_POSSIBLE,  IDH_SHOW_WEB_WHEN_POSSIBLE,
    IDC_FCUS_WHEN_CHOOSE,        IDH_SHOW_WEB_WHEN_CHOOSE,
    IDC_FCUS_SINGLECLICK,        IDH_SINGLE_CLICK_MODE,
    IDC_FCUS_DOUBLECLICK,        IDH_DOUBLE_CLICK_MODE,
    IDC_FCUS_ICON_IE,            IDH_TITLES_LIKE_LINKS,
    IDC_FCUS_ICON_HOVER,         IDH_TITLES_WHEN_POINT,
    IDC_FCUS_ICON_WEBVIEW,       IDH_WEB_VIEW_GEN,
    IDC_FCUS_ICON_WINDOW,        IDH_BROWSE_FOLDERS_GEN,
    IDC_FCUS_ICON_CLICKS,        IDH_ICON_OPEN_GEN,
    IDC_FCUS_RESTORE_DEFAULTS,   IDH_RESTORE_DEFAULTS_GEN,
    IDC_FCUS_WEBVIEW_GROUP_STATIC, -1,         // Suppress help for this item.
    0, 0
};

typedef struct
{
    CABINETSTATE cs;      // Cached "current" CabState.
    CFolderOptionsPsx *ppsx;    // to talk to our propsheet sibling
    // The icons corresponding to the radio button selected are stored here.
    HICON   ahIcon[IDC_FCUS_ICON_MAX - IDC_FCUS_WHENEVER_POSSIBLE + 1];
} FOLDEROPTDATA;

// Reads CabinetState and Default Folder Settings
void ReadStateAndSettings(HWND hDlg)
{
    FOLDEROPTDATA *pfod = (FOLDEROPTDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    pfod->ppsx->SetNeedRefresh(FALSE);

    //Get the current Cabinet State
    ReadCabinetState(&pfod->cs, sizeof(pfod->cs));
}

//
// This function selects a given radio button among a set of radio buttons AND it sets the Icon
// image corresponding to the radio button selected.

void CheckRBtnAndSetIcon(HWND hDlg, int idStartBtn, int idEndBtn, int idSelectedBtn, FOLDEROPTDATA *pfod, BOOL fCheckBtn)
{
    //
    //  Check the radio button if required
    //
    if (fCheckBtn)
        CheckRadioButton(hDlg, idStartBtn, idEndBtn, idSelectedBtn);

    // Now, select the Icon corresponding to this selection

    // The following code assumes the order and sequence of the following IDs.
    // So, we verify that no one has broken them inadvertently by doing the following
    // compile time checks.
    COMPILETIME_ASSERT((IDC_FCUS_WHENEVER_POSSIBLE + 1) == IDC_FCUS_WHEN_CHOOSE);
    COMPILETIME_ASSERT((IDC_FCUS_WHEN_CHOOSE + 1)       == IDC_FCUS_SAME_WINDOW);
    COMPILETIME_ASSERT((IDC_FCUS_SAME_WINDOW + 1)       == IDC_FCUS_SEPARATE_WINDOWS);
    COMPILETIME_ASSERT((IDC_FCUS_SEPARATE_WINDOWS + 1)  == IDC_FCUS_SINGLECLICK);
    COMPILETIME_ASSERT((IDC_FCUS_SINGLECLICK + 1)       == IDC_FCUS_DOUBLECLICK);
    COMPILETIME_ASSERT((IDC_FCUS_DOUBLECLICK + 1)       == IDC_FCUS_ICON_IE);
    COMPILETIME_ASSERT((IDC_FCUS_ICON_IE + 1)           == IDC_FCUS_ICON_HOVER);
    COMPILETIME_ASSERT((IDC_FCUS_ICON_HOVER + 1)        == IDC_FCUS_ICON_MAX);

    COMPILETIME_ASSERT((IDI_WEBVIEW_ON + 1)     == IDI_WEBVIEW_OFF);
    COMPILETIME_ASSERT((IDI_WEBVIEW_OFF + 1)    == IDI_SAME_WINDOW);
    COMPILETIME_ASSERT((IDI_SAME_WINDOW + 1)    == IDI_SEPARATE_WINDOW);
    COMPILETIME_ASSERT((IDI_SEPARATE_WINDOW + 1)== IDI_SINGLE_CLICK);
    COMPILETIME_ASSERT((IDI_SINGLE_CLICK + 1)   == IDI_DOUBLE_CLICK);

    COMPILETIME_ASSERT((IDC_FCUS_ICON_WEBVIEW + 1)       == IDC_FCUS_ICON_WINDOW);
    COMPILETIME_ASSERT((IDC_FCUS_ICON_WINDOW + 1)        == IDC_FCUS_ICON_CLICKS);

    ASSERT((IDC_FCUS_ICON_MAX - IDC_FCUS_WHENEVER_POSSIBLE + 1) == ARRAYSIZE(pfod->ahIcon));

    int iIndex = idSelectedBtn - IDC_FCUS_WHENEVER_POSSIBLE; //Calculate the index into the Icon Table

    ASSERT(iIndex < ARRAYSIZE(pfod->ahIcon));

    if (pfod->ahIcon[iIndex] == NULL)
        pfod->ahIcon[iIndex] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_WEBVIEW_ON + iIndex), IMAGE_ICON, 0,0, LR_DEFAULTSIZE);

    // Set the Icon image corresponding to the Radio button selected.
    // This dialog is broken into sections of radio buttons. Each section has two and only two main
    // radio buttons and a corresponding icon. In order to associate the radio buttons with their
    // corresponding icon, all button ids and all icon ids are kept in order (hence the above COMPILETIME_ASSERTs),
    // such that the first and second radio buttons belong with the first icon, second and third radio buttons
    // belong with the second icon, and so on. Now, given a radio button id, get its position in the list of
    // all the radio buttons (that is the index assigment just above) and shift it right by one bit to get the index
    // of the corresponding icon. The shift is neccesary because there is only one icon every two radio buttons.
    SendDlgItemMessage(hDlg, IDC_FCUS_ICON_WEBVIEW + (iIndex >> 1), STM_SETICON, (WPARAM)(pfod->ahIcon[iIndex]), 0);
}

BOOL_PTR CALLBACK FolderOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fCheckedSingleClickDialog = FALSE;
    static BOOL fCheckedWebStyle = FALSE;
    int idSelectedBtn, i;

    FOLDEROPTDATA *pfod = (FOLDEROPTDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
    case WM_INITDIALOG:
    {
        pfod = (FOLDEROPTDATA *)LocalAlloc(LPTR, sizeof(*pfod));
        if (pfod)
        {
            BOOL fClassicShell, fForceActiveDesktopOn;
            SHELLSTATE ss = { 0 };
            //Set the Folder Options data
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pfod);

            PROPSHEETPAGE *pps = (PROPSHEETPAGE *)lParam;
            pfod->ppsx = (CFolderOptionsPsx *)pps->lParam;

            ReadStateAndSettings(hDlg);

            // No need to initialize the array of icons with zeros
            // for(i = 0; i < ARRAYSIZE(pfod->ahIcon); i++)
            //    pfod->ahIcon[i] = NULL;

            fClassicShell = SHRestricted(REST_CLASSICSHELL);
            fForceActiveDesktopOn = SHRestricted(REST_FORCEACTIVEDESKTOPON);
            SHGetSetSettings(&ss, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC | SSF_WEBVIEW, FALSE);

            // browse folder options
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_SAME_WINDOW,
                         IDC_FCUS_SEPARATE_WINDOWS,
                         pfod->cs.fNewWindowMode ? IDC_FCUS_SEPARATE_WINDOWS:IDC_FCUS_SAME_WINDOW, pfod, TRUE);

            // show folders as web pages
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_WHENEVER_POSSIBLE,
                         IDC_FCUS_WHEN_CHOOSE,
                         ss.fWebView && !fClassicShell? IDC_FCUS_WHENEVER_POSSIBLE : IDC_FCUS_WHEN_CHOOSE, pfod, TRUE);

            if (SHRestricted(REST_NOWEBVIEW) || fClassicShell)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_WHENEVER_POSSIBLE), FALSE);
                //EnableWindow(GetDlgItem(hDlg, IDC_FCUS_WHEN_CHOOSE), FALSE);
                //EnableWindow(GetDlgItem(hDlg, IDC_FCUS_WEBVIEW_GROUP_STATIC), FALSE);
            }

            // single/double click
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_SINGLECLICK,IDC_FCUS_DOUBLECLICK,
                         !ss.fWin95Classic
                         ? (ss.fDoubleClickInWebView ? IDC_FCUS_DOUBLECLICK:IDC_FCUS_SINGLECLICK)
                         : IDC_FCUS_DOUBLECLICK, pfod, TRUE);

            if (fClassicShell)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_SINGLECLICK), FALSE);
            }
            // gray out icon underline behvaior when not in single click mode
            BOOL fChecked = IsDlgButtonChecked(hDlg, IDC_FCUS_SINGLECLICK);
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_IE),    fChecked);
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), fChecked);

            DWORD dwIconUnderline = ICON_IE;

            if (!fClassicShell)
            {
                DWORD cb = sizeof(dwIconUnderline);

                SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                            TEXT("IconUnderline"),
                            NULL,
                            &dwIconUnderline,
                            &cb,
                            FALSE,
                            &dwIconUnderline,
                            cb);
            }

            // JANK : Fix for MIL bug #105236
            // Since these are sub radio buttons, they do not have an icon and therefore do not need
            // the CheckRBtnAndSetIcon call
            CheckRadioButton(hDlg, IDC_FCUS_ICON_IE, IDC_FCUS_ICON_HOVER,
                         dwIconUnderline == ICON_IE ? IDC_FCUS_ICON_IE : IDC_FCUS_ICON_HOVER);
/*
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_ICON_IE, IDC_FCUS_ICON_HOVER,
                         dwIconUnderline == ICON_IE ? IDC_FCUS_ICON_IE : IDC_FCUS_ICON_HOVER, pfod, TRUE);
*/

            if (fClassicShell)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), FALSE);
            }
        }
        else
        {
            // Can't use EndDialog because we weren't created by DialogBox()
            DestroyWindow(hDlg);
        }
        return TRUE;
    }

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_APPLY:
        {
            SHELLSTATE oldss = {0}, ss = { 0 };

            SHGetSetSettings(&oldss, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC | SSF_WEBVIEW, FALSE);

            BOOL fOldValue = BOOLIFY(pfod->cs.fNewWindowMode);
            if (IsDlgButtonChecked(hDlg, IDC_FCUS_SAME_WINDOW))
                pfod->cs.fNewWindowMode = FALSE;
            else
                pfod->cs.fNewWindowMode = TRUE;
            if (fOldValue != (pfod->cs.fNewWindowMode ? 1 : 0))
                Cabinet_StateChanged(&pfod->cs);

            if (IsDlgButtonChecked(hDlg, IDC_FCUS_WHENEVER_POSSIBLE))
            {
                ss.fWin95Classic = FALSE;
                ss.fWebView = TRUE;
            }
            else
            {
                ss.fWin95Classic = TRUE;
                ss.fWebView = FALSE;
            }

            if (IsDlgButtonChecked(hDlg, IDC_FCUS_SINGLECLICK))
            {
                ss.fDoubleClickInWebView = FALSE;
                ss.fWin95Classic = FALSE;
            }
            else
            {
                ss.fDoubleClickInWebView = TRUE;
                ss.fWin95Classic = FALSE;
            }

            DWORD dwIconUnderline, dwOldIconUnderline, dwDefaultIconUnderline;
            DWORD cb = sizeof(dwIconUnderline);

            //Get the current settings for "IconUnderline"
            dwDefaultIconUnderline = -1;  // not ICON_IE or will not WM_WININICHANGE
            SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                            TEXT("IconUnderline"), NULL, &dwOldIconUnderline, &cb,
                            FALSE, &dwDefaultIconUnderline, sizeof(dwDefaultIconUnderline));
                                
            if (IsDlgButtonChecked(hDlg, IDC_FCUS_ICON_IE))
                dwIconUnderline = ICON_IE;
            else
                dwIconUnderline = ICON_HOVER;

            if (dwOldIconUnderline != dwIconUnderline) //See if this setting has changed
            {
                cb = sizeof(dwIconUnderline);
                SHRegSetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                                TEXT("IconUnderline"), NULL, &dwIconUnderline, cb,
                                SHREGSET_DEFAULT);

                SHSendMessageBroadcast(WM_WININICHANGE, 0, (LPARAM)TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\IconUnderline"));
            }

            DWORD dwMask = 0;
            if (ss.fWebView != oldss.fWebView)
            {
                dwMask |= SSF_WEBVIEW;
            }
            
            if (ss.fWin95Classic != oldss.fWin95Classic)
            {
                dwMask |= SSF_WIN95CLASSIC;
            }
            
            if (ss.fDoubleClickInWebView != oldss.fDoubleClickInWebView)
            {
                dwMask |= SSF_DOUBLECLICKINWEBVIEW;
            }

            if (dwMask)
            {
                SHGetSetSettings(&ss, dwMask, TRUE);
            }

            if (ss.fWebView != oldss.fWebView)
            {
                Cabinet_RefreshAll(Cabinet_UpdateWebViewEnum, (LPARAM)ss.fWebView);
                // Note: This refreshes as well.
            }
            
            if ((ss.fWin95Classic != oldss.fWin95Classic)
                    || (ss.fDoubleClickInWebView != oldss.fDoubleClickInWebView))
            {
                Cabinet_RefreshAll(Cabinet_RefreshEnum, (LPARAM)0);
            }

            return TRUE;
        }

        case PSN_KILLACTIVE:
            // validate here
            // SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !ValidateLink());   // don't allow close
            return TRUE;

        case PSN_SETACTIVE:
            if (pfod->ppsx->NeedRefresh())
            {
                ReadStateAndSettings(hDlg);
            }
            return TRUE;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, TEXT(SHELL_HLP),
           HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aFolderOptsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, TEXT(SHELL_HLP), HELP_CONTEXTMENU,
            (ULONG_PTR)(void *)aFolderOptsHelpIDs);
        break;

    case WM_COMMAND:
        idSelectedBtn = GET_WM_COMMAND_ID(wParam, lParam);
        switch (idSelectedBtn)
        {
        case IDC_FCUS_SINGLECLICK:
        case IDC_FCUS_DOUBLECLICK:
            if (GET_WM_COMMAND_CMD(wParam,lParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_IE),    GET_WM_COMMAND_ID(wParam,lParam) == IDC_FCUS_SINGLECLICK);
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), GET_WM_COMMAND_ID(wParam,lParam) == IDC_FCUS_SINGLECLICK);
            }
            //Fall through ...
        case IDC_FCUS_WHENEVER_POSSIBLE:
        case IDC_FCUS_WHEN_CHOOSE:
        case IDC_FCUS_SAME_WINDOW:
        case IDC_FCUS_SEPARATE_WINDOWS:
            // We do not need to Check the radio button; It is alreay checked. We just need to
            // set the corresponding Icon. Hence we pass FALSE.
            CheckRBtnAndSetIcon(hDlg, 0, 0, idSelectedBtn, pfod, FALSE);
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            break;

        case IDC_FCUS_ICON_IE:
        case IDC_FCUS_ICON_HOVER:
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            break;

        case IDC_FCUS_RESTORE_DEFAULTS:
            //Set the "factory settings" as the default.
            // Don't set the default web view option if web view is disabled via system policy.
            if (0 == SHRestricted(REST_NOWEBVIEW))
            {
                CheckRBtnAndSetIcon(hDlg, IDC_FCUS_WHENEVER_POSSIBLE, IDC_FCUS_WHEN_CHOOSE, IDC_FCUS_WHENEVER_POSSIBLE, pfod, TRUE);
            }
            CheckRBtnAndSetIcon(hDlg, IDC_FCUS_SAME_WINDOW, IDC_FCUS_SEPARATE_WINDOWS, IDC_FCUS_SAME_WINDOW, pfod, TRUE);
            CheckRBtnAndSetIcon(hDlg, IDC_FCUS_SINGLECLICK, IDC_FCUS_DOUBLECLICK, IDC_FCUS_DOUBLECLICK, pfod, TRUE);

            CheckRadioButton(hDlg, IDC_FCUS_ICON_IE, IDC_FCUS_ICON_HOVER, IDC_FCUS_ICON_IE);
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_IE),    FALSE); //Disable
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), FALSE); //Disable

            //Enable the "Apply" button because changes have happened.
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);

            break;
        }
        break;

    case WM_DESTROY:
        if (pfod)
        {
            //Cleanup the Icons array!
            for (i = 0; i < ARRAYSIZE(pfod->ahIcon); i++)
            {
                if (pfod->ahIcon[i])
                    DestroyIcon(pfod->ahIcon[i]);
            }
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
            LocalFree((HANDLE)pfod);
        }
        break;
    }

    return FALSE;
}

// Moved from defview.cpp, which never used these functions

const TCHAR c_szExploreClass[]  = TEXT("ExploreWClass");
const TCHAR c_szIExploreClass[] = TEXT("IEFrame");
const TCHAR c_szCabinetClass[]  = TEXT("CabinetWClass");

BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return lstrcmp(szClass, pszClass) == 0;
}

BOOL IsExplorerWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, c_szExploreClass);
}

BOOL IsTrayWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, TEXT(WNDCLASS_TRAYNOTIFY));
}

BOOL IsFolderWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) || (lstrcmp(szClass, c_szIExploreClass) == 0);
}

BOOL CALLBACK Cabinet_GlobalStateEnum(HWND hwnd, LPARAM lParam)
{
    if (IsFolderWindow(hwnd) || IsExplorerWindow(hwnd))
    {
        PostMessage(hwnd, CWM_GLOBALSTATECHANGE, 0, 0);
    }

    return TRUE;
}

void Cabinet_StateChanged(CABINETSTATE *pcs)
{
    // Save the new settings away...
    WriteCabinetState(pcs);
    EnumWindows(Cabinet_GlobalStateEnum, 0);
}

HWND CreateGlobalFolderOptionsStubWindow(void)
{
    WNDCLASS wc = {0};
    
    wc.lpfnWndProc   = DefWindowProc;
    wc.hInstance     = HINST_THISDLL;
    wc.hIcon         = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_FOLDEROPTIONS));
    wc.lpszClassName = SZ_FOLDEROPTSTUBCLASS;

    RegisterClass(&wc);

    DWORD dwExStyle = WS_EX_TOOLWINDOW;
    if (IS_BIDI_LOCALIZED_SYSTEM()) 
    {
        dwExStyle |= dwExStyleRTLMirrorWnd;
    }
    return CreateWindowEx(dwExStyle, SZ_FOLDEROPTSTUBCLASS, c_szNULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL, HINST_THISDLL, NULL);
}

BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAXPROPPAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

void AddPropSheetCLSID(REFCLSID clsid, PROPSHEETHEADER *ppsh)
{
    IShellPropSheetExt *psx;
    HRESULT hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellPropSheetExt, &psx));
    if (SUCCEEDED(hres)) 
    {
        psx->AddPages(AddPropSheetPage, (LPARAM)ppsh);
        psx->Release();
    }
}

DWORD CALLBACK GlobalFolderOptPropSheetThreadProc(void *)
{
    HWND hwndStub = CreateGlobalFolderOptionsStubWindow();

    if (!SHRestricted(REST_NOFOLDEROPTIONS))
    {
        PROPSHEETHEADER psh = {0};
        HPROPSHEETPAGE rPages[MAXPROPPAGES];

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_DEFAULT;
        psh.hInstance = HINST_THISDLL;
        psh.hwndParent = hwndStub;
        psh.pszCaption = MAKEINTRESOURCE(IDS_FOLDEROPT_TITLE);
        psh.phpage = rPages;

        AddPropSheetCLSID(CLSID_ShellFldSetExt, &psh);
        AddPropSheetCLSID(CLSID_FileTypes, &psh);
        AddPropSheetCLSID(CLSID_OfflineFilesOptions, &psh);

        // Display the property sheet.
        PropertySheet(&psh);
    }
    else
    {
        SHRestrictedMessageBox(hwndStub);
    }

    // Clean up stub window.
    DestroyWindow(hwndStub);

    return 0;
}

BOOL CALLBACK FindFolderOptionsEnumProc(HWND hwnd, LPARAM lParam)
{
    BOOL fRet = TRUE;
    HWND *phwnd = (HWND *)lParam;
    TCHAR szClass[MAX_PATH];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

    if (lstrcmp(szClass, SZ_FOLDEROPTSTUBCLASS) == 0)
    {
        *phwnd = hwnd;
        fRet = FALSE;
    }

    return fRet;
}

void DoGlobalFolderOptions(void)
{
    HWND hwnd = NULL;
    
    EnumWindows(FindFolderOptionsEnumProc, (LPARAM)&hwnd);

    if (hwnd)
    {
        hwnd = GetLastActivePopup(hwnd);
        if (hwnd && IsWindow(hwnd))
        {
            SetForegroundWindow(hwnd);
        }
    }
    else
    {
        SHCreateThread(GlobalFolderOptPropSheetThreadProc, NULL, CTF_COINIT, NULL);
    }
}

// Public entry point for asking Explorer to launch Options stuff

STDAPI_(void) Options_RunDLLA(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    PostMessage(GetShellWindow(), CWM_SHOWFOLDEROPT, StrToIntA(pszCmdLine), (LPARAM)0);
}

STDAPI_(void) Options_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    PostMessage(GetShellWindow(), CWM_SHOWFOLDEROPT,  StrToIntW(pszCmdLine), (LPARAM)0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\shellprv.h ===
#include "..\shellprv.h"

#define  TF_QISTUB   0x00800000
#ifdef DEBUG
#include "dbutil.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\shfvocx.cpp ===
#include "stdafx.h"
#pragma hdrstop

class CShellFolderViewOC;

class CDViewEvents : public DShellFolderViewEvents
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo,LCID lcid,ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID *rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
              DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,UINT *puArgErr);

    CDViewEvents(CShellFolderViewOC * psfvOC) { _psfvOC = psfvOC; };
    ~CDViewEvents() {};

protected:
    CShellFolderViewOC * _psfvOC;
};

class ATL_NO_VTABLE CShellFolderViewOC
                    : public CComObjectRootEx<CComSingleThreadModel>
                    , public CComCoClass<CShellFolderViewOC, &CLSID_ShellFolderViewOC>
                    , public IDispatchImpl<IFolderViewOC, &IID_IFolderViewOC, &LIBID_Shell32>
                    , public IProvideClassInfo2Impl<&CLSID_ShellFolderView, NULL, &LIBID_Shell32>
                    , public IObjectSafetyImpl<CShellFolderViewOC, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
                    , public IConnectionPointContainerImpl<CShellFolderViewOC>
                    , public IConnectionPointImpl<CShellFolderViewOC, &DIID_DShellFolderViewEvents>
                    , public CComControl<CShellFolderViewOC>
                    , public IPersistStreamInitImpl<CShellFolderViewOC>
                    , public IOleControlImpl<CShellFolderViewOC>
                    , public IOleObjectImpl<CShellFolderViewOC>
                    , public IOleInPlaceActiveObjectImpl<CShellFolderViewOC>
                    , public IOleInPlaceObjectWindowlessImpl<CShellFolderViewOC>
                    , public ICommDlgBrowser
{
public:
    DECLARE_NO_REGISTRY();

BEGIN_COM_MAP(CShellFolderViewOC)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IFolderViewOC)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CShellFolderViewOC)
    CONNECTION_POINT_ENTRY(DIID_DShellFolderViewEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CShellFolderViewOC)
    MESSAGE_HANDLER(WM_DESTROY, _ReleaseForwarderMessage) 
END_MSG_MAP()

BEGIN_PROPERTY_MAP(CShellFolderViewOC)
END_PROPERTY_MAP()

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * phwnd) {return IOleInPlaceActiveObjectImpl<CShellFolderViewOC>::GetWindow(phwnd);};
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return IOleInPlaceActiveObjectImpl<CShellFolderViewOC>::ContextSensitiveHelp(fEnterMode); };

    // IOleInPlaceObject
    STDMETHODIMP InPlaceDeactivate(void) {return IOleInPlaceObject_InPlaceDeactivate();};
    STDMETHODIMP UIDeactivate(void) { return IOleInPlaceObject_UIDeactivate(); };
    STDMETHODIMP SetObjectRects(LPCRECT prcPosRect, LPCRECT prcClipRect) { return IOleInPlaceObject_SetObjectRects(prcPosRect, prcClipRect); };
    STDMETHODIMP ReactivateAndUndo(void)  { return E_NOTIMPL; };

    // IObjectWithSite overrides
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // IFolderViewOC
    STDMETHODIMP SetFolderView(IDispatch *pDisp);

    // IShellBrowser (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR pszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG pmsg, WORD wID);

    // IShellBrowser
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode, IStream **pStrm);
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND *phwnd);
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView)(THIS_ IShellView **ppshv);
    STDMETHOD(OnViewWindowActive)(THIS_ IShellView *pshv);
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON pButtons, UINT nButtons, UINT uFlags);

    // ICommDlgBrowser
    STDMETHOD(OnDefaultCommand) (THIS_ IShellView *psv);
    STDMETHOD(OnStateChange) (THIS_ IShellView *psv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ IShellView *psv, LPCITEMIDLIST pItem);

    friend class CDViewEvents;

protected:
    CShellFolderViewOC();
    ~CShellFolderViewOC();

private:
    HRESULT _SetupForwarder(void);
    void    _ReleaseForwarder(void);
    LRESULT _ReleaseForwarderMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);

    IDispatch    *_pFolderView;  // Hold onto ShellFolderView IDispatch
    DWORD        _dwViewEventsCookie;       // Have we installed _dViewEvents in browser?
    CDViewEvents _dViewEvents;
};

CShellFolderViewOC::CShellFolderViewOC() : 
    _dwViewEventsCookie(0), _pFolderView(NULL), _dViewEvents(this)
{
}

CShellFolderViewOC::~CShellFolderViewOC()
{
    ATOMICRELEASE(_pFolderView);
}

// IShellBrowser (same as IOleInPlaceFrame)
STDMETHODIMP CShellFolderViewOC::InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pMenuWidths)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::RemoveMenusSB(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::SetStatusTextSB(LPCOLESTR pwch)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::EnableModelessSB(BOOL fEnable)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::TranslateAcceleratorSB(LPMSG pmsg, WORD wID)
{
    return S_FALSE;
}

// IShellBrowser
STDMETHODIMP CShellFolderViewOC::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::GetViewStateStream(DWORD grfMode, IStream **pStrm)
{
    *pStrm = NULL;
    return  E_FAIL;
}

STDMETHODIMP CShellFolderViewOC::GetControlWindow(UINT id, HWND *phwnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::QueryActiveShellView(IShellView **ppsv)
{
    *ppsv = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CShellFolderViewOC::OnViewWindowActive(IShellView *psv)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::SetToolbarItems(LPTBBUTTON pButtons, UINT nButtons, UINT uFlags)
{
    return S_OK;
}


STDMETHODIMP CShellFolderViewOC::OnDefaultCommand(IShellView *psv)
{
    return S_FALSE;   // we did not handle it
}

STDMETHODIMP CShellFolderViewOC::OnStateChange(IShellView *psv, ULONG uChange)
{
    switch (uChange)
    {
    case CDBOSC_SETFOCUS:
        break;
    case CDBOSC_KILLFOCUS:
        break;
    case CDBOSC_SELCHANGE:
        break;
    case CDBOSC_RENAME:
        break;
    default:
        return E_NOTIMPL;
    }
    
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::IncludeObject(IShellView *psv, LPCITEMIDLIST pidl)
{
    return S_OK;
}


// IFolderViewOC

HRESULT CShellFolderViewOC::SetFolderView(IDispatch *pDisp)
{
    HRESULT hr = S_OK;

    _ReleaseForwarder();    // cleanup previous state

    IUnknown_Set((IUnknown **)&_pFolderView, pDisp);
    if (_pFolderView)
        hr = _SetupForwarder();

    return hr;
}


STDMETHODIMP CShellFolderViewOC::SetClientSite(IOleClientSite *pClientSite)
{
    return IOleObjectImpl<CShellFolderViewOC>::SetClientSite(pClientSite);
}


HRESULT CShellFolderViewOC::_SetupForwarder()
{
    return ConnectToConnectionPoint(SAFECAST(&_dViewEvents, IDispatch *), DIID_DShellFolderViewEvents, TRUE, _pFolderView, &_dwViewEventsCookie, NULL);
}


void CShellFolderViewOC::_ReleaseForwarder()
{
    ConnectToConnectionPoint(NULL, DIID_DShellFolderViewEvents, FALSE, _pFolderView, &_dwViewEventsCookie, NULL);
}


// ATL maintainence functions
LRESULT CShellFolderViewOC::_ReleaseForwarderMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    bHandled = FALSE;
    _ReleaseForwarder();
    return 0;
}

STDMETHODIMP CDViewEvents::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI2(CDViewEvents, DIID_DShellFolderViewEvents, DShellFolderViewEvents),
        QITABENTMULTI(CDViewEvents, IDispatch, DShellFolderViewEvents),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CDViewEvents::AddRef()
{
    return SAFECAST(_psfvOC, IFolderViewOC*)->AddRef();
}

ULONG CDViewEvents::Release()
{
    return SAFECAST(_psfvOC, IFolderViewOC*)->Release();
}

STDMETHODIMP CDViewEvents::GetTypeInfoCount(UINT * pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDViewEvents::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDViewEvents::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, 
                                         UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDViewEvents::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                  DISPPARAMS *pdispparams, VARIANT *pvarResult, 
                                  EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    SHINVOKEPARAMS inv;
    inv.flags = 0;
    inv.dispidMember = dispidMember;
    inv.piid = &riid;
    inv.lcid = lcid;
    inv.wFlags = wFlags;
    inv.pdispparams = pdispparams;
    inv.pvarResult = pvarResult;
    inv.pexcepinfo = pexcepinfo;
    inv.puArgErr = puArgErr;

    return IUnknown_CPContainerInvokeIndirect(SAFECAST(_psfvOC, IFolderViewOC *), DIID_DShellFolderViewEvents, &inv);
}

STDAPI CShellFolderViewOC_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    return CComCreator< CComObject< CShellFolderViewOC > >::CreateInstance((void *)punkOuter, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\schedule.h ===
#ifndef _SCHEDULE_H
#define _SCHEDULE_H

#ifdef __cplusplus
extern "C" {
#endif

void CShellTaskScheduler_CreateThreadPool( void );
void CShellTaskScheduler_FreeThreadPool( void );

// global function for allocating a task scheduler.
// any object that uses it must make sure that its tasks are removed from the queue
// before it exits.
HRESULT SHGetSystemScheduler( LPSHELLTASKSCHEDULER * ppScheduler );
HRESULT SHFreeSystemScheduler( void );

#ifdef DEBUG
VOID SHValidateEmptySystemScheduler(void);
#else
#define SHValidateEmptySystemScheduler()
#endif

#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\srccpp.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

!include $(CCSHELL_DIR)\shell32\shell32.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shell32\shell32.inc

NO_BROWSER_FILE = 1

TARGETNAME      = unicpp
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = \
                  ..\adjust.cpp   \
                  ..\admoveri.cpp \
                  ..\advanced.cpp \
                  ..\colorctrl.cpp \
                  ..\cpymovto.cpp \
                  ..\dback.cpp    \
                  ..\dbackp.cpp   \
                  ..\dcomp.cpp    \
                  ..\dcompp.cpp   \
                  ..\dde.cpp      \
                  ..\deskcls.cpp  \
                  ..\deskhtml.cpp \
                  ..\deskmovr.cpp \
                  ..\deskstat.cpp \
                  ..\desktop.cpp  \
                  ..\dsubscri.cpp \
                  ..\dvoc.cpp     \
                  ..\dvutil.cpp   \
                  ..\dutil.cpp    \
                  ..\dvutil.cpp   \
                  ..\fldoppsx.cpp \
                  ..\libx.cpp     \
                  ..\mimeflt.cpp  \
                  ..\options.cpp  \
                  ..\propbag.cpp  \
                  ..\sendto.cpp   \
                  ..\shfvocx.cpp  \
                  ..\startmnu.cpp \
                  ..\utils.cpp    \


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\winnt\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\sendto.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <oleacc.h>     // MSAAMENUINFO stuff
#include <runtask.h>
#include "datautil.h"
#include "idlcomm.h"
#include "stgutil.h"
#include <winnls.h>
#include "filetbl.h"
#include "cdburn.h"
#include "mtpt.h"

#ifndef CMF_DVFILE
#define CMF_DVFILE       0x00010000     // "File" pulldown
#endif

class CSendToMenu : public IContextMenu3, IShellExtInit, IOleWindow
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    // IOleWindow
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode) {return E_NOTIMPL;};

private:    
    CSendToMenu();
    ~CSendToMenu();

    LONG    _cRef;
    HMENU   _hmenu;
    UINT    _idCmdFirst;
    BOOL    _bFirstTime;
    HWND    _hwnd;
    IDataObject *_pdtobj;
    LPITEMIDLIST _pidlLast;

    DWORD _GetKeyState(void);
    HRESULT _DoDragDrop(HWND hwndParent, IDropTarget *pdrop);
    BOOL _CanDrop(IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _MenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _RemovableDrivesMenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl);
    static HRESULT CALLBACK s_MenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl);
    static HRESULT CALLBACK s_RemovableDrivesMenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl);
    
    friend HRESULT CSendToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);
};

CSendToMenu::CSendToMenu() : _cRef(1) 
{
    DllAddRef();
}

CSendToMenu::~CSendToMenu()
{
    if (_hmenu)
        FileMenu_DeleteAllItems(_hmenu);
    
    if (_pdtobj)
        _pdtobj->Release();

    ILFree(_pidlLast);
    DllRelease();
}

HRESULT CSendToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSendToMenu *pstm = new CSendToMenu();
    if (pstm) 
    {
        hr = pstm->QueryInterface(riid, ppvOut);
        pstm->Release();
    }
    return hr;
}

HRESULT CSendToMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSendToMenu, IShellExtInit),                     // IID_IShellExtInit
        QITABENT(CSendToMenu, IOleWindow),                        // IID_IOleWindow
        QITABENT(CSendToMenu, IContextMenu3),                     // IID_IContextMenu3
        QITABENTMULTI(CSendToMenu, IContextMenu2, IContextMenu3), // IID_IContextMenu2
        QITABENTMULTI(CSendToMenu, IContextMenu, IContextMenu3),  // IID_IContextMenu
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CSendToMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CSendToMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CSendToMenu::GetWindow(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;

    if (phwnd)
    {
        *phwnd = _hwnd;
        hr = S_OK;
    }

    return hr;
}

HRESULT CSendToMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    // if they want the default menu only (CMF_DEFAULTONLY) OR 
    // this is being called for a shortcut (CMF_VERBSONLY)
    // we don't want to be on the context menu
    
    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return S_OK;
    
    UINT idMax = idCmdFirst;
    
    _hmenu = CreatePopupMenu();
    if (_hmenu)
    {
        TCHAR szSendLinkTo[80];
        TCHAR szSendPageTo[80];
        MENUITEMINFO mii;
        
        // add a dummy item so we are identified at WM_INITMENUPOPUP time
        
        LoadString(g_hinst, IDS_SENDLINKTO, szSendLinkTo, ARRAYSIZE(szSendLinkTo));
        LoadString(g_hinst, IDS_SENDPAGETO, szSendPageTo, ARRAYSIZE(szSendPageTo));
        
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szSendLinkTo;
        mii.wID = idCmdFirst + 1;
        
        if (InsertMenuItem(_hmenu, 0, TRUE, &mii))
        {
            _idCmdFirst = idCmdFirst + 1;   // remember this for later
            
            mii.fType = MFT_STRING;
            mii.dwTypeData = szSendLinkTo;
            mii.wID = idCmdFirst;
            mii.fState = MF_DISABLED | MF_GRAYED;
            mii.fMask = MIIM_TYPE | MIIM_SUBMENU | MIIM_ID;
            mii.hSubMenu = _hmenu;
            
            if (InsertMenuItem(hmenu, indexMenu, TRUE, &mii))
            {
                idMax += 0x40;      // reserve space for this many items
                _bFirstTime = TRUE; // fill this at WM_INITMENUPOPUP time
            }
            else
            {
                _hmenu = NULL;
            }
        }
    }
    _hmenu = NULL;
    return ResultFromShort(idMax - idCmdFirst);
}

DWORD CSendToMenu::_GetKeyState(void)
{
    DWORD grfKeyState = MK_LBUTTON; // default

    if (GetAsyncKeyState(VK_CONTROL) < 0)
        grfKeyState |= MK_CONTROL;

    if (GetAsyncKeyState(VK_SHIFT) < 0)
        grfKeyState |= MK_SHIFT;

    if (GetAsyncKeyState(VK_MENU) < 0)
        grfKeyState |= MK_ALT;          // menu's don't really allow this
    
    return grfKeyState;
}

HRESULT CSendToMenu::_DoDragDrop(HWND hwndParent, IDropTarget *pdrop)
{

    DWORD grfKeyState = _GetKeyState();
    if (grfKeyState == MK_LBUTTON)
    {
        // no modifieres, change default to COPY
        grfKeyState = MK_LBUTTON | MK_CONTROL;
        DataObj_SetDWORD(_pdtobj, g_cfPreferredDropEffect, DROPEFFECT_COPY);
    }

    _hwnd = hwndParent;
    IUnknown_SetSite(pdrop, SAFECAST(this, IOleWindow *));  // Let them have access to our HWND.
    HRESULT hr = SHSimulateDrop(pdrop, _pdtobj, grfKeyState, NULL, NULL);
    IUnknown_SetSite(pdrop, NULL);

    if (hr == S_FALSE)
    {
        ShellMessageBox(g_hinst, hwndParent, 
                        MAKEINTRESOURCE(IDS_SENDTO_ERRORMSG),
                        MAKEINTRESOURCE(IDS_CABINET), 
                        MB_OK|MB_ICONEXCLAMATION);
    }                    
    return hr;
}

HRESULT CSendToMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;
    
    if (_pdtobj && _pidlLast)
    {
        IDropTarget *pdrop;
        hr = SHGetUIObjectFromFullPIDL(_pidlLast, pici->hwnd, IID_PPV_ARG(IDropTarget, &pdrop));
        if (SUCCEEDED(hr))
        {
            hr = _DoDragDrop(pici->hwnd, pdrop);
            pdrop->Release();
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

HRESULT CSendToMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

HRESULT CSendToMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

BOOL CSendToMenu::_CanDrop(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL fCanDrop = FALSE;
    IDropTarget *pdt;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidl, IID_X_PPV_ARG(IDropTarget, 0, &pdt))))
    {
        POINTL pt = {0};
        DWORD dwEffect = DROPEFFECT_COPY;

        // Do a drag enter, if they return no drop effect then we can't drop
        if (SUCCEEDED(pdt->DragEnter(_pdtobj, _GetKeyState(), pt, &dwEffect)))
        {
            if (dwEffect != DROPEFFECT_NONE)
                fCanDrop = TRUE;  // show it!
            pdt->DragLeave();        
        }
        pdt->Release();
    }
    return fCanDrop;
}

HRESULT CSendToMenu::_MenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    switch (fmm)
    {
    case FMM_ADD:
        hr = _CanDrop(psf, pidl) ? S_OK : S_FALSE;
        break;

    case FMM_SETLASTPIDL:
        Pidl_Set(&_pidlLast, pidl);
        break;

    default:
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CSendToMenu::_RemovableDrivesMenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    switch (fmm)
    {
    case FMM_ADD:
        hr = S_FALSE; // assume we wont show it
        if (_CanDrop(psf, pidl))
        {
            // now we know it's a removable drive.  in general we dont want to display cd-rom drives.
            // we know this is the my computer folder so just get the parsing name, we need it for GetDriveType.
            WCHAR szDrive[MAX_PATH];
            if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szDrive, ARRAYSIZE(szDrive))))
            {
                CMountPoint *pmtpt = CMountPoint::GetMountPoint(szDrive);
                if (pmtpt)
                {
                    if (pmtpt->IsCDROM())
                    {
                        // of all cdroms, only the enabled burning folder is okay to put on sendto
                        WCHAR szRecorder[4];
                        if (SUCCEEDED(CDBurn_GetRecorderDriveLetter(szRecorder, ARRAYSIZE(szRecorder))) &&
                            (lstrcmpiW(szRecorder, szDrive) == 0))
                        {
                            hr = S_OK;
                        }
                    }
                    else if (pmtpt->IsFloppy() || pmtpt->IsStrictRemovable() || pmtpt->IsRemovableDevice())
                    {
                        // also put on removable devices.
                        hr = S_OK;
                    }
                    pmtpt->Release();
                }
                else
                {
                    // if this failed it could be a memory condition but its more likely to be that the
                    // parsing name doesnt map to a mountpoint.  in that case fall back to SFGAO_REMOVABLE
                    // to pick up portable audio devices.  if this was because of lowmem its no biggie.
                    if (SHGetAttributes(psf, pidl, SFGAO_REMOVABLE))
                    {
                        hr = S_OK;
                    }
                }
            }
        }
        break;

    case FMM_SETLASTPIDL:
        Pidl_Set(&_pidlLast, pidl);
        break;

    default:
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CSendToMenu::s_MenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return ((CSendToMenu*)lParam)->_MenuCallback(fmm, psf, pidl);
}

HRESULT CSendToMenu::s_RemovableDrivesMenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return ((CSendToMenu*)lParam)->_RemovableDrivesMenuCallback(fmm, psf, pidl);
}

HRESULT GetFolder(int csidl, IShellFolder **ppsf)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, ppsf));
        ILFree(pidl);
    }
    return hr;
}

HRESULT CSendToMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_OK;
    LRESULT lRes = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        if (_bFirstTime)
        {
            _bFirstTime = FALSE;
            
            //In case of Shell_MergeMenus
            if (_hmenu == NULL)
                _hmenu = (HMENU)wParam;

            // delete the dummy entry
            DeleteMenu(_hmenu, 0, MF_BYPOSITION);

            FMCOMPOSE fmc = {0};
            if (SUCCEEDED(GetFolder(CSIDL_SENDTO, &fmc.psf)))
            {
                fmc.idCmd = _idCmdFirst;
                fmc.grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
                fmc.pfnCallback = s_MenuCallback;
                fmc.lParam = (LPARAM)this;              // not reference counted
                                    
                FileMenu_Compose(_hmenu, FMCM_REPLACE, &fmc);                    
                fmc.psf->Release();
            }
            if (SUCCEEDED(GetFolder(CSIDL_DRIVES, &fmc.psf)))
            {
                fmc.dwMask = FMC_NOEXPAND;
                fmc.idCmd = _idCmdFirst;
                fmc.grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
                fmc.pfnCallback = s_RemovableDrivesMenuCallback;
                fmc.lParam = (LPARAM)this;              // not reference counted
                                    
                FileMenu_Compose(_hmenu, FMCM_APPEND, &fmc);                    
                fmc.psf->Release();
            }
        }
        else if (_hmenu != (HMENU)wParam)
        {
            // secondary cascade menu
            FileMenu_InitMenuPopup((HMENU)wParam);
        }
        break;
        
    case WM_DRAWITEM:
        {
            DRAWITEMSTRUCT *pdi = (DRAWITEMSTRUCT *)lParam;
            
            if (pdi->CtlType == ODT_MENU && pdi->itemID == _idCmdFirst) 
            {
                lRes = FileMenu_DrawItem(NULL, pdi);
            }
        }
        break;
        
    case WM_MEASUREITEM:
        {
            MEASUREITEMSTRUCT *pmi = (MEASUREITEMSTRUCT *)lParam;
            
            if (pmi->CtlType == ODT_MENU && pmi->itemID == _idCmdFirst) 
            {
                lRes = FileMenu_MeasureItem(NULL, pmi);
            }
        }
        break;

    case WM_MENUCHAR:
        {
            TCHAR ch = (TCHAR)LOWORD(wParam);
            HMENU hmenu = (HMENU)lParam;
            lRes = FileMenu_HandleMenuChar(hmenu, ch);
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plResult)
        *plResult = lRes;

    return hr;
}

HRESULT CSendToMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}


#define CXIMAGEGAP  6

//This is included by shell32/shellprv.h I'm not sure where this is in shdocvw
#define CCH_KEYMAX  64

typedef struct 
{
    // Accessibility info must be first
    MSAAMENUINFO msaa;
    TCHAR chPrefix;
    TCHAR szMenuText[CCH_KEYMAX];
    TCHAR szExt[MAX_PATH];
    TCHAR szClass[CCH_KEYMAX];
    DWORD dwFlags;
    int iImage;
    TCHAR szUserFile[CCH_KEYMAX];
} NEWOBJECTINFO;

typedef struct 
{
    int type;
    void *lpData;
    DWORD cbData;
    HKEY hkeyNew;
} NEWFILEINFO;

typedef struct 
{
    ULONG       cbStruct;
    ULONG       ver;
    SYSTEMTIME  lastupdate;
} SHELLNEW_CACHE_STAMP;

// ShellNew config flags
#define SNCF_DEFAULT    0x0000
#define SNCF_NOEXT      0x0001
#define SNCF_USERFILES  0x0002

#define NEWTYPE_DATA    0x0003
#define NEWTYPE_FILE    0x0004
#define NEWTYPE_NULL    0x0005
#define NEWTYPE_COMMAND 0x0006
#define NEWTYPE_FOLDER  0x0007
#define NEWTYPE_LINK    0x0008

#define NEWITEM_FOLDER  0
#define NEWITEM_LINK    1
#define NEWITEM_MAX     2

class CNewMenu : public CObjectWithSite,
                 public IContextMenu3, 
                 public IShellExtInit
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);
    
    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
   
    LONG            _cRef;
    HMENU           _hmenu;
    UINT            _idCmdFirst;
    HIMAGELIST      _himlSystemImageList;
    IDataObject    *_pdtobj;
    LPITEMIDLIST    _pidlFolder;
    POINT           _ptNewItem;     // from the view, point of click
    NEWOBJECTINFO  *_pnoiLast;
    HDPA            _hdpaMenuInfo;
    
    CNewMenu();
    ~CNewMenu();
    
    friend HRESULT CNewMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);

private:
    //Handle Menu messages submitted to HandleMenuMsg
    BOOL DrawItem(DRAWITEMSTRUCT *lpdi);
    LRESULT MeasureItem(MEASUREITEMSTRUCT *pmi);
    BOOL InitMenuPopup(HMENU hMenu);
    
    //Internal Helpers
    NEWOBJECTINFO *GetItemData(HMENU hmenu, UINT iItem);
    HRESULT RunCommand(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszRun);
    HRESULT CopyTemplate(IStream *pStream, NEWFILEINFO *pnfi);

    // Generates it from the Fragment and _pidlFolder
    BOOL _GeneratePidlFromName(LPTSTR pszName, LPITEMIDLIST* ppidl);
    HRESULT _GetItemName(IUnknown *punkFolder, LPWSTR pszItemName, LPWSTR pszPath, UINT cchPath);

    HRESULT _MatchMenuItem(TCHAR ch, LRESULT* plRes);
    BOOL _InsertNewMenuItem(HMENU hmenu, UINT idCmd, NEWOBJECTINFO *pnoiClone);
    
    HRESULT ConsolidateMenuItems(BOOL bForce);

    HANDLE _hMutex, _hEvent;
};

void GetConfigFlags(HKEY hkey, DWORD * pdwFlags)
{
    TCHAR szTemp[MAX_PATH];
    DWORD cbData = ARRAYSIZE(szTemp);
    
    *pdwFlags = SNCF_DEFAULT;
    
    if (SHQueryValueEx(hkey, TEXT("NoExtension"), 0, NULL, (BYTE *)szTemp, &cbData) == ERROR_SUCCESS) 
    {
        *pdwFlags |= SNCF_NOEXT;
    }
}

BOOL GetNewFileInfoForKey(HKEY hkeyExt, NEWFILEINFO *pnfi, DWORD * pdwFlags)
{
    BOOL fRet = FALSE;
    HKEY hKey; // this gets the \\.ext\progid  key
    HKEY hkeyNew;
    TCHAR szProgID[80];
    DWORD cbProgID = sizeof(szProgID);
    
    // open the Newcommand
    if (SHRegGetValue(hkeyExt, NULL, NULL, SRRF_RT_REG_SZ, NULL, szProgID, &cbProgID) != ERROR_SUCCESS)
    {
        return FALSE;
    }
    
    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyExt, szProgID, 0, KEY_QUERY_VALUE, &hKey))
    {
        hKey = hkeyExt;
    }
    
    if (ERROR_SUCCESS == RegOpenKeyEx(hKey, TEXT("ShellNew"), 0, KEY_QUERY_VALUE, &hkeyNew))
    {
        DWORD dwType, cbData;
        TCHAR szTemp[MAX_PATH];
        HKEY hkeyConfig;
        
        // Are there any config flags?
        if (pdwFlags)
        {
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyNew, TEXT("Config"), 0, KEY_QUERY_VALUE, &hkeyConfig))
            {
                GetConfigFlags(hkeyConfig, pdwFlags);
                RegCloseKey(hkeyConfig);
            }
            else
            {
                *pdwFlags = 0;
            }
        }
        
        if (cbData = sizeof(szTemp), (SHQueryValueEx(hkeyNew, TEXT("FileName"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS) 
            && ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))) 
        {
            fRet = TRUE;
            if (pnfi)
            {
                pnfi->type = NEWTYPE_FILE;
                pnfi->hkeyNew = hkeyNew; // store this away so we can find out which one held the file easily
                ASSERT((LPTSTR*)pnfi->lpData == NULL);
                pnfi->lpData = StrDup(szTemp);
                
                hkeyNew = NULL;
            }
        } 
        else if (cbData = sizeof(szTemp), (SHQueryValueEx(hkeyNew, TEXT("command"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS) 
            && ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))) 
        {
            
            fRet = TRUE;
            if (pnfi)
            {
                pnfi->type = NEWTYPE_COMMAND;
                pnfi->hkeyNew = hkeyNew; // store this away so we can find out which one held the command easily
                ASSERT((LPTSTR*)pnfi->lpData == NULL);
                pnfi->lpData = StrDup(szTemp);
                hkeyNew = NULL;
            }
        } 
        else if ((SHQueryValueEx(hkeyNew, TEXT("Data"), 0, &dwType, NULL, &cbData) == ERROR_SUCCESS) && cbData) 
        {
            // yes!  the data for a new file is stored in the registry
            fRet = TRUE;
            // do they want the data?
            if (pnfi)
            {
                pnfi->type = NEWTYPE_DATA;
                pnfi->cbData = cbData;
                pnfi->lpData = (void*)LocalAlloc(LPTR, cbData);
                if (pnfi->lpData)
                {
                    if (dwType == REG_SZ)
                    {
                        //  Get the Unicode data from the registry.
                        LPWSTR pszTemp = (LPWSTR)LocalAlloc(LPTR, cbData);
                        if (pszTemp)
                        {
                            SHQueryValueEx(hkeyNew, TEXT("Data"), 0, &dwType, (LPBYTE)pszTemp, &cbData);
                            
                            pnfi->cbData = SHUnicodeToAnsi(pszTemp, (LPSTR)pnfi->lpData, cbData);
                            if (pnfi->cbData == 0)
                            {
                                LocalFree(pnfi->lpData);
                                pnfi->lpData = NULL;
                            }
                            
                            LocalFree(pszTemp);
                        }
                        else
                        {
                            LocalFree(pnfi->lpData);
                            pnfi->lpData = NULL;
                        }
                    }
                    else
                    {
                        SHQueryValueEx(hkeyNew, TEXT("Data"), 0, &dwType, (BYTE*)pnfi->lpData, &cbData);
                    }
                }
            }
        }
        else if (cbData = sizeof(szTemp), (SHQueryValueEx(hkeyNew, TEXT("NullFile"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS)) 
        {
            fRet = TRUE;
            if (pnfi)
            {
                pnfi->type = NEWTYPE_NULL;
                pnfi->cbData = 0;
                pnfi->lpData = NULL;
            }
        } 
        
        if (hkeyNew)
            RegCloseKey(hkeyNew);
    }
    
    if (hKey != hkeyExt)
    {
        RegCloseKey(hKey);
    }
    return fRet;
}

BOOL GetNewFileInfoForExtension(NEWOBJECTINFO *pnoi, NEWFILEINFO *pnfi, HKEY* phKey, LPINT piIndex)
{
    TCHAR szValue[80];
    DWORD lSize = sizeof(szValue);
    HKEY hkeyNew;
    BOOL fRet = FALSE;;
    
    if (phKey && ((*phKey) == (HKEY)-1))
    {
        // we're done
        return FALSE;
    }
    
    // do the ShellNew key stuff if there's no phKey passed in (which means
    // use the info in pnoi to get THE one) and there's no UserFile specified.
    // 
    // if there IS a UserFile specified, then it's a file, and that szUserFile points to it..
    if (!phKey && !pnoi->szUserFile[0] ||
        (phKey && !*phKey)) 
    {
        // check the new keys under the class id (if any)
        TCHAR szSubKey[128];
        HRESULT hr;

        hr = StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\CLSID"), pnoi->szClass);
        if (SUCCEEDED(hr))
        {
            lSize = sizeof(szValue);
            if (SHRegGetValue(HKEY_CLASSES_ROOT, szSubKey, NULL, SRRF_RT_REG_SZ, NULL, szValue, &lSize) == ERROR_SUCCESS)
            {
                hr = StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s"), szValue);
                if (SUCCEEDED(hr))
                {
                    lSize = sizeof(szValue);
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, KEY_QUERY_VALUE, &hkeyNew))
                    {
                        fRet = GetNewFileInfoForKey(hkeyNew, pnfi, &pnoi->dwFlags);
                        RegCloseKey(hkeyNew);
                    }
                }
            }
        }

        // otherwise check under the type extension... do the extension, not the type
        // so that multi-ext to 1 type will work right
        if (!fRet && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pnoi->szExt, 0, KEY_QUERY_VALUE, &hkeyNew)))
        {
            fRet = GetNewFileInfoForKey(hkeyNew, pnfi, &pnoi->dwFlags);
            RegCloseKey(hkeyNew);
        }
        
        if (phKey)
        {
            // if we're iterating, then we've got to open the key now...
            hr = StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\ShellNew\\FileName"), pnoi->szExt, pnoi->szClass);
            if (SUCCEEDED(hr))
            {
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, KEY_QUERY_VALUE, phKey))
                {
                    *piIndex = 0;

                    // if we didn't find one of the default ones above,
                    // try it now
                    // otherwise just return success or failure on fRet
                    if (!fRet)
                    {
                        goto Iterate;
                    }
                }
                else
                {
                    *phKey = (HKEY)-1;
                }
            }
            else
            {
                *phKey = (HKEY)-1;
            }
        }
    }
    else if (!phKey && pnoi->szUserFile[0])
    {
        // there's no key, so just return info about szUserFile
        pnfi->type = NEWTYPE_FILE;
        pnfi->lpData = StrDup(pnoi->szUserFile);
        pnfi->hkeyNew = NULL;
        
        fRet = TRUE;
    }
    else if (phKey)
    {
        DWORD dwSize;
        DWORD dwData;
        DWORD dwType;
        // we're iterating through...
        
Iterate:
        
        dwSize = ARRAYSIZE(pnoi->szUserFile);
        dwData = ARRAYSIZE(pnoi->szMenuText);
        
        if (RegEnumValue(*phKey, *piIndex, pnoi->szUserFile, &dwSize, NULL,
            &dwType, (LPBYTE)pnoi->szMenuText, &dwData) == ERROR_SUCCESS)
        {
            (*piIndex)++;
            // if there's something more than the null..
            if (dwData <= 1)
            { 
                HRESULT hr = StringCchCopy(pnoi->szMenuText, ARRAYSIZE(pnoi->szMenuText), PathFindFileName(pnoi->szUserFile));
                if (SUCCEEDED(hr))
                {
                    PathRemoveExtension(pnoi->szMenuText);
                }
                else
                {
                    pnoi->szMenuText[0] = TEXT('\0');
                }
            }
            fRet = TRUE;
        }
        else
        {
            RegCloseKey(*phKey);
            *phKey = (HKEY)-1;
            fRet = FALSE;
        }
    }
    
    return fRet;
}

#define SHELLNEW_CONSOLIDATION_MUTEX TEXT("ShellNewConsolidationMutex")
#define SHELLNEW_CONSOLIDATION_EVENT TEXT("ShellNewConsolidationEvent")

CNewMenu::CNewMenu() :
    _cRef(1),
    _hMutex(CreateMutex(NULL, FALSE, SHELLNEW_CONSOLIDATION_MUTEX)),
    _hEvent(CreateEvent(NULL, FALSE, FALSE, SHELLNEW_CONSOLIDATION_EVENT))
{
    DllAddRef();
    ASSERT(_pnoiLast == NULL);
}

CNewMenu::~CNewMenu()
{
    if (_hdpaMenuInfo)
    {
        // we dont own the lifetime of _hmenu, and it gets destroyed before the destructor
        // is called.  thus maintain the lifetime of our NEWOBJECTINFO data in a dpa.
        for (int i = 0; i < DPA_GetPtrCount(_hdpaMenuInfo); i++)
        {
            NEWOBJECTINFO *pNewObjInfo = (NEWOBJECTINFO *)DPA_GetPtr(_hdpaMenuInfo, i);
            LocalFree(pNewObjInfo);
        }
        DPA_Destroy(_hdpaMenuInfo);
    }
    
    ILFree(_pidlFolder);

    if (_pdtobj)
        _pdtobj->Release();

    if (_hMutex)
    {
        CloseHandle(_hMutex);
    }
    if (_hEvent)
    {
        CloseHandle(_hEvent);
    }

    DllRelease();
}

HRESULT CNewMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    // aggregation checking is handled in class factory
    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CNewMenu * pShellNew = new CNewMenu();
    if (pShellNew) 
    {
        if (!pShellNew->_hMutex || !pShellNew->_hEvent)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pShellNew->QueryInterface(riid, ppvOut);
        }
        pShellNew->Release();
    }

    return hr;
}

HRESULT CNewMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CNewMenu, IShellExtInit),                     // IID_IShellExtInit
        QITABENT(CNewMenu, IContextMenu3),                     // IID_IContextMenu3
        QITABENTMULTI(CNewMenu, IContextMenu2, IContextMenu3), // IID_IContextMenu2
        QITABENTMULTI(CNewMenu, IContextMenu, IContextMenu3),  // IID_IContextMenu
        QITABENT(CNewMenu, IObjectWithSite),                   // IID_IObjectWithSite
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CNewMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CNewMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CNewMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    // if they want the default menu only (CMF_DEFAULTONLY) OR 
    // this is being called for a shortcut (CMF_VERBSONLY)
    // we don't want to be on the context menu
    MENUITEMINFO mfi = {0};
    
    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return S_OK;
    
    ConsolidateMenuItems(FALSE);

    _idCmdFirst = idCmdFirst+2;
    TCHAR szNewMenu[80];
    LoadString(g_hinst, IDS_NEWMENU, szNewMenu, ARRAYSIZE(szNewMenu));

    // HACK: I assume that they are querying during a WM_INITMENUPOPUP or equivalent
    GetCursorPos(&_ptNewItem);
    
    _hmenu = CreatePopupMenu();
    mfi.cbSize = sizeof(MENUITEMINFO);
    mfi.fMask = MIIM_ID | MIIM_TYPE;
    mfi.wID = idCmdFirst+1;
    mfi.fType = MFT_STRING;
    mfi.dwTypeData = szNewMenu;
    
    InsertMenuItem(_hmenu, 0, TRUE, &mfi);
    
    ZeroMemory(&mfi, sizeof (mfi));
    mfi.cbSize = sizeof(MENUITEMINFO);
    mfi.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_DATA;
    mfi.fType = MFT_STRING;
    mfi.wID = idCmdFirst;
    mfi.hSubMenu = _hmenu;
    mfi.dwTypeData = szNewMenu;
    mfi.dwItemData = 0;
    
    InsertMenuItem(hmenu, indexMenu, TRUE, &mfi);

    _hmenu = NULL;
    return ResultFromShort(_idCmdFirst - idCmdFirst + 1);
}

// This is almost the same as ILCreatePidlFromPath, but
// uses only the filename from the full path pszPath and
// the _pidlFolder to generate the pidl. This is used because
// when creating an item in Desktop\My Documents, it used to create a
// full pidl c:\documents and Settings\lamadio\My Documents\New folder
// instead of the pidl desktop\my documents\New Folder.
BOOL CNewMenu::_GeneratePidlFromName(LPTSTR pszFile, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;  // Out param

    IShellFolder* psf;
    if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, _pidlFolder, &psf))))
    {
        LPITEMIDLIST pidlItem;

        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, pszFile, NULL, &pidlItem, NULL)))
        {
            *ppidl = ILCombine(_pidlFolder, pidlItem);
            ILFree(pidlItem);
        }

        psf->Release();
    }

    return BOOLFROMPTR(*ppidl);
}

HRESULT CNewMenu::_GetItemName(IUnknown *punkFolder, LPWSTR pszItemName, LPWSTR pszPath, UINT cchPath)
{
    // we need to pick up the name by asking the folder about the item,
    // not by pathappending to the folder's path.
    IShellFolder *psf;
    HRESULT hr = punkFolder->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFile;
        hr = psf->ParseDisplayName(NULL, NULL, pszItemName, NULL, &pidlFile, NULL);
        if (SUCCEEDED(hr))
        {
            hr = DisplayNameOf(psf, pidlFile, SHGDN_FORPARSING, pszPath, cchPath);
            ILFree(pidlFile);
        }
        psf->Release();
    }
    return hr;
}

const ICIVERBTOIDMAP c_IDMap[] =
{
    { L"NewFolder", "NewFolder", NEWITEM_FOLDER, NEWITEM_FOLDER, },
    { L"link",      "link",      NEWITEM_LINK,   NEWITEM_LINK,   },
};

HRESULT CNewMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    DWORD dwFlags;

    if (IS_INTRESOURCE(pici->lpVerb) && _pnoiLast)
        dwFlags = _pnoiLast->dwFlags;
    else
    {
        UINT uID;
        if (SUCCEEDED(SHMapICIVerbToCmdID(pici, c_IDMap, ARRAYSIZE(c_IDMap), &uID)))
        {
            switch (uID)
            {
                case NEWITEM_FOLDER:
                    dwFlags = NEWTYPE_FOLDER;
                    break;
                case NEWITEM_LINK:
                    dwFlags = NEWTYPE_LINK;
                    break;
                default:
                    ASSERTMSG(0, "should not get what we don't put on the menu");
                    return E_FAIL;
            }
        }
    }
    
    TCHAR szFileSpec[MAX_PATH+80];   // Add some slop incase we overflow
    TCHAR szTemp[MAX_PATH+80];       // Add some slop incase we overflow

    //See if the pidl is folder shortcut and if so get the target path.
    SHGetTargetFolderPath(_pidlFolder, szTemp, ARRAYSIZE(szTemp));
    BOOL fLFN = IsLFNDrive(szTemp);

    NEWFILEINFO nfi;
    DWORD dwErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    nfi.lpData = NULL;
    nfi.hkeyNew = NULL;

    switch (dwFlags)
    {
    case NEWTYPE_FOLDER:
        LoadString(g_hinst, fLFN ? IDS_FOLDERLONGPLATE : IDS_FOLDERTEMPLATE, szFileSpec, ARRAYSIZE(szFileSpec));
        break;

    case NEWTYPE_LINK:
        LoadString(g_hinst, IDS_NEWLINKTEMPLATE, szFileSpec, ARRAYSIZE(szFileSpec));
        break;

    default:
        LoadString(g_hinst, IDS_NEWFILEPREFIX, szFileSpec, ARRAYSIZE(szFileSpec));

        //
        // If we are running on a mirrored BiDi localized system,
        // then flip the order of concatenation so that the
        // string is read properly for Arabic. [samera]
        //
        if (IS_BIDI_LOCALIZED_SYSTEM())
        {
            StringCchCopy(szTemp, ARRAYSIZE(szTemp), szFileSpec);   // ok to truncate, for display only
            StringCchPrintf(szFileSpec, ARRAYSIZE(szFileSpec), TEXT("%s %s"), _pnoiLast->szMenuText, szTemp);   // ok to truncate, for display only
        }
        else
        {
            StringCchCat(szFileSpec, ARRAYSIZE(szFileSpec), _pnoiLast->szMenuText); // ok to truncate, for display only
        }
        SHStripMneumonic(szFileSpec);

        if (!(dwFlags & SNCF_NOEXT))
        {
            StringCchCat(szFileSpec, ARRAYSIZE(szFileSpec), _pnoiLast->szExt);  // ok to truncate, for display only
        }
        break;
    }

    BOOL fCreateStorage = (dwFlags == NEWTYPE_FOLDER);

    //See if the pidl is folder shortcut and if so get the target pidl.
    LPITEMIDLIST pidlTarget;
    hr = SHGetTargetFolderIDList(_pidlFolder, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        IStorage * pStorage;
        hr = StgBindToObject(pidlTarget, STGM_READWRITE, IID_PPV_ARG(IStorage, &pStorage));
        if (SUCCEEDED(hr))
        {
            IStream *pStreamCreated = NULL;
            IStorage *pStorageCreated = NULL;

            STATSTG statstg = { 0 };
            if (fCreateStorage)
            {
                hr = StgMakeUniqueName(pStorage, szFileSpec, IID_PPV_ARG(IStorage, &pStorageCreated));
                if (SUCCEEDED(hr))
                    pStorageCreated->Stat(&statstg, STATFLAG_DEFAULT);
            }
            else
            {
                hr = StgMakeUniqueName(pStorage, szFileSpec, IID_PPV_ARG(IStream, &pStreamCreated));
                if (SUCCEEDED(hr))
                    pStreamCreated->Stat(&statstg, STATFLAG_DEFAULT);
            }

            if (SUCCEEDED(hr))
            {
                switch (dwFlags)
                {
                case NEWTYPE_FOLDER:
                    // we're already done.
                    break;

                case NEWTYPE_LINK:
                    if (statstg.pwcsName)
                    {
                        // Lookup Command in Registry under key HKCR/.lnk/ShellNew/Command
                        TCHAR szCommand[MAX_PATH];
                        DWORD dwLength = sizeof(szCommand);
                        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, 
                            TEXT(".lnk\\ShellNew"), TEXT("Command"), NULL, szCommand, &dwLength))
                        {
                            TCHAR szPath[MAX_PATH];
                            hr = _GetItemName(SAFECAST(pStorage, IUnknown*), statstg.pwcsName, szPath, ARRAYSIZE(szPath));
                            if (SUCCEEDED(hr))
                            {
                                hr = RunCommand(pici->hwnd, szPath, szCommand);
                            }
                        }
                    }
                    break;

                default:
                    if (GetNewFileInfoForExtension(_pnoiLast, &nfi, NULL, NULL))
                    {
                        switch (nfi.type) 
                        {
                        case NEWTYPE_FILE:
                            hr = CopyTemplate(pStreamCreated, &nfi);
                            break;

                        case NEWTYPE_NULL:
                            // already created a zero-length file.
                            break;

                        case NEWTYPE_DATA:
                            ULONG ulWritten;
                            hr = pStreamCreated->Write(nfi.lpData, nfi.cbData, &ulWritten);
                            if (SUCCEEDED(hr))
                            {
                                hr = pStreamCreated->Commit(STGC_DEFAULT);
                            }
                            break;

                        case NEWTYPE_COMMAND:
                            if (statstg.pwcsName)
                            {
                                TCHAR szPath[MAX_PATH];
                                hr = _GetItemName(SAFECAST(pStorage, IUnknown*), statstg.pwcsName, szPath, ARRAYSIZE(szPath));
                                if (SUCCEEDED(hr))
                                {
                                    // oops, we already created the stream, but we actually
                                    // just wanted the filename for the RunCommand, so we
                                    // have to delete it first.
                                    ATOMICRELEASE(pStreamCreated);
                                    hr = pStorage->DestroyElement(statstg.pwcsName);
                                    // flush out any notifications from the destroy (the
                                    // destroy causes notifications).
                                    SHChangeNotifyHandleEvents();

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = RunCommand(pici->hwnd, szPath, (LPTSTR)nfi.lpData);
                                        if (hr == S_FALSE)
                                            hr = S_OK;
                                    }
                                }
                            }
                            break;

                        default:
                            hr = E_FAIL;
                            break;
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
                    }
                    break;
                }

                // these have to be released before _GeneratePidlFromName, since that opens
                // the storage in exclusive mode for other reasons.  but we can't release
                // them earlier because CopyTemplate might need them.
                if (pStorageCreated)
                    pStorageCreated->Release();
                if (pStreamCreated)
                    pStreamCreated->Release();
                if (SUCCEEDED(hr))
                    hr = pStorage->Commit(STGC_DEFAULT);
                pStorage->Release();

                LPITEMIDLIST pidlCreatedItem;
                if (SUCCEEDED(hr) &&
                    _GeneratePidlFromName(statstg.pwcsName, &pidlCreatedItem))
                {
                    SHChangeNotifyHandleEvents();
                    IShellView2 *psv2;
                    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellView2, &psv2))))
                    {
                        DWORD dwFlagsSelFlags = SVSI_SELECT | SVSI_POSITIONITEM;

                        if (!(dwFlags & NEWTYPE_LINK))
                            dwFlagsSelFlags |= SVSI_EDIT;

                        psv2->SelectAndPositionItem(ILFindLastID(pidlCreatedItem), dwFlagsSelFlags, NULL);
                        psv2->Release();
                    }
                    ILFree(pidlCreatedItem);
                }

                CoTaskMemFree(statstg.pwcsName);
            }
            else
            {
                pStorage->Release();
            }
        }

        ILFree(pidlTarget);
    }

    if (nfi.lpData)
        LocalFree((HLOCAL)nfi.lpData);
    
    if (nfi.hkeyNew)
        RegCloseKey(nfi.hkeyNew);

    if (FAILED_AND_NOT_CANCELED(hr) && !(pici->fMask & CMIC_MASK_FLAG_NO_UI))
    {
        TCHAR szTitle[MAX_PATH];

        LoadString(g_hinst, (fCreateStorage ? IDS_DIRCREATEFAILED_TITLE : IDS_FILECREATEFAILED_TITLE), szTitle, ARRAYSIZE(szTitle));
        SHSysErrorMessageBox(pici->hwnd, szTitle, fCreateStorage ? IDS_CANNOTCREATEFOLDER : IDS_CANNOTCREATEFILE,
                HRESULT_CODE(hr), szFileSpec, MB_OK | MB_ICONEXCLAMATION);
    }

    SetErrorMode(dwErrorMode);

    return hr;
}

HRESULT CNewMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    switch (uType)
    {
    case GCS_HELPTEXT:
        if (idCmd < NEWITEM_MAX)
        {
            LoadString(g_hinst, (UINT)(IDS_NEWHELP_FIRST + idCmd), (LPTSTR)pszName, cchMax);
            return S_OK;
        }
        break;
    case GCS_HELPTEXTA:
        if (idCmd < NEWITEM_MAX)
        {
            LoadStringA(g_hinst, (UINT)(IDS_NEWHELP_FIRST + idCmd), pszName, cchMax);
            return S_OK;
        }
        break;

    case GCS_VERBW:
    case GCS_VERBA:
        return SHMapCmdIDToVerb(idCmd, c_IDMap, ARRAYSIZE(c_IDMap), pszName, cchMax, (GCS_VERBW == uType));
    }

    return E_NOTIMPL;
}

//Defined in fsmenu.obj
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand);

HRESULT CNewMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

HRESULT CNewMenu::_MatchMenuItem(TCHAR ch, LRESULT* plRes)
{
    // If plRes is NULL we're being called on HandleMenuMsg() which
    // doesn't support returning an LRESULT, which is needed for WM_MENUCHAR...
    if (plRes == NULL)
        return S_FALSE;

    int iLastSelectedItem = -1;
    int iNextMatch = -1;
    BOOL fMoreThanOneMatch = FALSE;
    int c = GetMenuItemCount(_hmenu);

    // Pass 1: Locate the Selected Item
    for (int i = 0; i < c; i++) 
    {
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
        {
            if (mii.fState & MFS_HILITE)
            {
                iLastSelectedItem = i;
                break;
            }
        }
    }

    // Pass 2: Starting from the selected item, locate the first item with the matching name.
    for (i = iLastSelectedItem + 1; i < c; i++) 
    {
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA | MIIM_STATE;
        if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
        {
            NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)mii.dwItemData;
            if (pnoi && _MenuCharMatch(pnoi->szMenuText, ch, FALSE))
            {
                _pnoiLast = pnoi;
                
                if (iNextMatch != -1)
                {
                    fMoreThanOneMatch = TRUE;
                    break;                      // We found all the info we need
                }
                else
                {
                    iNextMatch = i;
                }
            }
        }
    }

    // Pass 3: If we did not find a match, or if there was only one match
    // Search from the first item, to the Selected Item
    if (iNextMatch == -1 || fMoreThanOneMatch == FALSE)
    {
        for (i = 0; i <= iLastSelectedItem; i++) 
        {
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_DATA | MIIM_STATE;
            if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
            {
                NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)mii.dwItemData;
                if (pnoi && _MenuCharMatch(pnoi->szMenuText, ch, FALSE))
                {
                    _pnoiLast = pnoi;
                    if (iNextMatch != -1)
                    {
                        fMoreThanOneMatch = TRUE;
                        break;
                    }
                    else
                    {
                        iNextMatch = i;
                    }
                }
            }
        }
    }

    if (iNextMatch != -1)
    {
        *plRes = MAKELONG(iNextMatch, fMoreThanOneMatch? MNC_SELECT : MNC_EXECUTE);
    }
    else
    {
        *plRes = MAKELONG(0, MNC_IGNORE);
    }

    return S_OK;
}

HRESULT CNewMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *plResult)
{
    HRESULT hr = S_OK;
    LRESULT lRes = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        if (_hmenu == NULL)
        {
            _hmenu = (HMENU)wParam;
        }
        
        InitMenuPopup(_hmenu);
        break;
        
    case WM_DRAWITEM:
        DrawItem((DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_MEASUREITEM:
        lRes = MeasureItem((MEASUREITEMSTRUCT *)lParam);
        break;

    case WM_MENUCHAR:
        hr = _MatchMenuItem((TCHAR)LOWORD(wParam), &lRes);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plResult)
        *plResult = lRes;

    return hr;
}

HRESULT CNewMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    ASSERT(_pidlFolder == NULL);
    _pidlFolder = ILClone(pidlFolder);
   
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

BOOL CNewMenu::DrawItem(DRAWITEMSTRUCT *lpdi)
{
    BOOL fFlatMenu = FALSE;
    BOOL fFrameRect = FALSE;

    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&fFlatMenu, 0);

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        int x, y;
        SIZE sz;
        NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)lpdi->itemData;
        
        // Draw the image (if there is one).
        
        GetTextExtentPoint(lpdi->hDC, pnoi->szMenuText, lstrlen(pnoi->szMenuText), &sz);
        
        if (lpdi->itemState & ODS_SELECTED)
        {
            // REVIEW HACK - keep track of the last selected item.
            _pnoiLast = pnoi;
            if (fFlatMenu)
            {
                fFrameRect = TRUE;
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_MENUHILIGHT));
                SetTextColor(lpdi->hDC, GetSysColor(COLOR_MENUTEXT));
                FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_MENUHILIGHT));
            }
            else
            {
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
            }
        }
        else
        {
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_MENUTEXT));
            FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_MENU));
        }
        
        RECT rc = lpdi->rcItem;
        rc.left += +2*CXIMAGEGAP+g_cxSmIcon;
        
        
        DrawText(lpdi->hDC,pnoi->szMenuText,lstrlen(pnoi->szMenuText),
            &rc,DT_SINGLELINE|DT_VCENTER);
        if (pnoi->iImage != -1)
        {
            x = lpdi->rcItem.left+CXIMAGEGAP;
            y = (lpdi->rcItem.bottom+lpdi->rcItem.top-g_cySmIcon)/2;
            HIMAGELIST himlSmall;
            Shell_GetImageLists(NULL, &himlSmall);
            ImageList_Draw(himlSmall, pnoi->iImage, lpdi->hDC, x, y, ILD_TRANSPARENT);
        } 
        else 
        {
            x = lpdi->rcItem.left+CXIMAGEGAP;
            y = (lpdi->rcItem.bottom+lpdi->rcItem.top-g_cySmIcon)/2;
        }

        if (fFrameRect)
        {
            HBRUSH hbrFill = (HBRUSH)GetSysColorBrush(COLOR_HIGHLIGHT);
            HBRUSH hbrSave = (HBRUSH)SelectObject(lpdi->hDC, hbrFill);
            int x = lpdi->rcItem.left;
            int y = lpdi->rcItem.top;
            int cx = lpdi->rcItem.right - x - 1;
            int cy = lpdi->rcItem.bottom - y - 1;

            PatBlt(lpdi->hDC, x, y, 1, cy, PATCOPY);
            PatBlt(lpdi->hDC, x + 1, y, cx, 1, PATCOPY);
            PatBlt(lpdi->hDC, x, y + cy, cx, 1, PATCOPY);
            PatBlt(lpdi->hDC, x + cx, y + 1, 1, cy, PATCOPY);

            SelectObject(lpdi->hDC, hbrSave);
        }

        return TRUE;
    }

    return FALSE;
}

LRESULT CNewMenu::MeasureItem(MEASUREITEMSTRUCT *pmi)
{
    LRESULT lres = FALSE;
    NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)pmi->itemData;
    if (pnoi)
    {
        // Get the rough height of an item so we can work out when to break the
        // menu. User should really do this for us but that would be useful.
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            // REVIEW cache out the menu font?
            NONCLIENTMETRICS ncm;
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
            {
                HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    SIZE sz;
                    HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                    GetTextExtentPoint(hdc, pnoi->szMenuText, lstrlen(pnoi->szMenuText), &sz);
                    pmi->itemHeight = max (g_cySmIcon+CXIMAGEGAP/2, ncm.iMenuHeight);
                    pmi->itemWidth = g_cxSmIcon + 2*CXIMAGEGAP + sz.cx;
                    //pmi->itemWidth = 2*CXIMAGEGAP + sz.cx;
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                    lres = TRUE;
                }
            }
            ReleaseDC(NULL, hdc);
        }
    }
    return lres;
}

BOOL GetClassDisplayName(LPTSTR pszClass,LPTSTR pszDisplayName,DWORD cchDisplayName)
{
    DWORD cch;

    return SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, pszClass, TEXT("open"), NULL, &cch)) && 
           SUCCEEDED(AssocQueryString(0, ASSOCSTR_FRIENDLYDOCNAME, pszClass, NULL, pszDisplayName, &cchDisplayName));
}

//  New Menu item consolidation worker task
class CNewMenuConsolidator : public CRunnableTask
{
public:
    virtual STDMETHODIMP RunInitRT(void);
    static const GUID _taskid;

    static HRESULT CreateInstance(REFIID riid, void **ppv);

private:
    CNewMenuConsolidator();
    ~CNewMenuConsolidator();

    HANDLE _hMutex, _hEvent;
};


CNewMenuConsolidator::CNewMenuConsolidator() :
    CRunnableTask(RTF_DEFAULT),
    _hMutex(CreateMutex(NULL, FALSE, SHELLNEW_CONSOLIDATION_MUTEX)),
    _hEvent(CreateEvent(NULL, FALSE, FALSE, SHELLNEW_CONSOLIDATION_EVENT))
{
    DllAddRef();
}

CNewMenuConsolidator::~CNewMenuConsolidator()
{
    if (_hMutex)
    {
        CloseHandle(_hMutex);
    }
    if (_hEvent)
    {
        CloseHandle(_hEvent);
    }
    DllRelease();
}

//
// Instance generator.
//
HRESULT CNewMenuConsolidator::CreateInstance(REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CNewMenuConsolidator *pnmc = new CNewMenuConsolidator();
    if (pnmc)
    {
        if (!pnmc->_hMutex || !pnmc->_hEvent)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = pnmc->QueryInterface(riid, ppv);
        }
        pnmc->Release();
    }
    return hr;
}



const GUID CNewMenuConsolidator::_taskid = 
    { 0xf87a1f28, 0xc7f, 0x11d2, { 0xbe, 0x1d, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };


#define REGSTR_SESSION_SHELLNEW STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\ShellNew")
#define REGVAL_SESSION_SHELLNEW_TIMESTAMP TEXT("~reserved~")
#define REGVAL_SESSION_SHELLNEW_LANG TEXT("Language")

#define SHELLNEW_CACHE_CURRENTVERSION  MAKELONG(1, 1)
             
//  Constructs a current New submenu cache stamp.
void CNewMenu_MakeCacheStamp(SHELLNEW_CACHE_STAMP* pStamp)
{
    pStamp->cbStruct = sizeof(*pStamp);
    pStamp->ver = SHELLNEW_CACHE_CURRENTVERSION;
    GetLocalTime(&pStamp->lastupdate);
}

//   Determines whether the New submenu cache needs to be rebuilt.
BOOL CNewMenu_ShouldUpdateCache(SHELLNEW_CACHE_STAMP* pStamp)
{
    //  Correct version?
    return !(sizeof(*pStamp) == pStamp->cbStruct &&
              SHELLNEW_CACHE_CURRENTVERSION == pStamp->ver);
}

//  Gathers up shellnew entries from HKCR into a distinct registry location 
//  for faster enumeration of the New submenu items.
//
//  We'll do a first time cache initialization only if we have to before showing
//  the menu, but will always rebuild the cache following display of the menu.
HRESULT CNewMenu::ConsolidateMenuItems(BOOL bForce)
{
    HKEY          hkeyShellNew = NULL;
    BOOL          bUpdate = TRUE;   // unless we discover otherwise
    HRESULT       hr = S_OK;

    // make sure that a worker thread isnt currently slamming the registry info we're inspecting.
    // if we timeout, then do nothing, since the worker thread is already working on it.
    if (WAIT_OBJECT_0 == WaitForSingleObject(_hMutex, 0))
    {
        //  If we're not being told to unconditionally update the cache and
        //  we validate that we've already established one, then we get out of doing any
        //  work.
        if (!bForce &&
            ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW,
                                           0, KEY_QUERY_VALUE, &hkeyShellNew))
        {
            SHELLNEW_CACHE_STAMP stamp;
            ULONG cbVal = sizeof(stamp);
            if (ERROR_SUCCESS == SHQueryValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_TIMESTAMP, NULL,
                                                  NULL, (LPBYTE)&stamp, &cbVal) &&
                sizeof(stamp) == cbVal)
            {
                bUpdate = CNewMenu_ShouldUpdateCache(&stamp);
            }

            LCID lcid;
            ULONG cblcid = sizeof(lcid);

            if (!bUpdate &&
                ERROR_SUCCESS == SHQueryValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_LANG, NULL,
                                                  NULL, (LPBYTE)&lcid, &cblcid) &&
                sizeof(lcid) == cblcid)
            {
                bUpdate = (GetUserDefaultUILanguage() != lcid); // if the languages are different, then update
            }
            RegCloseKey(hkeyShellNew);
        }

        // end synchronize
        ReleaseMutex(_hMutex);
    
        if (bUpdate)
        {
            IShellTaskScheduler* pScheduler;
            hr = CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC,
                                                IID_PPV_ARG(IShellTaskScheduler, &pScheduler));
            if (SUCCEEDED(hr))
            {
                IRunnableTask *pTask;
                hr = CNewMenuConsolidator::CreateInstance(IID_PPV_ARG(IRunnableTask, &pTask));
                if (SUCCEEDED(hr))
                {
                    // the background task will set _hEvent for us when it's done.
                    hr = pScheduler->AddTask(pTask, CNewMenuConsolidator::_taskid, NULL, ITSAT_DEFAULT_PRIORITY);
                    pTask->Release();
                }
                pScheduler->Release();
            }
        }

        if (!bUpdate || FAILED(hr))
        {
            // if the scheduler wont activate the event, we do it ourselves.
            SetEvent(_hEvent);
        }
    }
    
    return hr;
}

//  Consolidation worker.
STDMETHODIMP CNewMenuConsolidator::RunInitRT()
{
    ULONG dwErr = ERROR_SUCCESS;

    // the possible owners of the mutex are
    // - nobody, we'll own it
    // - other worker threads like this one
    // - the guy who checks to see if the cached info is in the registry.

    // if there's another worker thread which owns this mutex, then bail, since that one
    // will do all the work we're going to do.
    // if the guy who checks the cached info has it, then bail, since it'll spawn
    // another one of these soon enough.
    // so use a 0 timeout.
    if (WAIT_OBJECT_0 == WaitForSingleObject(_hMutex, 0))
    {
        HKEY  hkeyShellNew = NULL;
        TCHAR szExt[MAX_PATH];
        ULONG dwDisposition;
        //  Delete the existing cache; we'll build it from scratch each time.
        while (ERROR_SUCCESS == (dwErr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW,
                                                         0, NULL, 0, KEY_SET_VALUE, NULL,
                                                         &hkeyShellNew, &dwDisposition)) &&
                REG_CREATED_NEW_KEY != dwDisposition)
        {
            //  Key already existed, so delete it, and loop to reopen.
            RegCloseKey(hkeyShellNew);
            SHDeleteKey(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW);
            hkeyShellNew = NULL;
        }

        if (ERROR_SUCCESS == dwErr)
        {
            // Enumerate each subkey of HKCR, looking for New menu items.
            for (int i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szExt, ARRAYSIZE(szExt)) == ERROR_SUCCESS; i++)
            {
                TCHAR szClass[CCH_KEYMAX];
                TCHAR szDisplayName[CCH_KEYMAX];
                DWORD cbVal = sizeof(szClass);

                // find .ext that have proper class descriptions with them.
                if ((szExt[0] == TEXT('.')) &&
                    SHRegGetValue(HKEY_CLASSES_ROOT, szExt, NULL, SRRF_RT_REG_SZ, NULL, szClass, &cbVal) == ERROR_SUCCESS 
                    && GetClassDisplayName(szClass, szDisplayName, ARRAYSIZE(szDisplayName)))
                {
                    NEWOBJECTINFO noi = {0};
                    HKEY          hkeyIterate = NULL;
                    int           iIndex = 0;
                    HRESULT       hr;
                    BOOL          fOk = TRUE;

                    hr = StringCchCopy(noi.szExt, ARRAYSIZE(noi.szExt), szExt);
                    if (FAILED(hr))
                    {
                        fOk = FALSE;
                    }
                    hr = StringCchCopy(noi.szClass, ARRAYSIZE(noi.szClass), szClass);
                    if (FAILED(hr))
                    {
                        fOk = FALSE;
                    }
                    hr = StringCchCopy(noi.szMenuText, ARRAYSIZE(noi.szMenuText), szDisplayName);
                    if (FAILED(hr))
                    {
                        fOk = FALSE;
                    }
                    noi.iImage = -1;

                    if (fOk)
                    {
                        //  Retrieve all additional information for the key.
                        while (GetNewFileInfoForExtension(&noi, NULL, &hkeyIterate, &iIndex))
                        {
                            //  Stick it in the cache.
                            RegSetValueEx(hkeyShellNew, noi.szMenuText, NULL, REG_BINARY,
                                           (LPBYTE)&noi, sizeof(noi));
                        }
                    }
                }
            }

            //  Stamp the cache.
            SHELLNEW_CACHE_STAMP stamp;
            CNewMenu_MakeCacheStamp(&stamp);
            RegSetValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_TIMESTAMP,
                           NULL, REG_BINARY, (LPBYTE)&stamp, sizeof(stamp));
            LCID lcid = GetUserDefaultUILanguage();

            RegSetValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_LANG,
                           NULL, REG_DWORD, (LPBYTE)&lcid, sizeof(lcid));
        }
        if (NULL != hkeyShellNew)
            RegCloseKey(hkeyShellNew);

        // signal the event so InitMenuPopup can proceed.
        SetEvent(_hEvent);
        ReleaseMutex(_hMutex);
    }

    return HRESULT_FROM_WIN32(dwErr);
}

BOOL CNewMenu::_InsertNewMenuItem(HMENU hmenu, UINT idCmd, NEWOBJECTINFO *pnoiClone)
{
    if (pnoiClone->szMenuText[0])
    {
        NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)LocalAlloc(LPTR, sizeof(NEWOBJECTINFO));
        if (pnoi)
        {
            *pnoi = *pnoiClone;

            pnoi->msaa.dwMSAASignature = MSAA_MENU_SIG;
            if (StrChr(pnoi->szMenuText, TEXT('&')) == NULL)
            {
                pnoi->chPrefix = TEXT('&');
                pnoi->msaa.pszWText = &pnoi->chPrefix;
            }
            else
            {
                pnoi->msaa.pszWText = pnoi->szMenuText;
            }
            pnoi->msaa.cchWText = lstrlen(pnoi->msaa.pszWText);

            MENUITEMINFO mii  = {0};
            mii.cbSize        = sizeof(mii);
            mii.fMask         = MIIM_TYPE | MIIM_DATA | MIIM_ID;
            mii.fType         = MFT_OWNERDRAW;
            mii.fState        = MFS_ENABLED;
            mii.wID           = idCmd;
            mii.dwItemData    = (DWORD_PTR)pnoi;
            mii.dwTypeData    = (LPTSTR)pnoi;

            if (-1 != DPA_AppendPtr(_hdpaMenuInfo, pnoi))
            {
                InsertMenuItem(hmenu, -1, TRUE, &mii);
            }
            else
            {
                LocalFree(pnoi);
                return FALSE;
            }
        }
    }

    return TRUE;
}

//  WM_INITMENUPOPUP handler
BOOL CNewMenu::InitMenuPopup(HMENU hmenu)
{
    UINT iStart = 3;
    NEWOBJECTINFO noi = {0};
    if (GetItemData(hmenu, iStart))  //Position 0 is New Folder, 1 shortcut, 2 sep 
        return FALSE;                //already initialized. No need to do anything
    
    _hdpaMenuInfo = DPA_Create(4);
    if (!_hdpaMenuInfo)
        return FALSE;

    //Remove the place holder.
    DeleteMenu(hmenu,0,MF_BYPOSITION);
    
    //Insert New Folder menu item
    LoadString(g_hinst, IDS_NEWFOLDER, noi.szMenuText, ARRAYSIZE(noi.szMenuText));
    noi.dwFlags = NEWTYPE_FOLDER;
    noi.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_FOLDER, 0); //Shange to indicate Folder

    _InsertNewMenuItem(hmenu, _idCmdFirst-NEWITEM_MAX+NEWITEM_FOLDER, &noi);
    
    TCHAR szTemp[MAX_PATH+80];       // Add some slop incase we overflow
    //See if the pidl is folder shortcut and if so get the target path.
    SHGetTargetFolderPath(_pidlFolder, szTemp, ARRAYSIZE(szTemp));
    if (IsLFNDrive(szTemp)) //for short filename servers we don't support anything but new folder
    {
        //Insert New Shortcut menu item
        LoadString(g_hinst, IDS_NEWLINK, noi.szMenuText, ARRAYSIZE(noi.szMenuText));
        noi.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_LINK, 0); //Shange to indicate Link
        noi.dwFlags = NEWTYPE_LINK;

        _InsertNewMenuItem(hmenu, _idCmdFirst-NEWITEM_MAX+NEWITEM_LINK, &noi);
    
        //Insert menu item separator
        AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);

        // This may take a while, so put up the hourglass
        DECLAREWAITCURSOR;
        SetWaitCursor();

        //  Retrieve extension menu items from cache:

        //  begin synchronize.
        //
        if (WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, INFINITE))
        {
            HKEY hkeyShellNew;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW, 
                                               0, KEY_QUERY_VALUE, &hkeyShellNew))
            {
                TCHAR szVal[CCH_KEYMAX];
                ULONG cbVal = ARRAYSIZE(szVal);
                ULONG cbData = sizeof(noi);
                ULONG dwType = REG_BINARY;
            
                for (int i = 0; 
                     ERROR_SUCCESS == RegEnumValue(hkeyShellNew, i, szVal, &cbVal, 0,
                                                    &dwType, (LPBYTE)&noi, &cbData);
                     i++)
                {
                    if (lstrcmp(szVal, REGVAL_SESSION_SHELLNEW_TIMESTAMP) != 0 &&
                        sizeof(noi) == cbData && 
                        REG_BINARY == dwType)
                    {
                        SHFILEINFO sfi;
                        _himlSystemImageList = (HIMAGELIST)SHGetFileInfo(noi.szExt, FILE_ATTRIBUTE_NORMAL,
                                                                         &sfi, sizeof(SHFILEINFO), 
                                                                         SHGFI_USEFILEATTRIBUTES | 
                                                                         SHGFI_SYSICONINDEX | 
                                                                         SHGFI_SMALLICON);
                        if (_himlSystemImageList)
                        {
                            //pnoi->himlSmallIcons = sfi.hIcon;
                            noi.iImage = sfi.iIcon;
                        }
                        else
                        {
                            //pnoi->himlSmallIcons = INVALID_HANDLE_VALUE;
                            noi.iImage = -1;
                        }
                    
                        _InsertNewMenuItem(hmenu, _idCmdFirst, &noi);
                    }
                    cbVal = ARRAYSIZE(szVal);
                    cbData = sizeof(noi);
                    dwType = REG_BINARY;
                }

                RegCloseKey(hkeyShellNew);
            }

            //  consolidate menu items following display.
            ConsolidateMenuItems(TRUE);
        }
        ResetWaitCursor();
    }

    return TRUE;
}

NEWOBJECTINFO *CNewMenu::GetItemData(HMENU hmenu, UINT iItem)
{
    MENUITEMINFO mii;
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA | MIIM_STATE;
    mii.cch = 0;     // just in case...
    
    if (GetMenuItemInfo(hmenu, iItem, TRUE, &mii))
        return (NEWOBJECTINFO *)mii.dwItemData;
    
    return NULL;
}

LPTSTR ProcessArgs(LPTSTR szArgs,...)
{
    LPTSTR szRet;
    va_list ArgList;
    va_start(ArgList,szArgs);
    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        szArgs, 0, 0, (LPTSTR)&szRet, 0, &ArgList))
    {
        return NULL;
    }
    va_end(ArgList);
    return szRet;
}


HRESULT CNewMenu::RunCommand(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszRun)
{
    SHELLEXECUTEINFO ei = { 0 };
    TCHAR szCommand[MAX_PATH];
    TCHAR szRun[MAX_PATH];
    HRESULT hr;
    
    SHExpandEnvironmentStrings(pszRun, szCommand, ARRAYSIZE(szCommand));

    hr = StringCchCopy(szRun, ARRAYSIZE(szRun), szCommand);
    if (SUCCEEDED(hr))
    {
        PathRemoveArgs(szCommand);

        //
        //  Mondo hackitude-o-rama.
        //
        //  Win95, IE3, SDK:  %1 - filename
        //
        //  IE4:              %1 - hwnd, %2 = filename
        //
        //  So IE4 broken Win95 compat and broke compat with the SDK.
        //  For IE5 we restore compat with Win95 and the SDK, while
        //  still generating an IE4-style command if we detect that the
        //  registry key owner tested with IE4 rather than following the
        //  instructions in the SDK.
        //
        //  The algorithm is like this:
        //
        //  If we see a "%2", then use %1 - hwnd, %2 - filename
        //  Otherwise, use             %1 - filename, %2 - hwnd
        //

        LPTSTR pszArgs = PathGetArgs(szRun);
        LPTSTR ptszPercent2 = StrStr(pszArgs, TEXT("%2"));
        if (ptszPercent2 && ptszPercent2[2] != TEXT('!'))
        {
            // App wants %1 = hwnd and %2 = filename
            pszArgs = ProcessArgs(pszArgs, (DWORD_PTR)hwnd, pszPath);
        }
        else
        {
            // App wants %2 = hwnd and %1 = filename
            pszArgs = ProcessArgs(pszArgs, pszPath, (DWORD_PTR)hwnd);
        }

        if (pszArgs)
        {
            HMONITOR hMon = MonitorFromPoint(_ptNewItem, MONITOR_DEFAULTTONEAREST);
            if (hMon)
            {
                ei.fMask |= SEE_MASK_HMONITOR;
                ei.hMonitor = (HANDLE)hMon;
            }
            ei.hwnd            = hwnd;
            ei.lpFile          = szCommand;
            ei.lpParameters    = pszArgs;
            ei.nShow           = SW_SHOWNORMAL;
            ei.cbSize          = sizeof(ei);

            if (ShellExecuteEx(&ei))
                hr = S_FALSE;   // Return S_FALSE because ShellExecuteEx is not atomic
            else
                hr = E_FAIL;

            LocalFree(pszArgs);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CNewMenu::CopyTemplate(IStream *pStream, NEWFILEINFO *pnfi)
{
    TCHAR szSrcFolder[MAX_PATH], szSrc[MAX_PATH];

    szSrc[0] = 0;

    // failure here is OK, we will try CSIDL_COMMON_TEMPLATES too.
    if (SHGetSpecialFolderPath(NULL, szSrcFolder, CSIDL_TEMPLATES, FALSE))
    {
        if (PathCombine(szSrc, szSrcFolder, (LPTSTR)pnfi->lpData))
        {
            if (!PathFileExistsAndAttributes(szSrc, NULL))
                szSrc[0] = 0;
        }
        else
        {
            szSrc[0] = TEXT('\0');
        }
    }

    if (szSrc[0] == 0)
    {
        if (SHGetSpecialFolderPath(NULL, szSrcFolder, CSIDL_COMMON_TEMPLATES, FALSE))
        {
            if (PathCombine(szSrc, szSrcFolder, (LPTSTR)pnfi->lpData))
            {
                if (!PathFileExistsAndAttributes(szSrc, NULL))
                    szSrc[0] = 0;
            }
            else
            {
                szSrc[0] = TEXT('\0');
            }
        }
    }

    if (szSrc[0] == 0)
    {
        // work around CSIDL_TEMPLATES not being setup right or
        // templates that are left in the old %windir%\shellnew location

        UINT cch = GetWindowsDirectory(szSrcFolder, ARRAYSIZE(szSrcFolder));
        if (cch != 0 && cch < ARRAYSIZE(szSrcFolder))
        {
            if (PathAppend(szSrcFolder, TEXT("ShellNew")))
            {
                // note: if the file spec is fully qualified szSrcFolder is ignored
                if (PathCombine(szSrc, szSrcFolder, (LPTSTR)pnfi->lpData))
                {
                    // groovy
                }
                else
                {
                    szSrc[0] = TEXT('\0');
                }
            }
            else
            {
                szSrc[0] = TEXT('\0');
            }
        }
        else
        {
            szSrc[0] = TEXT('\0');
        }
    }

    //
    //  we just allow a null file to be created when the copy fails.
    //  this is for appcompat with office97.  they fail to copy winword8.doc
    //  anywhere on the system.  on win2k we succeed anyway with an empty file.
    //
    return SUCCEEDED(StgCopyFileToStream(szSrc, pStream)) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\startmnu.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <shlobjp.h>
#include <initguid.h>
#include "apithk.h"
#include "resource.h"
#include <runtask.h>
#include <msi.h>
#include <msip.h>

#define REGSTR_EXPLORER_WINUPDATE REGSTR_PATH_EXPLORER TEXT("\\WindowsUpdate")

#define IDM_TOPLEVELSTARTMENU  0

// StartMenuInit Flags
#define STARTMENU_DISPLAYEDBEFORE       0x00000001
#define STARTMENU_CHEVRONCLICKED        0x00000002

// New item counts for UEM stuff
#define UEM_NEWITEMCOUNT 2


// Menuband per pane user data
typedef struct
{
    BITBOOL _fInitialized;
} SMUSERDATA;

// for g_hdpaDarwinAds
EXTERN_C CRITICAL_SECTION g_csDarwinAds = {0};

#define ENTERCRITICAL_DARWINADS EnterCriticalSection(&g_csDarwinAds)
#define LEAVECRITICAL_DARWINADS LeaveCriticalSection(&g_csDarwinAds)

// The threading concern with this variable is create/delete/add/remove. We will only remove an item 
// and delete the hdpa on the main thread. We will however add and create on both threads.
// We need to serialize access to the dpa, so we're going to grab the shell crisec.
HDPA g_hdpaDarwinAds = NULL;

class CDarwinAd
{
public:
    LPITEMIDLIST    _pidl;
    LPTSTR          _pszDescriptor;
    LPTSTR          _pszLocalPath;
    INSTALLSTATE    _state;

    CDarwinAd(LPITEMIDLIST pidl, LPTSTR psz)
    {
        // I take ownership of this pidl
        _pidl = pidl;
        Str_SetPtr(&_pszDescriptor, psz);
    }

    void CheckInstalled()
    {
        TCHAR szProduct[GUIDSTR_MAX];
        TCHAR szFeature[MAX_FEATURE_CHARS+1];
        TCHAR szComponent[GUIDSTR_MAX];

        if (MsiDecomposeDescriptor(_pszDescriptor, szProduct, szFeature, szComponent, NULL) == ERROR_SUCCESS)
        {
            _state = MsiQueryFeatureState(szProduct, szFeature);
        }
        else
        {
            _state = INSTALLSTATE_INVALIDARG;
        }

        // Note: Cannot use ParseDarwinID since that bumps the usage count
        // for the app and we're not running the app, just looking at it.
        // Also because ParseDarwinID tries to install the app (eek!)
        //
        // Must ignore INSTALLSTATE_SOURCE because MsiGetComponentPath will
        // try to install the app even though we're just querying...
        TCHAR szCommand[MAX_PATH];
        DWORD cch = ARRAYSIZE(szCommand);

        if (_state == INSTALLSTATE_LOCAL &&
            MsiGetComponentPath(szProduct, szComponent, szCommand, &cch) == _state)
        {
            PathUnquoteSpaces(szCommand);
            Str_SetPtr(&_pszLocalPath, szCommand);
        }
        else
        {
            Str_SetPtr(&_pszLocalPath, NULL);
        }
    }

    BOOL IsAd()
    {
        return _state == INSTALLSTATE_ADVERTISED;
    }

    ~CDarwinAd()
    {
        ILFree(_pidl);
        Str_SetPtr(&_pszDescriptor, NULL);
        Str_SetPtr(&_pszLocalPath, NULL);
    }
};

int GetDarwinIndex(LPCITEMIDLIST pidlFull, CDarwinAd** ppda);

HRESULT GetMyPicsDisplayName(LPTSTR pszBuffer, UINT cchBuffer)
{
    LPITEMIDLIST pidlMyPics = SHCloneSpecialIDList(NULL, CSIDL_MYPICTURES, FALSE);
    if (pidlMyPics)
    {
        HRESULT hRet = SHGetNameAndFlags(pidlMyPics, SHGDN_NORMAL, pszBuffer, cchBuffer, NULL);
        ILFree(pidlMyPics);
        return hRet;
    }
    return E_FAIL;
}


BOOL AreIntelliMenusEnabled()
{
    DWORD dwRest = SHRestricted(REST_INTELLIMENUS);
    if (dwRest != RESTOPT_INTELLIMENUS_USER)
        return (dwRest == RESTOPT_INTELLIMENUS_ENABLED);

    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("IntelliMenus"),
                               FALSE, TRUE); // Don't ignore HKCU, Enable Menus by default
}

BOOL FeatureEnabled(LPTSTR pszFeature)
{
    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, pszFeature,
                        FALSE, // Don't ignore HKCU
                        FALSE); // Disable this cool feature.
}


// Since we can be presented with an Augmented shellfolder and we need a Full pidl,
// we have been given the responsibility to unwrap it for perf reasons.
LPITEMIDLIST FullPidlFromSMData(LPSMDATA psmd)
{
    LPITEMIDLIST pidlItem;
    LPITEMIDLIST pidlFolder = NULL;
    LPITEMIDLIST pidlFull = NULL;
    IAugmentedShellFolder2* pasf2;
    if (SUCCEEDED(psmd->psf->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder2, &pasf2))))
    {
        if (SUCCEEDED(pasf2->UnWrapIDList(psmd->pidlItem, 1, NULL, &pidlFolder, &pidlItem, NULL)))
        {
            pidlFull = ILCombine(pidlFolder, pidlItem);
            ILFree(pidlFolder);
            ILFree(pidlItem);
        }
        pasf2->Release();
    }

    if (!pidlFolder)
    {
        pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
    }

    return pidlFull;
}

//
//  Determine whether a namespace pidl in a merged shellfolder came
//  from the specified object GUID.
//
BOOL IsMergedFolderGUID(IShellFolder *psf, LPCITEMIDLIST pidl, REFGUID rguid)
{
    IAugmentedShellFolder* pasf;
    BOOL fMatch = FALSE;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder, &pasf))))
    {
        GUID guid;
        if (SUCCEEDED(pasf->GetNameSpaceID(pidl, &guid)))
        {
            fMatch = IsEqualGUID(guid, rguid);
        }
        pasf->Release();
    }

    return fMatch;
}

STDMETHODIMP_(int) s_DarwinAdsDestroyCallback(LPVOID pData1, LPVOID pData2)
{
    CDarwinAd* pda = (CDarwinAd*)pData1;
    if (pda)
        delete pda;
    return TRUE;
}


// SHRegisterDarwinLink takes ownership of the pidl
BOOL SHRegisterDarwinLink(LPITEMIDLIST pidlFull, LPWSTR pszDarwinID, BOOL fUpdate)
{
    BOOL fRetVal = FALSE;

    ENTERCRITICAL_DARWINADS;

    if (pidlFull)
    {
        CDarwinAd *pda = NULL;

        if (GetDarwinIndex(pidlFull, &pda) != -1 && pda)
        {
            // We already know about this link; don't need to add it
            fRetVal = TRUE;
        }
        else
        {
            pda = new CDarwinAd(pidlFull, pszDarwinID);
            if (pda)
            {
                pidlFull = NULL;    // take ownership

                // Do we have a global cache?
                if (g_hdpaDarwinAds == NULL)
                {
                    // No; This is either the first time this is called, or we
                    // failed the last time.
                    g_hdpaDarwinAds = DPA_Create(5);
                }

                if (g_hdpaDarwinAds)
                {
                    // DPA_AppendPtr returns the zero based index it inserted it at.
                    if(DPA_AppendPtr(g_hdpaDarwinAds, (void*)pda) >= 0)
                    {
                        fRetVal = TRUE;
                    }

                }
            }
        }

        if (!fRetVal)
        {
            // if we failed to create a dpa, delete this.
            delete pda;
        }
        else if (fUpdate)
        {
            // update the entry if requested
            pda->CheckInstalled();
        }
        ILFree(pidlFull);

    }
    else if (!pszDarwinID)
    {
        // NULL, NULL means "destroy darwin info, we're shutting down"
        HDPA hdpa = g_hdpaDarwinAds;
        g_hdpaDarwinAds = NULL;
        if (hdpa)
            DPA_DestroyCallback(hdpa, s_DarwinAdsDestroyCallback, NULL);
    }

    LEAVECRITICAL_DARWINADS;

    return fRetVal;
}

BOOL ProcessDarwinAd(IShellLinkDataList* psldl, LPCITEMIDLIST pidlFull)
{
    // This function does not check for the existance of a member before adding it,
    // so it is entirely possible for there to be duplicates in the list....
    BOOL fIsLoaded = FALSE;
    BOOL fFreesldl = FALSE;
    BOOL fRetVal = FALSE;

    if (!psldl)
    {
        // We will detect failure of this at use time.
        if (FAILED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkDataList, &psldl))))
        {
            return FALSE;
        }

        fFreesldl = TRUE;

        IPersistFile* ppf;
        OLECHAR sz[MAX_PATH];
        if (SHGetPathFromIDListW(pidlFull, sz))
        {
            if (SUCCEEDED(psldl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
            {
                // shelllink's job to load correctly.
                if (SUCCEEDED(ppf->Load(sz, 0)))
                {
                    fIsLoaded = TRUE;
                }
                ppf->Release();
            }
        }
    }
    else
        fIsLoaded = TRUE;

    CDarwinAd* pda = NULL;
    if (fIsLoaded)
    {
        EXP_DARWIN_LINK* pexpDarwin;

        if (SUCCEEDED(psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin)))
        {
            fRetVal = SHRegisterDarwinLink(ILClone(pidlFull), pexpDarwin->szwDarwinID, TRUE);
            LocalFree(pexpDarwin);
        }
    }

    if (fFreesldl)
        psldl->Release();

    return fRetVal;
}

// This routine creates the IShellFolder and pidl for one of the many
// merged folders on the Start Menu / Start Panel.

typedef struct {
    UINT    csidl;
    UINT    uANSFlags;          // Flags for AddNameSpace
    LPCGUID pguidObj;           // optional object tag
} MERGEDFOLDERINFO, *LPMERGEDFOLDERINFO;
typedef const MERGEDFOLDERINFO *LPCMERGEDFOLDERINFO;

HRESULT GetMergedFolder(IShellFolder **ppsf, LPITEMIDLIST *ppidl,
                        LPCMERGEDFOLDERINFO rgmfi, UINT cmfi)
{
    *ppidl = NULL;
    *ppsf = NULL;

    IShellFolder2 *psf;
    IAugmentedShellFolder2 *pasf;
    HRESULT hr = CoCreateInstance(CLSID_MergedFolder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAugmentedShellFolder2, &pasf));

    for (UINT imfi = 0; SUCCEEDED(hr) && imfi < cmfi; imfi++)
    {
        // If this is a common group and common groups are restricted, then
        // skip this item
        if ((rgmfi[imfi].uANSFlags & ASFF_COMMON) &&
            SHRestricted(REST_NOCOMMONGROUPS))
        {
            continue;
        }

        psf = NULL;    // in/out param below
        hr = SHCacheTrackingFolder(MAKEINTIDLIST(rgmfi[imfi].csidl), rgmfi[imfi].csidl, &psf);

        if (SUCCEEDED(hr))
        {
            // If this is a Start Menu folder, then apply the
            // "do not enumerate subfolders" restriction if the policy says so.
            // In which case, we cannot use the tracking folder cache.
            // (Perf note: We compare pointers directly.)
            if (rgmfi[imfi].pguidObj == &CLSID_StartMenu)
            {
                if (SHRestricted(REST_NOSTARTMENUSUBFOLDERS))
                {
                    ISetFolderEnumRestriction *prest;
                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(ISetFolderEnumRestriction, &prest))))
                    {
                        prest->SetEnumRestriction(0, SHCONTF_FOLDERS); // disallow subfolders
                        prest->Release();
                    }
                }
            }
            else
            {
                // If this assert fires, then our perf optimization above failed.
                ASSERT(rgmfi[imfi].pguidObj == NULL ||
                       !IsEqualGUID(*rgmfi[imfi].pguidObj, CLSID_StartMenu));
            }


            hr = pasf->AddNameSpace(rgmfi[imfi].pguidObj, psf, NULL, rgmfi[imfi].uANSFlags);
            if (SUCCEEDED(hr))
            {
                if (rgmfi[imfi].uANSFlags & ASFF_DEFNAMESPACE_DISPLAYNAME)
                {
                    // If this assert fires, it means somebody marked two
                    // folders as ASFF_DEFNAMESPACE_DISPLAYNAME, which is
                    // illegal (you can have only one default)
                    ASSERT(*ppidl == NULL);
                    hr = SHGetIDListFromUnk(psf, ppidl);    // copy out the pidl for this guy
                }
            }

            psf->Release();
        }
    }

    if (SUCCEEDED(hr))
        *ppsf = pasf;   // copy out the ref
    else
        ATOMICRELEASE(pasf);

    return hr;
}

HRESULT CreateMergedFolderHelper(LPCMERGEDFOLDERINFO rgmfi, UINT cmfi, REFIID riid, void **ppv)
{
    IShellFolder *psf;
    LPITEMIDLIST pidl;
    HRESULT hr = GetMergedFolder(&psf, &pidl, rgmfi, cmfi);
    if (SUCCEEDED(hr))
    {
        hr = psf->QueryInterface(riid, ppv);

        if (SUCCEEDED(hr))
        {
            IPersistPropertyBag *pppb;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistPropertyBag, &pppb))))
            {
                IPropertyBag *ppb;
                if (SUCCEEDED(SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb))))
                {
                    // these merged folders have to be told to use new changenotification
                    SHPropertyBag_WriteBOOL(ppb, L"MergedFolder\\ShellView", TRUE);
                    pppb->Load(ppb, NULL);
                    ppb->Release();
                }
                pppb->Release();
            }
        }

        psf->Release();
        ILFree(pidl);
    }
    return hr;
}

const MERGEDFOLDERINFO c_rgmfiStartMenu[] = {
    {   CSIDL_STARTMENU | CSIDL_FLAG_CREATE,    ASFF_DEFNAMESPACE_ALL,  &CLSID_StartMenu },
    {   CSIDL_COMMON_STARTMENU,                 ASFF_COMMON,            &CLSID_StartMenu },
};

const MERGEDFOLDERINFO c_rgmfiProgramsFolder[] = {
    {   CSIDL_PROGRAMS | CSIDL_FLAG_CREATE,     ASFF_DEFNAMESPACE_ALL,  NULL },
    {   CSIDL_COMMON_PROGRAMS,                  ASFF_COMMON,            NULL },
};

//
//  On the Start Panel, we want the fast items to sort above the Programs,
//  so we mark the Programs folders as ASFF_SORTDOWN so they go to the bottom.
//  We also list the Fast Items first so SMSET_SEPARATEMERGEFOLDER picks
//  them off properly.  And we only want to let Start Menu merge with
//  Common Start Menu (and Programs with Common Programs) so pass
//  ASFF_MERGESAMEGUID.

const MERGEDFOLDERINFO c_rgmfiProgramsFolderAndFastItems[] = {
    {   CSIDL_STARTMENU | CSIDL_FLAG_CREATE,    ASFF_DEFAULT          | ASFF_MERGESAMEGUID,                 &CLSID_StartMenu},
    {   CSIDL_COMMON_STARTMENU,                 ASFF_COMMON           | ASFF_MERGESAMEGUID,                 &CLSID_StartMenu},
    {   CSIDL_PROGRAMS | CSIDL_FLAG_CREATE,     ASFF_DEFNAMESPACE_ALL | ASFF_MERGESAMEGUID | ASFF_SORTDOWN, NULL },
    {   CSIDL_COMMON_PROGRAMS,                  ASFF_COMMON           | ASFF_MERGESAMEGUID | ASFF_SORTDOWN, NULL },
};

STDAPI CStartMenuFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CreateMergedFolderHelper(c_rgmfiStartMenu, ARRAYSIZE(c_rgmfiStartMenu), riid, ppv);
}

STDAPI CProgramsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CreateMergedFolderHelper(c_rgmfiProgramsFolder, ARRAYSIZE(c_rgmfiProgramsFolder), riid, ppv);
}

HRESULT GetFilesystemInfo(IShellFolder* psf, LPITEMIDLIST* ppidlRoot, int* pcsidl)
{
    ASSERT(psf);
    IPersistFolder3* ppf;
    HRESULT hr = E_FAIL;

    *pcsidl = 0;
    *ppidlRoot = 0;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf))))
    {
        PERSIST_FOLDER_TARGET_INFO pfti = {0};

        if (SUCCEEDED(ppf->GetFolderTargetInfo(&pfti)))
        {
            *pcsidl = pfti.csidl;
            if (-1 != pfti.csidl)
                hr = S_OK;

            ILFree(pfti.pidlTargetFolder);
        }

        if (SUCCEEDED(hr))
            hr = ppf->GetCurFolder(ppidlRoot);
            
        ppf->Release();
    }
    return hr;
}

HRESULT ExecStaticStartMenuItem(int idCmd, BOOL fAllUsers, BOOL fOpen)
{
    int csidl = -1;
    HRESULT hr = E_OUTOFMEMORY;
    SHELLEXECUTEINFO shei = {0};
    switch (idCmd)
    {
    case IDM_PROGRAMS:          csidl = fAllUsers ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS; break;
    case IDM_FAVORITES:         csidl = CSIDL_FAVORITES; break;
    case IDM_MYDOCUMENTS:       csidl = CSIDL_PERSONAL; break;
    case IDM_MYPICTURES:        csidl = CSIDL_MYPICTURES; break;
    case IDM_CONTROLS:          csidl = CSIDL_CONTROLS;  break;
    case IDM_PRINTERS:          csidl = CSIDL_PRINTERS;  break;
    case IDM_NETCONNECT:        csidl = CSIDL_CONNECTIONS; break;
    default:
        return E_FAIL;
    }

    if (csidl != -1)
    {
        SHGetFolderLocation(NULL, csidl, NULL, 0, (LPITEMIDLIST*)&shei.lpIDList);
    }

    if (shei.lpIDList)
    {
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST;
        shei.nShow      = SW_SHOWNORMAL;
        shei.lpVerb     = fOpen ? TEXT("open") : TEXT("explore");
        hr = ShellExecuteEx(&shei) ? S_OK: E_FAIL; // only opening and exploring special folder pidl
        ILFree((LPITEMIDLIST)shei.lpIDList);
    }

    return hr;
}

//
//  Base class for Classic and Personal start menus.
//

class CStartMenuCallbackBase : public IShellMenuCallback,
                               public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // derived class is expected to implement IShellMenuCallback

    // IObjectWithSite inherited from CObjectWithSite

protected:
    CStartMenuCallbackBase(BOOL fIsStartPanel = FALSE);
    ~CStartMenuCallbackBase();

    void _InitializePrograms();
    HRESULT _FilterPidl(UINT uParent, IShellFolder* psf, LPCITEMIDLIST pidl);
    HRESULT _Promote(LPSMDATA psmd, DWORD dwFlags);
    BOOL _IsTopLevelStartMenu(UINT uParent, IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _HandleNew(LPSMDATA psmd);
    HRESULT _GetSFInfo(SMDATA* psmd, SMINFO* psminfo);
    HRESULT _ProcessChangeNotify(SMDATA* psmd, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    HRESULT InitializeProgramsShellMenu(IShellMenu* psm);

    virtual DWORD _GetDemote(SMDATA* psmd) { return 0; }
    BOOL _IsDarwinAdvertisement(LPCITEMIDLIST pidlFull);

    void _RefreshSettings();

protected:
    int _cRef;

    DEBUG_CODE( DWORD _dwThreadID; )   // Cache the thread of the object

    LPTSTR          _pszPrograms;
    LPTSTR          _pszWindowsUpdate;
    LPTSTR          _pszConfigurePrograms;
    LPTSTR          _pszAdminTools;

    ITrayPriv2*     _ptp2;

    BOOL            _fExpandoMenus;
    BOOL            _fShowAdminTools;
    BOOL            _fIsStartPanel;
    BOOL            _fInitPrograms;
};

// IShellMenuCallback implementation
class CStartMenuCallback : public CStartMenuCallbackBase
{
public:
    // *** IUnknown methods *** inherited from CStartMenuBase

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods *** (overriding CObjectWithSite)
    STDMETHODIMP SetSite(IUnknown* punk);
    STDMETHODIMP GetSite(REFIID riid, void** ppvOut);

    CStartMenuCallback();
private:
    virtual ~CStartMenuCallback();

    IContextMenu*   _pcmFind;
    ITrayPriv*      _ptp;
    IUnknown*       _punkSite;
    IOleCommandTarget* _poct;
    BITBOOL         _fAddOpenFolder: 1;
    BITBOOL         _fCascadeMyDocuments: 1;
    BITBOOL         _fCascadePrinters: 1;
    BITBOOL         _fCascadeControlPanel: 1;
    BITBOOL         _fFindMenuInvalid: 1;
    BITBOOL         _fCascadeNetConnections: 1;
    BITBOOL         _fShowInfoTip: 1;
    BITBOOL         _fInitedShowTopLevelStartMenu: 1;
    BITBOOL         _fCascadeMyPictures: 1;

    BITBOOL         _fHasMyDocuments: 1;
    BITBOOL         _fHasMyPictures: 1;

    TCHAR           _szFindMnemonic[2];

    HWND            _hwnd;

    IMruDataList *  _pmruRecent;
    DWORD           _cRecentDocs;

    DWORD           _dwFlags;
    DWORD           _dwChevronCount;
    
    HRESULT _ExecHmenuItem(LPSMDATA psmdata);
    HRESULT _Init(SMDATA* psmdata);
    HRESULT _Create(SMDATA* psmdata, void** pvUserData);
    HRESULT _Destroy(SMDATA* psmdata);
    HRESULT _GetHmenuInfo(SMDATA* psmd, SMINFO*sminfo);
    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _CheckRestricted(DWORD dwRestrict, BOOL* fRestricted);
    HRESULT _FilterRecentPidl(IShellFolder* psf, LPCITEMIDLIST pidl);
    HRESULT _Demote(LPSMDATA psmd);
    HRESULT _GetTip(LPWSTR pstrTitle, LPWSTR pstrTip);
    DWORD _GetDemote(SMDATA* psmd);
    HRESULT _HandleAccelerator(TCHAR ch, SMDATA* psmdata);
    HRESULT _GetDefaultIcon(LPWSTR psz, int* piIndex);
    void _GetStaticStartMenu(HMENU* phmenu, HWND* phwnd);
    HRESULT _GetStaticInfoTip(SMDATA* psmd, LPWSTR pszTip, int cch);

    // helper functions
    DWORD GetInitFlags();
    void  SetInitFlags(DWORD dwFlags);
    HRESULT _InitializeFindMenu(IShellMenu* psm);
    HRESULT _ExecItem(LPSMDATA, UINT);
    HRESULT VerifyCSIDL(int idCmd, int csidl, IShellMenu* psm);
    HRESULT VerifyMergedGuy(BOOL fPrograms, IShellMenu* psm);
    void _UpdateDocsMenuItemNames(IShellMenu* psm);
    void _UpdateDocumentsShellMenu(IShellMenu* psm);

public: // Make these public to this file. This is for the CreateInstance
    // Sub Menu creation
    HRESULT InitializeFastItemsShellMenu(IShellMenu* psm);
    HRESULT InitializeCSIDLShellMenu(int uId, int csidl, LPTSTR pszRoot, LPTSTR pszValue,
                                 DWORD dwPassInitFlags, DWORD dwSetFlags, BOOL fAddOpen, 
                                 IShellMenu* psm);
    HRESULT InitializeDocumentsShellMenu(IShellMenu* psm);
    HRESULT InitializeSubShellMenu(int idCmd, IShellMenu* psm);
};


class CStartContextMenu : IContextMenu
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);

    CStartContextMenu(int idCmd) : _idCmd(idCmd), _cRef(1) {};
private:
    int _cRef;
    virtual ~CStartContextMenu() {};

    int _idCmd;
};

void CStartMenuCallbackBase::_RefreshSettings()
{
    _fShowAdminTools = FeatureEnabled(TEXT("StartMenuAdminTools"));
}

CStartMenuCallbackBase::CStartMenuCallbackBase(BOOL fIsStartPanel)
    : _cRef(1), _fIsStartPanel(fIsStartPanel)
{
    DEBUG_CODE( _dwThreadID = GetCurrentThreadId() );

    TCHAR szBuf[MAX_PATH];
    DWORD cbSize = sizeof(szBuf); // SHGetValue wants sizeof

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_EXPLORER_WINUPDATE, TEXT("ShortcutName"),
        NULL, szBuf, &cbSize))
    {
        // Add ".lnk" if the file doesn't have an extension
        PathAddExtension(szBuf, TEXT(".lnk"));
        Str_SetPtr(&_pszWindowsUpdate, szBuf);
    }

    cbSize = sizeof(szBuf); // SHGetValue wants sizeof
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, TEXT("SM_ConfigureProgramsName"),
        NULL, szBuf, &cbSize))
    {
        PathAddExtension(szBuf, TEXT(".lnk"));
        Str_SetPtr(&_pszConfigurePrograms, szBuf);
    }

    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_COMMON_ADMINTOOLS | CSIDL_FLAG_CREATE, NULL, 0, szBuf)))
    {
        Str_SetPtr(&_pszAdminTools, PathFindFileName(szBuf));
    }

    _RefreshSettings();

    SHReValidateDarwinCache();
}

CStartMenuCallback::CStartMenuCallback() : _cRecentDocs(-1)
{
    LoadString(g_hinst, IDS_FIND_MNEMONIC, _szFindMnemonic, ARRAYSIZE(_szFindMnemonic));
}

CStartMenuCallbackBase::~CStartMenuCallbackBase()
{
    ASSERT( _dwThreadID == GetCurrentThreadId() );

    Str_SetPtr(&_pszWindowsUpdate, NULL);
    Str_SetPtr(&_pszConfigurePrograms, NULL);
    Str_SetPtr(&_pszAdminTools, NULL);
    Str_SetPtr(&_pszPrograms, NULL);

    ATOMICRELEASE(_ptp2);
}

CStartMenuCallback::~CStartMenuCallback()
{
    ATOMICRELEASE(_pcmFind);
    ATOMICRELEASE(_ptp);
    ATOMICRELEASE(_pmruRecent);
}

// *** IUnknown methods ***
STDMETHODIMP CStartMenuCallbackBase::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CStartMenuCallbackBase, IShellMenuCallback),
        QITABENT(CStartMenuCallbackBase, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CStartMenuCallbackBase::AddRef()
{
    return ++_cRef;
}


STDMETHODIMP_(ULONG) CStartMenuCallbackBase::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CStartMenuCallback::SetSite(IUnknown* punk)
{
    ATOMICRELEASE(_punkSite);
    _punkSite = punk;
    if (punk)
    {
        _punkSite->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CStartMenuCallback::GetSite(REFIID riid, void**ppvOut)
{
    if (_ptp)
        return _ptp->QueryInterface(riid, ppvOut);
    else
        return E_NOINTERFACE;
}

#ifdef DEBUG
void DBUEMQueryEvent(const IID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
#if 1
    return;
#else
    UEMINFO uei;

    uei.cbSize = sizeof(uei);
    uei.dwMask = ~0;    // UEIM_HIT etc.
    UEMQueryEvent(pguidGrp, eCmd, wParam, lParam, &uei);

    TCHAR szBuf[20];
    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("hit=%d"), uei.cHit);
    MessageBox(NULL, szBuf, TEXT("UEM"), MB_OKCANCEL);

    return;
#endif
}
#endif

DWORD CStartMenuCallback::GetInitFlags()
{
    DWORD dwType;
    DWORD cbSize = sizeof(DWORD);
    DWORD dwFlags = 0;
    SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuInit"), 
            &dwType, (BYTE*)&dwFlags, &cbSize);
    return dwFlags;
}

void CStartMenuCallback::SetInitFlags(DWORD dwFlags)
{
    SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuInit"), REG_DWORD, &dwFlags, sizeof(DWORD));
}

DWORD GetClickCount()
{

    //This function retrieves the number of times the user has clicked on the chevron item.

    DWORD dwType;
    DWORD cbSize = sizeof(DWORD);
    DWORD dwCount = 1;      // Default to three clicks before we give up.
                            // PMs what it to 1 now. Leaving back end in case they change their mind.
    SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuChevron"), 
            &dwType, (BYTE*)&dwCount, &cbSize);

    return dwCount;

}

void SetClickCount(DWORD dwClickCount)
{
    SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuChevron"), REG_DWORD, &dwClickCount, sizeof(dwClickCount));
}

BOOL CStartMenuCallbackBase::_IsTopLevelStartMenu(UINT uParent, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return uParent == IDM_TOPLEVELSTARTMENU ||
           (uParent == IDM_PROGRAMS && _fIsStartPanel && IsMergedFolderGUID(psf, pidl, CLSID_StartMenu));
};


STDMETHODIMP CStartMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    switch (uMsg)
    {

    case SMC_CREATE:
        hr = _Create(psmd, (void**)lParam);
        break;

    case SMC_DESTROY:
        hr = _Destroy(psmd);
        break;

    case SMC_INITMENU:
        hr = _Init(psmd);
        break;

    case SMC_SFEXEC:
        hr = _ExecItem(psmd, uMsg);
        break;

    case SMC_EXEC:
        hr = _ExecHmenuItem(psmd);
        break;

    case SMC_GETOBJECT:
        hr = _GetObject(psmd, (GUID)*((GUID*)wParam), (void**)lParam);
        break;

    case SMC_GETINFO:
        hr = _GetHmenuInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_GETSFINFOTIP:
        if (!_fShowInfoTip)
            hr = E_FAIL;  // E_FAIL means don't show. S_FALSE means show default
        break;

    case SMC_GETINFOTIP:
        hr = _GetStaticInfoTip(psmd, (LPWSTR)wParam, (int)lParam);
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_BEGINENUM:
        if (psmd->uIdParent == IDM_RECENT)
        {
            ASSERT(_cRecentDocs == -1);
            ASSERT(!_pmruRecent);
            CreateRecentMRUList(&_pmruRecent);

            _cRecentDocs = 0;
            hr = S_OK;
        }
        break;

    case SMC_ENDENUM:
        if (psmd->uIdParent == IDM_RECENT)
        {
            ASSERT(_cRecentDocs != -1);
            ATOMICRELEASE(_pmruRecent);

            _cRecentDocs = -1;
            hr = S_OK;
        }
        break;
    
    case SMC_DUMPONUPDATE:
        if (psmd->uIdParent == IDM_RECENT)
        {
            hr = S_OK;
        }
        break;
    
    case SMC_FILTERPIDL:
        ASSERT(psmd->dwMask & SMDM_SHELLFOLDER);

        if (psmd->uIdParent == IDM_RECENT)
        {
            //  we need to filter out all but the first MAXRECENTITEMS
            //  and no folders allowed!
            hr = _FilterRecentPidl(psmd->psf, psmd->pidlItem);
        }
        else
        {
            hr = _FilterPidl(psmd->uIdParent, psmd->psf, psmd->pidlItem);
        }
        break;

    case SMC_INSERTINDEX:
        ASSERT(lParam && IS_VALID_WRITE_PTR(lParam, int));
        *((int*)lParam) = 0;
        hr = S_OK;
        break;

    case SMC_SHCHANGENOTIFY:
        {
            PSMCSHCHANGENOTIFYSTRUCT pshf = (PSMCSHCHANGENOTIFYSTRUCT)lParam;
            hr = _ProcessChangeNotify(psmd, pshf->lEvent, pshf->pidl1, pshf->pidl2);
        }
        break;

    case SMC_REFRESH:
        if (psmd->uIdParent == IDM_TOPLEVELSTARTMENU)
        {
            hr = S_OK;

            // Refresh is only called on the top level.
            HMENU hmenu;
            IShellMenu* psm;
            _GetStaticStartMenu(&hmenu, &_hwnd);
            if (hmenu && psmd->punk && SUCCEEDED(psmd->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
            {
                hr = psm->SetMenu(hmenu, _hwnd, SMSET_BOTTOM | SMSET_MERGE);
                psm->Release();
            }

            _RefreshSettings();
            _fExpandoMenus = !_fIsStartPanel && AreIntelliMenusEnabled();
            _fCascadeMyDocuments = FeatureEnabled(TEXT("CascadeMyDocuments"));
            _fCascadePrinters = FeatureEnabled(TEXT("CascadePrinters"));
            _fCascadeControlPanel = FeatureEnabled(TEXT("CascadeControlPanel"));
            _fCascadeNetConnections = FeatureEnabled(TEXT("CascadeNetworkConnections"));
            _fAddOpenFolder = FeatureEnabled(TEXT("StartMenuOpen"));
            _fShowInfoTip = FeatureEnabled(TEXT("ShowInfoTip"));
            _fCascadeMyPictures = FeatureEnabled(TEXT("CascadeMyPictures"));
            _fFindMenuInvalid = TRUE;
            _dwFlags = GetInitFlags();
        }
        break;

    case SMC_DEMOTE:
        hr = _Demote(psmd);
        break;

    case SMC_PROMOTE:
        hr = _Promote(psmd, (DWORD)wParam);
        break;

    case SMC_NEWITEM:
        hr = _HandleNew(psmd);
        break;

    case SMC_MAPACCELERATOR:
        hr = _HandleAccelerator((TCHAR)wParam, (SMDATA*)lParam);
        break;

    case SMC_DEFAULTICON:
        ASSERT(psmd->uIdAncestor == IDM_FAVORITES); // This is only valid for the Favorites menu
        hr = _GetDefaultIcon((LPWSTR)wParam, (int*)lParam);
        break;

    case SMC_GETMINPROMOTED:
        // Only do this for the programs menu
        if (psmd->uIdParent == IDM_PROGRAMS)
            *((int*)lParam) = 4;        // 4 was choosen by RichSt 9.15.98
        break;

    case SMC_CHEVRONEXPAND:

        // Has the user already seen the chevron tip enough times? (We set the bit when the count goes to zero.
        if (!(_dwFlags & STARTMENU_CHEVRONCLICKED))
        {
            // No; Then get the current count from the registry. We set a default of 3, but an admin can set this
            // to -1, that would make it so that they user sees it all the time.
            DWORD dwClickCount = GetClickCount();
            if (dwClickCount > 0)
            {
                // Since they clicked, take one off.
                dwClickCount--;

                // Set it back in.
                SetClickCount(dwClickCount);
            }

            if (dwClickCount == 0)
            {
                // Ah, the user has seen the chevron tip enought times... Stop being annoying.
                _dwFlags |= STARTMENU_CHEVRONCLICKED;
                SetInitFlags(_dwFlags);
            }
        }
        hr = S_OK;
        break;

    case SMC_DISPLAYCHEVRONTIP:

        // We only want to see the tip on the top level programs case, no where else. We also don't
        // want to see it if they've had enough.
        if (psmd->uIdParent == IDM_PROGRAMS && 
            !(_dwFlags & STARTMENU_CHEVRONCLICKED) &&
            !SHRestricted(REST_NOSMBALLOONTIP))
        {
            hr = S_OK;
        }
        break;

    case SMC_CHEVRONGETTIP:
        if (!SHRestricted(REST_NOSMBALLOONTIP))
            hr = _GetTip((LPWSTR)wParam, (LPWSTR)lParam);
        break;
    }

    return hr;
}

// For the Favorites menu, since their icon handler is SO slow, we're going to fake the icon
// and have it get the real ones on the background thread...
HRESULT CStartMenuCallback::_GetDefaultIcon(LPWSTR psz, int* piIndex)
{
    DWORD cchSize = MAX_PATH;
    HRESULT hr = AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("InternetShortcut"), NULL, psz, &cchSize);
    if (SUCCEEDED(hr))
    {
        *piIndex = PathParseIconLocation(psz);
    }
    
    return hr;
}

HRESULT CStartMenuCallback::_ExecItem(LPSMDATA psmd, UINT uMsg)
{
    ASSERT( _dwThreadID == GetCurrentThreadId() );
    return _ptp->ExecItem(psmd->psf, psmd->pidlItem);
}

HRESULT CStartMenuCallback::_Demote(LPSMDATA psmd)
{
    //We want to for the UEM to demote pidlFolder, 
    // then tell the Parent menuband (If there is one)
    // to invalidate this pidl.
    HRESULT hr = S_FALSE;

    if (_fExpandoMenus && 
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        UEMINFO uei;
        uei.cbSize = sizeof(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = 0;
        hr = UEMSetEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
            UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }
    return hr;
}

// Even if intellimenus are off, fire a UEM event if it was an Exec from
// the More Programs menu of the Start Panel [SMINV_FORCE will be set]
// so we can detect which are the user's most popular apps.

HRESULT CStartMenuCallbackBase::_Promote(LPSMDATA psmd, DWORD dwFlags)
{
    if ((_fExpandoMenus || (_fIsStartPanel && (dwFlags & SMINV_FORCE))) &&
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        UEMFireEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
            UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem);
    }
    return S_OK;
}

HRESULT CStartMenuCallbackBase::_HandleNew(LPSMDATA psmd)
{
    HRESULT hr = S_FALSE;
    if (_fExpandoMenus && 
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        UEMINFO uei;
        uei.cbSize = sizeof(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = UEM_NEWITEMCOUNT;
        hr = UEMSetEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
            UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }

    if (psmd->uIdAncestor == IDM_PROGRAMS)
    {
        LPITEMIDLIST pidlFull = FullPidlFromSMData(psmd);
        if (pidlFull)
        {
            ProcessDarwinAd(NULL, pidlFull);
            ILFree(pidlFull);
        }
    }
    return hr;
}

HRESULT ShowFolder(UINT csidl)
{
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl)))
    {
        SHELLEXECUTEINFO shei = { 0 };

        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST;
        shei.nShow      = SW_SHOWNORMAL;
        shei.lpVerb     = TEXT("open");
        shei.lpIDList   = pidl;
        ShellExecuteEx(&shei); // only executing open on pidl
        ILFree(pidl);
    }
    return S_OK;
}

void _ExecRegValue(LPCTSTR pszValue)
{
    TCHAR szPath[MAX_PATH];
    DWORD cbSize = sizeof(szPath);

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_EXPLORER_ADVANCED, pszValue, 
        NULL, szPath, &cbSize))
    {
        SHELLEXECUTEINFO shei= { 0 };
        shei.cbSize = sizeof(shei);
        shei.nShow  = SW_SHOWNORMAL;
        shei.lpParameters = PathGetArgs(szPath);
        PathRemoveArgs(szPath);
        shei.lpFile = szPath;
        ShellExecuteEx(&shei); // raw shellexec but info comes from HKLM
    }
}

HRESULT CStartMenuCallback::_ExecHmenuItem(LPSMDATA psmd)
{
    HRESULT hr = S_FALSE;
    if (IsInRange(psmd->uId, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST) && _pcmFind)
    {
        CMINVOKECOMMANDINFOEX ici = { 0 };
        ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);
        ici.lpVerb = (LPSTR)MAKEINTRESOURCE(psmd->uId - TRAY_IDM_FINDFIRST);
        ici.nShow = SW_NORMAL;
        
        // record if shift or control was being held down
        SetICIKeyModifiers(&ici.fMask);

        _pcmFind->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
        hr = S_OK;
    }
    else
    {
        switch (psmd->uId)
        {
        case IDM_OPEN_FOLDER:
            switch(psmd->uIdParent)
            {
            case IDM_CONTROLS:
                hr = ShowFolder(CSIDL_CONTROLS);
                break;

            case IDM_PRINTERS:
                hr = ShowFolder(CSIDL_PRINTERS);
                break;

            case IDM_NETCONNECT:
                hr = ShowFolder(CSIDL_CONNECTIONS);
                break;

            case IDM_MYPICTURES:
                hr = ShowFolder(CSIDL_MYPICTURES);
                break;

            case IDM_MYDOCUMENTS:
                hr = ShowFolder(CSIDL_PERSONAL);
                break;
            }
            break;

        case IDM_NETCONNECT:
            hr = ShowFolder(CSIDL_CONNECTIONS);
            break;

        case IDM_MYDOCUMENTS:
            hr = ShowFolder(CSIDL_PERSONAL);
            break;

        case IDM_MYPICTURES:
            hr = ShowFolder(CSIDL_MYPICTURES);
            break;

        case IDM_CSC:
            _ExecRegValue(TEXT("StartMenuSyncAll"));
            break;

        default:
            hr = ExecStaticStartMenuItem(psmd->uId, FALSE, TRUE);
            break;
        }
    }
    return hr;
}

void CStartMenuCallback::_GetStaticStartMenu(HMENU* phmenu, HWND* phwnd)
{
    *phmenu = NULL;
    *phwnd = NULL;

    IMenuPopup* pmp;
    // The first one should be the bar that the start menu is sitting in.
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp))))
    {
        // Its site should be CStartMenuHost;
        if (SUCCEEDED(IUnknown_GetSite(pmp, IID_PPV_ARG(ITrayPriv, &_ptp))))
        {
            // Don't get upset if this fails
            _ptp->QueryInterface(IID_PPV_ARG(ITrayPriv2, &_ptp2));

            _ptp->GetStaticStartMenu(phmenu);
            IUnknown_GetWindow(_ptp, phwnd);

            if (!_poct)
                _ptp->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_poct));
        }
        else
            TraceMsg(TF_MENUBAND, "CStartMenuCallback::_SetSite : Failed to aquire CStartMenuHost");

        pmp->Release();
    }
}

HRESULT CStartMenuCallback::_Create(SMDATA* psmdata, void** ppvUserData)
{
    *ppvUserData = new SMUSERDATA;

    return S_OK;
}

HRESULT CStartMenuCallback::_Destroy(SMDATA* psmdata)
{
    if (psmdata->pvUserData)
    {
        delete (SMUSERDATA*)psmdata->pvUserData;
        psmdata->pvUserData = NULL;
    }

    return S_OK;
}

void CStartMenuCallbackBase::_InitializePrograms()
{
    if (!_fInitPrograms)
    {
        // We're either initing these, or reseting them.
        TCHAR szTemp[MAX_PATH];
        SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, 0, szTemp);
        Str_SetPtr(&_pszPrograms, PathFindFileName(szTemp));

        _fInitPrograms = TRUE;
    }
}



// Given a CSIDL and a Shell menu, this will verify if the IShellMenu
// is pointing at the same place as the CSIDL is. If not, then it will
// update the shell menu to the new location.
HRESULT CStartMenuCallback::VerifyCSIDL(int idCmd, int csidl, IShellMenu* psm)
{
    DWORD dwFlags;
    LPITEMIDLIST pidl;
    IShellFolder* psf;
    HRESULT hr = S_OK;
    if (SUCCEEDED(psm->GetShellFolder(&dwFlags, &pidl, IID_PPV_ARG(IShellFolder, &psf))))
    {
        psf->Release();

        LPITEMIDLIST pidlCSIDL;
        if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidlCSIDL)))
        {
            // If the pidl of the IShellMenu is not equal to the
            // SpecialFolder Location, then we need to update it so they are...
            if (!ILIsEqual(pidlCSIDL, pidl))
            {
                hr = InitializeSubShellMenu(idCmd, psm);
            }
            ILFree(pidlCSIDL);
        }
        ILFree(pidl);
    }

    return hr;
}

// This code special cases the Programs and Fast items shell menus. It
// understands Merging and will check both shell folders in a merged case
// to verify that the shell folder is still pointing at that location
HRESULT CStartMenuCallback::VerifyMergedGuy(BOOL fPrograms, IShellMenu* psm)
{
    DWORD dwFlags;
    LPITEMIDLIST pidl;
    HRESULT hr = S_OK;
    IAugmentedShellFolder2* pasf;
    if (SUCCEEDED(psm->GetShellFolder(&dwFlags, &pidl, IID_PPV_ARG(IAugmentedShellFolder2, &pasf))))
    {
        IShellFolder* psf;
        // There are 2 things in the merged namespace: CSIDL_PROGRAMS and CSIDL_COMMON_PROGRAMS
        for (int i = 0; i < 2; i++)
        {
            if (SUCCEEDED(pasf->QueryNameSpace(i, 0, &psf)))
            {
                int csidl;
                LPITEMIDLIST pidlFolder;

                if (SUCCEEDED(GetFilesystemInfo(psf, &pidlFolder, &csidl)))
                {
                    LPITEMIDLIST pidlCSIDL;
                    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidlCSIDL)))
                    {
                        // If the pidl of the IShellMenu is not equal to the
                        // SpecialFolder Location, then we need to update it so they are...
                        if (!ILIsEqual(pidlCSIDL, pidlFolder))
                        {

                            // Since one of these things has changed,
                            // we need to update the string cache
                            // so that we do proper filtering of 
                            // the programs item.
                            _fInitPrograms = FALSE;
                            if (fPrograms)
                                hr = InitializeProgramsShellMenu(psm);
                            else
                                hr = InitializeFastItemsShellMenu(psm);

                            i = 100;   // break out of the loop.
                        }
                        ILFree(pidlCSIDL);
                    }
                    ILFree(pidlFolder);
                }
                psf->Release();
            }
        }

        ILFree(pidl);
        pasf->Release();
    }

    return hr;
}

void _FixMenuItemName(IShellMenu *psm, UINT uID, LPTSTR pszNewMenuName)
{
    HMENU hMenu;
    ASSERT(NULL != psm);
    if (SUCCEEDED(psm->GetMenu(&hMenu, NULL, NULL)))
    {
        MENUITEMINFO mii = {0};
        TCHAR szMenuName[256];
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE;
        mii.dwTypeData = szMenuName;
        mii.cch = ARRAYSIZE(szMenuName);
        szMenuName[0] = TEXT('\0');
        if (::GetMenuItemInfo(hMenu, uID, FALSE, &mii))
        {
            if (0 != StrCmp(szMenuName, pszNewMenuName))
            {
                // The mydocs name has changed, update the menu item:
                mii.dwTypeData = pszNewMenuName;
                if (::SetMenuItemInfo(hMenu, uID, FALSE, &mii))
                {
                    SMDATA smd;
                    smd.dwMask = SMDM_HMENU;
                    smd.uId = uID;
                    psm->InvalidateItem(&smd, SMINV_ID | SMINV_REFRESH);
                }
            }
        }
    }
}

void CStartMenuCallback::_UpdateDocumentsShellMenu(IShellMenu* psm)
{
    // Add/Remove My Documents and My Pictures items of menu

    BOOL fMyDocs = !SHRestricted(REST_NOSMMYDOCS);
    if (fMyDocs)
    {
        LPITEMIDLIST pidl;
        fMyDocs = SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidl));
        if (fMyDocs)
            ILFree(pidl);
    }

    BOOL fMyPics = !SHRestricted(REST_NOSMMYPICS);
    if (fMyPics)
    {
        LPITEMIDLIST pidl;
        fMyPics = SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_MYPICTURES, NULL, 0, &pidl));
        if (fMyPics)
            ILFree(pidl);
    }

    // Do not update menu if not different than currently have
    if (fMyDocs != (BOOL)_fHasMyDocuments || fMyPics != (BOOL)_fHasMyPictures)
    {
        HMENU hMenu = SHLoadMenuPopup(HINST_THISDLL, MENU_STARTMENU_MYDOCS);
        if (hMenu)
        {
            if (!fMyDocs)
                DeleteMenu(hMenu, IDM_MYDOCUMENTS, MF_BYCOMMAND);
            if (!fMyPics)
                DeleteMenu(hMenu, IDM_MYPICTURES, MF_BYCOMMAND);
            // Reset section of menu
            psm->SetMenu(hMenu, _hwnd, SMSET_TOP);
        }

        // Cache what folders are available
        _fHasMyDocuments = fMyDocs;
        _fHasMyPictures = fMyPics;
    }
}

void CStartMenuCallback::_UpdateDocsMenuItemNames(IShellMenu* psm)
{
    TCHAR szBuffer[MAX_PATH];

    if (_fHasMyDocuments) 
    {
        if ( SUCCEEDED(GetMyDocumentsDisplayName(szBuffer, ARRAYSIZE(szBuffer))) )
            _FixMenuItemName(psm, IDM_MYDOCUMENTS, szBuffer);
    }

    if (_fHasMyPictures) 
    {
        if ( SUCCEEDED(GetMyPicsDisplayName(szBuffer, ARRAYSIZE(szBuffer))) )
            _FixMenuItemName(psm, IDM_MYPICTURES, szBuffer);
    }
}

HRESULT CStartMenuCallback::_Init(SMDATA* psmdata)
{
    HRESULT hr = S_FALSE;
    IShellMenu* psm;
    if (psmdata->punk && SUCCEEDED(hr = psmdata->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
    {
        switch(psmdata->uIdParent)
        {
        case IDM_TOPLEVELSTARTMENU:
        {
            if (psmdata->pvUserData && !((SMUSERDATA*)psmdata->pvUserData)->_fInitialized)
            {
                TraceMsg(TF_MENUBAND, "CStartMenuCallback::_Init : Initializing Toplevel Start Menu");
                ((SMUSERDATA*)psmdata->pvUserData)->_fInitialized = TRUE;

                HMENU hmenu;

                TraceMsg(TF_MENUBAND, "CStartMenuCallback::_Init : First Time, and correct parameters");

                _GetStaticStartMenu(&hmenu, &_hwnd);
                if (hmenu)
                {
                    HMENU   hmenuOld = NULL;
                    HWND    hwnd;
                    DWORD   dwFlags;

                    psm->GetMenu(&hmenuOld, &hwnd, &dwFlags);
                    if (hmenuOld != NULL)
                    {
                        TBOOL(DestroyMenu(hmenuOld));
                    }
                    hr = psm->SetMenu(hmenu, _hwnd, SMSET_BOTTOM);
                    TraceMsg(TF_MENUBAND, "CStartMenuCallback::_Init : SetMenu(HMENU 0x%x, HWND 0x%x", hmenu, _hwnd);
                }

                _fExpandoMenus = !_fIsStartPanel && AreIntelliMenusEnabled();
                _fCascadeMyDocuments = FeatureEnabled(TEXT("CascadeMyDocuments"));
                _fCascadePrinters = FeatureEnabled(TEXT("CascadePrinters"));
                _fCascadeControlPanel = FeatureEnabled(TEXT("CascadeControlPanel"));
                _fCascadeNetConnections = FeatureEnabled(TEXT("CascadeNetworkConnections"));
                _fAddOpenFolder = FeatureEnabled(TEXT("StartMenuOpen"));
                _fShowInfoTip = FeatureEnabled(TEXT("ShowInfoTip"));
                _fCascadeMyPictures = FeatureEnabled(TEXT("CascadeMyPictures"));
                _dwFlags = GetInitFlags();
            }
            else if (!_fInitedShowTopLevelStartMenu)
            {
                _fInitedShowTopLevelStartMenu = TRUE;
                psm->InvalidateItem(NULL, SMINV_REFRESH);
            }

            // Verify that the Fast items is still pointing to the right location
            if (SUCCEEDED(hr))
            {
                hr = VerifyMergedGuy(FALSE, psm);
            }
            break;
        }
        case IDM_MENU_FIND:
            if (_fFindMenuInvalid)
            {
                hr = _InitializeFindMenu(psm);
                _fFindMenuInvalid = FALSE;
            }
            break;

        case IDM_PROGRAMS:
            // Verify the programs menu is still pointing to the right location
            hr = VerifyMergedGuy(TRUE, psm);
            break;

        case IDM_FAVORITES:
            hr = VerifyCSIDL(IDM_FAVORITES, CSIDL_FAVORITES, psm);
            break;

        case IDM_MYDOCUMENTS:
            hr = VerifyCSIDL(IDM_MYDOCUMENTS, CSIDL_PERSONAL, psm);
            break;

        case IDM_MYPICTURES:
            hr = VerifyCSIDL(IDM_MYPICTURES, CSIDL_MYPICTURES, psm);
            break;

        case IDM_RECENT:
            _UpdateDocumentsShellMenu(psm);
            _UpdateDocsMenuItemNames(psm);
            hr = VerifyCSIDL(IDM_RECENT, CSIDL_RECENT, psm);
            break;
        case IDM_CONTROLS:
            hr = VerifyCSIDL(IDM_CONTROLS, CSIDL_CONTROLS, psm);
            break;
        case IDM_PRINTERS:
            hr = VerifyCSIDL(IDM_PRINTERS, CSIDL_PRINTERS, psm);
            break;
        }

        psm->Release();
    }

    return hr;
}


HRESULT CStartMenuCallback::_GetStaticInfoTip(SMDATA* psmd, LPWSTR pszTip, int cch)
{
    if (!_fShowInfoTip)
        return E_FAIL;

    HRESULT hr = E_FAIL;

    const static struct 
    {
        UINT idCmd;
        UINT idInfoTip;
    } s_mpcmdTip[] = 
    {
#if 0   // No tips for the Toplevel. Keep this here because I bet that someone will want them...
       { IDM_PROGRAMS,       IDS_PROGRAMS_TIP },
       { IDM_FAVORITES,      IDS_FAVORITES_TIP },
       { IDM_RECENT,         IDS_RECENT_TIP },
       { IDM_SETTINGS,       IDS_SETTINGS_TIP },
       { IDM_MENU_FIND,      IDS_FIND_TIP },
       { IDM_HELPSEARCH,     IDS_HELP_TIP },        // Redundant?
       { IDM_FILERUN,        IDS_RUN_TIP },
       { IDM_LOGOFF,         IDS_LOGOFF_TIP },
       { IDM_EJECTPC,        IDS_EJECT_TIP },
       { IDM_EXITWIN,        IDS_SHUTDOWN_TIP },
#endif
       // Settings Submenu
       { IDM_CONTROLS,       IDS_CONTROL_TIP },
       { IDM_PRINTERS,       IDS_PRINTERS_TIP },
       { IDM_TRAYPROPERTIES, IDS_TRAYPROP_TIP },
       { IDM_NETCONNECT,     IDS_NETCONNECT_TIP },

       // Recent Folder
       { IDM_MYDOCUMENTS,    IDS_MYDOCS_TIP },
       { IDM_MYPICTURES,     IDS_MYPICS_TIP },
     };


    for (int i = 0; i < ARRAYSIZE(s_mpcmdTip); i++)
    {
        if (s_mpcmdTip[i].idCmd == psmd->uId)
        {
            TCHAR szTip[MAX_PATH];
            if (LoadString(g_hinst, s_mpcmdTip[i].idInfoTip, szTip, ARRAYSIZE(szTip)))
            {
                SHTCharToUnicode(szTip, pszTip, cch);
                hr = S_OK;
            }
            break;
        }
    }

    return hr;
}

typedef struct
{
    WCHAR wszMenuText[MAX_PATH];
    WCHAR wszHelpText[MAX_PATH];
    int   iIcon;
} SEARCHEXTDATA, *LPSEARCHEXTDATA;

HRESULT CStartMenuCallback::_GetHmenuInfo(SMDATA* psmd, SMINFO* psminfo)
{
    const static struct 
    {
        UINT idCmd;
        int  iImage;
    } s_mpcmdimg[] = { // Top level menu
                       { IDM_PROGRAMS,       -IDI_CLASSICSM_PROGS },
                       { IDM_FAVORITES,      -IDI_CLASSICSM_FAVORITES },
                       { IDM_RECENT,         -IDI_CLASSICSM_RECENTDOCS },
                       { IDM_SETTINGS,       -IDI_CLASSICSM_SETTINGS },
                       { IDM_MENU_FIND,      -IDI_CLASSICSM_FIND },
                       { IDM_HELPSEARCH,     -IDI_CLASSICSM_HELP },
                       { IDM_FILERUN,        -IDI_CLASSICSM_RUN },
                       { IDM_LOGOFF,         -IDI_CLASSICSM_LOGOFF },
                       { IDM_EJECTPC,        -IDI_CLASSICSM_UNDOCK },
                       { IDM_EXITWIN,        -IDI_CLASSICSM_SHUTDOWN },
                       { IDM_MU_SECURITY,    II_MU_STSECURITY },
                       { IDM_MU_DISCONNECT,  II_MU_STDISCONN  },
                       { IDM_SETTINGSASSIST, -IDI_CLASSICSM_SETTINGS },
                       { IDM_CONTROLS,       II_STCPANEL },
                       { IDM_PRINTERS,       II_STPRNTRS },
                       { IDM_TRAYPROPERTIES, II_STTASKBR },
                       { IDM_MYDOCUMENTS,    -IDI_MYDOCS},
                       { IDM_CSC,            -IDI_CSC},
                       { IDM_NETCONNECT,     -IDI_NETCONNECT},
                     };


    ASSERT(IS_VALID_WRITE_PTR(psminfo, SMINFO));

    int iIcon = -1;
    DWORD dwFlags = psminfo->dwFlags;
    MENUITEMINFO mii = {0};
    HRESULT hr = S_FALSE;

    if (psminfo->dwMask & SMIM_ICON)
    {
        if (IsInRange(psmd->uId, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST))
        {
            // The find menu extensions pack their icon into their data member of
            // Menuiteminfo....
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_DATA;
            if (GetMenuItemInfo(psmd->hmenu, psmd->uId, MF_BYCOMMAND, &mii))
            {
                LPSEARCHEXTDATA psed = (LPSEARCHEXTDATA)mii.dwItemData;

                if (psed)
                    psminfo->iIcon = psed->iIcon;
                else
                    psminfo->iIcon = -1;

                dwFlags |= SMIF_ICON;
                hr = S_OK;
            }
        }
        else
        {
            if (psmd->uId == IDM_MYPICTURES)
            {
                LPITEMIDLIST pidlMyPics = SHCloneSpecialIDList(NULL, CSIDL_MYPICTURES, FALSE);
                if (pidlMyPics)
                {
                    LPCITEMIDLIST pidlObject;
                    IShellFolder *psf;
                    hr = SHBindToParent(pidlMyPics, IID_PPV_ARG(IShellFolder, &psf), &pidlObject);
                    if (SUCCEEDED(hr))
                    {
                        SHMapPIDLToSystemImageListIndex(psf, pidlObject, &psminfo->iIcon);
                        dwFlags |= SMIF_ICON;
                        psf->Release();
                    }
                    ILFree(pidlMyPics);
                }
            }
            else
            {
                UINT uIdLocal = psmd->uId;
                if (uIdLocal == IDM_OPEN_FOLDER)
                    uIdLocal = psmd->uIdAncestor;

                for (int i = 0; i < ARRAYSIZE(s_mpcmdimg); i++)
                {
                    if (s_mpcmdimg[i].idCmd == uIdLocal)
                    {
                        iIcon = s_mpcmdimg[i].iImage;
                        break;
                    }
                }

                if (iIcon != -1)
                {
                    dwFlags |= SMIF_ICON;
                    psminfo->iIcon = Shell_GetCachedImageIndex(TEXT("shell32.dll"), iIcon, 0);
                    hr = S_OK;
                }
            }
        }
    }

    if (psminfo->dwMask & SMIM_FLAGS)
    {
        psminfo->dwFlags = dwFlags;

        if ( (psmd->uId == IDM_CONTROLS    && _fCascadeControlPanel   ) ||
             (psmd->uId == IDM_PRINTERS    && _fCascadePrinters       ) ||
             (psmd->uId == IDM_MYDOCUMENTS && _fCascadeMyDocuments    ) ||
             (psmd->uId == IDM_NETCONNECT  && _fCascadeNetConnections ) ||
             (psmd->uId == IDM_MYPICTURES  && _fCascadeMyPictures     ) )
        {
            psminfo->dwFlags |= SMIF_SUBMENU;
            hr = S_OK;
        }
        else switch (psmd->uId)
        {
        case IDM_FAVORITES:
        case IDM_PROGRAMS:
            psminfo->dwFlags |= SMIF_DROPCASCADE;
            hr = S_OK;
            break;
        }
    }

    return hr;
}

DWORD CStartMenuCallback::_GetDemote(SMDATA* psmd)
{
    UEMINFO uei;
    DWORD dwFlags = 0;

    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT;
    if (SUCCEEDED(UEMQueryEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
        UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei)))
    {
        if (uei.cHit == 0) 
        {
            dwFlags |= SMIF_DEMOTED;
        }
    }

    return dwFlags;
}

//
//  WARNING!  Since this function returns a pointer from our Darwin cache,
//  it must be called while the Darwin critical section is held.
//
int GetDarwinIndex(LPCITEMIDLIST pidlFull, CDarwinAd** ppda)
{
    int iRet = -1;
    if (g_hdpaDarwinAds)
    {
        int chdpa = DPA_GetPtrCount(g_hdpaDarwinAds);
        for (int ihdpa = 0; ihdpa < chdpa; ihdpa++)
        {
            *ppda = (CDarwinAd*)DPA_FastGetPtr(g_hdpaDarwinAds, ihdpa);
            if (*ppda)
            {
                if (ILIsEqual((*ppda)->_pidl, pidlFull))
                {
                    iRet = ihdpa;
                    break;
                }
            }
        }
    }
    return iRet;
}

BOOL CStartMenuCallbackBase::_IsDarwinAdvertisement(LPCITEMIDLIST pidlFull)
{
    // What this is doing is comparing the passed in pidl with the
    // list of pidls in g_hdpaDarwinAds. That hdpa contains a list of
    // pidls that are darwin ads.

    // If the background thread is not done, then we must assume that
    // it has not processed the shortcut that we are on. That is why we process it
    // in line.


    ENTERCRITICAL_DARWINADS;

    // NOTE: There can be two items in the hdpa. This is ok.
    BOOL fAd = FALSE;
    CDarwinAd* pda = NULL;
    int iIndex = GetDarwinIndex(pidlFull, &pda);
    // Are there any ads?
    if (iIndex != -1 && pda != NULL)
    {
        //This is a Darwin pidl. Is it installed?
        fAd = pda->IsAd();
    }

    LEAVECRITICAL_DARWINADS;

    return fAd;
}

STDAPI SHParseDarwinIDFromCacheW(LPWSTR pszDarwinDescriptor, LPWSTR *ppwszOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (g_hdpaDarwinAds)
    {
        ENTERCRITICAL_DARWINADS;
        int chdpa = DPA_GetPtrCount(g_hdpaDarwinAds);
        for (int ihdpa = 0; ihdpa < chdpa; ihdpa++)
        {
            CDarwinAd *pda = (CDarwinAd*)DPA_FastGetPtr(g_hdpaDarwinAds, ihdpa);
            if (pda && pda->_pszLocalPath && pda->_pszDescriptor &&
                StrCmpCW(pszDarwinDescriptor, pda->_pszDescriptor) == 0)
            {
                hr = SHStrDupW(pda->_pszLocalPath, ppwszOut);
                break;
            }
        }
        LEAVECRITICAL_DARWINADS;
    }

    return hr;
}


// REARCHITECT (lamadio): There is a duplicate of this helper in browseui\browmenu.cpp
//                   When modifying this, rev that one as well.
void UEMRenamePidl(const GUID *pguidGrp1, IShellFolder* psf1, LPCITEMIDLIST pidl1,
                   const GUID *pguidGrp2, IShellFolder* psf2, LPCITEMIDLIST pidl2)
{
    UEMINFO uei;
    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT | UEIM_FILETIME;
    if (SUCCEEDED(UEMQueryEvent(pguidGrp1, 
                                UEME_RUNPIDL, (WPARAM)psf1, 
                                (LPARAM)pidl1, &uei)) &&
                                uei.cHit > 0)
    {
        UEMSetEvent(pguidGrp2, 
            UEME_RUNPIDL, (WPARAM)psf2, (LPARAM)pidl2, &uei);

        uei.cHit = 0;
        UEMSetEvent(pguidGrp1, 
            UEME_RUNPIDL, (WPARAM)psf1, (LPARAM)pidl1, &uei);
    }
}

// REARCHITECT (lamadio): There is a duplicate of this helper in browseui\browmenu.cpp
//                   When modifying this, rev that one as well.
void UEMDeletePidl(const GUID *pguidGrp, IShellFolder* psf, LPCITEMIDLIST pidl)
{
    UEMINFO uei;
    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT;
    uei.cHit = 0;
    UEMSetEvent(pguidGrp, UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
}

//
//  Sortof safe version of ILIsParent which catches when pidlParent or
//  pidlBelow is NULL.  pidlParent can be NULL on systems that don't
//  have a Common Program Files folder.  pidlBelow should never be NULL
//  but it doesn't hurt to check.
//
STDAPI_(BOOL) SMILIsAncestor(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlBelow)
{
    if (pidlParent && pidlBelow)
        return ILIsParent(pidlParent, pidlBelow, FALSE);
    else
        return FALSE;
}

HRESULT CStartMenuCallbackBase::_ProcessChangeNotify(SMDATA* psmd, LONG lEvent,
                                                 LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    switch (lEvent)
    {
    case SHCNE_ASSOCCHANGED:
        SHReValidateDarwinCache();
        return S_OK;

    case SHCNE_RENAMEFOLDER:
        // NTRAID89654-2000/03/13 (lamadio): We should move the MenuOrder stream as well. 5.5.99
    case SHCNE_RENAMEITEM:
        {
            LPITEMIDLIST pidlPrograms;
            LPITEMIDLIST pidlProgramsCommon;
            LPITEMIDLIST pidlFavorites;
            SHGetFolderLocation(NULL, CSIDL_PROGRAMS, NULL, 0, &pidlPrograms);
            SHGetFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, &pidlProgramsCommon);
            SHGetFolderLocation(NULL, CSIDL_FAVORITES, NULL, 0, &pidlFavorites);

            BOOL fPidl1InStartMenu =    SMILIsAncestor(pidlPrograms, pidl1) ||
                                        SMILIsAncestor(pidlProgramsCommon, pidl1);
            BOOL fPidl1InFavorites =    SMILIsAncestor(pidlFavorites, pidl1);


            // If we're renaming something from the Start Menu
            if ( fPidl1InStartMenu ||fPidl1InFavorites)
            {
                IShellFolder* psfFrom;
                LPCITEMIDLIST pidlFrom;
                if (SUCCEEDED(SHBindToParent(pidl1, IID_PPV_ARG(IShellFolder, &psfFrom), &pidlFrom)))
                {
                    // Into the Start Menu
                    BOOL fPidl2InStartMenu =    SMILIsAncestor(pidlPrograms, pidl2) ||
                                                SMILIsAncestor(pidlProgramsCommon, pidl2);
                    BOOL fPidl2InFavorites =    SMILIsAncestor(pidlFavorites, pidl2);
                    if (fPidl2InStartMenu || fPidl2InFavorites)
                    {
                        IShellFolder* psfTo;
                        LPCITEMIDLIST pidlTo;

                        if (SUCCEEDED(SHBindToParent(pidl2, IID_PPV_ARG(IShellFolder, &psfTo), &pidlTo)))
                        {
                            // Then we need to rename it
                            UEMRenamePidl(fPidl1InStartMenu ? &UEMIID_SHELL: &UEMIID_BROWSER, 
                                            psfFrom, pidlFrom, 
                                          fPidl2InStartMenu ? &UEMIID_SHELL: &UEMIID_BROWSER, 
                                            psfTo, pidlTo);
                            psfTo->Release();
                        }
                    }
                    else
                    {
                        // Otherwise, we delete it.
                        UEMDeletePidl(fPidl1InStartMenu ? &UEMIID_SHELL : &UEMIID_BROWSER, 
                            psfFrom, pidlFrom);
                    }

                    psfFrom->Release();
                }
            }

            ILFree(pidlPrograms);
            ILFree(pidlProgramsCommon);
            ILFree(pidlFavorites);
        }
        break;

    case SHCNE_DELETE:
        // NTRAID89654-2000/03/13 (lamadio): We should nuke the MenuOrder stream as well. 5.5.99
    case SHCNE_RMDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(SHBindToParent(pidl1, IID_PPV_ARG(IShellFolder, &psf), &pidl)))
            {
                // NOTE favorites is the only that will be initialized
                UEMDeletePidl(psmd->uIdAncestor == IDM_FAVORITES ? &UEMIID_BROWSER : &UEMIID_SHELL, 
                    psf, pidl);
                psf->Release();
            }

        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(SHBindToParent(pidl1, IID_PPV_ARG(IShellFolder, &psf), &pidl)))
            {
                UEMINFO uei;
                uei.cbSize = sizeof(uei);
                uei.dwMask = UEIM_HIT;
                uei.cHit = UEM_NEWITEMCOUNT;
                UEMSetEvent(psmd->uIdAncestor == IDM_FAVORITES? &UEMIID_BROWSER: &UEMIID_SHELL, 
                    UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
                psf->Release();
            }

        }
        break;
    }

    return S_FALSE;
}

HRESULT CStartMenuCallbackBase::_GetSFInfo(SMDATA* psmd, SMINFO* psminfo)
{
    if (psminfo->dwMask & SMIM_FLAGS &&
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        if (_fExpandoMenus)
        {
            psminfo->dwFlags |= _GetDemote(psmd);
        }

        // This is a little backwards. If the Restriction is On, Then we allow the feature.
        if (SHRestricted(REST_GREYMSIADS) &&
            psmd->uIdAncestor == IDM_PROGRAMS)
        {
            LPITEMIDLIST pidlFull = FullPidlFromSMData(psmd);
            if (pidlFull)
            {
                if (_IsDarwinAdvertisement(pidlFull))
                {
                    psminfo->dwFlags |= SMIF_ALTSTATE;
                }
                ILFree(pidlFull);
            }
        }

        if (_ptp2)
        {
            _ptp2->ModifySMInfo(psmd, psminfo);
        }
    }
    return S_OK;
}

STDAPI_(void) SHReValidateDarwinCache()
{
    if (g_hdpaDarwinAds)
    {
        ENTERCRITICAL_DARWINADS;
        int chdpa = DPA_GetPtrCount(g_hdpaDarwinAds);
        for (int ihdpa = 0; ihdpa < chdpa; ihdpa++)
        {
            CDarwinAd* pda = (CDarwinAd*)DPA_FastGetPtr(g_hdpaDarwinAds, ihdpa);
            if (pda)
            {
                pda->CheckInstalled();
            }
        }
        LEAVECRITICAL_DARWINADS;
    }
}

// Determines if a CSIDL is a child of another CSIDL
// e.g.
//  CSIDL_STARTMENU = c:\foo\bar\Start Menu
//  CSIDL_PROGRAMS  = c:\foo\bar\Start Menu\Programs
//  Return true
BOOL IsCSIDLChild(int csidlParent, int csidlChild)
{
    BOOL fChild = FALSE;
    TCHAR sz1[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, csidlParent, NULL, 0, sz1)))
    {
        TCHAR sz2[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, csidlChild, NULL, 0, sz2)))
        {
            TCHAR szCommonRoot[MAX_PATH];
            if (PathCommonPrefix(sz1, sz2, szCommonRoot) ==
                lstrlen(sz1))
            {
                fChild = TRUE;
            }
        }
    }

    return fChild;
}

//
// Now StartMenuChange value is stored seperately for classic startmenu and new startmenu.
// So, we need to check which one is currently on before we read the value.
//
BOOL IsStartMenuChangeNotAllowed(BOOL fStartPanel)
{
    return(IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOCHANGESTARMENU, 
                    TEXT("Advanced"), 
                    (fStartPanel ? TEXT("Start_EnableDragDrop") : TEXT("StartMenuChange")), 
                    ROUS_DEFAULTALLOW | ROUS_KEYALLOWS));
}

// Creates the "Start Menu\\Programs" section of the start menu by
// generating a Merged Shell folder, setting the locations into that item
// then sets it into the passed IShellMenu.
HRESULT CStartMenuCallbackBase::InitializeProgramsShellMenu(IShellMenu* psm)
{
    HKEY hkeyPrograms = NULL;
    LPITEMIDLIST pidl = NULL;

    DWORD dwInitFlags = SMINIT_VERTICAL;
    if (!FeatureEnabled(_fIsStartPanel ? TEXT("Start_ScrollPrograms") : TEXT("StartMenuScrollPrograms")))
        dwInitFlags |= SMINIT_MULTICOLUMN;

    if (IsStartMenuChangeNotAllowed(_fIsStartPanel))
        dwInitFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;

    if (_fIsStartPanel)
        dwInitFlags |= SMINIT_TOPLEVEL;

    HRESULT hr = psm->Initialize(this, IDM_PROGRAMS, IDM_PROGRAMS, dwInitFlags);
    if (SUCCEEDED(hr))
    {
        _InitializePrograms();

        LPCTSTR pszOrderKey = _fIsStartPanel ?
                STRREG_STARTMENU2 TEXT("\\Programs") :
                STRREG_STARTMENU TEXT("\\Programs");

        // setshellfolder calls need read and write key
        RegCreateKeyEx(HKEY_CURRENT_USER, pszOrderKey, NULL, NULL,
            REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
            NULL, &hkeyPrograms, NULL);

        IShellFolder* psf;
        BOOL fOptimize = FALSE;
        DWORD dwSmset = SMSET_TOP;

        if (_fIsStartPanel)
        {
            // Start Panel: Menu:  The Programs section is a merge of the
            // Fast Items and Programs folders with a separator between them.
            dwSmset |= SMSET_SEPARATEMERGEFOLDER;
            hr = GetMergedFolder(&psf, &pidl, c_rgmfiProgramsFolderAndFastItems,
                                 ARRAYSIZE(c_rgmfiProgramsFolderAndFastItems));
        }
        else
        {
            // Classic Start Menu:  The Programs section is just the per-user
            // and common Programs folders merged together
            hr = GetMergedFolder(&psf, &pidl, c_rgmfiProgramsFolder,
                                 ARRAYSIZE(c_rgmfiProgramsFolder));

            // We used to register for change notify at CSIDL_STARTMENU and assumed
            // that CSIDL_PROGRAMS was a child of CSIDL_STARTMENU. Since this wasn't always the 
            // case, I removed the optimization.

            // Both panes are registered recursive. So, When CSIDL_PROGRAMS _IS_ a 
            // child of CSIDL_STARTMENU we can enter a code path where when destroying 
            // CSIDL_PROGRAMS, we unregister it. This will flush the change nofiy queue 
            // of CSIDL_STARTMENU, and blow away all of the children, including CSIDL_PROGRAMS, 
            // while we are in the middle of destroying it... See the problem? I have been adding 
            // reentrance "Blockers" but this only delayed where we crashed. 
            // What was needed was to determine if Programs was a child of the Start Menu directory.
            // if it was we need to add the optmimization. If it's not we don't have a problem.

            // WINDOWS BUG 135156(tybeam): If one of the two is redirected, then this will get optimized
            // we can't do better than this because both are registed recursive, and this will fault...
            fOptimize = IsCSIDLChild(CSIDL_STARTMENU, CSIDL_PROGRAMS)
                || IsCSIDLChild(CSIDL_COMMON_STARTMENU, CSIDL_COMMON_PROGRAMS);
            if (fOptimize)
            {
                dwSmset |= SMSET_DONTREGISTERCHANGENOTIFY;
            }
        }

        if (SUCCEEDED(hr))
        {
            // We should have a pidl from CSIDL_Programs
            ASSERT(pidl);

            // We should have a shell folder from the bind.
            ASSERT(psf);

            hr = psm->SetShellFolder(psf, pidl, hkeyPrograms, dwSmset);
            psf->Release();
            ILFree(pidl);                        
        }

        if (FAILED(hr))
            RegCloseKey(hkeyPrograms);
    }

    return hr;
}

HRESULT GetFolderAndPidl(UINT csidl, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    *ppsf = NULL;
    HRESULT hr = SHGetFolderLocation(NULL, csidl, NULL, 0, ppidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, *ppidl, ppsf));
        if (FAILED(hr))
        {
            ILFree(*ppidl);
            *ppidl = NULL;
        }
    }
    return hr;
}

// Creates the "Start Menu\\<csidl>" section of the start menu by
// looking up the csidl, generating the Hkey from HKCU\pszRoot\pszValue,
//  Initializing the IShellMenu with dwPassInitFlags, then setting the locations 
// into the passed IShellMenu passing the flags dwSetFlags.
HRESULT CStartMenuCallback::InitializeCSIDLShellMenu(int uId, int csidl, LPTSTR pszRoot, LPTSTR pszValue,
                                                 DWORD dwPassInitFlags, DWORD dwSetFlags, BOOL fAddOpen,
                                                 IShellMenu* psm)
{
    DWORD dwInitFlags = SMINIT_VERTICAL | dwPassInitFlags;

    if (IsStartMenuChangeNotAllowed(_fIsStartPanel))
        dwInitFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;

    psm->Initialize(this, uId, uId, dwInitFlags);

    LPITEMIDLIST pidl;
    IShellFolder* psfFolder;
    HRESULT hr = GetFolderAndPidl(csidl, &psfFolder, &pidl);
    if (SUCCEEDED(hr))
    {
        HKEY hKey = NULL;

        if (pszRoot)
        {
            TCHAR szPath[MAX_PATH];
            StrCpyN(szPath, pszRoot, ARRAYSIZE(szPath));
            if (pszValue)
            {
                PathAppend(szPath, pszValue);
            }

            // setshellfolder calls need read and write key
            RegCreateKeyEx(HKEY_CURRENT_USER, szPath, NULL, NULL,
                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                NULL, &hKey, NULL);
        }

        // Point the menu to the shellfolder
        hr = psm->SetShellFolder(psfFolder, pidl, hKey, dwSetFlags);
        if (SUCCEEDED(hr))
        {
            if (fAddOpen && _fAddOpenFolder)
            {
                HMENU hMenu = SHLoadMenuPopup(HINST_THISDLL, MENU_STARTMENU_OPENFOLDER);
                if (hMenu)
                {
                    psm->SetMenu(hMenu, _hwnd, SMSET_BOTTOM);
                }
            }
        }
        else
            RegCloseKey(hKey);

        psfFolder->Release();
        ILFree(pidl);
    }

    return hr;
}

// This generates the Recent | My Documents, My Pictures sub menu.
HRESULT CStartMenuCallback::InitializeDocumentsShellMenu(IShellMenu* psm)
{
    HRESULT hr = InitializeCSIDLShellMenu(IDM_RECENT, CSIDL_RECENT, NULL, NULL,
                                SMINIT_RESTRICT_DRAGDROP, SMSET_BOTTOM, FALSE,
                                psm);

    // Initializing, reset cache bits for top part of menu
    _fHasMyDocuments = FALSE;
    _fHasMyPictures = FALSE;

    return hr;
}

HRESULT CStartMenuCallback::InitializeFastItemsShellMenu(IShellMenu* psm)
{
    DWORD dwFlags = SMINIT_TOPLEVEL | SMINIT_VERTICAL;

    if (IsStartMenuChangeNotAllowed(_fIsStartPanel))
        dwFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;

    HRESULT hr = psm->Initialize(this, 0, ANCESTORDEFAULT, dwFlags);
    if (SUCCEEDED(hr))
    {
        _InitializePrograms();

        // Add the fast item folder to the top of the menu
        IShellFolder* psfFast;
        LPITEMIDLIST pidlFast;
        hr = GetMergedFolder(&psfFast, &pidlFast, c_rgmfiStartMenu, ARRAYSIZE(c_rgmfiStartMenu));
        if (SUCCEEDED(hr))
        {
            HKEY hMenuKey = NULL;   // WARNING: pmb2->Initialize() will always owns hMenuKey, so don't close it

            // setshellfolder calls need read and write key
            RegCreateKeyEx(HKEY_CURRENT_USER, STRREG_STARTMENU, NULL, NULL,
                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                NULL, &hMenuKey, NULL);

            TraceMsg(TF_MENUBAND, "Root Start Menu Key Is %d", hMenuKey);
            hr = psm->SetShellFolder(psfFast, pidlFast, hMenuKey, SMSET_TOP | SMSET_NOEMPTY);

            psfFast->Release();
            ILFree(pidlFast);
        }
    }

    return hr;
}

HRESULT CStartMenuCallback::_InitializeFindMenu(IShellMenu* psm)
{
    HRESULT hr = E_FAIL;

    psm->Initialize(this, IDM_MENU_FIND, IDM_MENU_FIND, SMINIT_VERTICAL);

    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        ATOMICRELEASE(_pcmFind);

        if (_ptp)
        {
            if (SUCCEEDED(_ptp->GetFindCM(hmenu, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST, &_pcmFind)))
            {
                IContextMenu2 *pcm2;
                _pcmFind->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm2));
                if (pcm2)
                {
                    pcm2->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenu, 0);
                    pcm2->Release();
                }
            }

            if (_pcmFind)
            {
                hr = psm->SetMenu(hmenu, NULL, SMSET_TOP);
                // Don't Release _pcmFind
            }
        }

        // Since we failed to create the ShellMenu
        // we need to dispose of this HMENU
        if (FAILED(hr))
            DestroyMenu(hmenu);
    }

    return hr;
}

HRESULT CStartMenuCallback::InitializeSubShellMenu(int idCmd, IShellMenu* psm)
{
    HRESULT hr = E_FAIL;

    switch(idCmd)
    {
    case IDM_PROGRAMS:
        hr = InitializeProgramsShellMenu(psm);
        break;

    case IDM_RECENT:
        hr = InitializeDocumentsShellMenu(psm);
        break;

    case IDM_MENU_FIND:
        hr = _InitializeFindMenu(psm);
        break;

    case IDM_FAVORITES:
        hr = InitializeCSIDLShellMenu(IDM_FAVORITES, CSIDL_FAVORITES, STRREG_FAVORITES,
                             NULL, 0, SMSET_HASEXPANDABLEFOLDERS | SMSET_USEBKICONEXTRACTION, FALSE,
                             psm);
        break;
    
    case IDM_CONTROLS:
        hr = InitializeCSIDLShellMenu(IDM_CONTROLS, CSIDL_CONTROLS, STRREG_STARTMENU,
                             TEXT("ControlPanel"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_PRINTERS:
        hr = InitializeCSIDLShellMenu(IDM_PRINTERS, CSIDL_PRINTERS, STRREG_STARTMENU,
                             TEXT("Printers"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_MYDOCUMENTS:
        hr = InitializeCSIDLShellMenu(IDM_MYDOCUMENTS, CSIDL_PERSONAL, STRREG_STARTMENU,
                             TEXT("MyDocuments"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_MYPICTURES:
        hr = InitializeCSIDLShellMenu(IDM_MYPICTURES, CSIDL_MYPICTURES, STRREG_STARTMENU,
                             TEXT("MyPictures"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_NETCONNECT:
        hr = InitializeCSIDLShellMenu(IDM_NETCONNECT, CSIDL_CONNECTIONS, STRREG_STARTMENU,
                             TEXT("NetConnections"), 0, 0,  TRUE,
                             psm);
        break;
    }

    return hr;
}

HRESULT CStartMenuCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvOut)
{
    HRESULT hr = E_FAIL;
    UINT    uId = psmd->uId;

    ASSERT(ppvOut);
    ASSERT(IS_VALID_READ_PTR(psmd, SMDATA));

    *ppvOut = NULL;

    if (IsEqualGUID(riid, IID_IShellMenu))
    {
        IShellMenu* psm = NULL;
        hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hr))
        {
            hr = InitializeSubShellMenu(uId, psm);
 
            if (FAILED(hr))
            {
                psm->Release();
                psm = NULL;
            }
        }

        *ppvOut = psm;
    }
    else if (IsEqualGUID(riid, IID_IContextMenu))
    {
        //
        //  NOTE - we dont allow users to open the recent folder this way - ZekeL - 1-JUN-99
        //  because this is really an internal folder and not a user folder.
        //
        
        switch (uId)
        {
        case IDM_PROGRAMS:
        case IDM_FAVORITES:
        case IDM_MYDOCUMENTS:
        case IDM_MYPICTURES:
        case IDM_CONTROLS:
        case IDM_PRINTERS:
        case IDM_NETCONNECT:
            {
                CStartContextMenu* pcm = new CStartContextMenu(uId);
                if (pcm)
                {
                    hr = pcm->QueryInterface(riid, ppvOut);
                    pcm->Release();
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

//
//  Return S_OK to remove the pidl from enumeration
//
HRESULT CStartMenuCallbackBase::_FilterPidl(UINT uParent, IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    
    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    
    if (uParent == IDM_PROGRAMS || uParent == IDM_TOPLEVELSTARTMENU)
    {
        TCHAR szChild[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szChild, ARRAYSIZE(szChild))))
        {
            // HACKHACK (lamadio): This code assumes that the Display name
            // of the Programs and Commons Programs folders are the same. It
            // also assumes that the "programs" folder in the Start Menu folder
            // is the same name as the one pointed to by CSIDL_PROGRAMS.
            // Filter from top level start menu:
            //      Programs, Windows Update, Configure Programs
            if (_IsTopLevelStartMenu(uParent, psf, pidl))
            {
                if ((_pszPrograms && (0 == lstrcmpi(szChild, _pszPrograms))) ||
                    (SHRestricted(REST_NOUPDATEWINDOWS) && _pszWindowsUpdate && (0 == lstrcmpi(szChild, _pszWindowsUpdate))) ||
                    (SHRestricted(REST_NOSMCONFIGUREPROGRAMS) && _pszConfigurePrograms && (0 == lstrcmpi(szChild, _pszConfigurePrograms))))
                {
                    hr = S_OK;
                }
            }
            else
            {
                // IDM_PROGRAMS
                // Filter from Programs:  Administrative tools.
                if (!_fShowAdminTools && _pszAdminTools && lstrcmpi(szChild, _pszAdminTools) == 0)
                {
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

BOOL LinkGetInnerPidl(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlOut, DWORD *pdwAttr)
{
    *ppidlOut = NULL;

    IShellLink *psl;
    HRESULT hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLink, NULL, &psl));
    if (SUCCEEDED(hr))
    {
        psl->GetIDList(ppidlOut);

        if (*ppidlOut)
        {
            if (FAILED(SHGetAttributesOf(*ppidlOut, pdwAttr)))
            {
                ILFree(*ppidlOut);
                *ppidlOut = NULL;
            }
        }
        psl->Release();
    }
    return (*ppidlOut != NULL);
}


//
//  _FilterRecentPidl() 
//  the Recent Documents folder can now (NT5) have more than 15 or 
//  so documents, but we only want to show the 15 most recent that we always have on
//  the start menu.  this means that we need to filter out all folders and 
//  anything more than MAXRECENTDOCS
//
HRESULT CStartMenuCallback::_FilterRecentPidl(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(_cRecentDocs != -1);
    
    ASSERT(_cRecentDocs <= MAXRECENTDOCS);
    
    //  if we already reached our limit, dont go over...
    if (_pmruRecent && (_cRecentDocs < MAXRECENTDOCS))
    {
        //  we now must take a looksee for it...
        int iItem;
        DWORD dwAttr = SFGAO_FOLDER | SFGAO_BROWSABLE;
        LPITEMIDLIST pidlTrue;

        //  need to find out if the link points to a folder...
        //  because we dont want
        if (SUCCEEDED(_pmruRecent->FindData((BYTE *) pidl, ILGetSize(pidl), &iItem))
        && LinkGetInnerPidl(psf, pidl, &pidlTrue, &dwAttr))
        {
            if (!(dwAttr & SFGAO_FOLDER))
            {
                //  we have a link to something that isnt a folder 
                hr = S_FALSE;
                _cRecentDocs++;
            }

            ILFree(pidlTrue);
        }
    }
                
    //  return S_OK if you dont want to show this item...

    return hr;
}


HRESULT CStartMenuCallback::_HandleAccelerator(TCHAR ch, SMDATA* psmdata)
{
    // Since we renamed the 'Find' menu to 'Search' the PMs wanted to have
    // an upgrade path for users (So they can continue to use the old accelerator
    // on the new menu item.)
    // To enable this, when toolbar detects that there is not an item in the menu
    // that contains the key that has been pressed, then it sends a TBN_ACCL.
    // This is intercepted by mnbase, and translated into SMC_ACCEL. 
    if (CharUpper((LPTSTR)ch) == CharUpper((LPTSTR)_szFindMnemonic[0]))
    {
        psmdata->uId = IDM_MENU_FIND;
        return S_OK;
    }

    return S_FALSE;
}

HRESULT CStartMenuCallback::_GetTip(LPWSTR pstrTitle, LPWSTR pstrTip)
{
    if (pstrTitle == NULL || 
        pstrTip == NULL)
    {
        return S_FALSE;
    }

    // all callers must pass MAX_PATH
    LoadString(HINST_THISDLL, IDS_CHEVRONTIPTITLE, pstrTitle, MAX_PATH);
    LoadString(HINST_THISDLL, IDS_CHEVRONTIP, pstrTip, MAX_PATH);

    // Why would this fail?
    ASSERT(pstrTitle[0] != L'\0' && pstrTip[0] != L'\0');
    return S_OK;
}

STDAPI CStartMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_FAIL;
    IMenuPopup* pmp = NULL;

    *ppvOut = NULL;

    CStartMenuCallback* psmc = new CStartMenuCallback();
    if (psmc)
    {
        IShellMenu* psm;

        hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_MenuDeskBar, punkOuter, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &pmp));
            if (SUCCEEDED(hr)) 
            {
                IBandSite* pbs;
                hr = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pbs));
                if (SUCCEEDED(hr)) 
                {
                    hr = pmp->SetClient(pbs);
                    if (SUCCEEDED(hr)) 
                    {
                        IDeskBand* pdb;
                        hr = psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
                        if (SUCCEEDED(hr))
                        {
                           hr = pbs->AddBand(pdb);
                           pdb->Release();
                        }
                    }
                    pbs->Release();
                }
                // Don't free pmp. We're using it below.
            }

            if (SUCCEEDED(hr))
            {
                // This is so the ref counting happens correctly.
                hr = psm->Initialize(psmc, 0, 0, SMINIT_VERTICAL | SMINIT_TOPLEVEL);
                if (SUCCEEDED(hr))
                {
                    // if this fails, we don't get that part of the menu
                    // this is okay since it can happen if the start menu is redirected
                    // to where we dont have access.
                    psmc->InitializeFastItemsShellMenu(psm);
                }
            }

            psm->Release();
        }
        psmc->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pmp->QueryInterface(riid, ppvOut);
    }
    else
    {
        // We need to do this so that it does a cascading delete
        IUnknown_SetSite(pmp, NULL);        
    }

    if (pmp)
        pmp->Release();

    return hr;
}

// IUnknown
STDMETHODIMP CStartContextMenu::QueryInterface(REFIID riid, void **ppvObj)
{

    static const QITAB qit[] = 
    {
        QITABENT(CStartContextMenu, IContextMenu),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CStartContextMenu::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CStartContextMenu::Release(void)
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// IContextMenu
STDMETHODIMP CStartContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = E_FAIL;
    HMENU hmenuStartMenu = SHLoadMenuPopup(HINST_THISDLL, MENU_STARTMENUSTATICITEMS);

    if (hmenuStartMenu)
    {
        TCHAR szCommon[MAX_PATH];
        BOOL fAddCommon = (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL, 0, szCommon));

        if (fAddCommon)
            fAddCommon = IsUserAnAdmin();

        // Since we don't show this on the start button when the user is not an admin, don't show it here... I guess...
        if (_idCmd != IDM_PROGRAMS || !fAddCommon)
        {
            DeleteMenu(hmenuStartMenu, SMCM_OPEN_ALLUSERS, MF_BYCOMMAND);
            DeleteMenu(hmenuStartMenu, SMCM_EXPLORE_ALLUSERS, MF_BYCOMMAND);
        }

        if (Shell_MergeMenus(hmenu, hmenuStartMenu, 0, indexMenu, idCmdLast, uFlags))
        {
            SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);
            _SHPrettyMenu(hmenu);
            hr = ResultFromShort(GetMenuItemCount(hmenuStartMenu));
        }

        DestroyMenu(hmenuStartMenu);
    }
    
    return hr;
}

STDMETHODIMP CStartContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT hr = E_FAIL;
    if (HIWORD64(lpici->lpVerb) == 0)
    {
        BOOL fAllUsers = FALSE;
        BOOL fOpen = TRUE;
        switch(LOWORD(lpici->lpVerb))
        {
        case SMCM_OPEN_ALLUSERS:
            fAllUsers = TRUE;
        case SMCM_OPEN:
            // fOpen = TRUE;
            break;

        case SMCM_EXPLORE_ALLUSERS:
            fAllUsers = TRUE;
        case SMCM_EXPLORE:
            fOpen = FALSE;
            break;

        default:
            return S_FALSE;
        }

        hr = ExecStaticStartMenuItem(_idCmd, fAllUsers, fOpen);
    }

    // Ahhh Don't handle verbs!!!
    return hr;

}

STDMETHODIMP CStartContextMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

//****************************************************************************
//
//  CPersonalStartMenuCallback

class CPersonalProgramsMenuCallback : public CStartMenuCallbackBase
{
public:
    CPersonalProgramsMenuCallback() : CStartMenuCallbackBase(TRUE) { }

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods *** (overriding CObjectWithSite)
    STDMETHODIMP SetSite(IUnknown* punk);

public:
    HRESULT Initialize(IShellMenu *psm)
        { return InitializeProgramsShellMenu(psm); }

private:
    void _UpdateTrayPriv();

};

//
//  Throw away any previous TrayPriv2 and try to find a new one.
//
//  Throwing it away is important to break circular reference loops.
//
//  Trying to find it will typically fail at SetSite since when we are
//  given our site, CDesktopHost hasn't connected at the top yet so
//  we are unable to find him.  But he will be there by the time
//  SMC_INITMENU arrives, so we try again then.
//
void CPersonalProgramsMenuCallback::_UpdateTrayPriv()
{
    ATOMICRELEASE(_ptp2);
    IObjectWithSite *pows;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IObjectWithSite, &pows))))
    {
        pows->GetSite(IID_PPV_ARG(ITrayPriv2, &_ptp2));
        pows->Release();
    }
}

STDMETHODIMP CPersonalProgramsMenuCallback::SetSite(IUnknown* punk)
{
    HRESULT hr = CObjectWithSite::SetSite(punk);
    _UpdateTrayPriv();
    return hr;
}

STDMETHODIMP CPersonalProgramsMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uMsg)
    {

    case SMC_INITMENU:
        _UpdateTrayPriv();
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_NEWITEM:
        hr = _HandleNew(psmd);
        break;

    case SMC_FILTERPIDL:
        ASSERT(psmd->dwMask & SMDM_SHELLFOLDER);
        hr = _FilterPidl(psmd->uIdParent, psmd->psf, psmd->pidlItem);
        break;

    case SMC_GETSFINFOTIP:
        if (!FeatureEnabled(TEXT("ShowInfoTip")))
            hr = E_FAIL;  // E_FAIL means don't show. S_FALSE means show default
        break;

    case SMC_PROMOTE:
        hr = _Promote(psmd, (DWORD)wParam);
        break;

    case SMC_SHCHANGENOTIFY:
        {
            PSMCSHCHANGENOTIFYSTRUCT pshf = (PSMCSHCHANGENOTIFYSTRUCT)lParam;
            hr = _ProcessChangeNotify(psmd, pshf->lEvent, pshf->pidl1, pshf->pidl2);
        }
        break;

    case SMC_REFRESH:
        _RefreshSettings();
        break;
    }

    return hr;
}


STDAPI CPersonalStartMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr;

    *ppvOut = NULL;

    IShellMenu *psm;
    hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER,
                          IID_PPV_ARG(IShellMenu, &psm));
    if (SUCCEEDED(hr))
    {
        CPersonalProgramsMenuCallback *psmc = new CPersonalProgramsMenuCallback();
        if (psmc)
        {
            hr = psmc->Initialize(psm);
            if (SUCCEEDED(hr))
            {
                // SetShellFolder takes ownership of hkCustom
                hr = psm->QueryInterface(riid, ppvOut);
            }
            psmc->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        psm->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\stdafx.h ===
// Precompiled header for UNICPP

#ifndef _UNICPP_PCH__
#define _UNICPP_PCH__

#include "w4warn.h"
#pragma warning(disable:4131)  // 'CreateInfoFile' : uses old-style declarator
#pragma warning(disable:4702) // unreachable code


#define _SHELL32_

#ifdef WINNT
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}
#endif

#undef STRICT

#include <shellprv.h>

#include <shlobj.h>

#include <shlwapi.h>
#include <shellp.h>
#include <shellids.h>
#include <shguidp.h>
#include <shlwapip.h>
#include <shsemip.h>
#include <desktopp.h>

#include <InetReg.h>
#include <cplext.h>
#include <dbt.h>        
#include <devioctl.h>
#include <fsmenu.h>
#include <hliface.h>
#include <iethread.h>
#include <inetreg.h>
#include <intshcut.h>
#include <mshtmdid.h>
#include <mshtml.h>

#include <objsafe.h>
#include <oleauto.h>
#include <olectl.h>

#include <regstr.h>
#include <stdarg.h>
#include <stdio.h>
#include <trayp.h>
#include <urlmon.h>
#include <webcheck.h>

#include <objclsid.h>
#include <objwindow.h>

#include "debug.h"
#include "shellp.h"
#include "shlguid.h"
#include "shguidp.h"
#include "clsobj.h"

#include "local.h"
#include "deskstat.h"
#include "dutil.h"

#include "admovr2.h"
#include "advanced.h"
#include "clsobj.h"
#include "dback.h"
#include "dbackp.h"
#include "dcomp.h"
#include "dcompp.h"
#include "deskcls.h"
#include "deskhtm.h"
#include "deskhtml.h"
#include "deskstat.h"
#include "dsubscri.h"
#include "dutil.h"
#include "expdsprt.h"
#include "hnfblock.h"
#include "local.h"
#include "msstkppg.h"
#include "options.h"
#include "resource.h"
#include "schedule.h"
#include "utils.h"
#include "comcat.h"
#include "netview.h"
#include "ids.h"
#include "fldset.h"
#include "recdocs.h"
#include "brfcasep.h"
#include "startids.h"
#include "defview.h"
#include "htmlhelp.h"
#include "uemapp.h"
#include "expdsprt.h"
#include "dspsprt.h"

// The W version of this API has been implemented in shlwapi, so we save code
// and use that version.  If we include w95wraps.h we'll get this definition
// for us, but shell32 isn't single binary yet so we don't use it.
#define ShellMessageBoxW ShellMessageBoxWrapW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\assoc.h ===
//  assoc.h
HRESULT AssocCreateW2k(REFIID riid, LPVOID *ppvOut);
HRESULT AssocCreateElement(REFCLSID clsid, REFIID riid, void **ppv);

BOOL _PathAppend(PCWSTR pszBase, PCWSTR pszAppend, PWSTR pszOut, DWORD cchOut);
BOOL _PathIsFile(PCWSTR pszPath);
void _MakeAppPathKey(PCWSTR pszApp, PWSTR pszKey, DWORD cchKey);
void _MakeApplicationsKey(LPCWSTR pszApp, LPWSTR pszKey, DWORD cchKey);

HRESULT _AssocOpenRegKey(HKEY hk, PCWSTR pszSub, HKEY *phkOut, BOOL fCreate = FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\utils.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <mshtml.h>


// let the shell dispatch objects know where to get their type lib
// (this stuff lives here for no better reason than it must be in some cpp file)
EXTERN_C GUID g_guidLibSdspatch = LIBID_Shell32;
EXTERN_C USHORT g_wMajorVerSdspatch = 1;
EXTERN_C USHORT g_wMinorVerSdspatch = 0;

// This isn't a typical delay load since it's called only if wininet
// is already loaded in memory. Otherwise the call is dropped on the floor.
// Defview did it this way I assume to keep WININET out of first boot time.
BOOL MyInternetSetOption(HANDLE h, DWORD dw1, LPVOID lpv, DWORD dw2)
{
    BOOL bRet = FALSE;
    HMODULE hmod = GetModuleHandle(TEXT("wininet.dll"));
    if (hmod)
    {
        typedef BOOL (*PFNINTERNETSETOPTIONA)(HANDLE h, DWORD dw1, LPVOID lpv, DWORD dw2);
        PFNINTERNETSETOPTIONA fp = (PFNINTERNETSETOPTIONA)GetProcAddress(hmod, "InternetSetOptionA");
        if (fp)
        {
            bRet = fp(h, dw1, lpv, dw2);
        }
    }
    return bRet;
}

// REVIEW: maybe just check (hwnd == GetShellWindow())

STDAPI_(BOOL) IsDesktopWindow(HWND hwnd)
{
    TCHAR szName[80];

    GetClassName(hwnd, szName, ARRAYSIZE(szName));
    if (!lstrcmp(szName, TEXT(STR_DESKTOPCLASS)))
    {
        return hwnd == GetShellWindow();
    }
    return FALSE;
}

// returns:
//      S_OK                returned if the .htt (web view template) file associated with the folder we're viewing is trusted
//      S_FALSE or 
//      E_ACCESSDENIED      bad... don't expose local machine access

STDAPI IsSafePage(IUnknown *punkSite)
{
    // Return S_FALSE if we don't have a host site since we have no way of doing a 
    // security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    HRESULT hr = E_ACCESSDENIED;

    // There are two safe cases:
    // 1) we are contained by a signed MD5 hashed defview template.
    // 2) we are contained by a .html file that's on the Local Zone
    //
    // Case 1) find the template path from webview...
    VARIANT vPath = {0};
    hr = IUnknown_QueryServiceExec(punkSite, SID_DefView, &CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vPath);
    if (SUCCEEDED(hr))
    {
        if (vPath.vt == VT_BSTR && vPath.bstrVal)
        {
            WCHAR wszPath[MAX_PATH];
            DWORD cchPath = ARRAYSIZE(wszPath);
            if (S_OK != PathCreateFromUrlW(vPath.bstrVal, wszPath, &cchPath, 0))
            {
                // it might not be an URL, in this case it is a file path
                StrCpyNW(wszPath, vPath.bstrVal, ARRAYSIZE(wszPath));
            }

            // it might not be an URL, in this case it is a file path
            // allow intranet if this is hosted under defview
            hr = SHRegisterValidateTemplate(wszPath, SHRVT_VALIDATE | SHRVT_ALLOW_INTRANET | SHRVT_PROMPTUSER | SHRVT_REGISTERIFPROMPTOK);
        }
        VariantClear(&vPath);
    }
    else
    {
        IUnknown* punkToFree = NULL;

        // Case 2) ask the browser, for example we are in a .HTM doc
        BOOL fFound = FALSE;
        do
        {
            IBrowserService* pbs;
            hr = IUnknown_QueryService(punkSite, SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;

                hr = pbs->GetPidl(&pidl);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszPath[MAX_PATH];
                    DWORD dwAttribs = SFGAO_FOLDER;
                    hr = SHGetNameAndFlagsW(pidl, SHGDN_FORPARSING, wszPath, ARRAYSIZE(wszPath), &dwAttribs);
                    if (dwAttribs & SFGAO_FOLDER)
                    {
                        // A folder is not a .HTM file, so continue on up...
                        ATOMICRELEASE(punkToFree);
                        hr = IUnknown_GetSite(pbs, IID_PPV_ARG(IUnknown, &punkToFree)); // gotta start with pbs's parent (otherwise you'll get the same pbs again)
                        if (FAILED(hr)) // to get by the weboc you need to explicitly ask for the oc's parent:
                        {
                            hr = IUnknown_QueryService(pbs, SID_QIClientSite, IID_PPV_ARG(IUnknown, &punkToFree));
                        }
                        punkSite = punkToFree;
                    }
                    else
                    {
                        // Found the nearest containing non-folder object.
                        fFound = TRUE;
                        hr = LocalZoneCheckPath(wszPath, punkSite); // check for local zone
                    }

                    ILFree(pidl);
                }
                pbs->Release();
            }
        } while (SUCCEEDED(hr) && !fFound);

        ATOMICRELEASE(punkToFree);
    }

    if (S_OK != hr)
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return HRESULT_FROM_WIN32(dwError);
}


STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName)
    {
        VARIANT va;

        va.vt = VT_UNKNOWN;
        va.punkVal = punk;

        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}


BOOL _GetRegValueString(HKEY hKey, LPCTSTR pszValName, LPTSTR pszString, int cchSize)
{
    DWORD cbSize = sizeof(pszString[0]) * cchSize;
    DWORD dwType;
    DWORD dwError = SHQueryValueEx(hKey, pszValName, NULL, &dwType, (LPBYTE)pszString, &cbSize);

    return (ERROR_SUCCESS == dwError);
}


//------------------------------------------------------------------------------------
//
//      IconSet/GetRegValueString()
//
//      Versions of Get/SetRegValueString that go to the user classes section.
//
//      Returns: success of string setting / retrieval
//
//------------------------------------------------------------------------------------
BOOL IconSetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue)
{
    HKEY hkey;
    if (SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, TRUE, TRUE, &hkey)))
    {
        DWORD dwRet = SHRegSetPath(hkey, NULL, lpszValName, lpszValue, 0);
        RegCloseKey(hkey);
        return (dwRet == ERROR_SUCCESS);
    }

    return FALSE;
}


BOOL _IconGetRegValueString(BOOL fDisplayName, const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue)
{
    HKEY hkey;
    if (SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, TRUE, FALSE, &hkey)) ||
        SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, FALSE, FALSE, &hkey)))
    {        
        BOOL fRet;
        if (fDisplayName)
        {
            fRet = SUCCEEDED(SHLoadLegacyRegUIString(hkey, NULL, lpszValue, cchValue));
        }
        else
        {
            fRet = _GetRegValueString(hkey, lpszValName, lpszValue, cchValue);
        }
        RegCloseKey(hkey);
        return fRet;
    }
    return FALSE;
}

BOOL IconGetRegNameString(const CLSID* pclsid, LPTSTR lpszValue, int cchValue)
{
    return _IconGetRegValueString(TRUE, pclsid, NULL, NULL, lpszValue, cchValue);
}

// lpszValName is used if there are multiple icons ("full" and "empty" for recycle bin)
BOOL IconGetRegIconString(const CLSID* pclsid, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue)
{
    return _IconGetRegValueString(FALSE, pclsid, TEXT("DefaultIcon"), lpszValName, lpszValue, cchValue);
}

BOOL CALLBACK Cabinet_RefreshEnum(HWND hwnd, LPARAM lParam)
{
    if (IsFolderWindow(hwnd) || IsExplorerWindow(hwnd))
    {
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, lParam);
    }

    return(TRUE);
}

BOOL CALLBACK Cabinet_UpdateWebViewEnum(HWND hwnd, LPARAM lParam)
{
    if (IsFolderWindow(hwnd) || IsExplorerWindow(hwnd))
    {
        // A value of -1L for lParam will force a refresh by loading the View window
        // with the new VID as specified in the global DefFolderSettings.
        PostMessage(hwnd, WM_COMMAND, SFVIDM_MISC_SETWEBVIEW, lParam);
    }
    return(TRUE);
}

void Cabinet_RefreshAll(WNDENUMPROC lpEnumFunc, LPARAM lParam)
{
    HWND hwnd = FindWindowEx(NULL, NULL, TEXT(STR_DESKTOPCLASS), NULL);
    if (hwnd)
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);

    hwnd = FindWindowEx(NULL, NULL, TEXT("Shell_TrayWnd"), NULL);
    if (hwnd)
        PostMessage(hwnd, TM_REFRESH, 0, 0L);

    EnumWindows(lpEnumFunc, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\assocelem.cpp ===
#include "priv.h"
#include "ids.h"
#include "assoc.h"
#include <memt.h>

BOOL _PathIsFile(PCWSTR pszPath)
{
    DWORD attrs = GetFileAttributesW(pszPath);

    return ((DWORD)-1 != attrs && !(attrs & FILE_ATTRIBUTE_DIRECTORY));
}

BOOL _GetAppPath(PCWSTR pszApp, PWSTR pszExe, DWORD cchExe)
{
    WCHAR sz[MAX_PATH];
    _MakeAppPathKey(pszApp, sz, SIZECHARS(sz));

    DWORD cb = CbFromCchW(cchExe);
    return ERROR_SUCCESS == SHGetValueW(HKEY_LOCAL_MACHINE, sz, NULL, NULL, pszExe, &cb);
}

inline HRESULT _QuerySourceCreateFromKey(HKEY hk, PCWSTR pszSub, BOOL fCreate, IQuerySource **ppqs)
{
    return QuerySourceCreateFromKey(hk, pszSub, fCreate, IID_PPV_ARG(IQuerySource, ppqs));
}

typedef struct QUERYKEYVAL
{
    ASSOCQUERY query;
    PCWSTR pszKey;
    PCWSTR pszVal;
} QUERYKEYVAL;

#define MAKEQKV(q, k, v) { q, k, v}

static const QUERYKEYVAL s_rgqkvVerb[] = 
{
    MAKEQKV(AQVS_COMMAND, L"command", NULL),
    MAKEQKV(AQVS_DDECOMMAND, L"ddeexec", NULL),
    MAKEQKV(AQVS_DDEIFEXEC, L"ddeexec\\ifexec", NULL),
    MAKEQKV(AQVS_DDEAPPLICATION, L"ddeexec\\application", NULL),
    MAKEQKV(AQVS_DDETOPIC, L"ddeexec\\topic", NULL),
    MAKEQKV(AQV_NOACTIVATEHANDLER, L"ddeexec", L"NoActivateHandler"),
    MAKEQKV(AQVD_MSIDESCRIPTOR, L"command", L"command"),
    MAKEQKV(AQVS_APPLICATION_FRIENDLYNAME, NULL, L"FriendlyAppName"),
};

static const QUERYKEYVAL s_rgqkvShell[] = 
{
    MAKEQKV(AQS_FRIENDLYTYPENAME, NULL, L"FriendlyTypeName"),
    MAKEQKV(AQS_DEFAULTICON, L"DefaultIcon", NULL),
    MAKEQKV(AQS_CLSID, L"Clsid", NULL),
    MAKEQKV(AQS_PROGID, L"Progid", NULL),
    MAKEQKV(AQNS_SHELLEX_HANDLER, L"ShellEx\\%s", NULL),
};

static const QUERYKEYVAL s_rgqkvExt[] = 
{
    MAKEQKV(AQNS_SHELLEX_HANDLER, L"ShellEx\\%s", NULL),
    MAKEQKV(AQS_CONTENTTYPE, NULL, L"Content Type"),
};

static const QUERYKEYVAL s_rgqkvApp[] = 
{
    MAKEQKV(AQVS_APPLICATION_FRIENDLYNAME, NULL, L"FriendlyAppName"),
};

const QUERYKEYVAL *_FindKeyVal(ASSOCQUERY query, const QUERYKEYVAL *rgQkv, UINT cQkv)
{
    for (UINT i = 0; i < cQkv; i++)
    {
        if (rgQkv[i].query == query)
        {
            return &rgQkv[i];
        }
    }
    return NULL;
}

HRESULT _SHAllocMUI(LPWSTR *ppsz)
{
    WCHAR sz[INFOTIPSIZE];
    HRESULT hr = SHLoadIndirectString(*ppsz, sz, ARRAYSIZE(sz), NULL);
    CoTaskMemFree(*ppsz);
    if (SUCCEEDED(hr))
        hr = SHStrDupW(sz, ppsz);
    else
        *ppsz = 0;
    return hr;
}

HRESULT CALLBACK _QuerySourceString(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, PWSTR *ppsz)
{
    HRESULT hr = pqs->QueryValueString(pszKey, pszValue, ppsz);
    if (SUCCEEDED(hr) && (query & AQF_MUISTRING))
    {
        //  NOTE - this sucks for stack usage.
        //  since there is currently no way to get
        //  the size of the target.
        hr = _SHAllocMUI(ppsz);
    }
    return hr;
}

HRESULT CALLBACK _QuerySourceDirect(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, FLAGGED_BYTE_BLOB **ppblob)
{
    return pqs->QueryValueDirect(pszKey, pszValue, ppblob);
}

HRESULT CALLBACK _QuerySourceExists(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, void *pv)
{
    return pqs->QueryValueExists(pszKey, pszValue);
}

HRESULT CALLBACK _QuerySourceDword(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, DWORD *pdw)
{
    return pqs->QueryValueDword(pszKey, pszValue, pdw);
}

class CAssocElement : public IObjectWithQuerySource,
                      public IAssociationElement
{
public:
    CAssocElement() : _cRef(1), _pqs(0) {}
    virtual ~CAssocElement() { ATOMICRELEASE(_pqs); }

    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return InterlockedIncrement(&_cRef);
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        LONG cNewRef = InterlockedDecrement(&_cRef);

        if (cNewRef == 0)
        {
            delete this;
        }

        return cNewRef;    
    }

    //  IObjectWithQuerySource 
    STDMETHODIMP SetSource(IQuerySource *pqs)
    {
        if (!_pqs)
        {
            _pqs = pqs;
            _pqs->AddRef();
            return S_OK;
        }
        return E_UNEXPECTED;
    }

    STDMETHODIMP GetSource(REFIID riid, void **ppv)
    {
        if (_pqs)
        {
            return _pqs->QueryInterface(riid, ppv);
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    //  IAssociationElement
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz)
        {
            *ppsz = 0;
            return _QuerySourceAny(_QuerySourceString, _pqs, (ASSOCQUERY)(AQF_DIRECT | AQF_STRING), query, pszCue, ppsz);
        }

    STDMETHODIMP QueryDword(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        DWORD *pdw)
        {
            return _QuerySourceAny(_QuerySourceDword, _pqs, (ASSOCQUERY)(AQF_DIRECT | AQF_DWORD), query, pszCue, pdw);
        }

    STDMETHODIMP QueryExists(
        ASSOCQUERY query, 
        PCWSTR pszCue)
        {
            return _QuerySourceAny(_QuerySourceExists, _pqs, (ASSOCQUERY)(AQF_DIRECT | AQF_EXISTS), query, pszCue, (void*)NULL);
        }

    STDMETHODIMP QueryDirect(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        FLAGGED_BYTE_BLOB **ppblob)
        {
            *ppblob = 0;
            return _QuerySourceAny(_QuerySourceDirect, _pqs, AQF_DIRECT, query, pszCue, ppblob);
        }

    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv)
        {
            *ppv = 0;
            return E_NOTIMPL;
        }

protected:
    template<class T> HRESULT _QueryKeyValAny(HRESULT (CALLBACK *pfnAny)(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, T *pData), const QUERYKEYVAL *rgQkv, UINT cQkv, IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszCue, T *pData)
    {
        HRESULT hr = E_INVALIDARG;
        const QUERYKEYVAL *pqkv = _FindKeyVal(query, rgQkv, cQkv);
        if (pqkv)
        {
            WCHAR szKey[128];
            PCWSTR pszKey = pqkv->pszKey;
            if (query & AQF_CUEIS_NAME)
            {
                if (pqkv->pszKey)
                {
                    wnsprintfW(szKey, ARRAYSIZE(szKey), pqkv->pszKey, pszCue);
                    pszKey = szKey;
                }
                // wnsprintf(szVal, ARRAYSIZE(szVal), pqkv->pszVal, pszCue);
            }
            hr = pfnAny(pqs, query, pszKey, pqkv->pszVal, pData);
        }
        return hr;
    }
    
    template<class T> HRESULT _QuerySourceAny(HRESULT (CALLBACK *pfnAny)(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, T *pData), IQuerySource *pqs, ASSOCQUERY mask, ASSOCQUERY query, PCWSTR pszCue, T *pData)
    {
        HRESULT hr = E_INVALIDARG;
        if (pqs)
        {
            if (query == AQN_NAMED_VALUE || query == AQNS_NAMED_MUI_STRING)
            {
                hr = pfnAny(pqs, query, NULL, pszCue, pData);
            }
            else if ((query & (mask)) == (mask))
            {
                const QUERYKEYVAL *rgQkv;
                UINT cQkv = _GetQueryKeyVal(&rgQkv);
                if (cQkv)
                {
                    hr = _QueryKeyValAny(pfnAny, rgQkv, cQkv, pqs, query, pszCue, pData);
                }
            }
        }
        return hr;
    }

    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) { *prgQkv = 0; return 0; }

protected:
    LONG _cRef;
    IQuerySource *_pqs;
};

HRESULT CAssocElement::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocElement, IAssociationElement),
        QITABENT(CAssocElement, IObjectWithQuerySource),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

HRESULT _QueryString(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    return pae->QueryString(query, pszCue, ppsz);
}

HRESULT _QueryDirect(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, FLAGGED_BYTE_BLOB **ppblob)
{
    return pae->QueryDirect(query, pszCue, ppblob);
}

HRESULT _QueryDword(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, DWORD *pdw)
{
    return pae->QueryDword(query, pszCue, pdw);
}

HRESULT _QueryExists(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, void *pv)
{
    return pae->QueryExists(query, pszCue);
}

class CAssocShellElement : public CAssocElement, public IPersistString2
{
public:
    virtual ~CAssocShellElement() { if (_pszInit && _pszInit != _szInit) LocalFree(_pszInit);}

    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocShellElement; return S_OK;}

    //  IPersistString2
    STDMETHODIMP SetString(PCWSTR psz)
    {
        if (!_pszInit)
        {
            int cchInit;

            DWORD cch = lstrlenW(psz);
            if (cch < ARRAYSIZE(_szInit))
            {
                _pszInit = _szInit;
                cchInit = ARRAYSIZE(_szInit);
            }
            else
            {
                SHLocalAlloc(CbFromCchW(cch + 1), &_pszInit);
                cchInit = cch + 1;
            }
            
            if (_pszInit)
            {
                StringCchCopyW(_pszInit, cchInit, psz);
                return _InitSource();
            }
        }
        return E_UNEXPECTED;
    }
    
    STDMETHODIMP GetString(PWSTR *ppsz)
        { return SHStrDupW(_pszInit, ppsz); }

    //  IAssociationElement
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryString, query, pszCue, ppsz);
            else
                return CAssocElement::QueryString(query, pszCue, ppsz);
        }
        
    STDMETHODIMP QueryDword(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        DWORD *pdw)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryDword, query, pszCue, pdw);
            else
                return CAssocElement::QueryDword(query, pszCue, pdw);
        }

    STDMETHODIMP QueryExists(
        ASSOCQUERY query, 
        PCWSTR pszCue)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryExists, query, pszCue, (void*)NULL);
            else
                return CAssocElement::QueryExists(query, pszCue);
        }

    STDMETHODIMP QueryDirect(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        FLAGGED_BYTE_BLOB **ppblob)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryDirect, query, pszCue, ppblob);
            else
                return CAssocElement::QueryDirect(query, pszCue, ppblob);
        }

    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv);

protected:
    template<class T> HRESULT _QueryVerbAny(HRESULT (CALLBACK *pfnAny)(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, T pData), ASSOCQUERY query, PCWSTR pszCue, T pData)
    {
        IAssociationElement *pae;        
        HRESULT hr = _GetVerbDelegate(pszCue, &pae);
        if (SUCCEEDED(hr))
        {
            hr = pfnAny(pae, query, NULL, pData);
            pae->Release();
        }
        return hr;
    }

    //  from CAssocElement
    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) 
        { *prgQkv = s_rgqkvShell; return ARRAYSIZE(s_rgqkvShell); }

    //  defaults for our subclasses
    virtual BOOL _UseEnumForDefaultVerb() 
        { return FALSE;}
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, _pszInit, FALSE, &_pqs); }
    virtual BOOL _IsAppSource() 
        { return FALSE; }

    HRESULT _GetVerbDelegate(PCWSTR pszVerb, IAssociationElement **ppae);
    HRESULT _DefaultVerbSource(IQuerySource **ppqsVerb);
    HRESULT _QueryShellExtension(PCWSTR pszShellEx, PWSTR *ppsz);

protected:
    PWSTR _pszInit;
    WCHAR _szInit[64];
};

HRESULT CAssocShellElement::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocShellElement, IAssociationElement),
        QITABENT(CAssocShellElement, IObjectWithQuerySource),
        QITABENT(CAssocShellElement, IPersistString2),
        QITABENTMULTI(CAssocShellElement, IPersist, IPersistString2),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

class CAssocProgidElement : public CAssocShellElement 
{
public:
    virtual ~CAssocProgidElement()  { ATOMICRELEASE(_pqsExt); }
    //  then we handle fallback for IAssociationElement
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocProgidElement; return S_OK;}


protected:  // methods
    HRESULT _InitSource();  
    HRESULT _DefaultVerbSource(IQuerySource **ppqsVerb);
    BOOL _UseEnumForDefaultVerb() 
        { return TRUE; }

protected:  // members
    IQuerySource *_pqsExt;
};

HRESULT _QuerySourceCreateFromKey2(HKEY hk, PCWSTR pszSub1, PCWSTR pszSub2, IQuerySource **ppqs)
{
    WCHAR szKey[MAX_PATH];
    _PathAppend(pszSub1, pszSub2, szKey, SIZECHARS(szKey));
    return _QuerySourceCreateFromKey(hk, szKey, FALSE, ppqs);
}

class CAssocClsidElement : public CAssocShellElement 
{
public:
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocClsidElement; return S_OK;}

protected:
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey2(HKEY_CLASSES_ROOT, L"CLSID", _pszInit, &_pqs);}
};

class CAssocSystemExtElement : public CAssocShellElement  
{
public:
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocSystemElement; return S_OK;}

protected:
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey2(HKEY_CLASSES_ROOT, L"SystemFileAssociations", _pszInit, &_pqs);}
};

class CAssocPerceivedElement : public CAssocShellElement 
{
public:
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocPerceivedElement; return S_OK;}
        
protected:    
    virtual HRESULT _InitSource();
    //  maybe _GetVerbDelegate() to support Accepts filters
};

class CAssocApplicationElement : public CAssocShellElement 
{
public:
    //  need to fallback to the pszInit for FriendlyAppName
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz); 
    
    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv);

    //  IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocApplicationElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource();
    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) 
        { *prgQkv = s_rgqkvApp; return ARRAYSIZE(s_rgqkvApp); }
    virtual BOOL _IsAppSource() 
        { return TRUE; }
    BOOL _UseEnumForDefaultVerb() 
        { return TRUE; }

    HRESULT _GetAppDisplayName(PWSTR *ppsz);
    
protected:
    BOOL _fIsPath;
};

HRESULT CAssocApplicationElement::_GetAppDisplayName(PWSTR *ppsz)
{
    HRESULT hr;
    PWSTR pszPath;
    if (_fIsPath)
    {
        hr = S_OK;
        pszPath = _pszInit;
        ASSERT(pszPath);
    }
    else
        hr = QueryString(AQVS_APPLICATION_PATH, NULL, &pszPath);

    if (SUCCEEDED(hr))
    {
        WCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        hr = SKGetValueW(SHELLKEY_HKCULM_MUICACHE, NULL, pszPath, NULL, sz, &cb);
        if (FAILED(hr))
        {
            UINT cch = ARRAYSIZE(sz);
            if (SHGetFileDescriptionW(pszPath, NULL, NULL, sz, &cch))
            {
                hr = S_OK;
                SKSetValueW(SHELLKEY_HKCULM_MUICACHE, NULL, pszPath, REG_SZ, sz, CbFromCchW(lstrlenW(sz) + 1));
            }
        }

        if (SUCCEEDED(hr))
            hr = SHStrDupW(sz, ppsz);

        if (pszPath != _pszInit)
            CoTaskMemFree(pszPath);
    }

        
    return hr;
}


HRESULT CAssocApplicationElement::_InitSource()
{
    WCHAR sz[MAX_PATH];
    PCWSTR pszName = PathFindFileNameW(_pszInit);
    _MakeApplicationsKey(pszName, sz, ARRAYSIZE(sz));
    HRESULT hr = _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, sz, FALSE, &_pqs);
    _fIsPath = pszName != _pszInit;
    if (FAILED(hr))
    {
        if (_fIsPath && PathFileExistsW(_pszInit))
            hr = S_FALSE;
    }
    return hr;
}

HRESULT CAssocApplicationElement::QueryObject(ASSOCQUERY query, PCWSTR pszCue, REFIID riid, void **ppv)
{
    if (query == AQVO_APPLICATION_DELEGATE)
    {
        return QueryInterface(riid, ppv);
    }
    return CAssocShellElement::QueryObject(query, pszCue, riid, ppv);
}
        

HRESULT CAssocApplicationElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{ 
    HRESULT hr = CAssocShellElement::QueryString(query, pszCue, ppsz);
    if (FAILED(hr))
    {
        switch (query)
        {
        case AQVS_APPLICATION_FRIENDLYNAME:
            hr = _GetAppDisplayName(ppsz);
            break;
            
        }
    }
    return hr;
}
    
class CAssocShellVerbElement : public CAssocElement
{
public:
    CAssocShellVerbElement(BOOL fIsApp) : _fIsApp(fIsApp) {}
    
    //  overload QS to return default DDEExec strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv);

protected:    
    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) 
        { *prgQkv = s_rgqkvVerb; return ARRAYSIZE(s_rgqkvVerb); }
    HRESULT _GetAppDelegate(REFIID riid, void **ppv);

protected:
    BOOL _fIsApp;
};

class CAssocFolderElement : public CAssocShellElement  
{
public:
    //  overload QS to return default MUI strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocFolderElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, L"Folder", FALSE, &_pqs); }
};

class CAssocStarElement : public CAssocShellElement  
{
public:
    //  overload QS to return default MUI strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocStarElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, L"*", FALSE, &_pqs); }
};

HRESULT CAssocShellElement::_DefaultVerbSource(IQuerySource **ppqsVerb)
{
    IQuerySource *pqsShell;
    HRESULT hr = _pqs->OpenSource(L"shell", FALSE, &pqsShell);
    if (SUCCEEDED(hr))
    {
        PWSTR pszFree = NULL;
        PCWSTR pszVerb;
        //  see if something is specified...
        if (SUCCEEDED(pqsShell->QueryValueString(NULL, NULL, &pszFree)))
        {
            pszVerb = pszFree;
        }
        else
        {
            //  default to "open"
            pszVerb = L"open";
        }

        hr = pqsShell->OpenSource(pszVerb, FALSE, ppqsVerb);
        if (FAILED(hr))
        {
            if (pszFree)
            {
                // try to find one of the ordered verbs
                int c = StrCSpnW(pszFree, L" ,");
                if (c != lstrlenW(pszFree))
                {
                    pszFree[c] = 0;
                    hr = pqsShell->OpenSource(pszFree, FALSE, ppqsVerb);
                }
            }
            else if (_UseEnumForDefaultVerb())
            {
                //  APPCOMPAT - regitems need to have the open verb - ZekeL - 30-JAN-2001
                //  so that the IQA and ICM will behave the same,
                //  and regitem folders will always default to 
                //  folder\shell\open unless they implement open 
                //  or specify default verbs.
                //
                // everything else, just use the first key we find....
                IEnumString *penum;
                if (SUCCEEDED(pqsShell->EnumSources(&penum)))
                {
                    ULONG c;
                    CSmartCoTaskMem<OLECHAR> spszEnum;
                    if (S_OK == penum->Next(1, &spszEnum, &c))
                    {
                        hr = pqsShell->OpenSource(spszEnum, FALSE, ppqsVerb);
                    }
                    penum->Release();
                }
            }
        }

        if (pszFree)
            CoTaskMemFree(pszFree);
        pqsShell->Release();
    }
    return hr;
}

HRESULT QSOpen2(IQuerySource *pqs, PCWSTR pszSub1, PCWSTR pszSub2, BOOL fCreate, IQuerySource **ppqs)
{
    WCHAR szKey[MAX_PATH];
    _PathAppend(pszSub1, pszSub2, szKey, SIZECHARS(szKey));
    return pqs->OpenSource(szKey, fCreate, ppqs);
}

HRESULT CAssocShellElement::_GetVerbDelegate(PCWSTR pszVerb, IAssociationElement **ppae)
{
    HRESULT hr = _pqs ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        //  we will recalc each time.
        //  the array will cache appropriately
        IQuerySource *pqs;
        if (pszVerb)
        {
            hr = QSOpen2(_pqs, L"shell", pszVerb, FALSE, &pqs);
        }
        else
        {
            hr = _DefaultVerbSource(&pqs);
        }

        if (SUCCEEDED(hr))
        {
            CAssocShellVerbElement *pave = new CAssocShellVerbElement(_IsAppSource());
            if (pave)
            {
                hr = pave->SetSource(pqs);
                // this cant fail...
                ASSERT(SUCCEEDED(hr));
                *ppae = pave;
            }
            else
                hr = E_OUTOFMEMORY;
            pqs->Release();            
        }
    }

    return hr;
}

HRESULT CAssocShellElement::QueryObject(ASSOCQUERY query, PCWSTR pszCue, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (AQF_CUEIS_SHELLVERB & query)
    {
        IAssociationElement *pae;        
        hr = _GetVerbDelegate(pszCue, &pae);
        if (SUCCEEDED(hr))
        {
            if (AQVO_SHELLVERB_DELEGATE == query)
                hr = pae->QueryInterface(riid, ppv);
            else
                hr = pae->QueryObject(query, NULL, riid, ppv);
            pae->Release();
        }
    }

    return hr;
}

HKEY _OpenProgidKey(PCWSTR pszProgid)
{
    HKEY hkOut;
    if (SUCCEEDED(_AssocOpenRegKey(HKEY_CLASSES_ROOT, pszProgid, &hkOut)))
    {
        // Check for a newer version of the ProgID
        WCHAR sz[64];
        DWORD cb = sizeof(sz);

        //
        //  APPCOMPAT LEGACY - Quattro Pro 2000 and Excel 2000 dont get along - ZekeL - 7-MAR-2000
        //  mill bug #129525.  the problem is if Quattro is installed
        //  first, then excel picks up quattro's CurVer key for some
        //  reason.  then we end up using Quattro.Worksheet as the current
        //  version of the Excel.Sheet.  this is bug in both of their code.
        //  since quattro cant even open the file when we give it to them,
        //  they never should take the assoc in the first place, and when excel
        //  takes over it shouldnt have preserved the CurVer key from the
        //  previous association.  we could add some code to insure that the 
        //  CurVer key follows the OLE progid naming conventions and that it must
        //  be derived from the same app name as the progid in order to take 
        //  precedence but for now we will block CurVer from working whenever
        //  the progid is excel.sheet.8 (excel 2000)
        //
        if (StrCmpIW(L"Excel.Sheet.8", pszProgid)
        && ERROR_SUCCESS == SHGetValueW(hkOut, L"CurVer", NULL, NULL, sz, &cb) 
        && (cb > sizeof(WCHAR)))
        {
            //  cache this bubby
            HKEY hkTemp = hkOut;            
            if (SUCCEEDED(_AssocOpenRegKey(HKEY_CLASSES_ROOT, sz, &hkOut)))
            {
                //
                //  APPCOMPAT LEGACY - order of preference - ZekeL - 22-JUL-99
                //  this is to support associations that installed empty curver
                //  keys, like microsoft project.
                //
                //  1.  curver with shell subkey
                //  2.  progid with shell subkey
                //  3.  curver without shell subkey
                //  4.  progid without shell subkey
                //
                HKEY hkShell;

                if (SUCCEEDED(_AssocOpenRegKey(hkOut, L"shell", &hkShell)))
                {
                    RegCloseKey(hkShell);
                    RegCloseKey(hkTemp);    // close old ProgID key
                }
                else if (SUCCEEDED(_AssocOpenRegKey(hkTemp, L"shell", &hkShell)))
                {
                    RegCloseKey(hkShell);
                    RegCloseKey(hkOut);
                    hkOut = hkTemp;
                }
                else
                    RegCloseKey(hkTemp);
                
            }
            else  // reset!
                hkOut = hkTemp;
        }
    }

    return hkOut;
}

HRESULT CAssocProgidElement::_InitSource()
{
    HRESULT hr = S_OK;
    //  we need to init from an extension or Progid.
    //  we also support redirection
    LPWSTR pszProgid;    
    if (_pszInit[0] == L'.')
    {
        hr = _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, _pszInit, FALSE, &_pqsExt);
        if (SUCCEEDED(hr))
            hr = _pqsExt->QueryValueString(NULL, NULL, &pszProgid);
    }
    else
        pszProgid = _pszInit;

    if (SUCCEEDED(hr))
    {
        HKEY hk = _OpenProgidKey(pszProgid);
        if (hk)
        {
            hr = _QuerySourceCreateFromKey(hk, NULL, FALSE, &_pqs);
            RegCloseKey(hk);
        }
        else
            hr = E_UNEXPECTED;

        if (pszProgid != _pszInit)
            CoTaskMemFree(pszProgid);
    }

    //  for legacy compat reasons, we support 
    //  falling back to "HKEY_CLASSES_ROOT\.ext"
    if (FAILED(hr) && _pqsExt)
    {
        _pqs = _pqsExt;
        _pqsExt = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CAssocProgidElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    HRESULT hr = CAssocShellElement::QueryString(query, pszCue, ppsz);
    if (FAILED(hr))
    {
        if ((AQF_QUERY_INITCLASS & query) && _pqsExt)
            hr = _QueryKeyValAny(_QuerySourceString, s_rgqkvExt, ARRAYSIZE(s_rgqkvExt), _pqsExt, query, pszCue, ppsz);
        else if (_pqs)
        {
            switch (query)
            {
            case AQS_FRIENDLYTYPENAME:
                //  we like to query the default value
                hr = _pqs->QueryValueString(NULL, NULL, ppsz);
                break;
            }
        }
    }
    return hr;
}

STDAPI _SHAllocLoadString(HINSTANCE hinst, int ids, PWSTR *ppsz)
{
    WCHAR sz[MAX_PATH];
    LoadStringW(hinst, ids, sz, ARRAYSIZE(sz));
    return SHStrDupW(sz, ppsz);
}
    
HRESULT CAssocFolderElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    if (query == AQS_FRIENDLYTYPENAME)
        return  _SHAllocLoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, ppsz);
    else
        return CAssocShellElement::QueryString(query, pszCue, ppsz);
}

HRESULT _GetFileTypeName(PWSTR pszExt, PWSTR *ppsz)
{
    if (pszExt && pszExt[0] == L'.' && pszExt[1])
    {
        WCHAR sz[MAX_PATH];
        WCHAR szTemplate[128];   // "%s File"
        CharUpperW(pszExt);
        LoadStringW(HINST_THISDLL, IDS_EXTTYPETEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
        wnsprintfW(sz, ARRAYSIZE(sz), szTemplate, pszExt + 1);
        return SHStrDupW(sz, ppsz);
    }
    else 
    {
        //  load the file description "File"
        return _SHAllocLoadString(HINST_THISDLL, IDS_FILETYPENAME, ppsz);
    }
}

HRESULT CAssocStarElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    if (query == AQS_FRIENDLYTYPENAME)
        return  _GetFileTypeName(_pszInit, ppsz);
    else
        return CAssocShellElement::QueryString(query, pszCue, ppsz);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)

BOOL PathIsAbsolute(PCWSTR pszPath)
{
    return PathIsUNCW(pszPath) || ((-1 != PathGetDriveNumberW(pszPath)) && (pszPath[2] == L'\\'));
}

inline HRESULT _PathExeExists(PWSTR pszPath)
{
    DWORD attrs;
    return (PathFileExistsDefExtAndAttributesW(pszPath, PFOPEX_CMD | PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE  | PFOPEX_OPTIONAL, &attrs) && !(attrs & FILE_ATTRIBUTE_DIRECTORY)) ? S_OK : CO_E_APPNOTFOUND;
}

inline HRESULT _PathFileExists(PWSTR pszPath)
{
    DWORD attrs;
    return (PathFileExistsAndAttributesW(pszPath, &attrs) && !(attrs & FILE_ATTRIBUTE_DIRECTORY)) ? S_OK : HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}

HRESULT _CopyExe(PWSTR pszDst, size_t cchDst, PCWSTR pszSrc, size_t cchSrc)
{
    
    *pszDst = 0;
    HRESULT hr = StringCchCatNW(pszDst, cchDst, pszSrc, cchSrc);
    if (SUCCEEDED(hr))
    {
        StrTrimW(pszDst, L" \t");
    }
    return hr;
}

HRESULT _PathFindInFolder(int csidl, PCWSTR pszName, PWSTR pszPath, size_t cchPath)
{
    ASSERT(cchPath >= MAX_PATH);
    HRESULT hr = SHGetFolderPathW(NULL, csidl, NULL, SHGFP_TYPE_CURRENT, pszPath);
    if (SUCCEEDED(hr))
    {
        StringCchCatW(pszPath, cchPath, L"\\");
        hr = StringCchCatW(pszPath, cchPath, pszName);
        if (SUCCEEDED(hr))
        {
            hr = _PathExeExists(pszPath);
        }
    }
    return hr;
}
    
HRESULT _PathFindInSystem(PWSTR pszExe, size_t cchExe)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = _PathFindInFolder(CSIDL_SYSTEM, pszExe, szPath, ARRAYSIZE(szPath));
    if (FAILED(hr))
    {
        hr = _PathFindInFolder(CSIDL_WINDOWS, pszExe, szPath, ARRAYSIZE(szPath));
    }

    if (SUCCEEDED(hr))
    {
        hr = StringCchCopyW(pszExe, cchExe, szPath);
    }
    return hr;
}

BOOL _PathMatchesSuspicious(PCWSTR pszPath)
{
    size_t cch = lstrlenW(pszPath);
    WCHAR sz[MAX_PATH];
    SHGetFolderPathW(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, sz);
    return 0 == StrCmpNIW(pszPath, sz, cch);
}

PWSTR _PathGuessNextBestArgs(PCWSTR pszArgs)
{
    PCWSTR pchSpace = NULL;
    BOOL fContinue = TRUE;
    ASSERT(*pszArgs);
    while (fContinue && *pszArgs)
    {
        switch (*pszArgs)
        {
        case L'\\':
            //  only count whacks that arent in quotes 
            //  or preceded by a :, since it looks like a path
            fContinue = !PathIsUNCW(pszArgs);
            if (fContinue)
            {
                pchSpace = NULL;
            }
            break;

        case L' ':
            if (!pchSpace)
                pchSpace = pszArgs;
            break;

        case L'%':
        case L'"':
            //  we see this as the beginning of the args regardless
            //  since shellexec() would probably replace it
            fContinue = FALSE;
            break;

        default:
            fContinue = PathIsValidCharW(*pszArgs, PIVC_LFN_NAME);
            break;
                
        }
        pszArgs++;
    }

    if (pchSpace)
    {
        while (*pchSpace == L' ')
            pchSpace++;
        return (PWSTR) pchSpace;
    }
    else 
    {
        //  if we dont want to continue, then 
        //  we return NULL
        if (!fContinue)
            pszArgs = NULL;
        
        return (PWSTR) pszArgs;
    }
}

BOOL _ParamIsApp(PCWSTR pszCmdTemplate)
{
    return (0 == StrCmpNW(pszCmdTemplate, L"%1", ARRAYSIZE(L"%1")-1))
        || (0 == StrCmpNW(pszCmdTemplate, L"\"%1\"", ARRAYSIZE(L"\"%1\"")-1));
}

LPWSTR _PathGetArgsLikeCreateProcess(LPCWSTR pszPath)
{
    //
    //  NTBUG#634668 - check for quoted commandlines without spaces - ZekeL
    //  it turns out apps can do something like:  
    //      "c:\pfiles\app.exe""%1"
    //      "notepad"txt
    //  notice no space between the params and quoted path.
    //  CreateProcess(), of course, supports this.  so we need to as well...
    //  we only do it if the original command line was quoted
    //  then we check for a possible early termination
    //
    PCWSTR pchArgs = (pszPath[0] == L'"') ? StrChrW(pszPath + 1, L'"') : StrChrW(pszPath, L' ');
    if (pchArgs)
    {
        pchArgs++;
    }
    else
    {
        pchArgs = pszPath + lstrlenW(pszPath);
    }
    
    return (LPWSTR)pchArgs;
}

LWSTDAPI SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate, PWSTR *ppszApplication, PWSTR *ppszCommandLine, PWSTR *ppszParameters)
{
    ASSERT(!IsWhite(pszCmdTemplate[0]));
    PWSTR pchArgs = _PathGetArgsLikeCreateProcess(pszCmdTemplate);
    WCHAR szExe[MAX_PATH];
    //  default to using the path in *ppszCommandLine
    PCWSTR pszName = szExe;
    HRESULT hr = _CopyExe(szExe, ARRAYSIZE(szExe), pszCmdTemplate, pchArgs - pszCmdTemplate);

    //
    // We check for %1 since it is what appears under (for example) HKEY_CLASSES_ROOT\exefile\shell\open\command
    // This will save us from hitting the disk with something we know is not there
    // context menu on a shortcut to an .exe or .bat file.
    if (SUCCEEDED(hr))
    {
        BOOL fQuoted = (szExe[0] == L'"');
        if (fQuoted)
            PathUnquoteSpacesW(szExe);
        
        if (PathIsAbsolute(szExe))
        {
            //  do no searching.
            //  require quotes based on policy
            //  if (fQuoted || !SHIsRestricted(QUOTEDFILEASSOCS) )
            //  we should log an event when we restrict 
            if (fQuoted || !_PathMatchesSuspicious(szExe))
                hr = _PathExeExists(szExe);
            else
                hr = E_ACCESSDENIED;

            if (FAILED(hr) && !fQuoted && *pchArgs)
            {
                //
                //  sometimes the path is not properly quoted.
                //  these keys will still work because of the
                //  way CreateProcess works, but we need to do
                //  some fiddling to figure that out.
                //
                do 
                {
                    //  next space is our break
                    pchArgs = _PathGuessNextBestArgs(pchArgs);
                    if (pchArgs)
                    {
                        hr = _CopyExe(szExe, ARRAYSIZE(szExe), pszCmdTemplate, pchArgs - pszCmdTemplate);
                        if (SUCCEEDED(hr))
                        {
                            hr = _PathExeExists(szExe);
                        }
                    }
                    
                } while (FAILED(hr) && pchArgs && *pchArgs);
            }
        }
        else if (PathIsFileSpecW(szExe))
        {
            if (_GetAppPath(szExe, szExe, ARRAYSIZE(szExe)))
            {
                hr = _PathExeExists(szExe);
            }
            else
            {
                //  maybe do our special stuff for system 32?
                //  we allow for non-quoted stuff from system32
                //  if (!SHIsRestricted(RELATIVEFILEASSOCS)
                hr = _PathFindInSystem(szExe, ARRAYSIZE(szExe));
                // if this failed, should we search spaces???
                // right now assume that no system files have spaces.
            }
            //  use the relative name in ppszCommandLine
            pszName = PathFindFileNameW(szExe);
        }
        else
        {
            //  disallow most relative paths like \foo.exe or ..\foo.exe
            //  since these are completely indeterminate
            hr = E_ACCESSDENIED;
        }
    }

    *ppszApplication = NULL;
    if (ppszCommandLine)
        *ppszCommandLine = NULL;
    if (ppszParameters)
        *ppszParameters = NULL;

    if (SUCCEEDED(hr))
    {
        hr = SHStrDupW(szExe, ppszApplication);

        //  if there were no args, then use empty args
        if (!pchArgs)
            pchArgs = L"";
        
        if (SUCCEEDED(hr) && ppszCommandLine)
        {
            size_t cchCommandLine = lstrlenW(pszName) + lstrlenW(pchArgs) + ARRAYSIZE(L"\"%s\" %s");
            hr = SHCoAlloc(CbFromCchW(cchCommandLine), ppszCommandLine);
            if (SUCCEEDED(hr))
            {
                hr = StringCchPrintfW(*ppszCommandLine, cchCommandLine, L"\"%s\" %s", pszName, pchArgs);
                ASSERT(SUCCEEDED(hr));
            }
        }

        if (SUCCEEDED(hr) && ppszParameters)
        {
            hr = SHStrDupW(pchArgs, ppszParameters);
        }

        if (FAILED(hr))
        {
            if (*ppszApplication)
            {
                CoTaskMemFree(*ppszApplication);
                *ppszApplication = NULL;
            }

            if (ppszCommandLine && *ppszCommandLine)
            {
                CoTaskMemFree(*ppszCommandLine);
                *ppszCommandLine = NULL;
            }
            //  dont have to worry about ppszParameters because there is no failure
            //  after allocation
            ASSERT(!*ppszParameters);
        }

    }
    return hr;
}

HRESULT _ExeFromCmd(PCWSTR pszCommand, PWSTR  *ppsz)
{
    //  if this is an EXE we act kinda funny
    if (_ParamIsApp(pszCommand))
    {
        return SHStrDupW(L"%1", ppsz);
    }
    
    PWSTR pszArgs;
    HRESULT hr = SHEvaluateSystemCommandTemplate(pszCommand, ppsz, NULL, &pszArgs);
    if (SUCCEEDED(hr))
    {
        if (S_OK == hr && 0 == StrCmpIW(PathFindFileNameW(*ppsz), L"rundll32.exe"))
        {
            //  ok this is a rundll.  all run dlls end up looking the same
            //  so we think of it really being the dll
            CoTaskMemFree(*ppsz);
            *ppsz = NULL;

            //  SHEvaluateSystemCommandTemplate() guarantees PathGetArgs() to return the right thing
            PWSTR pchComma = StrChrW(pszArgs, L',');
            //  make the comma the beginning of the args
            if (pchComma)
            {
                //  now we need to copy 
                WCHAR szDll[MAX_PATH];
                hr = _CopyExe(szDll, ARRAYSIZE(szDll), pszArgs, pchComma - pszArgs);
                if (SUCCEEDED(hr))
                {
                    PathUnquoteSpacesW(szDll);
                    //  can we instead just do PFOPX()
                    //  cuz i think that rundll just checks for 
                    //  the comma
                    if (!*(PathFindExtensionW(szDll)))
                    {
                        //  no extension, assume dll
                        StringCchCatW(szDll, ARRAYSIZE(szDll), L".dll");
                    }

                    if (PathIsAbsolute(szDll))
                    {
                        hr  = _PathFileExists(szDll);
                    }
                    else if (PathIsFileSpecW(szDll))
                    {
                        hr = _PathFindInSystem(szDll, ARRAYSIZE(szDll));
                    }
                    else
                    {
                        //  disallow most relative paths like \foo.exe or ..\foo.exe
                        //  since these are completely indeterminate
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = SHStrDupW(szDll, ppsz);
                    }
                }
            }
            else
            {
                //  disallow most relative paths like \foo.exe or ..\foo.exe
                //  since these are completely indeterminate
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
        }

        CoTaskMemFree(pszArgs);
    }


    return hr;
}

HRESULT CAssocShellVerbElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    HRESULT hr = CAssocElement::QueryString(query, pszCue, ppsz);
    if (FAILED(hr))
    {
        //  we havent scored yet
        switch (query)
        {
        case AQVS_DDEAPPLICATION:
            //  we make one up
            hr = QueryString(AQVS_APPLICATION_PATH, NULL, ppsz);
            if (SUCCEEDED(hr))
            {
                PathRemoveExtensionW(*ppsz);
                PathStripPathW(*ppsz);
                ASSERT(**ppsz);
            }
            break;

        case AQVS_DDETOPIC:
            hr = SHStrDupW(L"System", ppsz);
            break;

        case AQVS_APPLICATION_FRIENDLYNAME:
            //  need to delegate to the application element
            if (!_fIsApp)
            {
                IAssociationElement *pae;
                hr = _GetAppDelegate(IID_PPV_ARG(IAssociationElement, &pae));
                if (SUCCEEDED(hr))
                {
                    hr = pae->QueryString(AQVS_APPLICATION_FRIENDLYNAME, NULL, ppsz);
                    pae->Release();
                }
            }
            break;
            
        case AQVS_APPLICATION_PATH:
            {
                CSmartCoTaskMem<OLECHAR> spszCmd;
                hr = CAssocElement::QueryString(AQVS_COMMAND, NULL, &spszCmd);
                if (SUCCEEDED(hr))
                {
                    hr = _ExeFromCmd(spszCmd, ppsz);
                }
            }
        }
    }
    return hr;
}

HRESULT CAssocShellVerbElement::QueryObject(ASSOCQUERY query, PCWSTR pszCue, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (query == AQVO_APPLICATION_DELEGATE)
    {
        hr = _GetAppDelegate(riid, ppv);
    }
    return hr;
}

HRESULT CAssocShellVerbElement::_GetAppDelegate(REFIID riid, void **ppv)
{
    CSmartCoTaskMem<OLECHAR> spszApp;
    HRESULT hr = QueryString(AQVS_APPLICATION_PATH, NULL, &spszApp);
    if (SUCCEEDED(hr))
    {
        IPersistString2 *pips;
        hr = AssocCreateElement(CLSID_AssocApplicationElement, IID_PPV_ARG(IPersistString2, &pips));
        if (SUCCEEDED(hr))
        {
            hr = pips->SetString(spszApp);
            if (SUCCEEDED(hr))
                hr = pips->QueryInterface(riid, ppv);
            pips->Release();
        }
    }
    return hr;
}

HRESULT CAssocPerceivedElement::_InitSource()
{
    //  maybe support Content Type?
    WCHAR sz[64];
    DWORD cb = sizeof(sz);
    if (ERROR_SUCCESS == SHGetValueW(HKEY_CLASSES_ROOT, _pszInit, L"PerceivedType", NULL, sz, &cb))
    {
        return _QuerySourceCreateFromKey2(HKEY_CLASSES_ROOT, L"SystemFileAssociations", sz, &_pqs);
    }
    return E_FAIL;
}

class CAssocClientElement : public CAssocShellElement
{
public:
    //  overload QS to return default MUI strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocClientElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource();

private:
    HRESULT _InitSourceFromKey(HKEY hkRoot, LPCWSTR pszKey);
    HRESULT _FixNetscapeRegistration();
    BOOL    _CreateRepairedNetscapeRegistration(HKEY hkNSCopy);
};

HRESULT CAssocClientElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    HRESULT hr;
    switch (query)
    {
    case AQS_FRIENDLYTYPENAME:
        // First try LocalizedString; if that fails, then use the default value
        // for backwards compatibility.
        hr = CAssocShellElement::QueryString(AQNS_NAMED_MUI_STRING, L"LocalizedString", ppsz);
        if (FAILED(hr))
        {
            hr = CAssocShellElement::QueryString(AQN_NAMED_VALUE, NULL, ppsz);
        }
        break;

    case AQS_DEFAULTICON:
        // First try DefaultIcon; if that fails then use the first icon of the EXE
        // associated with the "open" verb.
        hr = CAssocShellElement::QueryString(AQS_DEFAULTICON, pszCue, ppsz);
        if (FAILED(hr))
        {
            hr = CAssocShellElement::QueryString(AQVS_APPLICATION_PATH, L"open", ppsz);
        }
        break;


    default:
        hr = CAssocShellElement::QueryString(query, pszCue, ppsz);
        break;
    }
    return hr;
}

HRESULT CAssocClientElement::_InitSourceFromKey(HKEY hkRoot, LPCWSTR pszKey)
{
    DWORD dwType, cbSize;
    WCHAR szClient[80];
    cbSize = sizeof(szClient);
    LONG lRc = SHGetValueW(hkRoot, pszKey, NULL, &dwType, szClient, &cbSize);
    if (lRc == ERROR_SUCCESS && dwType == REG_SZ && szClient[0])
    {
        // Client info is kept in HKLM
        HRESULT hr = _QuerySourceCreateFromKey2(HKEY_LOCAL_MACHINE, pszKey, szClient, &_pqs);

        //
        //  If this is the Mail client and the client is Netscape Messenger,
        //  then we need to do extra work to detect the broken Netscape
        //  Navigator 4.75 mail client and fix its registration because
        //  Netscape registered incorrectly.  They always registered
        //  incorrectly, but since the only access point before Windows XP
        //  was an obscure menu option under IE/Tools/Mail and News, they
        //  never noticed that it was wrong.
        //
        if (SUCCEEDED(hr) &&
            StrCmpICW(_pszInit, L"mail") == 0 &&
            StrCmpICW(szClient, L"Netscape Messenger") == 0 &&
            FAILED(QueryExists(AQVS_COMMAND, L"open")))
        {
            hr = _FixNetscapeRegistration();
        }

        return hr;
    }
    else
    {
        return E_FAIL;          // no registered client
    }
}

//  Create a volatile copy of the Netscape registration and repair it.
//  We don't touch the original registration because...
//
//  1.  Its existence may break the Netscape uninstaller, and
//  2.  We may be running as non-administrator so don't have write access
//      anyway.

HRESULT CAssocClientElement::_FixNetscapeRegistration()
{
    HKEY hkMail;
    HRESULT hr = E_FAIL;

    if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, L"Software\\Clients\\Mail",
                                         0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                         &hkMail, NULL))
    {
        HKEY hkNSCopy;
        DWORD dwDisposition;
        if (ERROR_SUCCESS == RegCreateKeyExW(hkMail, L"Netscape Messenger",
                                             0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL,
                                             &hkNSCopy, &dwDisposition))
        {
            if (dwDisposition == REG_OPENED_EXISTING_KEY ||
                _CreateRepairedNetscapeRegistration(hkNSCopy))
            {
                // Now swap in the good registration for the bad one
                _pqs->Release();
                hr = _QuerySourceCreateFromKey(hkNSCopy, NULL, FALSE, &_pqs);
            }
            RegCloseKey(hkNSCopy);
        }
        if (FAILED(hr))
        {
            SHDeleteKeyW(hkMail, L"Netscape Messenger");
        }

        RegCloseKey(hkMail);
    }
    return hr;
}

LONG _RegQueryString(HKEY hk, PCWSTR pszSub, LPWSTR pszBuf, LONG cbBuf)
{
    return RegQueryValueW(hk, pszSub, pszBuf, &cbBuf);
}

LONG _RegSetVolatileString(HKEY hk, PCWSTR pszSub, LPCWSTR pszBuf)
{
    HKEY hkSub;
    LONG lRc;
    if (!pszSub || pszSub[0] == L'\0')
    {
        lRc = RegOpenKeyEx(hk, NULL, 0, KEY_WRITE, &hkSub);
    }
    else
    {

        lRc = RegCreateKeyExW(hk, pszSub,
                               0, NULL, REG_OPTION_VOLATILE, KEY_WRITE, NULL,
                               &hkSub, NULL);
    }
    if (lRc == ERROR_SUCCESS)
    {
        lRc = RegSetValueW(hkSub, NULL, REG_SZ, pszBuf, (lstrlenW(pszBuf) + 1) * sizeof(pszBuf[0]));
        RegCloseKey(hkSub);
    }
    return lRc;
}

BOOL CAssocClientElement::_CreateRepairedNetscapeRegistration(HKEY hkNSCopy)
{
    BOOL fSuccess = FALSE;
    HKEY hkSrc;

    // Sadly, we cannot use SHCopyKey because SHCopyKey does not work
    // on volatile keys.  So we just copy the keys we care about.

    WCHAR szBuf[MAX_PATH];

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                      L"Software\\Clients\\Mail\\Netscape Messenger",
                      0, KEY_READ, &hkSrc))
    {
        // Copy default icon but don't panic if it's not there.
        if (ERROR_SUCCESS == _RegQueryString(hkSrc, L"Protocols\\mailto\\DefaultIcon", szBuf, ARRAYSIZE(szBuf)))
        {
            // Great, Netscape also registers the wrong icon so we have to fix that too.
            PathParseIconLocationW(szBuf);
            StrCatBuffW(szBuf, L",-1349", ARRAYSIZE(szBuf));
            _RegSetVolatileString(hkNSCopy, L"DefaultIcon", szBuf);
        }

        // Copy friendly name
        if (ERROR_SUCCESS == _RegQueryString(hkSrc, NULL, szBuf, ARRAYSIZE(szBuf)) &&
            ERROR_SUCCESS == _RegSetVolatileString(hkNSCopy, NULL, szBuf))
        {
            PWSTR pszExe;
            // Copy command line, but with a new command line parameter
            if (ERROR_SUCCESS == _RegQueryString(hkSrc, L"Protocols\\mailto\\shell\\open\\command", szBuf, ARRAYSIZE(szBuf)) &&
                SUCCEEDED(_ExeFromCmd(szBuf, &pszExe)))
            {
                lstrcpynW(szBuf, pszExe, ARRAYSIZE(szBuf));
                SHFree(pszExe);
                PathQuoteSpacesW(szBuf);
                StrCatBuffW(szBuf, L" -mail", ARRAYSIZE(szBuf));
                if (ERROR_SUCCESS == _RegSetVolatileString(hkNSCopy, L"shell\\open\\command", szBuf))
                {
                    fSuccess = TRUE;
                }
            }
        }

        RegCloseKey(hkSrc);
    }
    return fSuccess;
}

HRESULT CAssocClientElement::_InitSource()
{
    // First try HKCU; if that doesn't work (no value set in HKCU or
    // the value in HKCU is bogus), then try again with HKLM.

    WCHAR szKey[MAX_PATH];
    wnsprintfW(szKey, ARRAYSIZE(szKey), L"Software\\Clients\\%s", _pszInit);

    HRESULT hr = _InitSourceFromKey(HKEY_CURRENT_USER, szKey);
    if (FAILED(hr))
    {
        hr = _InitSourceFromKey(HKEY_LOCAL_MACHINE, szKey);
    }

    return hr;
}

HRESULT AssocCreateElement(REFCLSID clsid, REFIID riid, void **ppv)
{
    IAssociationElement *pae = NULL;
    if (clsid == CLSID_AssocShellElement)
        pae = new CAssocShellElement();
    else if (clsid == CLSID_AssocProgidElement)
        pae = new CAssocProgidElement();
    else if (clsid == CLSID_AssocClsidElement)
        pae = new CAssocClsidElement();
    else if (clsid == CLSID_AssocSystemElement)
        pae = new CAssocSystemExtElement();
    else if (clsid == CLSID_AssocPerceivedElement)
        pae = new CAssocPerceivedElement();
    else if (clsid == CLSID_AssocApplicationElement)
        pae = new CAssocApplicationElement();
    else if (clsid == CLSID_AssocFolderElement)
        pae = new CAssocFolderElement();
    else if (clsid == CLSID_AssocStarElement)
        pae = new CAssocStarElement();
    else if (clsid == CLSID_AssocClientElement)
        pae = new CAssocClientElement();

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    if (pae)
    {
        hr = pae->QueryInterface(riid, ppv);
        pae->Release();
    }
    else
        *ppv = 0;
    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

BOOL IsExplorerWindow(HWND hwnd);
BOOL IsFolderWindow(HWND hwnd);
BOOL IsTrayWindow(HWND hwnd);

BOOL MyInternetSetOption(HANDLE h, DWORD dw1, LPVOID lpv, DWORD dw2);
STDAPI_(BOOL) IsDesktopWindow(HWND hwnd);
HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType, OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData);

STDAPI IsSafePage(IUnknown *punkSite);
STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk);


BOOL IconSetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue);
BOOL IconGetRegNameString(const CLSID* pclsid, LPTSTR lpszValue, int cchValue);
BOOL IconGetRegIconString(const CLSID* pclsid, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue);

BOOL CALLBACK Cabinet_RefreshEnum(HWND hwnd, LPARAM lParam);
BOOL CALLBACK Cabinet_UpdateWebViewEnum(HWND hwnd, LPARAM lParam);
void Cabinet_RefreshAll(WNDENUMPROC lpEnumFunc, LPARAM lParam);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\aboutinf.cpp ===
#include <string.h>
#include <ntverp.h>
#include "priv.h"
#include "ids.h"

#define SECURITY_WIN32
#include <schnlsp.h>    // for UNISP_NAME_A
#include <sspi.h>       // for SCHANNEL.dll api -- to obtain encryption key size

#include <mluisupp.h>
#include <wininet.h>    // INTERNET_MAX_URL_LENGTH


typedef PSecurityFunctionTableA (APIENTRY *INITSECURITYINTERFACE_FN_A)(void);

// Returns the maximum cipher strength
DWORD GetCipherStrength()
{
    static DWORD dwKeySize = (DWORD)-1;
    
    if (dwKeySize == (DWORD)-1)
    {
        HINSTANCE hSecurity;

        dwKeySize = 0;

        hSecurity = LoadLibrary(TEXT("security.dll"));
        if (hSecurity)
        {
            INITSECURITYINTERFACE_FN_A pfnInitSecurityInterfaceA;

            // Get the SSPI dispatch table
            pfnInitSecurityInterfaceA = (INITSECURITYINTERFACE_FN_A)GetProcAddress(hSecurity, "InitSecurityInterfaceA");
            if (pfnInitSecurityInterfaceA)
            {
                PSecurityFunctionTableA pSecFuncTable;

                pSecFuncTable = pfnInitSecurityInterfaceA();
                if (pSecFuncTable                               &&
                    pSecFuncTable->AcquireCredentialsHandleA    &&
                    pSecFuncTable->QueryCredentialsAttributesA)
                {
                    TimeStamp  tsExpiry;
                    CredHandle chCred;
                    SecPkgCred_CipherStrengths cs;

                    if (SEC_E_OK == (*pSecFuncTable->AcquireCredentialsHandleA)(NULL,
                                                                                UNISP_NAME_A, // Package
                                                                                SECPKG_CRED_OUTBOUND,
                                                                                NULL,
                                                                                NULL,
                                                                                NULL,
                                                                                NULL,
                                                                                &chCred,      // Handle
                                                                                &tsExpiry))
                    {
                        if (SEC_E_OK == (*pSecFuncTable->QueryCredentialsAttributesA)(&chCred, SECPKG_ATTR_CIPHER_STRENGTHS, &cs))
                        {
                            dwKeySize = cs.dwMaximumCipherStrength;
                        }

                        // Free the handle if we can
                        if (pSecFuncTable->FreeCredentialsHandle)
                        {
                            (*pSecFuncTable->FreeCredentialsHandle)(&chCred);
                        }
                    }
                }
            }
            
            FreeLibrary(hSecurity);
        }
    }
    
    return dwKeySize;
}

typedef struct
{
    WCHAR szVersion[64];
    WCHAR szVBLVersion[64];
    WCHAR szCustomizedVersion[3];
    WCHAR szUserName[256];
    WCHAR szCompanyName[256];
    DWORD dwKeySize;
    WCHAR szProductId[256];
    WCHAR szUpdateUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR szIEAKStr[256];
} SHABOUTINFOW;

BOOL SHAboutInfoW(LPWSTR pszInfo, DWORD cchInfo)
{
    HRESULT hr = E_FAIL;

    if (cchInfo > 0)
    {
        SHABOUTINFOW* pInfo;
        
        pszInfo[0] = L'\0';
        
        pInfo = (SHABOUTINFOW*)LocalAlloc(LPTR, sizeof(SHABOUTINFOW));
        if (pInfo)
        {
            DWORD cbSize;

            if (GetModuleHandle(TEXT("EXPLORER.EXE")) || GetModuleHandle(TEXT("IEXPLORE.EXE")))
            {
                // get the Version number (version string is in the following format 5.00.xxxx.x)
                cbSize = sizeof(pInfo->szVersion);
                SHRegGetValueW(HKEY_LOCAL_MACHINE,
                               L"SOFTWARE\\Microsoft\\Internet Explorer",
                               L"Version",
                               SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                               NULL,
                               pInfo->szVersion,
                               &cbSize);

                // get the VBL version info (vbl string is in the following format 2600.lab.yymmdd)
                cbSize = sizeof(pInfo->szVBLVersion);
                if (ERROR_SUCCESS == SHRegGetValueW(HKEY_LOCAL_MACHINE,
                                                    L"Software\\Microsoft\\Windows NT\\Current Version",
                                                    L"BuildLab",
                                                    SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                                                    NULL,
                                                    pInfo->szVBLVersion,
                                                    &cbSize))
                {
                    int cchVBLVersion = lstrlenW(pInfo->szVBLVersion);
                    
                    if (cchVBLVersion > 12) // 12 for "2600.?.yymmdd"
                    {
                        // The "BuildLab" reg value contains the VBL build # in the format: "2204.reinerf.010700"
                        // Since we are only interested in the latter part, we remove the first 4 digits
                        MoveMemory(pInfo->szVBLVersion, &pInfo->szVBLVersion[4], (cchVBLVersion - 4 + 1) * sizeof(WCHAR));
                    }
                    else
                    {
                        pInfo->szVBLVersion[0] = L'\0';
                    }
                }
            }
            else
            {
                // Not in the explorer or iexplore process so we are doing some side by side stuff so
                // reflect this in the version string. Maybe we should get the version out of MSHTML
                // but not sure since this still doesn't reflect IE4 or IE5 properly anyway.
                MLLoadStringW(IDS_SIDEBYSIDE, pInfo->szVersion, ARRAYSIZE(pInfo->szVersion));
            }

            // added by pritobla on 9/1/98
            // CustomizedVersion contains a 2-letter code that identifies what mode was used
            // (CORP, ICP, ISP, etc.) in building this version IE using the IEAK.
            cbSize = sizeof(pInfo->szCustomizedVersion);
            SHRegGetValueW(HKEY_LOCAL_MACHINE,
                           L"SOFTWARE\\Microsoft\\Internet Explorer",
                           L"CustomizedVersion",
                           SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                           NULL,
                           pInfo->szCustomizedVersion,
                           &cbSize);
                    
            // get the User name.
            cbSize = sizeof(pInfo->szUserName);
            SHRegGetValueW(HKEY_LOCAL_MACHINE,
                           L"Software\\Microsoft\\Windows NT\\Current Version",
                           L"RegisteredOwner",
                           SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                           NULL,
                           pInfo->szUserName,
                           &cbSize);

            // get the Organization name.
            cbSize = sizeof(pInfo->szCompanyName);
            SHRegGetValueW(HKEY_LOCAL_MACHINE,
                           L"Software\\Microsoft\\Windows NT\\Current Version",
                           L"RegisteredOrganization",
                           SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                           NULL,
                           pInfo->szCompanyName,
                           &cbSize);

            // get the encription key size
            pInfo->dwKeySize = GetCipherStrength();

            cbSize = sizeof(pInfo->szProductId);
            SHRegGetValueW(HKEY_LOCAL_MACHINE,
                           L"SOFTWARE\\Microsoft\\Internet Explorer\\Registration",
                           L"ProductId",
                           SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                           NULL,
                           pInfo->szProductId,
                           &cbSize);

            // get the custom IEAK update url
            // (always get from Windows\CurrentVersion because IEAK policy file must be independent)
            cbSize = sizeof(pInfo->szUpdateUrl);
            SHRegGetValueW(HKEY_LOCAL_MACHINE,
                           L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion",
                           L"IEAKUpdateUrl",
                           SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                           NULL,
                           pInfo->szUpdateUrl,
                           &cbSize);

            // get the custom IEAK branded help string
            cbSize = sizeof(pInfo->szIEAKStr);
            SHRegGetValueW(HKEY_LOCAL_MACHINE,
                           L"SOFTWARE\\Microsoft\\Internet Explorer\\Registration",
                           L"IEAKHelpString",
                           SRRF_RT_REG_SZ | SRRF_ZEROONFAILURE,
                           NULL,
                           pInfo->szIEAKStr,
                           &cbSize);

            // glue all of the peices together
            hr = StringCchPrintfExW(pszInfo,
                                    cchInfo,
                                    NULL,
                                    NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s%s%s~%s~%s~%d~%s~%s~%s",
                                    pInfo->szVersion,
                                    pInfo->szVBLVersion,
                                    pInfo->szCustomizedVersion,
                                    pInfo->szUserName,
                                    pInfo->szCompanyName,
                                    pInfo->dwKeySize,
                                    pInfo->szProductId,
                                    pInfo->szUpdateUrl,
                                    pInfo->szIEAKStr);

            LocalFree(pInfo);
        }
    }

    return SUCCEEDED(hr);
}

BOOL SHAboutInfoA(LPSTR pszInfoA, DWORD cchInfoA)
{
    BOOL bRet = FALSE; 
    LPWSTR pszTemp;

    if (cchInfoA > 0)
    {
        DWORD cchTemp = cchInfoA;

        pszInfoA[0] = '\0';

        pszTemp = (LPWSTR)LocalAlloc(LPTR, cchTemp * sizeof(WCHAR));
        if (pszTemp)
        {
            bRet = SHAboutInfoW(pszTemp, cchTemp) && SHUnicodeToAnsi(pszTemp, pszInfoA, cchInfoA);
            LocalFree(pszTemp);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\color.c ===
#include "priv.h"

// Copied mostly from Desk.cpl.
#define  RANGE   240            // range of values for HLS scrollbars 
                                // HLS-RGB conversions work best when
                                // RANGE is divisible by 6 
#define  HLSMAX   RANGE
#define  RGBMAX   255
#define UNDEFINED (HLSMAX*2/3)  //Hue is undefined if Saturation is 0 (grey-scale)



//-------------------------------------------------------------------------
// ColorRGBToHLS
//
// Purpose: Convert RGB to HLS
//
// A point of reference for the algorithms is Foley and Van Dam, pp. 618-19.
// Their algorithm is in floating point.  CHART implements a less general
// (hardwired ranges) integral algorithm.


// There are potential roundoff errors lurking throughout here.
//   (0.5 + x/y) without floating point,
//      (x/y) phrased ((x + (y/2))/y)
//   yields very small roundoff error.
//   This makes many of the following divisions look funny.

// H,L, and S vary over 0-HLSMAX
// R,G, and B vary over 0-RGBMAX
// HLSMAX BEST IF DIVISIBLE BY 6
// RGBMAX, HLSMAX must each fit in a byte. 

STDAPI_(void) ColorRGBToHLS(COLORREF clrRGB, WORD* pwHue, WORD* pwLuminance, WORD* pwSaturation)
{
    int R,G,B;                /* input RGB values */
    WORD cMax,cMin;        /* max and min RGB values */
    WORD cSum,cDif;
    int  Rdelta,Gdelta,Bdelta;  /* intermediate value: % of spread from max */
    int H, L, S;

    /* get R, G, and B out of DWORD */
    R = GetRValue(clrRGB);
    G = GetGValue(clrRGB);
    B = GetBValue(clrRGB);

    /* calculate lightness */
    cMax = max( max(R,G), B);
    cMin = min( min(R,G), B);
    cSum = cMax + cMin;
    L = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX )/(2*RGBMAX));

    cDif = cMax - cMin;
    if (!cDif)   	/* r=g=b --> achromatic case */
    {
        S = 0;                         /* saturation */
        H = UNDEFINED;                 /* hue */
    }
    else                           /* chromatic case */
    {
        /* saturation */
        if (L <= (HLSMAX/2))
            S = (WORD) (((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
        else
            S = (WORD) ((DWORD) ((cDif * (DWORD) HLSMAX) + (DWORD)((2*RGBMAX-cSum)/2) )
                                                 / (2*RGBMAX-cSum));
        /* hue */
        Rdelta = (int) (( ((cMax-R)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
        Gdelta = (int) (( ((cMax-G)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
        Bdelta = (int) (( ((cMax-B)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);

        if ((WORD) R == cMax)
            H = Bdelta - Gdelta;
        else if ((WORD) G == cMax)
            H = (HLSMAX/3) + Rdelta - Bdelta;
        else /* B == cMax */
            H = ((2*HLSMAX)/3) + Gdelta - Rdelta;

        if (H < 0)
            H += HLSMAX;
        if (H > HLSMAX)
            H -= HLSMAX;
    }

   ASSERT( pwHue && pwLuminance && pwSaturation );
   *pwHue = (WORD) H;
   *pwLuminance = (WORD) L;
   *pwSaturation = (WORD) S;
}


/* utility routine for HLStoRGB */
WORD HueToRGB(WORD n1, WORD n2, WORD hue)
{

   /* range check: note values passed add/subtract thirds of range */

   /* The following is redundant for WORD (unsigned int) */

   if (hue > HLSMAX)
      hue -= HLSMAX;

   /* return r,g, or b value from this tridrant */
   if (hue < (HLSMAX/6))
      return ( n1 + (((n2-n1)*hue+(HLSMAX/12))/(HLSMAX/6)) );
   if (hue < (HLSMAX/2))
      return ( n2 );
   if (hue < ((HLSMAX*2)/3))
      return ( n1 + (((n2-n1)*(((HLSMAX*2)/3)-hue)+(HLSMAX/12)) / (HLSMAX/6)) );
   else
      return ( n1 );
}


//-------------------------------------------------------------------------
// ColorHLSToRGB
//
// Purpose: Convert HLS to RGB

STDAPI_(COLORREF) ColorHLSToRGB(WORD wHue, WORD wLuminance, WORD wSaturation)
{
    WORD R,G,B;                      /* RGB component values */
    WORD  Magic1,Magic2;       /* calculated magic numbers (really!) */

    if (wSaturation == 0)                /* achromatic case */
    {
        R = G = B = (wLuminance * RGBMAX) / HLSMAX;
        if (wHue != UNDEFINED)
        {
            R = G = B = 0;
        }
    }
    else                         /* chromatic case */
    {
        /* set up magic numbers */
        if (wLuminance <= (HLSMAX/2))
          Magic2 = (WORD)((wLuminance * ((DWORD)HLSMAX + wSaturation) + (HLSMAX/2))/HLSMAX);
        else
          Magic2 = wLuminance + wSaturation - (WORD)(((wLuminance*wSaturation) + (DWORD)(HLSMAX/2))/HLSMAX);
        Magic1 = 2*wLuminance-Magic2;

        /* get RGB, change units from HLSMAX to RGBMAX */
        R = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(wHue+(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
        G = (WORD)((HueToRGB(Magic1,Magic2,wHue)*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX;
        B = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(wHue-(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
    }

    return(RGB(R,G,B));
}


//-------------------------------------------------------------------------
// ColorAdjustLuma
//
// Purpose: Adjusts the luma of an RGB value

STDAPI_(COLORREF) ColorAdjustLuma(COLORREF clrRGB, int n, BOOL fScale)
{
    WORD H, L, S;

    if (n == 0)
        return clrRGB;

    ColorRGBToHLS(clrRGB, &H, &L, &S);

    if (fScale)
    {
        if (n > 0)
        {
            return ColorHLSToRGB((WORD)H, (WORD)(((long)L * (1000 - n) + (RANGE + 1l) * n) / 1000), (WORD)S);
        }
        else
        {
            return ColorHLSToRGB((WORD)H, (WORD)(((long)L * (n + 1000)) / 1000), (WORD)S);
        }
    }

    L += (int)((long)n * RANGE / 1000);

    if (L < 0)
        L = 0;
    if (L > HLSMAX)
        L = HLSMAX;

    return ColorHLSToRGB((WORD)H, (WORD)L, (WORD)S);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\datablok.cpp ===
#include "priv.h"
#include "stream.h"

#define _DBLNext(pdbList) ((LPDBLIST)(((LPBYTE)(pdbList)) + (pdbList)->cbSize ))
#define DBSIG_WRAP ((DWORD)-1)

STDAPI SHWriteDataBlockList(IStream* pstm, LPDBLIST pdbList)
{
    HRESULT hr = S_OK;

    if (pdbList)
    {
        for ( ; pdbList->cbSize; pdbList = _DBLNext(pdbList))
        {
            LPDATABLOCK_HEADER pdb;
            ULONG cbBytes;

            pdb = pdbList;
            if (DBSIG_WRAP == pdb->dwSignature)
                pdb++;

            TraceMsg(TF_DBLIST, "Writing extra data block, size:%x sig:%x", pdb->cbSize, pdb->dwSignature);
    
            if (FAILED(hr = ((CMemStream*)pstm)->Write((LPBYTE)pdb, pdb->cbSize, &cbBytes)))
                break;
    
            if (cbBytes != pdb->cbSize)
            {
                hr = STG_E_MEDIUMFULL;
                break;
            }
        }
    }

    // NULL terminate the list
    if (SUCCEEDED(hr))
    {
        DWORD dwData = 0;
        DWORD cbBytes;
        hr = ((CMemStream*)pstm)->Write(&dwData, sizeof(dwData), &cbBytes);
    }

    return(hr);
}

STDAPI SHReadDataBlockList(IStream* pstm, LPDBLIST * ppdbList)
{
    HRESULT hr;
    BYTE buf[200]; // all blocks today fit in this size (tested at 5)
    LPDATABLOCK_HEADER lpBuf = (LPDATABLOCK_HEADER)buf;
    DWORD cbBuf = sizeof(buf);
    DWORD dwSizeToRead, cbBytes;

    if (*ppdbList)
    {
        LocalFree((HLOCAL)(*ppdbList));
        *ppdbList = NULL;
    }

    while (TRUE)
    {
        DWORD cbSize;
        dwSizeToRead = sizeof(cbSize);
        hr = ((CMemStream*)pstm)->Read(&cbSize, dwSizeToRead, &cbBytes);
        if (SUCCEEDED(hr) && (cbBytes == dwSizeToRead))
        {

            // Windows 95 and NT 4 shipped a CShellLink that did NOT
            // NULL terminate the data it wrote out to the stream.
            // If more data was persisted after the CShellLink then
            // we will read in garbage. No real harm comes of this (*)
            // (because it is unlikely we'll get a dwSignature match)
            // but if the first dword is huge, we'll allocate a ton
            // of memory and page it in. This can take MINUTES on Win95.
            // Assume anything over 64K is from one of these
            // bogus streams.
            //
            // (*) actually, real harm comes because we don't leave the
            // stream in the correct place. Forms^3 put a work-around
            // in for this bug.
            //
            if (cbSize > 0x0000FFFF)
            {
                ULARGE_INTEGER liStart;
                LARGE_INTEGER liMove;

                // We read a DWORD of data that wasn't ours, back up.
                // NOTE: all of our stream implementations assume
                //       HighPart == 0
                //
                liMove.HighPart = liMove.LowPart = 0;
                if (SUCCEEDED(((CMemStream*)pstm)->Seek(liMove, STREAM_SEEK_CUR, &liStart)))
                {
                    ASSERT(liStart.HighPart == 0);
                    ASSERT(liStart.LowPart >= sizeof(cbSize));
                    liMove.LowPart = liStart.LowPart - sizeof(cbSize);

                    ((CMemStream*)pstm)->Seek(liMove, STREAM_SEEK_SET, NULL);
                }

                TraceMsg(TF_DBLIST, "ASSUMING NO NULL TERMINATION (FOR SIZE 0x%x)", cbSize);
                cbSize = 0;
            }

            // If we hit the 0 terminator, we're done.
            //
            if (cbSize < sizeof(DATABLOCK_HEADER))
                break;

            // Make sure we can read this block in.
            //
            if (cbSize > cbBuf)
            {
                HLOCAL pTemp;

                if (lpBuf == (LPDATABLOCK_HEADER)buf)
                    pTemp = LocalAlloc(LPTR, cbSize);
                else
                    pTemp = LocalReAlloc((HLOCAL)lpBuf, cbSize, LMEM_ZEROINIT | LMEM_MOVEABLE);

                if (pTemp)
                {
                    lpBuf = (LPDATABLOCK_HEADER)pTemp;
                    cbBuf = cbSize;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            // Read in data block
            //
            lpBuf->cbSize = cbSize;
            dwSizeToRead = cbSize - sizeof(cbSize);
            hr = ((CMemStream*)pstm)->Read((LPBYTE)&(lpBuf->dwSignature), dwSizeToRead, &cbBytes);
            if (SUCCEEDED(hr) && (cbBytes == dwSizeToRead))
            {
                TraceMsg(TF_DBLIST, "Reading extra data block, size:%x sig:%x", lpBuf->cbSize, lpBuf->dwSignature);

                SHAddDataBlock(ppdbList, lpBuf);
            }
            else
                break;
        }
        else
            break;
    }

    // Free any allocated buffer
    //
    if (lpBuf != (LPDATABLOCK_HEADER)buf)
    {
        LocalFree((HLOCAL)lpBuf);
    }

    return hr;
}

STDAPI_(void) SHFreeDataBlockList(LPDBLIST pdbList)
{
    if (pdbList)
    {
        LocalFree((HLOCAL)pdbList);
    }
}

STDAPI_(BOOL) SHAddDataBlock(LPDBLIST * ppdbList, LPDATABLOCK_HEADER pdb)
{
    LPDBLIST pdbCopyTo = NULL;
    DWORD dwSize;

    // Don't let anyone use our special signature
    //
    if (DBSIG_WRAP == pdb->dwSignature ||
        pdb->cbSize < sizeof(*pdb))
    {
        TraceMsg(TF_DBLIST, "SHAddDataBlock invalid datablock! (sig:%x size:%x)", pdb->dwSignature, pdb->cbSize);
        return FALSE;
    }

    // Figure out how much space we need to hold this block
    //
    dwSize = pdb->cbSize;
    if (pdb->cbSize & 0x3)
    {
        dwSize = ((dwSize + 3) & ~0x3) + sizeof(DATABLOCK_HEADER);

        TraceMsg(TF_DBLIST, "Adding non-DWORD data block, size:%x sig:%x", pdb->cbSize, pdb->dwSignature);
    }
    else
    {
        TraceMsg(TF_DBLIST, "Adding data block, size:%x sig:%x", pdb->cbSize, pdb->dwSignature);
    }

    // Allocate the space
    //
    if (!*ppdbList)
    {
        *ppdbList = (LPDBLIST)LocalAlloc(LPTR, dwSize + sizeof(DWORD)); // include NULL terminator
        pdbCopyTo = *ppdbList;
    }
    else
    {
        DWORD dwTotalSize = 0;
        LPDBLIST pdbList;
        HLOCAL lpTmp;

        for (pdbList = *ppdbList ; pdbList->cbSize ; pdbList = _DBLNext(pdbList))
            dwTotalSize += pdbList->cbSize;

        lpTmp = LocalReAlloc((HLOCAL)*ppdbList, dwTotalSize + dwSize + sizeof(DWORD), // include NULL terminator
                             LMEM_ZEROINIT | LMEM_MOVEABLE);
        if (lpTmp)
        {
            *ppdbList = (LPDBLIST)lpTmp;
            pdbCopyTo = (LPDBLIST)(((LPBYTE)lpTmp) + dwTotalSize);
        }
    }

    // Copy the data block
    //
    if (pdbCopyTo)
    {
        LPBYTE pTmp = (LPBYTE)pdbCopyTo;

        // This block would cause other blocks to be
        // unaligned, wrap it
        //
        ASSERT(0 == (dwSize & 0x3));
        if (dwSize != pdb->cbSize)
        {
            pdbCopyTo->cbSize = dwSize;
            pdbCopyTo->dwSignature = DBSIG_WRAP;
            pTmp = (LPBYTE)(pdbCopyTo + 1);
        }
        CopyMemory(pTmp, pdb, pdb->cbSize);

        // NULL terminate the list
        _DBLNext(pdbCopyTo)->cbSize = 0;

        return TRUE;
    }

    return FALSE;
}

STDAPI_(BOOL) SHRemoveDataBlock(LPDBLIST * ppdbList, DWORD dwSignature)
{
    LPDBLIST pdbRemove = NULL;

    // Can't call SHFindDataBlock because that returnes the
    // block that was wrapped, we want the block that wraps.
    //
    if (*ppdbList)
    {
        LPDBLIST pdbList = *ppdbList;

        for ( ; pdbList->cbSize ; pdbList = _DBLNext(pdbList))
        {
            if (dwSignature == pdbList->dwSignature)
            {
                TraceMsg(TF_DBLIST, "Removing data block, size:%x sig:%x ptr:%x", pdbList->cbSize, pdbList->dwSignature, pdbList);
                pdbRemove = pdbList;
                break;
            }
            else if (DBSIG_WRAP == pdbList->dwSignature)
            {
                LPDBLIST pdbWrap = pdbList + 1;
                if (dwSignature == pdbWrap->dwSignature)
                {
                    TraceMsg(TF_DBLIST, "Removing non-DWORD data block, size:%x sig:%x ptr:", pdbWrap->cbSize, pdbWrap->dwSignature, pdbWrap);
                    pdbRemove = pdbList;
                    break;
                }
            }
        }
    }

    if (pdbRemove)
    {
        LPDBLIST pdbNext = _DBLNext(pdbRemove);
        LPDBLIST pdbEnd;
        DWORD dwSizeOfBlockToRemove;
        LONG lNewSize;

        for (pdbEnd = pdbNext ; pdbEnd->cbSize ; pdbEnd = _DBLNext(pdbEnd))
            ;

        dwSizeOfBlockToRemove = pdbRemove->cbSize;

        // Move remaining memory down
        MoveMemory(pdbRemove, pdbNext, (DWORD_PTR)pdbEnd - (DWORD_PTR)pdbNext + sizeof(DWORD));

        // Shrink our buffer
        lNewSize = (LONG) LocalSize(*ppdbList ) - dwSizeOfBlockToRemove;
        if (lNewSize > sizeof(DWORD))
        {
            void *lpVoid = LocalReAlloc( (HLOCAL)*ppdbList, lNewSize, LMEM_ZEROINIT | LMEM_MOVEABLE );
            if (NULL != lpVoid)
            {
                *ppdbList = (LPDBLIST)lpVoid;
            }
        }
        else
        {
            // We've removed the last section, delete the whole deal
            LocalFree( (HLOCAL)(*ppdbList) );
            *ppdbList = NULL;

        }

        return TRUE;
    }

    return FALSE;
}

STDAPI_(void *) SHFindDataBlock(LPDBLIST pdbList, DWORD dwSignature)
{
    if (pdbList)
    {
        for ( ; pdbList->cbSize ; pdbList = _DBLNext(pdbList))
        {
            if (dwSignature == pdbList->dwSignature)
            {
                TraceMsg(TF_DBLIST, "Found data block, size:%x sig:%x ptr:%x", pdbList->cbSize, pdbList->dwSignature, pdbList);

                return (void *)pdbList;
            }
            else if (DBSIG_WRAP == pdbList->dwSignature)
            {
                LPDBLIST pdbWrap = pdbList + 1;
                if (dwSignature == pdbWrap->dwSignature)
                {
                    TraceMsg(TF_DBLIST, "Found non-DWORD data block, size:%x sig:%x ptr:%x", pdbWrap->cbSize, pdbWrap->dwSignature, pdbWrap);

                    return (void *)pdbWrap;
                }
            }
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\debug.c ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shlwapi"
#define SZ_MODULE           "SHLWAPI"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\assocapi.cpp ===
//
//
//  assocapi.cpp
//
//     Association APIs
//
//
//


#include "priv.h"
 #include <shstr.h>

#include <msi.h>
#include "assoc.h"
#include <filetype.h>

BOOL _PathAppend(LPCTSTR pszBase, LPCTSTR pszAppend, LPTSTR pszOut, DWORD cchOut);
void _MakeAppPathKey(LPCTSTR pszApp, LPTSTR pszKey, DWORD cchKey)
{
    if (_PathAppend(REGSTR_PATH_APPPATHS, pszApp, pszKey, cchKey))
    {
        // Currently we will only look up .EXE if an extension is not
        // specified
        if (*PathFindExtension(pszApp) == 0)
        {
            StrCatBuff(pszKey, TEXT(".exe"), cchKey);
        }
    }
}

void _MakeApplicationsKey(LPCWSTR pszApp, LPWSTR pszKey, DWORD cchKey)
{
    if (_PathAppend(TEXT("Applications"), pszApp, pszKey, cchKey))
    {
        // Currently we will only look up .EXE if an extension is not
        // specified
        if (*PathFindExtension(pszApp) == 0)
        {
            StrCatBuff(pszKey, TEXT(".exe"), cchKey);
        }
    }
}

HRESULT _AssocOpenRegKey(HKEY hk, LPCTSTR pszSub, HKEY *phkOut, BOOL fCreate)
{
    ASSERT(phkOut);
    *phkOut = NULL;
    if (!hk)
        return HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
        
    DWORD err;
    if (!fCreate)
        err = RegOpenKeyEx(hk, pszSub, 0, MAXIMUM_ALLOWED, phkOut);
    else
        err = RegCreateKeyEx(hk, pszSub, 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, phkOut, NULL);

    if (ERROR_SUCCESS != err)
    {
        ASSERT(!*phkOut);
        return HRESULT_FROM_WIN32(err);
    }
    return S_OK;
}
        
LWSTDAPI AssocCreate(CLSID clsid, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hr = E_INVALIDARG;

    if (ppvOut)
    {
        if (IsEqualGUID(clsid, CLSID_QueryAssociations) 
             || IsEqualGUID(clsid, IID_IQueryAssociations))
        {
            hr = SHCoCreateInstance(NULL, &CLSID_QueryAssociations, NULL, riid, ppvOut);
        }
        else
            hr = AssocCreateElement(clsid, riid, ppvOut);
    }
    return hr;
}

#define ASSOCF_INIT_ALL      (ASSOCF_INIT_BYEXENAME | ASSOCF_INIT_DEFAULTTOFOLDER | ASSOCF_INIT_DEFAULTTOSTAR | ASSOCF_INIT_NOREMAPCLSID)

LWSTDAPI AssocQueryStringW(ASSOCF flags, ASSOCSTR str, LPCWSTR pszAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut)
{
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&passoc);
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(flags & ASSOCF_INIT_ALL, pszAssoc, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = passoc->GetString(flags, str, pszExtra, pszOut, pcchOut);

        passoc->Release();
    }
    return hr;
}

LWSTDAPI AssocQueryStringA(ASSOCF flags, ASSOCSTR str, LPCSTR pszAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut)
{
    if (!pcchOut)
        return E_INVALIDARG;
        
    HRESULT hr = E_OUTOFMEMORY;
    SHSTRW strAssoc, strExtra;

    if (SUCCEEDED(strAssoc.SetStr(pszAssoc))
    &&  SUCCEEDED(strExtra.SetStr(pszExtra)))
    {
        SHSTRW strOut;
        DWORD cchIn = IS_INTRESOURCE(pcchOut) ? PtrToUlong(pcchOut) : *pcchOut;
        DWORD cch;
        LPTSTR pszTemp = NULL;

        if (pszOut)
        {
            strOut.SetSize(cchIn);
            cch = strOut.GetSize();
            pszTemp = strOut.GetInplaceStr();            
        }

        hr = AssocQueryStringW(flags, str, strAssoc, strExtra, pszTemp, &cch);

        if (SUCCEEDED(hr))
        {
            cch = SHUnicodeToAnsi(strOut, pszOut, cchIn);

            if (!IS_INTRESOURCE(pcchOut))
                *pcchOut = cch;
        }
    }

    return hr;
}

LWSTDAPI AssocQueryStringByKeyW(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut)
{
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&passoc);
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(flags & ASSOCF_INIT_ALL, NULL, hkAssoc, NULL);

        if (SUCCEEDED(hr))
            hr = passoc->GetString(flags, str, pszExtra, pszOut, pcchOut);

        passoc->Release();
    }

    return hr;
}

LWSTDAPI AssocQueryStringByKeyA(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut)
{
    if (!pcchOut)
        return E_INVALIDARG;
        
    HRESULT hr = E_OUTOFMEMORY;
    SHSTRW strExtra;

    if (SUCCEEDED(strExtra.SetStr(pszExtra)))
    {
        SHSTRW strOut;
        DWORD cchIn = IS_INTRESOURCE(pcchOut) ? PtrToUlong(pcchOut) : *pcchOut;
        DWORD cch;
        LPWSTR pszTemp = NULL;

        if (pszOut)
        {
            strOut.SetSize(cchIn);
            cch = strOut.GetSize();
            pszTemp = strOut.GetInplaceStr();            
        }

        hr = AssocQueryStringByKeyW(flags, str, hkAssoc, strExtra, pszTemp, &cch);

        if (SUCCEEDED(hr))
        {
            cch = SHUnicodeToAnsi(strOut, pszOut, cchIn);

            if (!IS_INTRESOURCE(pcchOut))
                *pcchOut = cch;
        }
    }

    return hr;
}

LWSTDAPI AssocQueryKeyW(ASSOCF flags, ASSOCKEY key, LPCWSTR pszAssoc, LPCWSTR pszExtra, HKEY *phkey)
{
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&passoc);
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(flags & ASSOCF_INIT_ALL, pszAssoc, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = passoc->GetKey(flags, key, pszExtra, phkey);

        passoc->Release();
    }

    return hr;
}

LWSTDAPI AssocQueryKeyA(ASSOCF flags, ASSOCKEY key, LPCSTR pszAssoc, LPCSTR pszExtra, HKEY *phkey)
{
        
    HRESULT hr = E_OUTOFMEMORY;
    SHSTRW strAssoc, strExtra;

    if (SUCCEEDED(strAssoc.SetStr(pszAssoc))
    &&  SUCCEEDED(strExtra.SetStr(pszExtra)))
    {
        hr = AssocQueryKeyW(flags, key, strAssoc, strExtra, phkey);

    }

    return hr;
}

#define ISQUOTED(s)   (TEXT('"') == *(s) && TEXT('"') == *((s) + lstrlen(s) - 1))

BOOL _TrySubst(SHSTR& str, LPCTSTR psz)
{
    BOOL fRet = FALSE;
    TCHAR szVar[MAX_PATH];
    DWORD cch = GetEnvironmentVariable(psz, szVar, SIZECHARS(szVar));

    if (cch && cch <= SIZECHARS(szVar))
    {
        if (0 == StrCmpNI(str, szVar, cch))
        {
            //  we got a match. 
            //  size the buffer for the env var... +3 = (% + % + \0)
            SHSTR strT;
            if (S_OK == strT.SetStr(str.GetStr() + cch)                
                && S_OK == str.SetSize(str.GetLen() - cch + lstrlen(psz) + 3)

               )
            {
                wnsprintf(str.GetInplaceStr(), str.GetSize(), TEXT("%%%s%%%s"), psz, strT.GetStr());
                fRet = TRUE;
            }
        }
    }
    return fRet;
}
    
BOOL _TryEnvSubst(SHSTR& str)
{
    static LPCTSTR rgszEnv[] = {
        TEXT("USERPROFILE"),
        TEXT("ProgramFiles"),
        TEXT("SystemRoot"),
        TEXT("SystemDrive"),
        TEXT("windir"),
        NULL
    };

    LPCTSTR *ppsz = rgszEnv;
    BOOL fRet = FALSE;

    while (*ppsz && !fRet)
    {
        fRet = _TrySubst(str, *ppsz++);
    }

    return fRet;
}

HRESULT _MakeCommandString(ASSOCF *pflags, LPCTSTR pszExe, LPCTSTR pszArgs, SHSTR& str)
{
    SHSTR strArgs;
    HRESULT hr;
    
    if (!pszArgs || !*pszArgs)
    {
        //  default to just passing the 
        //  file name right in.
        //  NOTE 16bit apps might have a problem with
        //  this, but i request that the caller
        //  specify that this is the case....
        pszArgs = TEXT("\"%1\"");
    }
    //  else NO _ParseCommand()

    hr = str.SetStr(pszExe);

    if (S_OK == hr)
    {
        //  check for quotes before doing env subst
        BOOL fNeedQuotes = (!ISQUOTED(str.GetStr()) && PathIsLFNFileSpec(str));
        
        //  this will put environment vars into the string...
        if ((*pflags & ASSOCMAKEF_SUBSTENV) && _TryEnvSubst(str))
        {
            *pflags |= ASSOCMAKEF_USEEXPAND;
        }

        str.Trim();

        if (fNeedQuotes)
        {
            //  3 = " + " + \0
            if (S_OK == str.SetSize(str.GetLen() + 3))
                PathQuoteSpaces(str.GetInplaceStr());
        }

        hr = str.Append(TEXT(' '));

        if (S_OK == hr)
        {
            hr = str.Append(pszArgs);
        }
    }

    return hr;
}
        
HRESULT _AssocMakeCommand(ASSOCMAKEF flags, HKEY hkVerb, LPCWSTR pszExe, LPCWSTR pszArgs)
{                    
    ASSERT(hkVerb && pszExe);
    SHSTR str;
    HRESULT hr = _MakeCommandString(&flags, pszExe, pszArgs, str);

    if (S_OK == hr)
    {
        DWORD dw = (flags & ASSOCMAKEF_USEEXPAND) ? REG_EXPAND_SZ : REG_SZ;

        DWORD err = SHSetValue(hkVerb, TEXT("command"), NULL, dw, (LPVOID) str.GetStr(), CbFromCch(str.GetLen() +1));

        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}

LWSTDAPI AssocMakeShell(ASSOCMAKEF flags, HKEY hkProgid, LPCWSTR pszApplication, ASSOCSHELL *pShell)
{
    HRESULT hr = E_INVALIDARG;

    if (hkProgid && pszApplication && pShell)
    {
        for (DWORD c = 0; c < pShell->cVerbs; c++)
        {
            ASSOCVERB *pverb = &pShell->rgVerbs[c];

            if (pverb->pszVerb)
            {
                TCHAR szVerbKey[MAX_PATH];
                HKEY hkVerb;
                
                _PathAppend(TEXT("shell"), pverb->pszVerb, szVerbKey, SIZECHARS(szVerbKey));
                
                if (c == pShell->iDefaultVerb) 
                    SHSetValue(hkProgid, TEXT("shell"), NULL, REG_SZ, pverb->pszVerb, CbFromCch(lstrlen(pverb->pszVerb) +1));

                //  ASSOCMAKEF_FAILIFEXIST check if its ok to overwrite
                if (SUCCEEDED(_AssocOpenRegKey(hkProgid, szVerbKey, &hkVerb, FALSE)))
                {
                    RegCloseKey(hkVerb);
                    SHDeleteKey(hkProgid, szVerbKey);
                }

                if (SUCCEEDED(_AssocOpenRegKey(hkProgid, szVerbKey, &hkVerb, TRUE)))
                {
                    if (pverb->pszTitle)
                        SHSetValue(hkVerb, NULL, NULL, REG_SZ, pverb->pszTitle, CbFromCch(lstrlen(pverb->pszTitle) +1));

                    hr = _AssocMakeCommand(flags, hkVerb, pverb->pszApplication ? pverb->pszApplication : pszApplication , pverb->pszParams);

                    // if (SUCCEEDED(hr) && pverb->pDDEExec)
                    //    hr = _AssocMakeDDEExec(flags, hkVerb, pverb->pDDEExec);

                    RegCloseKey(hkVerb);
                }
            }
        }
    }
    return hr;
}

HRESULT _OpenClasses(HKEY *phkOut)
{
    *phkOut = NULL;

    DWORD err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\classes"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, phkOut, NULL);
    if (err)
        err = RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\classes"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, phkOut, NULL);

    return HRESULT_FROM_WIN32(err);
}

LWSTDAPI AssocMakeProgid(ASSOCMAKEF flags, LPCWSTR pszApplication, ASSOCPROGID *pProgid, HKEY *phkProgid)
{
    HRESULT hr = E_INVALIDARG;

    if (pszApplication 
    && pProgid 
    && pProgid->cbSize >= sizeof(ASSOCPROGID) 
    && pProgid->pszProgid 
    && *pProgid->pszProgid)
    {
        HKEY hkRoot;
        if ((!(flags & ASSOCMAKEF_VERIFY)  || PathFileExists(pszApplication))
        && SUCCEEDED(_OpenClasses(&hkRoot)))
        {
            HKEY hkProgid;
            //  need to add support for ASSOCMAKEF_VOLATILE...
            hr = _AssocOpenRegKey(hkRoot, pProgid->pszProgid, &hkProgid, TRUE);

            if (SUCCEEDED(hr))
            {
                if (pProgid->pszFriendlyDocName)
                    SHSetValue(hkProgid, NULL, NULL, REG_SZ, pProgid->pszFriendlyDocName, CbFromCch(lstrlen(pProgid->pszFriendlyDocName) +1));

                if (pProgid->pszDefaultIcon)
                    SHSetValue(hkProgid, TEXT("DefaultIcon"), NULL, REG_SZ, pProgid->pszDefaultIcon, CbFromCch(lstrlen(pProgid->pszDefaultIcon) +1));

                if (pProgid->pShellKey)
                    hr = AssocMakeShell(flags, hkProgid, pszApplication, pProgid->pShellKey);

                if (SUCCEEDED(hr) && pProgid->pszExtensions)
                {
                    LPCTSTR psz = pProgid->pszExtensions;
                    DWORD err = NOERROR;
                    while (*psz && NOERROR == err)
                    {
                        err = SHSetValue(hkRoot, psz, NULL, REG_SZ, pProgid->pszProgid, CbFromCch(lstrlen(pProgid->pszProgid) + 1));
                        psz += lstrlen(psz) + 1;
                    }

                    if (NOERROR != err)
                        HRESULT_FROM_WIN32(err);
                }

                if (SUCCEEDED(hr) && phkProgid)
                    *phkProgid = hkProgid;
                else
                    RegCloseKey(hkProgid);
            }

            RegCloseKey(hkRoot);
        }
    }

    return hr;
}

HRESULT _AssocCopyVerb(HKEY hkSrc, HKEY hkDst, LPCTSTR pszVerb)
{
    HRESULT hr = S_OK;
    TCHAR szKey[MAX_PATH];
    HKEY hkVerb;
    DWORD dwDisp;

    //  only copy the verb component
    wnsprintf(szKey, SIZECHARS(szKey), TEXT("shell\\%s"), pszVerb);

    RegCreateKeyEx(hkDst, szKey, 0, NULL, 0,
        MAXIMUM_ALLOWED, NULL, &hkVerb, &dwDisp);

    //  create a failure state here...
    if (hkVerb)
    {
        //  we avoid overwriting old keys by checking the dwDisp
        if ((dwDisp == REG_CREATED_NEW_KEY) && SHCopyKey(hkSrc, pszVerb, hkVerb, 0L))
            hr = E_UNEXPECTED;

        RegCloseKey(hkVerb);
    }

    return hr;
}

typedef BOOL (*PFNALLOWVERB)(LPCWSTR psz, LPARAM param);

LWSTDAPI _AssocCopyVerbs(HKEY hkSrc, HKEY hkDst, PFNALLOWVERB pfnAllow, LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    HKEY hkEnum;
    
    if (SUCCEEDED(_AssocOpenRegKey(hkSrc, TEXT("shell"), &hkEnum, FALSE)))
    {
        TCHAR szVerb[MAX_PATH];
        DWORD cchVerb = SIZECHARS(szVerb);

        for (DWORD i = 0
            ; (NOERROR == RegEnumKeyEx(hkEnum, i, szVerb, &cchVerb, NULL, NULL, NULL, NULL))
            ; (cchVerb = SIZECHARS(szVerb)), i++)
        {
            if (!pfnAllow || pfnAllow(szVerb, lParam))
                hr = _AssocCopyVerb(hkEnum, hkDst, szVerb);
        }

        //  switch to cbVerb here
        cchVerb = sizeof(szVerb);
        if (NOERROR == SHGetValue(hkEnum, NULL, NULL, NULL, szVerb, &cchVerb))
        {
            SHSetValue(hkDst, TEXT("shell"), NULL, REG_SZ, szVerb, cchVerb);
        }
        
        RegCloseKey(hkEnum);
    }

    return hr;
}

LWSTDAPI AssocCopyVerbs(HKEY hkSrc, HKEY hkDst)
{
    return _AssocCopyVerbs(hkSrc, hkDst, NULL, NULL);
}

BOOL _IsMSIPerUserInstall(IQueryAssociations *pqa, ASSOCF flags, LPCWSTR pszVerb)
{
    WCHAR sz[MAX_PATH];
    DWORD cb = sizeof(sz);
    
    if (SUCCEEDED(pqa->GetData(flags, ASSOCDATA_MSIDESCRIPTOR, pszVerb, sz, &cb)))
    {
        WCHAR szOut[3];  // bit enough for "1" or "0"
        cb = SIZECHARS(szOut);
        
        if (NOERROR == MsiGetProductInfoW(sz, INSTALLPROPERTY_ASSIGNMENTTYPE, szOut, &cb))
        {
            //  The string "1" for the value represents machine installations, 
            //  while "0" represents user installations.

            if (0 == StrCmpW(szOut, L"0"))
                return TRUE;
        }

    }

    return FALSE;
}
    
typedef struct {
    IQueryAssociations *pqa;
    ASSOCF Qflags;
    LPCWSTR pszExe;
    BOOL fAllowPerUser;
} QUERYEXECB;

BOOL _AllowExeVerb(LPCWSTR pszVerb, QUERYEXECB *pqcb)
{
    BOOL fRet = FALSE;
    WCHAR sz[MAX_PATH];
    if (SUCCEEDED(pqcb->pqa->GetString(pqcb->Qflags, ASSOCSTR_EXECUTABLE, pszVerb,
        sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
    {
        if (0 == StrCmpIW(PathFindFileNameW(sz), pqcb->pszExe))
        {
            // 
            //  EXEs match so we should copy this verb.
            //  but we need to block per-user installs by darwin being added to the 
            //  applications key, since other users wont be able to use them
            //
            if (_IsMSIPerUserInstall(pqcb->pqa, pqcb->Qflags, pszVerb))
                fRet = pqcb->fAllowPerUser;
            else
                fRet = TRUE;
        }
    }
    //  todo  mask off DARWIN per-user installs

    return fRet;
}

HRESULT _AssocCreateAppKey(LPCWSTR pszExe, BOOL fPerUser, HKEY *phk)
{
    WCHAR szKey[MAX_PATH];
    wnsprintf(szKey, SIZECHARS(szKey), L"software\\classes\\applications\\%s", pszExe);

    if (*PathFindExtension(pszExe) == 0)
    {
        StrCatBuff(szKey, TEXT(".exe"), SIZECHARS(szKey));
    }

    return _AssocOpenRegKey(fPerUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE, szKey, phk, TRUE);
}

LWSTDAPI AssocMakeApplicationByKeyW(ASSOCMAKEF flags, HKEY hkSrc, LPCWSTR pszVerb)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    ASSOCF Qflags = (flags & ASSOCMAKEF_VERIFY) ? ASSOCF_VERIFY : 0;
    IQueryAssociations *pqa;
    AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&pqa);

    if (!pqa)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(pqa->Init(0, NULL, hkSrc, NULL)))
    {
        
        if (SUCCEEDED(pqa->GetString(Qflags, ASSOCSTR_EXECUTABLE, pszVerb, 
            szPath, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szPath))))
            && (0 != StrCmpW(szPath, TEXT("%1"))))
        {
            LPCWSTR pszExe = PathFindFileNameW(szPath);
            BOOL fPerUser = _IsMSIPerUserInstall(pqa, Qflags, pszVerb);
            HKEY hkDst;
            
            ASSERT(pszExe && *pszExe);
            //  we have an exe to use

            //  check to see if this Application already has
            //  this verb installed
            DWORD cch;
            hr = AssocQueryString(Qflags | ASSOCF_OPEN_BYEXENAME, ASSOCSTR_COMMAND, pszExe,
                pszVerb, NULL, &cch);

            if (FAILED(hr) && SUCCEEDED(_AssocCreateAppKey(pszExe, fPerUser, &hkDst)))
            {
                QUERYEXECB qcb = {pqa, Qflags, pszExe, fPerUser};
                
                if (pszVerb)
                {
                    if (_AllowExeVerb(pszVerb, &qcb))
                    {
                        HKEY hkSrcVerbs;
    
                        if (SUCCEEDED(_AssocOpenRegKey(hkSrc, TEXT("shell"), &hkSrcVerbs, FALSE)))
                        {
                            hr = _AssocCopyVerb(hkSrcVerbs, hkDst, pszVerb);
                            RegCloseKey(hkSrcVerbs);
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                }
                else
                {
                    hr = _AssocCopyVerbs(hkSrc, hkDst, (PFNALLOWVERB)_AllowExeVerb, (LPARAM)&qcb);
                }

                RegCloseKey(hkDst);
            }
            
            //  init the friendly name for later
            if ((flags & ASSOCMAKEF_VERIFY) && SUCCEEDED(hr))
            {
                AssocQueryString(ASSOCF_OPEN_BYEXENAME | Qflags, ASSOCSTR_FRIENDLYAPPNAME, 
                    pszExe, NULL, NULL, &cch);
            }
        }

        pqa->Release();
    }
    
    return hr;
}

LWSTDAPI AssocMakeApplicationByKeyA(ASSOCMAKEF flags, HKEY hkAssoc, LPCSTR pszVerb)
{
    // convert pszVerb to wide char but preserve difference
    // between NULL and "" for AssocMakeApplicationByKeyW

    if (! pszVerb)
        return AssocMakeApplicationByKeyW(flags, hkAssoc, NULL);

    SHSTRW strVerb;
    HRESULT hr = strVerb.SetStr(pszVerb);

    if (SUCCEEDED(hr))
        hr = AssocMakeApplicationByKeyW(flags, hkAssoc, strVerb);

    return hr;
}

// This list needs to continue to be updated and we should try to keep parity with Office
const LPCTSTR c_arszUnsafeExts[]  =
{
    TEXT(".ade"), TEXT(".adp"), TEXT(".asp"), TEXT(".bas"), TEXT(".bat"), TEXT(".chm"), 
    TEXT(".cmd"), TEXT(".com"), TEXT(".cpl"), TEXT(".crt"), TEXT(".exe"), TEXT(".hlp"), 
    TEXT(".hta"), TEXT(".inf"), TEXT(".ins"), TEXT(".isp"), TEXT(".its"), TEXT(".js"),  
    TEXT(".jse"), TEXT(".lnk"), TEXT(".mdb"), TEXT(".mde"), TEXT(".mdt"), TEXT(".mdw"), 
    TEXT(".msc"), TEXT(".msi"), TEXT(".msp"), TEXT(".mst"), TEXT(".pcd"), TEXT(".pif"), 
    TEXT(".reg"), TEXT(".scr"), TEXT(".sct"), TEXT(".shb"), TEXT(".shs"), TEXT(".tmp"),
    TEXT(".url"), TEXT(".vb"),  TEXT(".vbe"), TEXT(".vbs"), TEXT(".vsd"), TEXT(".vsmacros"),          
    TEXT(".vss"), TEXT(".vst"), TEXT(".vsw"), TEXT(".ws"),  TEXT(".wsc"), TEXT(".wsf"), TEXT(".wsh"), 
};

typedef BOOL (*PFNSAFERIISEXECUTABLEFILETYPE)(LPCWSTR szFullPathname, BOOLEAN bFromShellExecute);

LWSTDAPI_(BOOL) AssocIsDangerous(PCWSTR pszType)
{
#ifdef DEBUG
    //  make sure our sort is good.
    static BOOL fCheckedUnsafe = FALSE;
    if (!fCheckedUnsafe)
    {
        for (int i = 1; i < ARRAYSIZE(c_arszUnsafeExts); i++)
        {
            ASSERT(0 > StrCmpIW(c_arszUnsafeExts[i-1], c_arszUnsafeExts[i]));
        }
        fCheckedUnsafe = TRUE;
    }
#endif // DEBUG    

    BOOL fDangerous = IsTypeInList(pszType, c_arszUnsafeExts, ARRAYSIZE(c_arszUnsafeExts));
    if (!fDangerous && pszType)
    {
        IQueryAssociations *passoc;
        HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &passoc));
        if (SUCCEEDED(hr))
        {
            hr = passoc->Init(NULL, pszType, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                DWORD dwEditFlags;
                ULONG cb = sizeof(dwEditFlags);
                hr = passoc->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwEditFlags, &cb);
                if (SUCCEEDED(hr))
                {
                    fDangerous = dwEditFlags & FTA_AlwaysUnsafe;
                }
            }
            passoc->Release();
        }

        if (!fDangerous && IsOS(OS_WHISTLERORGREATER) && *pszType)
        {
            HMODULE hmod = LoadLibrary(TEXT("advapi32.dll"));
            if (hmod)
            {
                PFNSAFERIISEXECUTABLEFILETYPE pfnSaferiIsExecutableFileType = 
                    (PFNSAFERIISEXECUTABLEFILETYPE)GetProcAddress(hmod, "SaferiIsExecutableFileType");
                if (pfnSaferiIsExecutableFileType)
                    fDangerous = pfnSaferiIsExecutableFileType(pszType, TRUE);
                FreeLibrary(hmod);
            }
        }
    }
    return fDangerous;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\connect.cpp ===
//
// IConnectionPoint/IDispatch helper functions
//
#include "priv.h"
#include <shlobj.h>

//
//  IDispatch helper functions

//
//  Takes a variable number of parameters for IDispatch, packages
//  them up.
//
//  pdispparams  - The DISPPARAMS structure that receives the result
//                 of the packaging.
//
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//
//  cArgs        - Number of pairs of generic arguments.
//
//  ap           - va_list of parameters to package.  We package up the
//                 first (2 * cArgs) of them.  See SHPackDispParams
//                 for details.

typedef struct FAKEBSTR {
    ULONG cb;
    WCHAR wsz[1];
} FAKEBSTR;

const FAKEBSTR c_bstrNULL = { 0, L"" };

LWSTDAPI SHPackDispParamsV(DISPPARAMS *pdispparams, VARIANTARG *rgvarg, UINT cArgs, va_list ap)
{
    HRESULT hr = S_OK;

    ZeroMemory(rgvarg, cArgs * SIZEOF(VARIANTARG));

    // fill out DISPPARAMS structure
    pdispparams->rgvarg = rgvarg;
    pdispparams->rgdispidNamedArgs = NULL;
    pdispparams->cArgs = cArgs;
    pdispparams->cNamedArgs = 0;

    // parameters are ordered in ap with the right-most parameter
    // at index zero and the left-most parameter at the highest index; essentially,
    // the parameters are pushed from right to left.  Put the first argument we
    // encounter at the highest index.

    // pVarArg points to the argument structure in the array we are currently
    // filling in.  Initialize this to point at highest argument (zero-based,
    // hence the -1).  For each passed-in argument we process, *decrement*
    // the pVarArg pointer to achieve the "push from right-to-left" effect.
    VARIANTARG * pVarArg = &rgvarg[cArgs - 1];

    int nCount = cArgs;
    while (nCount) 
    {
        VARENUM vaType = va_arg(ap,VARENUM);

        // We don't have to call VariantInit because we zerod out
        // the entire array before entering this loop

        V_VT(pVarArg) = vaType;

        // the next field is a union, so we can be smart about filling it in
        //
        if (vaType & VT_BYREF)
        {
            // All byrefs can be packed the same way
            V_BYREF(pVarArg) = va_arg(ap, LPVOID);
        }
        else
        {
            switch (vaType)
            {
            case VT_BSTR:
            {
                // parameter is a BSTR
                // MFC doesn't like it when you pass NULL for a VT_BSTR type
                V_BSTR(pVarArg) = va_arg(ap, BSTR);
                if (V_BSTR(pVarArg) == NULL)
                    V_BSTR(pVarArg) =(BSTR)c_bstrNULL.wsz;
#ifdef DEBUG
                // Check if this BSTR is a valid BSTR
                FAKEBSTR *bstr = CONTAINING_RECORD(V_BSTR(pVarArg), FAKEBSTR, wsz);
                ASSERT(bstr->cb == lstrlenW(bstr->wsz) * SIZEOF(WCHAR));
#endif
                break;
            }
    
            case VT_BOOL:
                V_BOOL(pVarArg) = va_arg(ap, VARIANT_BOOL);
                break;

            case VT_DISPATCH:
                V_DISPATCH(pVarArg) = va_arg(ap, LPDISPATCH);
                break;

            case VT_UNKNOWN:
                V_UNKNOWN(pVarArg) = va_arg(ap, LPUNKNOWN);
                break;

            default:
                AssertMsg(0, TEXT("Packing unknown variant type 0x%x as VT_I4"), vaType);
                // if we don't know what it is treat it as VT_I4.
                // Hopefully it's not a pointer or a VT_R8 or that sort of
                // thing, or we're in trouble.
                V_VT(pVarArg) = VT_I4;

            case VT_I4:
                V_I4(pVarArg) = va_arg(ap, LONG);
                break;

            } 
        }

        nCount--;
        pVarArg--;
    }

    return hr;
}

//
//  Takes a variable number of generic parameters, packages
//  them up.
//
//  pdispparams  - The DISPPARAMS structure that receives the result
//                 of the packaging.
//
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//
//  cArgs        - Number of pairs of generic arguments (below).
//
//  ...          - A collection of (VARNUM, LPVOID) pairs of arguments.
//                 The first is the type of the argument, and the
//                 second is the corresponding value.
//
//                 As a special case, a null VT_BSTR can be passed
//                 as a NULL pointer and we will turn it into a
//                 genuine null BSTR.
//
//  The following VARENUMs are supported:
//
//      VT_BYREF        - Anything that is VT_BYREF is okay
//      VT_BSTR
//      VT_BOOL
//      VT_DISPATCH
//      VT_UNKNOWN
//      VT_I4
//
//  Any other type will be packaged randomly, so don't do that.
//
//  Example:
//
//      DISPPARAMS dispparams;
//      VARIANTARG args[4];                     // room for 4 parameters
//      SHPackDispParams(&dispparams, args, 4,  // and here they are
//                       VT_BSTR,   bstrURL,
//                       VT_I4,     dwFlags,
//                       VT_BSTR,   NULL,       // no post data
//                       VT_BSTR,   bstrHeaders);
//

LWSTDAPI SHPackDispParams(DISPPARAMS *pdispparams, VARIANTARG *rgvarg, UINT cArgs, ...)
{
    va_list ap;
    va_start(ap, cArgs);

    HRESULT hr = SHPackDispParamsV(pdispparams, rgvarg, cArgs, ap);

    va_end(ap);
    return hr;
}

//=============================================================================
//
//  IConnectionPoint helper functions


//-----------------------------------------------------------------------------
//
//  INVOKECALLBACK
//
//  Allows clients to customize the the invoke process.  The callback
//  receives the following parameters:
//
//  pdisp       - The IDispatch that is about to receive an invoke.
//
//  pinv        - SHINVOKEPARAMS structure that describes the invoke
//                that is about to occur.
//
//  The callback function is called before each sink is dispatched.
//  The callback can return any of the following values:
//
//  S_OK          Proceed with the invoke
//  S_FALSE       Skip this invoke but keep invoking others
//  E_FAIL        Stop invoking
//
//  A client can do lazy-evaluation of dispatch arguments by installing
//  a callback that sets up the dispatch arguments on the first callback.
//
//  A client can support a "Cancel" flag by returning E_FAIL once the
//  cancel has occurred.
//
//  A client can pre-validate an IDispatch for compatibility reasons
//  and either touch up the arguments and return S_OK, or decide that
//  the IDispatch should be skipped and return S_FALSE.
//
//  A client can append custom information to the end of the SHINVOKEPARAMS
//  structure to allow it to determine additional context.
//
//  A client can do post-invoke goo by doing work on the pre-invoke
//  of the subsequent callback (plus one final bout of work when the
//  entire enumeration completes).
//

//
//  Obtaining a connection point sink is supposed to be easy.  You just
//  QI for the interface.  Unfortunately, too many components are buggy.
//
//  mmc.exe faults if you QI for IDispatch
//  and punkCB is non-NULL.  And if you do pass in NULL,
//  it returns S_OK but fills punkCB with NULL anyway.
//  Somebody must've had a rough day.
//
//  Java responds only to its dispatch ID and not IID_IDispatch, even
//  though the dispatch ID is derived from IID_IDispatch.
//
//  The Explorer Band responds only to IID_IDispatch and not to
//  the dispatch ID.
//

HRESULT GetConnectionPointSink(IUnknown *pUnk, const IID *piidCB, IUnknown **ppunkCB)
{
    HRESULT hr = E_NOINTERFACE;
    *ppunkCB = NULL;                // Pre-zero it to work around MMC
    if (piidCB)                     // Optional interface (Java/ExplBand)
    {                   
        hr = pUnk->QueryInterface(*piidCB, (void **) ppunkCB);
        if (*ppunkCB == NULL)       // Clean up behind MMC
            hr = E_NOINTERFACE;
    }
    return hr;
}


//
//  Enumerate the connection point sinks, calling the callback for each one
//  found.
//
//  The callback function is called once for each sink.  The IUnknown is
//  whatever interface we could get from the sink (either piidCB or piidCB2).
//

typedef HRESULT (CALLBACK *ENUMCONNECTIONPOINTSPROC)(
    /* [in, iid_is(*piidCB)] */ IUnknown *psink, LPARAM lParam);

HRESULT EnumConnectionPointSinks(
    IConnectionPoint *pcp,              // IConnectionPoint victim
    const IID *piidCB,                  // Interface for callback
    const IID *piidCB2,                 // Alternate interface for callback
    ENUMCONNECTIONPOINTSPROC EnumProc,  // Callback procedure
    LPARAM lParam)                      // Refdata for callback
{
    HRESULT hr;
    IEnumConnections * pec;

    if (pcp)
        hr = pcp->EnumConnections(&pec);
    else
        hr = E_NOINTERFACE;

    if (SUCCEEDED(hr))
    {
        CONNECTDATA cd;
        ULONG cFetched;

        while (S_OK == (hr = pec->Next(1, &cd, &cFetched)))
        {
            IUnknown *punkCB;

            ASSERT(1 == cFetched);

            hr = GetConnectionPointSink(cd.pUnk, piidCB, &punkCB);
            if (FAILED(hr))
                hr = GetConnectionPointSink(cd.pUnk, piidCB2, &punkCB);

            if (EVAL(SUCCEEDED(hr)))
            {
                hr = EnumProc(punkCB, lParam);
                punkCB->Release();
            }
            else
            {
                hr = S_OK;      // Pretend callback succeeded
            }
            cd.pUnk->Release();
            if (FAILED(hr)) break; // Callback asked to stop
        }
        pec->Release();
        hr = S_OK;
    }

    return hr;
}

//
//  Send out the callback (if applicable) and then do the invoke if the
//  callback said that was a good idea.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.

HRESULT CALLBACK EnumInvokeCallback(IUnknown *psink, LPARAM lParam)
{
    IDispatch *pdisp = (IDispatch *)psink;
    LPSHINVOKEPARAMS pinv = (LPSHINVOKEPARAMS)lParam;
    HRESULT hr;

    if (pinv->Callback)
    {
        // Now see if the callback wants to do pre-vet the pdisp.
        // It can return S_FALSE to skip this callback or E_FAIL to
        // stop the invoke altogether
        hr = pinv->Callback(pdisp, pinv);
        if (hr != S_OK) return hr;
    }

    pdisp->Invoke(pinv->dispidMember, *pinv->piid, pinv->lcid,
                  pinv->wFlags, pinv->pdispparams, pinv->pvarResult,
                  pinv->pexcepinfo, pinv->puArgErr);

    return S_OK;
}

//
//  IConnectionPoint_InvokeIndirect
//
//  Given a connection point, call the IDispatch::Invoke for each
//  connected sink.
//
//  The return value merely indicates whether the command was dispatched.
//  If any particular sink fails the IDispatch::Invoke, we will still
//  return S_OK, since the command was indeed dispatched.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.
//                      The pdispparams field can be NULL; we will turn it
//                      into a real DISPPARAMS for you.
//
//  The SHINVOKEPARAMS.flags field can contain the following flags.
//
//      IPFL_USECALLBACK    - The callback field contains a callback function
//                            Otherwise, it will be set to NULL.
//      IPFL_USEDEFAULT     - Many fields in the SHINVOKEPARAMS will be set to
//                            default values to save the caller effort:
//
//                  riid            =   IID_NULL
//                  lcid            =   0
//                  wFlags          =   DISPATCH_METHOD
//                  pvarResult      =   NULL
//                  pexcepinfo      =   NULL
//                  puArgErr        =   NULL
//

LWSTDAPI IConnectionPoint_InvokeIndirect(
    IConnectionPoint *pcp,
    SHINVOKEPARAMS *pinv)
{
    HRESULT hr;
    DISPPARAMS dp = { 0 };
    IID iidCP;

    if (pinv->pdispparams == NULL)
        pinv->pdispparams = &dp;

    if (!(pinv->flags & IPFL_USECALLBACK))
    {
        pinv->Callback = NULL;
    }

    if (pinv->flags & IPFL_USEDEFAULTS)
    {
        pinv->piid            =  &IID_NULL;
        pinv->lcid            =   0;
        pinv->wFlags          =   DISPATCH_METHOD;
        pinv->pvarResult      =   NULL;
        pinv->pexcepinfo      =   NULL;
        pinv->puArgErr        =   NULL;
    }

    // Try both the interface they actually connected on,
    // as well as IDispatch.  Apparently Java responds only to
    // the connecting interface, and ExplBand responds only to
    // IDispatch, so we have to try both.  (Sigh.  Too many buggy
    // components in the system.)

    hr = EnumConnectionPointSinks(pcp,
                                  (pcp->GetConnectionInterface(&iidCP) == S_OK) ? &iidCP : NULL,
                                  &IID_IDispatch,
                                  EnumInvokeCallback,
                                  (LPARAM)pinv);

    // Put the original NULL back so the caller can re-use the SHINVOKEPARAMS.
    if (pinv->pdispparams == &dp)
        pinv->pdispparams = NULL;

    return hr;
}

//
//  Wrapper around IConnectionPoint_InvokeIndirect with special Cancel
//  semantics.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      dispid       -  The DISPID to invoke
//      pdispparams  -  The DISPPARAMS for the invoke
//      pfCancel     -  Optional BOOL to cancel the invoke
//      ppvCancel    -  Optional LPVOID to cancel the invoke
//
//  If either *pfCancel or *ppvCancel is nonzero/non-NULL, we stop the invoke
//  process.  This allows a sink to "handle" the event and prevent other
//  sinks from receiving it.  The ppvCancel parameter is for dispid's which
//  are queries that are asking for somebody to create an object and return it.
//
//  It is the caller's responsibility to check the values of *pfCancel
//  and/or *ppvCancel to determine if the operation was cancelled.
//

typedef struct INVOKEWITHCANCEL {
    SHINVOKEPARAMS inv;
    LPBOOL pfCancel;
    void **ppvCancel;
} INVOKEWITHCANCEL;

HRESULT CALLBACK InvokeWithCancelProc(IDispatch *psink, SHINVOKEPARAMS *pinv)
{
    INVOKEWITHCANCEL *piwc = CONTAINING_RECORD(pinv, INVOKEWITHCANCEL, inv);

    if ((piwc->pfCancel && *piwc->pfCancel) ||
        (piwc->ppvCancel && *piwc->ppvCancel))
        return E_FAIL;

    return S_OK;
}

LWSTDAPI IConnectionPoint_InvokeWithCancel(
    IConnectionPoint *pcp,
    DISPID dispidMember,
    DISPPARAMS * pdispparams,
    LPBOOL pfCancel,
    void **ppvCancel)
{
    INVOKEWITHCANCEL iwc;

    iwc.inv.flags = IPFL_USECALLBACK | IPFL_USEDEFAULTS;
    iwc.inv.dispidMember = dispidMember;
    iwc.inv.pdispparams = pdispparams;
    iwc.inv.Callback = InvokeWithCancelProc;
    iwc.pfCancel = pfCancel;
    iwc.ppvCancel = ppvCancel;

    return IConnectionPoint_InvokeIndirect(pcp, &iwc.inv);
}

//
//  Wrapper around IConnectionPoint_InvokeIndirect with IPFL_USEDEFAULTS.
//

LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS *pdispparams)
{
    SHINVOKEPARAMS inv;

    inv.flags = IPFL_USEDEFAULTS;
    inv.dispidMember = dispidMember;
    inv.pdispparams = pdispparams;

    return IConnectionPoint_InvokeIndirect(pcp, &inv);
}

//
//  Takes a variable number of parameters for IDispatch, packages
//  them up, and invokes them.
//
//  The parameters to the IDispatch::Invoke will be
//
//      dispidMember    -   dispidMember
//      riid            -   IID_NULL
//      lcid            -   0
//      wFlags          -   DISPATCH_METHOD
//      pdispparams     -   <parameters to this function>
//      pvarResult      -   NULL
//      pexcepinfo      -   NULL
//      puArgErr        -   NULL
//
//  The parameters to this function are
//
//  pcp          - IConnectionPoint whose sinks should be Invoke()d.
//                 If this parameter is NULL, the function does nothing.
//  dispidMember - The DISPID to invoke.
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//  cArgs        - Number of pairs of generic arguments (below).
//
//  ap           - va_list of parameters to package.  We package up the
//                 first (2 * cArgs) of them.  See SHPackDispParams
//                 for details.
//

LWSTDAPI IConnectionPoint_InvokeParamV(IConnectionPoint *pcp, DISPID dispidMember, 
                                       VARIANTARG *rgvarg, UINT cArgs, va_list ap)
{
    HRESULT hr;

    if (pcp)
    {
        DISPPARAMS dp;
        hr = SHPackDispParamsV(&dp, rgvarg, cArgs, ap);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = IConnectionPoint_SimpleInvoke(pcp, dispidMember, &dp);
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

//
//  Given a connection point that represents IPropertyNotifySink,
//  call the IPropertyNotifySink::OnChanged for each connected sink.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be notified.
//                      If this parameter is NULL, the function does nothing.
//      dispid       -  To pass to IPropertyNotifySink::OnChanged.

HRESULT CALLBACK OnChangedCallback(IUnknown *psink, LPARAM lParam)
{
    IPropertyNotifySink *pns = (IPropertyNotifySink *)psink;
    DISPID dispid = (DISPID)lParam;

    pns->OnChanged(dispid);

    return S_OK;
}

LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid)
{
#ifdef DEBUG
    // Make sure it really is an IPropertyNotifySink connection point.
    if (pcp)
    {
        IID iid;
        HRESULT hr = pcp->GetConnectionInterface(&iid);
        ASSERT(SUCCEEDED(hr) && iid == IID_IPropertyNotifySink);
    }
#endif
    return EnumConnectionPointSinks(pcp, &IID_IPropertyNotifySink, NULL,
                                    OnChangedCallback, (LPARAM)dispid);
}

//=============================================================================
//
//  IConnectionPointContainer helper functions

//
//  QI's for IConnectionPointContainer and then does the FindConnectionPoint.
//
//  Parameters:
//
//      punk         -  The object who might be an IConnectionPointContainer.
//                      This parameter may be NULL, in which case the
//                      operation fails.
//      riidCP       -  The connection point interface to locate.
//      pcpOut       -  Receives the IConnectionPoint, if any.

LWSTDAPI IUnknown_FindConnectionPoint(IUnknown *punk, REFIID riidCP, 
                                      IConnectionPoint **pcpOut)
{
    HRESULT hr;

    *pcpOut = NULL;

    if (punk)
    {
        IConnectionPointContainer *pcpc;
        hr = punk->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpc);
        if (SUCCEEDED(hr))
        {
            hr = pcpc->FindConnectionPoint(riidCP, pcpOut);
            pcpc->Release();
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, package up the
//  invoke parameters, and call the IDispatch::Invoke for each
//  connected sink.
//
//  See IConnectionPoint_InvokeParam for additional semantics.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      riidCP       -  ConnectionPoint interface to request
//      pinv         -  Arguments for the Invoke.
//

LWSTDAPI IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
                SHINVOKEPARAMS *pinv)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, riidCP, &pcp);
    if (SUCCEEDED(hr))
    {
        hr = IConnectionPoint_InvokeIndirect(pcp, pinv);
        pcp->Release();
    }
    return hr;
}

//
//  This is the ultimate in one-stop shopping.
//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, package up the
//  invoke parameters, and call the IDispatch::Invoke for each
//  connected sink.
//
//  See IConnectionPoint_InvokeParam for additional semantics.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      riidCP       -  ConnectionPoint interface to request
//      dispidMember -  The DISPID to invoke.
//      rgvarg       -  Array of length cArgs.
//                      It will be used to hold the parameters.
//      cArgs        -  Number of pairs of generic arguments (below).
//      ...          -  A collection of (VARNUM, LPVOID) pairs of arguments.
//                      See SHPackDispParams for details.
//
//  Example:
//
//      IUnknown_CPContainerInvokeParam(punk, DIID_DShellFolderViewEvents,
//                                      DISPID_SELECTIONCHANGED, NULL, 0);

LWSTDAPIV IUnknown_CPContainerInvokeParam(
    IUnknown *punk, REFIID riidCP,
    DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, riidCP, &pcp);

    if (SUCCEEDED(hr))
    {
        va_list ap;
        va_start(ap, cArgs);
        hr = IConnectionPoint_InvokeParamV(pcp, dispidMember, rgvarg, cArgs, ap);
        va_end(ap);
        pcp->Release();
    }

    return hr;
}

//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, and call the
//  IPropertyNotifySink::OnChanged for each connected sink.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      dispid       -  To pass to IPropertyNotifySink::OnChanged.

LWSTDAPI IUnknown_CPContainerOnChanged(IUnknown *punk, DISPID dispid)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, IID_IPropertyNotifySink, &pcp);
    if (SUCCEEDED(hr))
    {
        hr = IConnectionPoint_OnChanged(pcp, dispid);
        pcp->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\dll.c ===
/***************************************************************************
 *  dll.c
 *
 *  Standard DLL entry-point functions
 *
 ***************************************************************************/

#include "priv.h"
#include <ntverp.h>

#include <isos.c>

#define MLUI_INIT
#include <mluisupp.h>

HINSTANCE g_hinst = NULL;
CRITICAL_SECTION g_csDll = {0};
DWORD g_TpsTls = (UINT)-1;
DWORD g_tlsThreadRef  = (UINT)-1;
DWORD g_tlsOtherThreadsRef  = (UINT)-1;
BOOL g_bDllTerminating = FALSE;

#ifdef DEBUG
//#define PROOFREAD_PARSES
#endif

#ifdef PROOFREAD_PARSES
enum
{
    PP_COMPARE,
    PP_ORIGINAL_ONLY,
    PP_NEW_ONLY
};


DWORD g_dwProofMode = PP_COMPARE;

#endif // PROOFREAD_PARSES

void TermPalette();
void DeinitPUI();
void FreeViewStatePropertyBagCache();
void FreeDynamicLibraries();
STDAPI_(void) FreeAllAccessSA();

//
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//
//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
//
const LPCTSTR c_rgszClasses[] = {
    TEXT("WorkerA"),                        // util.cpp
    TEXT("WorkerW"),                        // util.cpp
    TEXT("WorkerW"),                        // util.cpp
};

//
// Global DCs used during mirroring an Icon.
//
HDC g_hdc = NULL, g_hdcMask = NULL;
BOOL g_bMirroredOS = FALSE;

STDAPI_(void) InitShellKeys(BOOL fInit);
#ifndef NO_ETW_TRACING
ULONG UnRegisterTracing();
#endif

BOOL APIENTRY DllMain(IN HANDLE hDll, IN DWORD dwReason, IN LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);

#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
        InitializeCriticalSection(&g_csDll);   // for later use

        g_hinst = hDll;
        MLLoadResources(g_hinst, TEXT("shlwaplc.dll"));

        InitStopWatchMode();    // See if perf mode is enabled

        // Check if we are running on a system that supports the mirroring APIs
        // i.e. (NT5 or Memphis/BiDi)
        //
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        g_TpsTls = TlsAlloc();
        g_tlsThreadRef = TlsAlloc();
        g_tlsOtherThreadsRef = TlsAlloc();

        InitShellKeys(TRUE);
        
#ifdef PROOFREAD_PARSES
        {
            DWORD dwSize = sizeof(g_dwProofMode);
            if (ERROR_SUCCESS != SHGetValue( HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("Verify URLCombine"), NULL, &g_dwProofMode, &dwSize) ||
                (g_dwProofMode > PP_NEW_ONLY))
            {
                g_dwProofMode = PP_COMPARE;
            }
        }
#endif
        break;

    case DLL_PROCESS_DETACH:
        g_bDllTerminating = TRUE;
        MLFreeResources(g_hinst);
        if (lpReserved == NULL)
        {
            DeinitPUI();            // free up plug ui resource hinstance dpa table
            FreeViewStatePropertyBagCache();
        }

        //
        // Icon mirroring stuff (see mirror.c)
        // Cleanup cached DCs. No need to synchronize the following section of
        // code since it is only called in DLL_PROCESS_DETACH which is
        // synchronized by the OS Loader.
        //
        if (g_bMirroredOS)
        {
            if (g_hdc)
                DeleteDC(g_hdc);

            if (g_hdcMask)
                DeleteDC(g_hdcMask);

            g_hdc = g_hdcMask = NULL;
        }
        
        FreeAllAccessSA();
        TermPalette();
        if (StopWatchMode()) {
            StopWatchFlush();   // Flush the performance timing data to disk
#ifndef NO_ETW_TRACING
            // If any event tracing controls are enabled, this cleans them up.
            UnRegisterTracing();
#endif
        }
        DeleteCriticalSection(&g_csDll);

        if (lpReserved == NULL) 
        {
            SHTerminateThreadPool();
            SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses));
#ifdef I_WANT_WIN95_TO_CRASH
            // If you call FreeLibrary during PROCESS_ATTACH, Win95 will crash
            FreeDynamicLibraries();
#endif
        }

        if (g_TpsTls != (UINT)-1)
            TlsFree(g_TpsTls);

        if (g_tlsThreadRef != (UINT)-1)
            TlsFree(g_tlsThreadRef);

        if (g_tlsOtherThreadsRef != (UINT)-1)
            TlsFree(g_tlsOtherThreadsRef);

        InitShellKeys(FALSE);

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        ASSERT(0);  // We shouldn't get these because we called DisableThreadLibraryCalls().
        break;

    default:
        break;
    }

    return TRUE;
}



// DllGetVersion
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\fstream.cpp ===
#include "priv.h"
 
class CFileStream : public IStream
{
public:
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IStream
    STDMETHOD(Read) (THIS_ void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write) (THIS_ void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(THIS_ IStream **ppstm);

    CFileStream(HANDLE hf, DWORD grfMode, LPCWSTR pszName);

private:
    ~CFileStream();
    HRESULT InternalCommit(DWORD grfCommitFlags, BOOL fSendChange);

    LONG        _cRef;           // Reference count
    HANDLE      _hFile;          // the file.
    DWORD       _grfMode;        // The mode that we opened the file in.
    BOOL        _fLastOpWrite;   // The last operation was a write.

    ULONG       _iBuffer;        // Index in Buffer
    ULONG       _cbBufLen;       // length of buffer if reading
    BYTE        _bBuffer[4096];  // buffer

    WCHAR       _szName[MAX_PATH]; // file name in case someone calls Stat
};

CFileStream::CFileStream(HANDLE hf, DWORD grfMode, LPCWSTR pszName) : _cRef(1), _hFile(hf), _grfMode(grfMode)
{
    ASSERT(_cbBufLen == 0);
    ASSERT(_iBuffer == 0);
    ASSERT(_fLastOpWrite == FALSE);

    HRESULT hr = StringCchCopyW(_szName, ARRAYSIZE(_szName), pszName);
    if (FAILED(hr))
    {
        _szName[0] = L'\0';
    }
}

CFileStream::~CFileStream()
{
    if (_fLastOpWrite)
    {
        InternalCommit(0, TRUE);
    }

    ASSERT(_hFile != INVALID_HANDLE_VALUE);
    CloseHandle(_hFile);
}

STDMETHODIMP CFileStream::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFileStream, IStream),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFileStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    ULONG cbReadRequestSize = cb;
    ULONG cbT, cbRead;
    HRESULT hr = S_OK;

    // Have we write since our last read?
    if (_fLastOpWrite == TRUE)
    {
        hr = InternalCommit(0, FALSE);
        if (FAILED(hr))
        {
            if (pcbRead)
                *pcbRead = 0;
            return hr;
        }
    }

    _fLastOpWrite = FALSE;

    while (cb > 0)
    {
        // Assert if we are beyond the bufferlen and Not sizeof(_bBuffer) which
        // would imply a seek happened...
        ASSERT((_iBuffer <= _cbBufLen) || (_iBuffer == sizeof(_bBuffer)));

        if (_iBuffer < _cbBufLen)
        {
            cbT = _cbBufLen - _iBuffer;

            if (cbT > cb)
                cbT = cb;

            memcpy(pv, &_bBuffer[_iBuffer], cbT);
            _iBuffer += cbT;
            cb -= cbT;

            if (cb == 0)
                break;

            (BYTE *&)pv += cbT;
        }

        // Buffer's empty.  Handle rest of large reads directly...
        //
        if (cb > sizeof(_bBuffer))
        {
            cbT = cb - cb % sizeof(_bBuffer);
            if (!ReadFile(_hFile, pv, cbT, &cbRead, NULL))
            {
                DebugMsg(DM_TRACE, TEXT("Stream read IO error %d"), GetLastError());
                hr = ResultFromLastError();
                break;
            }

            cb -= cbRead;
            (BYTE *&)pv += cbRead;

            if (cbT != cbRead)
                break;          // end of file
        }

        if (cb == 0)
            break;

        // was the last read a partial read?  if so we are done
        //
        if (_cbBufLen > 0 && _cbBufLen < sizeof(_bBuffer))
        {
            // DebugMsg(DM_TRACE, "Stream is empty");
            break;
        }

        // Read an entire buffer's worth.  We may try to read past EOF,
        // so we must only check for != 0...
        //
        if (!ReadFile(_hFile, _bBuffer, sizeof(_bBuffer), &cbRead, NULL))
        {
            DebugMsg(DM_TRACE, TEXT("Stream read IO error 2 %d"), GetLastError());
            hr = ResultFromLastError();
            break;
        }

        if (cbRead == 0)
            break;

        _iBuffer = 0;
        _cbBufLen = cbRead;
    }

    if (pcbRead)
        *pcbRead = cbReadRequestSize - cb;

    if (cb != 0)
    {
        // DebugMsg(DM_TRACE, "CFileStream::Read() incomplete read");
        hr = S_FALSE; // still success! but not completely
    }

    return hr;
}

STDMETHODIMP CFileStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    ULONG cbRequestedWrite = cb;
    ULONG cbT;
    HRESULT hr = S_OK;

    if (!((_grfMode & STGM_WRITE) || (_grfMode & STGM_READWRITE)))
    {
        // Can't write to a stream that we didn't open for write access
        return STG_E_ACCESSDENIED;
    }

    // Have we read since our last write?
    if (_fLastOpWrite == FALSE && _iBuffer < _cbBufLen)
    {
        // Need to reset the file pointer so that this write goes to the right spot
        SetFilePointer(_hFile, -(int)(_cbBufLen - _iBuffer), NULL, STREAM_SEEK_CUR);
        _iBuffer = 0;
        _cbBufLen = 0;
    }

    while (cb > 0)
    {
        if (_iBuffer < sizeof(_bBuffer))
        {
            cbT = min((ULONG)(sizeof(_bBuffer) - _iBuffer), cb);

            memcpy(&_bBuffer[_iBuffer], pv, cbT);
            _iBuffer += cbT;
            cb -= cbT;

            _fLastOpWrite = TRUE;

            if (cb == 0)
                break;

            (BYTE *&)pv += cbT;
        }

        hr = InternalCommit(0, FALSE);
        if (FAILED(hr))
            break;

        if (cb > sizeof(_bBuffer))
        {
            ULONG cbWrite;

            cbT = cb - cb % sizeof(_bBuffer);

            if (!WriteFile(_hFile, pv, cbT, &cbWrite, NULL))
            {
                DebugMsg(DM_TRACE, TEXT("Stream write IO error 2, %d"), GetLastError());
                hr = ResultFromLastError();
                break;
            }

            cb -= cbWrite;
            (BYTE *&)pv += cbWrite;

            if (cbWrite != cbT)
                break;          // media full, we are done
        }
    }

    if (pcbWritten)
        *pcbWritten = cbRequestedWrite - cb;

    if ((cb != 0) && (hr == S_OK))
    {
        DebugMsg(DM_TRACE, TEXT("CFileStream::Write() incomplete"));
        hr = S_FALSE; // still success! but not completely
    }

    return hr;
}

STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    COMPILETIME_ASSERT(FILE_BEGIN   == STREAM_SEEK_SET);
    COMPILETIME_ASSERT(FILE_CURRENT == STREAM_SEEK_CUR);
    COMPILETIME_ASSERT(FILE_END     == STREAM_SEEK_END);

    HRESULT hr = S_OK;
    LARGE_INTEGER liOut;

    // Have we written since our last read?
    if (_fLastOpWrite == TRUE)
    {
        hr = InternalCommit(0, FALSE);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (_iBuffer < _cbBufLen)
    {
        // Need to reset the file pointer to point to the right place
        SetFilePointer(_hFile, -(int)(_cbBufLen - _iBuffer), NULL, STREAM_SEEK_CUR);
    }

    // Invalidate the buffer because we may move the file pointer
    _iBuffer = 0;
    _cbBufLen = 0;     // Say we have not read it yet.

    if (SetFilePointerEx(_hFile, dlibMove, &liOut, dwOrigin))
    {
        // Some callers pass NULL for the plibNewPosition parameter
        // in the IStream::Seek() call.  \shell32\filetbl.c, _IconCacheSave()
        // is an example.
        if (plibNewPosition)
        {
            // SetFilePointerEx takes a LARGE_INTEGER, but Seek takes a ULARGE_INTEGER, Why the difference?
            plibNewPosition->QuadPart = liOut.QuadPart;
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    return hr;
}

STDMETHODIMP CFileStream::SetSize(ULARGE_INTEGER libNewSize)
{
    HRESULT hr = E_FAIL;
    // First save away the pointer's position
    LARGE_INTEGER pos, test;
    LARGE_INTEGER zero = {0};
    if (SetFilePointerEx(_hFile, zero, &pos, FILE_CURRENT))
    {
        if (libNewSize.HighPart != 0)
        {
            hr = STG_E_INVALIDFUNCTION;
        }
        else
        {
            // Now set the size
            LARGE_INTEGER largeint;
            largeint.HighPart = 0;
            largeint.LowPart = libNewSize.LowPart;
            if (SetFilePointerEx(_hFile, largeint, &test, FILE_BEGIN) &&
                SetEndOfFile(_hFile))
            {
                // Reset the file pointer position
                if (SetFilePointerEx(_hFile, pos, &test, FILE_BEGIN))
                {
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
 }

//
// REVIEW: this could use the internal buffer in the stream to avoid
// extra buffer copies.
//
STDMETHODIMP CFileStream::CopyTo(IStream *pstmTo, ULARGE_INTEGER cb,
             ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr = S_OK;

    if (pcbRead)
        pcbRead->QuadPart = 0;

    if (pcbWritten)
        pcbWritten->QuadPart = 0;

    //
    // I'd like to use a buffer size that takes about a second to copy 
    // for the sake of cancel opportunities, but IStream doesn't give
    // me useful info like the stream speed. 
    //

    const DWORD cbBuffer = 0x00010000;

    //
    // Alloc the buffer and begin the copy
    //
        
    BYTE * pBuf = (BYTE *) LocalAlloc(LPTR, cbBuffer);
    if (!pBuf)
        return E_OUTOFMEMORY;

    while (cb.QuadPart)
    {
        //
        // Cast is OK because we know sizeof(buf) fits in a ULONG
        //

        ULONG cbRead = (ULONG)min(cb.QuadPart, cbBuffer);
        hr = Read(pBuf, cbRead, &cbRead);

        if (pcbRead)
            pcbRead->QuadPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;

        cb.QuadPart -= cbRead;

        hr = pstmTo->Write(pBuf, cbRead, &cbRead);

        if (pcbWritten)
            pcbWritten->QuadPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;
    }
    LocalFree(pBuf);

    // ISSUE
    // 
    // This was here when I got here, but from the SDK I don't see
    // why we'd accept S_FALSE as "complete success"

    if (S_FALSE == hr)
        hr = S_OK;      

    return hr;
}

STDMETHODIMP CFileStream::Commit(DWORD grfCommitFlags)
{
    return InternalCommit(grfCommitFlags, TRUE);
}

HRESULT CFileStream::InternalCommit(DWORD grfCommitFlags, BOOL fSendChange)
{
    if (_fLastOpWrite)
    {
        if (_iBuffer > 0)
        {
            DWORD cbWrite;
            WriteFile(_hFile, _bBuffer, _iBuffer, &cbWrite, NULL);
            if (cbWrite != _iBuffer)
            {
                DebugMsg(DM_TRACE, TEXT("CFileStream::Commit() incomplete write %d"), GetLastError());
                return STG_E_MEDIUMFULL;
            }
            _iBuffer = 0;

            if (fSendChange)
            {
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATHW, _szName, NULL);
            }
        }

        // Since we committed already, we don't need to commit again until the next write, so assume read
        _fLastOpWrite = FALSE;
    }

    return S_OK;
}

STDMETHODIMP CFileStream::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if ( !pstatstg )
        return STG_E_INVALIDPOINTER;

    ZeroMemory(pstatstg, sizeof(STATSTG));  // per COM conventions

    HRESULT hr = E_FAIL;
    BY_HANDLE_FILE_INFORMATION bhfi;

    if ( GetFileInformationByHandle(_hFile, &bhfi) )
    {
        if (grfStatFlag & STATFLAG_NONAME)
            hr = S_OK;
        else
            hr = SHStrDupW(PathFindFileNameW(_szName), &pstatstg->pwcsName);

        if (SUCCEEDED(hr))
        {
            pstatstg->type = STGTY_STREAM;
            pstatstg->cbSize.HighPart = bhfi.nFileSizeHigh;
            pstatstg->cbSize.LowPart = bhfi.nFileSizeLow;
            pstatstg->mtime = bhfi.ftLastWriteTime;
            pstatstg->ctime = bhfi.ftCreationTime;
            pstatstg->atime = bhfi.ftLastAccessTime;
            pstatstg->grfMode = _grfMode;
            pstatstg->reserved = bhfi.dwFileAttributes;
        }
    }
    return hr;
}

STDMETHODIMP CFileStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}


// create an IStream from a Win32 file name.
// in:
//      pszFile     file name to open
//      grfMode     STGM_ flags
//

// We export a W version of this function
//
STDAPI SHCreateStreamOnFileW(LPCWSTR pszFile, DWORD grfMode, IStream **ppstm)
{
    *ppstm = NULL;

    // NOTE: these interpretations of the STGM bits are not done properly
    // but to maintain back compat we have to allow the invalid combinations
    // and not enforce the share bits right. use SHCreateStreamOnFileEx() to get
    // proper STGM bit support

    if (grfMode &
        ~(STGM_READ             |
          STGM_WRITE            |
          STGM_SHARE_DENY_NONE  |
          STGM_SHARE_DENY_READ  |
          STGM_SHARE_DENY_WRITE |
          STGM_SHARE_EXCLUSIVE  |
          STGM_READWRITE        |
          STGM_CREATE         ))
    {
        DebugMsg(DM_ERROR, TEXT("CreateSreamOnFile: Invalid STGM_ mode"));
        return E_INVALIDARG;
    }

    HANDLE hFile;
    BOOL fCreated = FALSE;
    if ( grfMode & STGM_CREATE)
    {
        // Need to get the file attributes of the file first, so
        // that CREATE_ALWAYS will succeed for HIDDEN and SYSTEM
        // attributes.
        DWORD dwAttrib = GetFileAttributesW(pszFile);
        if ((DWORD)-1 == dwAttrib )
        {
            // something went wrong, so set attributes to something
            // normal before we try to create the file...
            dwAttrib = 0;
            fCreated = TRUE;
        }

        // STGM_CREATE
        hFile = CreateFileW(pszFile, GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
            dwAttrib, NULL);
    }
    else
    {
        DWORD dwDesiredAccess, dwShareMode, dwShareBits;

        // not STGM_CREATE
        if ( grfMode & STGM_WRITE )
        {
            dwDesiredAccess = GENERIC_WRITE;
        }
        else
        {
            dwDesiredAccess = GENERIC_READ;
        }
        if ( grfMode & STGM_READWRITE )
        {
            dwDesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
        }
        dwShareBits = grfMode & (STGM_SHARE_EXCLUSIVE | 
                                 STGM_SHARE_DENY_WRITE | 
                                 STGM_SHARE_DENY_READ | 
                                 STGM_SHARE_DENY_NONE);
        switch( dwShareBits ) 
        {
        case STGM_SHARE_DENY_WRITE:
            dwShareMode = FILE_SHARE_READ;
            break;
        case STGM_SHARE_DENY_READ:
            dwShareMode = FILE_SHARE_WRITE;
            break;
        case STGM_SHARE_EXCLUSIVE:
            dwShareMode = 0;
            break;
        default:
            dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
            break;
        }
        hFile = CreateFileW(pszFile, dwDesiredAccess, dwShareMode, NULL, OPEN_EXISTING, 0, NULL);
    }

    HRESULT hr;
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if ((grfMode & STGM_CREATE) && fCreated)
        {
            SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, pszFile, NULL);
        }

        *ppstm = (IStream *)new CFileStream(hFile, grfMode, pszFile);
        if (*ppstm)
        {
            hr = S_OK;
        }
        else
        {
            CloseHandle(hFile);
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("CreateSreamOnFile: CreateFileW() failed %s"), pszFile);
        hr = ResultFromLastError();
    }
    return hr;
}

// We export an A version of this function
STDAPI SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, IStream **ppstm)
{
    WCHAR szFile[MAX_PATH];

    SHAnsiToUnicode(pszFile, szFile, ARRAYSIZE(szFile));
    return SHCreateStreamOnFileW(szFile, grfMode, ppstm);
}

STDAPI ModeToCreateFileFlags(DWORD grfMode, BOOL fCreate, DWORD *pdwDesiredAccess, DWORD *pdwShareMode, DWORD *pdwCreationDisposition)
{
    HRESULT hr = S_OK;

    *pdwDesiredAccess = *pdwShareMode = *pdwCreationDisposition = 0;

    switch (grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE))
    {
    case STGM_READ:
        *pdwDesiredAccess |= GENERIC_READ;
        break;

    case STGM_WRITE:
        *pdwDesiredAccess |= GENERIC_WRITE;
        break;

    case STGM_READWRITE:
        *pdwDesiredAccess |= GENERIC_READ | GENERIC_WRITE;
        break;

    default:
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if (SUCCEEDED(hr))
    {
        switch (grfMode & (STGM_SHARE_DENY_NONE | STGM_SHARE_DENY_READ | STGM_SHARE_DENY_WRITE | STGM_SHARE_EXCLUSIVE))
        {
        case STGM_SHARE_DENY_READ:
            *pdwShareMode = FILE_SHARE_WRITE | FILE_SHARE_DELETE;
            break;

        case STGM_SHARE_DENY_WRITE:
            *pdwShareMode = FILE_SHARE_READ;
            break;

        case STGM_SHARE_EXCLUSIVE:
            *pdwShareMode = 0;
            break;

        case STGM_SHARE_DENY_NONE:
        default:
            // assume STGM_SHARE_DENY_NONE as per documentation
            *pdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        }

        if (SUCCEEDED(hr))
        {
            switch (grfMode & (STGM_CREATE | STGM_FAILIFTHERE))
            {
            case STGM_CREATE:
                *pdwCreationDisposition = CREATE_ALWAYS;
                break;

            case STGM_FAILIFTHERE:  // this is a 0 flag
                *pdwCreationDisposition = fCreate ? CREATE_NEW : OPEN_EXISTING;
                break;

            default:
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            }
        }
    }

    return hr;
}

// similar to SHCreateStreamOnFile() but
//  1) properly maps STGM bits into CreateFile() params
//  2) takes dwAttributes for the STGM_CREATE case so you can create the file
//     with known attributes

// NOTE: returns WIN32 errors from GetLastError through the HRESULT, NOT STG errors.
STDAPI SHCreateStreamOnFileEx(LPCWSTR pszFile, DWORD grfMode, DWORD dwAttributes, BOOL fCreate, IStream * pstmTemplate, IStream **ppstm)
{
    *ppstm = NULL;

    DWORD dwDesiredAccess, dwShareMode, dwCreationDisposition;
    HRESULT hr = ModeToCreateFileFlags(grfMode, fCreate, &dwDesiredAccess, &dwShareMode, &dwCreationDisposition);
    if (SUCCEEDED(hr))
    {
        HANDLE hFile = CreateFileW(pszFile, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwAttributes, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            DWORD dwErr = GetLastError();

            // for some reason CreateFile is dumb and doesn't perform to spec here (?)
            if ((dwErr == ERROR_ACCESS_DENIED) &&
                (dwCreationDisposition == CREATE_NEW) &&
                PathFileExistsW(pszFile))
            {
                dwErr = ERROR_ALREADY_EXISTS;
            }

            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            if ((CREATE_NEW == dwCreationDisposition) || (CREATE_ALWAYS == dwCreationDisposition))
            {
                SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, pszFile, NULL);
            }

            *ppstm = (IStream *)new CFileStream(hFile, grfMode, pszFile);
            if (*ppstm)
            {
                hr = S_OK;
            }
            else
            {
                CloseHandle(hFile);
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}


// maps win32 errors from SHCreateStreamOnFileEx into STG error codes, for
// use in IStorage/IStream implementations.
HRESULT MapWin32ErrorToSTG(HRESULT hrIn)
{
    HRESULT hr = hrIn;

    if (FAILED(hr))
    {
        // munge some of the failure cases back into the STG error values
        // that are expected.
        switch (hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
            hr = STG_E_FILENOTFOUND;
            break;

        case HRESULT_FROM_WIN32(ERROR_FILE_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
            hr = STG_E_FILEALREADYEXISTS;
            break;

        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            hr = STG_E_ACCESSDENIED;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\fda.c ===
#include "priv.h"

//***   FDSA -- small/fast DSA routines
// DESCRIPTION
//  We attempt to behave as much like an array as possible (semantics
//  and performance and to some extent allocation).  In particular,
//  - indexing (FDSA_GetItemXxx) is done entirely inline; and...
//  - ... involves only 1 extra indirection vs. a true array; and...
//  - ... knows the data type so sizeof is a constant; and...
//  - ... does no range checks (except possibly in DEBUG versions).
//  - part of the FDSA is statically alloc'ed, so one can put critical
//  items in the static part to ensure that they'll be there even under
//  low memory conditions.
// NOTES
//  For now we only implement:
//      Initialize, Destroy, GetItemPtr, GetItemCount, InsertItem, AppendItem

// FEATURE eventually these come from comctl...
#define DABreak()   /*NOTHING*/
// ReAlloc and Free come from inc/heapaloc.h

//***   SDSA_PITEM -- get item the hard way
//
#define SDSA_PITEM(pfdsa, i) \
    ((void *)(((BYTE *)(pfdsa)->aItem) + ((i) * (pfdsa)->cbItem)))

//***   FDSA_Initialize -- initialize
//
// SECURITY: caller is responsible for aItemStatic having at least (cItemStatice * cbItem) bytes
BOOL WINAPI FDSA_Initialize(int cbItem, int cItemGrow,
    PFDSA pfdsa, void * aItemStatic, int cItemStatic)
{
    ASSERT(pfdsa != NULL);      // WARNING how handle?

    if (cItemGrow == 0)
        cItemGrow = 1;

    // for implementation simplicity, cItemStatic must be a multiple of
    // cItemGrow.  o.w. our 1st grow from static->dynamic is messy and
    // probably buggy.
    if (cItemStatic % cItemGrow != 0) {
        AssertMsg(0, TEXT("CItemStatic must be a multiple of cItemGrow"));
        return FALSE;
    }

    if (aItemStatic != NULL) 
    {
        // since we're (eventually) in comctl, we can't assume caller's
        // buffer was 0'ed
        ZeroMemory(aItemStatic, cItemStatic * cbItem);
    }

    if (pfdsa) {
        pfdsa->cItem = 0;
        pfdsa->cItemAlloc = cItemStatic;
        pfdsa->aItem = aItemStatic;
        pfdsa->fAllocated = FALSE;

        pfdsa->cbItem = cbItem;
        ASSERT(pfdsa->cbItem == cbItem);        // bitfield overflow

        pfdsa->cItemGrow = cItemGrow;
        ASSERT(pfdsa->cItemGrow == cItemGrow);  // bitfield overflow
    }

    return TRUE;
}

BOOL WINAPI FDSA_Destroy(PFDSA pdsa)
{
    if (pdsa == NULL)       // allow NULL for low memory cases
        return TRUE;

    if (pdsa->fAllocated && pdsa->aItem && !LocalFree(pdsa->aItem))
        return FALSE;

    return TRUE;
}

void* _LocalReAlloc(void* p, UINT uBytes)
{
    if (uBytes) {
        if (p) {
            return LocalReAlloc(p, uBytes, LMEM_MOVEABLE | LMEM_ZEROINIT);
        } else {
            return LocalAlloc(LPTR, uBytes);
        }
    } else {
        if (p)
            LocalFree(p);
        return NULL;
    }
}

//***   FDSA_InsertItem -- insert an item
// ENTRY/EXIT
//  index   insertion point; index > count (e.g. DA_LAST) means append
// NOTES
//  param called 'pdsa' (vs. pfdsa) for easy diff'ing w/ DSA_InsertItem
int WINAPI FDSA_InsertItem(PFDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(pitem);

    if (index < 0) {
        TraceMsg(DM_ERROR, "FDSA: InsertItem: Invalid index: %d", index);
        DABreak();
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc) {
        void FAR* aItemNew = _LocalReAlloc(pdsa->fAllocated ? pdsa->aItem : NULL,
                (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
            return -1;

        if (!pdsa->fAllocated) {
            // when we go from static->dynamic, we need to copy
            pdsa->fAllocated = TRUE;
            hmemcpy(aItemNew, pdsa->aItem, pdsa->cItem * pdsa->cbItem);
        }

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem) {
        hmemcpy(SDSA_PITEM(pdsa, index + 1), SDSA_PITEM(pdsa, index),
            (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    hmemcpy(SDSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}


BOOL WINAPI FDSA_DeleteItem(PFDSA pdsa, int index)
{
    ASSERT(pdsa);

    if (index < 0 || index >= pdsa->cItem)
    {
        TraceMsg(TF_ERROR, "FDSA: DeleteItem: Invalid index: %d", index);
        DABreak();
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        hmemcpy(SDSA_PITEM(pdsa, index), SDSA_PITEM(pdsa, index + 1),
            (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\ids.h ===
#ifndef _IDS_H_
#define _IDS_H_
// IDs for common UI resources (note that these MUST BE decimal numbers)

#define IDI_SECURITY    1

#define IDS_HOUR    0x100
#define IDS_MIN     0x101
#define IDS_SEC     0x102

#define IDS_BYTES   0x103
#define IDS_ORDERKB 0x104
#define IDS_ORDERMB 0x105
#define IDS_ORDERGB 0x106
#define IDS_ORDERTB 0x107
#define IDS_ORDERPB 0x108
#define IDS_ORDEREB 0x109

#define IDS_LONGDATE_SEP    0x10a

#define IDS_SIDEBYSIDE 0x10F

// strings for GetRelativeDateFormat (note: sun-sat must be kept in order)
#define IDS_DAYSOFTHEWEEK               0x110
#define IDS_SUNDAY                      (IDS_DAYSOFTHEWEEK)
#define IDS_MONDAY                      (IDS_DAYSOFTHEWEEK+1)
#define IDS_TUESDAY                     (IDS_DAYSOFTHEWEEK+2)
#define IDS_WEDNESDAY                   (IDS_DAYSOFTHEWEEK+3)
#define IDS_THURSDAY                    (IDS_DAYSOFTHEWEEK+4)
#define IDS_FRIDAY                      (IDS_DAYSOFTHEWEEK+5)
#define IDS_SATURDAY                    (IDS_DAYSOFTHEWEEK+6)
#define IDS_TODAY                       0x117
#define IDS_YESTERDAY                   0x118

// strings for Zone stuff (security.cpp)
#define IDS_MIXED                       0x119
#define IDS_INTERNETSECURITY            0x11A

// strings for SHRestrictedMessageBox (util.cpp)
#define IDS_RESTRICTIONS                0x11B
#define IDS_RESTRICTIONSTITLE           0x11C
 
// Free spaces 0x11D thru 0x11F

#define IDS_DRIVENOTREADY               0x120
#define IDS_UNFORMATTED                 0x121
#define IDS_NOFMT                       0x122
#define IDS_NOSUCHDRIVE                 0x123
#define IDS_FILEERROR                   0x124
#define IDS_FILEERRORMOVE               0x124  // Same as IDS_FILEERROR because (IDS_FILEERROR + FO_MOVE) or FO_COPY, FO_DELETE, FO_RENAME
#define IDS_FILEERRORCOPY               0x125
#define IDS_FILEERRORDEL                0x126
#define IDS_FILEERRORREN                0x127
#define IDS_SECURITY                    0x128
#define IDS_TEMPLATENOTSECURE           0x129

// SHMessageBoxHelp "click help for more info" string
#define IDS_CLICKHELPFORINFO            0x130
#define DLG_NULL                        0x131

#define DLG_MESSAGEBOXCHECK     0x1200
#define IDC_MBC_TEXT            0x1201
#define IDC_MBC_CHECK           0x1202
#define IDC_MBC_ICON            0x1203

#define IDS_EXTTYPETEMPLATE     0x1300
#define IDS_FILETYPENAME        0x1301
#define IDS_FOLDERTYPENAME      0x1302


#endif // _IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\gcount.cpp ===
#include "priv.h"

//
// #defines
//
#ifdef DEBUG
#define GLOBAL_COUNTER_WAIT_TIMEOUT 30*1000  // on debug we set this to 30 seconds
#else
#define GLOBAL_COUNTER_WAIT_TIMEOUT 0        // on retail its zero so we test the objects state and return immedaeately
#endif

//
// Globals
//
SECURITY_ATTRIBUTES* g_psa = NULL;


//  There are three kinds of null-type DACL's.
//
//  1. No DACL. This means that we inherit the ambient DACL from our thread.
//  2. Null DACL. This means "full access to everyone".
//  3. Empty DACL. This means "deny all access to everyone".
//
//  NONE of these are correct for our needs. We used to use Null DACL's (2), 
//  but the issue with these is that someone can change the ACL on the object thus
//  locking us out so we can't synchronize to the object anymore.
// 
//  So now we create a specific DACL with 3 ACE's in it:
//
//          ACE #1: Everyone        - GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE
//          ACE #2: SYSTEM          - GENERIC_ALL (full control)
//          ACE #3: Administrators  - GENERIC_ALL (full control)
//
STDAPI_(SECURITY_ATTRIBUTES*) SHGetAllAccessSA()
{    
    if (g_psa == NULL)
    {
        SECURITY_ATTRIBUTES* psa = (SECURITY_ATTRIBUTES*)LocalAlloc(LPTR, sizeof(*psa));

        if (psa)
        {
            SECURITY_DESCRIPTOR* psd;

            SHELL_USER_PERMISSION supEveryone;
            SHELL_USER_PERMISSION supSystem;
            SHELL_USER_PERMISSION supAdministrators;
            PSHELL_USER_PERMISSION apUserPerm[3] = {&supEveryone, &supAdministrators, &supSystem};

            // we want the everyone to have read, write, exec and sync only 
            supEveryone.susID = susEveryone;
            supEveryone.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
            supEveryone.dwAccessMask = (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE);
            supEveryone.fInherit = FALSE;
            supEveryone.dwInheritMask = 0;
            supEveryone.dwInheritAccessMask = 0;

            // we want the SYSTEM to have full control
            supSystem.susID = susSystem;
            supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
            supSystem.dwAccessMask = GENERIC_ALL;
            supSystem.fInherit = FALSE;
            supSystem.dwInheritMask = 0;
            supSystem.dwInheritAccessMask = 0;

            // we want the Administrators to have full control
            supAdministrators.susID = susAdministrators;
            supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
            supAdministrators.dwAccessMask = GENERIC_ALL;
            supAdministrators.fInherit = FALSE;
            supAdministrators.dwInheritMask = 0;
            supAdministrators.dwInheritAccessMask = 0;

            // allocate the global SECURITY_DESCRIPTOR
            psd = GetShellSecurityDescriptor(apUserPerm, ARRAYSIZE(apUserPerm));
            if (psd)
            {
                // setup the psa
                psa->nLength = sizeof(*psa);
                psa->lpSecurityDescriptor = psd;
                psa->bInheritHandle = FALSE;

                if (InterlockedCompareExchangePointer((void**)&g_psa, psa, NULL))
                {
                    // someone else beat us to initing s_psa, free ours
                    LocalFree(psd);
                    LocalFree(psa);
                }
            }
            else
            {
                LocalFree(psa);
            }
        }
    }

    return g_psa;
}


//
// called at process detach to release our global all-access SA
//
STDAPI_(void) FreeAllAccessSA()
{
    SECURITY_ATTRIBUTES* psa = (SECURITY_ATTRIBUTES*)InterlockedExchangePointer((void**)&g_psa, NULL);
    if (psa)
    {
        LocalFree(psa->lpSecurityDescriptor);
        LocalFree(psa);
    }
}


STDAPI_(HANDLE) SHGlobalCounterCreateNamedW(LPCWSTR szName, LONG lInitialValue)
{
    HANDLE hSem = NULL;
    WCHAR szCounterName[MAX_PATH];  // "shell.szName"

    if (SUCCEEDED(StringCchCopyW(szCounterName, ARRAYSIZE(szCounterName), L"shell.")) &&
        SUCCEEDED(StringCchCatW(szCounterName, ARRAYSIZE(szCounterName), szName)))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        
        if (psa)
        {
            hSem = CreateSemaphoreW(psa, lInitialValue, 0x7FFFFFFF, szCounterName);
        }

        if (!hSem)
        {
            hSem = OpenSemaphoreW(SEMAPHORE_MODIFY_STATE | SYNCHRONIZE, FALSE, szCounterName);
        }
    }

    return hSem;
}


STDAPI_(HANDLE) SHGlobalCounterCreateNamedA(LPCSTR szName, LONG lInitialValue)
{
    HANDLE hSem = NULL;
    WCHAR szCounterName[MAX_PATH];

    if (SHAnsiToUnicode(szName, szCounterName, ARRAYSIZE(szCounterName)))
    {
        hSem = SHGlobalCounterCreateNamedW(szCounterName, lInitialValue);
    }

    return hSem;
}


//
// This lets the user pass a GUID. The name of the global counter will be "shell.{guid}",
// and its initial value will be zero.
//
STDAPI_(HANDLE) SHGlobalCounterCreate(REFGUID rguid)
{
    HANDLE hSem = NULL;
    WCHAR szGUIDString[GUIDSTR_MAX];

    if (SHStringFromGUIDW(rguid, szGUIDString, ARRAYSIZE(szGUIDString)))
    {
        hSem = SHGlobalCounterCreateNamedW(szGUIDString, 0);
    }

    return hSem;
}


// returns current value of the global counter
// Note: The result is not thread-safe in the sense that if two threads
// look at the value at the same time, one of them might read the wrong
// value.
STDAPI_(long) SHGlobalCounterGetValue(HANDLE hCounter)
{ 
    long lPreviousValue = 0;
    DWORD dwRet;

    ReleaseSemaphore(hCounter, 1, &lPreviousValue); // poll and bump the count
    dwRet = WaitForSingleObject(hCounter, GLOBAL_COUNTER_WAIT_TIMEOUT); // reduce the count

    // this shouldnt happen since we just bumped up the count above
    ASSERT(dwRet != WAIT_TIMEOUT);
    
    return lPreviousValue;
}


// returns new value
// Note: this _is_ thread safe
STDAPI_(long) SHGlobalCounterIncrement(HANDLE hCounter)
{ 
    long lPreviousValue = 0;

    ReleaseSemaphore(hCounter, 1, &lPreviousValue); // bump the count
    return lPreviousValue + 1;
}

// returns new value
// Note: The result is not thread-safe in the sense that if two threads
// try to decrement the value at the same time, whacky stuff can happen.
STDAPI_(long) SHGlobalCounterDecrement(HANDLE hCounter)
{ 
    DWORD dwRet;
    long lCurrentValue = SHGlobalCounterGetValue(hCounter);

#ifdef DEBUG
    // extra sanity check
    if (lCurrentValue == 0)
    {
        ASSERTMSG(FALSE, "SHGlobalCounterDecrement called on a counter that was already equal to 0 !!");
        return 0;
    }
#endif

    dwRet = WaitForSingleObject(hCounter, GLOBAL_COUNTER_WAIT_TIMEOUT); // reduce the count

    ASSERT(dwRet != WAIT_TIMEOUT);

    return lCurrentValue - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\httpfnc.cpp ===
#include "priv.h"
#pragma  hdrstop

#include "objidl.h"
#include "urlmon.h"
#include "exdisp.h"     // IWebBrowserApp
#include "shlobj.h"     // IShellBrowser
#include "inetreg.h"
#include <mlang.h>

// Internal helper functions
HRESULT wrap_CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc);
HRESULT wrap_RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI common_GetAcceptLanguages(CHAR *psz, LPDWORD pcch);

#define SETFMTETC(p, a) {(p)->cfFormat = (a); \
                         (p)->dwAspect = DVASPECT_CONTENT; \
                         (p)->lindex = -1; \
                         (p)->tymed = TYMED_ISTREAM; \
                         (p)->ptd = NULL;}

const SA_BSTRGUID s_sstrEFM = {
    38 * sizeof(WCHAR),
    L"{D0FCA420-D3F5-11CF-B211-00AA004AE837}"    
};


STDAPI CreateDefaultAcceptHeaders(VARIANT* pvar, IWebBrowserApp* pdie)
{
    IEnumFORMATETC* pEFM;
    HKEY hkey;
    HRESULT hr = S_OK;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Accepted Documents"),
            0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD iValue = 0;
        DWORD iValidEntries = 0;
        TCHAR szValueName[128];
        DWORD cchValueName = ARRAYSIZE(szValueName);
        DWORD dwType;

        // Count the types in the registry
        while (RegEnumValue(hkey, iValue++, szValueName, &cchValueName,
                            NULL, &dwType, NULL, NULL)==ERROR_SUCCESS)
        {
            // purpose is to increment iValue
            cchValueName = ARRAYSIZE(szValueName);
        }

        // Previous loop ends +1, so no need to add +1 for CF_NULL
        
        FORMATETC *prgfmtetc = (FORMATETC *)LocalAlloc(LPTR, iValue * sizeof(FORMATETC));
        if (prgfmtetc)
        {
            FORMATETC *pcurfmtetc = prgfmtetc;
            for (DWORD nValue=0; SUCCEEDED(hr) && (nValue < (iValue -1)); nValue++)
            {
                TCHAR szFormatName[128];
                DWORD cchFormatName = ARRAYSIZE(szFormatName);

                cchValueName = ARRAYSIZE(szValueName);
                if (RegEnumValue(hkey, nValue, szValueName, &cchValueName, NULL,
                                 &dwType, (LPBYTE) szFormatName, &cchFormatName)==ERROR_SUCCESS)
                {
                    pcurfmtetc->cfFormat = (CLIPFORMAT) RegisterClipboardFormat(szFormatName);
                    if (pcurfmtetc->cfFormat)
                    {
                        SETFMTETC (pcurfmtetc, pcurfmtetc->cfFormat);
                        pcurfmtetc++;   // move to next fmtetc
                        iValidEntries++;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                } // if RegEnum
            } // for nValue

            if (SUCCEEDED(hr))
            {
                // for the last pcurfmtetc, we fill in for CF_NULL
                // no need to do RegisterClipboardFormat("*/*")
                SETFMTETC(pcurfmtetc, CF_NULL);
                iValidEntries++;
    
                hr = wrap_CreateFormatEnumerator (iValidEntries, prgfmtetc, &pEFM);
                if (SUCCEEDED(hr))
                {
                    ASSERT(pvar->vt == VT_EMPTY);
                    pvar->vt = VT_UNKNOWN;
                    pvar->punkVal = (IUnknown *)pEFM;
                    hr = pdie->PutProperty((BSTR)s_sstrEFM.wsz, *pvar);
                    if (FAILED(hr))
                    {
                        pEFM->Release();  // if we failed to pass ownership on, free EFM
                        pvar->vt = VT_EMPTY;
                        pvar->punkVal = NULL;
                    }
                }
            }
    
            LocalFree (prgfmtetc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        RegCloseKey(hkey);
    }
    else
    {
        DebugMsg(TF_ERROR, TEXT("RegOpenkey failed!"));
        hr = E_FAIL;
    }

    return hr;
}

STDAPI RegisterDefaultAcceptHeaders(IBindCtx* pbc, LPSHELLBROWSER psb)
{
    IEnumFORMATETC* pEFM;
    IWebBrowserApp* pdie;

    ASSERT(pbc);
    ASSERT(psb);
    HRESULT hres = IUnknown_QueryService(psb, IID_IWebBrowserApp, IID_IWebBrowserApp, (LPVOID*)&pdie);
    if (SUCCEEDED(hres))
    {
        VARIANT var;
        hres = pdie->GetProperty((BSTR)s_sstrEFM.wsz, &var);
        if (SUCCEEDED(hres))
        {
            if (var.vt == VT_EMPTY)
            {
#ifdef FULL_DEBUG
                DebugMsg(DM_TRACE, TEXT("RegisterDefaultAcceptHeaders var.vt == VT_EMPTY"));
#endif
                CreateDefaultAcceptHeaders(&var, pdie);
            }
            else if (var.vt == VT_UNKNOWN)
            {
#ifdef FULL_DEBUG
                DebugMsg(DM_TRACE, TEXT("RegisterDefaultAcceptHeaders var.vt == VT_UNKNOWN"));
#endif
                hres = var.punkVal->QueryInterface(IID_IEnumFORMATETC, (LPVOID*)&pEFM);
                if (SUCCEEDED(hres)) {
                    IEnumFORMATETC* pEFMClone = NULL;
                    hres = pEFM->Clone(&pEFMClone);
                    if (SUCCEEDED(hres)) {
#ifdef FULL_DEBUG
                        DebugMsg(DM_TRACE, TEXT("RegisterDefaultAcceptHeaders registering FormatEnum %x"), pEFMClone);
#endif
                        hres = wrap_RegisterFormatEnumerator(pbc, pEFMClone, 0);
                        pEFMClone->Release();
                    } else {
                        DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders Clone failed %x"), hres);
                    }
                    pEFM->Release();
                }
            }
            else
            {
                DebugMsg(TF_ERROR, TEXT("GetProperty() returned illegal Variant Type: %x"), var.vt);
                DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders not registering FormatEnum"));
            }

            VariantClear(&var);
        } else {
            DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders pdie->GetProperty() failed %x"), hres);
        }

        pdie->Release();
    } else {
        DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders QueryService(ISP) failed %x"), hres);
    }

    return hres;
} // RegisterDefaultAcceptHeaders

STDAPI GetAcceptLanguagesA(LPSTR pszLanguages, LPDWORD pcchLanguages)
{
    return common_GetAcceptLanguages(pszLanguages, pcchLanguages);
}  // GetAcceptLanguagesA

STDAPI GetAcceptLanguagesW(LPWSTR pwzLanguages, LPDWORD pcchLanguages)
{
    if (!pwzLanguages || !pcchLanguages || !*pcchLanguages)
        return E_FAIL;

    DWORD dwcchMaxOut = *pcchLanguages;

    LPSTR psz = (LPSTR) LocalAlloc (LPTR, dwcchMaxOut);
    if (!psz)
        return E_OUTOFMEMORY;

    HRESULT hr = common_GetAcceptLanguages(psz, &dwcchMaxOut);
    if (SUCCEEDED(hr))
    {
        *pcchLanguages = MultiByteToWideChar(CP_ACP, 0, psz, -1,
                             pwzLanguages, *pcchLanguages - 1);

        pwzLanguages[*pcchLanguages] = 0;
    }

    LocalFree(psz);
    return hr;
} // GetAcceptLanguagesW

STDAPI common_GetAcceptLanguages(CHAR *psz, LPDWORD pcch)
{
    HKEY hk;
    HRESULT hr = E_FAIL;

    if (!psz || !pcch || !*pcch)
        return hr;

    if ((RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, 0, KEY_READ, &hk) == ERROR_SUCCESS) && hk) 
    {
        DWORD dwType;

        // pcch == pcb
        if (RegQueryValueEx(hk, REGSTR_VAL_ACCEPT_LANGUAGE, NULL, &dwType, (UCHAR *)psz, pcch) != ERROR_SUCCESS) 
        {

            // When there is no AcceptLanguage key, we have to default
            DWORD LCID = GetUserDefaultLCID();            

            // Use MLang for RFC1766 language name            
            hr = LcidToRfc1766A(LCID, psz, *pcch);
            
            if (S_OK == hr)
                *pcch = lstrlenA(psz);
            else 
            {
                *pcch = 0;
                AssertMsg(FALSE, TEXT("We should add LCID 0x%lx to MLang RFC1766 table"), LCID);
            }
        } 
        else 
        {
            hr = S_OK;
            if (!*psz) 
            {
                // A NULL AcceptLanguage means send no A-L: header
                hr = S_FALSE;
            }
        }

        RegCloseKey (hk);
    } 

    return hr;
}  // w_GetAcceptLanguages
    

//
// Both of these functions will be called only once per browser session - the
// first time we create the FormatEnumerator.  After that, we will use the one
// we created, rather than needing to call these to allocate a new one.
//

HRESULT wrap_RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hurl = LoadLibrary(TEXT("URLMON.DLL"));
    if (hurl) 
    {
        HRESULT (*pfnRFE)(LPBC pBC, IEnumFORMATETC * pEFetc, DWORD reserved);

        pfnRFE = (HRESULT (*)(LPBC, IEnumFORMATETC*, DWORD))GetProcAddress (hurl, "RegisterFormatEnumerator");
        if (pfnRFE) 
        {
            hr = pfnRFE(pBC, pEFetc, reserved);
        }

        FreeLibrary(hurl);
    }

    return hr;
}

HRESULT wrap_CreateFormatEnumerator(UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hurl = LoadLibrary(TEXT("URLMON.DLL"));
    if (hurl) 
    {
        HRESULT (*pfnCFE)(UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC **ppenumfmtetc);

        pfnCFE = (HRESULT (*)(UINT, FORMATETC*, IEnumFORMATETC **))GetProcAddress (hurl, "CreateFormatEnumerator");
        if (pfnCFE) 
        {
            hr = pfnCFE(cfmtetc, rgfmtetc, ppenumfmtetc);
        }

        FreeLibrary(hurl);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\inistr.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       inistr.cpp
//
//  Contents:   SHGet/SetIniStringW implementations, which save strings into
//              INI files in a manner that survives the round trip to disk.
//
//----------------------------------------------------------------------------

#include "priv.h"
#define _SHELL32_
#define _SHDOCVW_

#include <platform.h>
#include <mlang.h>
#include "cstrinout.h"

//
//  Do this in every wrapper function that has an output parameter.
//  It raises assertion failures on the main code path so that
//  the same assertions are raised on NT and 95.  The CStrOut class
//  doesn't like it when you say that an output buffer is NULL yet
//  has nonzero length.  Without this macro, the bug would go undetected
//  on NT and appear only on Win95.
//
#define VALIDATE_OUTBUF(s, cch) ASSERT((s) != NULL || (cch) == 0)

//----------------------------------------------------------------------------
//
//  The basic problem is that INI files are ANSI-only, so any UNICODE
//  string you put into it won't round-trip.
//
//  So the solution is to record UNICODE strings in UTF7.  Why UTF7?
//  Because we can't use UTF8, since XxxPrivateProfileStringW will try
//  to convert the 8-bit values to/from UNICODE and mess them up.  Since
//  some of the 8-bit values might not even be valid (e.g., a DBCS lead
//  byte followed by an illegal trail byte), we cannot assume that the
//  string will survive the ANSI -> UNICODE -> ANSI round-trip.
//
//  The UTF7 string is stored in a [Section.W] section, under the
//  same key name.  The original ANSI string is stored in a [Section.A]
//  section, again, with the same key name.
//
//  (We separate the A/W from the section name with a dot so it is less
//  likely that we will accidentally collide with other section names.
//
//  We store the original ANSI string twice so we can compare the two
//  and see if a downlevel app (e.g., IE4) has changed the [Section]
//  version.  If so, then we ignore the [Section.W] version since it's stale.
//
//  If the original string is already 7-bit clean, then no UTF7 string is
//  recorded.
//

BOOL
Is7BitClean(LPCWSTR pwsz)
{
    for ( ; *pwsz; pwsz++) {
        if ((UINT)*pwsz > 127)
            return FALSE;
    }
    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Yet another conversion class -- this one is for creating the
//  variants of a section name.
//
//  Note!  Since INI files are ASCII, section names are necessarily 7-bit
//  clean, so we can cheat a lot of stuff.
//

class CStrSectionX : public CConvertStrW
{
public:
    CStrSectionX(LPCWSTR pwszSection);
};

//
//  We append a dot an an A or W to the section name.
//
#define SECTION_SUFFIX_LEN  2

CStrSectionX::CStrSectionX(LPCWSTR pwszSection)
{
    ASSERT(_pwstr == NULL);
    if (pwszSection) {
        int cch_pwstr;

        ASSERT(Is7BitClean(pwszSection));

        UINT cwchNeeded = lstrlenW(pwszSection) + SECTION_SUFFIX_LEN + 1;
        if (cwchNeeded > ARRAYSIZE(_awch)) {
            _pwstr = new WCHAR[cwchNeeded];
            cch_pwstr = cwchNeeded;
        } else {
            _pwstr = _awch;
            cch_pwstr = ARRAYSIZE(_awch);
        }

        if (_pwstr) {
            // Build the string initially with ".A" stuck on the end
            // It will later get changed to a ".W"
            StringCchCopyW(_pwstr, cch_pwstr, pwszSection);
            StringCchCatW(_pwstr, cch_pwstr, L".A");
        } else {
            _pwstr = _awch;
            _awch[0] = L'\0';
        }
    }
}

//----------------------------------------------------------------------------
//
//  Mini-class for keeping track of UTF7 strings.  These are kept in ANSI
//  most of the time since that's what ConvertINetUnicodeToMultiByte uses.
//
//  The UTF7 shadow is prefixed by a checksum of the original string, which
//  we use on read-back to see if the shadow still corresponds to the
//  original string.
//

class CStrUTF7 : public CConvertStr
{
public:
    inline CStrUTF7() : CConvertStr(CP_ACP) { };
    void SetUnicode(LPCWSTR pwszValue);
};

//
//  Note that this can be slow since it happens only when we encounter
//  a non-ANSI character.
//
void CStrUTF7::SetUnicode(LPCWSTR pwszValue)
{
    int cwchLen = lstrlenW(pwszValue);
    HRESULT hres;
    DWORD dwMode;

    int cwchLenT = cwchLen;

    // Save room for terminating NULL.  We must convert the NULL separately
    // because UTF7 does not translate NULL to NULL.
    int cchNeeded = ARRAYSIZE(_ach) - 1;
    dwMode = 0;
    hres = ConvertINetUnicodeToMultiByte(&dwMode, CP_UTF7, pwszValue,
                                         &cwchLenT, _ach,
                                         &cchNeeded);
    if (SUCCEEDED(hres)) {
        ASSERT(cchNeeded + 1 <= ARRAYSIZE(_ach));
        _pstr = _ach;
    } else {
        _pstr = new CHAR[cchNeeded + 1];
        if (!_pstr)
            return;                 // No string - tough

        cwchLenT = cwchLen;
        dwMode = 0;
        hres = ConvertINetUnicodeToMultiByte(&dwMode, CP_UTF7, pwszValue,
                                    &cwchLenT, _pstr,
                                    &cchNeeded);
        if (FAILED(hres)) {         // Couldn't convert - tough
            Free();
            return;
        }
    }

    // Terminate explicitly since UTF7 doesn't.
    _pstr[cchNeeded] = '\0';
}

//
//  pwszSection  = section name into which to write pwszValue (UNICODE)
//  pwszSectionA = section name into which to write ANSI shadow
//  pwszKey      = key name for both pwszValue and strUTF7
//  pwszFileName = file name
//
//  pwszSectionA can be NULL if a low-memory condition was encountered.
//
//  strUTF7 can be NULL, meaning that the shadows should be deleted.
//
//  Write pwszSection first, followed by pwszSectionA, then pwszSectionW.
//  This ensures that the backwards-compatibility string comes first in
//  the file, in case there are apps that assume such.
//
//  pwszSectionW is computed from pwszSectionA by changing the last "A"
//  to a "W".  pwszSecionW gets the UTF7-encoded unicode string.
//  strUTF7 might be NULL, meaning that we should delete the shadow strings.
//
BOOL WritePrivateProfileStringMultiW(LPCWSTR pwszSection,  LPCWSTR pwszValue,
                                      LPWSTR pwszSectionA, CStrUTF7& strUTF7,
                                     LPCWSTR pwszKey,      LPCWSTR pwszFileName)
{
    BOOL fRc = WritePrivateProfileStringW(pwszSection, pwszKey, pwszValue, pwszFileName);

    if (pwszSectionA) {
        //
        //  Write the [Section.A] key, or delete it if there is no UTF7.
        //
        WritePrivateProfileStringW(pwszSectionA, pwszKey,
                                   strUTF7 ? pwszValue : NULL, pwszFileName);

        //
        //  Now change pwszSectionA to pwszSectionW so we can write out
        //  the UTF7 encoding.
        //
        pwszSectionA[lstrlenW(pwszSectionA) - 1] = TEXT('W');

        CStrInW strUTF7W(strUTF7);
        if (strUTF7W.strlen())
        {
            // This really writes [Section.W]
            WritePrivateProfileStringW(pwszSectionA, pwszKey, strUTF7W, pwszFileName);
        }
    }

    return fRc;
}

BOOL WINAPI
SHSetIniStringW(LPCWSTR pwszSection, LPCWSTR pwszKey, LPCWSTR pwszValue, LPCWSTR pwszFileName)
{
    // We have no way of encoding these two, so they had better by 7-bit clean
    // We also do not support "delete entire section"
    AssertMsg(pwszSection != NULL,
              TEXT("SHSetIniStringW: Section name cannot be NULL; bug in caller"));
    AssertMsg(Is7BitClean(pwszSection),
              TEXT("SHSetIniStringW: Section name not 7-bit clean; bug in caller"));
    AssertMsg(pwszKey != NULL,
              TEXT("SHSetIniStringW: Key name cannot be NULL; bug in caller"));
    AssertMsg(!pwszKey     || Is7BitClean(pwszKey),
              TEXT("SHSetIniStringW: Key name not 7-bit clean; bug in caller"));

    CStrSectionX strSectionX(pwszSection);
    CStrUTF7 strUTF7;               // Assume no UTF7 needed.

    if (strSectionX && pwszKey && pwszValue && !Is7BitClean(pwszValue)) {
        //
        //  The value is not 7-bit clean.  Must create a UTF7 version.
        //
        strUTF7.SetUnicode(pwszValue);
    }

        return WritePrivateProfileStringMultiW(pwszSection, pwszValue,
                                               strSectionX, strUTF7,
                                               pwszKey,     pwszFileName);
}

//
//  Keep calling GetPrivateProfileString with bigger and bigger buffers
//  until we get the entire string.  Start with MAX_PATH, since that's
//  usually plenty big enough.
//
//  The returned buffer must be freed with LocalFree, not delete[].
//
LPVOID GetEntirePrivateProfileStringAorW(
    LPCVOID pszSection,
    LPCVOID pszKey,
    LPCVOID pszFileName,
    BOOL    fUnicode)
{
    int    CharSize = fUnicode ? sizeof(WCHAR) : sizeof(CHAR);
    UINT   cchResult = MAX_PATH;
    LPVOID pszResult = LocalAlloc(LMEM_FIXED, cchResult * CharSize);
    LPVOID pszFree = pszResult;

    while (pszResult) {
        UINT cchRc;
        if (fUnicode)
            cchRc = GetPrivateProfileStringW((LPCWSTR)pszSection,
                                             (LPCWSTR)pszKey,
                                             L"",
                                             (LPWSTR)pszResult, cchResult,
                                             (LPCWSTR)pszFileName);
        else
            cchRc = GetPrivateProfileStringA((LPCSTR)pszSection,
                                             (LPCSTR)pszKey,
                                             "",
                                             (LPSTR)pszResult, cchResult,
                                             (LPCSTR)pszFileName);

        if (cchRc < cchResult - 1)
            return pszResult;

        // Buffer too small - iterate
        cchResult *= 2;
        LPVOID pszNew = LocalReAlloc(pszResult, cchResult * CharSize, LMEM_MOVEABLE);
        pszFree = pszResult;
        pszResult = pszNew;
    }

    //
    //  Memory allocation failed; free pszFree while we still can.
    //
    if (pszFree)
        LocalFree(pszFree);
    return NULL;
}

DWORD GetPrivateProfileStringMultiW(LPCWSTR pwszSection, LPCWSTR pwszKey,
                                    LPWSTR pwszSectionA,
                                    LPWSTR pwszReturnedString, DWORD cchSize,
                                    LPCWSTR pwszFileName)
{
    LPWSTR pwszValue  = NULL;
    LPWSTR pwszValueA = NULL;
    LPWSTR pwszUTF7 = NULL;
    DWORD dwRc;

    pwszValue  = (LPWSTR)GetEntirePrivateProfileStringAorW(
                              pwszSection, pwszKey,
                              pwszFileName, TRUE);
    if (pwszValue) {

        //
        //  If the value is an empty string, then don't waste your
        //  time trying to get the UNICODE version - the UNICODE version
        //  of the empty string is the empty string.
        //
        //  Otherwise, get the ANSI shadow hidden in [Section.A]
        //  and see if it matches.  If not, then the file was edited
        //  by a downlevel app and we should just use pwszValue after all.

        if (pwszValue[0] &&
            (pwszValueA = (LPWSTR)GetEntirePrivateProfileStringAorW(
                                      pwszSectionA, pwszKey,
                                      pwszFileName, TRUE)) != NULL &&
            lstrcmpW(pwszValue, pwszValueA) == 0) {

            // our shadow is still good - run with it
            // Change [Section.A] to [Section.W]
            pwszSectionA[lstrlenW(pwszSectionA) - 1] = TEXT('W');

            pwszUTF7 = (LPWSTR)GetEntirePrivateProfileStringAorW(
                                      pwszSectionA, pwszKey,
                                      pwszFileName, TRUE);

            CStrIn strUTF7(pwszUTF7);

            dwRc = 0;                   // Assume something goes wrong

            if (strUTF7.strlen()) {
                dwRc = SHAnsiToUnicodeCP(CP_UTF7, strUTF7, pwszReturnedString, cchSize);
            }

            if (dwRc == 0) {
                // Problem converting to UTF7 - just use the ANSI version
                dwRc = SHUnicodeToUnicode(pwszValue, pwszReturnedString, cchSize);
            }

        } else {
            // String was empty or couldn't get [Section.A] shadow or
            // shadow doesn't match.  Just use the regular string.
            dwRc = SHUnicodeToUnicode(pwszValue, pwszReturnedString, cchSize);
        }

        // The SHXxxToYyy functions include the terminating zero,
        // which we want to exclude.
        if (dwRc > 0)
            dwRc--;

    } else {
        // Fatal error reading values from file; just use the boring API
        dwRc = GetPrivateProfileStringW(pwszSection,
                                        pwszKey,
                                        L"",
                                        pwszReturnedString, cchSize,
                                        pwszFileName);
    }

    if (pwszValue)
        LocalFree(pwszValue);
    if (pwszValueA)
        LocalFree(pwszValueA);
    if (pwszUTF7)
        LocalFree(pwszUTF7);

    return dwRc;
}

DWORD WINAPI SHGetIniStringW(LPCWSTR pwszSection, LPCWSTR pwszKey, LPWSTR pwszReturnedString, DWORD cchSize, LPCWSTR pwszFileName)
{
    VALIDATE_OUTBUF(pwszReturnedString, cchSize);

    // We have no way of encoding these two, so they had better by 7-bit clean
    // We also do not support "get all section names" or "get entire section".
    AssertMsg(pwszSection != NULL,
              TEXT("SHGetIniStringW: Section name cannot be NULL; bug in caller"));
    AssertMsg(Is7BitClean(pwszSection),
              TEXT("SHGetIniStringW: Section name not 7-bit clean; bug in caller"));
    AssertMsg(pwszKey != NULL,
              TEXT("SHGetIniStringW: Key name cannot be NULL; bug in caller"));
    AssertMsg(Is7BitClean(pwszKey),
              TEXT("SHGetIniStringW: Key name not 7-bit clean; bug in caller"));

    CStrSectionX strSectionX(pwszSection);
    if (!strSectionX[0])
    {
        return 0; // out of memory
    }

    return GetPrivateProfileStringMultiW(pwszSection, pwszKey,
                                         strSectionX,
                                         pwszReturnedString, cchSize,
                                         pwszFileName);
}

//+---------------------------------------------------------------------------
//
//  CreateURLFileContents
//
//  shdocvw.dll and url.dll need to create in-memory images
//  of URL files, so this helper function does all the grunky work so they
//  can remain insulated from the way we encode Unicode strings into INI files.
//  The resulting memory should be freed via GlobalFree().

//
//  Writes a string into the URL file.  If fWrite is FALSE, then
//  then just do the math and don't actually write anything.  This lets us
//  use one function to handle both the measurement pass and the rendering
//  pass.
//
LPSTR AddToURLFileContents(LPSTR pszFile, LPCSTR psz, BOOL fWrite)
{
    int cch = lstrlenA(psz);
    if (fWrite) {
        memcpy(pszFile, psz, cch * sizeof(char));
    }
    pszFile += cch;
    return pszFile;
}

LPSTR AddURLFileSection(LPSTR pszFile, LPCSTR pszSuffix, LPCSTR pszUrl, BOOL fWrite)
{
    pszFile = AddToURLFileContents(pszFile, "[InternetShortcut", fWrite);
    pszFile = AddToURLFileContents(pszFile, pszSuffix, fWrite);
    pszFile = AddToURLFileContents(pszFile, "]\r\nURL=", fWrite);
    pszFile = AddToURLFileContents(pszFile, pszUrl, fWrite);
    pszFile = AddToURLFileContents(pszFile, "\r\n", fWrite);
    return pszFile;
}

//
//  The file consists of an [InternetShortcut] section, followed if
//  necessary by [InternetShortcut.A] and [InternetShortcut.W].
//
LPSTR AddURLFileContents(LPSTR pszFile, LPCSTR pszUrl, LPCSTR pszUTF7, BOOL fWrite)
{
    pszFile = AddURLFileSection(pszFile, "", pszUrl, fWrite);
    if (pszUTF7) {
        pszFile = AddURLFileSection(pszFile, ".A", pszUrl, fWrite);
        pszFile = AddURLFileSection(pszFile, ".W", pszUTF7, fWrite);
    }
    return pszFile;
}

//
//  Returns number of bytes in file contents (not including trailing NULL),
//  or an OLE error code.  If ppszOut is NULL, then no contents are returned.
//
HRESULT GenerateURLFileContents(LPCWSTR pwszUrl, LPCSTR pszUrl, LPSTR *ppszOut)
{
    HRESULT hr = 0;

    if (ppszOut)
        *ppszOut = NULL;

    if (pwszUrl && pszUrl) {
        CStrUTF7 strUTF7;               // Assume no UTF7 needed.
        if (!Is7BitClean(pwszUrl)) {
            //
            //  The value is not 7-bit clean.  Must create a UTF7 version.
            //
            strUTF7.SetUnicode(pwszUrl);
        }

        hr = PtrToUlong(AddURLFileContents(NULL, pszUrl, strUTF7, FALSE));
        ASSERT(SUCCEEDED(hr));

        if (ppszOut) {
            *ppszOut = (LPSTR)GlobalAlloc(GMEM_FIXED, hr + 1);
            if (*ppszOut) {
                LPSTR pszEnd = AddURLFileContents(*ppszOut, pszUrl, strUTF7, TRUE);
                *pszEnd = '\0';
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    //
    //  Double-check the value we return.
    //
    if (SUCCEEDED(hr) && ppszOut) {
        ASSERT(hr == lstrlenA(*ppszOut));
    }

    return hr;
}


HRESULT CreateURLFileContentsW(LPCWSTR pwszUrl, LPSTR *ppszOut)
{
    if (pwszUrl)
    {
        CStrIn strUrl(pwszUrl);
        if (strUrl.strlen())
        {
            return GenerateURLFileContents(pwszUrl, strUrl, ppszOut);
        }
        return E_OUTOFMEMORY;
    }
    return E_INVALIDARG;
}

HRESULT CreateURLFileContentsA(LPCSTR pszUrl, LPSTR *ppszOut)
{
    if (pszUrl)
    {
        CStrInW strUrl(pszUrl);
        if (strUrl.strlen())
        {
            return GenerateURLFileContents(strUrl, pszUrl, ppszOut);
        }
        return E_OUTOFMEMORY;
    }
    return E_INVALIDARG;
}

DWORD SHGetIniStringUTF7W(LPCWSTR lpSection, LPCWSTR lpKey, LPWSTR lpBuf, DWORD nSize, LPCWSTR lpFile)
{
    if (*lpKey == CH_CANBEUNICODEW)
        return SHGetIniStringW(lpSection, lpKey+1, lpBuf, nSize, lpFile);
    else
        return GetPrivateProfileStringW(lpSection, lpKey, L"", lpBuf, nSize, lpFile);
}

BOOL SHSetIniStringUTF7W(LPCWSTR lpSection, LPCWSTR lpKey, LPCWSTR lpString, LPCWSTR lpFile)
{
    if (*lpKey == CH_CANBEUNICODEW)
        return SHSetIniStringW(lpSection, lpKey+1, lpString, lpFile);
    else
        return WritePrivateProfileStringW(lpSection, lpKey, lpString, lpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\menu.c ===
#include "priv.h"
#pragma  hdrstop


int GetMenuPosFromID(HMENU hmenu, UINT id)
{
    int iPos = -1;
    int cItems = GetMenuItemCount(hmenu);
    int i;

    for (i=0; i<cItems;i++)
    {
        MENUITEMINFO mii;
        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_ID;
        mii.wID = 0;
        if (GetMenuItemInfo(hmenu, i, TRUE, &mii))
        {
            if (mii.wID == id)
            {
                iPos = i;
                break;
            }
        }
    }

    return iPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\helpmb.cpp ===
//
// SHMessageBoxHelp implementation
//
// History
//  01/14/00 dsheldon created
//

#include "priv.h"
#include "ids.h"
#include <htmlhelp.h>
 
HRESULTHELPMAPPING g_prghhmShellDefault[] =
{
    {HRESULT_FROM_WIN32(ERROR_NO_NETWORK),   "tshoot00.chm>windefault",      "w0networking.htm"      },
};

class CHelpMessageBox
{
public:
    CHelpMessageBox(HRESULTHELPMAPPING* prghhm, DWORD chhm);
    int DoHelpMessageBox(HWND hwndParent, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, HRESULT hrErr);

private:
    int DisplayMessageBox(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType);
    HRESULTHELPMAPPING* GetHResultHelpMapping(HRESULT hrErr, HRESULTHELPMAPPING* prghhm, DWORD chhm);
    
    static INT_PTR CALLBACK StaticDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Data
    HRESULTHELPMAPPING*   _prghhm;
    DWORD                 _chhm;

    HRESULTHELPMAPPING*   _phhmEntry;

    LPCWSTR                _pszText;
    LPCWSTR                _pszCaption;
    UINT                   _uType;
};


CHelpMessageBox::CHelpMessageBox(HRESULTHELPMAPPING* prghhm, DWORD chhm)
{
    // Initialize class members
    _phhmEntry = NULL;
    _prghhm = prghhm;
    _chhm = chhm;
}


int CHelpMessageBox::DisplayMessageBox(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType)
{
    LPWSTR pszAllocString = NULL;

    if (NULL != _phhmEntry)
    {
        uType |= MB_HELP;

        // Need to add the "For more information, click help." string.
        WCHAR szMoreInfo[256];

        if (LoadStringW(HINST_THISDLL, IDS_CLICKHELPFORINFO, szMoreInfo, ARRAYSIZE(szMoreInfo)))
        {
            DWORD cchText = lstrlenW(pszText);

            // The 3 here are for '\n', '\n', '\0'
            DWORD cchBuffer = cchText + lstrlenW(szMoreInfo) + 3;

            pszAllocString = (LPWSTR) LocalAlloc(0, cchBuffer * sizeof (WCHAR));

            if (pszAllocString)
            {
                StringCchPrintfW(pszAllocString, cchBuffer, L"%s\n\n%s", pszText, szMoreInfo);
            }
        }
    }
    else
    {
        // No help topic mapping for this error
        TraceMsg(TF_WARNING, "No help topic mapping for this error. Removing help button.");
        uType &= (~MB_HELP);
    }

    int iReturn = MessageBoxW(hwnd, pszAllocString ? pszAllocString : pszText, pszCaption, uType);

    if (pszAllocString)
    {
        LocalFree(pszAllocString);
    }

    return iReturn;
}

HRESULTHELPMAPPING* CHelpMessageBox::GetHResultHelpMapping(HRESULT hrErr, HRESULTHELPMAPPING* prghhm, DWORD chhm)
{
    HRESULTHELPMAPPING* phhm = NULL;

    for (DWORD i = 0; i < chhm; i++)
    {
        if (prghhm[i].hr == hrErr)
        {
            phhm = &(prghhm[i]);
            break;
        }
    }    

    return phhm;
}

CHelpMessageBox::DoHelpMessageBox(HWND hwndParent, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, HRESULT hrErr)
{
    int iReturn = 0;
    _pszText = pszText;
    _pszCaption = pszCaption;
    _uType = uType;

    // Find the index of the help topic matching the hresult
    // First search the mapping the user passed in, if present
    if (NULL != _prghhm)
    {
        _phhmEntry = GetHResultHelpMapping(hrErr, _prghhm, _chhm);
    }

    // If we didn't find a mapping in the caller's list, search the shell's global list
    if (NULL == _phhmEntry)
    {
        _phhmEntry = GetHResultHelpMapping(hrErr, g_prghhmShellDefault, ARRAYSIZE(g_prghhmShellDefault));
    }

    ULONG_PTR ul;
    HANDLE h = CreateAndActivateContext(&ul);
    iReturn = (int) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_NULL), hwndParent, StaticDlgProc, (LPARAM) this);
    DeactivateAndDestroyContext(h, ul);

    return iReturn;
}

INT_PTR CHelpMessageBox::StaticDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHelpMessageBox* pthis = NULL;
    
    if (uMsg == WM_INITDIALOG)
    {
        pthis = (CHelpMessageBox*) lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pthis);
    }
    else
    {
        pthis = (CHelpMessageBox*) GetWindowLongPtr(hwnd, DWLP_USER);
    }

    if (NULL != pthis)
    {
        return pthis->DlgProc(hwnd, uMsg, wParam, lParam);
    }
 
    return 0;
}

INT_PTR CHelpMessageBox::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR iReturn = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Launch Messagebox
        {
            int i = DisplayMessageBox(hwnd, _pszText, _pszCaption, _uType);

            EndDialog(hwnd, i);
        }

        iReturn = TRUE;

        break;
    case WM_HELP:
        // Call the appropriate help topic
        ASSERT(_phhmEntry != NULL);

        HtmlHelpA(
            hwnd, 
            _phhmEntry->szHelpFile, 
            HH_DISPLAY_TOPIC,
            (DWORD_PTR) _phhmEntry->szHelpTopic);
        
        break;
    default:
        break;
    }

    return iReturn;
}

STDAPI_(int) SHMessageBoxHelpA(HWND hwnd, 
                               LPCSTR pszText, 
                               LPCSTR pszCaption, 
                               UINT uType,
                               HRESULT hrErr,
                               HRESULTHELPMAPPING* prghhm,
                               DWORD chhm)
{
    WCHAR szTextW[1024];
    WCHAR szCaptionW[256];

    CHelpMessageBox parent(prghhm, chhm);

    if (!SHAnsiToUnicode(pszText, szTextW, ARRAYSIZE(szTextW)))
    {
        *szTextW = 0;
    }

    if (!SHAnsiToUnicode(pszCaption, szCaptionW, ARRAYSIZE(szCaptionW)))
    {
        *szCaptionW = 0;
    }

    return parent.DoHelpMessageBox(hwnd, szTextW, szCaptionW, uType, hrErr);
}

STDAPI_(int) SHMessageBoxHelpW(HWND hwnd, 
                               LPCWSTR pszText, 
                               LPCWSTR pszCaption, 
                               UINT uType,
                               HRESULT hrErr,
                               HRESULTHELPMAPPING* prghhm,
                               DWORD chhm)
{
    CHelpMessageBox parent(prghhm, chhm);
    return parent.DoHelpMessageBox(hwnd, pszText, pszCaption, uType, hrErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\machinfo.cpp ===
//
// machinfo.cpp - SHGetMachineInfo and related functions
//
//

#include "priv.h"
#include <dbt.h>
#include <cfgmgr32.h>
 
#include <batclass.h>

const GUID GUID_DEVICE_BATTERY = { 0x72631e54L, 0x78A4, 0x11d0,
              { 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a } };

/*****************************************************************************
 *
 *  DOCK STATE - Win95, Win98, and WinNT all do this differently (yuck)
 *
 *****************************************************************************/

C_ASSERT(GMID_NOTDOCKABLE == CM_HWPI_NOT_DOCKABLE);
C_ASSERT(GMID_UNDOCKED    == CM_HWPI_UNDOCKED);
C_ASSERT(GMID_DOCKED      == CM_HWPI_DOCKED);

DWORD GetDockedStateNT()
{
    HW_PROFILE_INFO hpi;
    DWORD Result = GMID_NOTDOCKABLE;    // assume the worst

    if (GetCurrentHwProfile(&hpi)) {
        Result = hpi.dwDockInfo & (DOCKINFO_UNDOCKED | DOCKINFO_DOCKED);

        // Wackiness: If the machine does not support docking, then
        // NT returns >both< flags set.  Go figure.
        if (Result == (DOCKINFO_UNDOCKED | DOCKINFO_DOCKED)) {
            Result = GMID_NOTDOCKABLE;
        }
    } else {
        TraceMsg(DM_WARNING, "GetDockedStateNT: GetCurrentHwProfile failed");
    }
    return Result;
}

//
//  Platforms that do not support Win95/Win98 can just call the NT version.
//
#define GetDockedState()            GetDockedStateNT()


/*****************************************************************************
 *
 *  BATTERY STATE - Once again, Win95 and Win98 and NT all do it differently
 *
 *****************************************************************************/

//
//  Values for SYSTEM_POWER_STATUS.ACLineStatus
//
#define SPSAC_OFFLINE       0
#define SPSAC_ONLINE        1

//
//  Values for SYSTEM_POWER_STATUS.BatteryFlag
//
#define SPSBF_NOBATTERY     128

//
//  So many ways to detect batteries, so little time...
//
DWORD GetBatteryState()
{
    //
    //  Since GMIB_HASBATTERY is cumulative (any battery turns it on)
    //  and GMIB_ONBATTERY is subtractive (any AC turns it off), the
    //  state you have to start in before you find a battery is
    //  GMIB_HASBATTERY off and GMIB_ONBATTERY on.
    //
    //  dwResult & GMIB_ONBATTERY means we have yet to find AC power.
    //  dwResult & GMIB_HASBATTERY means we have found a non-UPS battery.
    //
    DWORD dwResult = GMIB_ONBATTERY;

    //------------------------------------------------------------------
    //
    //  First try - IOCTL_BATTERY_QUERY_INFORMATION
    //
    //------------------------------------------------------------------
    //
    //  Windows 98 and Windows 2000 support IOCTL_BATTERY_QUERY_INFORMATION,
    //  which lets us enumerate the batteries and ask each one for information.
    //  Except that on Windows 98, we can enumerate only ACPI batteries.
    //  We still have to use VPOWERD to enumerate APM batteries.
    //  FEATURE -- deal with Win98 APM batteries

    HDEVINFO hdev = SetupDiGetClassDevs(&GUID_DEVICE_BATTERY, 0, 0,
                        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hdev != INVALID_HANDLE_VALUE) {
        SP_DEVICE_INTERFACE_DATA did;
        did.cbSize = sizeof(did);
        // Stop at 100 batteries so we don't go haywire
        for (int idev = 0; idev < 100; idev++) {
            // Pre-set the error code because our DLLLOAD wrapper doesn't
            // and Windows NT 4 supports SetupDiGetClassDevs but not
            // SetupDiEnumDeviceInterfaces (go figure).
            SetLastError(ERROR_NO_MORE_ITEMS);
            if (SetupDiEnumDeviceInterfaces(hdev, 0, &GUID_DEVICE_BATTERY, idev, &did)) {
                DWORD cbRequired = 0;

                /*
                 *  Ask for the required size then allocate it then fill it.
                 *
                 *  Sigh.  Windows NT and Windows 98 implement
                 *  SetupDiGetDeviceInterfaceDetail differently if you are
                 *  querying for the buffer size.
                 *
                 *  Windows 98 returns FALSE, and GetLastError() returns
                 *  ERROR_INSUFFICIENT_BUFFER.
                 *
                 *  Windows NT returns TRUE.
                 *
                 *  So we allow the cases either where the call succeeds or
                 *  the call fails with ERROR_INSUFFICIENT_BUFFER.
                 */

                if (SetupDiGetDeviceInterfaceDetail(hdev, &did, 0, 0, &cbRequired, 0) ||
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
                    pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LPTR, cbRequired);
                    if (pdidd) {
                        pdidd->cbSize = sizeof(*pdidd);
                        if (SetupDiGetDeviceInterfaceDetail(hdev, &did, pdidd, cbRequired, &cbRequired, 0)) {
                            /*
                             *  Finally enumerated a battery.  Ask it for information.
                             */
                            HANDLE hBattery = CreateFile(pdidd->DevicePath,
                                                         GENERIC_READ | GENERIC_WRITE,
                                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                         NULL, OPEN_EXISTING,
                                                         FILE_ATTRIBUTE_NORMAL, NULL);
                            if (hBattery != INVALID_HANDLE_VALUE) {
                                /*
                                 *  Now you have to ask the battery for its tag.
                                 */
                                BATTERY_QUERY_INFORMATION bqi;

                                DWORD dwWait = 0;
                                DWORD dwOut;
                                bqi.BatteryTag = 0;

                                if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_TAG,
                                                    &dwWait, sizeof(dwWait),
                                                    &bqi.BatteryTag, sizeof(bqi.BatteryTag),
                                                    &dwOut, NULL) && bqi.BatteryTag) {
                                    /*
                                     *  With the tag, you can query the battery info.
                                     */
                                    BATTERY_INFORMATION bi;
                                    bqi.InformationLevel = BatteryInformation;
                                    bqi.AtRate = 0;
                                    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION,
                                                        &bqi, sizeof(bqi),
                                                        &bi,  sizeof(bi),
                                                        &dwOut, NULL)) {
                                        // Only system batteries count
                                        if (bi.Capabilities & BATTERY_SYSTEM_BATTERY)  {
                                            if (!(bi.Capabilities & BATTERY_IS_SHORT_TERM)) {
                                                dwResult |= GMIB_HASBATTERY;
                                            }

                                            /*
                                             *  And then query the battery status.
                                             */
                                            BATTERY_WAIT_STATUS bws;
                                            BATTERY_STATUS bs;
                                            ZeroMemory(&bws, sizeof(bws));
                                            bws.BatteryTag = bqi.BatteryTag;
                                            if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_STATUS,
                                                                &bws, sizeof(bws),
                                                                &bs,  sizeof(bs),
                                                                &dwOut, NULL)) {
                                                if (bs.PowerState & BATTERY_POWER_ON_LINE) {
                                                    dwResult &= ~GMIB_ONBATTERY;
                                                }
                                            }
                                        }
                                    }
                                }
                                CloseHandle(hBattery);
                            }
                        }
                        LocalFree(pdidd);
                    }
                }
            } else {
                // Enumeration failed - perhaps we're out of items
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);

    }

    //
    //  Final cleanup:  If we didn't find a battery, then presume that we
    //  are on AC power.
    //
    if (!(dwResult & GMIB_HASBATTERY))
        dwResult &= ~GMIB_ONBATTERY;

    return dwResult;
}

/*****************************************************************************
 *
 *  TERMINAL SERVER CLIENT
 *
 *  This is particularly gruesome because Terminal Server for NT4 SP3 goes
 *  to extraordinary lengths to prevent you from detecting it.  Even the
 *  semi-documented NtCurrentPeb()->SessionId trick doesn't work on NT4 SP3.
 *  So we have to go to the totally undocumented winsta.dll to find out.
 *
 *****************************************************************************/
BOOL IsTSClient(void)
{
    // NT5 has a new system metric to detect this
    return GetSystemMetrics(SM_REMOTESESSION);
}

/*****************************************************************************
 *
 *  SHGetMachineInfo
 *
 *****************************************************************************/

//
//  SHGetMachineInfo
//
//  Given an index, returns some info about that index.  See shlwapi.w
//  for documentation on the flags available.
//
STDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi)
{
    switch (gmi) {
    case GMI_DOCKSTATE:
        return GetDockedState();

    case GMI_BATTERYSTATE:
        return GetBatteryState();

    //
    //  It smell like a laptop if it has a battery or if it can be docked.
    //
    case GMI_LAPTOP:
        return (GetBatteryState() & GMIB_HASBATTERY) ||
               (GetDockedState() != GMID_NOTDOCKABLE);

    case GMI_TSCLIENT:
        return IsTSClient();
    }

    TraceMsg(DM_WARNING, "SHGetMachineInfo: Unknown info query %d", gmi);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\itfwrap.cpp ===
//
// Wrapper functions for shell interfaces
//
//  Many ISVs mess up various IShellFolder methods, so we centralize the
//  workarounds so everybody wins.
//
//  Someday, IExtractIcon and IShellLink wrappers may also be added, should
//  the need arise.
//

#include "priv.h"
#include <shlobj.h>

//----------------------------------------------------------------------------
//
//  IShellFolder::GetDisplayNameOf was not very well documented.  Lots of
//  people don't realize that the SHGDN values are flags, so they use
//  equality tests instead of bit tests.  So whenever we add a new flag,
//  these people say "Huh?  I don't understand."  So we have to keep
//  retrying with fewer and fewer flags until finally they get something
//  they like.  SHGDN_FORPARSING has the opposite problem:  Some people
//  demand that the flag be set.

//
//  This array lists the things we try to do to get the uFlags into a state
//  that the app will eventually like.
//
//  We walk through the list and do this:
//
//      uFlags = (uFlags & AND) | OR
//
//  Most of the time, the entry will turn off a bit in the uFlags, but
//  SHGDN_FORPARSING is weird and it's a flag you actually want to turn on
//  instead of off.
//

typedef struct GDNCOMPAT {
    DWORD   dwAnd;
    DWORD   dwOr;
    DWORD   dwAllow;                    // flag to allow this rule to fire
} GDNCOMPAT;

#define GDNADDFLAG(f)   ~0, f           // Add a flag to uFlags
#define GDNDELFLAG(f)   ~f, 0           // Remove a flag from uFlags

#define ISHGDN2_CANREMOVEOTHERFLAGS 0x80000000

GDNCOMPAT c_gdnc[] = {
  { GDNDELFLAG(SHGDN_FOREDITING),       ISHGDN2_CANREMOVEOTHERFLAGS },  // Some apps don't like this flag
  { GDNDELFLAG(SHGDN_FORADDRESSBAR),    ISHGDN2_CANREMOVEOTHERFLAGS },  // Some apps don't like this flag
  { GDNADDFLAG(SHGDN_FORPARSING),       ISHGDN2_CANREMOVEOTHERFLAGS },  // Some apps require this flag
  { GDNDELFLAG(SHGDN_FORPARSING),       ISHGDN2_CANREMOVEFORPARSING },  // And others don't like it
  { GDNDELFLAG(SHGDN_INFOLDER),         ISHGDN2_CANREMOVEOTHERFLAGS },  // Desperation - remove this flag too
};

//
//  These are the return values we tend to get back when people see
//  flags they don't like.
//
BOOL __inline IsBogusHRESULT(HRESULT hres)
{
    return  hres == E_FAIL ||
            hres == E_INVALIDARG ||
            hres == E_NOTIMPL;
}

//
//  dwFlags2 controls how aggressively we try to find a working display name.
//
//  ISHGDN2_CANREMOVEFORPARSING
//      Normally, we do not turn off the SHGDN_FORPARSING flag because
//      if a caller asks for the parse name, it probably really wants the
//      parse name.  This flag indicates that we are allowed to turn off
//      SHGDN_FORPARSING if we think it'll help.
//

STDAPI IShellFolder_GetDisplayNameOf(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName,
    DWORD dwFlags2)
{
    HRESULT hres;

    hres = psf->GetDisplayNameOf(pidl, uFlags, lpName);
    if (!IsBogusHRESULT(hres))
        return hres;

    int i;
    DWORD uFlagsOrig = uFlags;

    //
    //  If the caller didn't pass SHGDN_FORPARSING, then clearly it's
    //  safe to remove it.
    //
    if (!(uFlags & SHGDN_FORPARSING)) {
        dwFlags2 |= ISHGDN2_CANREMOVEFORPARSING;
    }

    // We can always remove other flags.
    dwFlags2 |= ISHGDN2_CANREMOVEOTHERFLAGS;

    for (i = 0; i < ARRAYSIZE(c_gdnc); i++)
    {
        if (c_gdnc[i].dwAllow & dwFlags2)
        {
            DWORD uFlagsNew = (uFlags & c_gdnc[i].dwAnd) | c_gdnc[i].dwOr;
            if (uFlagsNew != uFlags)
            {
                uFlags = uFlagsNew;
                hres = psf->GetDisplayNameOf(pidl, uFlags, lpName);
                if (!IsBogusHRESULT(hres))
                    return hres;
            }
        }
    }

    // By now, we should've removed all the flags, except perhaps for
    // SHGDN_FORPARSING.
    if (dwFlags2 & ISHGDN2_CANREMOVEFORPARSING) {
        ASSERT(uFlags == SHGDN_NORMAL);
    } else {
        ASSERT(uFlags == SHGDN_NORMAL || uFlags == SHGDN_FORPARSING);
    }

    return hres;
}

//----------------------------------------------------------------------------
//
//  The documentation on IShellFolder::ParseDisplayName wasn't clear that
//  pchEaten and pdwAttributes can be NULL, and some people dereference
//  them unconditionally.  So make sure it's safe to dereference them.
//
//  It is also popular to forget to set *ppidl=NULL on failure, so we null
//  it out here.
//
//  We request no attributes, so people who aren't buggy won't go out of
//  their way trying to retrieve expensive attributes.
//

STDAPI IShellFolder_ParseDisplayName(
    IShellFolder *psf,
    HWND hwnd,
    LPBC pbc,
    LPOLESTR pszDisplayName,
    ULONG *pchEaten,
    LPITEMIDLIST *ppidl,
    ULONG *pdwAttributes)
{
    ULONG cchEaten;
    ULONG dwAttributes = 0;

    if (pchEaten == NULL)
        pchEaten = &cchEaten;
    if (pdwAttributes == NULL)
        pdwAttributes = &dwAttributes;

    if (ppidl)
        *ppidl = NULL;

    return psf->ParseDisplayName(hwnd, pbc, pszDisplayName, pchEaten, ppidl, pdwAttributes);
}

STDAPI IShellFolder_CompareIDs(IShellFolder *psf, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // We have new bits here...
    if (lParam & ~SHCIDS_COLUMNMASK)
    {
        IShellFolder2* psf2;
        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            psf2->Release();
        }
        else
        {
            // But we can't send them to legacy IShellFolder implementations
            lParam &= SHCIDS_COLUMNMASK;
        }
    }

    return psf->CompareIDs(lParam, pidl1, pidl2);
}


//----------------------------------------------------------------------------
//
//  IShellFolder::EnumObjects
//
CLSID CLSID_ZipFolder =
{ 0xe88dcce0, 0xb7b3, 0x11d1, { 0xa9, 0xf0, 0x00, 0xaa, 0x00, 0x60, 0xfa, 0x31 } };

STDAPI IShellFolder_EnumObjects(
    IShellFolder *psf,
    HWND hwnd,
    DWORD grfFlags,
    IEnumIDList **ppenumIDList)
{
    if (hwnd == NULL || hwnd == GetDesktopWindow())
    {
        //  The first parameter to EnumObjects is supposed to be the window
        //  on which to parent UI, or NULL for no UI, or GetDesktopWindow()
        //  for "parentless UI".
        //
        //  Win98 Plus! Zip Folders takes the hwnd and uses it as the basis
        //  for a search for a rebar window, since they (for some bizarre
        //  reason) want to hide the address bar when an enumeration starts.
        //
        //  We used to pass NULL or GetDesktopWindow(), but this caused zip
        //  folders to start searching from the desktop, which means that
        //  it eventually finds the taskbar and tries to send it
        //  inter-process rebar messages, which causes the shell to fault.
        //
        //  When we discover we are about to pass NULL to Zip Folders,
        //  we change it to HWND_BOTTOM.  This is not a valid window handle,
        //  which causes Zip Folders' search to bail out quickly and it ends
        //  up not killing anyone.
        //

        CLSID clsid;
        if (SUCCEEDED(IUnknown_GetClassID(psf, &clsid)) &&
            IsEqualCLSID(clsid, CLSID_ZipFolder))
            hwnd = HWND_BOTTOM;
    }

    return psf->EnumObjects(hwnd, grfFlags, ppenumIDList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\mirror.c ===
/****************************** Module*Header *****************************\
* Module Name: mirror.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines used to Right-To-Left mirror an icon on the fly so that         *
* it would be displayed normal on a RTL mirrored localized OS. This is     *
* mainly a concern for 3rd party Apps.                                     *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "priv.h"




/***************************************************************************\
* MirrorIcon
*
* Mirror an Icon , given an Icon handle so that when these icons are displayed
* on a Mirrored DC, they end would be displayed normal.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
STDAPI_(BOOL) SHMirrorIcon(HICON* phiconSmall, HICON* phiconLarge)
{
    HDC      hdcScreen;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    HICON    hicon[2] = {NULL,NULL};
    HICON    hiconNew[2] = {NULL,NULL};
    ICONINFO ii ;
    int      i;

    if (!g_bMirroredOS)
    {
        return FALSE;
    }

    //
    // Synchronize access to global DCs now!
    // Allocate DCs if we didn't so far.
    //  
    ENTERCRITICAL;
    if (!g_hdc && !g_hdcMask)
    {
        g_hdc = CreateCompatibleDC(NULL);
        if (g_hdc)
        {
            g_hdcMask = CreateCompatibleDC(NULL);

            if( g_hdcMask )
            {
                SET_DC_RTL_MIRRORED(g_hdc);
                SET_DC_RTL_MIRRORED(g_hdcMask);
            }
            else
            {
                DeleteDC( g_hdc );
                g_hdc = NULL;
            }
        }
    }

    if (phiconSmall)
        hicon[0] = *phiconSmall;

    if (phiconLarge)
        hicon[1] = *phiconLarge;

    //
    // Acquire screen DC
    //
    hdcScreen = GetDC(NULL);

    if (g_hdc && g_hdcMask && hdcScreen) 
    {
        for( i=0 ; i<(sizeof(hicon)/sizeof(hicon[0])) ; i++ )
        {
            if( hicon[i] )
            {
                if( GetIconInfo(hicon[i], &ii) &&
                    GetObjectW(ii.hbmColor, sizeof(bm), &bm))
                {

                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(g_hdc, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(g_hdcMask, hbmMask);
        
                    DrawIconEx(g_hdc, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(g_hdcMask, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(g_hdc, hbmOld);
                    SelectObject(g_hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hiconNew[i] = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }
    }

    ReleaseDC(NULL, hdcScreen);

    //
    // Now we can reuse the global DCs
    //
    LEAVECRITICAL;

    //
    // Update icons if needed, and destroy old ones!
    //
    if (hicon[0] && hiconNew[0])
    {
        *phiconSmall = hiconNew[0];
        DestroyIcon(hicon[0]);
    }

    if (hicon[1] && hiconNew[1])
    {
        *phiconLarge = hiconNew[1];

        //
        // Don't delete twice
        //
        if (hicon[1] != hicon[0]) 
            DestroyIcon(hicon[1]);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\mime.cpp ===
//
// Mime stuff used by shell32/shdocvw/shdoc401
//
#include "priv.h"


#define TF_MIME 0

/*----------------------------------------------------------
Purpose: Generates the HKEY_CLASSES_ROOT subkey for a MIME
         type

Returns: 
Cond:    --
*/
STDAPI_(BOOL) GetMIMETypeSubKeyA(LPCSTR pcszMIMEType, LPSTR pszSubKeyBuf, UINT cchBuf)
{
    BOOL bResult;

    bResult = ((UINT)lstrlenA(TEXT("MIME\\Database\\Content Type\\")) +
               (UINT)lstrlenA(pcszMIMEType) < cchBuf);

    if (bResult)
    {
        StringCchPrintfA(pszSubKeyBuf, cchBuf, TEXT("MIME\\Database\\Content Type\\%s"), pcszMIMEType);
    }
    else
    {
        if (cchBuf > 0)
           *pszSubKeyBuf = '\0';

        TraceMsg(TF_WARNING, "GetMIMETypeSubKey(): Given sub key buffer of length %u is too short to hold sub key for MIME type %hs.",
                     cchBuf, pcszMIMEType);
    }

    ASSERT(! cchBuf ||
           (IS_VALID_STRING_PTRA(pszSubKeyBuf, -1) &&
            (UINT)lstrlenA(pszSubKeyBuf) < cchBuf));
    ASSERT(bResult ||
           ! cchBuf ||
           ! *pszSubKeyBuf);

    return(bResult);
}


STDAPI_(BOOL) GetMIMETypeSubKeyW(LPCWSTR pszMIMEType, LPWSTR pszBuf, UINT cchBuf)
{
    BOOL bRet;
    char szMIMEType[MAX_PATH];
    char sz[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pszMIMEType, -1));

    WideCharToMultiByte(CP_ACP, 0, pszMIMEType, -1, szMIMEType, SIZECHARS(szMIMEType), NULL, NULL);
    bRet = GetMIMETypeSubKeyA(szMIMEType, sz, SIZECHARS(sz));

    if (bRet)
    {
        ASSERT(cchBuf <= SIZECHARS(sz));
        MultiByteToWideChar(CP_ACP, 0, sz, -1, pszBuf, cchBuf);
    }
    return bRet;
}    


/*
** RegisterExtensionForMIMEType()
**
** Under HKEY_CLASSES_ROOT\MIME\Database\Content Type\mime/type, add
** Content Type = mime/type and Extension = .ext.
**
*/
STDAPI_(BOOL) RegisterExtensionForMIMETypeA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType)
{
    BOOL bResult;
    CHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRA(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszMIMEContentType, -1));

    ASSERT(IsValidExtensionA(pcszExtension));

    bResult = GetMIMETypeSubKeyA(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                SIZECHARS(szMIMEContentTypeSubKey));

    if (bResult)
    {
        /* (+ 1) for null terminator. */
        bResult = (NO_ERROR == SHSetValueA(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                          "Extension", REG_SZ, pcszExtension,
                                          CbFromCchA(lstrlenA(pcszExtension) + 1)));
    }

    return(bResult);
}


STDAPI_(BOOL) RegisterExtensionForMIMETypeW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType)
{
    BOOL bResult;
    WCHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszMIMEContentType, -1));

    ASSERT(IsValidExtensionW(pcszExtension));

    bResult = GetMIMETypeSubKeyW(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                SIZECHARS(szMIMEContentTypeSubKey));

    if (bResult)
    {
        /* (+ 1) for null terminator. */
        bResult = (NO_ERROR == SHSetValueW(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                          TEXTW("Extension"), REG_SZ, pcszExtension,
                                          (lstrlenW(pcszExtension) + 1)*sizeof(WCHAR)));
    }

    return(bResult);
}


/*
** UnregisterExtensionForMIMEType()
**
** Deletes Extension under
** HKEY_CLASSES_ROOT\MIME\Database\Content Type\mime/type.  If no other values
** or sub keys are left, deletes
** HKEY_CLASSES_ROOT\MIME\Database\Content Type\mime/type.
**
** Side Effects:  May also delete MIME key.
*/
STDAPI_(BOOL) UnregisterExtensionForMIMETypeA(LPCSTR pcszMIMEContentType)
{
    BOOL bResult;
    CHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRA(pcszMIMEContentType, -1));

    bResult = (GetMIMETypeSubKeyA(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                 SIZECHARS(szMIMEContentTypeSubKey)) &&
               NO_ERROR == SHDeleteValueA(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                         "Extension") &&
               NO_ERROR == SHDeleteEmptyKeyA(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey));

    return(bResult);
}


STDAPI_(BOOL) UnregisterExtensionForMIMETypeW(LPCWSTR pcszMIMEContentType)
{
    BOOL bResult;
    WCHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pcszMIMEContentType, -1));

    bResult = (GetMIMETypeSubKeyW(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                 SIZECHARS(szMIMEContentTypeSubKey)) &&
               NO_ERROR == SHDeleteValueW(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                         TEXTW("Extension")) &&
               NO_ERROR == SHDeleteEmptyKeyW(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey));

    return(bResult);
}


/*
** UnregisterMIMETypeForExtension()
**
** Deletes Content Type under HKEY_CLASSES_ROOT\.ext.
**
** Side Effects:  none
*/
STDAPI_(BOOL) UnregisterMIMETypeForExtensionA(LPCSTR pcszExtension)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszExtension, -1));
    ASSERT(IsValidExtensionA(pcszExtension));

    return NO_ERROR == SHDeleteValueA(HKEY_CLASSES_ROOT, pcszExtension, "Content Type");
}


STDAPI_(BOOL) UnregisterMIMETypeForExtensionW(LPCWSTR pcszExtension)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszExtension, -1));
    ASSERT(IsValidExtensionW(pcszExtension));

    return NO_ERROR == SHDeleteValueW(HKEY_CLASSES_ROOT, pcszExtension, TEXTW("Content Type"));
}


/*
** RegisterMIMETypeForExtension()
**
** Under HKEY_CLASSES_ROOT\.ext, add Content Type = mime/type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) RegisterMIMETypeForExtensionA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszMIMEContentType, -1));

    ASSERT(IsValidExtensionA(pcszExtension));

    /* (+ 1) for null terminator. */
    return NO_ERROR == SHSetValueA(HKEY_CLASSES_ROOT, pcszExtension, "Content Type", 
                                  REG_SZ, pcszMIMEContentType,
                                  CbFromCchA(lstrlenA(pcszMIMEContentType) + 1));
}


STDAPI_(BOOL) RegisterMIMETypeForExtensionW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszMIMEContentType, -1));
    ASSERT(IsValidExtensionW(pcszExtension));

    /* (+ 1) for null terminator. */
    return NO_ERROR == SHSetValueW(HKEY_CLASSES_ROOT, pcszExtension, TEXTW("Content Type"), 
                                  REG_SZ, pcszMIMEContentType,
                                  (lstrlenW(pcszMIMEContentType) + 1) * sizeof(WCHAR));
}

/*
** GetMIMEValue()
**
** Retrieves the data for a value of a MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) GetMIMEValueA(LPCSTR pcszMIMEType, LPCSTR pcszValue,
                              PDWORD pdwValueType, PBYTE pbyteValueBuf,
                              PDWORD pdwcbValueBufLen)
{
   BOOL bResult;
   CHAR szMIMETypeSubKey[MAX_PATH];

   ASSERT(IS_VALID_STRING_PTRA(pcszMIMEType, -1));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTRA(pcszValue, -1));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   bResult = (GetMIMETypeSubKeyA(pcszMIMEType, szMIMETypeSubKey,SIZECHARS(szMIMETypeSubKey)) &&
              NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, szMIMETypeSubKey,
                                      pcszValue, pdwValueType, pbyteValueBuf,
                                      pdwcbValueBufLen));

   return(bResult);
}

STDAPI_(BOOL) GetMIMEValueW(LPCWSTR pcszMIMEType, LPCWSTR pcszValue,
                              PDWORD pdwValueType, PBYTE pbyteValueBuf,
                              PDWORD pdwcbValueBufLen)
{
   BOOL bResult;
   WCHAR szMIMETypeSubKey[MAX_PATH];

   ASSERT(IS_VALID_STRING_PTRW(pcszMIMEType, -1));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTRW(pcszValue, -1));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   bResult = (GetMIMETypeSubKeyW(pcszMIMEType, szMIMETypeSubKey,SIZECHARS(szMIMETypeSubKey)) &&
              NO_ERROR == SHGetValueW(HKEY_CLASSES_ROOT, szMIMETypeSubKey,
                                      pcszValue, pdwValueType, pbyteValueBuf,
                                      pdwcbValueBufLen));

   return(bResult);
}

/*
** GetMIMETypeStringValue()
**
** Retrieves the string for a registered MIME type's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) GetMIMETypeStringValueA(LPCSTR pcszMIMEType, LPCSTR pcszValue,
                                         LPSTR pszBuf, UINT ucBufLen)
{
   BOOL bResult;
   DWORD dwValueType;
   DWORD dwcbLen = CbFromCchA(ucBufLen);

   /* GetMIMEValue() will verify parameters. */

   bResult = (GetMIMEValueA(pcszMIMEType, pcszValue, &dwValueType, (PBYTE)pszBuf, &dwcbLen) &&
              dwValueType == REG_SZ);

   if (! bResult)
   {
      if (ucBufLen > 0)
         *pszBuf = '\0';
   }

   ASSERT(! ucBufLen || IS_VALID_STRING_PTRA(pszBuf, -1));

   return(bResult);
}

STDAPI_(BOOL) GetMIMETypeStringValueW(LPCWSTR pcszMIMEType, LPCWSTR pcszValue,
                                         LPWSTR pszBuf, UINT ucBufLen)
{
   BOOL bResult;
   DWORD dwValueType;
   DWORD dwcbLen = CbFromCchW(ucBufLen);

   /* GetMIMEValue() will verify parameters. */

   bResult = (GetMIMEValueW(pcszMIMEType, pcszValue, &dwValueType, (PBYTE)pszBuf, &dwcbLen) &&
              dwValueType == REG_SZ);

   if (! bResult)
   {
      if (ucBufLen > 0)
         *pszBuf = '\0';
   }

   ASSERT(! ucBufLen || IS_VALID_STRING_PTRW(pszBuf, -1));

   return(bResult);
}


/*
** MIME_GetExtension()
**
** Determines the file name extension to be used when writing a file of a MIME
** type to the file system.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) MIME_GetExtensionA(LPCSTR pcszMIMEType, LPSTR pszExtensionBuf, UINT ucExtensionBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRING_PTRA(pcszMIMEType, -1));
   ASSERT(IS_VALID_WRITE_BUFFER(pszExtensionBuf, CHAR, ucExtensionBufLen));

   if (EVAL(ucExtensionBufLen > 2))
   {
      /* Leave room for possible leading period. */

      if (GetMIMETypeStringValueA(pcszMIMEType, "Extension", pszExtensionBuf + 1, ucExtensionBufLen - 1))
      {
         if (pszExtensionBuf[1])
         {
            /* Prepend period if necessary. */

            if (pszExtensionBuf[1] == TEXT('.'))
               /* (+ 1) for null terminator. */
               MoveMemory(pszExtensionBuf, pszExtensionBuf + 1,
                          CbFromCchA(lstrlenA(pszExtensionBuf + 1) + 1));
            else
               pszExtensionBuf[0] = TEXT('.');

            bResult = TRUE;
         }
      }
   }

   if (! bResult)
   {
      if (ucExtensionBufLen > 0)
         *pszExtensionBuf = '\0';
   }

   if (bResult)
      TraceMsgA(TF_MIME, "MIME_GetExtension(): Extension %s registered as default extension for MIME type %s.",
                 pszExtensionBuf, pcszMIMEType);

   ASSERT((bResult &&
           IsValidExtensionA(pszExtensionBuf)) ||
          (! bResult &&
           (! ucExtensionBufLen ||
            ! *pszExtensionBuf)));
   ASSERT(! ucExtensionBufLen ||
          (UINT)lstrlenA(pszExtensionBuf) < ucExtensionBufLen);

   return(bResult);
}


STDAPI_(BOOL) MIME_GetExtensionW(LPCWSTR pcszMIMEType, LPWSTR pszExtensionBuf, UINT ucExtensionBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRING_PTRW(pcszMIMEType, -1));
   ASSERT(IS_VALID_WRITE_BUFFER(pszExtensionBuf, CHAR, ucExtensionBufLen));

   if (EVAL(ucExtensionBufLen > 2))
   {
      /* Leave room for possible leading period. */

      if (GetMIMETypeStringValueW(pcszMIMEType, TEXTW("Extension"), pszExtensionBuf + 1, ucExtensionBufLen - 1))
      {
         if (pszExtensionBuf[1])
         {
            /* Prepend period if necessary. */

            if (pszExtensionBuf[1] == TEXT('.'))
               /* (+ 1) for null terminator. */
               MoveMemory(pszExtensionBuf, pszExtensionBuf + 1,
                          CbFromCchW(lstrlenW(pszExtensionBuf + 1) + 1));
            else
               pszExtensionBuf[0] = TEXT('.');

            bResult = TRUE;
         }
      }
   }

   if (! bResult)
   {
      if (ucExtensionBufLen > 0)
         *pszExtensionBuf = '\0';
   }

   if (bResult)
      TraceMsgW(TF_MIME, "MIME_GetExtension(): Extension %s registered as default extension for MIME type %s.",
                 pszExtensionBuf, pcszMIMEType);

   ASSERT((bResult &&
           IsValidExtensionW(pszExtensionBuf)) ||
          (! bResult &&
           (! ucExtensionBufLen ||
            ! *pszExtensionBuf)));
   ASSERT(! ucExtensionBufLen ||
          (UINT)lstrlenW(pszExtensionBuf) < ucExtensionBufLen);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\mlui.h ===
// registered window messages global variables, defined in mlui.cpp
extern UINT g_ML_GETTEXT,
            g_ML_GETTEXTLENGTH,
            g_ML_SETTEXT;

extern UINT g_ML_LB_ADDSTRING,
            g_ML_LB_FINDSTRING,
            g_ML_LB_FINDSTRINGEXACT,
            g_ML_LB_GETTEXT,
            g_ML_LB_GETTEXTLEN,
            g_ML_LB_INSERTSTRING,
            g_ML_LB_SELECTSTRING;

extern UINT g_ML_CB_ADDSTRING,
            g_ML_CB_FINDSTRING,
            g_ML_CB_FINDSTRINGEXACT,
            g_ML_CB_GETLBTEXT,
            g_ML_CB_GETLBTEXTLEN,
            g_ML_CB_INSERTSTRING,
            g_ML_CB_SELECTSTRING;


BOOL fDoMungeUI(HINSTANCE hinst);
INT_PTR MLDialogBoxIndirectParamI(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
INT_PTR MLDialogBoxParamI(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
HWND MLCreateDialogIndirectParamI(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
HWND MLCreateDialogParamI(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
BOOL MLIsEnabled(HWND hwnd);
int MLGetControlTextI(HWND hWnd, LPCWSTR lpString, int nMaxCount);
BOOL MLSetControlTextI(HWND hWnd, LPCWSTR lpString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\nullstm.h ===
#ifndef UNIX
IStream* SHConstNullStream();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\native.cpp ===
// Contains code that needs to be dual compiled, once for ansi and once for unicode
#include "priv.h"
#include <memt.h>
#include "userenv.h"

BOOL _PathAppend(LPCTSTR pszBase, LPCTSTR pszAppend, LPTSTR pszOut, DWORD cchOut)
{
    BOOL bRet = FALSE;

    if (SUCCEEDED(StringCchCopy(pszOut, cchOut, pszBase))   &&
        SUCCEEDED(StringCchCat(pszOut, cchOut, TEXT("\\"))) &&
        SUCCEEDED(StringCchCat(pszOut, cchOut, pszAppend)))
    {
        bRet = TRUE;
    }
    
    return bRet;
}

LWSTDAPI AssocMakeFileExtsToApplication(ASSOCMAKEF flags, LPCTSTR pszExt, LPCTSTR pszApplication)
{
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT _AllocValueString(HKEY hkey, LPCTSTR pszKey, LPCTSTR pszVal, LPTSTR *ppsz)
{
    DWORD cb, err;
    err = SHGetValue(hkey, pszKey, pszVal, NULL, NULL, &cb);

    ASSERT(ppsz);
    *ppsz = NULL;

    if (NOERROR == err)
    {
        LPTSTR psz = (LPTSTR) LocalAlloc(LPTR, cb);

        if (psz)
        {
            err = SHGetValue(hkey, pszKey, pszVal, NULL, (LPVOID)psz, &cb);

            if (NOERROR == err)
                *ppsz = psz;
            else
                LocalFree(psz);
        }
        else
            err = ERROR_OUTOFMEMORY;
    }

    return HRESULT_FROM_WIN32(err);
}


// <Swipped from the NT5 version of Shell32>
#define SZ_REGKEY_FILEASSOCIATION TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileAssociation")

LWSTDAPI_(void) PrettifyFileDescription(LPTSTR pszDesc, LPCTSTR pszCutList)
{
    LPTSTR pszCutListReg;

    if (!pszDesc || !*pszDesc)
        return;

    // get the Cut list from registry
    //  this is MULTI_SZ
    if (S_OK == _AllocValueString(HKEY_LOCAL_MACHINE, SZ_REGKEY_FILEASSOCIATION, TEXT("CutList"), &pszCutListReg))
    {
        pszCutList = pszCutListReg;
    }

    if (pszCutList)
    {

        // cut strings in cut list from file description
        for (LPCTSTR pszCut = pszCutList; *pszCut; pszCut = pszCut + lstrlen(pszCut) + 1)
        {
            LPTSTR pch = StrRStrI(pszDesc, NULL, pszCut);

            // cut the exact substring from the end of file description
            if (pch && !*(pch + lstrlen(pszCut)))
            {
                *pch = '\0';

                // remove trailing spaces
                for (--pch; (pch >= pszDesc) && (TEXT(' ') == *pch); pch--)
                    *pch = 0;

                break;
            }
        }

        if (pszCutListReg)
            LocalFree(pszCutListReg);
    }
}

/*
    <Swipped from the NT5 version of Shell32>

    GetFileDescription retrieves the friendly name from a file's verion rsource.
    The first language we try will be the first item in the
    "\VarFileInfo\Translations" section;  if there's nothing there,
    we try the one coded into the IDS_VN_FILEVERSIONKEY resource string.
    If we can't even load that, we just use English (040904E4).  We
    also try English with a null codepage (04090000) since many apps
    were stamped according to an old spec which specified this as
    the required language instead of 040904E4.

    If there is no FileDescription in version resource, return the file name.

    Parameters:
        LPCTSTR pszPath: full path of the file
        LPTSTR pszDesc: pointer to the buffer to receive friendly name. If NULL,
                        *pcchDesc will be set to the length of friendly name in
                        characters, including ending NULL, on successful return.
        UINT *pcchDesc: length of the buffer in characters. On successful return,
                        it contains number of characters copied to the buffer,
                        including ending NULL.

    Return:
        TRUE on success, and FALSE otherwise
*/
BOOL WINAPI SHGetFileDescription(LPCTSTR pszPath, LPCTSTR pszVersionKeyIn, LPCTSTR pszCutListIn, LPTSTR pszDesc, UINT *pcchDesc)
{
    UINT cchValue = 0;
    TCHAR szPath[MAX_PATH], *pszValue = NULL;
    DWORD dwAttribs;

    DWORD dwHandle;                 /* version subsystem handle */
    DWORD dwVersionSize;            /* size of the version data */
    LPTSTR lpVersionBuffer = NULL;  /* pointer to version data */
    TCHAR szVersionKey[60];         /* big enough for anything we need */

    struct _VERXLATE
    {
        WORD wLanguage;
        WORD wCodePage;
    } *lpXlate;                     /* ptr to translations data */

    ASSERT(pszPath && *pszPath && pcchDesc);

    if (!PathFileExistsAndAttributes(pszPath, &dwAttribs))
    {
        return FALSE;
    }

    // copy the path to the dest dir
    StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));

    if ((dwAttribs & FILE_ATTRIBUTE_DIRECTORY)  ||
        PathIsUNCServer(pszPath)                ||
        PathIsUNCServerShare(pszPath))
    {
        // bail in the \\server, \\server\share, and directory case or else GetFileVersionInfo() will try
        // to do a LoadLibraryEx() on the path (which will fail, but not before we seach the entire include
        // path which can take a long time)
        goto Exit;
    }


    dwVersionSize = GetFileVersionInfoSize(szPath, &dwHandle);
    if (dwVersionSize == 0L)
        goto Exit;                 /* no version info */

    lpVersionBuffer = (LPTSTR)LocalAlloc(LPTR, dwVersionSize);
    if (lpVersionBuffer == NULL)
        goto Exit;

    if (!GetFileVersionInfo(szPath, dwHandle, dwVersionSize, lpVersionBuffer))
        goto Exit;

    // Try same language as the caller
    if (pszVersionKeyIn)
    {
        StrCpyN(szVersionKey, pszVersionKeyIn, ARRAYSIZE(szVersionKey));

        if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
        {
            goto Exit;
        }
    }

    // Try first language this supports
    // Look for translations
    if (VerQueryValue(lpVersionBuffer, TEXT("\\VarFileInfo\\Translation"),
                      (void **)&lpXlate, &cchValue)
        && cchValue)
    {
        wnsprintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\%04X%04X\\FileDescription"),
                 lpXlate[0].wLanguage, lpXlate[0].wCodePage);
        if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
            goto Exit;

    }

#ifdef UNICODE
    if (SUCCEEDED(StringCchCopy(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\040904B0\\FileDescription"))) &&
        VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
    {
        goto Exit;
    }
#endif

    // try English
    if (SUCCEEDED(StringCchCopy(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\040904E4\\FileDescription"))) &&
        VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
    {
        goto Exit;
    }

    // try English, null codepage
    if (SUCCEEDED(StringCchCopy(szVersionKey,  ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\04090000\\FileDescription"))) &&
        VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
    {
        goto Exit;
    }

Exit:
    if (!pszValue || !*pszValue)
    {
        // Could not find FileVersion info in a reasonable format, return file name
        PathRemoveExtension(szPath);
        pszValue = PathFindFileName(szPath);
        cchValue = lstrlen(pszValue);
    }

    PrettifyFileDescription(pszValue, pszCutListIn);
    cchValue = lstrlen(pszValue) + 1;

    if (!pszDesc)   // only want to know the length of the friendly name
        *pcchDesc = cchValue;
    else
    {
        *pcchDesc = min(*pcchDesc, cchValue);
        StrCpyN(pszDesc, pszValue, *pcchDesc);
    }

    if (lpVersionBuffer)
        LocalFree(lpVersionBuffer);

    return TRUE;
}

// Convert LPTSTR to LPSTR and return TRUE if the LPSTR can
// be converted back to LPTSTR without unacceptible data loss
//
BOOL DoesStringRoundTrip(LPCTSTR pwszIn, LPSTR pszOut, UINT cchOut)
{
#ifdef UNICODE
    // On NT5 we have to be more stringent since you can switch UI
    // languages on the fly, thereby breaking this constant codepage
    // assumption inherent in the downlevel implementations.
    //
    // we have to support the function being called with a null pszOut
    // just to determine if pwszIn will roundtrip
    //
    {
        LPCTSTR pIn = pwszIn;
        LPSTR pOut = pszOut;
        UINT cch = cchOut;

        while (*pIn)
        {
            if (*pIn > ((TCHAR)127))
            {
                if (cchOut) // caller has provided a buffer
                {
#ifdef DEBUG
                    SHUnicodeToAnsiCP(CP_ACPNOVALIDATE, pwszIn, pszOut, cchOut);
#else                
                    SHUnicodeToAnsi(pwszIn, pszOut, cchOut);                                    
#endif
                }
                return FALSE;
            }

            if (cch) // we have a buffer and it still has space
            {
                *pOut++ = (char)*pIn;
                if (!--cch)
                {
                    break; // out buffer filled, leave.  
                }                                        
            }

            pIn++;
                        
        }

        // Null terminate the out buffer
        if (cch)
        {
            *pOut = '\0';
        }
        else if (cchOut)
        {
            *(pOut-1) = '\0';
        }

        // Everything was low ascii, no dbcs worries and it will always round-trip
        return TRUE;
    }

#else

    StrCpyN(pszOut, pwszIn, cchOut);
    return TRUE;
#endif
}

DWORD _ExpandRegString(PTSTR pszData, DWORD cchData, DWORD *pcchSize)
{
    DWORD err = ERROR_OUTOFMEMORY;
    PTSTR psz = StrDup(pszData);
    if (psz)
    {
        //  now we will try to expand back into the target buffer
        //  NOTE we deliberately dont use SHExpandEnvironmentStrings
        //  since it will not give us the size we need
        //  we have to use 
#ifdef UNICODE        
        *pcchSize = ExpandEnvironmentStringsW(psz, pszData, cchData);
#else        
        *pcchSize = ExpandEnvironmentStringsA(psz, pszData, cchData);
#endif        
        
        if (*pcchSize > 0)
        {
            if (*pcchSize <=  cchData) 
            {
                err = NO_ERROR;
            }
            else
            {
                //  pcchSize returns the needed size
                err = ERROR_MORE_DATA;
            }
        }
        else
            err = GetLastError();

        LocalFree(psz);
    }
    
    return err;
}
                

#ifdef UNICODE
#define NullTerminateRegSzString NullTerminateRegSzStringW
#else
#define NullTerminateRegSzString NullTerminateRegSzStringA
#endif

STDAPI_(LONG)
NullTerminateRegSzString(
    IN OUT  void *  pvData,         // data bytes returned from RegQueryValueEx()
    IN OUT  DWORD * pcbData,        // data size returned from RegQueryValueEx()
    IN      DWORD   cbDataBuffer,   // data buffer size (actual allocated size of pvData)
    IN      LONG    lr)             // long result returned from RegQueryValueEx()
{
    ASSERT(pcbData != NULL); // Sanity check.

    if (lr == ERROR_SUCCESS && pvData != NULL)
    {
        DWORD cchDataBuffer = cbDataBuffer / sizeof(TCHAR); // cchDataBuffer is the actual allocated size of pvData in TCHARs
        DWORD cchData = *pcbData / sizeof(TCHAR);           // cchData is the length of the string written into pvData in TCHARs (including the null terminator)
        PTSTR pszData = (PTSTR)pvData;
        DWORD cNullsMissing;

        ASSERT(cchDataBuffer >= cchData); // Sanity check.

        //
        // [1] string and size request with sufficient original buffer
        //     (must ensure returned string and returned size include
        //      null terminator)
        //

        cNullsMissing = cchData >= 1 && pszData[cchData-1] == TEXT('\0') ? 0 : 1;

        if (cNullsMissing > 0)
        {
            if (cchData + cNullsMissing <= cchDataBuffer)
            {
                pszData[cchData] = TEXT('\0');
            }
            else
            {
                lr = ERROR_MORE_DATA;
            }
        }

        *pcbData = (cchData + cNullsMissing) * sizeof(TCHAR);
    }
    else if ((lr == ERROR_SUCCESS && pvData == NULL) || lr == ERROR_MORE_DATA)
    {
        //
        // [2] size only request or string and size request with insufficient
        //     original buffer (must ensure returned size includes null
        //     terminator)
        //

        *pcbData += sizeof(TCHAR); // *** APPROXIMATION FOR PERF -- size is
                                   // therefore not guaranteed to be exact,
                                   // merely sufficient
    }

    return lr;
}

#ifdef UNICODE
#define NullTerminateRegExpandSzString NullTerminateRegExpandSzStringW
#else
#define NullTerminateRegExpandSzString NullTerminateRegExpandSzStringA
#endif

STDAPI_(LONG)
NullTerminateRegExpandSzString(
    IN      HKEY    hkey,
    IN      PCTSTR  pszValue,
    IN      DWORD * pdwType,
    IN OUT  void *  pvData,         // data bytes returned from RegQueryValueEx()
    IN OUT  DWORD * pcbData,        // data size returned from RegQueryValueEx()
    IN      DWORD   cbDataBuffer,   // data buffer size (actual allocated size of pvData)
    IN      LONG    lr)             // long result returned from RegQueryValueEx()
{
    ASSERT(pdwType != NULL); // Sanity check.
    ASSERT(pcbData != NULL); // Sanity check.

    DWORD cbExpandDataBuffer;
    DWORD cbExpandData;
    void *pvExpandData;

    if (lr == ERROR_SUCCESS && pvData != NULL)
    {
        lr = NullTerminateRegSzString(pvData, pcbData, cbDataBuffer, lr);
        if (lr == ERROR_SUCCESS)
        {
            cbExpandDataBuffer = cbDataBuffer;
            cbExpandData = *pcbData;
            pvExpandData = pvData;
        }
        else
        {
            cbExpandDataBuffer = 0;
            cbExpandData = lr == ERROR_MORE_DATA ? *pcbData : 0;
            pvExpandData = pvData;
        }
    }
    else
    {
        cbExpandDataBuffer = 0;
        cbExpandData = (lr == ERROR_SUCCESS || lr == ERROR_MORE_DATA) ? *pcbData + sizeof(TCHAR) : 0;
        pvExpandData = NULL;
    }

    ASSERT(cbExpandData == 0 || cbExpandData >= sizeof(TCHAR)); // Sanity check.

    if (cbExpandData && !cbExpandDataBuffer)
    {
        DWORD cbTempBuffer = cbExpandData;
        DWORD cbTemp       = cbExpandData;
        void *pvTemp       = LocalAlloc(LPTR, cbTempBuffer);
        if (pvTemp)
        {
            if (pvExpandData)
            {
                ASSERT(lr == ERROR_MORE_DATA && pvData != NULL);
                memcpy(pvTemp, pvExpandData, cbExpandData - sizeof(TCHAR)); // zero-init of pvTemp automatically null-terminates
            }
            else
            {
                ASSERT(lr == ERROR_SUCCESS && pvData == NULL || lr == ERROR_MORE_DATA);
                DWORD dwTempType;
                if (RegQueryValueEx(hkey, pszValue, NULL, &dwTempType, (BYTE *)pvTemp, &cbTemp) != ERROR_SUCCESS
                    || dwTempType != *pdwType
                    || NullTerminateRegSzString(pvTemp, &cbTemp, cbTempBuffer, ERROR_SUCCESS) != ERROR_SUCCESS)
                {
                    lr = ERROR_CAN_NOT_COMPLETE;
                    LocalFree(pvTemp);
                    pvTemp = NULL;
                }
            }

            if (pvTemp)
            {
                cbExpandDataBuffer = cbTempBuffer;
                cbExpandData = cbTemp;
                pvExpandData = pvTemp;
            }
        }
        else
        {
            lr = GetLastError();
        }
    }

    ASSERT(!cbExpandDataBuffer || (pvExpandData && cbExpandData)); // Sanity check.

    if (cbExpandDataBuffer)
    {
        ASSERT(lr == ERROR_SUCCESS || lr == ERROR_MORE_DATA); // Sanity check.

        DWORD lenExpandedData;
        lr = _ExpandRegString((PTSTR)pvExpandData, cbExpandDataBuffer / sizeof(TCHAR), &lenExpandedData);
        *pcbData = max(lenExpandedData * sizeof(TCHAR), cbExpandData);
        if (lr == ERROR_SUCCESS && *pcbData > cbDataBuffer && pvData)
        {
            lr = ERROR_MORE_DATA;
        }
        else if (lr == ERROR_MORE_DATA && pvData == NULL)
        {
            lr = ERROR_SUCCESS; // mimic RegQueryValueEx() convention
        }                       // for size only (pcbData) requests

        if (pvExpandData != pvData)
        {
            LocalFree(pvExpandData);
        }
    }
    else
    {
        ASSERT(lr != ERROR_SUCCESS && lr != ERROR_MORE_DATA); // Sanity check.
    }

    return lr;
}

#ifdef UNICODE
#define NullTerminateRegMultiSzString NullTerminateRegMultiSzStringW
#else
#define NullTerminateRegMultiSzString NullTerminateRegMultiSzStringA
#endif

STDAPI_(LONG)
NullTerminateRegMultiSzString(
    IN OUT  void *  pvData,         // data bytes returned from RegQueryValueEx()
    IN OUT  DWORD * pcbData,        // data size returned from RegQueryValueEx()
    IN      DWORD   cbDataBuffer,   // data buffer size (actual allocated size of pvData)
    IN      LONG    lr)             // long result returned from RegQueryValueEx()
{
    ASSERT(pcbData != NULL); // Sanity check.

    if (lr == ERROR_SUCCESS && pvData != NULL)
    {
        DWORD cchDataBuffer = cbDataBuffer / sizeof(TCHAR); // cchDataBuffer is the actual allocated size of pvData in TCHARs
        DWORD cchData = *pcbData / sizeof(TCHAR);           // cchData is the length of the string written into pvData in TCHARs (including the null terminator)
        PTSTR pszData = (PTSTR)pvData;
        DWORD cNullsMissing;

        ASSERT(cchDataBuffer >= cchData); // Sanity check.

        //
        // [1] string and size request with sufficient original buffer
        //     (must ensure returned string and returned size include
        //      double null terminator)
        //

        if (cchData >= 2)
        {
            cNullsMissing = pszData[cchData-2]
                ? (pszData[cchData-1] ? 2 : 1)
                : (pszData[cchData-1] ? 1 : 0);
        }
        else
        {
            cNullsMissing = cchData == 1 && pszData[0] == TEXT('\0')
                ? 1
                : 2;
        }

        if (cchData + cNullsMissing <= cchDataBuffer)
        {
            for (DWORD i = 0; i < cNullsMissing; i++)
            {
                pszData[cchData+i] = TEXT('\0');
            }
        }
        else
        {
            lr = ERROR_MORE_DATA;
        }

        *pcbData = (cchData + cNullsMissing) * sizeof(TCHAR);
    }
    else if ((lr == ERROR_SUCCESS && pvData == NULL) || lr == ERROR_MORE_DATA)
    {
        //
        // [2] size only request or string and size request with insufficient
        //     original buffer (must ensure returned size includes double
        //     null terminator)
        //

        *pcbData += 2 * sizeof(TCHAR); // *** APPROXIMATION FOR PERF -- size
                                       // is therefore not guaranteed to be
                                       // exact, merely sufficient
    }

    return lr;
}

#ifdef UNICODE
#define FixRegData FixRegDataW
#else
#define FixRegData FixRegDataA
#endif

STDAPI_(LONG)
FixRegData(
    IN      HKEY    hkey,
    IN      PCTSTR  pszValue,
    IN      SRRF    dwFlags,
    IN      DWORD * pdwType,
    IN OUT  void *  pvData,         // data bytes returned from RegQueryValueEx()
    IN OUT  DWORD * pcbData,        // data size returned from RegQueryValueEx()
    IN      DWORD   cbDataBuffer,   // data buffer size (actual allocated size of pvData)
    IN      LONG    lr)             // long result returned from RegQueryValueEx()
{
    switch (*pdwType)
    {
        case REG_SZ:
            if (pcbData)
                lr = NullTerminateRegSzString(pvData, pcbData, cbDataBuffer, lr);
            break;

        case REG_EXPAND_SZ:
            if (pcbData)
                lr = dwFlags & SRRF_NOEXPAND
                    ? NullTerminateRegSzString(pvData, pcbData, cbDataBuffer, lr)
                    : NullTerminateRegExpandSzString(hkey, pszValue, pdwType, pvData, pcbData, cbDataBuffer, lr);

            // Note:
            //  If we automatically expand the REG_EXPAND_SZ data, we change
            //  *pdwType to REG_SZ to reflect this fact.  This helps to avoid
            //  the situation where the caller could mistakenly re-expand it.
            if (!(dwFlags & SRRF_NOEXPAND))
                *pdwType = REG_SZ;

            break;

        case REG_MULTI_SZ:
            if (pcbData)
                lr = NullTerminateRegMultiSzString(pvData, pcbData, cbDataBuffer, lr);
            break;
    }

    return lr;
}

// SHExpandEnvironmentStrings
//
// In all cases, this returns a valid output buffer.  The buffer may
// be empty, or it may be truncated, but you can always use the string.
//
// RETURN VALUE:
//   0  implies failure, either a truncated expansion or no expansion whatsoever
//   >0 implies complete expansion, value is count of characters written (excluding NULL)
//

DWORD WINAPI SHExpandEnvironmentStringsForUser(HANDLE hToken, PCTSTR pwzSrc, PTSTR pwzDst, DWORD cchSize)
{
    DWORD   dwRet;

    // 99/05/28 vtan: Handle specified users here. It's a Windows NT
    // thing only. Check for both conditions then load the function
    // dynamically out of userenv.dll. If the function cannot be
    // located or returns a problem default to the current user as
    // NULL hToken.

    if (hToken)
    {
        if (ExpandEnvironmentStringsForUser(hToken, pwzSrc, pwzDst, cchSize) != FALSE)
        {

            // userenv!ExpandEnvironmentStringsForUser returns
            // a BOOL result. Convert this to a DWORD result
            // that matches what kernel32!ExpandEnvironmentStrings
            // returns.

            dwRet = lstrlen(pwzDst) + sizeof('\0');
        }
        else
        {
            dwRet = 0;
        }
    }
    else
    {
        dwRet = ExpandEnvironmentStrings(pwzSrc, pwzDst, cchSize);
    }

    // The implementations of this function don't seem to gurantee gurantee certain
    // things about the output buffer in failure conditions that callers rely on.
    // So clean things up here.
    //
    // And I found code occasionally that handled semi-failure (success w/ dwRet>cchSize)
    // that assumed the string wasn't properly NULL terminated in this case.  Fix that here
    // in the wrapper so our callers don't have to wig-out about errors.
    //
    // NOTE: we map all failures to 0 too.
    //
    if (dwRet > cchSize)
    {
        // Buffer too small, some code assumed there was still a string there and
        // tried to NULL terminate, do it for them.
        SHTruncateString(pwzDst, cchSize);
        dwRet = 0;
    }
    else if (dwRet == 0)
    {
        // Failure, assume no expansions...
        StrCpyN(pwzDst, pwzSrc, cchSize);
    }

    return dwRet;
}

DWORD WINAPI SHExpandEnvironmentStrings(LPCTSTR pwzSrc, LPTSTR pwzDst, DWORD cchSize)
{
    return(SHExpandEnvironmentStringsForUser(NULL, pwzSrc, pwzDst, cchSize));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\mlui.cpp ===
#include "priv.h"
#include <regapix.h>
#include <htmlhelp.h>
#include <shlwapi.h>
#include <wininet.h>    // INTERNET_MAX_URL_LENGTH
#include "mlui.h"
#include "cstrinout.h"


//
//  Registry Key
//
const CHAR c_szLocale[] = "Locale";
const CHAR c_szInternational[] = "Software\\Microsoft\\Internet Explorer\\International";
const WCHAR c_wszAppPaths[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\iexplore.exe";
const WCHAR c_wszMUI[] = L"mui";
const WCHAR c_wszWebTemplate[] = L"\\Web\\%s";
const WCHAR c_wszMuiTemplate[] = L"\\Web\\mui\\%04x\\%s";
const CHAR c_szCheckVersion[] = "CheckVersion";

//
//  MLGetUILanguage(void)
//
LWSTDAPI_(LANGID) MLGetUILanguage(void)
{
    return GetUserDefaultUILanguage();
}

static const TCHAR s_szUrlMon[] = TEXT("urlmon.dll");
static const TCHAR s_szFncFaultInIEFeature[] = TEXT("FaultInIEFeature");
const CLSID CLSID_Satellite =  {0x85e57160,0x2c09,0x11d2,{0xb5,0x46,0x00,0xc0,0x4f,0xc3,0x24,0xa1}};

HRESULT 
_FaultInIEFeature(HWND hwnd, uCLSSPEC *pclsspec, QUERYCONTEXT *pQ, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    typedef HRESULT (WINAPI *PFNJIT)(
        HWND hwnd, 
        uCLSSPEC *pclsspec, 
        QUERYCONTEXT *pQ, 
        DWORD dwFlags);
    PFNJIT  pfnJIT = NULL;
    BOOL fDidLoadLib = FALSE;

    HINSTANCE hUrlMon = GetModuleHandle(s_szUrlMon);
    if (!hUrlMon)
    {
        hUrlMon = LoadLibrary(s_szUrlMon);
        fDidLoadLib = TRUE;
    }
    
    if (hUrlMon)
    {
        pfnJIT = (PFNJIT)GetProcAddress(hUrlMon, s_szFncFaultInIEFeature);
    }
    
    if (pfnJIT)
       hr = pfnJIT(hwnd, pclsspec, pQ, dwFlags);
       
    if (fDidLoadLib && hUrlMon)
        FreeLibrary(hUrlMon);

    return hr;
}

HRESULT GetMUIPathOfIEFileW(LPWSTR pszMUIFilePath, int cchMUIFilePath, LPCWSTR pcszFileName, LANGID lidUI)
{
    HRESULT hr = S_OK;
    
    ASSERT(pszMUIFilePath);
    ASSERT(pcszFileName);

    // deal with the case that pcszFileName has full path
    LPWSTR pchT = StrRChrW(pcszFileName, NULL, L'\\');
    if (pchT)
    {
        pcszFileName = pchT;
    }

    static WCHAR s_szMUIPath[MAX_PATH] = { L'\0' };
    static LANGID s_lidLast = 0;

    DWORD cb;

    // use cached string if possible
    if ( !s_szMUIPath[0] || s_lidLast != lidUI)
    {
        WCHAR szAppPath[MAXIMUM_VALUE_NAME_LENGTH];

        s_lidLast = lidUI;

        cb = sizeof(szAppPath);
        if (ERROR_SUCCESS == SHGetValueW(HKEY_LOCAL_MACHINE, c_wszAppPaths, NULL, NULL, szAppPath, &cb))
            PathRemoveFileSpecW(szAppPath);
        else
            szAppPath[0] = L'0';

        wnsprintfW(s_szMUIPath, cchMUIFilePath, L"%s\\%s\\%04x\\", szAppPath, c_wszMUI, lidUI );
    }
    StrCpyNW(pszMUIFilePath, s_szMUIPath, cchMUIFilePath);
    StrCatBuffW(pszMUIFilePath, pcszFileName, cchMUIFilePath);

    return hr;
}

#define CP_THAI     874
#define CP_ARABIC   1256
#define CP_HEBREW   1255

BOOL fDoMungeLangId(LANGID lidUI)
{
    LANGID lidInstall = GetSystemDefaultUILanguage();
    BOOL fRet = FALSE;

    if (0x0409 != lidUI && lidUI != lidInstall) // US resource is always no need to munge
    {
        CHAR szUICP[8];
        static UINT uiACP = GetACP();

        GetLocaleInfoA(MAKELCID(lidUI, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szUICP, ARRAYSIZE(szUICP));

        if (uiACP != (UINT) StrToIntA(szUICP))
            fRet = TRUE;
    }
    return fRet;
}

LANGID GetNormalizedLangId(DWORD dwFlag)
{
    LANGID lidUI = GetUserDefaultUILanguage();
    if (ML_NO_CROSSCODEPAGE == (dwFlag & ML_CROSSCODEPAGE_MASK))
    {
        if (fDoMungeLangId(lidUI))
            lidUI = 0;
    }

    return (lidUI) ? lidUI: GetSystemDefaultUILanguage();
}

//
//  MLLoadLibrary
//

HDPA g_hdpaPUI = NULL;

typedef struct tagPUIITEM
{
    HINSTANCE hinstRes;
    LANGID lidUI;
} PUIITEM, *PPUIITEM;

EXTERN_C BOOL InitPUI(void)
{
    if (NULL == g_hdpaPUI)
    {
        ENTERCRITICAL;
        if (NULL == g_hdpaPUI)
            g_hdpaPUI = DPA_Create(4);
        LEAVECRITICAL;
    }
    return (g_hdpaPUI)? TRUE: FALSE;
}

int GetPUIITEM(HINSTANCE hinst)
{
    int i = 0, cItems = 0;

    ASSERTCRITICAL;

    if (InitPUI())
    {
        cItems = DPA_GetPtrCount(g_hdpaPUI);

        for (i = 0; i < cItems; i++)
        {
            PPUIITEM pItem = (PPUIITEM)DPA_FastGetPtr(g_hdpaPUI, i);

            if (pItem && pItem->hinstRes == hinst)
                break;
        }
    }
    return (i < cItems)? i: -1;
}

EXTERN_C void DeinitPUI(void)
{
    if (g_hdpaPUI)
    {
        ENTERCRITICAL;
        if (g_hdpaPUI)
        {
            int i, cItems = 0;
        
            cItems = DPA_GetPtrCount(g_hdpaPUI);

            // clean up if there is anything left
            for (i = 0; i < cItems; i++)
                LocalFree(DPA_FastGetPtr(g_hdpaPUI, i));

            DPA_DeleteAllPtrs(g_hdpaPUI);
            DPA_Destroy(g_hdpaPUI);
            g_hdpaPUI = NULL;
        }
        LEAVECRITICAL;
    }
}

LWSTDAPI MLSetMLHInstance(HINSTANCE hInst, LANGID lidUI)
{
    int i=-1;
    
    if (hInst)
    {
        PPUIITEM pItem = (PPUIITEM)LocalAlloc(LPTR, sizeof(PUIITEM));

        if (pItem)
        {
            pItem->hinstRes = hInst;
            pItem->lidUI = lidUI;
            if (InitPUI())
            {
                ENTERCRITICAL;
                i = DPA_AppendPtr(g_hdpaPUI, pItem);
                LEAVECRITICAL;
            }
            if (-1 == i)
                LocalFree(pItem);
        }
    }

    return (-1 == i) ? E_OUTOFMEMORY : S_OK;
}

LWSTDAPI MLClearMLHInstance(HINSTANCE hInst)
{
    int i;

    ENTERCRITICAL;
    i = GetPUIITEM(hInst);
    if (0 <= i)
    {
        LocalFree(DPA_FastGetPtr(g_hdpaPUI, i));
        DPA_DeletePtr(g_hdpaPUI, i);
    }
    LEAVECRITICAL;

    return S_OK;
}

LWSTDAPI
SHGetWebFolderFilePathW(LPCWSTR pszFileName, LPWSTR pszMUIPath, UINT cchMUIPath)
{
    HRESULT hr;
    UINT    cchWinPath;
    LANGID  lidUI;
    LANGID  lidInstall;
    LPWSTR  pszWrite;
    UINT    cchMaxWrite;
    BOOL    fPathChosen;

    RIP(IS_VALID_STRING_PTRW(pszFileName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszMUIPath, WCHAR, cchMUIPath));

    hr = E_FAIL;
    fPathChosen = FALSE;

    //
    // build the path to the windows\web folder...
    //

    cchWinPath = GetSystemWindowsDirectoryW(pszMUIPath, cchMUIPath);
    if (cchWinPath >= cchMUIPath)
    {
        return hr; // buffer would have overflowed
    }

    if (cchWinPath > 0 &&
        pszMUIPath[cchWinPath-1] == L'\\')
    {
        // don't have two L'\\' in a row
        cchWinPath--;
    }

    lidUI = GetNormalizedLangId(ML_CROSSCODEPAGE);
    lidInstall = GetSystemDefaultUILanguage();

    pszWrite = pszMUIPath+cchWinPath;
    cchMaxWrite = cchMUIPath-cchWinPath;

    if (lidUI != lidInstall)
    {
        //
        // add L"\\Web\\mui\\xxxx\\<filename>"
        // where xxxx is the langid specific folder name
        //

        wnsprintfW(pszWrite, cchMaxWrite, c_wszMuiTemplate, lidUI, pszFileName);

        if (PathFileExistsW(pszMUIPath))
        {
            fPathChosen = TRUE;
        }
    }

    if (!fPathChosen)
    {
        //
        // add L"\\Web\\<filename>"
        //

        wnsprintfW(pszWrite, cchMaxWrite, c_wszWebTemplate, pszFileName);

        if (PathFileExistsW(pszMUIPath))
        {
            fPathChosen = TRUE;
        }
    }

    if (fPathChosen)
    {
        hr = S_OK;
    }

    return hr;
}

LWSTDAPI
SHGetWebFolderFilePathA(LPCSTR pszFileName, LPSTR pszMUIPath, UINT cchMUIPath)
{
    RIP(IS_VALID_STRING_PTRA(pszFileName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszMUIPath, CHAR, cchMUIPath));

    HRESULT     hr;
    CStrInW     strFN(pszFileName);
    CStrOutW    strMP(pszMUIPath, cchMUIPath);

    hr = SHGetWebFolderFilePathW(strFN, strMP, strMP.BufSize());

    return hr;
}

//  Given a string of form 5.00.2919.6300, this function gets the equivalent dword
//  representation of it.

#define NUM_VERSION_NUM 4
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    WORD rwVer[NUM_VERSION_NUM];

    for(int i = 0; i < NUM_VERSION_NUM; i++)
        rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
        rwVer[i] = (WORD) StrToInt(pszVer);
        pszVer = StrChr(pszVer, TEXT('.'));
        if (pszVer)
            pszVer++;
    }

   *pdwVer = (rwVer[0]<< 16) + rwVer[1];
   *pdwBuild = (rwVer[2] << 16) + rwVer[3];

}

/*
    For SP's we don't update the MUI package. So in order for the golden MUI package to work
    with SP's, we now check if the MUI package is compatible with range of version numbers.
    Since we have different modules calling into this, and they have different version numbers,
    we read the version range from registry for a particular module.

    This Function takes the lower and upper version number of the MUI package. It gets the caller's
    info and reads the version range from registry. If the MUI package version lies in the version
    range specified in the registry, it returns TRUE.
*/


BOOL IsMUICompatible(DWORD dwMUIFileVersionMS, DWORD dwMUIFileVersionLS)
{
    TCHAR szVersionInfo[MAX_PATH];
    DWORD dwType, dwSize;
    TCHAR szProcess[MAX_PATH];

    dwSize = sizeof(szVersionInfo);

    //Get the caller process
    if(!GetModuleFileName(NULL, szProcess, MAX_PATH))
        return FALSE;

    //Get the file name from the path
    LPTSTR lpszFileName = PathFindFileName(szProcess);

    //Query the registry for version info. If the key doesn't exists or there is an 
    //error, return false.
    if(ERROR_SUCCESS != SHRegGetUSValueA(c_szInternational, lpszFileName, 
                        &dwType, (LPVOID)szVersionInfo, &dwSize, TRUE, NULL, 0))
    {
        return FALSE;
    }

    LPTSTR lpszLowerBound = szVersionInfo;

    LPTSTR lpszUpperBound = StrChr(szVersionInfo, TEXT('-'));
    if(!lpszUpperBound || !*(lpszUpperBound+1))
        return FALSE;
    
    *(lpszUpperBound++) = NULL;

    DWORD dwLBMS, dwLBLS, dwUBMS, dwUBLS;

    ConvertVersionStrToDwords(lpszLowerBound, &dwLBMS, &dwLBLS);
    ConvertVersionStrToDwords(lpszUpperBound, &dwUBMS, &dwUBLS);

    //check if MUI version is in the specified range.
    if( (dwMUIFileVersionMS < dwLBMS) ||
        (dwMUIFileVersionMS == dwLBMS && dwMUIFileVersionLS < dwLBLS) ||
        (dwMUIFileVersionMS > dwUBMS) ||
        (dwMUIFileVersionMS == dwUBMS && dwMUIFileVersionLS > dwUBLS) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CheckFileVersion(LPWSTR lpFile, LPWSTR lpFileMUI)
{
    DWORD dwSize, dwHandle, dwSizeMUI, dwHandleMUI;
    LPVOID lpVerInfo, lpVerInfoMUI;
    VS_FIXEDFILEINFO *pvsffi, *pvsffiMUI;
    BOOL fRet = FALSE;

    dwSize = GetFileVersionInfoSizeW(lpFile, &dwHandle);
    dwSizeMUI = GetFileVersionInfoSizeW(lpFileMUI, &dwHandleMUI);
    if (dwSize && dwSizeMUI)
    {
        if (lpVerInfo = LocalAlloc(LPTR, dwSize))
        {
            if (lpVerInfoMUI = LocalAlloc(LPTR, dwSizeMUI))
            {
                if (GetFileVersionInfoW(lpFile, dwHandle, dwSize, lpVerInfo) &&
                    GetFileVersionInfoW(lpFileMUI, dwHandleMUI, dwSizeMUI, lpVerInfoMUI))
                {
                    if (VerQueryValueW(lpVerInfo, L"\\", (LPVOID *)&pvsffi, (PUINT)&dwSize) &&
                        VerQueryValueW(lpVerInfoMUI, L"\\", (LPVOID *)&pvsffiMUI, (PUINT)&dwSizeMUI))
                    {
                        if ((pvsffi->dwFileVersionMS == pvsffiMUI->dwFileVersionMS &&
                            pvsffi->dwFileVersionLS == pvsffiMUI->dwFileVersionLS)||
                            IsMUICompatible(pvsffiMUI->dwFileVersionMS, pvsffiMUI->dwFileVersionLS))
                        {
                            fRet = TRUE;
                        }
                    }
                }
                LocalFree(lpVerInfoMUI);
            }
            LocalFree(lpVerInfo);
        }
    }
    return fRet;
}

LWSTDAPI_(HINSTANCE) MLLoadLibraryW(LPCWSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage)
{
    LANGID lidUI;
    WCHAR szPath[MAX_PATH], szMUIPath[MAX_PATH];
    LPCWSTR lpPath = NULL;
    HINSTANCE hInst;
    static BOOL fCheckVersion = SHRegGetBoolUSValueA(c_szInternational, c_szCheckVersion, TRUE, TRUE);;

    if (!lpLibFileName)
        return NULL;

    szPath[0] = szMUIPath[0] = NULL;
    lidUI = GetNormalizedLangId(dwCrossCodePage);

    if (hModule)
    {
        if (GetModuleFileNameW(hModule, szPath, ARRAYSIZE(szPath)))
        {
            PathRemoveFileSpecW(szPath);
            if (PathAppendW(szPath, lpLibFileName) &&
                GetSystemDefaultUILanguage() == lidUI)
                lpPath = szPath;
        }
    }

    if (!lpPath)
    {
        GetMUIPathOfIEFileW(szMUIPath, ARRAYSIZE(szMUIPath), lpLibFileName, lidUI);
        lpPath = szMUIPath;
    }

    // Check version between module and resource. If different, use default one.
    if (fCheckVersion && szPath[0] && szMUIPath[0] && !CheckFileVersion(szPath, szMUIPath))
    {
        lidUI = GetSystemDefaultUILanguage();
        lpPath = szPath;
    }

    ASSERT(lpPath);
    
    // PERF: This should use PathFileExist first then load what exists
    //         failing in LoadLibrary is slow
    hInst = LoadLibraryW(lpPath);

    if (NULL == hInst)
    {
        // All failed. Try to load default one lastly.
        if (!hInst && lpPath != szPath)
        {
            lidUI = GetSystemDefaultUILanguage();
            hInst = LoadLibraryW(szPath);
        }
    }

    if (NULL == hInst)
        hInst = LoadLibraryW(lpLibFileName);

    // if we load any resource, save info into dpa table
    MLSetMLHInstance(hInst, lidUI);

    return hInst;
}

//
//  Wide-char wrapper for MLLoadLibraryA
//
LWSTDAPI_(HINSTANCE) MLLoadLibraryA(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage)
{
    WCHAR szLibFileName[MAX_PATH];

    SHAnsiToUnicode(lpLibFileName, szLibFileName, ARRAYSIZE(szLibFileName));

    return MLLoadLibraryW(szLibFileName, hModule, dwCrossCodePage);
}

LWSTDAPI_(BOOL) MLFreeLibrary(HMODULE hModule)
{
    MLClearMLHInstance(hModule);
    return FreeLibrary(hModule);
}

LWSTDAPI_(BOOL) MLIsMLHInstance(HINSTANCE hInst)
{
    int i;

    ENTERCRITICAL;
    i = GetPUIITEM(hInst);
    LEAVECRITICAL;

    return (0 <= i);
}

const WCHAR c_szResPrefix[] = L"res://";

LWSTDAPI
MLBuildResURLW(LPCWSTR  pszLibFile,
               HMODULE  hModule,
               DWORD    dwCrossCodePage,
               LPCWSTR  pszResName,
               LPWSTR   pszResUrlOut,
               int      cchResUrlOut)
{
    HRESULT hr;
    LPWSTR  pszWrite;
    int     cchBufRemaining;
    int     cchWrite;

    RIP(IS_VALID_STRING_PTRW(pszLibFile, -1));
    RIP(hModule != INVALID_HANDLE_VALUE);
    RIP(hModule != NULL);
    RIP(IS_VALID_STRING_PTRW(pszResName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszResUrlOut, WCHAR, cchResUrlOut));

    hr = E_INVALIDARG;

    if (pszLibFile != NULL &&
        hModule != NULL &&
        hModule != INVALID_HANDLE_VALUE &&
        (dwCrossCodePage == ML_CROSSCODEPAGE || dwCrossCodePage == ML_NO_CROSSCODEPAGE) &&
        pszResName != NULL &&
        pszResUrlOut != NULL)
    {
        hr = E_FAIL;

        pszWrite = pszResUrlOut;
        cchBufRemaining = cchResUrlOut;

        // write in the res protocol prefix
        cchWrite = lstrlenW(c_szResPrefix);
        if (cchBufRemaining >= cchWrite+1)
        {
            HINSTANCE   hinstLocRes;

            StrCpyNW(pszWrite, c_szResPrefix, cchBufRemaining);
            pszWrite += cchWrite;
            cchBufRemaining -= cchWrite;

            // figure out the module path
            // unfortunately the module path might only exist
            // after necessary components are JIT'd, and
            // we don't know whether a JIT is necessary unless
            // certain LoadLibrary's have failed.
            hinstLocRes = MLLoadLibraryW(pszLibFile, hModule, dwCrossCodePage);
            if (hinstLocRes != NULL)
            {
                BOOL    fGotModulePath;
                WCHAR   szLocResPath[MAX_PATH];

                fGotModulePath = GetModuleFileNameW(hinstLocRes, szLocResPath, ARRAYSIZE(szLocResPath));

                MLFreeLibrary(hinstLocRes);

                if (fGotModulePath)
                {
                    // copy in the module path
                    cchWrite = lstrlenW(szLocResPath);
                    if (cchBufRemaining >= cchWrite+1)
                    {
                        StrCpyNW(pszWrite, szLocResPath, cchBufRemaining);
                        pszWrite += cchWrite;
                        cchBufRemaining -= cchWrite;

                        // write the next L'/' and the resource name
                        cchWrite = 1 + lstrlenW(pszResName);
                        if (cchBufRemaining >= cchWrite+1)
                        {
                            *(pszWrite++) = L'/';
                            cchBufRemaining--;
                            StrCpyNW(pszWrite, pszResName, cchBufRemaining);

                            ASSERT(pszWrite[lstrlenW(pszResName)] == '\0');

                            hr = S_OK;
                        }
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            pszResUrlOut[0] = L'\0';
        }
    }

    return hr;
}

LWSTDAPI
MLBuildResURLA(LPCSTR    pszLibFile,
               HMODULE  hModule,
               DWORD    dwCrossCodePage,
               LPCSTR   pszResName,
               LPSTR   pszResUrlOut,
               int      cchResUrlOut)
{
    HRESULT hr;

    RIP(IS_VALID_STRING_PTR(pszLibFile, -1));
    RIP(hModule != INVALID_HANDLE_VALUE);
    RIP(hModule != NULL);
    RIP(IS_VALID_STRING_PTRA(pszResName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszResUrlOut, CHAR, cchResUrlOut));

    CStrInW     strLF(pszLibFile);
    CStrInW     strRN(pszResName);
    CStrOutW    strRUO(pszResUrlOut, cchResUrlOut);

    hr = MLBuildResURLW(strLF, hModule, dwCrossCodePage, strRN, strRUO, strRUO.BufSize());

    return hr;
}

#define MAXRCSTRING 514

// this will check to see if lpcstr is a resource id or not.  if it
// is, it will return a LPSTR containing the loaded resource.
// the caller must LocalFree this lpstr.  if pszText IS a string, it
// will return pszText
//
// returns:
//      pszText if it is already a string
//      or
//      LocalAlloced() memory to be freed with LocalFree
//      if pszRet != pszText free pszRet

LPWSTR ResourceCStrToStr(HINSTANCE hInst, LPCWSTR pszText)
{
    WCHAR szTemp[MAXRCSTRING];
    LPWSTR pszRet = NULL;

    if (!IS_INTRESOURCE(pszText))
        return (LPWSTR)pszText;

    if (LOWORD((DWORD_PTR)pszText) && LoadStringW(hInst, LOWORD((DWORD_PTR)pszText), szTemp, ARRAYSIZE(szTemp)))
    {
        int cchRet = lstrlenW(szTemp) + 1;

        pszRet = (LPWSTR)LocalAlloc(LPTR, cchRet * sizeof(WCHAR));
        if (pszRet)
        {
            StringCchCopyW(pszRet, cchRet, szTemp);
        }
    }
    return pszRet;
}

LPWSTR _ConstructMessageString(HINSTANCE hInst, LPCWSTR pszMsg, va_list *ArgList)
{
    LPWSTR pszRet;
    LPWSTR pszRes = ResourceCStrToStr(hInst, pszMsg);
    if (!pszRes)
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: Failed to load string template"));
        return NULL;
    }

    if (!FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pszRes, 0, 0, (LPWSTR)&pszRet, 0, ArgList))
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: FormatMessage failed %d"),GetLastError());
        DebugMsg(DM_ERROR, TEXT("                         pszRes = %s"), pszRes );
        DebugMsg(DM_ERROR, !IS_INTRESOURCE(pszMsg) ? 
            TEXT("                         pszMsg = %s") : 
            TEXT("                         pszMsg = 0x%x"), pszMsg );
        pszRet = NULL;
    }


    if (pszRes != pszMsg)
        LocalFree(pszRes);

    return pszRet;      // free with LocalFree()
}


LWSTDAPIV_(int) ShellMessageBoxWrapW(HINSTANCE hInst, HWND hWnd, LPCWSTR pszMsg, LPCWSTR pszTitle, UINT fuStyle, ...)
{
    LPWSTR pszText;
    int result;
    WCHAR szBuffer[80];
    va_list ArgList;

    // BUG 95214
#ifdef DEBUG
    IUnknown* punk = NULL;
    if (SUCCEEDED(SHGetThreadRef(&punk)) && punk)
    {
        ASSERTMSG(hWnd != NULL, TEXT("shlwapi\\mlui.cpp : ShellMessageBoxW - Caller should either be not under a browser or should have a parent hwnd"));
        punk->Release();
    }
#endif

    if (!IS_INTRESOURCE(pszTitle))
    {
        // do nothing
    }
    else if (LoadStringW(hInst, LOWORD((DWORD_PTR)pszTitle), szBuffer, ARRAYSIZE(szBuffer)))
    {
        // Allow this to be a resource ID or NULL to specifiy the parent's title
        pszTitle = szBuffer;
    }
    else if (hWnd)
    {
        // The caller didn't give us a Title, so let's use the Window Text.

        // Grab the title of the parent
        GetWindowTextW(hWnd, szBuffer, ARRAYSIZE(szBuffer));

        // HACKHACK YUCK!!!!
        // Is the window the Desktop window?
        if (!StrCmpW(szBuffer, L"Program Manager"))
        {
            // Yes, so we now have two problems,
            // 1. The title should be "Desktop" and not "Program Manager", and
            // 2. Only the desktop thread can call this or it will hang the desktop
            //    window.

            // Is the window Prop valid?
            if (GetWindowThreadProcessId(hWnd, 0) == GetCurrentThreadId())
            {
                // Yes, so let's get it...

                // Problem #1, load a localized version of "Desktop"
                pszTitle = (LPCWSTR) GetProp(hWnd, TEXT("pszDesktopTitleW"));

                if (!pszTitle)
                {
                    // Oops, this must have been some app with "Program Manager" as the title.
                    pszTitle = szBuffer;
                }
            }
            else
            {
                // No, so we hit problem 2...

                // Problem #2, Someone is going to
                //             hang the desktop window by using it as the parent
                //             of a dialog that belongs to a thread other than
                //             the desktop thread.
                RIPMSG(0, "****************ERROR********** The caller is going to hang the desktop window by putting a modal dlg on it.");
            }
        }
        else
            pszTitle = szBuffer;
    }
    else
    {
        pszTitle = L"";
    }

    va_start(ArgList, fuStyle);
    pszText = _ConstructMessageString(hInst, pszMsg, &ArgList);
    va_end(ArgList);

    if (pszText)
    {
        result = MessageBoxW(hWnd, pszText, pszTitle, fuStyle | MB_SETFOREGROUND);
        LocalFree(pszText);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("smb: Not enough memory to put up dialog."));
        result = -1;    // memory failure
    }

    return result;
}

HRESULT GetFilePathFromLangId (LPCWSTR pszFile, LPWSTR pszOut, int cchOut, DWORD dwFlag)
{
    HRESULT hr = S_OK;
    WCHAR szMUIPath[MAX_PATH];
    LPCWSTR lpPath;
    LANGID lidUI;
    
    if (pszFile)
    {
        // FEATURE: should support '>' format but not now
        if (*pszFile == L'>') return E_FAIL;

        lidUI = GetNormalizedLangId(dwFlag);
        if (0 == lidUI || GetSystemDefaultUILanguage() == lidUI)
            lpPath = pszFile;
        else
        {
            GetMUIPathOfIEFileW(szMUIPath, ARRAYSIZE(szMUIPath), pszFile, lidUI);
            lpPath = szMUIPath;
        }
        lstrcpynW(pszOut, lpPath, min(MAX_PATH, cchOut));
    }
    else
        hr = E_FAIL;

    return hr;
}

// 
// MLHtmlHelp / MLWinHelp
//
// Function: load a help file corresponding to the current UI lang setting 
//           from \mui\<Lang ID>
//
//
HWND MLHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = E_FAIL;
    HWND hwnd = NULL;

    // FEATURE: 1) At this moment we only support the cases that pszFile points to 
    //         a fully qualified file path, like when uCommand == HH_DISPLAY_TOPIC
    //         or uCommand == HH_DISPLAY_TEXT_POPUP. 
    //         2) We should support '>' format to deal with secondary window
    //         3) we may need to thunk file names within HH_WINTYPE structures?
    //
    if (uCommand == HH_DISPLAY_TOPIC || uCommand == HH_DISPLAY_TEXT_POPUP)
    {
        hr = GetFilePathFromLangId(pszFile, szPath, ARRAYSIZE(szPath), dwCrossCodePage);
        if (hr == S_OK)
            hwnd = HtmlHelpW(hwndCaller, szPath, uCommand, dwData);
    }

    // if there was any failure in getting ML path of help file
    // we call the help engine with original file path.
    if (hr != S_OK)
    {
        hwnd = HtmlHelpW(hwndCaller, pszFile, uCommand, dwData);
    }
    return hwnd;
}

BOOL MLWinHelpW(HWND hwndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{

    WCHAR szPath[MAX_PATH];
    BOOL fret;

    HRESULT hr = GetFilePathFromLangId(lpszHelp, szPath, ARRAYSIZE(szPath), ML_NO_CROSSCODEPAGE);
    if (hr == S_OK)
    {
        fret = WinHelpW(hwndCaller, szPath, uCommand, dwData);
    }
    else
        fret = WinHelpW(hwndCaller, lpszHelp, uCommand, dwData);

    return fret;
}

//
//  Note that we cannot thunk to MLHtmlHelpW because we must call through
//  HtmlHelpA to get the dwData interpreted correctly.
//
HWND MLHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage)
{
    HRESULT hr = E_FAIL;
    HWND hwnd = NULL;

    // FEATURE: 1) At this moment we only support the cases that pszFile points to 
    //         a fully qualified file path, like when uCommand == HH_DISPLAY_TOPIC
    //         or uCommand == HH_DISPLAY_TEXT_POPUP. 
    //         2) We should support '>' format to deal with secondary window
    //         3) we may need to thunk file names within HH_WINTYPE structures?
    //
    if (uCommand == HH_DISPLAY_TOPIC || uCommand == HH_DISPLAY_TEXT_POPUP)
    {
        WCHAR wszFileName[MAX_PATH];
        LPCWSTR pszFileParam = NULL;
        if (pszFile)
        {
            SHAnsiToUnicode(pszFile, wszFileName, ARRAYSIZE(wszFileName));
            pszFileParam = wszFileName;
        }

        hr = GetFilePathFromLangId(pszFileParam, wszFileName, ARRAYSIZE(wszFileName), dwCrossCodePage);
        if (hr == S_OK)
        {
            ASSERT(NULL != pszFileParam);   // GetFilePathFromLangId returns E_FAIL with NULL input

            CHAR szFileName[MAX_PATH];
            SHUnicodeToAnsi(wszFileName, szFileName, ARRAYSIZE(szFileName));
            hwnd = HtmlHelpA(hwndCaller, szFileName, uCommand, dwData);
        }
    }

    // if there was any failure in getting ML path of help file
    // we call the help engine with original file path.
    if (hr != S_OK)
    {
        hwnd = HtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
    }
    return hwnd;
}

BOOL MLWinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
    WCHAR szFileName[MAX_PATH];
    LPCWSTR pszHelpParam = NULL;

    if (lpszHelp && SHAnsiToUnicode(lpszHelp, szFileName, ARRAYSIZE(szFileName)))
    {
        pszHelpParam = szFileName;
    }
    return  MLWinHelpW(hWndMain, pszHelpParam, uCommand, dwData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\palette.c ===
/***************************************************************************
 *  palette.c
 *
 *  Common halftone palette used by shell.   
 *
 ***************************************************************************/

#include "priv.h"
#include "palette.h"

BYTE * g_pbWinNTCMAP = NULL;

// This function behaves the same as CreateHalftone palette:
//      hdc == NULL         always return full palette
//      hdc palettized      return full palette
//      hdc not palettized  return default palette (VGA colors)

HPALETTE SHCreateShellPalette(HDC hdc)
{
    // We would like to use CreateHalftonePalette() always but they
    // differ significantly between NT and Win95.  Win95's is very
    // close to Netscape's; NT's is significantly different (color
    // cube cut differently) and it is not an identity palette.
    //
    // So, we will use CreateHalftonePalette() on Win95 and on NT
    // we will use a custom palette containing the same colors in
    // Win95's halftone palette ordered so that the color flash
    // will be minimized when switching between NT's halftone palette
    // and our palette.
    //
    // On NT 5 and later the halftone palette matches Win95's so the
    // custom palette will only be used on machines running NT 4 or below.
    // However, we still need to patch in the system colors on NT 5.

    HPALETTE hpalHalftone = CreateHalftonePalette(hdc);

    if (hpalHalftone)
    {
        HDC hdcScreen = hdc;
	    LOGPAL256       lp;
        lp.wCnt = (WORD)GetPaletteEntries(hpalHalftone, 0, 256, lp.ape);
        lp.wVer = 0x0300;
        DeleteObject(hpalHalftone);

        if (hdcScreen == NULL)
            hdcScreen = CreateCompatibleDC(NULL);
        if (hdcScreen)
        {
            GetSystemPaletteEntries(hdcScreen, 0, 10, lp.ape);
            GetSystemPaletteEntries(hdcScreen, 246, 10, lp.ape + 246);
        }
        hpalHalftone = CreatePalette((LOGPALETTE *)&lp);
        
        if (hdc == NULL && hdcScreen)
            DeleteDC(hdcScreen);
    }

    return hpalHalftone;
}

// SOMEDAY: (raymondc) Pre-invert the map in the header file so we don't
// have to compute it on the fly.
static const BYTE *GetInverseCMAP()
{
    if (g_pbWinNTCMAP == NULL)
    {
        BYTE * pbMap = LocalAlloc(LPTR, 32768);
        if (pbMap)
        {
            int i;
            BYTE * pbDst = pbMap;
            const BYTE * pbSrc = g_abWin95CMAP;
            for (i = 0; i < 32768; ++i)
            {
                *pbDst++ = g_abWin95ToNT5[*pbSrc++];
            }
            if (SHInterlockedCompareExchange((void **)&g_pbWinNTCMAP, pbMap, NULL))
            {
                LocalFree(pbMap);   // race, get rid of dupe copy
            }
        }
    }
    return g_pbWinNTCMAP;
}

HRESULT SHGetInverseCMAP(BYTE *pbMap, ULONG cbMap)
{
    const BYTE *pbSrc;

    if (pbMap == NULL)
        return E_POINTER;
        
    if (cbMap != 32768 && cbMap != sizeof(BYTE *))
        return E_INVALIDARG;

    pbSrc = GetInverseCMAP();

    if (pbSrc == NULL)
        return E_OUTOFMEMORY;

    if (cbMap == sizeof(BYTE *))
    {
        *(const BYTE **)pbMap = pbSrc;
    }
    else
    {
        memcpy(pbMap, pbSrc, 32768);
    }

    return(S_OK);
}


void TermPalette()
{
    if (g_pbWinNTCMAP)
        LocalFree(g_pbWinNTCMAP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\ole2dup.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: ole2dup.c
//
//  This file contains all the duplicated code from OLE 2.0 DLLs to avoid
// any link to their DLLs from the shell. If we decided to have links to
// them, we need to delete these files.
//
// History:
//  04-16-97 AndyP      moved parts to shlwapi (from shell32)
//  12-29-92 SatoNa     Created.
//
//---------------------------------------------------------------------------

#include "priv.h"

//
// SHStringFromGUIDA
//
// converts GUID into (...) form without leading identifier; returns
// amount of data copied to lpsz if successful; 0 if buffer too small.
//

// An endian-dependant map of what bytes go where in the GUID
// text representation.
//
// Do NOT use the TEXT() macro in GuidMap... they're intended to be bytes
//

static const BYTE c_rgbGuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                     8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const CHAR c_szDigitsA[] = "0123456789ABCDEF";
static const WCHAR c_szDigitsW[] = TEXTW("0123456789ABCDEF");

STDAPI_(int) 
SHStringFromGUIDA(
    UNALIGNED REFGUID rguid, 
    LPSTR   psz, 
    int     cchMax)
{
    int i;
    const BYTE * pBytes = (const BYTE *) rguid;

    if (cchMax < GUIDSTR_MAX)
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintf(psz, cchMax,"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid->Data1, rguid->Data2, rguid->Data3,
            rguid->Data4[0], rguid->Data4[1],
            rguid->Data4[2], rguid->Data4[3],
            rguid->Data4[4], rguid->Data4[5],
            rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = '{';

    for (i = 0; i < sizeof(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == '-')      // don't TEXT() this line
        {
            *psz++ = '-';
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigitsA[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigitsA[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = '}';
    *psz   = '\0';
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}


STDAPI_(int) 
SHStringFromGUIDW(
    UNALIGNED REFGUID rguid, 
    LPWSTR  psz, 
    int     cchMax)
{
    int i;
    const BYTE * pBytes = (const BYTE *) rguid;

    if (cchMax < GUIDSTR_MAX)
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintfW(psz, cchMax, L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid->Data1, rguid->Data2, rguid->Data3,
            rguid->Data4[0], rguid->Data4[1],
            rguid->Data4[2], rguid->Data4[3],
            rguid->Data4[4], rguid->Data4[5],
            rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = TEXTW('{');

    for (i = 0; i < sizeof(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == '-')      // don't TEXT() this line
        {
            *psz++ = TEXTW('-');
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigitsW[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigitsW[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = TEXTW('}');
    *psz   = TEXTW('\0');
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}

// this makes sure the DLL for the given clsid stays in memory
// this is needed because we violate COM rules and hold apparment objects
// across the lifetime of appartment threads. these objects really need
// to be free threaded (we have always treated them as such)
//
//  Look in the registry and pull out the name of the DLL who owns
//  the CLSID.  We must pull the DLL name as unicode in case the
//  DLL name contains unicode characters.
//
STDAPI_(HINSTANCE) SHPinDllOfCLSID(const CLSID *pclsid)
{
    HKEY hk;
    DWORD dwSize;
    HINSTANCE hinst = NULL;
    TCHAR szClass[GUIDSTR_MAX + 64];    // CLSID\{...}\InProcServer32
    WCHAR szDllPath[MAX_PATH];

    if (SUCCEEDED(StringCchCopy(szClass, ARRAYSIZE(szClass), TEXT("CLSID\\"))) &&
        SHStringFromGUID(pclsid, szClass + 6, ARRAYSIZE(szClass) - 6)	       &&       // 6 = strlen("CLSID\\") 
        SUCCEEDED(StringCchCat(szClass, ARRAYSIZE(szClass), TEXT("\\InProcServer32"))))
    {
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szClass, 0, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS)
        {
            // Explicitly read as unicode.  SHQueryValueEx handles REG_EXPAND_SZ
            dwSize = sizeof(szDllPath);
            if (SHQueryValueExW(hk, 0, 0, 0, szDllPath, &dwSize) == ERROR_SUCCESS)
            {
                hinst = LoadLibraryExW(szDllPath, NULL, 0);
            }

            RegCloseKey(hk);
        }
    }

    return hinst;
}

// scan psz for a number of hex digits (at most 8); update psz, return
// value in Value; check for chDelim; return TRUE for success.
BOOL HexStringToDword(LPCTSTR * ppsz, DWORD * lpValue, int cDigits, TCHAR chDelim)
{
    int ich;
    LPCTSTR psz = *ppsz;
    DWORD Value = 0;
    BOOL fRet = TRUE;

    for (ich = 0; ich < cDigits; ich++)
    {
        TCHAR ch = psz[ich];
        if (InRange(ch, TEXT('0'), TEXT('9')))
        {
            Value = (Value << 4) + ch - TEXT('0');
        }
        else if ( InRange( (ch |= (TEXT('a')-TEXT('A'))), TEXT('a'), TEXT('f')) )
        {
            Value = (Value << 4) + ch - TEXT('a') + 10;
        }
        else
            return(FALSE);
    }

    if (chDelim)
    {
        fRet = (psz[ich++] == chDelim);
    }

    *lpValue = Value;
    *ppsz = psz+ich;

    return fRet;
}

// parse above format; return TRUE if succesful; always writes over *pguid.
STDAPI_(BOOL) GUIDFromString(LPCTSTR psz, GUID *pguid)
{
    DWORD dw;
    if (*psz++ != TEXT('{') /*}*/ )
        return FALSE;

    if (!HexStringToDword(&psz, &pguid->Data1, sizeof(DWORD)*2, TEXT('-')))
        return FALSE;

    if (!HexStringToDword(&psz, &dw, sizeof(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, TEXT('-')))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(&psz, &dw, sizeof(BYTE)*2, /*(*/ TEXT('}')))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

#ifdef UNICODE

LWSTDAPI_(BOOL) GUIDFromStringA(LPCSTR psz, GUID *pguid)
{
    TCHAR sz[GUIDSTR_MAX];

    SHAnsiToTChar(psz, sz, SIZECHARS(sz));
    return GUIDFromString(sz, pguid);
}

#else

LWSTDAPI_(BOOL) GUIDFromStringW(LPCWSTR psz, GUID *pguid)
{
    TCHAR sz[GUIDSTR_MAX];

    SHUnicodeToAnsi(psz, sz, SIZECHARS(sz));
    return GUIDFromString(sz, pguid);
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\palette.h ===
#include <platform.h>

typedef struct
{
    WORD            wVer;
    WORD            wCnt;
    PALETTEENTRY    ape[256];
} LOGPAL256;

const LOGPAL256 g_lpHalftone =
{
    0x0300, 256,
    {
        PALETTE_ENTRY( 0x00, 0x00, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x00, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x80, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x80, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x00, 0x80, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x00, 0x80, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x80, 0x80, 0x00 ),
        PALETTE_ENTRY( 0xC0, 0xC0, 0xC0, 0x00 ),
        PALETTE_ENTRY( 0xC0, 0xDC, 0xC0, 0x00 ),
        PALETTE_ENTRY( 0xA6, 0xCA, 0xF0, 0x00 ),
        PALETTE_ENTRY( 0x99, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xEF, 0xD6, 0xC6, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xAD, 0xA9, 0x90, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xA5, 0x00, 0x21, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xD6, 0x00, 0x93, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x50, 0x50, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x7C, 0x80, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x04, 0x04, 0x04, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x08, 0x08, 0x08, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x0C, 0x0C, 0x0C, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x11, 0x11, 0x11, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x16, 0x16, 0x16, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x1C, 0x1C, 0x1C, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x22, 0x22, 0x22, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x29, 0x29, 0x29, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x39, 0x39, 0x39, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x42, 0x42, 0x42, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x4D, 0x4D, 0x4D, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x55, 0x55, 0x55, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x5F, 0x5F, 0x5F, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x77, 0x77, 0x77, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x86, 0x86, 0x86, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x96, 0x96, 0x96, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xB2, 0xB2, 0xB2, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCB, 0xCB, 0xCB, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xD7, 0xD7, 0xD7, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xDD, 0xDD, 0xDD, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xE3, 0xE3, 0xE3, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xEA, 0xEA, 0xEA, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xF1, 0xF1, 0xF1, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xF8, 0xF8, 0xF8, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xE7, 0xE7, 0xD6, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xEC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFB, 0xF0, 0x00 ),
        PALETTE_ENTRY( 0xA0, 0xA0, 0xA4, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x80, 0x80, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0xFF, 0x00, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x00, 0xFF, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0x00, 0xFF, 0x00 ),
        PALETTE_ENTRY( 0x00, 0xFF, 0xFF, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0xFF, 0x00 ),
    }
};

const BYTE g_abWin95CMAP[32768] = {
  0, 11, 11, 12, 60, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 11, 11, 12, 13, 60, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 11, 12, 13, 13, 14, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 12, 13, 13, 14, 14, 66, 66, 66, 66, 66,101,101,101,101,101,  4,  4,166,166,
166,166,166,199,199,199,199,199,199,199,252,252,252,
 33, 33, 14, 14, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,252,252,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,199,252,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,199,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,199,205,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,205,205,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,  6,  6,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,  6,  6,  6,  6,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 72, 72, 72, 72, 72, 72,107,107,107,  6,  6,  6,  6,  6,  6,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 78, 78, 78, 78, 78, 78,112,112,112,  6,  6,  6,  6,  6,  6,
129,129,129,178,178,178,178,178,178,178,211,211,211,
  2,  2,  2, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,  6,  6,  6,  6,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,  6,  6,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
250,250,250,250, 84, 84, 84, 84, 84,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250, 84, 84, 84,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250,250, 90,123,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
 11, 11, 12, 13, 60, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 11, 12, 13, 13, 14, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 12, 13, 13, 14, 14, 15, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 13, 13, 14, 14, 15, 15, 66, 66, 66, 66,101,101,101,101,101,  4,  4,166,166,
166,166,166,199,199,199,199,199,199,199,252,252,252,
 33, 14, 14, 15, 15, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,252,252,
 33, 33, 15, 15, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,205,205,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,  6,  6,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,  6,  6,  6,  6,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 72, 72, 72, 72, 72, 72,107,107,107,  6,  6,  6,  6,  6,  6,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 78, 78, 78, 78, 78, 78,112,112,112,  6,  6,  6,  6,  6,  6,
129,129,129,178,178,178,178,178,178,178,211,211,211,
  2,  2,  2, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,  6,  6,  6,  6,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,  6,  6,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
250,250,250,250, 84, 84, 84, 84, 84,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250, 90, 90, 90,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250, 90, 90, 90,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
 11, 12, 13, 13, 14, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 12, 13, 13, 14, 14, 15, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 13, 13, 14, 14, 15, 15, 15, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 13, 14, 14, 15, 15, 15, 16, 16, 66, 66,101,101,101,101,101,  4,  4,166,166,
166,166,166,199,199,199,199,199,199,199,252,252,252,
 14, 14, 15, 15, 15, 16, 16, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 15, 15, 15, 16, 16, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 15, 16, 16, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 33, 16, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,  6,  6,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,  6,  6,  6,  6,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 72, 72, 72, 72, 72, 72,107,107,107,  6,  6,  6,  6,  6,  6,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 78, 78, 78, 78, 78, 78,112,112,112,  6,  6,  6,  6,  6,  6,
129,129,129,178,178,178,178,178,178,178,211,211,211,
  2,  2,  2, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,  6,  6,  6,  6,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,  6,  6,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
250,250,250,250, 90, 90, 90, 90, 90,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250, 90, 90, 90, 90, 90,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250, 90, 90, 90, 90, 90,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
 12, 13, 13, 14, 14, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96,  4,  4,162,162,
162,162,162,196,196,196,196,196,196,196,252,252,252,
 13, 13, 14, 14, 15, 15, 61, 61, 61, 61, 96, 96, 96, 96, 96,  4,  4,162,162,
162,162,162,196,196,196,196,196,196,196,252,252,252,
 13, 14, 14, 15, 15, 15, 16, 16, 61, 61, 96, 96, 96, 96, 96,  4,  4,162,162,
162,162,162,196,196,196,196,196,196,196,252,252,252,
 14, 14, 15, 15, 15, 16, 16, 17, 17, 17,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 14, 15, 15, 15, 16, 16, 17, 17, 17, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 15, 15, 16, 16, 17, 17, 17, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,  6,  6,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
  2,  2,  2, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,  6,  6,  6,  6,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
  2,  2,  2, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,  6,  6,  6,  6,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,  6,  6,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
250,250,250, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250,250, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250,250, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 14, 14, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,252,252,
 29, 14, 14, 15, 15, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,252,252,
 14, 14, 15, 15, 15, 16, 16, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 14, 15, 15, 15, 16, 16, 17, 17, 17, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 15, 15, 16, 16, 17, 17, 17, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,196,252,
 29, 29, 15, 15, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,200,200,
 29, 15, 15, 15, 16, 16, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 15, 15, 16, 16, 17, 17, 17, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 20,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 52, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,196,200,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,200,200,
 29, 29, 15, 16, 16, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 20, 20,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 52, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,196,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,200,200,
 29, 29, 29, 16, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 21, 20, 20, 20, 20, 19, 19,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 20, 20, 19, 19,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 19,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 52, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 21, 20, 20, 20, 20, 19, 19,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 20, 20, 20, 20, 19, 19, 19, 18, 18,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 20, 20, 19, 19, 19, 18, 18,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 19, 19, 18, 18,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 18, 18,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 18,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,197,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,197,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,197,197,197,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 21, 20, 20, 20, 20, 19, 19,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 20, 20, 20, 20, 19, 19, 19, 18, 18,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 20, 20, 20, 20, 19, 19, 19, 18, 18, 18, 18,234,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 20, 20, 19, 19, 19, 18, 18, 18, 18,234,234,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 19, 19, 18, 18, 18, 18,234,234,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 18, 18, 18, 18,234,234,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 18, 18, 18,234,234,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 18,234,234,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73,234,234,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 57, 57, 57, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 57, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 57, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 20,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 20, 20,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 20, 20, 19, 19,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 20, 20, 19, 19, 19, 18, 18,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 20, 20, 19, 19, 19, 18, 18, 18, 18,234,234,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 19, 19, 18, 18, 18, 18,234,234,234,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18, 18,234,234,234,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18,234,234,234,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 19,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 19, 19, 18, 18,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 19, 19, 18, 18, 18, 18,234,234,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18, 18,234,234,234,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18,234,234,234,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,235,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 18, 18,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 18, 18, 18, 18,234,234,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18,234,234,234,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,235,235,235,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97,  5,  5,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97,  5,  5,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97,  5,  5,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 18,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 18, 18, 18,234,234,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 74, 74, 74, 74, 74, 74, 74,109,109,235,235,235,235,235,248,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 80, 80, 80, 80, 80, 80, 80,114,114,114,235,235,235,248,248,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,248,248,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
  1,  1,  1, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97,  5,  5,  5,  5,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97,  5,  5,  5,  5,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97,  5,  5,  5,  5,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,  5,  5,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 18,234,234,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 74, 74, 74, 74, 74, 74, 74,109,109,235,235,235,235,235,248,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 74, 74, 74, 74, 74, 74,109,235,235,235,235,235,248,248,248,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 80, 80, 80, 80, 80, 80,114,114,235,235,235,248,248,248,236,
145,145,145,180,180,180,180,180,180,180,213,213,213,
  3,  3,  3, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,248,248,248,236,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,248,236,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
  1,  1,  1,  1, 62, 62, 62, 62, 62, 62, 97, 97, 97,  5,  5,  5,  5,  5,  5,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1,  1, 62, 62, 62, 62, 62, 62, 97, 97, 97,  5,  5,  5,  5,  5,  5,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1,  1, 62, 62, 62, 62, 62, 62, 97, 97, 97,  5,  5,  5,  5,  5,  5,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,  5,  5,  5,  5,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68,234,234,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 74, 74, 74, 74, 74, 74, 74,109,109,235,235,235,235,235,248,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 74, 74, 74, 74, 74, 74,109,235,235,235,235,235,248,248,248,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 74, 74, 74, 74, 74, 74,235,235,235,235,235,248,248,248,236,
236,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 80, 80, 80, 80, 80, 80,114,235,235,235,248,248,248,236,236,
236,236,145,180,180,180,180,180,180,180,213,213,213,
  3,  3,  3,  3, 80, 80, 80, 80, 80, 80,114,114,114,248,248,248,236,236,236,
236,145,145,180,180,180,180,180,180,180,213,213,213,
  3,  3,  3, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,248,236,236,236,236,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,236,236,236,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,236,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
  1,  1,  1,  1, 63, 63, 63, 63, 63, 63, 98, 98, 98,  5,  5,  5,  5,  5,  5,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,  1, 63, 63, 63, 63, 63, 63, 98, 98, 98,  5,  5,  5,  5,  5,  5,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,  1, 63, 63, 63, 63, 63, 63, 98, 98, 98,  5,  5,  5,  5,  5,  5,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,  5,  5,  5,  5,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,235,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,235,235,235,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 75, 75, 75, 75, 75, 75, 75,110,110,110,235,235,235,248,248,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 75, 75, 75, 75, 75, 75,110,110,235,235,235,248,248,248,236,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 75, 75, 75, 75, 75, 75,110,235,235,235,248,248,248,236,236,
236,236,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 81, 81, 81, 81, 81, 81,115,115,235,248,248,248,236,236,236,
236,237,237,181,181,181,181,181,181,181,214,214,214,
  3,  3,  3,  3, 81, 81, 81, 81, 81, 81,115,115,115,248,248,236,236,236,236,
237,237,237,181,181,181,181,181,181,181,214,214,214,
  3,  3,  3, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,236,236,236,236,237,
237,237,237,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
  1,  1,  1,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98,  5,  5,  5,  5,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98,  5,  5,  5,  5,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98,  5,  5,  5,  5,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,  5,  5,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,248,248,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,248,248,248,236,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 75, 75, 75, 75, 75, 75,110,110,110,248,248,248,236,236,236,
236,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 81, 81, 81, 81, 81, 81,115,115,115,248,248,236,236,236,236,
237,237,237,181,181,181,181,181,181,181,214,214,214,
  3,  3,  3, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,236,236,236,236,237,
237,237,237,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31, 31, 31,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98,  5,  5,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31, 31,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98,  5,  5,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31, 31,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98,  5,  5,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,248,236,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,248,236,236,236,236,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,236,236,236,236,237,
237,237,237,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115, 28,146,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120, 28, 28,152,
152,152,239,239,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31, 31,233,233,233, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36, 36,233, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,236,236,236,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115, 28,146,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28,
146,146,239,239,239,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28, 28, 
28,239,239,239,239,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,239,239,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31, 31,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36,233,233,233, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,236,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115, 28, 28,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28,146,239,239,239,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28,239,239,239,239,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28, 28, 
28,239,239,239,239,239,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28,152,
152,239,239,239,239,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,239,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  8,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  8,  8,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31,233,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31,233,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31,233,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36,233,233,233, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28,146,239,239,239,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28, 28,239,239,239,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,  7,  7,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28, 28, 
28,239,239,239,239,  7,  7,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,239,239,  7,  7,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  7,  7,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  8,  8,  8,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,  8,  8,  8,  8,  8,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,  8,  8,  8,  8,  8,  8,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,  8,  8,  8,  8,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 32,233,233,233,233,233, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32,233,233,233,233,233, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32,233,233,233,233,233, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37,233,233,233,233, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116, 28, 28,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28,
147,147,239,239,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28, 
28, 28,239,239,239,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,  7,  7,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121, 28, 28, 28, 28, 28, 
28,239,239,239,239,  7,  7,  7,  7,  7,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28, 28, 
28,239,239,239,  7,  7,  7,  7,  7,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121, 28, 28,153,
153,239,239,  7,  7,  7,  7,  7,238,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,  8,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,  8,  8,  8,  8,  8,  8,  8,  8,188, 25, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,  8,  8,  8,  8,  8,  8,  8,  8, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,  8,  8,  8,  8,  8,  8,  8, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,  8,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32,233, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32,233, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32,233, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116, 28, 28,147,
147,147,239,239,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28,
147,239,239,239,239,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28, 
28,239,239,239,239,  7,  7,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28, 28, 
28,239,239,239,  7,  7,  7,  7,  7,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28,153,
153,239,239,  7,  7,  7,  7,  7,238,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,  8,188,240, 25, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,  8,  8,  8,  8,  8,  8,  8,  8, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,  8,  8,  8,  8,  8,  8,194, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,194,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,239,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116, 28, 28,147,
147,147,239,239,  7,  7,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28,153,
153,239,239,  7,  7,  7,  7,  7,238,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,188,240,240, 25, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,  8,240,240, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,  8,  8,  8,  8,  8,194,194, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,194,194,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99, 24, 24,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99, 24, 24,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99, 24, 24,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,  7,  7,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,238,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  8,  8,188,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,188,240,240,240,241, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,240,240,241, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,  8,194,194,241,241, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105, 24,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,  7,182,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,238,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,238,238,188,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  8,188,188,188,240,240,240,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  8,  8,188,240,240,240,241,241, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,240,240,241,241,242, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,194,194,241,241,242,242, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,242, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105, 24, 24,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 23,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,238,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,238,238,188,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26,188,188,188,240,240,240,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26,240,240,240,241,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26,240,240,241,241,242,242, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 27, 27,241,241,242,242,243, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159, 26, 27, 27, 27, 27,242,242,243,243, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194, 27, 27,243,243,243, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,243,243,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24, 24,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24, 24,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24, 24,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105, 24, 24, 24, 24, 
24,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 23,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 23, 23, 23,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 23, 23, 23, 23, 23, 23,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 23, 23, 23, 23,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 23, 23,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 23,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111, 22, 22,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111, 22, 22, 22, 22,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111, 22, 22, 22, 22,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116, 22, 22, 22, 22,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 22, 22,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7, 26,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26, 26,240,240,240,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 26,240,240,241,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 26,240,241,241,242,242,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 26,241,241,242,242,243,243,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 27, 27,242,242,243,243,243,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159, 26, 26, 26, 27, 27, 27, 27,243,243,243,244,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194, 27, 27, 27, 27, 27,243,243,244,244,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194, 27, 27, 27,243,244,244,244,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100, 24,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100, 24,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100, 24,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 23,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 23, 23, 23, 23,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 23, 23, 23, 23, 23, 23,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23, 23,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 23,227,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227,227, 22, 22,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227, 22, 22, 22, 22,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227, 22, 22, 22, 22, 22, 22,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117, 22, 22, 22, 22, 22, 22,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117, 22, 22,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26,189,189,241,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26, 26,241,241,242,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 26,241,242,242,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 27,242,242,243,243,243,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 27, 27, 27,243,243,243,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160, 26, 26, 27, 27, 27, 27,243,243,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195, 27, 27, 27, 27,243,244,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195, 27,244,244,244,245,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 23,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 23, 23, 23, 23,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 23, 23, 23, 23, 23, 23,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23, 23,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 23,227,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227,227, 22, 22,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227, 22, 22, 22, 22,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227, 22, 22, 22, 22, 22, 22,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117, 22, 22, 22, 22, 22, 22,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117, 22, 22,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26, 26,189,242,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 26, 27,243,243,243,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 27, 27,243,243,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160, 26, 26, 26, 27, 27, 27,243,244,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195, 27,244,244,244,245,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195,195,244,244,245,245,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 23,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 23, 23, 23, 23,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 23, 23, 23, 23, 23, 23,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23, 23,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 23,227,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227,227, 22, 22,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227, 22, 22, 22, 22,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227, 22, 22, 22, 22, 22, 22,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117, 22, 22, 22, 22, 22, 22,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117, 22, 22,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26,189,189,243,243,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26, 27, 27,243,244,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195, 27,244,244,244,245,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195,195,244,244,245,245,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195,195,244,245,245,255,
};

const BYTE g_abWin95ToNT5[256] ={
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  0, 14, 14, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 11, 30, 31,
 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 10, 12, 62, 63,
 64, 65, 13, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
 96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\nullstm.cpp ===
#include "priv.h"
#include "nullstm.h"

#ifndef UNIX

// A static empty stream implementation, for back compat & no memory hit
//
// Macros copied from cfdefs.h
//
#define STDMETHODX(fn)      HRESULT STDMETHODCALLTYPE fn
#define STDMETHODX_(ret,fn) ret STDMETHODCALLTYPE fn
class CNullStream {
public:
    IStream *vtable;
    
    STDMETHODX (QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHODX_(ULONG, AddRef)();
    STDMETHODX_(ULONG, Release)();

    STDMETHODX (Read)(void *pv, ULONG cb, ULONG *pcbRead) { if (pcbRead) *pcbRead = 0; return E_NOTIMPL; }
    STDMETHODX (Write)(void const *pv, ULONG cb, ULONG *pcbWritten) { if (pcbWritten) *pcbWritten = 0; return E_NOTIMPL; }
    STDMETHODX (Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition) { plibNewPosition->HighPart = plibNewPosition->LowPart = 0; return E_NOTIMPL; }
    STDMETHODX (SetSize)(ULARGE_INTEGER libNewSize) { return E_NOTIMPL; }
    STDMETHODX (CopyTo)(IStream *, ULARGE_INTEGER, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten) { if (pcbRead) pcbRead->LowPart = pcbRead->HighPart = 0; if (pcbWritten) pcbWritten->LowPart = pcbWritten->HighPart = 0; return E_NOTIMPL; }
    STDMETHODX (Commit)(DWORD) { return E_NOTIMPL; }
    STDMETHODX (Revert)() { return E_NOTIMPL; }
    STDMETHODX (LockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODX (UnlockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODX (Stat)(STATSTG *, DWORD) { return E_NOTIMPL; }
    STDMETHODX (Clone)(IStream **ppstm) { *ppstm = NULL; return E_NOTIMPL; }
};

STDMETHODIMP CNullStream::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj=this;
        // DllAddRef(); // if this dll supported CoCreateInstance
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}
STDMETHODIMP_(ULONG) CNullStream::AddRef()
{
    // DllAddRef(); // if this dll supported CoCreateInstance
    return 2;
}
STDMETHODIMP_(ULONG) CNullStream::Release()
{
    // DllRelease(); // if this dll supported CoCreateInstance
    return 1;
}

// We need the C vtable declaration, but this is .CPP.
// Simulate the vtable, swiped from objidl.h and touched up.
//
typedef struct IStreamVtbl
{
    HRESULT ( STDMETHODCALLTYPE CNullStream::*QueryInterface )(REFIID riid, void **ppvObject);
    ULONG ( STDMETHODCALLTYPE CNullStream::*AddRef )( );
    ULONG ( STDMETHODCALLTYPE CNullStream::*Release )( );
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Read )( 
        void *pv,
        ULONG cb,
        ULONG *pcbRead);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Write )( 
        const void *pv,
        ULONG cb,
        ULONG *pcbWritten);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Seek )( 
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*SetSize )( 
        ULARGE_INTEGER libNewSize);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*CopyTo )( 
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Commit )( 
        DWORD grfCommitFlags);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Revert )( );
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*LockRegion )( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*UnlockRegion )( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Stat )( 
        STATSTG *pstatstg,
        DWORD grfStatFlag);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Clone )( 
        IStream **ppstm);
    
} IStreamVtbl;


IStream* SHConstNullStream()
{
    static const IStreamVtbl c_NullStream = {
        CNullStream::QueryInterface, 
        CNullStream::AddRef,
        CNullStream::Release,
        CNullStream::Read,
        CNullStream::Write,
        CNullStream::Seek,
        CNullStream::SetSize,
        CNullStream::CopyTo,
        CNullStream::Commit,
        CNullStream::Revert,
        CNullStream::LockRegion,
        CNullStream::UnlockRegion,
        CNullStream::Stat,
        CNullStream::Clone,
    };
    static const void * vtable = (void*)&c_NullStream;

    return (IStream*)&vtable;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\path.c ===
#include "priv.h"
#include "privpath.h"

#define CH_WHACK TEXT(FILENAME_SEPARATOR)
#define SZ_WHACK TEXT(FILENAME_SEPARATOR_STR)

#include <platform.h>


// Warning this define is in NTDEF.H but not winnt.h...
#ifdef UNICODE
typedef WCHAR TUCHAR;
#else
typedef unsigned char TUCHAR;
#endif

#ifdef UNICODE // {
//***   FAST_CharNext -- fast CharNext for path operations
// DESCRIPTION
//  when we're just stepping thru chars in a path, a simple '++' is fine.
#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#ifdef DEBUG
LPWSTR WINAPI
DBNotNULL(LPCWSTR lpszCurrent)
{
    ASSERT(*lpszCurrent);
    return (LPWSTR) lpszCurrent;
}
#else
#define DBNotNULL(p)    (p)
#endif

#else // }{
#define FAST_CharNext(p)    CharNext(p)
#endif // }

static const TCHAR c_szPATH[] = TEXT("PATH");
static const TCHAR c_szEllipses[] = TEXT("...");

//
// Inline function to check for a double-backslash at the
// beginning of a string
//

static __inline BOOL DBL_BSLASH(LPCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}


#ifdef DBCS

// NOTE:
// LCMAP_IGNOREDBCS is a private bit has been redefined to
// 0x80000000 in NT5 source tree becuase it conflicts with
// another public bit.
// To make this code work with the OLD platforms, namely
// Win95 and OSRs. We have to define this flag.

#define LCMAP_IGNOREDBCS_WIN95 0x01000000

//
// This is supposed to work only with Path string.
//
int CaseConvertPathExceptDBCS(LPTSTR pszPath, int cch, BOOL fUpper)
{
    TCHAR szTemp[MAX_PATH];
    int   cchUse;
    DWORD fdwMap = (fUpper? LCMAP_UPPERCASE:LCMAP_LOWERCASE);

    // APPCOMPAT !!! (ccteng)
    // Do we need to check for Memphis? Is Memphis shipping a
    // kernel compiled with new headers?

    // LCMAP_IGNOREDBCS is ignored on NT.
    // And also this flag has been redefined in NT5 headers to
    // resolve a conflict which broke the backward compatibility.
    // So we only set the old flag when it's NOT running on NT.

    cchUse = (cch == 0)? lstrlen(pszPath): cch;

    // LCMapString cannot deal with src/dst in the same address.
    //
    if (pszPath)
    {
        if (SUCCEEDED(StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszPath)))
        {
            return LCMapString(LOCALE_SYSTEM_DEFAULT,fdwMap, szTemp, cchUse, pszPath, cchUse);
        }
    }
    return 0;
}

STDAPI_(LPTSTR) CharLowerNoDBCS(LPTSTR psz)
{
    if(CaseConvertPathExceptDBCS(psz, 0, FALSE))
    {
        return psz;
    }
    return NULL;
}

STDAPI_(LPTSTR) CharUpperNoDBCS(LPTSTR psz)
{
    if(CaseConvertPathExceptDBCS(psz, 0, TRUE))
    {
        return psz;
    }
    return NULL;
}

UINT CharLowerBuffNoDBCS(LPTSTR lpsz, UINT cb)
{
    return (UINT)CaseConvertPathExceptDBCS(lpsz, cb, FALSE);
}

UINT CharUpperBuffNoDBCS(LPTSTR lpsz, UINT cb)
{
    return (UINT)CaseConvertPathExceptDBCS(lpsz, cb, TRUE);
}
#endif // DBCS


// FEATURE, we should validate the sizes of all path buffers by filling them
// with MAX_PATH fill bytes.


/*----------------------------------------------------------
Purpose: converts a file path to make it look a bit better if
         it is all upper case characters.

Returns:
*/
STDAPI_(BOOL)
PathMakePretty(LPTSTR lpPath)
{
    LPTSTR lp;

    RIPMSG(lpPath && IS_VALID_STRING_PTR(lpPath, -1), "PathMakePretty: caller passed bad lpPath");

    if (!lpPath)
    {
        return FALSE;
    }

    // REVIEW: INTL need to deal with lower case chars in (>127) range?

    // check for all uppercase
    for (lp = lpPath; *lp; lp = FAST_CharNext(lp))
    {
        if ((*lp >= TEXT('a')) && (*lp <= TEXT('z')) || IsDBCSLeadByte(*lp))
        {
            // this is a LFN or DBCS, dont mess with it
            return FALSE;
        }
    }

#ifdef DBCS
    // In order to be compatible with the file system, we cannot
    // case convert DBCS Roman characters.
    //
    CharLowerNoDBCS(lpPath);
    CharUpperBuffNoDBCS(lpPath, 1);
#else
    CharLower(lpPath);
    CharUpperBuff(lpPath, 1);
#endif

    return TRUE;        // did the conversion
}

// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// "foo.exe bar.txt"    -> "bar.txt"
// "foo.exe"            -> ""
//
// Spaces in filenames must be quoted.
// " "A long name.txt" bar.txt " -> "bar.txt"

STDAPI_(LPTSTR)
PathGetArgs(LPCTSTR pszPath)
{
    RIPMSG(!pszPath || IS_VALID_STRING_PTR(pszPath, -1), "PathGetArgs: caller passed bad pszPath");

    if (pszPath)
    {
        BOOL fInQuotes = FALSE;

        while (*pszPath)
        {
            if (*pszPath == TEXT('"'))
            {
                fInQuotes = !fInQuotes;
            }
            else if (!fInQuotes && *pszPath == TEXT(' '))
            {
                return (LPTSTR)pszPath+1;
            }

            pszPath = FAST_CharNext(pszPath);
        }
    }

    return (LPTSTR)pszPath;
}


/*----------------------------------------------------------
Purpose: Remove arguments from pszPath.

Returns: --
Cond:    --
*/
STDAPI_(void)
PathRemoveArgs(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathRemoveArgs: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pArgs = PathGetArgs(pszPath);
    
        if (*pArgs)
        {
            // clobber the ' '
            *(pArgs - 1) = TEXT('\0');
        }
        else
        {
            // Handle trailing space
            pArgs = CharPrev(pszPath, pArgs);

            if (*pArgs == TEXT(' '))
            {
                *pArgs = TEXT('\0');
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Determines if a file exists.  This is fast.

Returns: TRUE if it exists

  ***********************************************************************************************
  !!NOTE!!
  If you want to see if a UNC server, or UNC server\share exists (eg "\\pyrex" or "\\banyan\iptd"),
  then you have to call PathFileExistsAndAttributes, as this function will fail on the UNC server
  and server\share case!
  ***********************************************************************************************

*/
STDAPI_(BOOL)
PathFileExists(LPCTSTR pszPath)
{
    BOOL fResult = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFileExists: caller passed bad pszPath");

#ifdef DEBUG
    if (PathIsUNCServer(pszPath) || PathIsUNCServerShare(pszPath))
    {
        TraceMsg(TF_WARNING, "PathFileExists: called with a UNC server or server-share, use PathFileExistsAndAttributes for correct results in this case!!");
    }
#endif

    if (pszPath)
    {
        DWORD dwErrMode;

        dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        fResult = (BOOL)(GetFileAttributes(pszPath) != (DWORD)-1);

        SetErrorMode(dwErrMode);
    }

    return fResult;
}


/*----------------------------------------------------------
Purpose: Determines if a file exists, and returns the attributes
         of the file.

Returns: TRUE if it exists. If the function is able to get the file attributes and the
         caller passed a pdwAttributes, it will fill them in, else it will fill in -1.

  *******************************************************************************************************
  !!NOTE!!
  If you want to fail on UNC servers (eg "\\pyrex") or UNC server\shares (eg "\\banyan\iptd") then you
  should call PathFileExists and not this api!
  *******************************************************************************************************

*/
STDAPI_(BOOL) PathFileExistsAndAttributes(LPCTSTR pszPath, OPTIONAL DWORD* pdwAttributes)
{
    DWORD dwAttribs;
    BOOL fResult = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFileExistsAndAttributes: caller passed bad pszPath");

    if (pdwAttributes)
    {
        *pdwAttributes = (DWORD)-1;
    }
        
    if (pszPath)
    {
        DWORD dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        dwAttribs = GetFileAttributes(pszPath);

        if (pdwAttributes)
        {
            *pdwAttributes = dwAttribs;
        }

        if (dwAttribs == (DWORD)-1)
        {
            if (PathIsUNCServer(pszPath) || PathIsUNCServerShare(pszPath))
            {
                NETRESOURCE nr = {0};
                LPTSTR lpSystem = NULL;
                DWORD dwRet;
                DWORD dwSize;
                TCHAR Buffer[256];

                nr.dwScope = RESOURCE_GLOBALNET;
                nr.dwType = RESOURCETYPE_ANY;
                nr.lpRemoteName = (LPTSTR)pszPath;
                dwSize = sizeof(Buffer);
    
                // the net api's might at least tell us if this exists or not in the \\server or \\server\share cases
                // even if GetFileAttributes() failed
                dwRet = WNetGetResourceInformation(&nr, Buffer, &dwSize, &lpSystem);

                fResult = (dwRet == WN_SUCCESS || dwRet == WN_MORE_DATA);
            }
        }
        else
        {
            // GetFileAttributes succeeded!
            fResult = TRUE;
        }

        SetErrorMode(dwErrMode);
    }

    return fResult;
}


static const TCHAR c_szDotPif[] = TEXT(".pif");
static const TCHAR c_szDotCom[] = TEXT(".com");
static const TCHAR c_szDotBat[] = TEXT(".bat");
static const TCHAR c_szDotCmd[] = TEXT(".cmd");
static const TCHAR c_szDotLnk[] = TEXT(".lnk");
static const TCHAR c_szDotExe[] = TEXT(".exe");
static const TCHAR c_szNone[] = TEXT("");
// NB Look for .pif's first so that bound OS/2 apps (exe's)
// can have their dos stubs run via a pif.
//
// The COMMAND.COM search order is COM then EXE then BAT.  Windows 3.x
// matched this search order.  We need to search in the same order.

//  *** WARNING *** The order of the PFOPEX_ flags must be identical to the order
//  of the c_aDefExtList array.  PathFileExistsDefExt relies on it.
static const LPCTSTR c_aDefExtList[] = {
    c_szDotPif,
    c_szDotCom,
    c_szDotExe,
    c_szDotBat,
    c_szDotLnk,
    c_szDotCmd,
    c_szNone
};
#define IEXT_NONE (ARRAYSIZE(c_aDefExtList) - 1)
//  *** END OF WARNING ***

static UINT _FindInDefExts(LPCTSTR pszExt, UINT fExt)
{
    UINT iExt = 0;
    for (; iExt < ARRAYSIZE(c_aDefExtList); iExt++, fExt >>= 1) 
    {
        //  let NONE match up even tho there is 
        //  no bit for it.  that way find folders
        //  without a trailing dot correctly
        if (fExt & 1 || (iExt == IEXT_NONE)) 
        {
            if (0 == StrCmpI(pszExt, c_aDefExtList[iExt]))
                break;
        }
    }
    return iExt;
}

// pszPath assumed to be MAX_PATH or larger...
static BOOL _ApplyDefaultExts(LPTSTR pszPath, UINT fExt, DWORD *pdwAttribs)
{
    UINT cchPath = lstrlen(pszPath);
    //  Bail if not enough space for 4 more chars
    if (cchPath + ARRAYSIZE(c_szDotPif) < MAX_PATH) 
    {
        LPTSTR pszPathEnd = pszPath + cchPath;
        UINT cchFileSpecEnd = (UINT)(pszPathEnd - PathFindFileName(pszPath));
        DWORD dwAttribs = (DWORD) -1;
        // init to outside bounds
        UINT iExtBest = ARRAYSIZE(c_aDefExtList);  
        WIN32_FIND_DATA wfd = {0};
        
        //  set it up for the find
        if (SUCCEEDED(StringCchCat(pszPath, MAX_PATH, TEXT(".*"))))
        {
            HANDLE h = FindFirstFile(pszPath, &wfd);
            if (h != INVALID_HANDLE_VALUE)
            {
                do 
                {
                    //  use cchFileSpecEnd, instead of PathFindExtension(),
                    //  so that if there is foo.bat and foo.bar.exe
                    //  we dont incorrectly return foo.exe.
                    //  this way we always compare apples to apples.
                    UINT iExt = _FindInDefExts((wfd.cFileName + cchFileSpecEnd), fExt);
                    if (iExt < iExtBest)
                    {
                        iExtBest = iExt;
                        dwAttribs = wfd.dwFileAttributes;
                    }

                } while (FindNextFile(h, &wfd));

                FindClose(h);
            }
            
            if ((iExtBest < ARRAYSIZE(c_aDefExtList)) &&
                SUCCEEDED(StringCchCopyEx(pszPathEnd, MAX_PATH - cchPath, c_aDefExtList[iExtBest], NULL, NULL, STRSAFE_NO_TRUNCATION)))
            {
                if (pdwAttribs)
                {
                    *pdwAttribs = dwAttribs;
                }
                 return TRUE;
            }
            else
            {
                // Get rid of any extension
                *pszPathEnd = TEXT('\0');
            }
        }
    }

    return FALSE;
}

//------------------------------------------------------------------
// Return TRUE if a file exists (by attribute check) after
// applying a default extensions (if req).
STDAPI_(BOOL) PathFileExistsDefExtAndAttributes(LPTSTR pszPath, UINT fExt, DWORD *pdwAttribs)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFileExistsDefExt: caller passed bad pszPath");

    if (fExt)
    {
        RIPMSG(!pszPath || !IS_VALID_STRING_PTR(pszPath, -1) || // avoid RIP when above RIP would have caught it
               IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathFileExistsDefExt: caller passed bad pszPath");
        DEBUGWhackPathString(pszPath, MAX_PATH);
    }

    if (pdwAttribs)
        *pdwAttribs = (DWORD) -1;

    if (pszPath)
    {
        // Try default extensions?
        if (fExt && (!*PathFindExtension(pszPath) || !(PFOPEX_OPTIONAL & fExt)))
        {
            return _ApplyDefaultExts(pszPath, fExt, pdwAttribs);
        }
        else
        {
            return PathFileExistsAndAttributes(pszPath, pdwAttribs);
        }
    }
    return FALSE;
}

//------------------------------------------------------------------
// Return TRUE if a file exists (by attribute check) after
// applying a default extensions (if req).
STDAPI_(BOOL) PathFileExistsDefExt(LPTSTR pszPath, UINT fExt)
{
    // No sense sticking an extension on a server or share...
    if (PathIsUNCServer(pszPath) || PathIsUNCServerShare(pszPath))
    {
        return FALSE;
    }
    else return PathFileExistsDefExtAndAttributes(pszPath, fExt, NULL);
}


// walk through a path type string (semicolon seperated list of names)
// this deals with spaces and other bad things in the path
//
// call with initial pointer, then continue to call with the
// result pointer until it returns NULL
//
// input: "C:\FOO;C:\BAR;"
//
// in:
//      lpPath      starting point of path string "C:\foo;c:\dos;c:\bar"
//      cchPath     size of szPath
//
// out:
//      szPath      buffer with path piece
//
// returns:
//      pointer to next piece to be used, NULL if done
//
//
// FEATURE, we should write some test cases specifically for this code
//
STDAPI_(LPCTSTR) NextPath(LPCTSTR lpPath, LPTSTR szPath, int cchPath)
{
    LPCTSTR lpEnd;

    if (!lpPath)
        return NULL;

    // skip any leading ; in the path...
    while (*lpPath == TEXT(';'))
    {
        lpPath++;
    }

    // See if we got to the end
    if (*lpPath == 0)
    {
        // Yep
        return NULL;
    }

    lpEnd = StrChr(lpPath, TEXT(';'));

    if (!lpEnd)
    {
        lpEnd = lpPath + lstrlen(lpPath);
    }

    StrCpyN(szPath, lpPath, min((DWORD)cchPath, (DWORD)(lpEnd - lpPath + 1)));

    szPath[lpEnd-lpPath] = TEXT('\0');

    PathRemoveBlanks(szPath);

    if (szPath[0])
    {
        if (*lpEnd == TEXT(';'))
        {
            // next path string (maybe NULL)
            return lpEnd + 1;
        }
        else
        {
            // pointer to NULL
            return lpEnd;
        }
    }
    else 
    {
        return NULL;
    }
}


// check to see if a dir is on the other dir list
// use this to avoid looking in the same directory twice (don't make the same dos call)

BOOL IsOtherDir(LPCTSTR pszPath, LPCTSTR *ppszOtherDirs)
{
    for (;*ppszOtherDirs; ppszOtherDirs++)
    {
        if (lstrcmpi(pszPath, *ppszOtherDirs) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// fully qualify a path by walking the path and optionally other dirs
//
// in:
//      ppszOtherDirs a list of LPCTSTRs to other paths to look
//      at first, NULL terminated.
//
//  fExt
//      PFOPEX_ flags specifying what to look for (exe, com, bat, lnk, pif)
//
// in/out
//      pszFile     non qualified path, returned fully qualified
//                      if found (return was TRUE), otherwise unaltered
//                      (return FALSE);
//
// returns:
//      TRUE        the file was found on and qualified
//      FALSE       the file was not found
//
STDAPI_(BOOL) PathFindOnPathEx(LPTSTR pszFile, LPCTSTR* ppszOtherDirs, UINT fExt)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szFullPath[256];       // Default size for buffer
    LPTSTR pszEnv = NULL;        // Use if greater than default
    LPCTSTR lpPath;
    int i;

    RIPMSG(pszFile && IS_VALID_STRING_PTR(pszFile, -1) && IS_VALID_WRITE_BUFFER(pszFile, TCHAR, MAX_PATH), "PathFindOnPathEx: caller passed bad pszFile");
    DEBUGWhackPathString(pszFile, MAX_PATH);

    if (!pszFile) // REVIEW: do we need to check !*pszFile too?
        return FALSE;

    // REVIEW, we may want to just return TRUE here but for
    // now assume only file specs are allowed

    if (!PathIsFileSpec(pszFile))
        return FALSE;

    // first check list of other dirs

    for (i = 0; ppszOtherDirs && ppszOtherDirs[i] && *ppszOtherDirs[i]; i++)
    {
        PathCombine(szPath, ppszOtherDirs[i], pszFile);
        if (PathFileExistsDefExt(szPath, fExt))
        {
            StringCchCopy(pszFile, MAX_PATH, szPath);
            return TRUE;
        }
    }

    // Look in system dir (system for Win95, system32 for NT)
    //  - this should probably be optional.
    GetSystemDirectory(szPath, ARRAYSIZE(szPath));
    if (!PathAppend(szPath, pszFile))
        return FALSE;

    if (PathFileExistsDefExt(szPath, fExt))
    {
        StringCchCopy(pszFile, MAX_PATH, szPath);
        return TRUE;
    }

    {
#ifdef WX86
        // Look in WX86 system  directory (WindDir\Sys32x86)
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = TRUE;
        GetSystemDirectory(szPath, ARRAYSIZE(szPath));
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;

        if (!PathAppend(szPath, pszFile))
            return FALSE;

        if (PathFileExistsDefExt(szPath, fExt))
        {
            StringCchCopy(pszFile, MAX_PATH, szPath);
            return TRUE;
        }
#endif

        // Look in WOW directory (\nt\system instead of \nt\system32)
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));

        if (!PathAppend(szPath,TEXT("System")))
            return FALSE;
        if (!PathAppend(szPath, pszFile))
            return FALSE;

        if (PathFileExistsDefExt(szPath, fExt))
        {
            StringCchCopy(pszFile, MAX_PATH, szPath);
            return TRUE;
        }
    }

    // Look in windows dir - this should probably be optional.
    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    if (!PathAppend(szPath, pszFile))
        return FALSE;

    if (PathFileExistsDefExt(szPath, fExt))
    {
        StringCchCopy(pszFile, MAX_PATH, szPath);
        return TRUE;
    }

    // Look along the path.
    i = GetEnvironmentVariable(c_szPATH, szFullPath, ARRAYSIZE(szFullPath));
    if (i >= ARRAYSIZE(szFullPath))
    {
        pszEnv = (LPTSTR)LocalAlloc(LPTR, i*sizeof(TCHAR)); // no need for +1, i includes it
        if (pszEnv == NULL)
            return FALSE;

        GetEnvironmentVariable(c_szPATH, pszEnv, i);

        lpPath = pszEnv;
    }
    else
    {
        if (i == 0)
            return FALSE;

        lpPath = szFullPath;
    }

    while (NULL != (lpPath = NextPath(lpPath, szPath, ARRAYSIZE(szPath))))
    {
        if (!ppszOtherDirs || !IsOtherDir(szPath, ppszOtherDirs))
        {
            PathAppend(szPath, pszFile);
            if (PathFileExistsDefExt(szPath, fExt))
            {
                StringCchCopy(pszFile, MAX_PATH, szPath);
                if (pszEnv)
                    LocalFree((HLOCAL)pszEnv);
                return TRUE;
            }
        }
    }

    if (pszEnv)
        LocalFree((HLOCAL)pszEnv);

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Find the given file on the path.

Returns:
Cond:    --
*/
STDAPI_(BOOL) PathFindOnPath(LPTSTR pszFile, LPCTSTR* ppszOtherDirs)
{
    return PathFindOnPathEx(pszFile, ppszOtherDirs, PFOPEX_NONE);
}


// returns a pointer to the extension of a file.
//
// in:
//      qualified or unqualfied file name
//
// returns:
//      pointer to the extension of this file.  if there is no extension
//      as in "foo" we return a pointer to the NULL at the end
//      of the file
//
//      foo.txt     ==> ".txt"
//      foo         ==> ""
//      foo.        ==> "."
//
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFindExtension: caller passed bad pszPath");

    if (pszPath)
    {
        for (; *pszPath; pszPath = FAST_CharNext(pszPath))
        {
            switch (*pszPath)
            {
                case TEXT('.'):
                    pszDot = pszPath;   // remember the last dot
                    break;

                case CH_WHACK:
                case TEXT(' '):         // extensions can't have spaces
                    pszDot = NULL;      // forget last dot, it was in a directory
                    break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}


//
// Find if a given pathname contains any one of the suffixes in a given array of suffixes
//
// in:
//      pszPath     A filename with or without a path.
//
//      apszSuffix   An array of suffixes that we are looking for.
//
// returns:
//      pointer to the suffix in pszPath, if it exists.
//      NULL is returned if the given path does not end with the given suffix.
//
//  NOTE:  This does a CASE SENSITIVE comparison!!! So, the suffix will have to match exactly.
//
STDAPI_(LPCTSTR) PathFindSuffixArray(LPCTSTR pszPath, const LPCTSTR* apszSuffix, int iArraySize)
{
    RIPMSG((iArraySize>=0 && (pszPath && IS_VALID_STRING_PTR(pszPath, -1) && apszSuffix)), "PathFindSuffixArray: caller passed bad parameters");

    if (pszPath && apszSuffix)
    {
        int     iLenSuffix;
        int     iLenPath   = lstrlen(pszPath);
        LPCTSTR pszTail;
        int     i;

        for(i = 0; i< iArraySize; i++)
        {
            iLenSuffix = lstrlen(apszSuffix[i]);
            if(iLenPath < iLenSuffix)
                continue;

            // Let's get to a pointer to the tail piece which is the same length as the suffix
            // we are looking for.
            pszTail = (LPCTSTR)(pszPath+iLenPath-iLenSuffix);

#ifndef UNICODE
            {
                LPCSTR  pszTemp = pszTail;
            
                // In the ANSI world, pszTemp could be in the middle of a DBCS character.
                // So, move pszTemp such that it points to the begining of a valid character Lead char.
                while(pszTemp > pszPath)
                {
                    pszTemp--;
                    if(!IsDBCSLeadByte(*pszTemp))
                    {
                        // Since pszTemp is pointing to the FIRST trail Byte, the next byte must be a
                        // valid character. Move pszTemp to point to a valid character.
                        pszTemp++;
                        break;
                    }
                }

                // Everything between pszTemp and pszTail is nothing but lead characters. So, see if they 
                // are Odd or Even number of them.
                if(((int)(pszTail - pszTemp)&1) && (pszTail > pszPath))
                {
                    // There are odd number of lead bytes. That means that pszTail is definitely in the
                    // middle of a DBCS character. Move it to such that it points to a valid char.
                    pszTail--;
                }
            }
#endif

            if(!lstrcmp(pszTail, apszSuffix[i]))
                return pszTail;
        }
    }

    //Given suffix is not found in the array!
    return NULL;
}


// add .exe to a file name (if no extension was already there)
//
// in:
//      pszExtension    extension to tag on, if NULL .exe is assumed
//                      (".bat", ".txt", etc)
//
// in/out:
//      pszPath     path string to modify
//
//
// returns:
//      TRUE    added .exe (there was no extension to begin with)
//      FALSE   didn't change the name (it already had an extension)

STDAPI_(BOOL) PathAddExtension(LPTSTR pszPath, LPCTSTR pszExtension)
{
    BOOL bRet = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathAddExtension: caller passed bad pszPath");
    RIPMSG(!pszExtension || IS_VALID_STRING_PTR(pszExtension, -1), "PathAddExtension: caller passed bad pszExtension");
    DEBUGWhackPathString(pszPath, MAX_PATH);

    if (pszPath)
    {
        if (*PathFindExtension(pszPath) == 0 && ((lstrlen(pszPath) + lstrlen(pszExtension ? pszExtension : c_szDotExe)) < MAX_PATH))
        {
            if (pszExtension == NULL)
            {
                pszExtension = c_szDotExe;
            }

            bRet = SUCCEEDED(StringCchCatEx(pszPath, MAX_PATH, pszExtension, NULL, NULL, STRSAFE_NO_TRUNCATION));
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Remove the extension from pszPath, if one exists.

Returns: --
Cond:    --
*/
STDAPI_(void) PathRemoveExtension(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathRemoveExtension: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pExt = PathFindExtension(pszPath);
        if (*pExt)
        {
            ASSERT(*pExt == TEXT('.'));
            *pExt = 0;    // null out the "."
        }
    }
}


/*----------------------------------------------------------
Purpose: Renames the extension

Returns: FALSE if not enough room
Cond:    --
*/
STDAPI_(BOOL) PathRenameExtension(LPTSTR pszPath, LPCTSTR pszExt)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathRenameExtension: caller passed bad pszPath");
    RIPMSG(pszExt && IS_VALID_STRING_PTR(pszExt, -1), "PathRenameExtension: caller passed bad pszExt");
    DEBUGWhackPathString(pszPath, MAX_PATH);

    if (pszPath && pszExt)
    {
        LPTSTR pCurExt = PathFindExtension(pszPath);  // Rets ptr to end of str if none
        int cchNewExt = lstrlen(pszExt);
        size_t cchCurOther = pCurExt - pszPath;

        if (cchNewExt + cchCurOther + 1 > MAX_PATH)  // +1 for the null terminator
        {
            return FALSE;
        }

        StringCchCopy(pCurExt, MAX_PATH - cchCurOther, pszExt);
        return TRUE;
    }
    return FALSE;
}


// find the next slash or null terminator
LPCTSTR StrSlash(LPCTSTR psz)
{
    for (; *psz && *psz != CH_WHACK; psz = FAST_CharNext(psz));

    return psz;
}


//
// in:
//      pszFile1 -- fully qualified path name to file #1.
//      pszFile2 -- fully qualified path name to file #2.
//
// out:
//      pszPath  -- pointer to a string buffer (may be NULL)
//
// returns:
//      length of output buffer not including the NULL
//
// examples:
//      c:\win\desktop\foo.txt
//      c:\win\tray\bar.txt
//      -> c:\win
//
//      c:\                                ;
//      c:\                                ;
//      -> c:\  NOTE, includes slash
//
// Returns:
//      Length of the common prefix string usually does NOT include
//      trailing slash, BUT for roots it does.
//
STDAPI_(int) PathCommonPrefix(LPCTSTR pszFile1, LPCTSTR pszFile2, LPTSTR  pszPath)
{
    RIPMSG(pszFile1 && IS_VALID_STRING_PTR(pszFile1, -1), "PathCommonPrefix: caller passed bad pszFile1");
    RIPMSG(pszFile2 && IS_VALID_STRING_PTR(pszFile2, -1), "PathCommonPrefix: caller passed bad pszFile2");
    RIPMSG(!pszPath || IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathCommonPrefix: caller passed bad pszPath");

    if (pszFile1 && pszFile2)
    {
        LPCTSTR psz1, psz2, pszNext1, pszNext2, pszCommon;
        int cch;

        pszCommon = NULL;
        if (pszPath)
            *pszPath = TEXT('\0');

        psz1 = pszFile1;
        psz2 = pszFile2;

        // special cases for UNC, don't allow "\\" to be a common prefix

        if (DBL_BSLASH(pszFile1))
        {
            if (!DBL_BSLASH(pszFile2))
                return 0;

            psz1 = pszFile1 + 2;
        }
        if (DBL_BSLASH(pszFile2))
        {
            if (!DBL_BSLASH(pszFile1))
                return 0;

            psz2 = pszFile2 + 2;
        }

        while (1)
        {
            if (!(*psz1 != CH_WHACK && *psz2 != CH_WHACK))
                TraceMsg(TF_WARNING, "PathCommonPrefix: caller passed in ill-formed or non-qualified path");

            pszNext1 = StrSlash(psz1);
            pszNext2 = StrSlash(psz2);

            cch = (int) (pszNext1 - psz1);

            if (cch != (pszNext2 - psz2))
                break;      // lengths of segments not equal

            if (StrIntlEqNI(psz1, psz2, cch))
                pszCommon = pszNext1;
            else
                break;

            ASSERT(*pszNext1 == TEXT('\0') || *pszNext1 == CH_WHACK);
            ASSERT(*pszNext2 == TEXT('\0') || *pszNext2 == CH_WHACK);

            if (*pszNext1 == TEXT('\0'))
                break;

            psz1 = pszNext1 + 1;

            if (*pszNext2 == TEXT('\0'))
                break;

            psz2 = pszNext2 + 1;
        }

        if (pszCommon)
        {
            cch = (int) (pszCommon - pszFile1);

            // special case the root to include the slash
            if (cch == 2)
            {
                ASSERT(pszFile1[1] == TEXT(':'));
                cch++;
            }
        }
        else
            cch = 0;

        if (pszPath && (cch < MAX_PATH))
        {
            CopyMemory(pszPath, pszFile1, cch * sizeof(TCHAR));
            pszPath[cch] = TEXT('\0');
        }

        return cch;
    }

    return 0;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if pszPrefix is the full prefix of pszPath.

Returns:
Cond:    --
*/
STDAPI_(BOOL) PathIsPrefix(IN LPCTSTR  pszPrefix, IN LPCTSTR  pszPath)
{
    RIPMSG(pszPrefix && IS_VALID_STRING_PTR(pszPrefix, -1), "PathIsPrefix: caller passed bad pszPrefix");
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsPrefix: caller passed bad pszPath");

    if (pszPrefix && pszPath)
    {
        int cch = PathCommonPrefix(pszPath, pszPrefix, NULL);

        return (lstrlen(pszPrefix) == cch);
    }
    return FALSE;
}


static const TCHAR c_szDot[] = TEXT(".");
static const TCHAR c_szDotDot[] = TEXT("..");

static const TCHAR c_szDotDotSlash[] = TEXT("..\\");


// in:
//      pszFrom         base path, including filespec!
//      pszTo           path to be relative to pszFrom
// out:
//      relative path to construct pszTo from the base path of pszFrom
//
//      c:\a\b\FileA
//      c:\a\x\y\FileB
//      -> ..\x\y\FileB
//
STDAPI_(BOOL) PathRelativePathTo(LPTSTR pszPath, LPCTSTR pszFrom, DWORD dwAttrFrom, LPCTSTR pszTo, DWORD dwAttrTo)
{
#ifdef DEBUG
    TCHAR szFromCopy[MAX_PATH];
    TCHAR szToCopy[MAX_PATH];

    RIPMSG(pszPath && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathRelativePathTo: caller passed bad pszPath");
    RIPMSG(pszFrom && IS_VALID_STRING_PTR(pszFrom, -1), "PathRelativePathTo: caller passed bad pszFrom");
    RIPMSG(pszTo && IS_VALID_STRING_PTR(pszTo, -1), "PathRelativePathTo: caller passed bad pszTo");

    // we make copies of the pszFrom and pszTo buffers in case one of the strings they are passing is a pointer
    // inside pszPath buffer. If this were the case, it would be trampled when we call DEBUGWhackPathBuffer().
    if (pszFrom)
    {
        StrCpyN(szFromCopy, pszFrom, ARRAYSIZE(szFromCopy));
        pszFrom = szFromCopy;
    }
    
    if (pszTo)
    {
        StrCpyN(szToCopy, pszTo, ARRAYSIZE(szToCopy));
        pszTo = szToCopy;
    }
#endif DEBUG


    if (pszPath && pszFrom && pszTo)
    {
        TCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
        LPTSTR psz;
        UINT cchCommon;

        DEBUGWhackPathBuffer(pszPath, MAX_PATH);

        *pszPath = 0;       // assume none

        StrCpyN(szFrom, pszFrom, ARRAYSIZE(szFrom));
        StrCpyN(szTo, pszTo, ARRAYSIZE(szTo));

        if (!(dwAttrFrom & FILE_ATTRIBUTE_DIRECTORY))
            PathRemoveFileSpec(szFrom);

        if (!(dwAttrTo & FILE_ATTRIBUTE_DIRECTORY))
            PathRemoveFileSpec(szTo);

        cchCommon = PathCommonPrefix(szFrom, szTo, NULL);
        if (cchCommon == 0)
            return FALSE;

        psz = szFrom + cchCommon;

        if (*psz)
        {
            // build ..\.. part of the path
            if (*psz == CH_WHACK)
            {
                // skip slash
                psz++;
            }

            while (*psz)
            {
                psz = PathFindNextComponent(psz);
                StringCchCat(pszPath, MAX_PATH, *psz ? c_szDotDotSlash : c_szDotDot);
            }
        }
        else
        {
            StringCchCopy(pszPath, MAX_PATH, c_szDot);
        }

        if (pszTo[cchCommon])
        {
            // deal with root case
            if (pszTo[cchCommon] != CH_WHACK)
                cchCommon--;

            if ((lstrlen(pszPath) + lstrlen(pszTo + cchCommon)) >= MAX_PATH)
            {
                TraceMsg(TF_ERROR, "PathRelativePathTo: path won't fit in buffer");
                *pszPath = 0;
                return FALSE;
            }

            ASSERT(pszTo[cchCommon] == CH_WHACK);
            StringCchCat(pszPath, MAX_PATH, pszTo + cchCommon);
        }

        ASSERT(PathIsRelative(pszPath));
        ASSERT(lstrlen(pszPath) < MAX_PATH);

        return TRUE;
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Build a root path name given a drive number.

Returns: pszRoot
*/
STDAPI_(LPTSTR) PathBuildRoot(LPTSTR pszRoot, int iDrive)
{
    RIPMSG(pszRoot && IS_VALID_WRITE_BUFFER(pszRoot, TCHAR, 4), "PathBuildRoot: caller passed bad pszRoot");
    RIPMSG(iDrive >= 0 && iDrive < 26, "PathBuildRoot: caller passed bad iDrive");

    if (pszRoot && iDrive >= 0 && iDrive < 26)
    {
        pszRoot[0] = (TCHAR)iDrive + (TCHAR)TEXT('A');
        pszRoot[1] = TEXT(':');
        pszRoot[2] = TEXT('\\');
        pszRoot[3] = 0;
    }

    return pszRoot;
}


// Strips leading and trailing blanks from a string.
// Alters the memory where the string sits.
//
// in:
//  lpszString  string to strip
//
// out:
//  lpszString  string sans leading/trailing blanks
//
STDAPI_(void) PathRemoveBlanks(LPTSTR lpszString)
{
    RIPMSG(lpszString && IS_VALID_STRING_PTR(lpszString, -1), "PathRemoveBlanks: caller passed bad lpszString");

    if (lpszString)
    {
        LPTSTR lpszPosn = lpszString;

        /* strip leading blanks */
        while (*lpszPosn == TEXT(' '))
        {
            lpszPosn++;
        }

        if (lpszPosn != lpszString)
        {
            StringCchCopy(lpszString, MAX_PATH, lpszPosn);
        }

        /* strip trailing blanks */

        // Find the last non-space
        // Note that AnsiPrev is cheap is non-DBCS, but very expensive otherwise
        for (lpszPosn=lpszString; *lpszString; lpszString=FAST_CharNext(lpszString))
        {
            if (*lpszString != TEXT(' '))
            {
                lpszPosn = lpszString;
            }
        }

        // Note AnsiNext is a macro for non-DBCS, so it will not stop at NULL
        if (*lpszPosn)
        {
            *FAST_CharNext(lpszPosn) = TEXT('\0');
        }
    }
}


// Removes a trailing backslash from a path
//
// in:
//  lpszPath    (A:\, C:\foo\, etc)
//
// out:
//  lpszPath    (A:\, C:\foo, etc)
//
// returns:
//  ponter to NULL that replaced the backslash
//  or the pointer to the last character if it isn't a backslash.
//
STDAPI_(LPTSTR) PathRemoveBackslash(LPTSTR lpszPath)
{
    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathRemoveBackslash: caller passed bad lpszPath");

    if (lpszPath)
    {
        int len = lstrlen(lpszPath)-1;
        if (IsDBCSLeadByte(*CharPrev(lpszPath,lpszPath+len+1)))
            len--;

        if (!PathIsRoot(lpszPath) && lpszPath[len] == CH_WHACK)
            lpszPath[len] = TEXT('\0');

        return lpszPath + len;
    }
    return NULL;
}


//
// Return a pointer to the end of the next path componenent in the string.
// ie return a pointer to the next backslash or terminating NULL.
//
LPCTSTR GetPCEnd(LPCTSTR lpszStart)
{
    LPCTSTR lpszEnd;

    lpszEnd = StrChr(lpszStart, CH_WHACK);
    if (!lpszEnd)
    {
        lpszEnd = lpszStart + lstrlen(lpszStart);
    }

    return lpszEnd;
}


//
// Given a pointer to the end of a path component, return a pointer to
// its begining.
// ie return a pointer to the previous backslash (or start of the string).
//
LPCTSTR PCStart(LPCTSTR lpszStart, LPCTSTR lpszEnd)
{
    LPCTSTR lpszBegin = StrRChr(lpszStart, lpszEnd, CH_WHACK);
    if (!lpszBegin)
    {
        lpszBegin = lpszStart;
    }
    return lpszBegin;
}


//
// Fix up a few special cases so that things roughly make sense.
//
void NearRootFixups(LPTSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[0] = CH_WHACK;
        lpszPath[1] = TEXT('\0');
    }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':') && lpszPath[2] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[2] = TEXT('\\');
        lpszPath[3] = TEXT('\0');
    }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == TEXT('\\') && lpszPath[1] == TEXT('\0'))
    {
        // Fix up.
        //lpszPath[0] = TEXT('\\'); // already checked in if guard
        lpszPath[1] = TEXT('\\');
        lpszPath[2] = TEXT('\0');
    }
}


/*----------------------------------------------------------
Purpose: Canonicalize a path.

Returns:
Cond:    --
*/
STDAPI_(BOOL) PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc)
{
    LPCTSTR lpchSrc;
    LPCTSTR lpchPCEnd;      // Pointer to end of path component.
    LPTSTR lpchDst;
    BOOL fUNC;
    int cchPC;
    HRESULT hr;

    RIPMSG(lpszDst && IS_VALID_WRITE_BUFFER(lpszDst, TCHAR, MAX_PATH), "PathCanonicalize: caller passed bad lpszDst");
    RIPMSG(lpszSrc && IS_VALID_STRING_PTR(lpszSrc, -1), "PathCanonicalize: caller passed bad lpszSrc");
    RIPMSG(lpszDst != lpszSrc, "PathCanonicalize: caller passed the same buffer for lpszDst and lpszSrc");

    if (!lpszDst || !lpszSrc)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DEBUGWhackPathBuffer(lpszDst, MAX_PATH);
    *lpszDst = TEXT('\0');
    
    fUNC = PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
    {
        // REVIEW: this should just return the count
        lpchPCEnd = GetPCEnd(lpchSrc);
        cchPC = (int) (lpchPCEnd - lpchSrc)+1;

        if (cchPC == 1 && *lpchSrc == CH_WHACK)                                      // Check for slashes.
        {
            // Just copy them.
            hr = StringCchCopy(lpchDst, lpszDst + MAX_PATH - lpchDst, SZ_WHACK);
            if (FAILED(hr))
            {
                return FALSE;   // dest exceeded MAX_PATH!
            }

            lpchDst++;
            lpchSrc++;
        }
        else if (cchPC == 2 && *lpchSrc == TEXT('.'))                                // Check for dots.
        {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == TEXT('\0'))
            {
                lpchSrc++;

                // remove the last slash we copied (if we've copied one), but don't make a mal-formed root
                if ((lpchDst > lpszDst) && !PathIsRoot(lpszDst))
                {
                    lpchDst--;
                }
            }
            else // ".\"
            {
                lpchSrc += 2; // ignore this path segment
            }
        }
        else if (cchPC == 3 && *lpchSrc == TEXT('.') && *(lpchSrc + 1) == TEXT('.')) // Check for dot dot.
        {
            // make sure we aren't already at the root
            if (!PathIsRoot(lpszDst))
            {
                // Go up... Remove the previous path component.
                lpchDst = (LPTSTR)PCStart(lpszDst, lpchDst - 1);
            }
            else
            {
                // When we can't back up, skip the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == CH_WHACK)
                {
                    lpchSrc++;
                }
            }

            // skip ".."
            lpchSrc += 2;       
        }
        else                                                                        // Everything else
        {
            // Just copy it.
            hr = StringCchCopyN(lpchDst, lpszDst + MAX_PATH - lpchDst, lpchSrc, cchPC - 1);
            if (FAILED(hr))
            {
                return FALSE;   // dest exceeded MAX_PATH!
            }
            lpchDst += cchPC - 1;
            lpchSrc += cchPC - 1;
        }

        // Keep everything nice and tidy.
        *lpchDst = TEXT('\0');
    }

    // Check for weirdo root directory stuff.
    NearRootFixups(lpszDst, fUNC);

    return TRUE;
}


// Modifies:
//      pszRoot
//
// Returns:
//      TRUE if a drive root was found
//      FALSE otherwise
//
STDAPI_(BOOL) PathStripToRoot(LPTSTR pszRoot)
{
    RIPMSG(pszRoot && IS_VALID_STRING_PTR(pszRoot, -1), "PathStripToRoot: caller passed bad pszRoot");

    if (pszRoot)
    {
        while (!PathIsRoot(pszRoot))
        {
            if (!PathRemoveFileSpec(pszRoot))
            {
                // If we didn't strip anything off,
                // must be current drive
                return FALSE;
            }
        }
        return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Concatenate lpszDir and lpszFile into a properly formed
         path and canonicalize any relative path pieces.

         lpszDest and lpszFile can be the same buffer
         lpszDest and lpszDir can be the same buffer

Returns: pointer to lpszDest
*/
STDAPI_(LPTSTR) PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile)
{
#ifdef DEBUG
    TCHAR szDirCopy[MAX_PATH];
    TCHAR szFileCopy[MAX_PATH];

    RIPMSG(lpszDest && IS_VALID_WRITE_BUFFER(lpszDest, TCHAR, MAX_PATH), "PathCombine: caller passed bad lpszDest");
    RIPMSG(!lpszDir || IS_VALID_STRING_PTR(lpszDir, -1), "PathCombine: caller passed bad lpszDir");
    RIPMSG(!lpszFile || IS_VALID_STRING_PTR(lpszFile, -1), "PathCombine: caller passed bad lpszFile");
    RIPMSG(lpszDir || lpszFile, "PathCombine: caller neglected to pass lpszDir or lpszFile");

    // we make copies of all the lpszDir and lpszFile buffers in case one of the strings they are passing is a pointer
    // inside lpszDest buffer. If this were the case, it would be trampled when we call DEBUGWhackPathBuffer().
    if (lpszDir)
    {
        StrCpyN(szDirCopy, lpszDir, ARRAYSIZE(szDirCopy));
        lpszDir = szDirCopy;
    }
    
    if (lpszFile)
    {
        StrCpyN(szFileCopy, lpszFile, ARRAYSIZE(szFileCopy));
        lpszFile = szFileCopy;
    }

    // lpszDest could be lpszDir, so be careful which one we call
    if (lpszDest != lpszDir && lpszDest != lpszFile)
        DEBUGWhackPathBuffer(lpszDest, MAX_PATH);
    else if (lpszDest)
        DEBUGWhackPathString(lpszDest, MAX_PATH);
#endif DEBUG


    if (lpszDest)
    {
        TCHAR szTemp[MAX_PATH];
        LPTSTR pszT;

        *szTemp = TEXT('\0');

        if (lpszDir && *lpszDir)
        {
            if (!lpszFile || *lpszFile==TEXT('\0'))
            {
                StrCpyN(szTemp, lpszDir, ARRAYSIZE(szTemp));       // lpszFile is empty
            }
            else if (PathIsRelative(lpszFile))
            {
                StrCpyN(szTemp, lpszDir, ARRAYSIZE(szTemp));
                pszT = PathAddBackslash(szTemp);
                if (pszT)
                {
                    int iRemaining = (int)(ARRAYSIZE(szTemp) - (pszT - szTemp));

                    if (lstrlen(lpszFile) < iRemaining)
                    {
                        StrCpyN(pszT, lpszFile, iRemaining);
                    }
                    else
                    {
                        *szTemp = TEXT('\0');
                    }
                }
                else
                {
                    *szTemp = TEXT('\0');
                }
            }
            else if (*lpszFile == CH_WHACK && !PathIsUNC(lpszFile))
            {
                StrCpyN(szTemp, lpszDir, ARRAYSIZE(szTemp));
                // FEATURE: Note that we do not check that an actual root is returned;
                // it is assumed that we are given valid parameters
                PathStripToRoot(szTemp);

                pszT = PathAddBackslash(szTemp);
                if (pszT)
                {
                    // Skip the backslash when copying
                    // Note: We don't support strings longer than 4GB, but that's
                    // okay because we already barf at MAX_PATH
                    StrCpyN(pszT, lpszFile+1, (int)(ARRAYSIZE(szTemp) - (pszT - szTemp)));
                }
                else
                {
                    *szTemp = TEXT('\0');
                }
            }
            else
            {
                StrCpyN(szTemp, lpszFile, ARRAYSIZE(szTemp));     // already fully qualified file part
            }
        }
        else if (lpszFile && *lpszFile)
        {
            StrCpyN(szTemp, lpszFile, ARRAYSIZE(szTemp));     // no dir just use file.
        }

        //
        // if szTemp has something in it we succeeded.  Also if szTemp is empty and
        // the input strings are empty we succeed and PathCanonicalize() will
        // return "\"
        // 
        if (*szTemp || ((lpszDir || lpszFile) && !((lpszDir && *lpszDir) || (lpszFile && *lpszFile))))
        {
            // this deals with .. and . stuff
            // returns "\" on empty szTemp
            if (!PathCanonicalize(lpszDest, szTemp))
            {
                *lpszDest = TEXT('\0');
                lpszDest = NULL;
            }                                   
        }
        else
        {
            *lpszDest = TEXT('\0');   // set output buffer to empty string.
            lpszDest  = NULL;         // return failure.
        }
    }

    return lpszDest;
}


/*----------------------------------------------------------
Purpose: Appends a filename to a path.  Checks the \ problem first
          (which is why one can't just use StrCatBuff())
         Also don't append a \ to : so we can have drive-relative paths...
         this last bit is no longer appropriate since we qualify first!

Returns:
*/
STDAPI_(BOOL) PathAppend(LPTSTR pszPath, LPCTSTR pszMore)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathAppend: caller passed bad pszPath");
    RIPMSG(pszMore && IS_VALID_STRING_PTR(pszMore, -1), "PathAppend: caller passed bad pszMore");
    // PathCombine will do this for us: DEBUGWhackPathString(pszPath, MAX_PATH);

    if (pszPath && pszMore)
    {
        // Skip any initial terminators on input, unless it is a UNC path in wich case we will 
        // treat it as a full path
        if (!PathIsUNC(pszMore))
        {
            while (*pszMore == CH_WHACK)
            {
#ifndef UNICODE
                pszMore = FAST_CharNext(pszMore);
#else
                pszMore++;
#endif
            }
        }

        return PathCombine(pszPath, pszPath, pszMore) ? TRUE : FALSE;
    }
    
    return FALSE;
}


// rips the last part of the path off including the backslash
//      C:\foo      -> C:\
//      C:\foo\bar  -> C:\foo
//      C:\foo\     -> C:\foo
//      \\x\y\x     -> \\x\y
//      \\x\y       -> \\x
//      \\x         -> \\ (Just the double slash!)
//      \foo        -> \  (Just the slash!)
//
// in/out:
//      pFile   fully qualified path name
// returns:
//      TRUE    we stripped something
//      FALSE   didn't strip anything (root directory case)
//
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{
    RIPMSG(pFile && IS_VALID_STRING_PTR(pFile, -1), "PathRemoveFileSpec: caller passed bad pFile");

    if (pFile)
    {
        LPTSTR pT;
        LPTSTR pT2 = pFile;

        for (pT = pT2; *pT2; pT2 = FAST_CharNext(pT2))
        {
            if (*pT2 == CH_WHACK)
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pFile) && (*pT == CH_WHACK)) ||                        //  is it the "\foo" case?
                 ((pT == pFile+1) && (*pT == CH_WHACK && *pFile == CH_WHACK)))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}



// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path
//
STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath)
{
    LPTSTR lpszRet = NULL;

    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathAddBackslash: caller passed bad lpszPath");

    if (lpszPath)
    {
        int    ichPath = lstrlen(lpszPath);
        LPTSTR lpszEnd = lpszPath + ichPath;

        if (ichPath)
        {

            // Get the end of the source directory
            switch(*CharPrev(lpszPath, lpszEnd))
            {
                case CH_WHACK:
                    break;

                default:
                    // try to keep us from tromping over MAX_PATH in size.
                    // if we find these cases, return NULL.  Note: We need to
                    // check those places that call us to handle their GP fault
                    // if they try to use the NULL!
                    if (ichPath >= (MAX_PATH - 2)) // -2 because ichPath doesn't include NULL, and we're adding a CH_WHACK.
                    {
                        TraceMsg(TF_WARNING, "PathAddBackslash: caller passed in lpszPath > MAX_PATH, can't append whack");
                        return(NULL);
                    }

                    *lpszEnd++ = CH_WHACK;
                    *lpszEnd = TEXT('\0');
            }
        }

        lpszRet = lpszEnd;
    }

    return lpszRet;
}


// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
//
STDAPI_(LPTSTR) PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT = pPath;
    
    RIPMSG(pPath && IS_VALID_STRING_PTR(pPath, -1), "PathFindFileName: caller passed bad pPath");

    if (pPath)
    {
        for ( ; *pPath; pPath = FAST_CharNext(pPath))
        {
            if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
                && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
                pT = pPath + 1;
        }
    }

    return (LPTSTR)pT;   // const -> non const
}


// determine if a path is just a filespec (contains no path parts)
//
// REVIEW: we may want to count the # of elements, and make sure
// there are no illegal chars, but that is probably another routing
// PathIsValid()
//
// in:
//      lpszPath    path to look at
// returns:
//      TRUE        no ":" or "\" chars in this path
//      FALSE       there are path chars in there
//
//
STDAPI_(BOOL) PathIsFileSpec(LPCTSTR lpszPath)
{
    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsFileSpec: caller passed bad lpszPath");

    if (lpszPath)
    {
        for (; *lpszPath; lpszPath = FAST_CharNext(lpszPath))
        {
            if (*lpszPath == CH_WHACK || *lpszPath == TEXT(':'))
                return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
//
STDAPI_(BOOL) PathIsUNC(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsUNC: caller passed bad pszPath");

    if (pszPath)
    {
        return DBL_BSLASH(pszPath);
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a path that is on a mounted network drive    
//
// Cond:    Calls SHELL32's IsNetDrive function
//
STDAPI_(BOOL) PathIsNetworkPath(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsNetworkPath: caller passed bad pszPath");

    if (pszPath)
    {
        return DBL_BSLASH(pszPath) || IsNetDrive(PathGetDriveNumber(pszPath));
    }

    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path to a server only (no share name).
//
// TRUE
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\\foo\bar"
//      "\foo"
//      "foo"
//      "c:\foo"
//
STDAPI_(BOOL) PathIsUNCServer(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsUNCServer: caller passed bad pszPath");

    if (pszPath)
    {
        if (DBL_BSLASH(pszPath))
        {
            int i = 0;
            LPTSTR szTmp;

            for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = FAST_CharNext(szTmp) )
            {
                if (*szTmp==TEXT('\\'))
                {
                    i++;
                }
            }

            return (i == 2);
        }
    }

    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path to a server\share only.
//
// TRUE
//      "\\foo\bar"         <- careful
// FALSE
//      "\\foo\bar\bar"
//      "\foo"
//      "foo"
//      "c:\foo"
//
STDAPI_(BOOL) PathIsUNCServerShare(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsUNCServerShare: caller passed bad pszPath");

    if (pszPath)
    {
        if (DBL_BSLASH(pszPath))
        {
            int i = 0;
            LPTSTR szTmp;

            for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = FAST_CharNext(szTmp) )
            {
                if (*szTmp==TEXT('\\'))
                {
                    i++;
                }
            }

            return (i == 3);
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has
// a drive letter, otherwise returns -1.
//
//
STDAPI_(int) PathGetDriveNumber(LPCTSTR lpsz)
{
    RIPMSG(lpsz && IS_VALID_STRING_PTR(lpsz, -1), "PathGetDriveNumber: caller passed bad lpsz");

    if (lpsz)
    {
        if (!IsDBCSLeadByte(lpsz[0]) && lpsz[1] == TEXT(':'))
        {
            if (lpsz[0] >= TEXT('a') && lpsz[0] <= TEXT('z'))
            {
                return (lpsz[0] - TEXT('a'));
            }
            else if (lpsz[0] >= TEXT('A') && lpsz[0] <= TEXT('Z'))
            {
                return (lpsz[0] - TEXT('A'));
            }
        }
    }

    return -1;
}


//---------------------------------------------------------------------------
// Return TRUE if the path isn't absoulte.
//
// TRUE
//      "foo.exe"
//      ".\foo.exe"
//      "..\boo\foo.exe"
//
// FALSE
//      "\foo"
//      "c:bar"     <- be careful
//      "c:\bar"
//      "\\foo\bar"
//
STDAPI_(BOOL) PathIsRelative(LPCTSTR lpszPath)
{
    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsRelative: caller passed bad lpszPath");

    if (!lpszPath || *lpszPath == 0)
    {
        // The NULL path is assumed relative
        return TRUE;
    }

    if (lpszPath[0] == CH_WHACK)
    {
        // Does it begin with a slash ?
        return FALSE;
    }
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':'))
    {
        // Does it begin with a drive and a colon ?
        return FALSE;
    }
    else
    {
        // Probably relative.
        return TRUE;
    }
}


// remove the path part from a fully qualified spec
//
// c:\foo\bar   -> bar
// c:\foo       -> foo
// c:\          -> c:\ and the like
//
STDAPI_(void) PathStripPath(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathStripPath: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pszName = PathFindFileName(pszPath);

        if (pszName != pszPath)
        {
            StringCchCopy(pszPath, MAX_PATH, pszName);
        }
    }
}

// replaces forward slashes with backslashes
// NOTE: the "AndColon" part is not implemented

STDAPI_(void) FixSlashesAndColon(LPTSTR pszPath)
{
    // walk the entire path string, keep track of last
    // char in the path
    for (; *pszPath; pszPath = FAST_CharNext(pszPath))
    {
        if (*pszPath == TEXT('/'))
        {
            *pszPath = CH_WHACK;
        }
    }
}


#ifdef DEBUG
BOOL IsFullPath(LPCTSTR pcszPath)
{
    BOOL bResult = FALSE;
    TCHAR rgchFullPath[MAX_PATH];

    if (IS_VALID_STRING_PTR(pcszPath, -1) && EVAL(lstrlen(pcszPath) < MAX_PATH))
    {
        DWORD dwPathLen;
        LPTSTR pszFileName;

        dwPathLen = GetFullPathName(pcszPath, SIZECHARS(rgchFullPath),
                                    rgchFullPath, &pszFileName);

        if (EVAL(dwPathLen > 0) &&
            EVAL(dwPathLen < SIZECHARS(rgchFullPath)))
            bResult = EVAL(! lstrcmpi(pcszPath, rgchFullPath));
    }

    return(bResult);
}
#endif // DEBUG


/*----------------------------------------------------------
Purpose: Fully qualify a path and search for it.

Returns: TRUE if the path is qualified
         FALSE if not

Cond:    --
*/
STDAPI_(BOOL) PathSearchAndQualify(LPCTSTR pcszPath, LPTSTR pszFullyQualifiedPath, UINT cchFullyQualifiedPath)
{
    BOOL bRet = FALSE;

    RIPMSG(pcszPath && IS_VALID_STRING_PTR(pcszPath, -1), "PathSearchAndQualify: caller passed bad pcszPath");
    RIPMSG(IS_VALID_WRITE_BUFFER(pszFullyQualifiedPath, TCHAR, cchFullyQualifiedPath), "PathSearchAndQualify: caller passed bad pszFullyQualifiedPath");
    DEBUGWhackPathBuffer(pszFullyQualifiedPath, cchFullyQualifiedPath);

    if (pcszPath && ((cchFullyQualifiedPath == 0) || pszFullyQualifiedPath))
    {
        LPTSTR pszFileName;
        
        /* Any path separators? */
        if (!StrPBrk(pcszPath, TEXT(":/\\")))
        {
            /* No.  Search for file. */
            bRet = (SearchPath(NULL, pcszPath, NULL, cchFullyQualifiedPath, pszFullyQualifiedPath, &pszFileName) > 0);
        }

        if (!bRet && (GetFullPathName(pcszPath, cchFullyQualifiedPath, pszFullyQualifiedPath, &pszFileName) > 0))
        {
            bRet = TRUE;
        }

        if ( !bRet )
        {
            if (cchFullyQualifiedPath > 0)
            {
                *pszFullyQualifiedPath = '\0';
            }
        }
        
        ASSERT((bRet && IsFullPath(pszFullyQualifiedPath)) ||
               (!bRet && (!cchFullyQualifiedPath || !*pszFullyQualifiedPath)));
    }

    return bRet;
}


// check if a path is a root
//
// returns:
//  TRUE 
//      "\" "X:\" "\\" "\\foo" "\\foo\bar"
//
//  FALSE for others including "\\foo\bar\" (!)
//
STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath)
{
    RIPMSG(pPath && IS_VALID_STRING_PTR(pPath, -1), "PathIsRoot: caller passed bad pPath");
    
    if (!pPath || !*pPath)
    {
        return FALSE;
    }
    
    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, TEXT(":\\")))
        {
            return TRUE;    // "X:\" case
        }
    }
    
    if ((*pPath == CH_WHACK) && (*(pPath + 1) == 0))
    {
        return TRUE;    // "/" or "\" case
    }
    
    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;
        
        for (p = pPath + 2; *p; p = FAST_CharNext(p))
        {
            if (*p == TEXT('\\')) 
            {
                //
                //  return FALSE for "\\server\share\dir"
                //  so just check if there is more than one slash
                //
                //  "\\server\" without a share name causes
                //  problems for WNet APIs.  we should return
                //  FALSE for this as well
                //
                if ((++cBackslashes > 1) || !*(p+1))
                    return FALSE;   
            }
        }
        // end of string with only 1 more backslash
        // must be a bare UNC, which looks like a root dir
        return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Determines if pszPath is a directory.  "C:\" is
         considered a directory too.

Returns: TRUE if it is
*/
STDAPI_(BOOL) PathIsDirectory(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsDirectory: caller passed bad pszPath");

    if (pszPath)
    {
        if (PathIsUNCServer(pszPath))
        {
            return FALSE;
        }
        else if (PathIsUNCServerShare(pszPath))
        {
            union {
                NETRESOURCE nr;
                TCHAR buf[512];
            } nrb = {0};

            LPTSTR lpSystem = NULL;
            DWORD dwSize = sizeof(nrb);
            DWORD dwRet;

            nrb.nr.dwScope = RESOURCE_GLOBALNET;
            nrb.nr.dwType = RESOURCETYPE_ANY;
            nrb.nr.lpRemoteName = (LPTSTR)pszPath;

            dwRet = WNetGetResourceInformation(&nrb.nr, &nrb, &dwSize, &lpSystem);

            if (dwRet != WN_SUCCESS)
                goto TryGetFileAttrib;

            if (nrb.nr.dwDisplayType == RESOURCEDISPLAYTYPE_GENERIC)
                goto TryGetFileAttrib;

            if ((nrb.nr.dwDisplayType == RESOURCEDISPLAYTYPE_SHARE) &&
                ((nrb.nr.dwType == RESOURCETYPE_ANY) ||
                 (nrb.nr.dwType == RESOURCETYPE_DISK)))
            {
                return TRUE;
            }
        }
        else
        {
            DWORD dwAttribs;
TryGetFileAttrib:

            dwAttribs = GetFileAttributes(pszPath);
            if (dwAttribs != (DWORD)-1)
                return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
        }
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Determines if pszPath is a directory.  "C:\" is
         considered a directory too.

Returns: TRUE if it is, FALSE if it is not a directory or there is
         at least one file other than "." or ".."
*/
STDAPI_(BOOL) PathIsDirectoryEmpty(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsDirectoryEmpty: caller passed bad pszPath");

    if (pszPath)
    {
        TCHAR szDirStarDotStar[MAX_PATH];
        HANDLE hDir;
        WIN32_FIND_DATA wfd;

        if (!PathIsDirectory(pszPath))
        {
            // its not even an directory, so it dosent fall into the
            // category of "empty" directory
            return FALSE;
        }

        StringCchCopy(szDirStarDotStar, ARRAYSIZE(szDirStarDotStar), pszPath);
        if (!PathAddBackslash(szDirStarDotStar))
        {
            return FALSE;
        }

        StrCatBuff(szDirStarDotStar, TEXT("*.*"), ARRAYSIZE(szDirStarDotStar));

        hDir = FindFirstFile(szDirStarDotStar, &wfd);

        if (INVALID_HANDLE_VALUE == hDir)
        {
            // we cant see into it, so assume some stuff is there
            return FALSE;
        }

        while (PathIsDotOrDotDot(wfd.cFileName))
        {
            if (!FindNextFile(hDir, &wfd))
            {
                // failed and all we found was "." and "..", so I guess
                // the directory is empty
                FindClose(hDir);
                return TRUE;
            }

        }

        // If we made it out of the loop, it means we found a file that 
        // wasen't "." or ".." Therefore, directory is NOT empty
        FindClose(hDir);
    }
    return FALSE;
}


#ifndef UNICODE
// light weight logic for charprev that is not painful for sbcs
BOOL IsTrailByte(LPCTSTR pszSt, LPCTSTR pszCur)
{
    LPCTSTR psz = pszCur;


    // if the given pointer is at the top of string, at least it's not a trail byte.
    if (psz <= pszSt) return FALSE;

    while (psz > pszSt)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or pszCur itself.
            psz++;
            break;
        }
    }

    // Now psz can point to:
    //     1) a leadbyte of double byte character.
    //     2) pszSt
    //     3) pszCur
    //
    // if psz == pszSt, psz should point to a valid double byte char.
    //                  because we didn't hit the above if statement.
    //
    // if psz == pszCur, the *(pszCur-1) was non lead byte so pszCur can't
    //                   be a trail byte.
    //
    // Thus, we can see pszCur as trail byte pointer if the distance from
    // psz is not DBCS boundary that is 2.
    //
    return (BOOL) ((pszCur-psz) & 1);
}
#endif

// modify lpszPath in place so it fits within dx space (using the
// current font).  the base (file name) of the path is the minimal
// thing that will be left prepended with ellipses
//
// examples:
//      c:\foo\bar\bletch.txt -> c:\foo...\bletch.txt   -> TRUE
//      c:\foo\bar\bletch.txt -> c:...\bletch.txt       -> TRUE
//      c:\foo\bar\bletch.txt -> ...\bletch.txt         -> FALSE
//      relative-path         -> relative-...           -> TRUE
//
// in:
//      hDC         used to get font metrics
//      lpszPath    path to modify (in place)
//      dx          width in pixels
//
// returns:
//      TRUE    path was compacted to fit in dx
//      FALSE   base part didn't fit, the base part of the path was
//              bigger than dx
//
STDAPI_(BOOL) PathCompactPath(HDC hDC, LPTSTR lpszPath, UINT dx)
{
    BOOL bRet = TRUE;

    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1) && IS_VALID_WRITE_BUFFER(lpszPath, TCHAR, MAX_PATH), "PathCompactPath: caller passed bad lpszPath");
    DEBUGWhackPathString(lpszPath, MAX_PATH);

    if (lpszPath)
    {
        int           len;
        UINT          dxFixed, dxEllipses;
        LPTSTR        lpEnd;          /* end of the unfixed string */
        LPTSTR        lpFixed;        /* start of text that we always display */
        BOOL          bEllipsesIn;
        SIZE sz;
        TCHAR szTemp[MAX_PATH];
        HDC hdcGet = NULL;

        if (!hDC)
            hDC = hdcGet = GetDC(NULL);

        /* Does it already fit? */

        GetTextExtentPoint(hDC, lpszPath, lstrlen(lpszPath), &sz);
        if ((UINT)sz.cx <= dx)
        {
            goto Exit;
        }

        lpFixed = PathFindFileName(lpszPath);
        if (lpFixed != lpszPath)
        {
            lpFixed = CharPrev(lpszPath, lpFixed);  // point at the slash
        }

        /* Save this guy to prevent overlap. */
        StrCpyN(szTemp, lpFixed, ARRAYSIZE(szTemp));

        lpEnd = lpFixed;
        bEllipsesIn = FALSE;

        GetTextExtentPoint(hDC, lpFixed, lstrlen(lpFixed), &sz);
        dxFixed = sz.cx;

        GetTextExtentPoint(hDC, c_szEllipses, 3, &sz);
        dxEllipses = sz.cx;

        // PERF: GetTextExtentEx() or something should let us do this without looping

        if (lpFixed == lpszPath)
        {
            // if we're just doing a file name, just tack on the ellipses at the end
            lpszPath = lpszPath + lstrlen(lpszPath);

            if ((3 + lpszPath - lpFixed) >= MAX_PATH)
            {
                lpszPath = lpFixed + MAX_PATH - 4;
            }

            while (TRUE) 
            {
#ifndef UNICODE
                if (IsTrailByte(lpFixed, lpszPath))
                    lpszPath--;
#endif
                StringCchCopy(lpszPath, MAX_PATH, c_szEllipses);
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                GetTextExtentPoint(hDC, lpFixed, (int)(3 + lpszPath - lpFixed), &sz);

                if (sz.cx <= (int)dx)
                    break;
                
                lpszPath--;
            }

        }
        else
        {
            // Note that we need to avoid calling GetTextExtentPoint with a
            // length of zero (because Win95 allegedly crashes under conditions
            // yet to be determined precisely), but lpEnd is guaranteed
            // to be greater than lpszPath to start.
            //
            // raymondc - I'm guessing that some crappy display driver has
            // patched GetTextExtent and messed up their "optimized" version.
            do
            {
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                GetTextExtentPoint(hDC, lpszPath, (int)(lpEnd - lpszPath), &sz);

                len = dxFixed + sz.cx;

                if (bEllipsesIn)
                    len += dxEllipses;

                if (len <= (int)dx)
                    break;


                // Step back a character.
                lpEnd = CharPrev(lpszPath, lpEnd);
                
                if (!bEllipsesIn)
                {
                    // if this is the first
                    // truncation, go ahead and truncate by 3 (lstrlen of c_szEllipses);
                    // so that we don't just go back one, then write 3 and overwrite the buffer
                    lpEnd = CharPrev(lpszPath, lpEnd);
                    lpEnd = CharPrev(lpszPath, lpEnd);
                }

                bEllipsesIn = TRUE;

            } while (lpEnd > lpszPath);

            // Things didn't fit. Note that we'll still overflow here because the
            // filename is larger than the available space. We should probably trim
            // the file name, but I'm just trying to prevent a crash, not actually
            // make this work.
            if (lpEnd <= lpszPath)
            {
                StringCchCopy(lpszPath, MAX_PATH, c_szEllipses);
                StrCatBuff(lpszPath, szTemp, MAX_PATH);
                bRet = FALSE;
                goto Exit;
            }

            if (bEllipsesIn)
            {
                StrCpyN(lpEnd, c_szEllipses, MAX_PATH - (int)(lpEnd - lpszPath));
                StrCatBuff(lpEnd, szTemp, MAX_PATH - (int)(lpEnd - lpszPath));
            }
        }
        Exit:
        if (hdcGet)
            ReleaseDC(NULL, hdcGet);
    }
    
    return bRet;
}

#define LEN_MID_ELLIPSES        4
#define LEN_END_ELLIPSES        3
#define MIN_CCHMAX              LEN_MID_ELLIPSES + LEN_END_ELLIPSES

// PathCompactPathEx
// Output:
//          "."
//          ".."
//          "..."
//          "...\"
//          "...\."
//          "...\.."
//          "...\..."
//          "...\Truncated filename..."
//          "...\whole filename"
//          "Truncated path\...\whole filename"
//          "Whole path\whole filename"
// The '/' might be used instead of a '\' if the original string used it
// If there is no path, but only a file name that does not fit, the output is:
//          "truncated filename..."
//
STDAPI_(BOOL) PathCompactPathEx(LPTSTR pszOut, LPCTSTR pszSrc, UINT cchMax, DWORD dwFlags)
{
    RIPMSG(pszSrc && IS_VALID_STRING_PTR(pszSrc, -1), "PathCompactPathEx: caller passed bad pszSrc");
    RIPMSG(pszOut && IS_VALID_WRITE_BUFFER(pszOut, TCHAR, cchMax), "PathCompactPathEx: caller passed bad pszOut");
    RIPMSG(!dwFlags, "PathCompactPathEx: caller passed non-ZERO dwFlags");
    DEBUGWhackPathBuffer(pszOut, cchMax);

    if (pszSrc)
    {
        TCHAR * pszFileName, *pszWalk;
        UINT uiFNLen = 0;
        int cchToCopy = 0, n;
        TCHAR chSlash = TEXT('0');

        ZeroMemory(pszOut, cchMax * sizeof(TCHAR));

        if ((UINT)lstrlen(pszSrc)+1 < cchMax)
        {
            StringCchCopy(pszOut, cchMax, pszSrc);
            ASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Determine what we use as a slash - a / or a \ (default \)
        pszWalk = (TCHAR*)pszSrc;
        chSlash = TEXT('\\');

        // Scan the entire string as we want the path separator closest to the end
        // eg. "file://\\Themesrv\desktop\desktop.htm"
        while(*pszWalk)
        {
            if ((*pszWalk == TEXT('/')) || (*pszWalk == TEXT('\\')))
                chSlash = *pszWalk;

            pszWalk = FAST_CharNext(pszWalk);
        }

        pszFileName = PathFindFileName(pszSrc);
        uiFNLen = lstrlen(pszFileName);

        // if the whole string is a file name
        if(pszFileName == pszSrc && cchMax > LEN_END_ELLIPSES)
        {
            StrCpyN(pszOut, pszSrc, cchMax - LEN_END_ELLIPSES);
#ifndef UNICODE
            if (IsTrailByte(pszSrc, pszSrc+cchMax-LEN_END_ELLIPSES-1))
            {
                *(pszOut+cchMax-LEN_END_ELLIPSES-2) = TEXT('\0');
            }
#endif
            StringCchCat(pszOut, cchMax, TEXT("..."));
            ASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Handle all the cases where we just use ellipses ie '.' to '.../...'
        if ((cchMax < MIN_CCHMAX))
        {
            for (n = 0; n < (int)cchMax-1; n++)
            {
                if ((n+1) == LEN_MID_ELLIPSES)
                {
                    pszOut[n] = chSlash;
                }
                else
                {
                    pszOut[n] = TEXT('.');
                }
            }

            ASSERT(0==cchMax || pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Ok, how much of the path can we copy ? Buffer - (Lenght of MID_ELLIPSES + Len_Filename)
        cchToCopy = cchMax - (LEN_MID_ELLIPSES + uiFNLen);
        
        if (cchToCopy < 0)
            cchToCopy = 0;

#ifndef UNICODE
        if (cchToCopy > 0 && IsTrailByte(pszSrc, pszSrc+cchToCopy))
            cchToCopy--;
#endif

        StrCpyN(pszOut, pszSrc, cchToCopy);

        // Now throw in the ".../" or "...\"
        StringCchCat(pszOut, cchMax, TEXT(".../"));
        pszOut[lstrlen(pszOut) - 1] = chSlash;

        //Finally the filename and ellipses if necessary
        if (cchMax > (LEN_MID_ELLIPSES + uiFNLen))
        {
            StringCchCat(pszOut, cchMax, pszFileName);
        }
        else
        {
            cchToCopy = cchMax - LEN_MID_ELLIPSES - LEN_END_ELLIPSES;
#ifndef UNICODE
            if (cchToCopy >0 && IsTrailByte(pszFileName, pszFileName+cchToCopy))
            {
                cchToCopy--;
            }
#endif
            StrCpyN(pszOut + LEN_MID_ELLIPSES, pszFileName, cchToCopy);
            StringCchCat(pszOut, cchMax, TEXT("..."));
        }

        ASSERT(pszOut[cchMax-1] == TEXT('\0'));
        return TRUE;
    }
    return FALSE;
}


// fill a control with a path, using PathCompactPath() to crunch the
// path to fit.
//
// in:
//      hDlg    dialog box or parent window
//      id      child id to put the path in
//      pszPath path to put in
//
STDAPI_(void) PathSetDlgItemPath(HWND hDlg, int id, LPCTSTR pszPath)
{
    RECT rc;
    HDC hdc;
    HFONT hFont;
    TCHAR szPath[MAX_PATH + 1];  // can have one extra char
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, id);
    
    if (!hwnd)
        return;

    szPath[0] = 0;

    if (pszPath)
        StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));

    GetClientRect(hwnd, &rc);

    hdc = GetDC(hDlg);
    hFont = (HANDLE)SendMessage(hwnd, WM_GETFONT, 0, 0L);
    
    if (NULL != (hFont = SelectObject(hdc, hFont)))
    {
        PathCompactPath(hdc, szPath, (UINT)rc.right);
        SelectObject(hdc, hFont);
    }
    
    ReleaseDC(hDlg, hdc);
    SetWindowText(hwnd, szPath);
}


/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

Returns: --
Cond:    --
*/
STDAPI_(void) PathUnquoteSpaces(LPTSTR lpsz)
{
    RIPMSG(lpsz && IS_VALID_STRING_PTR(lpsz, -1), "PathUnquoteSpaces: caller passed bad lpsz");

    if (lpsz)
    {
        int cch;

        cch = lstrlen(lpsz);

        // Are the first and last chars quotes?
        // (It is safe to go straight to the last character because
        // the quotation mark is not a valid DBCS trail byte.)
        if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
        {
            // Yep, remove them.
            lpsz[cch-1] = TEXT('\0');
            hmemcpy(lpsz, lpsz+1, (cch-1) * sizeof(TCHAR));
        }
    }
}


//----------------------------------------------------------------------------
// If a path contains spaces then put quotes around the whole thing.
//
STDAPI_(void)PathQuoteSpaces(LPTSTR lpsz)
{
    RIPMSG(lpsz && IS_VALID_STRING_PTR(lpsz, -1) && IS_VALID_WRITE_BUFFER(lpsz, TCHAR, MAX_PATH), "PathQuoteSpaces: caller passed bad lpsz");
    DEBUGWhackPathString(lpsz, MAX_PATH);

    if (lpsz)
    {
        int cch;

        if (StrChr(lpsz, TEXT(' ')))
        {
            // NB - Use hmemcpy coz it supports overlapps.
            cch = lstrlen(lpsz)+1;

            if (cch+1 < MAX_PATH)
            {
                hmemcpy(lpsz+1, lpsz, cch * sizeof(TCHAR));
                lpsz[0] = TEXT('"');
                lpsz[cch] = TEXT('"');
                lpsz[cch+1] = TEXT('\0');
            }
        }
    }
}


//---------------------------------------------------------------------------
// Given a pointer to a point in a path - return a ptr the start of the
// next path component. Path components are delimted by slashes or the
// null at the end.
// There's special handling for UNC names.
// This returns NULL if you pass in a pointer to a NULL ie if you're about
// to go off the end of the  path.
//
STDAPI_(LPTSTR) PathFindNextComponent(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFindNextComponent: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pszLastSlash;

        // Are we at the end of a path.
        if (!*pszPath)
        {
            // Yep, quit.
            return NULL;
        }
        // Find the next slash.
        // REVIEW UNDONE - can slashes be quoted?
        pszLastSlash = StrChr(pszPath, TEXT('\\'));
        // Is there a slash?
        if (!pszLastSlash)
        {
            // No - Return a ptr to the NULL.
            return (LPTSTR)pszPath + lstrlen(pszPath);
        }
        else
        {
            // Is it a UNC style name?
            if (*(pszLastSlash + 1) == TEXT('\\'))
            {
                // Yep, skip over the second slash.
                return pszLastSlash + 2;
            }
            else
            {
                // Nope. just skip over one slash.
                return pszLastSlash + 1;
            }
        }
    }

    return NULL;
}

// helper for PathMatchSpec.
// originally PathMatchSpec had this logic embedded in it and it recursively called itself.
// only problem is the recursion picked up all the extra specs, so for example
// PathMatchSpec("foo....txt", "*.txt;*.a;*.b;*.c;*.d;*.e;*.f;*.g") called itself too much
// and wound up being O(N^3).
// in fact this logic doesnt match strings efficiently, but we shipped it so leave it be.
// just test one spec at a time and its all good.
// pszSpec is a pointer within the pszSpec passed to PathMatchSpec so we terminate at ';' in addition to '\0'.
BOOL PathMatchSingleSpec(LPCTSTR pszFileParam, LPCTSTR pszSpec)
{
    LPCTSTR pszFile = pszFileParam;

    // Strip leading spaces from each spec.  This is mainly for commdlg
    // support;  the standard format that apps pass in for multiple specs
    // is something like "*.bmp; *.dib; *.pcx" for nicer presentation to
    // the user.
    while (*pszSpec == TEXT(' '))
        pszSpec++;

    while (*pszFile && *pszSpec && *pszSpec != TEXT(';'))
    {
        switch (*pszSpec)
        {
        case TEXT('?'):
            pszFile = FAST_CharNext(pszFile);
            pszSpec++;      // NLS: We know that this is a SBCS
            break;

        case TEXT('*'):

            // We found a * so see if this is the end of our file spec
            // or we have *.* as the end of spec, in which case we
            // can return true.
            //
            if (*(pszSpec + 1) == 0 || *(pszSpec + 1) == TEXT(';'))   // "*" matches everything
                return TRUE;


            // Increment to the next character in the list
            pszSpec = FAST_CharNext(pszSpec);

            // If the next character is a . then short circuit the
            // recursion for performance reasons
            if (*pszSpec == TEXT('.'))
            {
                pszSpec++;  // Get beyond the .

                // Now see if this is the *.* case
                if ((*pszSpec == TEXT('*')) &&
                        ((*(pszSpec+1) == TEXT('\0')) || (*(pszSpec+1) == TEXT(';'))))
                    return TRUE;

                // find the extension (or end in the file name)
                while (*pszFile)
                {
                    // If the next char is a dot we try to match the
                    // part on down else we just increment to next item
                    if (*pszFile == TEXT('.'))
                    {
                        pszFile++;

                        if (PathMatchSingleSpec(pszFile, pszSpec))
                            return TRUE;

                    }
                    else
                        pszFile = FAST_CharNext(pszFile);
                }

                return FALSE;   // No item found so go to next pattern
            }
            else
            {
                // Not simply looking for extension, so recurse through
                // each of the characters until we find a match or the
                // end of the file name
                while (*pszFile)
                {
                    // recurse on our self to see if we have a match
                    if (PathMatchSingleSpec(pszFile, pszSpec))
                        return TRUE;
                    pszFile = FAST_CharNext(pszFile);
                }

                return FALSE;   // No item found so go to next pattern
            }

        default:
            if (CharUpper((LPTSTR)(ULONG_PTR)(TUCHAR)*pszSpec) ==
                     CharUpper((LPTSTR)(ULONG_PTR)(TUCHAR)*pszFile))
            {
                if (IsDBCSLeadByte(*pszSpec))
                {
#ifdef  DBCS
                    // Because AnsiUpper(CharUpper) just return 0
                    // for broken DBCS char passing case, above if state
                    // always true with DBCS char so that we should check
                    // first byte of DBCS char here again.
                    if (*pszFile != *pszSpec)
                        return FALSE;
#endif
                    pszFile++;
                    pszSpec++;
                    if (*pszFile != *pszSpec)
                        return FALSE;
                }
                pszFile++;
                pszSpec++;
            }
            else
            {
                return FALSE;
            }
        }
    }

    // If we made it to the end of both strings, we have a match...
    //
    if (!*pszFile)
    {
        if ((!*pszSpec || *pszSpec == TEXT(';')))
            return TRUE;

        // Also special case if things like foo should match foo*
        // as well as foo*; for foo*.* or foo*.*;
        if ( (*pszSpec == TEXT('*')) &&
            ( (*(pszSpec+1) == TEXT('\0')) || (*(pszSpec+1) == TEXT(';')) ||
                ((*(pszSpec+1) == TEXT('.')) &&  (*(pszSpec+2) == TEXT('*')) &&
                    ((*(pszSpec+3) == TEXT('\0')) || (*(pszSpec+3) == TEXT(';'))))))

                return TRUE;
    }
    return FALSE;
}

//
// Match a DOS wild card spec against a dos file name
// Both strings must be ANSI.
//
STDAPI_(BOOL) PathMatchSpec(LPCTSTR pszFileParam, LPCTSTR pszSpec)
{
    RIPMSG(pszSpec && IS_VALID_STRING_PTR(pszSpec, -1), "PathMathSpec: caller passed bad pszSpec");
    RIPMSG(pszFileParam && IS_VALID_STRING_PTR(pszFileParam, -1), "PathMathSpec: caller passed bad pszFileParam");

    if (pszSpec && pszFileParam)
    {
        // Special case empty string, "*", and "*.*"...
        //
        if (*pszSpec == 0)
        {
            return TRUE;
        }

        // loop over the spec, break off at ';', and call our helper for each.
        do
        {
            if (PathMatchSingleSpec(pszFileParam, pszSpec))
                return TRUE;

            // Skip to the end of the path spec...
            while (*pszSpec && *pszSpec != TEXT(';'))
                pszSpec = FAST_CharNext(pszSpec);

        // If we have more specs, keep looping...
        } while (*pszSpec++ == TEXT(';'));
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the beginning of the subpath
         that follows the root (drive letter or UNC server/share).

Returns:
Cond:    --

Notes: dsheldon - won't properly handle \\?\
*/
STDAPI_(LPTSTR) PathSkipRoot(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathSkipRoot: caller passed bad pszPath");

    if (pszPath)
    {
        if (DBL_BSLASH(pszPath))
        {
            pszPath = StrChr(pszPath+2, TEXT('\\'));
            if (pszPath)
            {
                pszPath = StrChr(pszPath+1, TEXT('\\'));
                if (pszPath)
                {
                    ++pszPath;
                }
            }
        }
        else if (!IsDBCSLeadByte(pszPath[0]) && pszPath[1]==TEXT(':') && pszPath[2]==TEXT('\\'))
        {
            pszPath += 3;
        }
        else
        {
            pszPath = NULL;
        }
    }

    return (LPTSTR)pszPath;
}


// see if two paths have the same root component
//
STDAPI_(BOOL) PathIsSameRoot(LPCTSTR pszPath1, LPCTSTR pszPath2)
{
    RIPMSG(pszPath1 && IS_VALID_STRING_PTR(pszPath1, -1), "PathIsSameRoot: caller passed bad pszPath1");
    RIPMSG(pszPath2 && IS_VALID_STRING_PTR(pszPath2, -1), "PathIsSameRoot: caller passed bad pszPath2");

    if (pszPath1 && pszPath2)
    {
        LPTSTR pszAfterRoot = PathSkipRoot(pszPath1);
        int nLen = PathCommonPrefix(pszPath1, pszPath2, NULL);

        // Add 1 to account for the '\\'
        return pszAfterRoot && (pszAfterRoot - pszPath1) <= (nLen + 1);
    }
    return FALSE;
}

#define IsDigit(c) ((c) >= TEXT('0') && c <= TEXT('9'))

/*----------------------------------------------------------
Purpose: Takes a location string ("shell32.dll,3") and parses
         it into a file-component and an icon index.

Returns: icon index
Cond:    --
*/
STDAPI_(int) PathParseIconLocation(IN OUT LPTSTR pszIconFile)
{
    int iIndex = 0;

    RIPMSG(pszIconFile && IS_VALID_STRING_PTR(pszIconFile, -1), "PathParseIconLocation: caller passed bad pszIconFile");
    
    if (pszIconFile)
    {
        LPTSTR pszComma, pszEnd;

        // look for the last comma in the string
        pszEnd = pszIconFile + lstrlen(pszIconFile);
        pszComma = StrRChr(pszIconFile, pszEnd, TEXT(','));
        
        if (pszComma && *pszComma)
        {
            LPTSTR pszComma2 = pszComma + 1;
            BOOL fIsDigit = FALSE;

            // Sometimes we get something like: "C:\path, comma\path\file.ico"
            // where the ',' is in the path and does not indicates that an icon index follows
            while (*pszComma2)
            {
                if ((TEXT(' ') == *pszComma2) || (TEXT('-') == *pszComma2))
                {
                    ++pszComma2;
                }
                else
                {
                    if (IsDigit(*pszComma2))
                    {
                        fIsDigit = TRUE;
                    }
                    break;
                }
            }

            if (fIsDigit)
            {
                *pszComma++ = 0;            // terminate the icon file name.
                iIndex = StrToInt(pszComma);
            }
        }

        PathUnquoteSpaces(pszIconFile);
        PathRemoveBlanks(pszIconFile);
    }
    return iIndex;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given path is of a URL format.
         See http://www.w3.org for a complete description of
         the URL format.

         A complete URL looks like:
            <URL:http://www.microsoft.com/software/index.html>

         But generally URLs don't have the leading "URL:" and
         the wrapping angle brackets.  So this function only
         tests for the following format:

            http://www.microsoft.com/software

         It does not check if the path points to an existing
         site, only if is in a legal URL format.

Returns: TRUE if URL format
         FALSE if not
Cond:    --
*/
STDAPI_(BOOL) PathIsURL(IN LPCTSTR pszPath)
{
    PARSEDURL pu;

    if (!pszPath)
        return FALSE;

    RIPMSG(IS_VALID_STRING_PTR(pszPath, -1), "PathIsURL: caller passed bad pszPath");

    pu.cbSize = sizeof(pu);
    return SUCCEEDED(ParseURL(pszPath, &pu));
}


/****************************************************\
    FUNCTION: PathIsContentType

    PARAMETERS:
        pszPath - File Name to check.
        pszContentType - Content Type to look for.

    DESCRIPTION:
        Is the file (pszPath) of the content type
    specified (pszContentType)?.
\****************************************************/
#define SZ_VALUE_CONTENTTYPE      TEXT("Content Type")

BOOL PathIsContentType(LPCTSTR pszPath, LPCTSTR pszContentType)
{
    BOOL fDoesMatch = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsContentType: caller passed bad pszPath");
    RIPMSG(pszContentType && IS_VALID_STRING_PTR(pszContentType, -1), "PathIsContentType: caller passed bad pszContentType");

    if (pszPath)
    {
        LPTSTR pszExtension = PathFindExtension(pszPath);

        if (pszExtension && pszExtension[0])
        {
            TCHAR szRegData[MAX_PATH];
            DWORD dwDataSize = ARRAYSIZE(szRegData);
            
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pszExtension, NULL, szRegData, &dwDataSize)))
            {
                fDoesMatch = (0 == lstrcmpi(szRegData, pszContentType));
            }
        }
    }

    return fDoesMatch;
}


/*----------------------------------------------------------
Purpose: Returns the character type (GCT_)

  FEATURE (reinerf) - this API is not very good, use PathIsValidChar() instead, its more customizable
                     
*/
UINT PathGetCharType(TUCHAR ch)
{
    switch (ch)
    {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('"'):
        case TEXT('/'):
            return GCT_INVALID;

        case TEXT('?'):
        case TEXT('*'):
            return GCT_WILD;

        case TEXT('\\'):      // path separator
        case TEXT(':'):       // drive colon
            return GCT_SEPARATOR;

        case TEXT(';'):
        case TEXT(','):
        case TEXT(' '):
            return GCT_LFNCHAR;     // actually valid in short names
                                    // but we want to avoid this
        default:
            if (ch > TEXT(' '))
            {
                return GCT_SHORTCHAR | GCT_LFNCHAR;
            }
            else
            {
                // control character
                return GCT_INVALID;
            }
    }
}


/*----------------------------------------------------------
Purpose: returns if a character is a valid path character given
         the flags that you pass in (PIVC_XXX). Some basic flags are given below:

         PIVC_ALLOW_QUESTIONMARK        treat '?' as valid
         PIVC_ALLOW_STAR                treat '*' as valid
         PIVC_ALLOW_DOT                 treat '.' as valid
         PIVC_ALLOW_SLASH               treat '\\' as valid
         PIVC_ALLOW_COLON               treat ':' as valid
         PIVC_ALLOW_SEMICOLON           treat ';' as valid
         PIVC_ALLOW_COMMA               treat ',' as valid
         PIVC_ALLOW_SPACE               treat ' ' as valid
         PIVC_ALLOW_NONALPAHABETIC      treat non-alphabetic extenede chars as valid
         PIVC_ALLOW_QUOTE               treat '"' as valid

         if you pass 0, then only alphabetic characters are valid. there are also basic
         conglomerations of the above flags:

         PIVC_ALLOW_FULLPATH, PIVC_ALLOW_WILDCARD, PIVC_ALLOW_LFN, ...
         

Returns: TRUE if the character is a valid path character given the dwFlags constraints
         FALSE if this does not qualify as a valid path character given the dwFlags constraints
Cond:    --
*/
STDAPI_(BOOL) PathIsValidChar(TUCHAR ch, DWORD dwFlags)
{
    switch (ch)
    {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
            return FALSE;   // these are allways illegal in a path
            break;

        case TEXT('?'):
            return dwFlags & PIVC_ALLOW_QUESTIONMARK;
            break;

        case TEXT('*'):
            return dwFlags & PIVC_ALLOW_STAR;
            break;

        case TEXT('.'):
            return dwFlags & PIVC_ALLOW_DOT;
            break;

        case TEXT('\\'):
            return dwFlags & PIVC_ALLOW_SLASH;
            break;

        case TEXT(':'):
            return dwFlags & PIVC_ALLOW_COLON;
            break;

        case TEXT(';'):
            return dwFlags & PIVC_ALLOW_SEMICOLON;
            break;

        case TEXT(','):
            return dwFlags & PIVC_ALLOW_COMMA;
            break;

        case TEXT(' '):
            return dwFlags & PIVC_ALLOW_SPACE;
            break;

        case TEXT('"'):
            return dwFlags & PIVC_ALLOW_QUOTE;
            break;

        default:
            if (InRange(ch, TEXT('a'), TEXT('z')) ||
                InRange(ch, TEXT('A'), TEXT('Z')))
            {
                // we have an alphabetic character, 
                // this is always valid
                return TRUE;
            }
            else if (ch < TEXT(' '))
            {
                // we have a control sequence, 
                // this is allways illegal
                return FALSE;
            }
            else
            {
                // we have an non-alphabetic extenede character
                return dwFlags & PIVC_ALLOW_NONALPAHABETIC;
            }
            break;
    }
}


BOOL IsSystemSpecialCase(LPCTSTR pszPath)
{
    static TCHAR *g_pszWin = NULL, *g_pszSys = NULL;

    if (g_pszWin == NULL)
    {
        TCHAR szTemp[MAX_PATH];
        UINT cch = GetWindowsDirectory(szTemp, ARRAYSIZE(szTemp));

        if (cch && cch < ARRAYSIZE(szTemp))
            g_pszWin = StrDup(szTemp);
    }

    if (g_pszSys == NULL)
    {
        TCHAR szTemp[MAX_PATH];
        UINT cch = GetSystemDirectory(szTemp, ARRAYSIZE(szTemp));

        if (cch && cch < ARRAYSIZE(szTemp))
            g_pszSys = StrDup(szTemp);
    }

    return (g_pszWin && (lstrcmpi(g_pszWin, pszPath) == 0)) ||
           (g_pszSys && (lstrcmpi(g_pszSys, pszPath) == 0));
}


/*----------------------------------------------------------
Purpose: Mark a folder to be a shell folder by stamping
         either FILE_ATTRIBUTES_READONLY or FILE_ATTRIBUTE_SYSTEM
         into it's attributes.  Which flag is used is based
         on the presence/absense of a registry switch

         NOTE: we also mark the contained desktop.ini +s +h if it exists
*/
BOOL PathMakeSystemFolder(LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
        
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathMakeSystemFolder: caller passed bad pszPath");

    if (pszPath && *pszPath)
    {
        TCHAR szTemp[MAX_PATH];

        if (IsSystemSpecialCase(pszPath))
        {
            fRet = TRUE;
        }
        else
        {
            DWORD dwAttrb, dwAttrbSet = FILE_ATTRIBUTE_READONLY;

            if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_EXPLORER, 
                TEXT("UseSystemForSystemFolders"), NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                dwAttrbSet = FILE_ATTRIBUTE_SYSTEM;
            }

            dwAttrb = GetFileAttributes(pszPath);
            if ((dwAttrb != (DWORD)-1) && (dwAttrb & FILE_ATTRIBUTE_DIRECTORY))
            {
                dwAttrb &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
                dwAttrb |= dwAttrbSet;

                fRet = SetFileAttributes(pszPath, dwAttrb);
            }

            if (fRet)
            {
                FILETIME ftCurrent;
                HANDLE h;

                // People typically call this API after writing a desktop.ini in the
                // folder.  Doing this often changes the thumbnail of the folder.
                // But on FAT systems, this doesn't update the Modified time of the
                // folder like it does for NTFS.  So manually do that now:
                //
                GetSystemTimeAsFileTime(&ftCurrent);
                // woohoo yay for private flags
                // 0x100 lets us open a directory in write access
                h = CreateFile(pszPath, GENERIC_READ | 0x100,
                                   FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                                   OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
                if (h != INVALID_HANDLE_VALUE)
                {
                    SetFileTime(h, NULL, NULL, &ftCurrent);
                    CloseHandle(h);
                }

                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pszPath, NULL);
            }
        }

        // we also set the contained desktop.ini file to be (+h +s), if it exists
        if (PathCombine(szTemp, pszPath, TEXT("desktop.ini")))
        {
            // we explicitly do not OR in the attribs, because we want to reset the
            // readonly bit since writeprivateprofilestring fails on reaonly files.
            SetFileAttributes(szTemp, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }
    }

    return fRet;
}

/*----------------------------------------------------------
Purpose: Unmark a folder so it is no longer a system folder.
         (remove both FILE_ATTRIBUTES_READONLY and FILE_ATTRIBUTE_SYSTEM
         attribute).
*/
BOOL PathUnmakeSystemFolder(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathUnmakeSystemFolder: caller passed bad pszPath");

    if (pszPath && *pszPath)
    {
        DWORD dwAttrb = GetFileAttributes( pszPath );

        if ((dwAttrb != (DWORD)-1) && (dwAttrb & FILE_ATTRIBUTE_DIRECTORY))
        {
            dwAttrb &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);

            return SetFileAttributes(pszPath, dwAttrb);
        }
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: checks whether given path is a system (shell) folder.
         if path is NULL, then use the attributes passed in
         instead of reading them off the disk.

*/
BOOL PathIsSystemFolder(LPCTSTR pszPath, DWORD dwAttrb)
{
    if (pszPath && *pszPath)
        dwAttrb = GetFileAttributes(pszPath);

    if ((dwAttrb != (DWORD)-1) && (dwAttrb & FILE_ATTRIBUTE_DIRECTORY))
    {
        if (dwAttrb & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
        {
            return TRUE;
        }
    }
    return FALSE;
}



LPCTSTR PathSkipLeadingSlashes(LPCTSTR pszURL)
{
    LPCTSTR pszURLStart = pszURL;

    RIPMSG(pszURL && IS_VALID_STRING_PTR(pszURL, -1), "PathSkipLeadingSlashes: caller passed bad pszURL");
    if (pszURL)
    {
        // Skip two leading slashes.

        if (pszURL[0] == TEXT('/') && pszURL[1] == TEXT('/'))
            pszURLStart += 2;

        ASSERT(IS_VALID_STRING_PTR(pszURL, -1) &&
               IsStringContained(pszURL, pszURLStart));
    }
    
    return pszURLStart;
}


//
// returns:
//      TRUE    given filespec is long (> 8.3 form)
//      FALSE   filespec is short
//
STDAPI_(BOOL) PathIsLFNFileSpec(LPCTSTR pszName)
{
    RIPMSG(pszName && IS_VALID_STRING_PTR(pszName, -1), "PathIsLFNFileSpec: caller passed bad pszName");

    if (pszName)
    {
        BOOL bSeenDot = FALSE;
        int iCount = 1; 
        
        while (*pszName)
        {
            if (bSeenDot)
            {
                if (iCount > 3)
                {
                    // found a long name
                    return TRUE;
                }
            }

            if (*pszName == TEXT(' '))
            {
                // Short names dont have blanks in them.
                return TRUE;
            }

            if (*pszName == TEXT('.'))
            {
                if (bSeenDot)
                {
                    // short names can only have one '.'
                    return TRUE;
                }

                bSeenDot = TRUE;
                iCount = 0; // don't include the '.'
            }
            else if (iCount > 8)
            {
                // long name
                return TRUE;
            }

            if (IsDBCSLeadByte(*pszName)) // should this be CharNext?
            {
                pszName += 2;
                iCount += 2;
            }
            else
            {
                pszName++;
                iCount++;
            }
        }
    }

    return FALSE;       // short name
}


/*----------------------------------------------------------
Purpose: Removes regexp \[[0-9]*\] from base name of file  
         that is typically added by the wininet cache.
*/

#define DECORATION_OPENING_CHAR TEXT('[')
#define DECORATION_CLOSING_CHAR TEXT(']')

STDAPI_(void) PathUndecorate(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathUndecorate: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pszExt, pszScan;
        DWORD cchMove;
        
        // First, skip over the extension, if any.
        pszExt = PathFindExtension(pszPath);
        ASSERT(pszExt >= pszPath); // points to null at end if no ext

        // Whoa, a completely empty path
        if (pszExt <= pszPath)
            return;

        // Scan backwards from just before the "."
        pszScan = pszExt - 1;

        // Check for closing bracket.
        if (*pszScan-- != DECORATION_CLOSING_CHAR)
            return;
        if (pszScan <= pszPath) // it was a 1-char filename ")"
            return;
#ifndef UNICODE
        if (IsTrailByte(pszPath, pszScan+1))    // Oops, that ")" was the 2nd byte of a DBCS char
            return;
#endif

        // Skip over digits.
        while (pszScan > pszPath && IsDigit(*pszScan))
            pszScan--;
#ifndef UNICODE
        if (IsTrailByte(pszPath, pszScan+1))   // Oops, that last number was the 2nd byte of a DBCS char
            return;
#endif

        // Check for opening bracket
        if (*pszScan != DECORATION_OPENING_CHAR)
            return;
        if (pszScan <= pszPath) // it was all decoration (we don't want to go to an empty filename)
            return;
#ifndef UNICODE
        if (IsTrailByte(pszPath, pszScan))  // Oops, that "(" was the 2nd byte of a DBCS char
            return;
#endif
        // Make sure we're not looking at the end of the path (we don't want to go to an empty filename)
        if (*(pszScan-1) == FILENAME_SEPARATOR
#ifndef UNICODE
            // make sure that slash isn't the 2nd byte of a DBCS char
            && ((pszScan-1) == pszPath || !IsTrailByte(pszPath, pszScan-1))
#endif
           )
        {
            return;
        }
        
        // Got a decoration.  Cut it out of the string.
        cchMove = lstrlen(pszExt) + 1;
        memmove(pszScan, pszExt, cchMove * sizeof(TCHAR));
    }
}

//  If the given environment variable exists as the first part of the path,
//  then the environment variable is inserted into the output buffer.
//
//  Returns TRUE if pszResult is filled in.
//
//  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SYSTEMROOT%
//            Output -- %SYSTEMROOT%\SYSTEM32\FOO.TXT
//

#ifdef  UNICODE
#define UnExpandEnvironmentStringForUser    UnExpandEnvironmentStringForUserW
#else
#define UnExpandEnvironmentStringForUser    UnExpandEnvironmentStringForUserA
#endif

BOOL UnExpandEnvironmentStringForUser(HANDLE hToken, LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cchResult)
{
    TCHAR szEnvVar[MAX_PATH];
    DWORD dwEnvVar = SHExpandEnvironmentStringsForUser(hToken, pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar));
    if (dwEnvVar)
    {
        dwEnvVar--; // don't count the NULL

        if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2)
        {
            if (lstrlen(pszPath) - (int)dwEnvVar + lstrlen(pszEnvVar) < (int)cchResult)
            {
                StringCchCopy(pszResult, cchResult, pszEnvVar);
                StringCchCat(pszResult, cchResult, pszPath + dwEnvVar);
                return TRUE;
            }
        }
    }
    return FALSE;
}

STDAPI_(BOOL) PathUnExpandEnvStringsForUser(HANDLE hToken, LPCTSTR pszPath, LPTSTR pszBuf, UINT cchBuf)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathUnExpandEnvStrings: caller passed bad pszPath");
    RIPMSG(pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf), "PathUnExpandEnvStrings: caller passed bad pszBuf");
    DEBUGWhackPathBuffer(pszBuf, cchBuf);

    // Bail out if we're not in NT (nothing to do if those environment variables
    // aren't defined).
    //
    if (pszPath && pszBuf)
    {

        // 99/05/28 #346950 vtan: WARNING!!! Be careful about the order of comparison
        // here. The longer paths (supersets of other possible paths) MUST be compared
        // first. For example (default case):
        //      %APPDATA%       =   x:\Documents And Settings\user\Application Data
        //      %USERPROFILE%   =   x:\Documents And Settings\user
        // If %USERPROFILE% is matched first then %APPDATA% will never be matched.

        // Added %APPDATA% to support Darwin installation into that folder and the
        // setting of the link icon location.
        // Also note that %APPDATA% and %USERPROFILE% are user relative and depend on
        // the context in which this function is invoked. Normally it is within the
        // currently logged on user's context but Darwin installs from msiexec.exe which
        // is launched from SYSTEM. Unless the process' environment block is correctly
        // modified the current user information is incorrect. In this case it is up
        // to the process to impersonate a user on a thread. We get the impersonated
        // user information from the hToken passed to us.

        return (UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%APPDATA%"), pszBuf, cchBuf)           ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%USERPROFILE%"), pszBuf, cchBuf)       ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%ALLUSERSPROFILE%"), pszBuf, cchBuf)   ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%ProgramFiles%"), pszBuf, cchBuf)      ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%SystemRoot%"), pszBuf, cchBuf)        ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%SystemDrive%"), pszBuf, cchBuf));
    }
    else
    {
        // Zero out the string if there's room.
        if (pszBuf && (cchBuf > 0))
            *pszBuf = TEXT('\0');
        return FALSE;
    }
}

STDAPI_(BOOL) PathUnExpandEnvStrings(LPCTSTR pszPath, LPTSTR pszBuf, UINT cchBuf)

{
    return(PathUnExpandEnvStringsForUser(NULL, pszPath, pszBuf, cchBuf));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef STRICT
#undef STRICT
#endif
#define STRICT

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4706) /* assignment within conditional expression                              */
#pragma warning(disable:4127) /* conditional expression is constant                                    */
#pragma warning(disable:4245) /* 'initializing' : conversion from 'int' to 'DWORD', signed/unsigned    */
                              /*    mismatch                                                           */
#pragma warning(disable:4189) /* local variable is initialized but not referenced                      */
#pragma warning(disable:4057) /* 'LPSTR ' differs in indirection to slightly different base types from */
                              /*   'LPBYTE '                                                           */
#pragma warning(disable:4701) /* local variable 'clrBkSav' may be used without having been initialized */
#pragma warning(disable:4310) /* cast truncates constant value                                         */
#pragma warning(disable:4702) /* unreachable code                                                      */
#pragma warning(disable:4206) /* nonstandard extension used : translation unit is empty                */
#pragma warning(disable:4267) /* '=' : conversion from 'size_t' to 'int', possible loss of data        */
#pragma warning(disable:4328) /* 'BOOL StrToIntExA(const LPCSTR,DWORD,int *__ptr64 )' : indirection    */
                              /*   alignment of formal parameter 3 (4) is greater than the actual      */
                              /*   argument alignment (2)                                              */
#pragma warning(disable:4509) /* nonstandard extension used: 'IOWorkerThread' uses SEH and 'info'      */
                              /*   has destructor                                                      */


#ifdef WIN32
#define _SHLWAPI_
#define _SHLWAPI_THUNK_
#define _OLE32_                     // we delay-load OLE
#define _OLEAUT32_                  // we delay-load OLEAUT32
#define _INC_OLE
#define CONST_VTABLE
#endif

#define _COMCTL32_                  // for DECLSPEC_IMPORT
#define _NTSYSTEM_                  // for DECLSPEC_IMPORT ntdll
#define _SETUPAPI_                  // for DECLSPEC_IMPORT setupapi

#define CC_INTERNAL

// Conditional for apithk.c
#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS      0x0400
#endif

#ifndef WINVER
#define WINVER              0x0400
#endif

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <port32.h>
#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <winnlsp.h>
#include <docobj.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <ccstock.h>
#include <crtfree.h>
#include <regstr.h>
#include <setupapi.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))


#ifdef TRY_NtPowerInformation
//
//  We would like to include <ntpoapi.h>, but ntpoapi.h redefines things
//  in a manner incompatible with <winnt.h>...  It also relies on <nt.h>,
//  which also redefines things in a manner incompatible with <winnt.h>.
//  So we have to fake its brains out.  Yuck.
//
typedef LONG NTSTATUS;
#undef ES_SYSTEM_REQUIRED
#undef ES_DISPLAY_REQUIRED
#undef ES_USER_PRESENT
#undef ES_CONTINUOUS
#define LT_DONT_CARE        NTPOAPI_LT_DONT_CARE
#define LT_LOWEST_LATENCY   NTPOAPI_LT_LOWEST_LATENCY
#define LATENCY_TIME        NTPOAPI_LATENCY_TIME
#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif

#include <ntpoapi.h>
#endif

//
// This is a very important piece of performance hack for non-DBCS codepage.
//
#ifdef UNICODE
// NB - These are already macros in Win32 land.
#ifdef WIN32
#undef AnsiNext
#undef AnsiPrev
#endif

#define AnsiNext(x) ((x)+1)
#define AnsiPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)
#endif // DBCS

#define CH_PREFIX TEXT('&')

//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in debug.h)
//

// Trace flags
#define TF_IDLIST           0x00000010      // IDList stuff
#define TF_PATH             0x00000020      // path stuff
#define TF_URL              0x00000040      // URL stuff
#define TF_REGINST          0x00000080      // REGINST stuff
#define TF_RIFUNC           0x00000100      // REGINST func tracing
#define TF_REGQINST         0x00000200      // RegQueryInstall tracing
#define TF_DBLIST           0x00000400      // SHDataBlockList tracing

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

// -1 means use CP_ACP, but do *not* verify
// kind of a hack, but it's DEBUG and leaves 99% of callers unchanged
#define CP_ACPNOVALIDATE    ((UINT)-1)

//
// Global variables
//
EXTERN_C HINSTANCE g_hinst;

#define HINST_THISDLL   g_hinst

// Icon mirroring
EXTERN_C HDC g_hdc;
EXTERN_C HDC g_hdcMask;
EXTERN_C BOOL g_bMirroredOS;
EXTERN_C DWORD g_tlsThreadRef;
EXTERN_C DWORD g_tlsOtherThreadsRef;


EXTERN_C int DrawTextFLW(HDC hdc, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);
EXTERN_C int DrawTextExFLW(HDC hdc, LPWSTR pwzText, int cchText, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
EXTERN_C BOOL GetTextExtentPointFLW(HDC hdc, LPCWSTR lpString, int nCount, LPSIZE lpSize);
EXTERN_C int ExtTextOutFLW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp);

STDAPI_(HANDLE) CreateAndActivateContext(ULONG_PTR* pul);
STDAPI_(void) DeactivateAndDestroyContext(HANDLE hActCtx, ULONG_PTR ul);

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\propbag.cpp ===
#include "priv.h"
#include "varutil.h"

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

#define MAX_PROPERTY_SIZE       2048

//  simple inline base class.
class CBasePropertyBag : public IPropertyBag, IPropertyBag2
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CBasePropertyBag, IPropertyBag),
            QITABENT(CBasePropertyBag, IPropertyBag2),
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }
        
    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&_cRef);
    }

    STDMETHODIMP_(ULONG) Release()
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) PURE;
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar) PURE;

    // IPropertyBag2 (note, does not derive from IPropertyBag)
    STDMETHODIMP Read(ULONG cProperties,  PROPBAG2 *pPropBag, IErrorLog *pErrLog, VARIANT *pvarValue, HRESULT *phrError);
    STDMETHODIMP Write(ULONG cProperties, PROPBAG2 *pPropBag, VARIANT *pvarValue);
    STDMETHODIMP CountProperties(ULONG *pcProperties);
    STDMETHODIMP GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2 *pPropBag, ULONG *pcProperties);
    STDMETHODIMP LoadObject(LPCOLESTR pstrName, DWORD dwHint, IUnknown *pUnkObject, IErrorLog *pErrLog);

protected:  //  methods
    CBasePropertyBag() {}       //  DONT DELETE ME
    CBasePropertyBag(DWORD grfMode) :
        _cRef(1), _grfMode(grfMode) {}

    virtual ~CBasePropertyBag() {}  //  DONT DELETE ME
    HRESULT _CanRead(void) 
        { return STGM_WRITE != (_grfMode & (STGM_WRITE | STGM_READWRITE)) ? S_OK : E_ACCESSDENIED;}

    HRESULT _CanWrite(void) 
        { return (_grfMode & (STGM_WRITE | STGM_READWRITE)) ? S_OK : E_ACCESSDENIED;}

protected:  //  members
    LONG _cRef;
    DWORD _grfMode;
};

STDMETHODIMP CBasePropertyBag::Read(ULONG cProperties, PROPBAG2 *pPropBag, IErrorLog *pErrLog, VARIANT *pvarValue, HRESULT *phrError)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::Write(ULONG cProperties, PROPBAG2 *pPropBag, VARIANT *pvarValue)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::CountProperties(ULONG *pcProperties)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2 *pPropBag, ULONG *pcProperties)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::LoadObject(LPCOLESTR pstrName, DWORD dwHint, IUnknown *pUnkObject, IErrorLog *pErrLog)
{
    return E_NOTIMPL;
}


//
// Ini file property bag implementation
//

class CIniPropertyBag : public CBasePropertyBag
{

public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected:  //  methods
    CIniPropertyBag(DWORD grfMode) : CBasePropertyBag(grfMode) {}
    virtual ~CIniPropertyBag();
    HRESULT _Init(LPCWSTR pszFile, LPCWSTR pszSection);
    HRESULT _GetSectionAndName(LPCWSTR pszProp, LPWSTR pszSection, UINT cchSec, LPWSTR pszName, UINT cchName);

protected:  //  members
    LPWSTR _pszFile;
    LPWSTR _pszSection;

friend HRESULT SHCreatePropertyBagOnProfileSection(LPCWSTR pszFile, LPCWSTR pszSection, DWORD grfMode, REFIID riid, void **ppv);
};

CIniPropertyBag::~CIniPropertyBag()
{
    LocalFree(_pszFile);        // accepts NULL
    LocalFree(_pszSection);     // accepts NULL
}

HRESULT CIniPropertyBag::_Init(LPCWSTR pszFile, LPCWSTR pszSection)
{
    HRESULT hr = E_OUTOFMEMORY;

    _pszFile = StrDupW(pszFile);
    if (_pszFile)
    {
        if (pszSection)
        {
            _pszSection = StrDupW(pszSection);
            if (_pszSection)
                hr = S_OK;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

// support the <section name>.<prop name> scheme

HRESULT CIniPropertyBag::_GetSectionAndName(LPCWSTR pszProp, 
                                            LPWSTR pszSection, UINT cchSec, 
                                            LPWSTR pszName, UINT cchName)
{
    HRESULT hr;
    LPCWSTR pszSlash = StrChrW(pszProp, L'\\');
    if (pszSlash)
    {
        StrCpyNW(pszSection, pszProp, min((UINT)(pszSlash - pszProp) + 1, cchSec));
        StrCpyNW(pszName, pszSlash + 1, cchName);
        hr = S_OK;
    }
    else if (_pszSection)
    {
        StrCpyNW(pszSection, _pszSection, cchSec);
        StrCpyNW(pszName, pszProp, cchName);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

// only supports strings.  use VariantChangeType() to suppor others

HRESULT CIniPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
    VARTYPE vtDesired = pvar->vt;

    VariantInit(pvar);

    HRESULT hr = _CanRead();
    if (SUCCEEDED(hr))
    {
        WCHAR szSec[64], szName[64];
        hr = _GetSectionAndName(pszPropName, szSec, ARRAYSIZE(szSec), szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            WCHAR sz[MAX_PROPERTY_SIZE];
            if (SHGetIniStringUTF7W(szSec, szName, sz, ARRAYSIZE(sz), _pszFile))
            {
                pvar->bstrVal = SysAllocString(sz);
                if (pvar->bstrVal)
                {
                    pvar->vt = VT_BSTR;

                    hr = VariantChangeTypeForRead(pvar, vtDesired);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}


// only writes as strings to the INI file, we use VariantChangeType() to morp the types.

HRESULT CIniPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    HRESULT hr = _CanWrite();
    if (SUCCEEDED(hr))
    {
        LPCWSTR psz = pvar->vt == VT_EMPTY ? NULL : pvar->bstrVal;
        VARIANT var = { 0 };
            
        if ((pvar->vt != VT_EMPTY) && (pvar->vt != VT_BSTR))
        {
            hr = VariantChangeType(&var, pvar, 0, VT_BSTR);
            if (SUCCEEDED(hr))
                psz = var.bstrVal;                           
        }

        if (SUCCEEDED(hr))
        {
            WCHAR szSec[64], szName[64];
            hr = _GetSectionAndName(pszPropName, szSec, ARRAYSIZE(szSec), szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                if (!SHSetIniStringUTF7W(szSec, szName, psz, _pszFile))
                {
                    hr = E_FAIL;
                }
                else
                {
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATHW, _pszFile, NULL);
                }
            }
        }

        VariantClear(&var);
    }
    return hr;
}

HRESULT SHCreatePropertyBagOnProfileSection(LPCWSTR pszFile, LPCWSTR pszSection, DWORD grfMode, REFIID riid, void **ppv)
{
    if (grfMode & STGM_CREATE)
    {
        //  we need to touch this file first
        HANDLE h = CreateFileW(pszFile, 0, FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        if (INVALID_HANDLE_VALUE != h)
        {
            WCHAR szFolder[MAX_PATH];
            StrCpyNW(szFolder, pszFile, ARRAYSIZE(szFolder));
            if (PathRemoveFileSpecW(szFolder))
            {
                PathMakeSystemFolderW(szFolder);
            }
            CloseHandle(h);
        }
    }

    if (PathFileExistsAndAttributesW(pszFile, NULL))
    {
        CIniPropertyBag *pbag = new CIniPropertyBag(grfMode);
        if (pbag)
        {
            HRESULT hr = pbag->_Init(pszFile, pszSection);
            if (SUCCEEDED(hr))
                hr = pbag->QueryInterface(riid, ppv);
            pbag->Release();

            return hr;
        }
    }

    *ppv = NULL;
    return E_OUTOFMEMORY;
}


//
// Registry property bag implementation
//

class CRegPropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected:  //  methods
    CRegPropertyBag(DWORD grfMode);
    virtual ~CRegPropertyBag();
    HRESULT _Init(HKEY hk, LPCWSTR pszSubKey);
    friend HRESULT SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv);

private:
    HRESULT _ReadDword(LPCOLESTR pszPropName, VARIANT *pvar);
    HRESULT _ReadString(LPCOLESTR pszPropName, VARIANT *pvar, DWORD cb);
    HRESULT _ReadStream(VARIANT* pvar, BYTE* pBuff, DWORD cb);
    HRESULT _ReadBinary(LPCOLESTR pszPropName, VARIANT* pvar, VARTYPE vt, DWORD cb);
    HRESULT _GetStreamSize(IStream* pstm, DWORD* pcb);
    HRESULT _CopyStreamIntoBuff(IStream* pstm, BYTE* pBuff, DWORD cb);
    HRESULT _WriteStream(LPCOLESTR pszPropName, IStream* pstm);

protected:  //  members
    HKEY  _hk;

friend HRESULT SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv);
};

CRegPropertyBag::CRegPropertyBag(DWORD grfMode) : CBasePropertyBag(grfMode)
{
    ASSERT(NULL == _hk);
}

CRegPropertyBag::~CRegPropertyBag()
{
    if (_hk)
        RegCloseKey(_hk);
}

HRESULT CRegPropertyBag::_Init(HKEY hk, LPCWSTR pszSubKey)
{
    DWORD err;
    REGSAM sam = 0;

    if (SUCCEEDED(_CanRead()))
        sam |= KEY_READ;

    if (SUCCEEDED(_CanWrite()))
        sam |= KEY_WRITE;

    if (_grfMode & STGM_CREATE)
        err = RegCreateKeyExW(hk, pszSubKey, 0, NULL, 0, sam, NULL, &_hk, NULL);
    else
        err = RegOpenKeyExW(hk, pszSubKey, 0, sam, &_hk);

    return HRESULT_FROM_WIN32(err);
}

HRESULT CRegPropertyBag::_ReadDword(LPCOLESTR pszPropName, VARIANT *pvar)
{
    HRESULT hr;

    DWORD   dwType;
    DWORD   cb  = sizeof(pvar->lVal);

    if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, &pvar->lVal, &cb))
    {
        ASSERT(REG_DWORD == dwType);
        pvar->vt = VT_UI4;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CRegPropertyBag::_ReadString(LPCOLESTR pszPropName, VARIANT *pvar, DWORD cb)
{
    HRESULT hr;

    DWORD   dwType;
    pvar->bstrVal = SysAllocStringByteLen(NULL, cb);

    if (pvar->bstrVal)
    {
        pvar->vt = VT_BSTR;

        if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, pvar->bstrVal, &cb))
        {
            hr = S_OK;
        }
        else
        {
            VariantClear(pvar);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CRegPropertyBag::_ReadStream(VARIANT* pvar, BYTE* pBuff, DWORD cb)
{
    HRESULT hr;

    pvar->punkVal = SHCreateMemStream(pBuff, cb);

    if (pvar->punkVal)
    {
        pvar->vt = VT_UNKNOWN;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CRegPropertyBag::_ReadBinary(LPCOLESTR pszPropName, VARIANT* pvar, VARTYPE vt, DWORD cb)
{
    HRESULT hr;

    switch(vt)
    {
    case VT_UNKNOWN:
        hr = E_FAIL;
        if (EVAL(cb >= sizeof(GUID)))
        {
            BYTE* pBuff = static_cast<BYTE*>(LocalAlloc(LPTR, cb));
            if (pBuff)
            {
                DWORD dwType;
                if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, pBuff, &cb))
                {
                    GUID* pguid = (GUID*)pBuff;

                    if (IsEqualGUID(GUID_NULL, *pguid))
                    {
                        // it's our non-cocreatable IStream implementation
                        hr = _ReadStream(pvar, pBuff + sizeof(GUID), cb - sizeof(GUID));
                    }
                    else
                    {
                        ASSERTMSG(FALSE, "We don't support writing other types of objects yet.");
                    }
                }

                LocalFree(pBuff);
            }
        }
        break;

    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

HRESULT CRegPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
    HRESULT hr = _CanRead();

    if (SUCCEEDED(hr))
    {
        VARTYPE vtDesired = pvar->vt;
        VariantInit(pvar);

        DWORD dwType;
        DWORD cb;

        if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, NULL, &cb))
        {
            switch(dwType)
            {
                case REG_DWORD:
                    hr = _ReadDword(pszPropName, pvar);
                    break;

                case REG_SZ:
                    hr = _ReadString(pszPropName, pvar, cb);
                    break;

                case REG_BINARY:
                    hr = _ReadBinary(pszPropName, pvar, vtDesired, cb);
                    break;

                default:
                    hr = E_FAIL;
                    break;
            }

            if (SUCCEEDED(hr))
            {
                hr = VariantChangeTypeForRead(pvar, vtDesired);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
        VariantInit(pvar);

    return hr;
}

HRESULT CRegPropertyBag::_GetStreamSize(IStream* pstm, DWORD* pcb)
{
    HRESULT hr;

    *pcb = 0;

    ULARGE_INTEGER uli;
    hr = IStream_Size(pstm, &uli);

    if (SUCCEEDED(hr))
    {
        if (0 == uli.HighPart)
        {
            *pcb = uli.LowPart;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CRegPropertyBag::_CopyStreamIntoBuff(IStream* pstm, BYTE* pBuff, DWORD cb)
{
    HRESULT hr;

    hr = IStream_Reset(pstm);

    if (SUCCEEDED(hr))
    {
        hr = IStream_Read(pstm, pBuff, cb);
    }

    return hr;
}

HRESULT CRegPropertyBag::_WriteStream(LPCOLESTR pszPropName, IStream* pstm)
{
    HRESULT hr;
    
    DWORD cb;

    hr = _GetStreamSize(pstm, &cb);

    if (SUCCEEDED(hr) && cb)
    {
        BYTE* pBuff = static_cast<BYTE*>(LocalAlloc(LPTR, cb + sizeof(GUID)));

        if (pBuff)
        {
            // we're using a NULL GUID to mean our own IStream implementation
            hr = _CopyStreamIntoBuff(pstm, pBuff + sizeof(GUID), cb);

            if (SUCCEEDED(hr))
            {
                if (NOERROR != SHSetValueW(_hk, NULL, pszPropName, REG_BINARY, pBuff, cb + sizeof(GUID)))
                {
                    hr = E_FAIL;
                }
            }

            LocalFree(pBuff);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CRegPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    HRESULT hr = _CanWrite();
    if (SUCCEEDED(hr))
    {
        VARIANT var = { 0 };

        switch(pvar->vt)
        {
            case VT_EMPTY:
                SHDeleteValueW(_hk, NULL, pszPropName);
                break;

            case VT_I1:
            case VT_I2:
            case VT_I4:
            case VT_INT:
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_UINT:
            case VT_BOOL:
                hr = VariantChangeType(&var, pvar, 0, VT_UI4);
                if (SUCCEEDED(hr))
                {
                    if (NOERROR != SHSetValueW(_hk, NULL, pszPropName, REG_DWORD, &var.lVal, sizeof(var.lVal)))
                    {
                        hr = E_FAIL;
                    }
                }
                break;

            case VT_UNKNOWN:
                IStream* pstm;
                hr = pvar->punkVal->QueryInterface(IID_PPV_ARG(IStream, &pstm));
                if (SUCCEEDED(hr))
                {
                    hr = _WriteStream(pszPropName, pstm);
                    pstm->Release();
                }
                else
                {
                    TraceMsg(TF_WARNING, "CRegPropertyBag::Write: Someone is trying to write an object we don't know how to save");
                }
                break;

            default:
                hr = VariantChangeType(&var, pvar, 0, VT_BSTR);
                if (SUCCEEDED(hr))
                {
                    if (NOERROR != SHSetValueW(_hk, NULL, pszPropName, REG_SZ, var.bstrVal, CbFromCchW(lstrlenW(var.bstrVal) + 1)))
                    {
                        hr = E_FAIL;
                    }
                    VariantClear(&var);
                }
                break;
        }
    }
    return hr;
}

HRESULT SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv)
{
    HRESULT hr;
    CRegPropertyBag *pbag = new CRegPropertyBag(grfMode);
    if (pbag)
    {
        hr = pbag->_Init(hk, pszSubKey);

        if (SUCCEEDED(hr))
            hr = pbag->QueryInterface(riid, ppv);

        pbag->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//
// Memory property bag implementation
//

typedef struct
{
    LPWSTR pszPropName;
    VARIANT variant;
} PBAGENTRY, * LPPBAGENTRY;

class CMemPropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);

protected:  // methods
    CMemPropertyBag(DWORD grfMode) : CBasePropertyBag(grfMode) {}
    ~CMemPropertyBag();
    HRESULT _Find(LPCOLESTR pszPropName, PBAGENTRY **pppbe, BOOL fCreate);

    friend HRESULT SHCreatePropertyBagOnMemory(DWORD grfMode, REFIID riid, void **ppv);

protected:  // members
    HDSA _hdsaProperties;
};

INT _FreePropBagCB(LPVOID pData, LPVOID lParam)
{
    LPPBAGENTRY ppbe = (LPPBAGENTRY)pData;
    Str_SetPtrW(&ppbe->pszPropName, NULL);
    VariantClear(&ppbe->variant);
    return 1;
}

CMemPropertyBag::~CMemPropertyBag()
{
    if (_hdsaProperties)
        DSA_DestroyCallback(_hdsaProperties, _FreePropBagCB, NULL);
}

//
// manange the list of propeties in the property bag
//

HRESULT CMemPropertyBag::_Find(LPCOLESTR pszPropName, PBAGENTRY **pppbe, BOOL fCreate)
{   
    int i;
    PBAGENTRY pbe = { 0 };

    *pppbe = NULL;

    // look up the property in the DSA
    // PERF: change to a DPA and sort accordingly for better perf (daviddv 110798)

    for ( i = 0 ; _hdsaProperties && (i < DSA_GetItemCount(_hdsaProperties)) ; i++ )
    {
        LPPBAGENTRY ppbe = (LPPBAGENTRY)DSA_GetItemPtr(_hdsaProperties, i);
        if ( !StrCmpIW(pszPropName, ppbe->pszPropName) )
        {
            *pppbe = ppbe;
            return S_OK;
        }
    }

    // no entry found, should we create one?

    if ( !fCreate )
        return E_FAIL;

    // yes, so lets check to see if we have a DSA yet.

    if ( !_hdsaProperties )
        _hdsaProperties = DSA_Create(SIZEOF(PBAGENTRY), 4);
    if ( !_hdsaProperties )
        return E_OUTOFMEMORY;

    // we have the DSA so lets fill the record we want to put into it

    if ( !Str_SetPtrW(&pbe.pszPropName, pszPropName) )
        return E_OUTOFMEMORY;

    VariantInit(&pbe.variant);

    // append it to the DSA we are using

    i = DSA_AppendItem(_hdsaProperties, &pbe);
    if ( -1 == i )
    {
        Str_SetPtrW(&pbe.pszPropName, NULL);
        return E_OUTOFMEMORY;
    }
    
    *pppbe = (LPPBAGENTRY)DSA_GetItemPtr(_hdsaProperties, i);

    return S_OK;
}


//
// IPropertyBag methods
//

STDMETHODIMP CMemPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pv, IErrorLog *pErrorLog)
{
    VARTYPE vtDesired = pv->vt;

    VariantInit(pv);

    HRESULT hr = _CanRead();
    if (SUCCEEDED(hr))
    {
        hr = (pszPropName && pv) ? S_OK : E_INVALIDARG;

        if (SUCCEEDED(hr))
        {
            LPPBAGENTRY ppbe;
            hr = _Find(pszPropName, &ppbe, FALSE);
            if (SUCCEEDED(hr))
            {
                hr = VariantCopy(pv, &ppbe->variant);
                if (SUCCEEDED(hr))
                    hr = VariantChangeTypeForRead(pv, vtDesired);
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CMemPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pv)
{
    HRESULT hr = _CanWrite();
    if (SUCCEEDED(hr))
    {
        hr = (pszPropName && pv) ? S_OK : E_INVALIDARG;
        if (SUCCEEDED(hr))
        {
            LPPBAGENTRY ppbe;
            hr = _Find(pszPropName, &ppbe, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = VariantCopy(&ppbe->variant, pv);
            }
        }
    }

    return hr;
}


//
// Exported function for creating a IPropertyBag (or variant of) object.
//

STDAPI SHCreatePropertyBagOnMemory(DWORD grfMode, REFIID riid, void **ppv)
{
    CMemPropertyBag *ppb = new CMemPropertyBag(grfMode);
    if (ppb)
    {    
        HRESULT hres = ppb->QueryInterface(riid, ppv);
        ppb->Release();

        return hres;
    }
    *ppv = NULL;
    return E_OUTOFMEMORY;
}



//
// Property bag helper functions
//

STDAPI SHPropertyBag_ReadType(IPropertyBag *ppb, LPCWSTR pszPropName, VARIANT *pv, VARTYPE vt)
{
    VariantInit(pv);
    pv->vt = vt;

    HRESULT hr = ppb->Read(pszPropName, pv, NULL);
    if (SUCCEEDED(hr))
    {
        if (vt != pv->vt && vt != VT_EMPTY)
        {
            TraceMsg(TF_WARNING, "SHPropertyBag_ReadType found an IPropertyBag that did not return the correct data!");
        }

        // Our IPropertyBag implementations have been buggy in the past, cover up for them
        hr = VariantChangeTypeForRead(pv, vt);
    }
    else
    {
        // don't break the caller by returning a bogus VARIANT struct
        VariantInit(pv);
    }

    return hr;
}

STDAPI SHPropertyBag_ReadBSTR(IPropertyBag *ppb, LPCWSTR pszPropName, BSTR* pbstr)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadBSTR caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadBSTR caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pbstr, *pbstr), "SHPropertyBag_ReadBSTR caller passed bad pbstr");

    HRESULT hr;

    if (ppb && pszPropName && pbstr)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_BSTR);
        if (SUCCEEDED(hr))
            *pbstr = va.bstrVal;
        else
            *pbstr = NULL;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadStr(IPropertyBag* ppb, LPCWSTR pszPropName, LPWSTR psz, int cch)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadStr caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadStr caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_BUFFER(psz, *psz, cch), "SHPropertyBag_ReadStr caller passed bad psz and cch");

    HRESULT hr;

    if (ppb && pszPropName && psz)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_BSTR);
        if (SUCCEEDED(hr))
        {
            StrCpyNW(psz, va.bstrVal, cch);
            VariantClear(&va);
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }          

    return hr;
}

STDAPI SHPropertyBag_WriteStr(IPropertyBag* ppb, LPCWSTR pszPropName, LPCWSTR psz)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteStr caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteStr caller passed bad pszPropName");
    RIPMSG(NULL == psz || IS_VALID_STRING_PTRW(psz, -1), "SHPropertyBag_WriteStr caller passed bad psz");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.bstrVal = SysAllocString(psz);

        if (va.bstrVal)
        {
            va.vt = VT_BSTR;
            hr = ppb->Write(pszPropName, &va);
            SysFreeString(va.bstrVal);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadInt(IPropertyBag* ppb, LPCWSTR pszPropName, int* piResult)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadInt caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadInt caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(piResult, *piResult), "SHPropertyBag_ReadInt caller passed bad piResult");

    HRESULT hr;

    if (ppb && pszPropName && piResult)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_I4);
        if (SUCCEEDED(hr))
        {
            *piResult = va.ulVal;
            // VT_I4 has nothing to VariantClear
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteInt(IPropertyBag* ppb, LPCWSTR pszPropName, int i)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteInt caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteInt caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_I4;
        va.lVal = i;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadSHORT(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT* psh)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadSHORT caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadSHORT caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(psh, *psh), "SHPropertyBag_ReadSHORT caller passed bad psh");

    HRESULT hr;

    if (ppb && pszPropName && psh)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_UI2);
        if (SUCCEEDED(hr))
        {
            *psh = va.iVal;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteSHORT(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT sh)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteSHORT caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteSHORT caller passed bad pszPropName");
 
    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_UI2;
        va.iVal = sh;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadLONG(IPropertyBag* ppb, LPCWSTR pszPropName, LONG* pl)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadLONG caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadLONG caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pl, *pl), "SHPropertyBag_ReadLONG caller passed bad pl");

    HRESULT hr;

    if (ppb && pszPropName && pl)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_I4);
        if (SUCCEEDED(hr))
        {
            *pl = va.ulVal;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteLONG(IPropertyBag* ppb, LPCWSTR pszPropName, LONG l)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteLONG caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteLONG caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_I4;
        va.lVal = l;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadDWORD(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadDWORD caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadDWORD caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pdw, *pdw), "SHPropertyBag_ReadInt caller passed bad pdw");

    HRESULT hr;

    if (ppb && pszPropName && pdw)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_UI4);
        if (SUCCEEDED(hr))
        {
            *pdw = va.ulVal;
            // VT_UI4 has nothing to VariantClear
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteDWORD(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD dw)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteDWORD caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteDWORD caller passed bad pszPropName");
 
    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_UI4;
        va.ulVal = dw;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

// This shipped on Whistler Beta 1.  It's exported by ordinal.
STDAPI_(BOOL) SHPropertyBag_ReadBOOLOld(IPropertyBag *ppb, LPCWSTR pwzPropName, BOOL fResult)
{
    VARIANT va;
    HRESULT hr = SHPropertyBag_ReadType(ppb, pwzPropName, &va, VT_BOOL);
    if (SUCCEEDED(hr))
    {
        fResult = (va.boolVal == VARIANT_TRUE);
        // VT_BOOL has nothing to VariantClear
    }
    return fResult;
}


STDAPI SHPropertyBag_ReadBOOL(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL* pfResult)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadBOOL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadBOOL caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pfResult, *pfResult), "SHPropertyBag_ReadBOOL caller passed bad pfResult");

    HRESULT hr;

    if (ppb && pszPropName && pfResult)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_BOOL);
        if (SUCCEEDED(hr))
        {
            *pfResult = (va.boolVal == VARIANT_TRUE);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteBOOL(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL fValue)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteBOOL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteBOOL caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_BOOL;
        va.boolVal = fValue ? VARIANT_TRUE : VARIANT_FALSE;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadGUID(IPropertyBag* ppb, LPCWSTR pszPropName, GUID* pguid)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadGUID caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadGUID caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pguid, *pguid), "SHPropertyBag_ReadGUID caller passed bad pguid");

    HRESULT hr;

    if (ppb && pszPropName && pguid)
    {
        VARIANT var;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &var, VT_EMPTY);
        if (SUCCEEDED(hr))
        {
            if (var.vt == (VT_ARRAY | VT_UI1)) // some code has been writing GUIDs as array's of bytes
            {
                hr = VariantToGUID(&var, pguid) ? S_OK : E_FAIL;
            }
            else if (var.vt == VT_BSTR)
            {
                hr = GUIDFromStringW(var.bstrVal, pguid) ? S_OK : E_FAIL;
            }
            VariantClear(&var);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
 
STDAPI SHPropertyBag_WriteGUID(IPropertyBag *ppb, LPCWSTR pszPropName, const GUID *pguid)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteGUID caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteGUID caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(pguid, *pguid), "SHPropertyBag_WriteGUID caller passed bad pguid");

    HRESULT hr;

    if (ppb && pszPropName && pguid)
    {
        WCHAR sz[64];
        SHStringFromGUIDW(*pguid, sz, ARRAYSIZE(sz));
        hr = SHPropertyBag_WriteStr(ppb, pszPropName, sz);            // assumes null terminator
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadPOINTL(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadPOINTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadPOINTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(ppt, *ppt), "SHPropertyBag_ReadPOINTL caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 2);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 3)
        {
            StrCpyNW(szProp + cch, L".x", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_ReadLONG(ppb, szProp, &ppt->x);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".y", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_ReadLONG(ppb, szProp, &ppt->y);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WritePOINTL(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTL* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WritePOINTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WritePOINTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(ppt, *ppt), "SHPropertyBag_WritePOINTL caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 2);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 3)
        {
            StrCpyNW(szProp + cch, L".x", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_WriteLONG(ppb, szProp, ppt->x);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".y", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_WriteLONG(ppb, szProp, ppt->y);

                if (FAILED(hr))
                {
                    StrCpyNW(szProp + cch, L".x", ARRAYSIZE(szProp) - cch);        
                    hr = SHPropertyBag_Delete(ppb, szProp);
                }                    
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadPOINTS(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadPOINTS caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadPOINTS caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(ppt, *ppt), "SHPropertyBag_ReadPOINTS caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        POINTL ptL;
        hr = SHPropertyBag_ReadPOINTL(ppb, pszPropName, &ptL);

        if (SUCCEEDED(hr))
        {
            ppt->x = static_cast<SHORT>(ptL.x);
            ppt->y = static_cast<SHORT>(ptL.y);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WritePOINTS(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTS* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WritePOINTS caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WritePOINTS caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(ppt, *ppt), "SHPropertyBag_WritePOINTS caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        POINTL ptL;
        ptL.x = ppt->x;
        ptL.y = ppt->y;

        hr = SHPropertyBag_WritePOINTL(ppb, pszPropName, &ptL);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadRECTL(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadRECTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadRECTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(prc, *prc), "SHPropertyBag_ReadRECTL caller passed bad prc");

    HRESULT hr;

    if (ppb && pszPropName && prc)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 7);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 8)
        {
            StrCpyNW(szProp + cch, L".left", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->left);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".top", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->top);

                if (SUCCEEDED(hr))
                {
                    StrCpyNW(szProp + cch, L".right", ARRAYSIZE(szProp) - cch);
                    hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->right);

                    if (SUCCEEDED(hr))
                    {
                        StrCpyNW(szProp + cch, L".bottom", ARRAYSIZE(szProp) - cch);
                        hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->bottom);
                    }
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteRECTL(IPropertyBag* ppb, LPCWSTR pszPropName, const RECTL* prc)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteRECTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteRECTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(prc, *prc), "SHPropertyBag_WriteRECTL caller passed bad prc");

    HRESULT hr;

    if (ppb && pszPropName && prc)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 7);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 8)
        {
            StrCpyNW(szProp + cch, L".left", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->left);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".top", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->top);

                if (SUCCEEDED(hr))
                {
                    StrCpyNW(szProp + cch, L".right", ARRAYSIZE(szProp) - cch);
                    hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->right);

                    if (SUCCEEDED(hr))
                    {
                        StrCpyNW(szProp + cch, L".bottom", ARRAYSIZE(szProp) - cch);
                        hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->bottom);

                        if (FAILED(hr))
                        {
                            StrCpyNW(szProp + cch, L".right", ARRAYSIZE(szProp) - cch);
                            hr = SHPropertyBag_Delete(ppb, szProp);
                        }
                    }

                    if (FAILED(hr))
                    {
                        StrCpyNW(szProp + cch, L".top", ARRAYSIZE(szProp) - cch);
                        hr = SHPropertyBag_Delete(ppb, szProp);
                    }
                }

                if (FAILED(hr))
                {
                    StrCpyNW(szProp + cch, L".left", ARRAYSIZE(szProp) - cch);        
                    hr = SHPropertyBag_Delete(ppb, szProp);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadStream(IPropertyBag* ppb, LPCWSTR pszPropName, IStream** ppstm)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_GetSTREAM caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_GetSTREAM caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(ppstm, *ppstm), "SHPropertyBag_GetSTREAM caller passed bad ppstm");

    HRESULT hr;

    if (ppb && pszPropName && ppstm)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_UNKNOWN);

        if (SUCCEEDED(hr))
        {
            hr = va.punkVal->QueryInterface(IID_PPV_ARG(IStream, ppstm));
            va.punkVal->Release();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteStream(IPropertyBag* ppb, LPCWSTR pszPropName, IStream* pstm)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_GetSTREAM caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_GetSTREAM caller passed bad pszPropName");
    RIPMSG(NULL != pstm, "SHPropertyBag_GetSTREAM caller passed bad pstm");

    HRESULT hr;

    if (ppb && pszPropName && pstm)
    {
        VARIANT va;
        va.vt = VT_UNKNOWN;
        va.punkVal = pstm;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDAPI SHPropertyBag_Delete(IPropertyBag* ppb, LPCWSTR pszPropName)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_GetSTREAM caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_GetSTREAM caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_EMPTY;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


class CDesktopUpgradePropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected: 
    CDesktopUpgradePropertyBag() : CBasePropertyBag(STGM_READ) {}
    ~CDesktopUpgradePropertyBag() {}
    friend HRESULT SHGetDesktopUpgradePropertyBag(REFIID riid, void** ppv);

private:
    HRESULT _ReadFlags(VARIANT* pVar);
    HRESULT _ReadItemPositions(VARIANT* pVar);
    IStream* _GetOldDesktopViewStream(void);
    IStream* _NewStreamFromOld(IStream* pstmOld);
    BOOL _AlreadyUpgraded(HKEY hk);
    void _MarkAsUpgraded(HKEY hk);
};

HRESULT CDesktopUpgradePropertyBag::_ReadFlags(VARIANT* pVar)
{
    HRESULT hr;

    FOLDERSETTINGS fs;
    DWORD cb = sizeof(fs);

    if (NOERROR == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\DeskView"),
                              TEXT("Settings"), NULL, (BYTE *)&fs, &cb)                   &&
        cb >= sizeof(fs))
    {
        pVar->uintVal = fs.fFlags | FWF_DESKTOP | FWF_NOCLIENTEDGE;
        pVar->vt = VT_UINT;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

typedef struct
{
    WORD  wSig;
    BYTE  bDontCare[12];
    WORD  cbPosOffset;
}OLDVS_STREAMHEADER;

#define OLDVS_STREAMHEADERSIG  28  // sizeof(WIN95HEADER)

IStream* CDesktopUpgradePropertyBag::_NewStreamFromOld(IStream* pstmOld)
{
    IStream* pstmNew = NULL;

    OLDVS_STREAMHEADER ovssh;

    if (SUCCEEDED(IStream_Read(pstmOld, &ovssh, sizeof(ovssh))) && OLDVS_STREAMHEADERSIG == ovssh.wSig)
    {
        LARGE_INTEGER liPos;
        liPos.QuadPart = ovssh.cbPosOffset - sizeof(ovssh);

        if (SUCCEEDED(pstmOld->Seek(liPos, STREAM_SEEK_CUR, NULL)))
        {
            ULARGE_INTEGER uliSize;

            if (SUCCEEDED(IStream_Size(pstmOld, &uliSize)))
            {
                pstmNew = SHCreateMemStream(NULL, 0);

                if (pstmNew)
                {
                    uliSize.QuadPart -= ovssh.cbPosOffset;

                    if (SUCCEEDED(pstmOld->CopyTo(pstmNew, uliSize, NULL, NULL)))
                    {
                        IStream_Reset(pstmNew);
                    }
                    else
                    {
                        pstmNew->Release();
                        pstmNew = NULL;
                    }
                }
            }
        }
    }

    return pstmNew;
}

BOOL CDesktopUpgradePropertyBag::_AlreadyUpgraded(HKEY hk)
{
    DWORD dwUpgrade;
    DWORD cbUpgrade = sizeof(dwUpgrade);
    DWORD dwType;    

    return (ERROR_SUCCESS == SHGetValueW(hk, NULL, L"Upgrade", &dwType, &dwUpgrade, &cbUpgrade));
}

void CDesktopUpgradePropertyBag::_MarkAsUpgraded(HKEY hk)
{
    DWORD dwVal = 1;
    SHSetValueW(hk, NULL, L"Upgrade", REG_DWORD, &dwVal, sizeof(dwVal));
}


IStream* CDesktopUpgradePropertyBag::_GetOldDesktopViewStream()
{
    IStream* pstmRet = NULL;

    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, L"Streams\\Desktop", FALSE);
    if (hk)
    {
        if (!_AlreadyUpgraded(hk))
        {
            pstmRet = SHOpenRegStream2W(hk, NULL, L"ViewView2", STGM_READ);

            if (NULL != pstmRet)
            {
                ULARGE_INTEGER uliSize;
                if (SUCCEEDED(IStream_Size(pstmRet, &uliSize)) && 0 == uliSize.QuadPart)
                {
                    pstmRet->Release();
                    pstmRet = NULL;
                }                   
            }

            if (NULL == pstmRet)
                pstmRet = SHOpenRegStream2W(hk, NULL, L"ViewView", STGM_READ);

            _MarkAsUpgraded(hk);
        }
        RegCloseKey(hk);        
    }

    return pstmRet;
}

HRESULT CDesktopUpgradePropertyBag::_ReadItemPositions(VARIANT* pVar)
{
    HRESULT hr = E_FAIL;

    IStream* pstmOld = _GetOldDesktopViewStream();
    if (pstmOld)
    {
        IStream* pstmNew = _NewStreamFromOld(pstmOld);
        if (pstmNew)
        {
            pVar->punkVal = pstmNew;
            pVar->vt      = VT_UNKNOWN;
            hr = S_OK;
        }

        pstmOld->Release();
    }

    return hr;
}


HRESULT CDesktopUpgradePropertyBag::Read(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    VARTYPE vtDesired = pVar->vt;

    if (0 == StrCmpW(VS_PROPSTR_FFLAGS, pszPropName))
    {
        hr = _ReadFlags(pVar); 
    }
    else if (0 == StrCmpNW(VS_PROPSTR_ITEMPOS, pszPropName, ARRAYSIZE(VS_PROPSTR_ITEMPOS) - 1))
    {
        hr = _ReadItemPositions(pVar);
    }
    else
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        hr = VariantChangeTypeForRead(pVar, vtDesired);
    }
    else
    {
        VariantInit(pVar);
    }

    return hr;
}

HRESULT CDesktopUpgradePropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    return E_NOTIMPL;
}


HRESULT SHGetDesktopUpgradePropertyBag(REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    CDesktopUpgradePropertyBag* pbag = new CDesktopUpgradePropertyBag();

    if (pbag)
    {
        hr = pbag->QueryInterface(riid, ppv);
        pbag->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




class CViewStatePropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected: 
    CViewStatePropertyBag(void);
    virtual ~CViewStatePropertyBag();
    HRESULT _Init(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags);
    BOOL    _IsSameBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags);
    friend HRESULT SHGetViewStatePropertyBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv);
    friend HRESULT GetCachedViewStatePropertyBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv);

private:
    HRESULT _CreateBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, REFIID riid, void** ppv);
    HRESULT _CreateUpgradeBag(REFIID riid, void** ppv);

    BOOL    _CanAccessPidlBag(void);
    BOOL    _EnsurePidlBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadPidlBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessUpgradeBag(void);
    BOOL    _EnsureUpgradeBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadUpgradeBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessInheritBag(void);
    BOOL    _EnsureInheritBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadInheritBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessUserDefaultsBag(void);
    BOOL    _EnsureUserDefaultsBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadUserDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessFolderDefaultsBag(void);
    BOOL    _EnsureFolderDefaultsBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadFolderDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessGlobalDefaultsBag(void);
    BOOL    _EnsureGlobalDefaultsBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadGlobalDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _EnsureReadBag(DWORD grfMode, REFIID riid);    
    BOOL    _EnsureWriteBag(DWORD grfMode, REFIID riid);    
    HRESULT _GetRegKey(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, HKEY hk, LPWSTR pszKey, UINT cch);
    DWORD   _GetMRUSize(HKEY hk);
    HRESULT _GetMRUSlots(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD adwSlot[], DWORD dwcSlots, DWORD* pdwFetched);
    HRESULT _GetMRUSlot(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD* pdwSlot);
    HKEY    _GetHKey(DWORD dwFlags);
    void    _ResetTryAgainFlag();
    HRESULT _FindNearestInheritBag(REFIID riid, void** ppv);
    void    _PruneMRUTree(void);
    BOOL    _IsSamePidl(LPCITEMIDLIST pidl);
    BOOL    _IsSystemFolder(void);

private:
    LPITEMIDLIST  _pidl;
    LPWSTR        _pszBagName;
    DWORD         _dwFlags;
    IPropertyBag* _ppbPidl;
    IPropertyBag* _ppbUpgrade;
    IPropertyBag* _ppbInherit;
    IPropertyBag* _ppbUserDefaults;
    IPropertyBag* _ppbFolderDefaults;
    IPropertyBag* _ppbGlobalDefaults;
    IPropertyBag* _ppbRead;
    IPropertyBag* _ppbWrite;

    BOOL          _fTriedPidlBag;
    BOOL          _fTriedUpgradeBag;
    BOOL          _fTriedInheritBag;
    BOOL          _fTriedUserDefaultsBag;
    BOOL          _fTriedFolderDefaultsBag;
    BOOL          _fTriedGlobalDefaultsBag;
    BOOL          _fTriedReadBag;
    BOOL          _fTriedWriteBag;
};

CViewStatePropertyBag::CViewStatePropertyBag() : CBasePropertyBag(STGM_READ)
{
    ASSERT(NULL == _pidl);
    ASSERT(NULL == _pszBagName);
    ASSERT(   0 == _dwFlags);
    ASSERT(NULL == _ppbPidl);
    ASSERT(NULL == _ppbUpgrade);
    ASSERT(NULL == _ppbInherit);
    ASSERT(NULL == _ppbUserDefaults);
    ASSERT(NULL == _ppbFolderDefaults);
    ASSERT(NULL == _ppbGlobalDefaults);
    ASSERT(NULL == _ppbRead);
    ASSERT(NULL == _ppbWrite);
}

CViewStatePropertyBag::~CViewStatePropertyBag()
{
    if (_pidl)
        ILFree(_pidl);

    if (_pszBagName)
        LocalFree(_pszBagName);

    if (_ppbPidl)
        _ppbPidl->Release();

    if (_ppbUpgrade)
        _ppbUpgrade->Release();

    if (_ppbInherit)
        _ppbInherit->Release();

    if (_ppbUserDefaults)
        _ppbUserDefaults->Release();

    if (_ppbFolderDefaults)
        _ppbFolderDefaults->Release();

    if (_ppbGlobalDefaults)
        _ppbGlobalDefaults->Release();

    if (_ppbRead)
        _ppbRead->Release();

    if (_ppbWrite)
        _ppbWrite->Release();
}

HKEY CViewStatePropertyBag::_GetHKey(DWORD dwFlags)
{
    HKEY hkRet;

    if ((dwFlags & SHGVSPB_PERUSER) || (dwFlags & SHGVSPB_INHERIT))
    {
        if (!(_dwFlags & SHGVSPB_ROAM) || !(dwFlags & SHGVSPB_PERFOLDER))
        {
            hkRet = SHGetShellKey(SHELLKEY_HKCU_SHELLNOROAM, NULL, TRUE);
        }
        else
        {
            hkRet = SHGetShellKey(SHELLKEY_HKCU_SHELL, NULL, TRUE);
        }
    }
    else
    {
        hkRet = SHGetShellKey(SHELLKEY_HKLM_SHELL, NULL, TRUE);
    }

    return hkRet;
}

DWORD CViewStatePropertyBag::_GetMRUSize(HKEY hk)
{
    DWORD dwMRUSize;
    DWORD dwSize = sizeof(dwMRUSize);

    if (NOERROR != SHGetValueW(hk, NULL, L"BagMRU Size", NULL, &dwMRUSize, &dwSize))
    {
        dwMRUSize = 400; // default size.
    }

    return dwMRUSize;
}

HRESULT CViewStatePropertyBag::_GetMRUSlots(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD adwSlots[], DWORD cSlots, DWORD* pdwFetched)
{
    HRESULT hr;

    IMruPidlList *pmru;
    hr = CoCreateInstance(CLSID_MruPidlList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMruPidlList, &pmru));

    if (SUCCEEDED(hr))
    {
        hr = pmru->InitList(_GetMRUSize(hk), hk, L"BagMRU");

        if (SUCCEEDED(hr))
        {
            hr = pmru->QueryPidl(pidl, cSlots, adwSlots, pdwFetched);

            if (S_OK == hr || (grfMode & (STGM_WRITE | STGM_READWRITE)))
            {
                hr = pmru->UsePidl(pidl, &adwSlots[0]);
            }
            else if (1 == cSlots) // return S_FALSE for cSlots > 1 if parent slots exist.
            {
                hr = E_FAIL;
            }
        }

        pmru->Release();
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_GetMRUSlot(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD* pdwSlot)
{
    DWORD dwFetched;

    return _GetMRUSlots(pidl, grfMode, hk, pdwSlot, 1, &dwFetched);
}

HRESULT CViewStatePropertyBag::_GetRegKey(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, HKEY hk, LPWSTR pszKey, UINT cch)
{
    HRESULT hr = S_OK;

    if ((dwFlags & SHGVSPB_PERFOLDER) || (dwFlags & SHGVSPB_INHERIT))
    {
        DWORD dwSlot;
        hr = _GetMRUSlot(pidl, grfMode, hk, &dwSlot);

        if (SUCCEEDED(hr))
        {
            if (!(dwFlags & SHGVSPB_INHERIT))
            {
                wnsprintfW(pszKey, cch, L"Bags\\%d\\%s", dwSlot, pszBagName);
            }
            else
            {
                wnsprintfW(pszKey, cch, L"Bags\\%d\\%s\\Inherit", dwSlot, pszBagName);
            }
        }
    }
    else
    {
        wnsprintfW(pszKey, cch, L"Bags\\AllFolders\\%s", pszBagName);
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_Init(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (pidl)
    {
        _pidl = ILClone(pidl);
    }

    _pszBagName = StrDupW(pszBagName);

    if (_pszBagName)
    {
        _dwFlags = dwFlags;
        hr = S_OK;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_IsSamePidl(LPCITEMIDLIST pidl)
{
    return (((pidl == NULL) && (_pidl == NULL)) ||
            ((pidl != NULL) && (_pidl != NULL) && ILIsEqual(pidl, _pidl)));
}
BOOL CViewStatePropertyBag::_IsSameBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags)
{
    return dwFlags == _dwFlags && 0 == StrCmpW(pszBagName, _pszBagName) && _IsSamePidl(pidl);
}

HRESULT CViewStatePropertyBag::_CreateBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, REFIID riid, void** ppv)
{
    HRESULT hr;

    DWORD grfMode2 = grfMode | ((grfMode & (STGM_WRITE | STGM_READWRITE)) ? STGM_CREATE : 0);

    if (!(dwFlags & SHGVSPB_ALLUSERS) || !(dwFlags & SHGVSPB_PERFOLDER))
    {
        HKEY hk = _GetHKey(dwFlags);

        if (hk)
        {
            WCHAR szRegSubKey[64];
            hr = _GetRegKey(pidl, pszBagName, dwFlags, grfMode2, hk, szRegSubKey, ARRAYSIZE(szRegSubKey));

            if (SUCCEEDED(hr))
            {            
                hr = SHCreatePropertyBagOnRegKey(hk, szRegSubKey, grfMode2, riid, ppv);
            }

            RegCloseKey(hk);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        IBindCtx* pbctx;
        hr = BindCtx_CreateWithMode(grfMode2, &pbctx);

        if (SUCCEEDED(hr))
        {
            // can't use - causes link problems.
            // hr = SHBindToObjectEx(NULL, _pidl, pbctx, riid, ppv); 

            IShellFolder* psf;
            hr = SHGetDesktopFolder(&psf);

            if (SUCCEEDED(hr))
            {
                hr = psf->BindToObject(_pidl, pbctx, riid, ppv);

                if (SUCCEEDED(hr) && NULL == *ppv)
                    hr = E_FAIL;

                psf->Release();
            }

            pbctx->Release();
        }
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_CreateUpgradeBag(REFIID riid, void** ppv)
{
    return SHGetDesktopUpgradePropertyBag(riid, ppv);
}

BOOL CViewStatePropertyBag::_CanAccessPidlBag()
{
    return (_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_PERFOLDER);
}

BOOL CViewStatePropertyBag::_EnsurePidlBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbPidl && !_fTriedPidlBag && _CanAccessPidlBag())
    {
        _fTriedPidlBag = TRUE;
        _CreateBag(_pidl, _pszBagName, (SHGVSPB_PERUSER | SHGVSPB_PERFOLDER), grfMode, riid, (void**)&_ppbPidl);
    }

    return NULL != _ppbPidl;
}

HRESULT CViewStatePropertyBag::_ReadPidlBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsurePidlBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbPidl->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessUpgradeBag()
{
    // only upgrade desktop for now.

    return 0 == StrCmpW(_pszBagName, VS_BAGSTR_DESKTOP);
}

BOOL CViewStatePropertyBag::_EnsureUpgradeBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbUpgrade && !_fTriedUpgradeBag && _CanAccessUpgradeBag())
    {
        _fTriedUpgradeBag = TRUE;

        _CreateUpgradeBag(riid, (void**)&_ppbUpgrade);
    }

    return NULL != _ppbUpgrade;
}

HRESULT CViewStatePropertyBag::_ReadUpgradeBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureUpgradeBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbUpgrade->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_FindNearestInheritBag(REFIID riid, void** ppv)
{
    HRESULT hr = E_FAIL;

    *ppv = NULL;

    HKEY hk = _GetHKey(SHGVSPB_INHERIT);
    if (hk)
    {
        DWORD aParentSlots[64];
        DWORD dwFetched;

        if (SUCCEEDED(_GetMRUSlots(_pidl, STGM_READ, hk, aParentSlots, ARRAYSIZE(aParentSlots), &dwFetched)))
        {
            for (DWORD i = 0; i < dwFetched && FAILED(hr); i++)
            {
                WCHAR szRegSubKey[64];
                wnsprintfW(szRegSubKey, ARRAYSIZE(szRegSubKey), L"Bags\\%d\\%s\\Inherit", aParentSlots[i], _pszBagName);

                hr = SHCreatePropertyBagOnRegKey(hk, szRegSubKey, STGM_READ, riid, ppv);
            }
        }

        RegCloseKey(hk);
    }

    return hr;
}


BOOL CViewStatePropertyBag::_CanAccessInheritBag()
{
    return _CanAccessPidlBag() || (_dwFlags & SHGVSPB_INHERIT);
}

BOOL CViewStatePropertyBag::_EnsureInheritBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbInherit && !_fTriedInheritBag && _CanAccessInheritBag())
    {
        _fTriedInheritBag = TRUE;
        _FindNearestInheritBag(riid, (void**)&_ppbInherit);
    }

    return NULL != _ppbInherit;
}

HRESULT CViewStatePropertyBag::_ReadInheritBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureInheritBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbInherit->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessUserDefaultsBag()
{
    return _CanAccessPidlBag() || ((_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_ALLFOLDERS));
}

BOOL CViewStatePropertyBag::_EnsureUserDefaultsBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbUserDefaults && !_fTriedUserDefaultsBag && _CanAccessUserDefaultsBag())
    {
        _fTriedUserDefaultsBag = TRUE;
        _CreateBag(NULL, _pszBagName, SHGVSPB_PERUSER | SHGVSPB_ALLFOLDERS, grfMode, riid, (void**)&_ppbUserDefaults);
    }

    return NULL != _ppbUserDefaults;
}

HRESULT CViewStatePropertyBag::_ReadUserDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureUserDefaultsBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbUserDefaults->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessFolderDefaultsBag()
{
    return _CanAccessUserDefaultsBag() || ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_PERFOLDER));
}

BOOL CViewStatePropertyBag::_IsSystemFolder()
{
    BOOL fRet = FALSE;
    LPCITEMIDLIST pidlLast;
    IShellFolder* psf;
    if (SUCCEEDED(SHBindToParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast)))
    {
        WIN32_FIND_DATAW fd;
        if (SUCCEEDED(SHGetDataFromIDListW(psf, pidlLast, SHGDFIL_FINDDATA, &fd, sizeof(fd))))
        {
            fRet = PathIsSystemFolder(NULL, fd.dwFileAttributes);
        }

        psf->Release();
    }
    
    return fRet;
}

BOOL CViewStatePropertyBag::_EnsureFolderDefaultsBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbFolderDefaults && !_fTriedFolderDefaultsBag && _CanAccessFolderDefaultsBag())
    {
        _fTriedFolderDefaultsBag = TRUE;

        // PERF: Use the desktop.ini only if the folder is a system folder.
        if (_IsSystemFolder())
        {
            _CreateBag(_pidl, _pszBagName, SHGVSPB_ALLUSERS | SHGVSPB_PERFOLDER, grfMode, riid, (void**)&_ppbFolderDefaults);
        }
    }

    return NULL != _ppbFolderDefaults;
}

HRESULT CViewStatePropertyBag::_ReadFolderDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureFolderDefaultsBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbFolderDefaults->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessGlobalDefaultsBag()
{
    return _CanAccessFolderDefaultsBag() || ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_ALLFOLDERS));
}

BOOL CViewStatePropertyBag::_EnsureGlobalDefaultsBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbGlobalDefaults && !_fTriedGlobalDefaultsBag && _CanAccessGlobalDefaultsBag())
    {
        _fTriedGlobalDefaultsBag = TRUE;
        _CreateBag(NULL, _pszBagName, SHGVSPB_ALLUSERS | SHGVSPB_ALLFOLDERS, grfMode, riid, (void**)&_ppbGlobalDefaults);
    }

    return NULL != _ppbGlobalDefaults;
}

HRESULT CViewStatePropertyBag::_ReadGlobalDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureGlobalDefaultsBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbGlobalDefaults->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_EnsureReadBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbRead && !_fTriedReadBag)
    {
        _fTriedReadBag = TRUE;
        _CreateBag(_pidl, _pszBagName, _dwFlags, grfMode, riid, (void**)&_ppbRead);
    }

    return NULL != _ppbRead;
}

HRESULT CViewStatePropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if ((_dwFlags & SHGVSPB_NOAUTODEFAULTS) || (_dwFlags & SHGVSPB_INHERIT))
    {
        if (_EnsureReadBag(STGM_READ, IID_IPropertyBag))
        {
            hr = _ppbRead->Read(pszPropName, pVar, pErrorLog);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = _ReadPidlBag(pszPropName, pVar, pErrorLog); // per user per folder

        if (FAILED(hr))
        {
            hr = _ReadInheritBag(pszPropName, pVar, pErrorLog);

            if (FAILED(hr))
            {
                hr = _ReadUpgradeBag(pszPropName, pVar, pErrorLog); // (legacy per user per folder)

                if (FAILED(hr))
                {
                    hr = _ReadUserDefaultsBag(pszPropName, pVar, pErrorLog); // per user all folders

                    if (FAILED(hr))
                    {
                        hr = _ReadFolderDefaultsBag(pszPropName, pVar, pErrorLog); // per folder all users

                        if (FAILED(hr))
                        {
                            hr = _ReadGlobalDefaultsBag(pszPropName, pVar, pErrorLog); // all folders all users
                        }
                    }
                }
            }
        }
    }

    return hr;
}

void CViewStatePropertyBag::_PruneMRUTree()
{
    HKEY hk = _GetHKey(SHGVSPB_INHERIT);

    if (hk)
    {
        IMruPidlList *pmru;
        HRESULT hr = CoCreateInstance(CLSID_MruPidlList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMruPidlList, &pmru));

        if (SUCCEEDED(hr))
        {
            hr = pmru->InitList(200, hk, L"BagMRU");

            if (SUCCEEDED(hr))
            {
                pmru->PruneKids(_pidl);
            }

            pmru->Release();
        }

        RegCloseKey(hk);
    }
}

void CViewStatePropertyBag::_ResetTryAgainFlag()
{
    if (_dwFlags & SHGVSPB_NOAUTODEFAULTS)
    {
        _fTriedReadBag = FALSE;      
    }
    else
    {
        if ((_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_PERFOLDER))
        {
            _fTriedPidlBag = FALSE;
        }
        else if (_dwFlags & SHGVSPB_INHERIT)
        {
            _fTriedInheritBag = FALSE;
        }
        else if ((_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_ALLFOLDERS))
        {
            _fTriedUserDefaultsBag = FALSE;
        }
        else if ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_PERFOLDER))
        {
            _fTriedFolderDefaultsBag = FALSE;
        }
        else if ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_ALLFOLDERS))
        {
            _fTriedGlobalDefaultsBag = FALSE;
        }
    }
}

BOOL CViewStatePropertyBag::_EnsureWriteBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbWrite && !_fTriedWriteBag)
    {
        _fTriedWriteBag = TRUE;
        _CreateBag(_pidl, _pszBagName, _dwFlags, grfMode, riid, (void**)&_ppbWrite);
        if (_ppbWrite)
        {
            _ResetTryAgainFlag();

            if (SHGVSPB_INHERIT & _dwFlags)
            {
                _PruneMRUTree();
            }
        }
    }

    return NULL != _ppbWrite;
}

HRESULT CViewStatePropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    HRESULT hr;

    if (_EnsureWriteBag(STGM_WRITE, IID_IPropertyBag))
    {
        hr = _ppbWrite->Write(pszPropName, pVar);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


#ifdef DEBUG

void IS_VALID_SHGVSPB_PARAMS(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv)
{
    RIP((NULL == pidl && (dwFlags & SHGVSPB_ALLFOLDERS)) || (IsValidPIDL(pidl) && ((SHGVSPB_PERFOLDER & dwFlags) || (SHGVSPB_INHERIT & dwFlags))));
    RIP(pszBagName);
    RIP(SHGVSPB_PERUSER == (dwFlags & (SHGVSPB_PERUSER | SHGVSPB_ALLUSERS | SHGVSPB_INHERIT)) || SHGVSPB_ALLUSERS == (dwFlags & (SHGVSPB_PERUSER | SHGVSPB_ALLUSERS | SHGVSPB_INHERIT)) || SHGVSPB_INHERIT == (dwFlags & (SHGVSPB_PERUSER | SHGVSPB_ALLUSERS | SHGVSPB_INHERIT)));
    RIP(SHGVSPB_PERFOLDER  == (dwFlags & (SHGVSPB_PERFOLDER | SHGVSPB_ALLFOLDERS | SHGVSPB_INHERIT)) || SHGVSPB_ALLFOLDERS == (dwFlags & (SHGVSPB_PERFOLDER | SHGVSPB_ALLFOLDERS | SHGVSPB_INHERIT)) || SHGVSPB_INHERIT == (dwFlags & (SHGVSPB_PERFOLDER | SHGVSPB_ALLFOLDERS | SHGVSPB_INHERIT)));
    RIP(riid == IID_IPropertyBag || riid == IID_IUnknown);
    RIP(NULL != ppv);
}

#else

#define IS_VALID_SHGVSPB_PARAMS(a, b, c, d, e)

#endif

// Cache the last bag accessed. 
CViewStatePropertyBag* g_pCachedBag = NULL;

EXTERN_C void FreeViewStatePropertyBagCache()
{
    ENTERCRITICAL;
    {
        if (g_pCachedBag)
        {
            g_pCachedBag->Release();
            g_pCachedBag = NULL;
        }
    }
    LEAVECRITICAL;
}

BOOL SHIsRemovableDrive(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;
    LPCITEMIDLIST pidlLast;
    IShellFolder* psf;
    if (SUCCEEDED(SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast)))
    {
        STRRET str;
        if (SUCCEEDED(psf->GetDisplayNameOf(pidlLast, SHGDN_FORPARSING, &str)))
        {
            WCHAR szPath[MAX_PATH];
            if (SUCCEEDED(StrRetToBufW(&str, pidlLast, szPath, ARRAYSIZE(szPath))))
            {
                int iDrive = PathGetDriveNumberW(szPath);
                if (iDrive != -1)
                {
                    int iDriveType = RealDriveType(iDrive, FALSE);

                    fRet = (DRIVE_REMOVABLE == iDriveType || DRIVE_CDROM == iDriveType);
                }
            }
        }

        psf->Release();
    }
    
    return fRet;
}

STDAPI SHGetViewStatePropertyBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv)
{
    IS_VALID_SHGVSPB_PARAMS(pidl, pszBagName, dwFlags, riid, ppv);

    HRESULT hr;

    *ppv = NULL;

    ENTERCRITICAL;
    {
        if (g_pCachedBag && g_pCachedBag->_IsSameBag(pidl, pszBagName, dwFlags))
        {
            hr = S_OK;
        }
        else
        {
            if (!SHIsRemovableDrive(pidl))
            {
                CViewStatePropertyBag* pBag = new CViewStatePropertyBag();

                if (pBag)
                {
                    hr = pBag->_Init(pidl, pszBagName, dwFlags);

                    if (SUCCEEDED(hr))
                    {
                        if (g_pCachedBag)
                            g_pCachedBag->Release();

                        g_pCachedBag = pBag;
                    }
                    else
                    {
                        pBag->Release();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;  // don't save property bags for removable drives.
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = g_pCachedBag->QueryInterface(riid, ppv);
        }
    }
    LEAVECRITICAL;

    return hr;
}

ULONG SHGetPerScreenResName(WCHAR* pszRes, ULONG cch, DWORD dwVersion)
{
    RIPMSG(IS_VALID_WRITE_BUFFER(pszRes, *pszRes, cch), "SHGetPerScreenResName caller passed bad pszRes or cch");

    ULONG uRet;

    if (0 == dwVersion)
    {
        HDC hdc = GetDC(NULL);
        int x = GetDeviceCaps(hdc, HORZRES);
        int y = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(NULL, hdc);

        int n = GetSystemMetrics(SM_CMONITORS);

        int cchLen = wnsprintfW(pszRes, cch, L"%dx%d(%d)", x, y, n);    

        uRet =  (cchLen > 0) ? cchLen : 0;
    }
    else
    {
        uRet = 0;
    }

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\qistub.cpp ===
// this version of qistub is for retail only.
// if clients (e.g. shell32) want debug version
// they staticaly link to it (and the local version
// overwrites this one

#include "priv.h"

#ifdef  DEBUG
// warning Warning WARNING!!!
// priv.h's PCH has been built DEBUG, and now we're #undef'ing it.
// so various macros are still 'on'.  this leads to inconsistencies
// in ../lib/qistub.cpp.  i've hacked around this for the 1 known
// pblm case in ../lib/qistub.cpp (DBEXEC).
//
// (and we can't just move the #undef up above priv.h, it will still
// be ignored because the PCH already exists).
//
// i'm 99% sure that the reason we don't want DEBUG on here is to avoid
// having any static data in shlwapi.  that's an old restriction (though
// still a perf issue) (but not for DEBUG...), so for DEBUG we can probably
// just remove this entire hack.  i haven't tested that theory yet though
// so for now we'll continue to live w/ it.
#undef  DEBUG
#endif

#include "..\inc\qistub.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\privpath.h ===
#ifndef _PRIVPATH_H_
#define _PRIVPATH_H_

//
// #define all private path functions here so we dont get redefinition
// warnings when linking pathw.obj and patha.obj, who both have these
// functions.
//
#ifdef UNICODE
#define CaseConvertPathExceptDBCS CaseConvertPathExceptDBCSW
#define AnsiLowerNoDBCS AnsiLowerNoDBCSW
#define AnsiUpperNoDBCS AnsiUpperNoDBCSW
#define AnsiLowerBuffNoDBCS AnsiLowerBuffNoDBCSW
#define AnsiUpperBuffNoDBCS AnsiUpperBuffNoDBCSW
#define NextPath NextPathW
#define IsOtherDir IsOtherDirW
#define StrSlash StrSlashW
#define GetPCEnd GetPCEndW
#define PCStart PCStartW
#define NearRootFixups NearRootFixupsW
#define UnExpandEnvironmentString UnExpandEnvironmentStringW
#define IsSystemSpecialCase IsSystemSpecialCaseW
#define CharLowerBuffNoDBCS CharLowerBuffNoDBCSW
#define CharUpperBuffNoDBCS CharUpperBuffNoDBCSW
#define PathMatchSingleSpec PathMatchSingleSpecW
#else
#define CaseConvertPathExceptDBCS CaseConvertPathExceptDBCSA
#define AnsiLowerNoDBCS AnsiLowerNoDBCSA
#define AnsiUpperNoDBCS AnsiUpperNoDBCSA
#define AnsiLowerBuffNoDBCS AnsiLowerBuffNoDBCSA
#define AnsiUpperBuffNoDBCS AnsiUpperBuffNoDBCSA
#define NextPath NextPathA
#define IsOtherDir IsOtherDirA
#define StrSlash StrSlashA
#define GetPCEnd GetPCEndA
#define PCStart PCStartA
#define NearRootFixups NearRootFixupsA
#define UnExpandEnvironmentString UnExpandEnvironmentStringA
#define IsSystemSpecialCase IsSystemSpecialCaseA
#define CharLowerBuffNoDBCS CharLowerBuffNoDBCSA
#define CharUpperBuffNoDBCS CharUpperBuffNoDBCSA
#define PathMatchSingleSpec PathMatchSingleSpecA
#endif // UNICODE


#endif // _PRIVPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\regsrc.cpp ===
#include "priv.h"

#include <enumt.h>
#include <memt.h>
#include "assoc.h"

class CRegistrySource : public IQuerySource, public IObjectWithRegistryKey
{
    
public:  //  methods
    CRegistrySource() : _cRef(1), _hk(NULL) {}
    ~CRegistrySource() { if (_hk) RegCloseKey(_hk); }
    HRESULT Init(HKEY hk, PCWSTR pszSub, BOOL fCreate);
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef()
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    //  IObjectWithRegistryKey
    STDMETHODIMP SetKey(HKEY hk);
    STDMETHODIMP GetKey(HKEY *phk);

    //  IQuerySource
    STDMETHODIMP EnumValues(IEnumString **ppenum);
    STDMETHODIMP EnumSources(IEnumString **ppenum);
    STDMETHODIMP QueryValueString(PCWSTR pszSubSource, PCWSTR pszValue, PWSTR *ppsz);
    STDMETHODIMP QueryValueDword(PCWSTR pszSubSource, PCWSTR pszValue, DWORD *pdw);
    STDMETHODIMP QueryValueExists(PCWSTR pszSubSource, PCWSTR pszValue); 
    STDMETHODIMP QueryValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, FLAGGED_BYTE_BLOB **ppblob);
    STDMETHODIMP OpenSource(PCWSTR pszSubSource, BOOL fCreate, IQuerySource **ppqs);
    STDMETHODIMP SetValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, ULONG qvt, DWORD cbData, BYTE *pvData);

protected: // methods

protected: // members
    LONG _cRef;
    HKEY _hk;
};

STDAPI CRegistrySource::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CRegistrySource, IQuerySource),
    QITABENT(CRegistrySource, IObjectWithRegistryKey),
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CRegistrySource::Init(HKEY hk, PCWSTR pszSub, BOOL fCreate)
{
    DWORD err;
    if (!fCreate)
        err = RegOpenKeyExW(hk, pszSub, 0, MAXIMUM_ALLOWED, &_hk);
    else
        err = RegCreateKeyExW(hk, pszSub, 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &_hk, NULL);

    return HRESULT_FROM_WIN32(err);
}

HRESULT CRegistrySource::SetKey(HKEY hk)
{ 
    if (!_hk)
    {
        _hk = SHRegDuplicateHKey(hk);
        if (_hk)
            return S_OK;
    }
    return E_UNEXPECTED;
}

HRESULT CRegistrySource::GetKey(HKEY *phk)
{
    if (_hk)
    {
        *phk = SHRegDuplicateHKey(_hk);
        if (*phk)
            return S_OK;
    }
    *phk = NULL;
    return E_UNEXPECTED;
}

HRESULT CRegistrySource::QueryValueString(PCWSTR pszSubSource, PCWSTR pszValue, PWSTR *ppsz)
{
    HRESULT hr = E_UNEXPECTED;
    WCHAR sz[128];
    DWORD cb = sizeof(sz);
    DWORD dwType;
    LONG err = SHGetValueW(_hk, pszSubSource, pszValue, &dwType, sz, &cb);
    *ppsz = 0;
    if (err == ERROR_SUCCESS)
    {    
        if (dwType == REG_SZ)
        {
            //  if they are querying for the default value, 
            //  then fail if it is empty
            if (pszValue || *sz)
                hr = SHStrDupW(sz, ppsz);
            else
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
        else 
            hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
    }
    else
    {
        if (err == ERROR_MORE_DATA)
        {
            //  retry with an alloc'd buffer
            ASSERT(cb > sizeof(sz));
            hr = SHCoAlloc(cb, ppsz);
            if (SUCCEEDED(hr))
            {
                err = SHGetValueW(_hk, pszSubSource, pszValue, &dwType, *ppsz, &cb);

                if (dwType != REG_SZ)
                    err = ERROR_DATATYPE_MISMATCH;
                    
                if (err)
                {
                    CoTaskMemFree(*ppsz);
                    *ppsz = 0;
                    hr = HRESULT_FROM_WIN32(err);
                }
            }
        }
        else
            hr = HRESULT_FROM_WIN32(err);
    }
    
    return hr;
}

HRESULT CRegistrySource::QueryValueDword(PCWSTR pszSubSource, PCWSTR pszValue, DWORD *pdw)
{
    DWORD cb = sizeof(*pdw);
    //  DWORD dwType;
    LONG err = SHGetValueW(_hk, pszSubSource, pszValue, NULL, pdw, &cb);
    //  dwType check REG_DWORD || REG_BINARY?
    return HRESULT_FROM_WIN32(err);
}

HRESULT CRegistrySource::QueryValueExists(PCWSTR pszSubSource, PCWSTR pszValue)
{
    LONG err = SHGetValueW(_hk, pszSubSource, pszValue, NULL, NULL, NULL);
    return HRESULT_FROM_WIN32(err);
}

HRESULT _SHAllocBlob(DWORD cb, BYTE *pb, FLAGGED_BYTE_BLOB **ppblob)
{
    HRESULT hr = SHCoAlloc(cb + FIELD_OFFSET(FLAGGED_BYTE_BLOB, abData), ppblob);
    if (SUCCEEDED(hr))
    {
        (*ppblob)->clSize = cb;
        if (pb)
            memcpy((*ppblob)->abData, pb, cb);
    }
    return hr;
}

HRESULT CRegistrySource::QueryValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, FLAGGED_BYTE_BLOB **ppblob)
{
    HRESULT hr = E_FAIL;
    BYTE rgch[256];
    DWORD cb = sizeof(rgch);
    DWORD dwType;
    HKEY hk = _hk;
    LONG err = ERROR_SUCCESS;

    *ppblob = 0;
    if (pszSubSource && *pszSubSource)
    {
        err = RegOpenKeyExW(_hk, pszSubSource, 0, KEY_QUERY_VALUE, &hk);
        ASSERT(NO_ERROR == err || !hk);
    }
            
    if (err == ERROR_SUCCESS)
    {
        err = RegQueryValueExW(hk, pszValue, NULL, &dwType, rgch, &cb);
        if (err == ERROR_SUCCESS)
        {
            hr = _SHAllocBlob(cb, rgch, ppblob);
        }
        else
        {
            if (err == ERROR_MORE_DATA)
            {
                //  retry with an alloc'd buffer
                ASSERT(cb > sizeof(rgch));
                hr = _SHAllocBlob(cb, NULL, ppblob);
                if (SUCCEEDED(hr))
                {
                    err = RegQueryValueExW(hk, pszValue, NULL, &dwType, (*ppblob)->abData, &cb);
                    if (err)
                    {
                        CoTaskMemFree(*ppblob);
                        *ppblob = 0;
                    }
                }
            }

            hr = HRESULT_FROM_WIN32(err);
        }
        if (hk != _hk)
            RegCloseKey(hk);
    }


    if (SUCCEEDED(hr))
        (*ppblob)->fFlags = dwType;
        
    return hr;
}

HRESULT CRegistrySource::OpenSource(PCWSTR pszSubSource, BOOL fCreate, IQuerySource **ppqs)
{
    return QuerySourceCreateFromKey(_hk, pszSubSource, fCreate, IID_PPV_ARG(IQuerySource, ppqs));
}

HRESULT CRegistrySource::SetValueDirect(PCWSTR pszSubSource, PCWSTR pszValue, ULONG qvt, DWORD cbData, BYTE *pvData)
{
    LONG err = SHSetValueW(_hk, pszSubSource, pszValue, qvt, pvData, cbData);
    return HRESULT_FROM_WIN32(err);
}

class CRegistryEnum : public CEnumAny<IEnumString, PWSTR>
{
public:
    HRESULT Init(HKEY hk, CRegistrySource *prs)
    { 
        //  we take a ref on the _punk to keep 
        //  the key alive
        _hk = hk;
        _punkKey = SAFECAST(prs, IQuerySource *);
        prs->AddRef();
        
        _cch = _MaxLen();
        if (_cch > ARRAYSIZE(_sz))
        {
            _psz = (PWSTR) LocalAlloc(LPTR, CbFromCchW(_cch));
        }
        else
        {
            _cch = ARRAYSIZE(_sz);
            _psz = _sz;
        }
        return _psz ? S_OK : E_OUTOFMEMORY;
    }

    virtual ~CRegistryEnum() { if (_psz && _psz != _sz) LocalFree(_psz); _punkKey->Release(); }
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);

        
protected:  // methods    
    BOOL _Next(PWSTR *ppsz);
    virtual DWORD _MaxLen() = 0;
    virtual BOOL _RegNext(LONG i) = 0;

protected:
    IUnknown *_punkKey;
    HKEY _hk;
    PWSTR _psz;
    WCHAR _sz[64];
    DWORD _cch;
};

STDAPI CRegistryEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CRegistryEnum, IEnumString),
    };

    return QISearch(this, qit, riid, ppvObj);
}

BOOL CRegistryEnum::_Next(PWSTR *ppsz)
{
    return (_RegNext(_cNext) && SUCCEEDED(SHStrDupW(_psz, ppsz)));
}

class CRegistryEnumKeys : public CRegistryEnum
{
protected:  // methods
    DWORD _MaxLen()
    {
        DWORD cch = 0;
        RegQueryInfoKeyW(
            _hk,
            NULL,
            NULL,
            NULL,
            NULL,
            &cch,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
        );
        return cch;
    }

    BOOL _RegNext(LONG i)
    {
        return ERROR_SUCCESS == RegEnumKeyW(_hk, i, _psz, _cch);
    }
};

class CRegistryEnumValues : public CRegistryEnum
{
protected:  // methods
    DWORD _MaxLen()
    {
        DWORD cch = 0;
        RegQueryInfoKeyW(
            _hk,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cch,
            NULL,
            NULL,
            NULL
        );
        return cch;
    }
    
    BOOL _RegNext(LONG i)
    {
        DWORD cch = _cch;
        return ERROR_SUCCESS == RegEnumValueW(_hk, i, _psz, &cch, NULL, NULL, NULL, NULL);
    }
};

STDMETHODIMP CRegistrySource::EnumValues(IEnumString **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CRegistryEnum *pre = new CRegistryEnumValues();
    *ppenum = 0;
    if (pre)
    {
        hr = pre->Init(_hk, this);
        if (SUCCEEDED(hr))
            *ppenum = pre;
        else
            pre->Release();
    }
    return hr;
}

STDMETHODIMP CRegistrySource::EnumSources(IEnumString **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CRegistryEnum *pre = new CRegistryEnumKeys();
    *ppenum = 0;
    if (pre)
    {
        hr = pre->Init(_hk, this);
        if (SUCCEEDED(hr))
            *ppenum = pre;
        else
            pre->Release();
    }
    return hr;
}

LWSTDAPI QuerySourceCreateFromKey(HKEY hk, PCWSTR pszSub, BOOL fCreate, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CRegistrySource *prs = new CRegistrySource();
    *ppv = 0;
    if (prs)
    {
        hr = prs->Init(hk, pszSub, fCreate);
        if (SUCCEEDED(hr))
            hr = prs->QueryInterface(riid, ppv);
        prs->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\reg.c ===
#include "priv.h"
#include <regapix.h>

/*----------------------------------------------------------
Purpose: Helper function to delete a key that has no subkeys and
         no values.  Otherwise does nothing.  Mimics what RegDeleteKey
         does on NT.

Returns:
Cond:    --
*/
DWORD
DeleteEmptyKey(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey)
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_READ | KEY_SET_VALUE, 
                          &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        DWORD ckeys;
        DWORD cvalues;

        // Are there any subkeys or values?

        dwRet = RegQueryInfoKey(hkeyNew, NULL, NULL, NULL, &ckeys,
                                NULL, NULL, &cvalues, NULL, NULL,
                                NULL, NULL);
        if (NO_ERROR == dwRet &&
            0 == cvalues && 0 == ckeys)
        {
            // No; delete the subkey
            dwRet = RegDeleteKeyA(hkey, pszSubKey);
        }
        else
        {
            dwRet = ERROR_DIR_NOT_EMPTY;
        }
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursivelyA(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursivelyA(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        if (pszSubKey)
        {
            dwRet = RegDeleteKeyA(hkey, pszSubKey);
        }
        else
        {
            //  we want to delete all the values by hand
            cchSubKeyName = ARRAYSIZE(szSubKeyName);
            while (ERROR_SUCCESS == RegEnumValueA(hkey, 0, szSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValueA(hkey, szSubKeyName))
                    break;
                    
                cchSubKeyName = ARRAYSIZE(szSubKeyName);
            }
        }
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursivelyW(
    IN HKEY   hkey, 
    IN LPCWSTR pwszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        WCHAR   wszSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(wszSubKeyName);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyW(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyW(hkSubKey, --dwIndex, wszSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursivelyW(hkSubKey, wszSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        if (pwszSubKey)
        {
            dwRet = RegDeleteKeyW(hkey, pwszSubKey);
        }
        else
        {
            //  we want to delete all the values by hand
            cchSubKeyName = ARRAYSIZE(wszSubKeyName);
            while (ERROR_SUCCESS == RegEnumValueW(hkey, 0, wszSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValueW(hkey, wszSubKeyName))
                    break;
                    
                cchSubKeyName = ARRAYSIZE(wszSubKeyName);
            }
        }
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Sets a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHSetValueA(
    IN  HKEY    hkey,
    IN OPTIONAL LPCSTR  pszSubKey,
    IN  LPCSTR  pszValue,
    IN  DWORD   dwType,
    IN  LPCVOID pvData,
    IN  DWORD   cbData)
{
    DWORD dwRet = NO_ERROR;
    HKEY hkeyNew;

    if (pszSubKey && pszSubKey[0])
        dwRet = RegCreateKeyExA(hkey, pszSubKey, 0, "", REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkeyNew, NULL);
    else
        hkeyNew = hkey;

    if (NO_ERROR == dwRet)
    {
        dwRet = RegSetValueExA(hkeyNew, pszValue, 0, dwType, pvData, cbData);

        if (hkeyNew != hkey)
            RegCloseKey(hkeyNew);
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Sets a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHSetValueW(
    IN  HKEY    hkey,
    IN OPTIONAL LPCWSTR pwszSubKey,
    IN  LPCWSTR pwszValue,
    IN  DWORD   dwType,
    IN  LPCVOID pvData,
    IN  DWORD   cbData)
{
    DWORD dwRet = NO_ERROR;
    HKEY hkeyNew;

    if (pwszSubKey && pwszSubKey[0])
    {
        dwRet = RegCreateKeyExW(hkey, pwszSubKey, 0, L"", REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkeyNew, NULL);
    }
    else
        hkeyNew = hkey;

    if (NO_ERROR == dwRet)
    {
        dwRet = RegSetValueExW(hkeyNew, pwszValue, 0, dwType, pvData, cbData);

        if (hkeyNew != hkey)
            RegCloseKey(hkeyNew);
    }

    return dwRet;

}


/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteValueA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey,
    IN  LPCSTR  pszValue)
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegDeleteValueA(hkeyNew, pszValue);
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteValueW(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey,
    IN  LPCWSTR pwszValue)
{
    HKEY hkeyNew;
	DWORD dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegDeleteValueW(hkeyNew, pwszValue);
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}

// purpose: recursively copy subkeys and values of hkeySrc\pszSrcSubKey to hkeyDest
// e.g. hkeyExplorer = HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\
//      SHCopyKey(HKEY_CURRENT_USER, "Software\\Classes\\", hkeyExplorer, 0)
// results in
//      ...\\CurrentVersion\\Explorer\\
//                                     Appid
//                                     CLSID\\
//                                            {xxxx yyyyy ...}
//                                     Interface
//                                     ...
// TO DO: currently we are not copying the ACL's but in the future we should do that
// upon request that's what fReserved is for
// NOTE that there is no hkeyDest, pszDestSubKey pair like src one, because in case
// pszDestSubKey did not exist we would have to create it and deal with Class name
// which would just clober the parameter list
STDAPI_(DWORD) SHCopyKeyA(HKEY hkeySrc, LPCSTR pszSrcSubKey, HKEY hkeyDest, DWORD fReserved)
{
    HKEY hkeyFrom;
    DWORD dwRet;
    
    if (pszSrcSubKey)
        dwRet = RegOpenKeyExA(hkeySrc, pszSrcSubKey, 0, MAXIMUM_ALLOWED, &hkeyFrom);
    else if (hkeySrc)    
    {
        dwRet = ERROR_SUCCESS;
        hkeyFrom = hkeySrc;
    }
    else
        dwRet = ERROR_INVALID_PARAMETER;

    if (dwRet == ERROR_SUCCESS)
    {
        DWORD dwIndex;
        DWORD cchValueSize;
        DWORD cchClassSize;
        DWORD dwType;
        CHAR  szValue[MAX_PATH]; //NOTE:szValue is also used to store subkey name when enumerating keys
        CHAR  szClass[MAX_PATH];
                
        cchValueSize = ARRAYSIZE(szValue);
        cchClassSize = ARRAYSIZE(szClass);
        for (dwIndex=0; 
             dwRet == ERROR_SUCCESS && (dwRet = RegEnumKeyExA(hkeyFrom, dwIndex, szValue, &cchValueSize, NULL, szClass, &cchClassSize, NULL)) == ERROR_SUCCESS; 
             dwIndex++, cchValueSize = ARRAYSIZE(szValue), cchClassSize = ARRAYSIZE(szClass))
        {
            HKEY  hkeyTo;
            DWORD dwDisp;

            // create new key
            dwRet = RegCreateKeyExA(hkeyDest, szValue, 0, szClass, REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY | KEY_SET_VALUE, NULL, &hkeyTo, &dwDisp);
            if (dwRet != ERROR_SUCCESS)
                break;

            dwRet = SHCopyKeyA(hkeyFrom, szValue, hkeyTo, fReserved); //if not error_success we break out
            RegCloseKey(hkeyTo);
        }

        // copied all the sub keys, now copy all the values
        if (dwRet == ERROR_NO_MORE_ITEMS)
        {
            DWORD  cb, cbBufferSize;
            LPBYTE lpbyBuffer;
            
            // get the max value size
            dwRet = RegQueryInfoKey(hkeyFrom, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &cb, NULL, NULL);
            if (dwRet == ERROR_SUCCESS)
            {
                // allocate buffer
                cb++; // add 1 just in case of a string
                lpbyBuffer = (LPBYTE)LocalAlloc(LPTR, cb);
                if (lpbyBuffer)
                    cbBufferSize = cb;
                else
                    dwRet = ERROR_OUTOFMEMORY;
                    
                cchValueSize = ARRAYSIZE(szValue);
                for (dwIndex=0;
                     dwRet == ERROR_SUCCESS && (dwRet = RegEnumValueA(hkeyFrom, dwIndex, szValue, &cchValueSize, NULL, &dwType, lpbyBuffer, &cb)) == ERROR_SUCCESS;
                     dwIndex++, cchValueSize = ARRAYSIZE(szValue), cb = cbBufferSize)
                {
                    // cb has the size of the value so use it rather than cbBufferSize which is just max size
                    dwRet = RegSetValueExA(hkeyDest, szValue, 0, dwType, lpbyBuffer, cb);
                    if (dwRet != ERROR_SUCCESS)
                        break;
                }

                if (lpbyBuffer != NULL)
                    LocalFree(lpbyBuffer);
            }
        }
    
        if (dwRet == ERROR_NO_MORE_ITEMS)
            dwRet = ERROR_SUCCESS;

        if (pszSrcSubKey)
            RegCloseKey(hkeyFrom);
    }

    return dwRet;
}

STDAPI_(DWORD) SHCopyKeyW(HKEY hkeySrc, LPCWSTR pwszSrcSubKey, HKEY hkeyDest, DWORD fReserved)
{
    CHAR sz[MAX_PATH];
    DWORD dwRet = !pwszSrcSubKey || WideCharToMultiByte(CP_ACP, 0, pwszSrcSubKey, -1, sz, SIZECHARS(sz), NULL, NULL)
        ? ERROR_SUCCESS
        : GetLastError();

    if (dwRet == ERROR_SUCCESS)
    {
        dwRet = SHCopyKeyA(hkeySrc, pwszSrcSubKey ? sz : NULL, hkeyDest, fReserved);
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Delete a key only if there are no subkeys or values.
         It comes close to mimicking the behavior of RegDeleteKey 
         as it works on NT, except the NT version ignores values.

*/
STDAPI_(DWORD)
SHDeleteEmptyKeyA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey)
{
    return DeleteEmptyKey(hkey, pszSubKey);
}


/*----------------------------------------------------------
Purpose: Delete a key only if there are no subkeys or values.
         It comes close to mimicking the behavior of RegDeleteKey 
         as it works on NT, except the NT version ignores values.

*/
STDAPI_(DWORD)
SHDeleteEmptyKeyW(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey)
{
    CHAR sz[MAX_PATH];
    DWORD dwRet = WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, sz, SIZECHARS(sz), NULL, NULL)
        ? ERROR_SUCCESS
        : GetLastError();

    if (dwRet == ERROR_SUCCESS)
    {
        dwRet = DeleteEmptyKey(hkey, sz);
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteKeyA(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    return DeleteKeyRecursivelyA(hkey, pszSubKey);
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteKeyW(
    IN HKEY    hkey, 
    IN LPCWSTR pwszSubKey)
{
    return DeleteKeyRecursivelyW(hkey, pwszSubKey);
}

/*----------------------------------------------------------
Purpose: Helper for SHRegGetValueA()/SHRegGetValueW() & SHRegQueryValueA()/SHRegQueryValueW().
*/
__inline LONG RestrictArguments(HKEY hkey, SRRF dwFlags, void *pvData, DWORD *pcbData, PCWSTR pwszCaller)
{
    LONG lr;
    SRRF dwRTFlags = dwFlags & SRRF_RT_ANY;

    if (hkey
        && dwRTFlags
        && (dwRTFlags == SRRF_RT_ANY || !(dwFlags & SRRF_RT_REG_EXPAND_SZ) || (dwFlags & SRRF_NOEXPAND))
        && (!pvData || pcbData))
    {
        lr = ERROR_SUCCESS;
    }
    else
    {
        RIPMSG(!!hkey,                  "%s: caller passed null hkey!", pwszCaller);
        RIPMSG(dwFlags & SRRF_RT_ANY,   "%s: caller passed invalid dwFlags!", pwszCaller);
        RIPMSG(dwRTFlags == SRRF_RT_ANY || !(dwFlags & SRRF_RT_REG_EXPAND_SZ) || (dwFlags & SRRF_NOEXPAND),
                                        "%s: caller passed SRRF_RT_REG_EXPAND_SZ dwFlags but not SRRF_NOEXPAND dwFlags!", pwszCaller);
        RIPMSG(!pvData || pcbData,      "%s: caller passed pvData output buffer but not size of buffer (pcbData)!", pwszCaller);

        lr = ERROR_INVALID_PARAMETER;
    }

    return lr;
}

/*----------------------------------------------------------
Purpose: Helper for SHRegQueryValueA()/SHRegQueryValueW().
*/
__inline LONG RestrictBootMode(SRRF dwFlags)
{
    LONG lr = ERROR_SUCCESS;

    if (dwFlags & (SRRF_RM_NORMAL | SRRF_RM_SAFE | SRRF_RM_SAFENETWORK))
    {
        switch (GetSystemMetrics(SM_CLEANBOOT))
        {
            case 0:     if (!(dwFlags & SRRF_RM_NORMAL))        { lr = ERROR_GEN_FAILURE; } break;
            case 1:     if (!(dwFlags & SRRF_RM_SAFE))          { lr = ERROR_GEN_FAILURE; } break;
            case 2:     if (!(dwFlags & SRRF_RM_SAFENETWORK))   { lr = ERROR_GEN_FAILURE; } break;
            default:
                RIPMSG(FALSE, "RestrictBootMode: GetSystemMetrics returned an unexpected value!");
                lr = ERROR_CAN_NOT_COMPLETE;
                break;
        }
    }

    return lr;
}

/*----------------------------------------------------------
Purpose: Helper for SHRegQueryValueA()/SHRegQueryValueW().
*/
__inline LONG RestrictRegType(SRRF dwFlags, DWORD dwType, DWORD cbData, LONG lr)
{
    RIPMSG(dwFlags & SRRF_RT_ANY, "RestrictRegType: caller passed invalid srrf!");

    if (lr == ERROR_SUCCESS || lr == ERROR_MORE_DATA)
    {
        switch (dwType)
        {
            case REG_NONE:      if (!(dwFlags & SRRF_RT_REG_NONE))              { lr = ERROR_UNSUPPORTED_TYPE; } break;
            case REG_SZ:        if (!(dwFlags & SRRF_RT_REG_SZ))                { lr = ERROR_UNSUPPORTED_TYPE; } break;
            case REG_EXPAND_SZ: if (!(dwFlags & SRRF_RT_REG_EXPAND_SZ))         { lr = ERROR_UNSUPPORTED_TYPE; } break;
            case REG_BINARY:
                if (dwFlags & SRRF_RT_REG_BINARY)
                {
                    if ((dwFlags & SRRF_RT_ANY) == SRRF_RT_QWORD)
                    {
                        if (cbData > 8)
                            lr = ERROR_DATATYPE_MISMATCH;
                    }
                    else if ((dwFlags & SRRF_RT_ANY) == SRRF_RT_DWORD)
                    {
                        if (cbData > 4)
                            lr = ERROR_DATATYPE_MISMATCH;
                    }
                }
                else
                {
                    lr = ERROR_UNSUPPORTED_TYPE;
                }
                break;
            case REG_DWORD:     if (!(dwFlags & SRRF_RT_REG_DWORD))             { lr = ERROR_UNSUPPORTED_TYPE; } break;
            case REG_MULTI_SZ:  if (!(dwFlags & SRRF_RT_REG_MULTI_SZ))          { lr = ERROR_UNSUPPORTED_TYPE; } break;
            case REG_QWORD:     if (!(dwFlags & SRRF_RT_REG_QWORD))             { lr = ERROR_UNSUPPORTED_TYPE; } break;
            default:            if (!((dwFlags & SRRF_RT_ANY) == SRRF_RT_ANY))  { lr = ERROR_UNSUPPORTED_TYPE; } break;
        }
    }

    return lr;
}


STDAPI_(LONG) FixRegDataA(HKEY hkey, PCSTR  pszValue,  SRRF dwFlags, DWORD *pdwType, void *pvData, DWORD *pcbData, DWORD cbDataBuffer, LONG lr);
STDAPI_(LONG) FixRegDataW(HKEY hkey, PCWSTR pwszValue, SRRF dwFlags, DWORD *pdwType, void *pvData, DWORD *pcbData, DWORD cbDataBuffer, LONG lr);

/*----------------------------------------------------------
Purpose: Helper for SHRegGetValueA().
         PRIVATE INTERNAL (do not call directly -- use SHRegGetValueA)
*/
STDAPI_(LONG)
SHRegQueryValueA(
    IN     HKEY    hkey,
    IN     PCSTR   pszValue,
    IN     SRRF    dwFlags,
    OUT    DWORD * pdwType,
    OUT    void *  pvData,
    IN OUT DWORD * pcbData)
{
    LONG  lr;

    ASSERT(ERROR_SUCCESS == RestrictArguments(hkey, dwFlags, pvData, pcbData, L"SHRegQueryValueA"));

    lr = RestrictBootMode(dwFlags);
    if (lr == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cbData;
        DWORD cbDataBuffer = pvData ? *pcbData : 0;

        if (!pdwType)
            pdwType = &dwType;

        if (!pcbData)
            pcbData = &cbData;

        lr = RegQueryValueExA(hkey, pszValue, NULL, pdwType, pvData, pcbData);
        lr = FixRegDataA(hkey, pszValue, dwFlags, pdwType, pvData, (pcbData != &cbData ? pcbData : NULL), cbDataBuffer, lr);
        lr = RestrictRegType(dwFlags, *pdwType, *pcbData, lr);
    }

    return lr;
}

/*----------------------------------------------------------
Purpose: Helper for SHRegGetValueW().
         PRIVATE INTERNAL (do not call directly -- use SHRegGetValueW)
*/
STDAPI_(LONG)
SHRegQueryValueW(
    IN     HKEY    hkey,
    IN     LPCWSTR pwszValue,
    IN     SRRF    dwFlags,
    OUT    LPDWORD pdwType,
    OUT    void *  pvData,
    IN OUT LPDWORD pcbData)
{
    LONG  lr;

    ASSERT(ERROR_SUCCESS == RestrictArguments(hkey, dwFlags, pvData, pcbData, L"SHRegQueryValueW"));

    lr = RestrictBootMode(dwFlags);
    if (lr == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cbData;
        DWORD cbDataBuffer = pvData ? *pcbData : 0;

        if (!pdwType)
            pdwType = &dwType;

        if (!pcbData)
            pcbData = &cbData;

        lr = RegQueryValueExW(hkey, pwszValue, NULL, pdwType, pvData, pcbData);
        lr = FixRegDataW(hkey, pwszValue, dwFlags, pdwType, pvData, (pcbData != &cbData ? pcbData : NULL), cbDataBuffer, lr);
        lr = RestrictRegType(dwFlags, *pdwType, *pcbData, lr);
    }

    return lr;
}


/*----------------------------------------------------------
Purpose: Helper for SHRegGetValueA()/SHRegGetValueW().
*/
__inline void ZeroDataOnFailure(SRRF dwFlags, void *pvData, DWORD cbDataBuffer, LONG lr)
{
    if ((lr != ERROR_SUCCESS) && (dwFlags & SRRF_ZEROONFAILURE) && (cbDataBuffer > 0))
    {
        ZeroMemory(pvData, cbDataBuffer);
    }
}

/*----------------------------------------------------------
Purpose: Gets a registry value.
         Reference documentation in shlwapi.w.
*/
STDAPI_(LONG)
SHRegGetValueA(
    IN      HKEY    hkey,
    IN      PCSTR   pszSubKey,          OPTIONAL
    IN      PCSTR   pszValue,           OPTIONAL
    IN      SRRF    dwFlags,            OPTIONAL
    OUT     DWORD * pdwType,            OPTIONAL
    OUT     void *  pvData,             OPTIONAL
    IN OUT  DWORD * pcbData)            OPTIONAL
{
    LONG  lr;
    DWORD cbDataBuffer = pvData && pcbData ? *pcbData : 0;

    lr = RestrictArguments(hkey, dwFlags, pvData, pcbData, L"SHRegGetValueA");
    if (lr == ERROR_SUCCESS)
    {
        if (pszSubKey && *pszSubKey)
        {
            HKEY hkSubKey;

            lr = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_QUERY_VALUE, &hkSubKey);
            if (lr == ERROR_SUCCESS)
            {
                lr = SHRegQueryValueA(hkSubKey, pszValue, dwFlags, pdwType, pvData, pcbData);
                RegCloseKey(hkSubKey);
            }
        }
        else
        {
            lr = SHRegQueryValueA(hkey, pszValue, dwFlags, pdwType, pvData, pcbData);
        }
    }

    ZeroDataOnFailure(dwFlags, pvData, cbDataBuffer, lr);

    return lr;
}


/*----------------------------------------------------------
Purpose: Gets a registry value.
         Reference documentation in shlwapi.w.
*/
STDAPI_(LONG)
SHRegGetValueW(
    IN      HKEY    hkey,
    IN      PCWSTR  pwszSubKey,         OPTIONAL
    IN      PCWSTR  pwszValue,          OPTIONAL
    IN      SRRF    dwFlags,            OPTIONAL
    OUT     DWORD * pdwType,            OPTIONAL
    OUT     void *  pvData,             OPTIONAL
    IN OUT  DWORD * pcbData)            OPTIONAL
{
    LONG  lr;
    DWORD cbDataBuffer = pvData && pcbData ? *pcbData : 0;

    lr = RestrictArguments(hkey, dwFlags, pvData, pcbData, L"SHRegGetValueW");
    if (lr == ERROR_SUCCESS)
    {
        if (pwszSubKey && *pwszSubKey)
        {
            HKEY hkSubKey;

            lr = RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_QUERY_VALUE, &hkSubKey);

            if (lr == ERROR_SUCCESS)
            {
                lr = SHRegQueryValueW(hkSubKey, pwszValue, dwFlags, pdwType, pvData, pcbData);
                RegCloseKey(hkSubKey);
            }
        }
        else
        {
            lr = SHRegQueryValueW(hkey, pwszValue, dwFlags, pdwType, pvData, pcbData);
        }
    }

    ZeroDataOnFailure(dwFlags, pvData, cbDataBuffer, lr);

    return lr;
}


/*----------------------------------------------------------
Purpose: Behaves just like RegEnumKeyExA, except it does not let
         you look at the class and timestamp of the sub-key. Written
         to provide equivalent for SHEnumKeyExW which is useful on
         Win95.

Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumKeyExA
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPSTR       pszName,
    IN OUT LPDWORD  pcchName
)
{
    return RegEnumKeyExA(hkey, dwIndex, pszName, pcchName, NULL, NULL, NULL, NULL);
}          
        
/*----------------------------------------------------------
Purpose: Behaves just like RegEnumKeyExW, except it does not let
         you look at the class and timestamp of the sub-key. 
         Wide char version supported under Win95.

Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumKeyExW
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPWSTR      pszName,
    IN OUT LPDWORD  pcchName
)
{
    return RegEnumKeyExW(hkey, dwIndex, pszName, pcchName, NULL, NULL, NULL, NULL);
}        

/*----------------------------------------------------------
Purpose: Behaves just like RegEnumValueA. Written to provide 
         equivalent for SHEnumKeyExW which is useful on Win95.
         Environment vars in a string are NOT expanded. 

Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumValueA
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPSTR       pszValueName,   OPTIONAL
    IN OUT LPDWORD  pcchValueName,   OPTIONAL
    OUT LPDWORD     pdwType,        OPTIONAL
    OUT LPVOID      pvData,         OPTIONAL
    IN OUT LPDWORD  pcbData         OPTIONAL
)
{
    return RegEnumValueA(hkey, dwIndex, pszValueName, pcchValueName, NULL, pdwType, pvData, pcbData);
}


/*----------------------------------------------------------
Purpose: Behaves just like RegEnumValueW. Wide char version
         works on Win95.
         Environment vars in a string are NOT expanded. 
Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumValueW
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPWSTR      pszValueName,   OPTIONAL       
    IN OUT LPDWORD  pcchValueName,  OPTIONAL
    OUT LPDWORD     pdwType,        OPTIONAL
    OUT LPVOID      pvData,         OPTIONAL
    IN OUT LPDWORD  pcbData         OPTIONAL
)
{
    return RegEnumValueW(hkey, dwIndex, pszValueName, pcchValueName, NULL, pdwType, pvData, pcbData);
}

/*----------------------------------------------------------
Purpose: Behaves just like RegQueryInfoKeyA. Written to provide
         equivalent for W version. 
Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHQueryInfoKeyA
(
    IN  HKEY        hkey,
    OUT LPDWORD     pcSubKeys,             OPTIONAL
    OUT LPDWORD     pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD     pcValues,              OPTIONAL
    OUT LPDWORD     pcchMaxValueNameLen    OPTIONAL
)
{
    return RegQueryInfoKeyA(hkey, NULL, NULL, NULL, pcSubKeys, pcchMaxSubKeyLen, 
                    NULL, pcValues, pcchMaxValueNameLen, NULL, NULL, NULL);
}                     


/*----------------------------------------------------------
Purpose: Behaves just like RegQueryInfoKeyW. Works on Win95.
Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHQueryInfoKeyW
(
    IN  HKEY        hkey,
    OUT LPDWORD     pcSubKeys,             OPTIONAL
    OUT LPDWORD     pcchMaxSubKeyLen,       OPTIONAL
    OUT LPDWORD     pcValues,              OPTIONAL
    OUT LPDWORD     pcchMaxValueNameLen     OPTIONAL
)
{
    return RegQueryInfoKeyW(hkey, NULL, NULL, NULL, pcSubKeys, pcchMaxSubKeyLen, 
                        NULL, pcValues, pcchMaxValueNameLen, NULL, NULL, NULL);
}


/*----------------------------------------------------------*\
        USER SPECIFC SETTINGS

  DESCRIPTION:
    These functions will be used to query User Specific settings
    correctly.  The installer needs to populate HKLM
    with User specific settings, because that's the only part
    of the registry that is shared between all users.  Code will
    then read values from HKCU, and if that's empty, it
    will look in HKLM.  The only exception is that if
    TRUE is passed in for the fIgnore parameter, then the HKLM version
    will be used instead of HKCU.  This is the way that an admin can
    specify that they doesn't want users to be able to use their
    User Specific values (HKCU).
\*----------------------------------------------------------*/

typedef struct tagUSKEY
{
    HKEY    hkeyCurrentUser;
    HKEY    hkeyCurrentUserRelative;
    HKEY    hkeyLocalMachine;
    HKEY    hkeyLocalMachineRelative;
    CHAR    szSubPath[MAXIMUM_SUB_KEY_LENGTH];
    REGSAM  samDesired;
} USKEY;

typedef USKEY * PUSKEY;
typedef PUSKEY * PPUSKEY;

#define IS_HUSKEY_VALID(pUSKey)    (((pUSKey) && IS_VALID_WRITE_PTR((pUSKey), USKEY) && ((pUSKey)->hkeyCurrentUser || (pUSKey)->hkeyLocalMachine)))


// Private Helper Function
// Bring the out of date key up to date.
LONG PrivFullOpen(PUSKEY pUSKey)
{
    LONG       lRet         = ERROR_SUCCESS;
    HKEY       *phkey       = NULL;
    HKEY       *phkeyRel    = NULL;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    if (!pUSKey->hkeyCurrentUser)           // Do we need to open HKCU?
    {
        phkey = &(pUSKey->hkeyCurrentUser);
        phkeyRel = &(pUSKey->hkeyCurrentUserRelative);
    }
    if (!pUSKey->hkeyLocalMachine)          // Do we need to open HKLM?
    {
        phkey = &(pUSKey->hkeyLocalMachine);
        phkeyRel = &(pUSKey->hkeyLocalMachineRelative);
    }

    if ((phkeyRel) && (*phkeyRel))
    {
        ASSERT(phkey);        // Will always be true, but assert against maintainence mistakes

        lRet = RegOpenKeyExA(*phkeyRel, pUSKey->szSubPath, 0, pUSKey->samDesired, phkey);

        // If we need to bring the out of date key, up to date, we need to free the old one.
        if ((HKEY_CURRENT_USER != *phkeyRel) && (HKEY_LOCAL_MACHINE != *phkeyRel))
            RegCloseKey(*phkeyRel);
        *phkeyRel = NULL;
        pUSKey->szSubPath[0] = '\0';
    }
    return lRet;
}



// Private Helper Function
// Bring the out of date key up to date.
LONG PrivFullCreate(PUSKEY pUSKey)
{
    LONG       lRet         = ERROR_SUCCESS;
    HKEY       *phkey       = NULL;
    HKEY       *phkeyRel    = NULL;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    if (!pUSKey->hkeyCurrentUser)           // Do we need to open HKCU?
    {
        phkey = &(pUSKey->hkeyCurrentUser);
        phkeyRel = &(pUSKey->hkeyCurrentUserRelative);
    }
    if (!pUSKey->hkeyLocalMachine)          // Do we need to open HKLM?
    {
        phkey = &(pUSKey->hkeyLocalMachine);
        phkeyRel = &(pUSKey->hkeyLocalMachineRelative);
    }

    if ((phkeyRel) && (*phkeyRel))
    {
        ASSERT(phkey);        // Will always be true, but assert against maintainence mistakes

        lRet = RegCreateKeyExA(*phkeyRel, pUSKey->szSubPath, 0, "", REG_OPTION_NON_VOLATILE, pUSKey->samDesired, NULL, phkey, NULL);

        // If we need to bring the out of date key, up to date, we need to free the old one.
        if ((HKEY_CURRENT_USER != *phkeyRel) && (HKEY_LOCAL_MACHINE != *phkeyRel))
            RegCloseKey(*phkeyRel);
        *phkeyRel = NULL;
        pUSKey->szSubPath[0] = '\0';
    }
    return lRet;
}


// Private Helper Function
// Create one of the keys (Called for both HKLM and HKCU)
LONG PrivCreateKey(LPHKEY lphkey, LPHKEY lphkeyRelative, LPCSTR lpSubPath, REGSAM samDesired)
{
    LONG    lRet = ERROR_SUCCESS;

    if (*lphkeyRelative)
    {
        lRet = RegCreateKeyExA(*lphkeyRelative, lpSubPath, 0, "", REG_OPTION_NON_VOLATILE, samDesired, NULL, lphkey, NULL);
        *lphkeyRelative = NULL;
    }
    else
    {
        // If the relative key == NULL, then we don't have enough of the path to
        // create this key.
        return(ERROR_INVALID_PARAMETER);
    }
    return(lRet);
}



// Private Helper Function
// Query for the specific value.
LONG PrivRegQueryValue(
    IN  PUSKEY          pUSKey,
    IN  HKEY            *phkey,
    IN  LPCWSTR         pwzValue,           // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN  BOOL            fWideChar,
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData)            OPTIONAL
{
    LONG       lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHQueryValueExW(*phkey, pwzValue, NULL, pdwType, pvData, pcbData);
        else
            lRet = SHQueryValueExA(*phkey, (LPCSTR)pwzValue, NULL, pdwType, pvData, pcbData);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}




// Private Helper Function
// Query for the specific value.
LONG PrivRegWriteValue(
    IN  PUSKEY          pUSKey,
    IN  HKEY            *phkey,
    IN  LPCWSTR         pwzValue,           // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN  BOOL            bWideChar,
    IN  BOOL            bForceWrite,
    IN  DWORD           dwType,             OPTIONAL
    IN  LPCVOID         pvData,             OPTIONAL
    IN  DWORD           cbData)             OPTIONAL
{
    LONG       lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullCreate(pUSKey);

    // Check if the caller only want's to write value if it's empty
    if (!bForceWrite)
    {   // Yes we need to check before we write.

        if (bWideChar)
            bForceWrite = !(ERROR_SUCCESS == SHQueryValueExW(*phkey, pwzValue, NULL, NULL, NULL, NULL));
        else
            bForceWrite = !(ERROR_SUCCESS == SHQueryValueExA(*phkey, (LPCSTR)pwzValue, NULL, NULL, NULL, NULL));
    }

    if ((ERROR_SUCCESS == lRet) && (*phkey) && bForceWrite)
    {
        if (bWideChar)
            // RegSetValueExW is not supported on Win95 but we have a thunking function.
            lRet = RegSetValueExW(*phkey, pwzValue, 0, dwType, pvData, cbData);
        else
            lRet = RegSetValueExA(*phkey, (LPCSTR)pwzValue, 0, dwType, pvData, cbData);
    }

    return lRet;
}

// Private helper function
// Enum sub-keys of a key.
LONG PrivRegEnumKey(
    IN      PUSKEY          pUSKey,
    IN      HKEY            *phkey,
    IN      DWORD           dwIndex,
    IN      LPWSTR          pwzName,           // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN      BOOL            fWideChar,
    IN OUT  LPDWORD         pcchName
)
{
    LONG lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));    

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHEnumKeyExW(*phkey, dwIndex, pwzName, pcchName);
        else
            lRet = SHEnumKeyExA(*phkey, dwIndex, (LPSTR)pwzName, pcchName);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}


// Private helper function
// Enum values of a key.
LONG PrivRegEnumValue(
    IN      PUSKEY          pUSKey,
    IN      HKEY            *phkey,
    IN      DWORD           dwIndex,
    IN      LPWSTR          pwzValueName,       // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN      BOOL            fWideChar,
    IN OUT  LPDWORD         pcchValueName,
    OUT     LPDWORD         pdwType,            OPTIONAL
    OUT     LPVOID          pvData,             OPTIONAL
    IN OUT  LPDWORD         pcbData             OPTIONAL
)
{
    LONG lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));    

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHEnumValueW(*phkey, dwIndex, pwzValueName, pcchValueName, pdwType, pvData, pcbData);
        else
            lRet = SHEnumValueA(*phkey, dwIndex, (LPSTR)pwzValueName, pcchValueName, pdwType, pvData, pcbData);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}

// Query the Key information.
LONG PrivRegQueryInfoKey(
    IN  PUSKEY      pUSKey,
    IN  HKEY        *phkey,
    IN  BOOL        fWideChar,
    OUT LPDWORD     pcSubKeys,             OPTIONAL
    OUT LPDWORD     pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD     pcValues,              OPTIONAL
    OUT LPDWORD     pcchMaxValueNameLen    OPTIONAL
)
{
    LONG lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));

    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHQueryInfoKeyW(*phkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
        else
            lRet = SHQueryInfoKeyA(*phkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}

LONG SHRegSubKeyAddBackslashA(PSTR pszSubKey, size_t cchSubKey)
{
    LONG lr;

    if (cchSubKey >= MAX_PATH)
    {
        lr = PathAddBackslashA(pszSubKey)
            ? ERROR_SUCCESS
            : ERROR_BUFFER_OVERFLOW;
    }
    else
    {
        CHAR szSubKey[MAX_PATH];

        // Note:
        //  Since (cchSubKey < MAX_PATH), we cannot safely call
        //  PathAddBackslashA without doing this nonsense first...

        lr = EVAL(SUCCEEDED(StringCchCopyA(szSubKey, ARRAYSIZE(szSubKey), pszSubKey))) && PathAddBackslashA(szSubKey) && SUCCEEDED(StringCchCopyA(pszSubKey, cchSubKey, szSubKey))
            ? ERROR_SUCCESS
            : ERROR_BUFFER_OVERFLOW;
    }

    return lr;
}

/*----------------------------------------------------------
Purpose: Create or open a user specifc registry key (HUSKEY).  

Description: This function will:
    1. Allocate a new USKEY structure.
    2. Initialize the structure.
    3. Create/Open HKLM if that flag is set.
    4. Create/Open HKCU if that flag is set.

    Note that there is no difference between FORCE and
    don't force in the dwFlags parameter.

    The hUSKeyRelative parameter should have also been opened by
    a call to SHRegCreateUSKey.  If SHRegOpenUSKey was called,
    it could have returned ERROR_SUCCESS but still be invalid
    for calling this function.  This will occur if: 1) the parameter
    fIgnoreHKCU was FALSE, 2) it was a relative open, 3) the
    HKCU branch could not be opened because it didn't exist, and
    4) HKLM opened successfully.  This situation renders the
    HUSKEY valid for reading but not writing.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegCreateUSKeyA(
    IN  LPCSTR          pszPath,         
    IN  REGSAM          samDesired,     // security access mask 
    IN  HUSKEY          hUSKeyRelative, // OPTIONAL
    OUT PHUSKEY         phUSKey,
    IN  DWORD           dwFlags)        // Indicates whether to create/open HKCU, HKLM, or both
{
    PUSKEY      pUSKeyRelative      = (PUSKEY) hUSKeyRelative;
    PPUSKEY     ppUSKey             = (PPUSKEY) phUSKey;
    PUSKEY      pUSKey;
    LONG        lRet                = ERROR_SUCCESS;
    CHAR        szTempPath[MAXIMUM_SUB_KEY_LENGTH]  = "\0";
    LPCSTR      lpszHKLMPath        = szTempPath;
    LPCSTR      lpszHKCUPath        = szTempPath;

    ASSERT(ppUSKey);
    // The following are invalid parameters...
    // 1. ppUSKey cannot be NULL
    // 2. If this is a relative open, pUSKeyRelative needs to be a valid HUSKEY.
    // 3. The user needs to have specified one of the following: SHREGSET_HKCU, SHREGSET_FORCE_HKCU, SHREGSET_HKLM, SHREGSET_FORCE_HKLM.
    if ((!ppUSKey) ||                                                   // 1.
        (pUSKeyRelative && FALSE == IS_HUSKEY_VALID(pUSKeyRelative)) || // 2.
        !(dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU  | SHREGSET_HKLM | SHREGSET_FORCE_HKLM))) // 3.
    {
        return ERROR_INVALID_PARAMETER;
    }

    // The temp path will be used when bringing the keys
    // up todate that was out of date in the Relative key.
    if (pUSKeyRelative)
    {
        StringCchCopyA(szTempPath, ARRAYSIZE(szTempPath), pUSKeyRelative->szSubPath); // truncation should not occur -- buffers of equal size

        // Add separator \ if reqd. 
        lRet = SHRegSubKeyAddBackslashA(szTempPath, ARRAYSIZE(szTempPath));
    }

    if (lRet == ERROR_SUCCESS)
    {
        if (SUCCEEDED(StringCchCatA(szTempPath, ARRAYSIZE(szTempPath), pszPath)))
        {
            /////  1. Allocate a new USKEY structure.
            pUSKey = *ppUSKey = (PUSKEY)LocalAlloc(LPTR, sizeof(USKEY));
            if (!pUSKey)
                return ERROR_NOT_ENOUGH_MEMORY;

            /////  2. Initialize the structure.
            if (!pUSKeyRelative)
            {
                // Init a new (non-relative) open.
                pUSKey->hkeyLocalMachineRelative    = HKEY_LOCAL_MACHINE;
                pUSKey->hkeyCurrentUserRelative     = HKEY_CURRENT_USER;
            }
            else
            {
                // Init a new (relative) open.
                *pUSKey = *pUSKeyRelative;

                if (pUSKey->hkeyLocalMachine)
                {
                    pUSKey->hkeyLocalMachineRelative = pUSKey->hkeyLocalMachine;
                    pUSKey->hkeyLocalMachine = NULL;
                    lpszHKLMPath = pszPath;

                    // This key is up to date in the Relative Key.  If the
                    // user doesn't want it to be up todate in the new key,
                    // we don't need the path from the Relative key.
                    if (!(dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)))
                        *(pUSKey->szSubPath) = '\0';
                }
                // We need to copy the key if:
                // 1. It will not be created in this call, and
                // 2. The relative key is not HKEY_LOCAL_MACHINE.
                if (!(dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)) &&
                    (pUSKey->hkeyLocalMachineRelative != HKEY_LOCAL_MACHINE))
                {
                    // Make a duplicate of this key.
                    lRet = RegOpenKeyExA(pUSKey->hkeyLocalMachineRelative, NULL, 0, pUSKey->samDesired, &(pUSKey->hkeyLocalMachineRelative));
                }

                if (pUSKey->hkeyCurrentUser)
                {
                    pUSKey->hkeyCurrentUserRelative = pUSKey->hkeyCurrentUser;
                    pUSKey->hkeyCurrentUser = NULL;
                    lpszHKCUPath = pszPath;

                    // This key is up to date in the Relative Key.  If the
                    // user doesn't want it to be up todate in the new key,
                    // we don't need the path from the Relative key.
                    if (!(dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)))
                        *(pUSKey->szSubPath) = '\0';
                }
                // We need to copy the key if:
                // 1. It will not be created in this call, and
                // 2. The relative key is not HKEY_CURRENT_USER.
                if (!(dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)) &&
                    (pUSKey->hkeyCurrentUserRelative != HKEY_CURRENT_USER))
                {
                    // Make a duplicate of this key.
                    lRet = RegOpenKeyExA(pUSKey->hkeyCurrentUserRelative, NULL, 0, pUSKey->samDesired, &(pUSKey->hkeyCurrentUserRelative));
                }
            }
            pUSKey->samDesired = samDesired;


            /////  3. Create/Open HKLM if that flag is set or fill in the structure as appropriate.
            if ((ERROR_SUCCESS == lRet) && (dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)))
                lRet = PrivCreateKey(&(pUSKey->hkeyLocalMachine), &(pUSKey->hkeyLocalMachineRelative), lpszHKLMPath, pUSKey->samDesired);

            /////  4. Create/Open HKCU if that flag is set or fill in the structure as appropriate.
            if ((ERROR_SUCCESS == lRet) && (dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)))
                lRet = PrivCreateKey(&(pUSKey->hkeyCurrentUser), &(pUSKey->hkeyCurrentUserRelative), lpszHKCUPath, pUSKey->samDesired);

            if (ERROR_SUCCESS == lRet)
            {
                if ((dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)) &&
                    (dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM))) 
                {
                    // The caller wanted both to be opened.
                    *(pUSKey->szSubPath) = '\0';       // Both paths are open so Delta Path is empty.
                }
                else
                {
                    // One of the paths is not open so set the Delta Path in case it needs to be opened later.
                    if (*(pUSKey->szSubPath))
                    {
                        lRet = SHRegSubKeyAddBackslashA(pUSKey->szSubPath, ARRAYSIZE(pUSKey->szSubPath));
                    }

                    if (lRet == ERROR_SUCCESS && FAILED(StringCchCat(pUSKey->szSubPath, ARRAYSIZE(pUSKey->szSubPath), pszPath)))
                    {
                        lRet == ERROR_BUFFER_OVERFLOW;
                    }
                }
            }

            // Free the memory if we are not successful.
            if (ERROR_SUCCESS != lRet)
            {
                if (pUSKey->hkeyCurrentUser)
                    RegCloseKey(pUSKey->hkeyCurrentUser);
                if (pUSKey->hkeyCurrentUserRelative && pUSKey->hkeyCurrentUserRelative != HKEY_CURRENT_USER)
                    RegCloseKey(pUSKey->hkeyCurrentUserRelative);
                if (pUSKey->hkeyLocalMachine)
                    RegCloseKey(pUSKey->hkeyLocalMachine);
                if (pUSKey->hkeyLocalMachineRelative && pUSKey->hkeyLocalMachineRelative != HKEY_LOCAL_MACHINE)
                    RegCloseKey(pUSKey->hkeyLocalMachineRelative);
                LocalFree((HLOCAL)pUSKey);
                *ppUSKey = NULL;
            }
        }
        else
        {
            lRet = ERROR_BUFFER_OVERFLOW;
        }
    }

    return lRet;
}







/*----------------------------------------------------------
Purpose: Create or open a user specifc registry key (HUSKEY).  

Description: This function will:
    1. Allocate a new USKEY structure.
    2. Initialize the structure.
    3. Create/Open HKLM if that flag is set.
    4. Create/Open HKCU if that flag is set.

    Note that there is no difference between FORCE and
    don't force in the dwFlags parameter.

    The hUSKeyRelative parameter should have also been opened by
    a call to SHRegCreateUSKey.  If SHRegOpenUSKey was called,
    it could have returned ERROR_SUCCESS but still be invalid
    for calling this function.  This will occur if: 1) the parameter
    fIgnoreHKCU was FALSE, 2) it was a relative open, 3) the
    HKCU branch could not be opened because it didn't exist, and
    4) HKLM opened successfully.  This situation renders the
    HUSKEY valid for reading but not writing.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegCreateUSKeyW(
    IN  LPCWSTR         pwzPath,
    IN  REGSAM          samDesired,// security access mask 
    IN  HUSKEY          hUSKeyRelative,       OPTIONAL
    OUT PHUSKEY         phUSKey,
    IN  DWORD           dwFlags)     // Indicates whether to create/open HKCU, HKLM, or both
{
    CHAR   szNewPath[MAXIMUM_SUB_KEY_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzPath, -1, szNewPath, ARRAYSIZE(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegCreateUSKeyA(szNewPath, samDesired, hUSKeyRelative, phUSKey, dwFlags);
}



/*----------------------------------------------------------
Purpose: Open a user specifc registry key (HUSKEY).  

Description: This function will:
    1. Allocate a new USKEY structure.
    2. Initialize the structure.
    3. Determine which key (HKLM or HKCU) will be the one brought up to date.
    4. Open the key that is going to be brought up to date.

    If #4 Succeeded:
    5a. Copy the handle of the out of date key, so it can be opened later if needed.

    If #4 Failed:
    5b. The other key will now be the one brought up to date, as long as it is HKLM.
    6b. Tag the out of date as INVALID. (Key == NULL; RelKey == NULL)

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegOpenUSKeyA(
    IN  LPCSTR          pszPath,         
    IN  REGSAM          samDesired,// security access mask 
    IN  HUSKEY          hUSKeyRelative,       OPTIONAL
    OUT PHUSKEY         phUSKey,     
    IN  BOOL            fIgnoreHKCU)           
{
    PUSKEY      pUSKeyRelative      = (PUSKEY) hUSKeyRelative;
    PPUSKEY     ppUSKey             = (PPUSKEY) phUSKey;
    PUSKEY      pUSKey;
    LONG        lRet               = ERROR_SUCCESS;
    HKEY        * phkeyMaster;
    HKEY        * phkeyRelMaster;
    HKEY        * phkeyOld;
    HKEY        * phkeyRelOld;

    ASSERT(ppUSKey);

    // The following are invalid parameters...
    // 1. ppUSKey cannot be NULL
    // 2. If this is a relative open, pUSKeyRelative needs to be a valid HUSKEY.
    if ((!ppUSKey) ||                                                   // 1.
        (pUSKeyRelative && FALSE == IS_HUSKEY_VALID(pUSKeyRelative)))   // 2.
    {
        return ERROR_INVALID_PARAMETER;
    }


    /////  1. Allocate a new USKEY structure.
    pUSKey = *ppUSKey = (PUSKEY)LocalAlloc(LPTR, sizeof(USKEY));
    if (!pUSKey)
        return ERROR_NOT_ENOUGH_MEMORY;

    /////  2. Initialize the structure.
    if (!pUSKeyRelative)
    {
        // Init a new (non-relative) open.
        pUSKey->hkeyLocalMachineRelative    = HKEY_LOCAL_MACHINE;
        pUSKey->hkeyCurrentUserRelative     = HKEY_CURRENT_USER;
    }
    else
    {
        // Init a new (relative) open.
        *pUSKey = *pUSKeyRelative;
    }
    pUSKey->samDesired = samDesired;


    /////  3. Determine which key (HKLM or HKCU) will be the one brought up to date.
    // The HUSKY struct will contain 4 HKEYs. HKCU, HKCU Relative, HKLM, and HKLM Relative.
    // For efficiency, only one key will be up to date (HKCU or HKLM).  The one that
    // is out of date will be NULL to indicate out of date.  The relative key for the
    // out of date key, will be the last opened key.  The string will be the delta between
    // the last open key and the current open level.

    // We will determine which key will be the new valid key (Master).
    if (FALSE == fIgnoreHKCU)
    {
        phkeyMaster     = &(pUSKey->hkeyCurrentUser);
        phkeyRelMaster  = &(pUSKey->hkeyCurrentUserRelative);
        phkeyOld        = &(pUSKey->hkeyLocalMachine);
        phkeyRelOld     = &(pUSKey->hkeyLocalMachineRelative);
    }
    else
    {
        phkeyMaster     = &(pUSKey->hkeyLocalMachine);
        phkeyRelMaster  = &(pUSKey->hkeyLocalMachineRelative);
        phkeyOld        = &(pUSKey->hkeyCurrentUser);
        phkeyRelOld     = &(pUSKey->hkeyCurrentUserRelative);
    }

    // Add the new Path to the Total path.
    if ('\0' != *(pUSKey->szSubPath))
    {
        // Add separator \ if reqd. 
        lRet = SHRegSubKeyAddBackslashA(pUSKey->szSubPath, ARRAYSIZE(pUSKey->szSubPath));
    }

    if (lRet == ERROR_SUCCESS)
    {
        if (SUCCEEDED(StringCchCatA(pUSKey->szSubPath, ARRAYSIZE(pUSKey->szSubPath), pszPath)))
        {
            /////  4. Open the key that is going to be brought up to date.
            if (*phkeyMaster)
            {
                // Masterkey is already up to date, so just do the relative open and add the string to szSubPath
                // It's safe to write write (*phkeyMaster) because it will be freed by the HUSKEY used for the
                // relative open.
                lRet = RegOpenKeyExA(*phkeyMaster, pszPath, 0, pUSKey->samDesired, phkeyMaster);
            }
            else
            {

                // Open Masterkey with the full path (pUSKey->szSubPath + pszPath)
                if (*phkeyRelMaster)
                {
                    lRet = RegOpenKeyExA(*phkeyRelMaster, pUSKey->szSubPath, 0, pUSKey->samDesired, phkeyMaster);
                }
                else
                {
                    lRet = ERROR_FILE_NOT_FOUND;
                }

                StringCchCopyA(pUSKey->szSubPath, ARRAYSIZE(pUSKey->szSubPath), pszPath);
                *phkeyRelMaster = NULL;
            }

            /////  Did #4 Succeeded?
            if (ERROR_FILE_NOT_FOUND == lRet)
            {
                /////  #4 Failed, Now we can try to open HKLM if the previous attempt was to open HKCU.
                if (!fIgnoreHKCU)
                {
                    if (*phkeyRelOld)       // Can HKLM be opened?
                    {
                        ASSERT(*phkeyOld == NULL);       // *phkeyOld should never have a value if *phkeyRelOld does.

                        /////  5b. The other key will now be the one brought up to date, as long as it is HKLM.
                        lRet = RegOpenKeyExA(*phkeyRelOld, pUSKey->szSubPath, 0, pUSKey->samDesired, phkeyOld);
                        *phkeyRelOld = NULL;
                    }
                    else if (*phkeyOld)       // Can HKLM be opened?
                    {
                        /////  5b. Attempt to bring the other key up to date.
                        lRet = RegOpenKeyExA(*phkeyOld, pUSKey->szSubPath, 0, pUSKey->samDesired, phkeyOld);
                    }
                }
                else
                {
                    *phkeyOld = NULL;            // Tag this as INVALID
                    *phkeyRelOld = NULL;         // Tag this as INVALID
                }

                /////  6b. Tag the out of date as INVALID. (Key == NULL; RelKey == NULL)
                *phkeyMaster = NULL;            // Tag this as INVALID
                *phkeyRelMaster = NULL;         // Tag this as INVALID
            }
            else
            {
                /////  #4 Succeeded:
                /////  5a. Does the out of date key need to be copied?
                if (*phkeyOld)
                {
                    // Copy the handle of the out of date key, so it can be opened later if needed.
                    // We can be assured that any NON-Relative HKEY will not be HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER
                    ASSERT(*phkeyOld != HKEY_LOCAL_MACHINE && *phkeyOld != HKEY_CURRENT_USER);       // But let's assert anyway.

                    RegOpenKeyExA(*phkeyOld, NULL, 0, pUSKey->samDesired, phkeyOld);
                }
                else
                {
                    if ((*phkeyRelOld) && (*phkeyRelOld != HKEY_LOCAL_MACHINE) && (*phkeyRelOld != HKEY_CURRENT_USER))
                    {
                        // Copy the handle of the out of date key, so it can be opened later if needed.
                        lRet = RegOpenKeyExA(*phkeyRelOld, NULL, 0, pUSKey->samDesired, phkeyRelOld);
                    }
                }

                if (*phkeyOld)
                {
                    *phkeyRelOld = *phkeyOld;
                    *phkeyOld = NULL;        // Mark this key as being out of date.
                }
            }
        }
        else
        {
            lRet = ERROR_BUFFER_OVERFLOW;
        }
    }

    // Free the memory if we are not successful.
    if (ERROR_SUCCESS != lRet)
    {
        pUSKey->hkeyCurrentUser     = NULL;     // Mark invalid.
        pUSKey->hkeyLocalMachine    = NULL;
        LocalFree((HLOCAL)pUSKey);
        *ppUSKey = NULL;
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Open a user specifc registry key (HUSKEY).  

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegOpenUSKeyW(
    IN  LPCWSTR         pwzPath,         
    IN  REGSAM          samDesired,// security access mask 
    IN  HUSKEY          hUSKeyRelative,       OPTIONAL
    OUT PHUSKEY         phUSKey,     
    IN  BOOL            fIgnoreHKCU)           
{
    CHAR   szNewPath[MAXIMUM_SUB_KEY_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzPath, -1, szNewPath, ARRAYSIZE(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegOpenUSKeyA(szNewPath, samDesired, hUSKeyRelative, phUSKey, fIgnoreHKCU);
}



/*----------------------------------------------------------
Purpose: Query a user specific registry entry for it's value.  
         This will NOT
         open and close the keys in which the value resides. 
         The caller needs to do this and it should be done
         when several keys will be queried for a perf increase.
         Callers that only call this once, will probably want
         to call SHGetUSValue().

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegQueryUSValueA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszValue,           
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  BOOL            fIgnoreHKCU,
    IN  LPVOID          pvDefaultData,      OPTIONAL
    IN  DWORD           dwDefaultDataSize)  OPTIONAL
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_SUCCESS;
    DWORD       dwSize      = (pcbData ? *pcbData : 0);
    DWORD       dwType      = (pdwType ? *pdwType : 0); // callers responsibility to set pdwType to the type of pvDefaultData (if they care)

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (!fIgnoreHKCU)
    {
        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyCurrentUser), (LPWSTR)pszValue, 
                                    FALSE, pdwType, pvData, pcbData);
    }
    if (fIgnoreHKCU || ERROR_SUCCESS != lRet)
    {
        if (pcbData)
            *pcbData = dwSize;  // We may need to reset if previous open failed.

        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyLocalMachine), (LPWSTR)pszValue, 
                                    FALSE, pdwType, pvData, pcbData);
    }

    // if fail, use default value.
    if ((ERROR_SUCCESS != lRet) && (pvDefaultData) && (dwDefaultDataSize) && 
        (pvData) && (dwSize >= dwDefaultDataSize))
    {
        MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
        if (pcbData)
        {
            *pcbData = dwDefaultDataSize;
        }
        if (pdwType)
        {
            *pdwType = dwType;
        }
        lRet = ERROR_SUCCESS;       // Call will now use a default value.
    }

    return lRet;
}



/*----------------------------------------------------------
Purpose: Query a user specific registry entry for it's value.    
         This will NOT
         open and close the keys in which the value resides. 
         The caller needs to do this and it should be done
         when several keys will be queried for a perf increase.
         Callers that only call this once, will probably want
         to call SHGetUSValue().

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegQueryUSValueW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzValue,           
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  BOOL            fIgnoreHKCU,
    IN  LPVOID          pvDefaultData,      OPTIONAL
    IN  DWORD           dwDefaultDataSize)  OPTIONAL
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet;
    DWORD       dwSize      = (pcbData ? *pcbData : 0);
    DWORD       dwType      = (pdwType ? *pdwType : 0); // callers responsibility to set pdwType to the type of pvDefaultData (if they care)


    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (!fIgnoreHKCU)
    {
        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyCurrentUser), pwzValue, 
                                    TRUE, pdwType, pvData, pcbData);
    }
    if (fIgnoreHKCU || ERROR_SUCCESS != lRet)
    {
        if (pcbData)
            *pcbData = dwSize;  // We may need to reset if previous open failed.
        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyLocalMachine), pwzValue, 
                                    TRUE, pdwType, pvData, pcbData);
    }

    // if fail, use default value.
    if ((ERROR_SUCCESS != lRet) && (pvDefaultData) && (dwDefaultDataSize) && 
        (pvData) && (dwSize >= dwDefaultDataSize))
    {
        MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
        if (pcbData)
        {
            *pcbData = dwDefaultDataSize;
        }
        if (pdwType)
        {
            *pdwType = dwType;
        }
     
        lRet = ERROR_SUCCESS;       // Call will now use a default value.
    }

    return lRet;
}






/*----------------------------------------------------------
Purpose: Write a user specific registry entry.  

Parameters:
  hUSKey - Needs to have been open with KEY_SET_VALUE permissions.
           KEY_QUERY_VALUE also needs to have been used if this is
           not a force write.
  pszValue - Registry Key value to write to.
  dwType - Type for the new registry key.
  pvData - Pointer to data to store
  cbData - Size of data to store.  
  dwFlags - Flags to determine if the registry entry should be written to
            HKLM, HKCU, or both.  Also determines if these are force or
            non-force writes. (non-force means it will only write the value
            if it's empty)  Using FORCE is faster than non-force.

Decription:
    This function will write the value to the
    registry in either the HKLM or HKCU branches depending
    on the flags set in the dwFlags parameter.
    
Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegWriteUSValueA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszValue,           
    IN  DWORD           dwType,
    IN  LPCVOID         pvData,
    IN  DWORD           cbData,
    IN  DWORD           dwFlags)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_SUCCESS;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    // Assert if: 1) This is not a force open, and 2) they key was not
    // opened with KEY_QUERY_VALUE permissions.
    if (!(dwFlags & (SHREGSET_FORCE_HKCU|SHREGSET_FORCE_HKLM)) && !(pUSKey->samDesired & KEY_QUERY_VALUE))
    {
        ASSERT(NULL);   // ERROR_INVALID_PARAMETER
        return(ERROR_INVALID_PARAMETER);
    }

    if (dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyCurrentUser), (LPWSTR)pszValue, 
            FALSE, dwFlags & SHREGSET_FORCE_HKCU, dwType, pvData, cbData);
    }
    if ((dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)) && (ERROR_SUCCESS == lRet))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyLocalMachine), (LPWSTR)pszValue, 
            FALSE, dwFlags & SHREGSET_FORCE_HKLM, dwType, pvData, cbData);
    }

    return lRet;
}



/*----------------------------------------------------------
Purpose: Write a user specific registry entry.  

Parameters:
  hUSKey - Needs to have been open with KEY_SET_VALUE permissions.
           KEY_QUERY_VALUE also needs to have been used if this is
           not a force write.
  pszValue - Registry Key value to write to.
  dwType - Type for the new registry key.
  pvData - Pointer to data to store
  cbData - Size of data to store.  
  dwFlags - Flags to determine if the registry entry should be written to
            HKLM, HKCU, or both.  Also determines if these are force or
            non-force writes. (non-force means it will only write the value
            if it's empty)  Using FORCE is faster than non-force.

Decription:
    This function will write the value to the
    registry in either the HKLM or HKCU branches depending
    on the flags set in the dwFlags parameter.
    
Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegWriteUSValueW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzValue,           
    IN  DWORD           dwType,
    IN  LPCVOID         pvData,
    IN  DWORD           cbData,
    IN  DWORD           dwFlags)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_SUCCESS;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    // Assert if: 1) This is not a force open, and 2) they key was not
    // opened with access permissions.
    if (!(dwFlags & (SHREGSET_FORCE_HKCU|SHREGSET_FORCE_HKLM)) && !(pUSKey->samDesired & KEY_QUERY_VALUE))
    {
        ASSERT(NULL);   // ERROR_INVALID_PARAMETER
        return(ERROR_INVALID_PARAMETER);
    }

    if (dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyCurrentUser), (LPWSTR)pwzValue, 
                                    TRUE, dwFlags & SHREGSET_FORCE_HKCU, dwType, pvData, cbData);
    }
    if (dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyLocalMachine), (LPWSTR)pwzValue, 
                                    TRUE, dwFlags & SHREGSET_FORCE_HKLM, dwType, pvData, cbData);
    }

    return lRet;
}





/*----------------------------------------------------------
Purpose: Deletes a registry value.  This will delete HKLM,
         HKCU, or both depending on the hkey parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteUSValueA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszValue,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGDEL_DEFAULT == delRegFlags)        // Delete whatever keys are open
    {
        if (!pUSKey->hkeyCurrentUser)  // Attempt to open HKCU if not currently open
            lRet = PrivFullOpen(pUSKey);

        if (pUSKey->hkeyCurrentUser)
            delRegFlags = SHREGDEL_HKCU;
        else
        {
            // We prefer to delete HKCU, but we got here, so we will delete HKLM
            // if it is open.
            if (pUSKey->hkeyLocalMachine)
                delRegFlags = SHREGDEL_HKLM;
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKCU))        // Check if the call wants to delete the HKLM value.
    {
        if (!pUSKey->hkeyCurrentUser)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyCurrentUser)
        {
            lRet = RegDeleteValueA(pUSKey->hkeyCurrentUser, pszValue);
            if (ERROR_FILE_NOT_FOUND == lRet)
                delRegFlags = SHREGDEL_HKLM;        // Delete the HKLM value if the HKCU value wasn't found.
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKLM))        // Check if the call wants to delete the HKLM value.
    {
        if (!pUSKey->hkeyLocalMachine)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyLocalMachine)
            lRet = RegDeleteValueA(pUSKey->hkeyLocalMachine, pszValue);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Deletes a registry value.  This will delete HKLM,
         HKCU, or both depending on the hkey parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteUSValueW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzValue,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    CHAR   szNewPath[MAXIMUM_VALUE_NAME_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzValue, -1, szNewPath, ARRAYSIZE(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegDeleteUSValueA(hUSKey, szNewPath, delRegFlags);
}


/*----------------------------------------------------------
Purpose: Deletes a registry sub-key if empty.  This will delete HKLM,
         HKCU, or both depending on the delRegFlags parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteEmptyUSKeyA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszSubKey,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGDEL_DEFAULT == delRegFlags)        // Delete whatever keys are open
    {
        if (!pUSKey->hkeyCurrentUser)  // Attempt to open HKCU if not currently open
            lRet = PrivFullOpen(pUSKey);

        if (pUSKey->hkeyCurrentUser)
            delRegFlags = SHREGDEL_HKCU;
        else
        {
            // We prefer to delete HKCU, but we got here, so we will delete HKLM
            // if it is open.
            if (pUSKey->hkeyLocalMachine)
                delRegFlags = SHREGDEL_HKLM;
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKCU))        // Check if the call wants to delete the HKLM key.
    {
        if (!pUSKey->hkeyCurrentUser)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyCurrentUser)
        {
            lRet = SHDeleteEmptyKeyA(pUSKey->hkeyCurrentUser, pszSubKey);
            if (ERROR_FILE_NOT_FOUND == lRet)
                delRegFlags = SHREGDEL_HKLM;        // Delete the HKLM key if the HKCU key wasn't found.
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKLM))        // Check if the call wants to delete the HKLM key.
    {
        if (!pUSKey->hkeyLocalMachine)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyLocalMachine)
            lRet = SHDeleteEmptyKeyA(pUSKey->hkeyLocalMachine, pszSubKey);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Deletes a registry key if empty.  This will delete HKLM,
         HKCU, or both depending on the delRegFlags parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteEmptyUSKeyW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzSubKey,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    CHAR   szNewPath[MAXIMUM_SUB_KEY_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzSubKey, -1, szNewPath, ARRAYSIZE(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegDeleteEmptyUSKeyA(hUSKey, szNewPath, delRegFlags);
}


/*----------------------------------------------------------
Purpose: Enumerates sub-keys under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSKeyA(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPSTR           pszName,
    IN  LPDWORD         pcchName,           
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                (LPWSTR)pszName, FALSE, pcchName);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                (LPWSTR)pszName, FALSE, pcchName);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Enumerates sub-keys under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSKeyW(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPWSTR          pszName,
    IN  LPDWORD         pcchName,           
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                pszName, TRUE, pcchName);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                pszName, TRUE, pcchName);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Enumerates Values under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSValueA(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPSTR           pszValueName,       
    IN  LPDWORD         pcchValueNameLen,
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                (LPWSTR)pszValueName, FALSE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                (LPWSTR)pszValueName, FALSE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Enumerates Values under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSValueW(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPWSTR          pszValueName,       
    IN  LPDWORD         pcchValueNameLen,   
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                pszValueName, TRUE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                pszValueName, TRUE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Gets Info about a HUSKEY.
         Re-uses same flags as enumeration functions. 
         Look at SHRegEnumKeyExA for an explanation of the flags.

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegQueryInfoUSKeyA
(
    IN  HUSKEY              hUSKey,
    OUT LPDWORD             pcSubKeys,             OPTIONAL
    OUT LPDWORD             pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD             pcValues,              OPTIONAL
    OUT LPDWORD             pcchMaxValueNameLen,   OPTIONAL
    IN SHREGENUM_FLAGS      enumRegFlags
)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyCurrentUser), FALSE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet))))
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyLocalMachine), FALSE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Gets Info about a HUSKEY.
         Re-uses same flags as enumeration functions. 
         Look at SHRegEnumKeyExA for an explanation of the flags.

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegQueryInfoUSKeyW
(
    IN  HUSKEY              hUSKey,
    OUT LPDWORD             pcSubKeys,             OPTIONAL
    OUT LPDWORD             pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD             pcValues,              OPTIONAL
    OUT LPDWORD             pcchMaxValueNameLen,    OPTIONAL
    IN SHREGENUM_FLAGS      enumRegFlags
)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyCurrentUser), TRUE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet))))
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyLocalMachine), TRUE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    return lRet;
}

/*----------------------------------------------------------
Purpose: Closes a HUSKEY (Handle to a User Specifc registry key).  

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegCloseUSKey(
    OUT HUSKEY  hUSKey)
{
    PUSKEY  pUSKey = (PUSKEY) hUSKey;
    LONG    lRet   = ERROR_SUCCESS;

    ASSERT(pUSKey);
    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (pUSKey->hkeyLocalMachine)
    {
        lRet = RegCloseKey(pUSKey->hkeyLocalMachine);
        pUSKey->hkeyLocalMachine = NULL;             // Used to indicate that it's invalid.
    }
    if (pUSKey->hkeyLocalMachineRelative && HKEY_LOCAL_MACHINE != pUSKey->hkeyLocalMachineRelative)
    {
        lRet = RegCloseKey(pUSKey->hkeyLocalMachineRelative);
    }

    if (pUSKey->hkeyCurrentUser)
    {
        lRet = RegCloseKey(pUSKey->hkeyCurrentUser);
        pUSKey->hkeyCurrentUser = NULL;             // Used to indicate that it's invalid.
    }
    if (pUSKey->hkeyCurrentUserRelative && HKEY_CURRENT_USER != pUSKey->hkeyCurrentUserRelative)
    {
        lRet = RegCloseKey(pUSKey->hkeyCurrentUserRelative);
    }

    LocalFree((HLOCAL)pUSKey);
    return lRet;
}



/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and then call SHRegQueryUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegGetUSValueA(
    IN  LPCSTR  pszSubKey,          
    IN  LPCSTR  pszValue,           
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData,            OPTIONAL
    IN  BOOL    fIgnoreHKCU,
    IN  LPVOID  pvDefaultData,      OPTIONAL
    IN  DWORD   dwDefaultDataSize)
{
    LONG    lRet;
    HUSKEY  hUSkeys;
    DWORD   dwInitialSize = (pcbData ? *pcbData : 0);
    DWORD   dwType        = (pdwType ? *pdwType : 0); // callers responsibility to set pdwType to the type of pvDefaultData (if they care)


    lRet = SHRegOpenUSKeyA(pszSubKey, KEY_QUERY_VALUE, NULL, &hUSkeys, fIgnoreHKCU);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegQueryUSValueA(hUSkeys, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize);
        SHRegCloseUSKey(hUSkeys);
    }
    
    if (ERROR_SUCCESS != lRet)
    {
        // if fail on open OR on query, use default value as long as dwDefaultDataSize isn't 0. (So we return the error)
        if ((pvDefaultData) && (dwDefaultDataSize) && (pvData) && (dwInitialSize >= dwDefaultDataSize))
        {
            MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
            if (pcbData)
            {
                *pcbData = dwDefaultDataSize;
            }
            if (pdwType)
            {
                *pdwType = dwType;
            }

            lRet = ERROR_SUCCESS;       // Call will now use a default value.
        }
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and then call SHRegQueryUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegGetUSValueW(
    IN  LPCWSTR pwzSubKey,          
    IN  LPCWSTR pwzValue,           
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData,            OPTIONAL
    IN  BOOL    fIgnoreHKCU,
    IN  LPVOID  pvDefaultData,      OPTIONAL
    IN  DWORD   dwDefaultDataSize)
{
    LONG    lRet;
    HUSKEY  hUSkeys;
    DWORD   dwInitialSize = (pcbData ? *pcbData : 0);
    DWORD   dwType = (pdwType ? *pdwType : 0);  // callers responsibility to set pdwType to the type of pvDefaultData (if they care)

    lRet = SHRegOpenUSKeyW(pwzSubKey, KEY_QUERY_VALUE, NULL, &hUSkeys, fIgnoreHKCU);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegQueryUSValueW(hUSkeys, pwzValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize);
        SHRegCloseUSKey(hUSkeys);
    }

    if (ERROR_SUCCESS != lRet)
    {
        // if fail on open OR on query, use default value as long as dwDefaultDataSize isn't 0. (So we return the error)
        if ((pvDefaultData) && (dwDefaultDataSize) && (pvData) && (dwInitialSize >= dwDefaultDataSize))
        {
            // if fail, use default value.
            MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
            if (pcbData)
            {
                *pcbData = dwDefaultDataSize;
            }
            if (pdwType)
            {
                *pdwType = dwType;
            }
            lRet = ERROR_SUCCESS;       // Call will now use a default value.
        }
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Sets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting a series
         of values in the same key, it is better to open
         the key once and then call SHRegWriteUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegSetUSValueA(
    IN  LPCSTR          pszSubKey,          
    IN  LPCSTR          pszValue,           
    IN  DWORD           dwType,
    IN  LPCVOID         pvData,         OPTIONAL
    IN  DWORD           cbData,         OPTIONAL
    IN  DWORD           dwFlags)        OPTIONAL
{
    LONG    lRet;
    HUSKEY  hUSkeys;

    lRet = SHRegCreateUSKeyA(pszSubKey, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hUSkeys, dwFlags);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegWriteUSValueA(hUSkeys, pszValue, dwType, pvData, cbData, dwFlags);
        SHRegCloseUSKey(hUSkeys);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Sets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting a series
         of values in the same key, it is better to open
         the key once and then call SHRegWriteUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegSetUSValueW(
    IN  LPCWSTR         pwzSubKey,          
    IN  LPCWSTR         pwzValue,           
    IN  DWORD           dwType,         OPTIONAL
    IN  LPCVOID         pvData,         OPTIONAL
    IN  DWORD           cbData,         OPTIONAL
    IN  DWORD           dwFlags)        OPTIONAL
{
    LONG    lRet;
    HUSKEY  hUSkeys;

    lRet = SHRegCreateUSKeyW(pwzSubKey, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hUSkeys, dwFlags);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegWriteUSValueW(hUSkeys, pwzValue, dwType, pvData, cbData, dwFlags);
        SHRegCloseUSKey(hUSkeys);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Gets a BOOL Setting from the registry.  The default
         parameter will be used if it's not found in the registry.  

Cond:    --
*/
#define BOOLSETTING_BOOL_TRUE1W   L"YES"
#define BOOLSETTING_BOOL_TRUE1A   "YES"
#define BOOLSETTING_BOOL_TRUE2W   L"TRUE"
#define BOOLSETTING_BOOL_TRUE2A   "TRUE"
#define BOOLSETTING_BOOL_FALSE1W  L"NO"
#define BOOLSETTING_BOOL_FALSE1A  "NO"
#define BOOLSETTING_BOOL_FALSE2W  L"FALSE"
#define BOOLSETTING_BOOL_FALSE2A  "FALSE"
#define BOOLSETTING_BOOL_1W       L"1"
#define BOOLSETTING_BOOL_1A       "1"
#define BOOLSETTING_BOOL_0W       L"0"
#define BOOLSETTING_BOOL_0A       "0"

STDAPI_(BOOL)
SHRegGetBoolUSValueW(
    IN  LPCWSTR         pwzSubKey,          
    IN  LPCWSTR         pwzValue,           
    IN  BOOL            fIgnoreHKCU,
    IN  BOOL            fDefault)
{
    LONG lRet;
    WCHAR szData[MAX_PATH];
    DWORD dwType = REG_SZ;  //because the default value we pass in is a string.
    DWORD dwSize = sizeof(szData);
    LPCWSTR pszDefault = fDefault ? BOOLSETTING_BOOL_TRUE1W : BOOLSETTING_BOOL_FALSE1W;
    DWORD dwDefaultSize = fDefault ? sizeof(BOOLSETTING_BOOL_TRUE1W) : sizeof(BOOLSETTING_BOOL_FALSE1W); // sizeof() includes terminating NULL

    lRet = SHRegGetUSValueW(pwzSubKey, pwzValue, &dwType, (LPVOID) szData, &dwSize, fIgnoreHKCU, (LPVOID) pszDefault, dwDefaultSize);
    if (ERROR_SUCCESS == lRet)
    {
        if (dwType == REG_BINARY || dwType == REG_DWORD)
        {
            fDefault = (*((DWORD*)szData) != 0);
        }
        else
        {
            if ((0 == lstrcmpiW(BOOLSETTING_BOOL_TRUE1W, szData)) || 
                (0 == lstrcmpiW(BOOLSETTING_BOOL_TRUE2W, szData)) ||
                (0 == lstrcmpiW(BOOLSETTING_BOOL_1W, szData)))
            {
                fDefault = TRUE;        // We read TRUE from the registry.
            }
            else if ((0 == lstrcmpiW(BOOLSETTING_BOOL_FALSE1W, szData)) || 
                (0 == lstrcmpiW(BOOLSETTING_BOOL_FALSE2W, szData)) ||
                (0 == lstrcmpiW(BOOLSETTING_BOOL_0W, szData)))
            {
                fDefault = FALSE;        // We read TRUE from the registry.
            }

        }
    }

    return fDefault;
}




/*----------------------------------------------------------
Purpose: Gets a BOOL Setting from the registry.  The default
         parameter will be used if it's not found in the registry.  

Cond:    --
*/

STDAPI_(BOOL)
SHRegGetBoolUSValueA(
    IN  LPCSTR          pszSubKey,          
    IN  LPCSTR          pszValue,           
    IN  BOOL            fIgnoreHKCU,
    IN  BOOL            fDefault)
{
    LONG lRet;
    CHAR szData[MAX_PATH];
    DWORD dwType = REG_SZ;  //because the default value we pass in is a string.
    DWORD dwSize = sizeof(szData);
    LPCSTR pszDefault = fDefault ? BOOLSETTING_BOOL_TRUE1A : BOOLSETTING_BOOL_FALSE1A;
    DWORD dwDefaultSize = (fDefault ? sizeof(BOOLSETTING_BOOL_TRUE1A) : sizeof(BOOLSETTING_BOOL_FALSE1A)) + sizeof(CHAR);

    lRet = SHRegGetUSValueA(pszSubKey, pszValue, &dwType, (LPVOID) szData, &dwSize, fIgnoreHKCU, (LPVOID) pszDefault, dwDefaultSize);
    if (ERROR_SUCCESS == lRet)
    {
        if (dwType == REG_BINARY || dwType == REG_DWORD)
        {
            fDefault = (*((DWORD*)szData) != 0);
        }
        else
        {
            if ((0 == lstrcmpiA(BOOLSETTING_BOOL_TRUE1A, szData)) || 
                (0 == lstrcmpiA(BOOLSETTING_BOOL_TRUE2A, szData)) ||
                (0 == lstrcmpiA(BOOLSETTING_BOOL_1A, szData)))
            {
                fDefault = TRUE;        // We read TRUE from the registry.
            }
            else if ((0 == lstrcmpiA(BOOLSETTING_BOOL_FALSE1A, szData)) || 
                (0 == lstrcmpiA(BOOLSETTING_BOOL_FALSE2A, szData)) ||
                (0 == lstrcmpiA(BOOLSETTING_BOOL_0A, szData)) )
            {
                fDefault = FALSE;        // We read TRUE from the registry.
            }
        }
    }

    return fDefault;
}


/*----------------------------------------------------------
Purpose: Given a CLSID open and return that key from HKCR, or
         the user local version.

Cond:    --
*/

LWSTDAPI SHRegGetCLSIDKeyW(UNALIGNED REFGUID rguid, LPCWSTR pszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey)
{
    HKEY    hkeyRef;
    WCHAR   szThisCLSID[GUIDSTR_MAX];
    WCHAR   szPath[GUIDSTR_MAX+MAX_PATH+1];   // room for clsid + extra
    PCWSTR pszPrefix;
    HRESULT hr;

    SHStringFromGUIDW(rguid, szThisCLSID, ARRAYSIZE(szThisCLSID));

    if (fUserSpecific)
    {
        hkeyRef = HKEY_CURRENT_USER;
        pszPrefix = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\";
    }
    else
    {
        pszPrefix = L"";
        hkeyRef = HKEY_CLASSES_ROOT;
    }

    if (pszSubKey)
    {
        hr = StringCchPrintfW(szPath, ARRAYSIZE(szPath), L"%sCLSID\\%s\\%s", pszPrefix, szThisCLSID, pszSubKey);
    }
    else
    {
        hr = StringCchPrintfW(szPath, ARRAYSIZE(szPath), L"%sCLSID\\%s", pszPrefix, szThisCLSID);
    }

    if (SUCCEEDED(hr))
    {
        LONG lError;

        if (fCreate)
        {
            // SECURITY:  KEY_ALL_ACCESS is used because this is exported so we must maintain backwards compatibility.
            lError = RegCreateKeyExW(hkeyRef, szPath, 0, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, phkey, NULL);
        }
        else
        {
            lError = RegOpenKeyExW(hkeyRef, szPath, 0, MAXIMUM_ALLOWED, phkey);
        }

        hr = HRESULT_FROM_WIN32(lError);
    }

    return hr;
}


LWSTDAPI SHRegGetCLSIDKeyA(UNALIGNED REFGUID rguid, LPCSTR pszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey)
{
    HKEY   hkeyRef;
    CHAR   szThisCLSID[GUIDSTR_MAX];
    CHAR   szPath[GUIDSTR_MAX+MAX_PATH+1];   // room for clsid + extra
    PCSTR pszPrefix;
    HRESULT hr;

    SHStringFromGUIDA(rguid, szThisCLSID, ARRAYSIZE(szThisCLSID));

    if (fUserSpecific)
    {
        hkeyRef = HKEY_CURRENT_USER;
        pszPrefix = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\";
    }
    else
    {
        pszPrefix = "";
        hkeyRef = HKEY_CLASSES_ROOT;
    }

    if (pszSubKey)
    {
        hr = StringCchPrintf(szPath, ARRAYSIZE(szPath), "%sCLSID\\%s\\%s", pszPrefix, szThisCLSID, pszSubKey);
    }
    else
    {
        hr = StringCchPrintf(szPath, ARRAYSIZE(szPath), "%sCLSID\\%s", pszPrefix, szThisCLSID);
    }

    if (SUCCEEDED(hr))
    {
        LONG lError;

        if (fCreate)
        {
            // SECURITY:  KEY_ALL_ACCESS is used because this is exported so we must maintain backwards compatibility.
            lError = RegCreateKeyExA(hkeyRef, szPath, 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, phkey, NULL);
        }
        else
        {
            lError = RegOpenKeyExA(hkeyRef, szPath, 0, MAXIMUM_ALLOWED, phkey);
        }

        hr = HRESULT_FROM_WIN32(lError);
    }    

    return hr;
}

/*----------------------------------------------------------
Purpose: Duplicate an hkey if an object wants to keep one open

//***   Reg_DupKey -- duplicate registry key (upping refcnt)
// NOTES
//  REARCHITECT gotta fix this logic (now that i understand how bogus it is).
//
//  what we're trying to do is dup the handle.  sounds easy.  it isn't.
// here's the deal.
//  1- RegOpenKeyEx(hkey, NULL, ..., &hkey2) is spec'ed as giving back the
//  same handle.  on win95 it ups the refcnt (good!).
//  2- but on winNT there is no refcnt associated w/ it.  so it gives back
//  the same handle but now *any* close will make *all* of the 'pseudo-dup'ed
//  handles invalid.
//  3- (on winNT) if we add MAXIMUM_ALLOWED, we're asking for a new SAM.
//  but the SAM is associated w/ the handle, so the only (or rather, closest)
//  way to do that is to give a new handle.  (presumably this only works
//  if we're not dup'ing a handle that's already MAXIMUM_ALLOWED).
//  4- (on winNT) but wait!  if we open HKEY_CURRENT_USER, we *always* get
//  back 0x80000001 (or somesuch).  but closes on that are ignored, so all
//  works.
//
//  so what we probably should do is:
//  - win95: just do #1, w/ default security.  win95 will give us the same
//  handle w/ an *upped* refcnt and we'll be fine.
//  - winNT: do a DuplicateHandle.  this will correctly give us a *new*
//  handle and we'll be fine.
//
*/
HKEY SHRegDuplicateHKey(HKEY hkey)
{
    HKEY hkeyDup = NULL; // in case incoming hkey is invalid

    // NULL returns key to same place and ups refcnt
    RegOpenKeyExW(hkey, NULL, 0, MAXIMUM_ALLOWED, &hkeyDup);

	ASSERT(hkeyDup != hkey ||
	    hkey == HKEY_CURRENT_USER ||
	    hkey == HKEY_CLASSES_ROOT ||
	    hkey == HKEY_LOCAL_MACHINE);

    return hkeyDup;
}

/*----------------------------------------------------------
Purpose: Read a string value from the registry and convert it
         to an integer.

*/
LWSTDAPI_(int) SHRegGetIntW(HKEY hk, LPCWSTR szKey, int nDefault)
{
    DWORD cb;
    WCHAR ach[20];

    if (hk == NULL)
        return nDefault;

    ach[0] = 0;
    cb = sizeof(ach);

    if (SHQueryValueExW(hk, szKey, NULL, NULL, (LPBYTE)ach, &cb) == ERROR_SUCCESS
        && ach[0] >= L'0'
        && ach[0] <= L'9')
        return StrToIntW(ach);
    else
        return nDefault;
}



//  Stores a file path in the registry but looks for a match with
//  certain environment variables first. This is a FIXED list.

//  Parameters:

//             hKey - an open HKEY or registry root key
//      pszSubKey - subkey in registry or NULL/zero length string
//       pszValue - value name in registry
//        pszPath - Win32 file path to write
//          dwFlags - unused / future expansion

//  Return value:
//      Returns Win32 error code from ADVAPI32.DLL function calls.

//
//  Match        %USERPROFILE% - x:\WINNT\Profiles\<user>
//                             - x:\Documents And Settings\<user>
//          %ALLUSERSPROFILES% - x:\WINNT\Profiles\<user>
//                             - x:\Documents And Settings\<user>
//              %ProgramFiles% - x:\Program Files
//                %SystemRoot% - x:\WINNT
//
//  %ALLUSERSPROFILE% and %ProgramFiles% are dubious and can be
//  removed.
//
//  WARNING: DO NOT CHANGE THE MATCH ORDER OF %USERPROFILE% AND
//  %SystemRoot%
//
//  If %SystemRoot% is matched first then %USERPROFILE% will
//  NEVER be matched if inside x:\WINNT\ 
//
DWORD SHRegSetPathW (HKEY hKey, LPCWSTR pszSubKey, LPCWSTR pszValue, LPCWSTR pszPath, DWORD dwFlags)
{
    DWORD dwType;
    PCWSTR pszData;
    WCHAR  szTemp[MAX_PATH];
    if (PathUnExpandEnvStringsW(pszPath, szTemp, ARRAYSIZE(szTemp)))
    {
        dwType = REG_EXPAND_SZ;
        pszData = szTemp;
    }
    else
    {
        dwType = REG_SZ;
        pszData = pszPath;
    }
    
    return SHSetValueW(hKey, pszSubKey, pszValue, dwType, pszData, (lstrlenW(pszData) + 1) * sizeof(pszData[0]));
}

DWORD SHRegSetPathA(HKEY hKey, LPCSTR pszSubKey, LPCSTR pszValue, LPCSTR pszPath, DWORD dwFlags)
{
    DWORD dwType;
    PCSTR pszData;
    CHAR  szTemp[MAX_PATH];
    if (PathUnExpandEnvStringsA(pszPath, szTemp, ARRAYSIZE(szTemp)))
    {
        dwType = REG_EXPAND_SZ;
        pszData = szTemp;
    }
    else
    {
        dwType = REG_SZ;
        pszData = pszPath;
    }
    
    return SHSetValueA(hKey, pszSubKey, pszValue, dwType, pszData, (lstrlenA(pszData) + 1) * sizeof(pszData[0]));
}

//  RegGetPath: Unicode implementation of function.
//  Returns an expanded file path from the registry.

//  Parameters:

//             hKey - an open HKEY or registry root key
//      pszSubKey - subkey in registry or NULL/zero length string
//       pszValue - value name in registry
//         pwszPath - string to place path in (assumed size of MAX_PATH chars)
//          dwFlags - unused / future expansion

//  Return value:
//      Returns Win32 error code from ADVAPI32.DLL function calls.

DWORD   SHRegGetPathA (HKEY hKey, LPCSTR pszSubKey, LPCSTR pszValue, LPSTR pszPath, DWORD dwFlags)
{
    DWORD cb = MAX_PATH * sizeof(pszPath[0]);
    return SHGetValueA(hKey, pszSubKey, pszValue, NULL, pszPath, &cb);
}

DWORD   SHRegGetPathW (HKEY hKey, LPCWSTR pszSubKey, LPCWSTR pszValue, LPWSTR pszPath, DWORD dwFlags)
{
    DWORD cb = MAX_PATH * sizeof(pszPath[0]);
    return SHGetValueW(hKey, pszSubKey, pszValue, NULL, pszPath, &cb);
}

BOOL Reg_GetCommand(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszValue, LPWSTR pszCommand)
{
    WCHAR szKey[1024];
    LONG cbSize = sizeof(szKey);
    int iLen;

    ASSERT(pszKey);

    StrCpyNW(szKey, pszKey, ARRAYSIZE(szKey));
    iLen = lstrlenW(szKey);
    pszCommand[0] = 0;

    // a trailing backslash means no value key
    if (szKey[iLen-1] == L'\\' ||
        (pszValue && !pszValue[0])) {

        if (!pszValue)
            szKey[iLen-1] = 0;

        RegQueryValueW(hkey, szKey, pszCommand, &cbSize);

    } else {

        if (!pszValue)
            pszValue = PathFindFileNameW(szKey);

        ASSERT(pszValue);
        if (!pszValue)
            return FALSE;

        PathRemoveFileSpecW(szKey);
        SHGetValueGoodBootW(hkey, szKey, pszValue, NULL, (LPBYTE)pszCommand, (DWORD*)&cbSize);
    }

    if (pszCommand[0]) {
        LPWSTR pszNextKey;

        // see if it's a registry spec
        if (!StrCmpNIW(pszCommand, L"HKCU:", 5)) {
            hkey = HKEY_CURRENT_USER;
            pszNextKey = pszCommand + 5;

        } else if (!StrCmpNIW(pszCommand, L"HKLM:", 5)) {
            hkey = HKEY_LOCAL_MACHINE;
            pszNextKey = pszCommand + 5;

        } else if (!StrCmpNIW(pszCommand, L"HKCR:", 5)) {
            hkey = HKEY_CLASSES_ROOT;
            pszNextKey = pszCommand + 5;
        } else {

            return (BOOL)pszCommand[0];
        }

        StrCpyNW(szKey, pszNextKey, ARRAYSIZE(szKey));
        return (Reg_GetCommand(hkey, szKey, NULL, pszCommand));
    }

    return (BOOL)pszCommand[0];
}

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFOW);

HRESULT RunRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey)
{
    HRESULT hr = E_FAIL;


    WCHAR szCommand[1024];
    if (Reg_GetCommand(hkey, pszKey, L"", szCommand)) 
    {
        LPWSTR pszArgs;
        SHELLEXECUTEINFOW ExecInfo;
        WCHAR szExpCommand[1024];

        SHExpandEnvironmentStringsW(szCommand, szExpCommand, ARRAYSIZE(szExpCommand));

        // Long filenames _should_ be surrounded by quote marks. However, some aren't.
        // This causes problems because the registry entry might be of the form 
        // (c:\program files\Windows Messaging\[...]) instead of 
        // ("c:\program files\Windows Messaging\[...]"). Compare this with 
        // a reg value with (rundll32 C:\progra~1\etc)
        // We end up parsing attempting to run C:\program, which of course doesn't exist.

        // This is a hack for the benefit OSR2, which turns szExpCommand
        // into a null string, rather than letting it be, if it can't be shortened.
        GetShortPathNameW(szExpCommand, szExpCommand, ARRAYSIZE(szExpCommand));
        if ((*szExpCommand==L'\0') && (*szCommand!=L'\0'))
        {
            SHExpandEnvironmentStringsW(szCommand, szExpCommand, ARRAYSIZE(szExpCommand));
        }
        pszArgs = PathGetArgsW(szExpCommand);
        PathRemoveArgsW(szExpCommand);
        PathUnquoteSpacesW(szExpCommand);
        FillExecInfo(ExecInfo, hwnd, NULL, szExpCommand, pszArgs, NULL, SW_SHOWNORMAL);
        ExecInfo.fMask |= SEE_MASK_FLAG_LOG_USAGE;

        hr = ShellExecuteExW(&ExecInfo) ? S_OK : ResultFromLastError();
    }

    return hr;
}

// NOTE!  RunIndirectRegCommand logs the action as user-initiated!

HRESULT RunIndirectRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey, LPCWSTR pszVerb)
{
    HRESULT hr = E_FAIL;
    WCHAR szDefApp[80];
    LONG cbSize = sizeof(szDefApp);

    if (RegQueryValueW(hkey, pszKey, szDefApp, &cbSize) == ERROR_SUCCESS) 
    {
        WCHAR szFullKey[256];

        // tack on shell\%verb%\command
        wnsprintfW(szFullKey, ARRAYSIZE(szFullKey), L"%s\\%s\\shell\\%s\\command", pszKey, szDefApp, pszVerb);
        hr = RunRegCommand(hwnd, hkey, szFullKey);
    }

    return hr;
}

HRESULT SHRunIndirectRegClientCommand(HWND hwnd, LPCWSTR pszClient)
{
    WCHAR szKey[80];

    wnsprintfW(szKey, ARRAYSIZE(szKey), L"Software\\Clients\\%s", pszClient);
    return RunIndirectRegCommand(hwnd, HKEY_LOCAL_MACHINE, szKey, L"Open");
}




/////////////////////////////////////////////////////////////////////////////
//
//
//  Deprecated Registry APIs
//
//


STDAPI_(DWORD) SHGetValueA(HKEY hkey, PCSTR pszSubKey, PCSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData)
{
    return SHRegGetValueA(hkey, pszSubKey, pszValue, SRRF_RT_ANY, pdwType, pvData, pcbData);
}

STDAPI_(DWORD) SHGetValueW(HKEY hkey, PCWSTR pwszSubKey, PCWSTR pwszValue, DWORD *pdwType, void *pvData, DWORD *pcbData)
{
    return SHRegGetValueW(hkey, pwszSubKey, pwszValue, SRRF_RT_ANY, pdwType, pvData, pcbData);
}

STDAPI_(DWORD) SHGetValueGoodBootA(HKEY hkey, PCSTR pszSubKey, PCSTR pszValue, DWORD *pdwType, BYTE *pbData, DWORD *pcbData)
{
    return SHRegGetValueA(hkey, pszSubKey, pszValue, SRRF_RT_ANY | SRRF_RM_NORMAL, pdwType, pbData, pcbData);
}

STDAPI_(DWORD) SHGetValueGoodBootW(HKEY hkey, PCWSTR pwszSubKey, PCWSTR pwszValue, DWORD *pdwType, BYTE *pbData, DWORD *pcbData)
{
    return SHRegGetValueW(hkey, pwszSubKey, pwszValue, SRRF_RT_ANY | SRRF_RM_NORMAL, pdwType, pbData, pcbData);
}

STDAPI_(DWORD) SHQueryValueExA(HKEY hkey, PCSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData)
{
    return SHRegGetValueA(hkey, NULL, pszValue, SRRF_RT_ANY, pdwType, pvData, pcbData);
}

STDAPI_(DWORD) SHQueryValueExW(HKEY hkey, PCWSTR pwszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData)
{
    return SHRegGetValueW(hkey, NULL, pwszValue, SRRF_RT_ANY, pdwType, pvData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\security.cpp ===
#include "priv.h"
#include <shlobj.h>
#include <shellp.h>
#include <shdguid.h>
#include "ids.h"
#include <objbase.h>
#include <wininet.h>            // INTERNET_MAX_URL_LENGTH
#include <shellp.h>
#include <commctrl.h>
#include <mluisupp.h>
#include <inetcpl.h>
#include <crypto\md5.h>

#ifdef UNIX
#include <urlmon.h>
#endif

// This will automatically be freed when the process shuts down.
// Creating the ClassFactory for CLSID_InternetSecurityManager
// is really slow, so we cache it because dragging and dropping
// files does a lot of zone checking.
IClassFactory * g_pcf = NULL;

HRESULT _GetCachedZonesManager(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (!g_pcf)
    {
        CoGetClassObject(CLSID_InternetSecurityManager, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&g_pcf);
        SHPinDllOfCLSID(&CLSID_InternetSecurityManager);
    }

    if (g_pcf) 
    {
        hr = g_pcf->CreateInstance(NULL, riid, ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }
    return hr;
}


             
/**********************************************************************\
    FUNCTION: ZoneCheckUrlExCacheW

    DESCRIPTION:

        Call IInternetSecurityManager::ProcessUrlAction using the
        cached one if available.

        pwszUrl - URL to check
        pdwPolicy - Receives resulting policy (optional)
        dwPolicySize - size of policy buffer (usually sizeof(DWORD))
        pdwContext - context (optional)
        dwContextSize - size of context buffer (usually sizeof(DWORD))
        dwActionType - ProcessUrlAction action type code
        dwFlags - Flags for ProcessUrlAction
        pisms - IInternetSecurityMgrSite to use during
                ProcessUrlAction (optional)
        ppismCache - (in/out) IInternetSecurityManager to use

        If ppismCache is NULL, then no cacheing is performed;
        we use a brand new IInternetSecurityManager.

        If ppismCache is non-null, then it used to cache an
        IInternetSecurityManager.  If there is one there already, we
        use it.  If there isn't one there already, we create one and
        save it there.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExCacheW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache)
{
    HRESULT hr = E_INVALIDARG;

    if (pwzUrl)
    {
        IInternetSecurityManager *psim;

        if (ppismCache && *ppismCache)
        {
            hr = (*ppismCache)->QueryInterface(IID_PPV_ARG(IInternetSecurityManager, &psim));
        }
        else
        {
            hr = _GetCachedZonesManager(IID_PPV_ARG(IInternetSecurityManager, &psim));
            if (SUCCEEDED(hr) && ppismCache)
                psim->QueryInterface(IID_PPV_ARG(IInternetSecurityManager, ppismCache));
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            if (pisms)
                psim->SetSecuritySite(pisms);

            hr = psim->ProcessUrlAction(pwzUrl, dwActionType, 
                                    (BYTE *)(pdwPolicy ? pdwPolicy : &dwPolicy), 
                                    (pdwPolicy ? dwPolicySize : sizeof(dwPolicy)), 
                                    (BYTE *)(pdwContext ? pdwContext : &dwContext), 
                                    (pdwContext ? dwContextSize : sizeof(dwContext)), 
                                    dwFlags, 0);
            TraceMsg(TF_GENERAL, "ZoneCheckUrlExW(\"%ls\") IsFile=%s; NoUI=%s; dwActionType=0x%lx; dwFlags=0x%lx; hr=%lx>",
                     pwzUrl, (dwFlags & PUAF_ISFILE) ? TEXT("Yes") : TEXT("No"),
                     (dwFlags & PUAF_NOUI) ? TEXT("Yes") : TEXT("No"),
                     dwActionType, dwFlags, hr);

            if (pisms)
                psim->SetSecuritySite(NULL);

            psim->Release();
        }
    }
    return hr;
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlExCacheA

    DESCRIPTION:

        ANSI version of ZoneCheckUrlExCacheW.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExCacheA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache)
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

    return ZoneCheckUrlExCacheW(wzUrl, pdwPolicy, dwPolicySize, pdwContext, dwContextSize, dwActionType, dwFlags, pisms, ppismCache);
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlExW

    DESCRIPTION:

        Just like ZoneCheckUrlExCacheW, except never caches.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    return ZoneCheckUrlExCacheW(pwzUrl, pdwPolicy, dwPolicySize, pdwContext, dwContextSize, dwActionType, dwFlags, pisms, NULL);
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlExA

    DESCRIPTION:

        ANSI version of ZoneCheckUrlExW.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlExA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

    return ZoneCheckUrlExW(wzUrl, pdwPolicy, dwPolicySize, pdwContext, dwContextSize, dwActionType, dwFlags, pisms);
}

             
/**********************************************************************\
    FUNCTION: ZoneCheckUrlW

    DESCRIPTION:

        Just like ZoneCheckUrlExW, except that no context or policy
        information are used.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlW(LPCWSTR pwzUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    return ZoneCheckUrlExW(pwzUrl, NULL, 0, NULL, 0, dwActionType, dwFlags, pisms);
}


/**********************************************************************\
    FUNCTION: ZoneCheckUrlA

    DESCRIPTION:
        ANSI version of ZoneCheckUrlW,

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckUrlA(LPCSTR pszUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

    return ZoneCheckUrlW(wzUrl, dwActionType, dwFlags, pisms);
}


/**********************************************************************\
    FUNCTION: ZoneCheckPathW

    DESCRIPTION:

        Just like ZoneCheckUrlW, except for filenames instead of URLs.

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckPathW(LPCWSTR pwzPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    ASSERT(!PathIsRelativeW(pwzPath));
    return ZoneCheckUrlW(pwzPath, dwActionType, (dwFlags | PUAF_ISFILE), pisms);
}


/**********************************************************************\
    FUNCTION: ZoneCheckPathA

    DESCRIPTION:
        ANSI version of ZoneCheckPathW,

        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckPathA(LPCSTR pszPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    WCHAR wzPath[INTERNET_MAX_URL_LENGTH];

    ASSERT(ARRAYSIZE(wzPath) > lstrlenA(pszPath));        // We only work for Urls of INTERNET_MAX_URL_LENGTH or shorter.
    SHAnsiToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));

    return ZoneCheckPathW(wzPath, dwActionType, dwFlags, pisms);
}

/**********************************************************************\
    FUNCTION: ZoneCheckHostEx

    DESCRIPTION:
        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckHostEx(IInternetHostSecurityManager * pihsm, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags)
{
    HRESULT hr;
    DWORD dwPolicy = 0;
    DWORD dwContext = 0;

    ASSERT(IsFlagClear(dwFlags, PUAF_ISFILE));  // This flag is not appropriate here.
    if (!EVAL(pihsm))
        return E_INVALIDARG;

    hr = pihsm->ProcessUrlAction(dwActionType, 
                            (BYTE *)(pdwPolicy ? pdwPolicy : &dwPolicy), 
                            (pdwPolicy ? dwPolicySize : sizeof(dwPolicy)), 
                            (BYTE *)(pdwContext ? pdwContext : &dwContext), 
                            (pdwContext ? dwContextSize : sizeof(dwContext)), 
                            dwFlags, 0);
    TraceMsg(TF_GENERAL, "ZoneCheckHostEx() NoUI=%s; hr=%lx", (dwFlags & PUAF_NOUI) ? TEXT("Yes") : TEXT("No"), hr);

    return hr;
}


/**********************************************************************\
    FUNCTION: ZoneCheckHost

    DESCRIPTION:
        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
LWSTDAPI ZoneCheckHost(IInternetHostSecurityManager * pihsm, DWORD dwActionType, DWORD dwFlags)
{
    return ZoneCheckHostEx(pihsm, NULL, 0, NULL, 0, dwActionType, dwFlags);
}

/**********************************************************************\
    FUNCTION: ZoneComputePaneSize
    
    DESCRIPTION:
        Computes the necessary size for the zones pane in a status bar.

    NOTES
        The longest zone is the following:

        Width of longest zone name +
        Width of " (Mixed)" +
        Width of small icon (SM_CXSMICON) +
        Width of gripper (SM_CXVSCROLL) +
        Four edges (4 * SM_CXEDGE)

    Why four edges?  Because the rectangle is framed in a DrawEdge(),
    which adds two edges on the left and two on the right, for a total
    of four.

    We cache the results of the font measurements for performance.

\**********************************************************************/

#define ZONES_PANE_WIDTH    220 // Size to use if we are desperate

int _ZoneComputePaneStringSize(HWND hwndStatus, HFONT hf)
{
    HDC hdc = GetDC(hwndStatus);
    HFONT hfPrev = SelectFont(hdc, hf);
    SIZE siz, sizMixed;
    HRESULT hrInit, hr;
    int cxZone;
    ZONEATTRIBUTES za;

    // Start with the length of the phrase " (Mixed)"
    MLLoadStringW(IDS_MIXED, za.szDisplayName, ARRAYSIZE(za.szDisplayName));
    GetTextExtentPoint32W(hdc, za.szDisplayName, lstrlenW(za.szDisplayName), &sizMixed);

    cxZone = 0;

    hrInit = SHCoInitialize();
    IInternetZoneManager *pizm;
    hr = CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetZoneManager, (void **)&pizm);
    if (SUCCEEDED(hr)) {
        DWORD dwZoneEnum, dwZoneCount;
        hr = pizm->CreateZoneEnumerator(&dwZoneEnum, &dwZoneCount, 0);
        if (SUCCEEDED(hr)) {
            for (int nIndex=0; (DWORD)nIndex < dwZoneCount; nIndex++)
            {
                DWORD dwZone;
                za.cbSize = sizeof(ZONEATTRIBUTES);
                pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);
                pizm->GetZoneAttributes(dwZone, &za);
                GetTextExtentPoint32W(hdc, za.szDisplayName, lstrlenW(za.szDisplayName), &siz);
                if (cxZone < siz.cx)
                    cxZone = siz.cx;
            }
            pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
        pizm->Release();
    }
    SHCoUninitialize(hrInit);

    SelectFont(hdc, hfPrev);
    ReleaseDC(hwndStatus, hdc);

    // If we couldn't get any zones, then use the panic value.
    if (cxZone == 0)
        return ZONES_PANE_WIDTH;
    else
        return cxZone + sizMixed.cx;
}

LOGFONT s_lfStatusBar;          // status bar font (cached metrics)
int s_cxMaxZoneText;            // size of longest zone text (cached)

LWSTDAPI_(int) ZoneComputePaneSize(HWND hwndStatus)
{
    LOGFONT lf;
    HFONT hf = GetWindowFont(hwndStatus);
    GetObject(hf, sizeof(lf), &lf);

    // Warning:  lf.lfFaceName is an ASCIIZ string, and there might be
    // uninitialized garbage there, so zero-fill it for consistency.
    UINT cchFaceName = lstrlen(lf.lfFaceName);
    ZeroMemory(&lf.lfFaceName[cchFaceName], sizeof(TCHAR) * (LF_FACESIZE - cchFaceName));

    if (memcmp(&lf, &s_lfStatusBar, sizeof(LOGFONT)) != 0)
    {
        ENTERCRITICAL;
        s_cxMaxZoneText = _ZoneComputePaneStringSize(hwndStatus, hf);
        s_lfStatusBar = lf;         // Update the cache
        LEAVECRITICAL;
    }

    return s_cxMaxZoneText + 
           GetSystemMetrics(SM_CXSMICON) +
           GetSystemMetrics(SM_CXVSCROLL) +
           GetSystemMetrics(SM_CXEDGE) * 4;
}

/**********************************************************************\
    FUNCTION: ZoneConfigure
    
    DESCRIPTION:
        Displays the Zones configuration control panel.

        pwszUrl is used to specify which zone is chosen as default.
        Inetcpl will choose the zone that the URL belongs to.

\**********************************************************************/

#define MAX_CPL_PAGES   16

BOOL CALLBACK _ZoneAddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_CPL_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

LWSTDAPI_(void) ZoneConfigureW(HWND hwnd, LPCWSTR pwszUrl)
{
    HMODULE hModInetCpl;

    if (hModInetCpl = LoadLibrary(TEXT("inetcpl.cpl")))
    {
        PFNADDINTERNETPROPERTYSHEETSEX pfnAddSheet = (PFNADDINTERNETPROPERTYSHEETSEX)GetProcAddress(hModInetCpl, STR_ADDINTERNETPROPSHEETSEX);
        if (pfnAddSheet)
        {
            IEPROPPAGEINFO iepi = {SIZEOF(iepi)};
            // Load the current url into the properties page
            CHAR szBufA[INTERNET_MAX_URL_LENGTH];
            SHUnicodeToAnsi(pwszUrl, szBufA, ARRAYSIZE(szBufA));
            iepi.pszCurrentURL = szBufA;

            PROPSHEETHEADER psh;
            HPROPSHEETPAGE rPages[MAX_CPL_PAGES];

            psh.dwSize = SIZEOF(psh);
            psh.dwFlags = PSH_PROPTITLE;
            psh.hInstance = MLGetHinst();
            psh.hwndParent = hwnd;
            psh.pszCaption = MAKEINTRESOURCE(IDS_INTERNETSECURITY);
            psh.nPages = 0;
            psh.nStartPage = 0;
            psh.phpage = rPages;

             // we just want the security page.
            iepi.dwFlags = INET_PAGE_SECURITY;

            pfnAddSheet(_ZoneAddPropSheetPage, (LPARAM)&psh, 0, 0, &iepi);

            //
            // Display the property sheet only if the "security" page was 
            // successfully added (it will fail if an IEAK setting says so)
            //
            if (psh.nPages > 0)
            {
                PropertySheet(&psh);
            }
            else
            {
                SHRestrictedMessageBox(hwnd);
            }
        }
        FreeLibrary(hModInetCpl);
    }
}

/**********************************************************************\
    DESCRIPTION:
        Registers or validates an htt/htm template with the shell.

        The WebView customization wizard and the code that installs the default
        WebView templates calls this API to register the templates.

        The shell object model uses this API to grant privileges to execute
        unsafe method calls (e.g. SHELL.APPLICATION) to templates registered
        with this API.  If they aren't registered, they can't call the unsafe methods.

\**********************************************************************/

#define REGSTR_TEMPLATE_REGISTRY (REGSTR_PATH_EXPLORER TEXT("\\TemplateRegistry"))
#define REGSTR_VALUE_KEY (TEXT("Value"))

BOOL GetTemplateValueFromReg(LPTSTR pszValue, DWORD *pdwValue)
{
    DWORD cbValue = sizeof(DWORD);
    BOOL bSuccess;

    if (!(bSuccess = (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_TEMPLATE_REGISTRY, pszValue, NULL, pdwValue, &cbValue))))
    {
        cbValue = sizeof(DWORD);
        bSuccess = (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_TEMPLATE_REGISTRY, pszValue, NULL, pdwValue, &cbValue));
    }
    return bSuccess;
}

BOOL SetTemplateValueInReg(LPTSTR pszValue, DWORD *pdwValue)
{
    return ((ERROR_SUCCESS == SHSetValue(HKEY_LOCAL_MACHINE, REGSTR_TEMPLATE_REGISTRY, pszValue, REG_DWORD, pdwValue, sizeof(DWORD))) ||
            (ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, REGSTR_TEMPLATE_REGISTRY, pszValue, REG_DWORD, pdwValue, sizeof(DWORD))));
}

// pKey must point to MD5DIGESTLEN bytes.
HRESULT GetTemplateInfoFromHandle(HANDLE h, UCHAR * pKey, DWORD *pdwSize)
{
    HRESULT hres = E_FAIL;
    DWORD  dwSize = GetFileSize(h, NULL);
    LPBYTE pFileBuff = (LPBYTE)LocalAlloc(0, dwSize);
    if (pFileBuff)
    {
        DWORD dwBytesRead;
        if (ReadFile(h, pFileBuff, dwSize, &dwBytesRead, NULL))
        {
            MD5_CTX md5;

            MD5Init(&md5);
            MD5Update(&md5, pFileBuff, dwBytesRead);
            MD5Final(&md5);

            memcpy(pKey, md5.digest, MD5DIGESTLEN);
            *pdwSize = dwSize;
            hres = S_OK;
        }
        LocalFree(pFileBuff);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

// in:
//      pszPath         URL or file system path
// return:
//      S_OK            if pszPath is in the local zone
//      E_ACCESSDENIED  we are not in a local zone
//
// WARNING: Only use this from SHRegisterValidateTemplate
//     because this isn't good enough for general use.
//
// QUESTION:
//     It's not good enought to CoCreate IInternetSecurityManager
//     (done in _GetCachedZonesManager), because it needs
//     to be provided from the host via QueryService. 
//     Outlook Express is one example that needs to over-ride
//     the default implementation.  Right?
// ANSWER:
//     Using this from SHRegisterValidateTemplate is OK
//     because the only callers are Explorer, which never
//     overrides the default zone behavior.  (And the templates
//     are defview implementations which also don't need zone override.)
//
STDAPI SuperPrivate_ZoneCheckPath(LPCWSTR pszPath, DWORD dwZone)
{
    HRESULT hr = E_ACCESSDENIED;
    IInternetSecurityManager *pSecMgr;
    if (SUCCEEDED(_GetCachedZonesManager(IID_PPV_ARG(IInternetSecurityManager, &pSecMgr)))) 
    {
        DWORD dwZoneID = URLZONE_UNTRUSTED;
        if (SUCCEEDED(pSecMgr->MapUrlToZone(pszPath, &dwZoneID, 0))) 
        {
            if (dwZoneID == dwZone)
            {
                hr = S_OK;      // we are good
            }
        }       
        pSecMgr->Release();
    }
    return hr;
}

// this API takes a Win32 file path
// in:
//      dwFlags     SHRVT_ falgs in shlwapi.h
// out:
//      S_OK        happy

LWSTDAPI SHRegisterValidateTemplate(LPCWSTR pszPath, DWORD dwFlags)
{
    if ((dwFlags & SHRVT_VALID) != dwFlags)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if (dwFlags & SHRVT_VALIDATE)
    {
        hr = SuperPrivate_ZoneCheckPath(pszPath, URLZONE_LOCAL_MACHINE);

        if (FAILED(hr) && (dwFlags & SHRVT_ALLOW_INTRANET))
        {
            hr = SuperPrivate_ZoneCheckPath(pszPath, URLZONE_INTRANET);
        }
    }

    if (S_OK == hr)
    {
        DWORD dwSize;
        UCHAR pKey[MD5DIGESTLEN];

        HANDLE hfile = CreateFileW(pszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (INVALID_HANDLE_VALUE != hfile)
        {
            hr = GetTemplateInfoFromHandle(hfile, pKey, &dwSize);
            CloseHandle(hfile);
        }
        else
            hr = E_INVALIDARG;

        if (SUCCEEDED(hr))
        {
            BOOL bSuccess;
            TCHAR szTemplate[MAX_PATH];

            DWORD *pdw = (DWORD *)pKey;

            ASSERT(MD5DIGESTLEN == (4 * sizeof(DWORD)));
        
            StringCchPrintf(szTemplate, ARRAYSIZE(szTemplate), TEXT("%u%u%u%u"), pdw[0], pdw[1], pdw[2], pdw[3]);

            if (dwFlags & SHRVT_VALIDATE)
            {
                DWORD dwSizeReg;
                bSuccess = (GetTemplateValueFromReg(szTemplate, &dwSizeReg) && (dwSizeReg == dwSize));
                if (!bSuccess && (dwFlags & SHRVT_PROMPTUSER))
                {
                    MSGBOXPARAMS mbp = {sizeof(MSGBOXPARAMS), NULL, g_hinst, MAKEINTRESOURCE(IDS_TEMPLATENOTSECURE), MAKEINTRESOURCE(IDS_SECURITY),
                                        MB_YESNO | MB_DEFBUTTON2 | MB_TASKMODAL | MB_USERICON, MAKEINTRESOURCE(IDI_SECURITY), 0, NULL, 0};

                    // REARCHITECT: posting a msg box with NULL hwnd, this should
                    // could use a site pointer to get an hwnd to go modal against
                    // if one was provided to the API
                    // Are we calling A or W MessageBoxIndirect and does this break on NT/9x?
                    // Doesn't seem to, -justmann
                    bSuccess = (MessageBoxIndirect(&mbp) == IDYES);

                    if (bSuccess && (dwFlags & SHRVT_REGISTERIFPROMPTOK))
                        SetTemplateValueInReg(szTemplate, &dwSize);
                }
            }
            else  if (dwFlags & SHRVT_REGISTER)
            {
                bSuccess = SetTemplateValueInReg(szTemplate, &dwSize);
            }
            hr = bSuccess ? S_OK : E_ACCESSDENIED;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\regw.cpp ===
#include "priv.h"
#include "unicwrap.h"

/*****************************************************************************\
    FUNCTION: SHLoadRegUIString

    DESCRIPTION:
        loads the data from the value given the hkey and
        pszValue. if the data is of the form:

        @[path\]<dllname>,-<strId>

        the string with id <strId> from <dllname> will be
        loaded. if not explicit path is provided then the
        dll will be chosen according to pluggable UI
        specifications, if possible.

        if the value's data doesn't yield a successful
        string load, then the data itself is returned

    NOTE:
        These strings are always loaded with cross codepage support.

    WARNING:
        This function can end up calling LoadLibrary and FreeLibrary.
        Therefore, you must not call SHLoadRegUIString during process
        attach or process detach.

    PARAMETERS:
        hkey        - hkey of where to look for pszValue
        pszValue    - value with text string or indirector (see above) to use
        pszOutBuf   - buffer in which to return the data or indirected string
        cchOutBuf   - size of pszOutBuf
\*****************************************************************************/

LANGID GetNormalizedLangId(DWORD dwFlag);

STDAPI
SHLoadRegUIStringW(HKEY     hkey,
                   LPCWSTR  pszValue,
                   LPWSTR   pszOutBuf,
                   UINT     cchOutBuf)
{
    HRESULT hr;

    RIP(hkey != NULL);
    RIP(hkey != INVALID_HANDLE_VALUE);
    RIP(NULL == pszValue || IS_VALID_STRING_PTRW(pszValue, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszOutBuf, WCHAR, cchOutBuf));

    DEBUGWhackPathBufferW(pszOutBuf, cchOutBuf);

    // Lots of people (regfldr.cpp, for example)
    // assume they'll get back an empty string on failure,
    // so let's give the public what it wants
    if (cchOutBuf)
        pszOutBuf[0] = 0;

    hr = E_INVALIDARG;

    if (hkey != INVALID_HANDLE_VALUE &&
        hkey != NULL &&
        pszOutBuf != NULL)
    {
        DWORD   cb;
        DWORD   dwRet;
        WCHAR * pszValueDataBuf;

        hr = E_FAIL;

        // first try to get the indirected text which will
        // point to a string id in a dll somewhere... this
        // allows plugUI enabled registry UI strings

        pszValueDataBuf = pszOutBuf;
        cb = CbFromCchW(cchOutBuf);

        dwRet = SHQueryValueExW(hkey, pszValue, NULL, NULL, (LPBYTE)pszValueDataBuf, &cb);
        if (dwRet == ERROR_SUCCESS || dwRet == ERROR_MORE_DATA)
        {
            BOOL fAlloc;

            fAlloc = (dwRet == ERROR_MORE_DATA);

            // if we didn't have space, this is where we correct the problem.
            // we create a buffer big enough, load the data, and leave
            // ourselves with pszValueDataBuf pointing at a valid buffer
            // containing valid data, exactly what we hoped for in the
            // SHQueryValueExW above

            if (fAlloc)
            {
                pszValueDataBuf = new WCHAR[(cb+1)/2];
                
                if (pszValueDataBuf != NULL)
                {
                    // try to load again... overwriting dwRet on purpose
                    // because we only need to know whether we successfully filled
                    // the buffer at some point (whether then or now)
                    
                    dwRet = SHQueryValueExW(hkey, pszValue, NULL, NULL, (LPBYTE)pszValueDataBuf, &cb);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }                
            }

            // proceed if we succesfully loaded something via one of the
            // two SHQueryValueExW calls.
            // we should have the data we want in a buffer pointed
            // to by pszValueDataBuf.
            
            if (dwRet == ERROR_SUCCESS)
            {
                hr = SHLoadIndirectString(pszValueDataBuf, pszOutBuf, cchOutBuf, NULL);
            }

            if (fAlloc && pszValueDataBuf != NULL)
            {
                delete [] pszValueDataBuf;
            }
        }
    }

    return hr;
}

STDAPI
SHLoadRegUIStringA(HKEY     hkey,
                   LPCSTR   pszValue,
                   LPSTR    pszOutBuf,
                   UINT     cchOutBuf)
{
    HRESULT     hr;

    RIP(hkey != NULL);
    RIP(hkey != INVALID_HANDLE_VALUE);
    RIP(IS_VALID_STRING_PTRA(pszValue, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszOutBuf, char, cchOutBuf));

    CStrInW     strV(pszValue);
    CStrOutW    strOut(pszOutBuf, cchOutBuf);

    hr = SHLoadRegUIStringW(hkey, strV, strOut, strOut.BufSize());

    return hr;
}

HRESULT _LoadDllString(LPCWSTR pszSource, LPWSTR pszOutBuf, UINT cchOutBuf)
{
    HRESULT hr = E_FAIL;
    WCHAR * pszParseBuf = StrDupW(pszSource);
    if (pszParseBuf)
    {
        // see if this is a special string reference.
        // such strings take the form [path\]dllname.dll,-123
        // where 123 is the id of the string resource
        // note that reference by index is not permitted

        int nStrId = PathParseIconLocationW(pszParseBuf);
        nStrId *= -1;

        if (nStrId > 0)
        {
            LPWSTR      pszDllName;
            HINSTANCE   hinst;
            BOOL        fUsedMLLoadLibrary = FALSE;

            pszDllName = PathFindFileNameW(pszParseBuf);
            ASSERT(pszDllName >= pszParseBuf);

            // try loading the dll with MLLoadLibrary, but
            // only if an explicit path was not provided.
            // we assume an explicit path means that
            // the caller knows precisely which dll is needed
            // use MLLoadLibrary first, otherwise we'll miss
            // out chance to have plugUI behavior

            hinst = NULL;
            if (pszDllName == pszParseBuf)
            {
                if (StrStrI(pszDllName, L"LC.DLL"))
                {
                    // note: using HINST_THISDLL (below) is sort of a hack because that's
                    // techinically supposed to be the *parent* dll's hinstance...
                    // however we get called from lots of places and therefore
                    // don't know the parent dll, and the hinst for browseui.dll
                    // is good enough since all the hinst is really used for is to
                    // find the path to check if the install language is the
                    // currently selected UI language. this will usually be
                    // something like "\winnt\system32"

                    hinst = MLLoadLibraryW(pszDllName, HINST_THISDLL, ML_CROSSCODEPAGE);
                    fUsedMLLoadLibrary = (hinst != NULL);
                }
                else
                    hinst = LoadLibraryExW(pszDllName, NULL, LOAD_LIBRARY_AS_DATAFILE);
            }

            if (!hinst)
            {
                // our last chance to load something is if a full
                // path was provided... if there's a full path it
                // will start at the beginning of the pszParseBuf buffer

                if (pszDllName > pszParseBuf)
                {
                    // don't bother if the file isn't there
                    // failling in LoadLibrary is slow
                    if (PathFileExistsW(pszParseBuf))
                    {
                        hinst = LoadLibraryExW(pszParseBuf, NULL, LOAD_LIBRARY_AS_DATAFILE);
                    }
                }
            }

            if (hinst)
            {
                // dll found, so load the string
                if (LoadStringW(hinst, nStrId, pszOutBuf, cchOutBuf))
                {
                    hr = S_OK;
                }
                else
                {
                    TraceMsg(TF_WARNING,
                             "SHLoadRegUIString(): Failure loading string %d from module %ws for valid load request %ws.",
                             nStrId,
                             pszParseBuf,
                             pszSource);
                }

                if (fUsedMLLoadLibrary)
                {
                    MLFreeLibrary(hinst);
                }
                else
                {
                    FreeLibrary(hinst);
                }
            }
        }

        LocalFree(pszParseBuf);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

inline BOOL _CanCacheMUI()
{
    return TRUE;
}

// Note: pszSource and pszOutBuf may be the same buffer
LWSTDAPI SHLoadIndirectString(LPCWSTR pszSource, LPWSTR pszOutBuf, UINT cchOutBuf, void **ppvReserved)
{
    HRESULT hr = E_FAIL;

    RIP(IS_VALID_WRITE_BUFFER(pszOutBuf, WCHAR, cchOutBuf));
    RIP(!ppvReserved);

    if (pszSource[0] == L'@') // "@dllname,-id" or "@dllname,-id?lid,string"
    {
        LPWSTR pszResource = StrDupW(pszSource);
        if (pszResource)
        {
            LANGID lidUI =0;
            //  the LidString is there to support our old caching model.
            //  the new caching model doesnt require any work for the caller
            LPWSTR pszLidString = StrChrW(pszResource+1, L'?');
            DWORD cchResource = lstrlen(pszResource);

            //  used to use '@' as the second delimiter as well.
            //  but it has collisions with filesystem paths.
            if (!pszLidString)
                pszLidString = StrChrW(pszResource+1, L'@');
                
            if (pszLidString)
            {
                cchResource = (DWORD)(pszLidString - pszResource);
                // NULL terminate the dll,id just in case we need to actually load
                pszResource[cchResource] = 0;
            }

            DWORD cb = CbFromCchW(cchOutBuf);
            hr = SKGetValue(SHELLKEY_HKCULM_MUICACHE, NULL, pszResource, NULL, pszOutBuf, &cb);
            
            if (FAILED(hr))
            {
                WCHAR wszDllId[MAX_PATH + 1 + 6]; // path + comma + -65536
                SHExpandEnvironmentStringsW(pszResource+1, wszDllId, ARRAYSIZE(wszDllId));
                hr = _LoadDllString(wszDllId, pszOutBuf, cchOutBuf);

                // Might as well write the new string out so we don't have to load the DLL next time through
                // but we don't write cross codepage string on Win9x
                if (SUCCEEDED(hr) && _CanCacheMUI())
                {
                    SKSetValue(SHELLKEY_HKCULM_MUICACHE, NULL, pszResource, REG_SZ, pszOutBuf, CbFromCchW(lstrlenW(pszOutBuf)+1));
                }
            }
            LocalFree(pszResource);

        }
        else
            hr = E_OUTOFMEMORY;

        if (FAILED(hr))
        {
            if (cchOutBuf)
                pszOutBuf[0] = L'\0'; // can't hand out an "@shell32.dll,-525" string
        }
    }
    else
    {
        if (pszOutBuf != pszSource)
            StrCpyN(pszOutBuf, pszSource, cchOutBuf);

        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\shlwapi.inc ===
#
#  Common settings for shlwapi
#

C_DEFINES       = $(C_DEFINES) -DDBCS

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                new

# The Hydra header files are messed up - you can't include them with
# "#include <hydra\winsta.h>" because they assume they are in sdk\inc,
# so we will add sdk\inc\hydra to the INCLUDES so they sort of work.

INCLUDES=$(INCLUDES);$(TERMSRV_INC_PATH);$(NET_INC_PATH);$(INETCORE_INC_PATH)

MSC_WARNING_LEVEL=/W4


#
#
# Con-fusion
#
# we can't use 123 because rundll32 will activate it, rendering all CPLs manifested	
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=shlwapi.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\shared.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1995
//
// File: shared.c
//
// History:
//  06-07-95 BobDay     Created.
//
// This file contains a set of routines for the management of shared memory.
//
//---------------------------------------------------------------------------
#include "priv.h"
#pragma  hdrstop

//---------------------------------------------------------------------------
// SHAllocShared  - Allocates a handle (in a given process) to a copy of a
//                  memory block in this process.
// SHFreeShared   - Releases the handle (and the copy of the memory block)
//
// SHLockShared   - Maps a handle (from a given process) into a memory block
//                  in this process.  Has the option of transfering the handle
//                  to this process, thereby deleting it from the given process
// SHUnlockShared - Opposite of SHLockShared, unmaps the memory block
//---------------------------------------------------------------------------
HANDLE SHMapHandle(HANDLE hData, DWORD dwSource, DWORD dwDest, DWORD dwDesiredAccess, DWORD dwFlags)
{
    HANDLE hMap = NULL;
    HANDLE hSource;

    // Under certain (valid) circumstances it is possible for DDE to
    // use :0:pid as the shared memory handle, which we should ignore.
    if (hData != NULL)
    {

        if (dwSource == GetCurrentProcessId())
            hSource = GetCurrentProcess();
        else
            hSource = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwSource);

        if (hSource)
        {
            HANDLE hDest;
            if (dwDest == GetCurrentProcessId())
                hDest = GetCurrentProcess();
            else
                hDest = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwDest);

            if (hDest)
            {
                if (!DuplicateHandle(hSource, hData, hDest, &hMap,
                        dwDesiredAccess, FALSE, dwFlags | DUPLICATE_SAME_ACCESS))
                {
                    //  may change the value...
                    hMap = NULL;
                }

                CloseHandle(hDest);
            }

            CloseHandle(hSource);
        }
    }

    return hMap;
}

void _FillHeader(SHMAPHEADER *pmh, DWORD dwSize, DWORD dwSrcId, DWORD dwDstId, void *pvData)
{
    pmh->dwSize = dwSize;
    pmh->dwSig = MAPHEAD_SIG;
    pmh->dwSrcId = dwSrcId;
    pmh->dwDstId = dwDstId;
    
    if (pvData)
        memcpy((pmh + 1), pvData, dwSize);
}    

HANDLE _AllocShared(DWORD dwSize, DWORD dwSrcId, DWORD dwDstId, void *pvData, void **ppvLock)
{
    HANDLE hShared = NULL;
   //
    // Make a filemapping handle with this data in it.
    //
    HANDLE hData = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0,
                               dwSize + sizeof(SHMAPHEADER),NULL);
    if (hData)
    {
        SHMAPHEADER *pmh = MapViewOfFile(hData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

        if (pmh)
        {
            _FillHeader(pmh, dwSize, dwSrcId, dwDstId, pvData);
                
            hShared = SHMapHandle(hData, dwSrcId, dwDstId, FILE_MAP_ALL_ACCESS, DUPLICATE_SAME_ACCESS);

            if (hShared && ppvLock)
                *ppvLock = (pmh+1);
            else
                UnmapViewOfFile(pmh);
        }
    
        CloseHandle(hData);
    }

    return hShared;
}

#if SHAREDLOCAL
HANDLE _AllocLocal(DWORD dwSize, DWORD dwSrcId, void *pvData, void **ppvLock)
{
    SHMAPHEADER *pmh = LocalAlloc(LPTR, dwSize + sizeof(SHMAPHEADER));
    if (pmh)
    {
        _FillHeader(pmh, dwSize, dwSrcId, dwSrcId, pvData);
            
        if (ppvLock)
            *ppvLock = (pmh+1);
    }

    return pmh;
}


LWSTDAPI_(HANDLE) SHAllocSharedEx(DWORD dwSize, DWORD dwDstId, void *pvData, void **ppvLock)
{
    DWORD dwSrcId = GetCurrentProcessId();
 
    if (fAllowLocal && dwDstId == dwSrcId)
    {
        return _AllocLocal(dwSize, dwSrcId, pvData, ppvLock);
    }
    else
    {
        return _AllocShared(dwSize, dwSrcId, dwDstId, pvData, ppvLock);
    }
}       
#endif 

HANDLE SHAllocShared(void *pvData, DWORD dwSize, DWORD dwOtherProcId)
{
    return _AllocShared(dwSize, GetCurrentProcessId(), dwOtherProcId, pvData, NULL);
}

LWSTDAPI_(void *) SHLockSharedEx(HANDLE hData, DWORD dwOtherProcId, BOOL fWrite)
{
    HANDLE hMapped = SHMapHandle(hData, dwOtherProcId, GetCurrentProcessId(), FILE_MAP_ALL_ACCESS,0);

    if (hMapped)
    {
        //
        // Now map that new process specific handle and close it
        //
        DWORD dwAccess = fWrite ? FILE_MAP_WRITE | FILE_MAP_READ : FILE_MAP_READ;
        SHMAPHEADER *pmh = (SHMAPHEADER *) MapViewOfFile(hMapped, dwAccess, 0, 0, 0);

        CloseHandle(hMapped);

        if (pmh)
        {
            ASSERT(pmh->dwSig == MAPHEAD_SIG);
            return (void *)(pmh+1);
        }
    }
    return NULL;
}

LWSTDAPI_(void *) SHLockShared(HANDLE hData, DWORD dwOtherProcId)
{
    return SHLockSharedEx(hData, dwOtherProcId, TRUE);
}

LWSTDAPI_(BOOL) SHUnlockShared(void *pvData)
{
    SHMAPHEADER *pmh = ((SHMAPHEADER *)pvData) - 1;

    // Only assert on Whistler or higher, on downlevel machines SHUnlockShared would sometimes be called
    //   without this header (the return value from SHAllocShared, for example) and we would fault.
    ASSERT(pmh->dwSig == MAPHEAD_SIG);
    
    //
    // Now just unmap the view of the file
    //
    return UnmapViewOfFile(pmh);
}

BOOL SHFreeShared(HANDLE hData, DWORD dwOtherProcId)
{
    if (hData)
    {
        //
        // The below call closes the original handle in whatever process it
        // came from.
        //
        HANDLE hMapped = SHMapHandle(hData, dwOtherProcId, GetCurrentProcessId(),
                                FILE_MAP_ALL_ACCESS, DUPLICATE_CLOSE_SOURCE);

        //
        // Now free up the local handle
        //
        return CloseHandle(hMapped);
    }
    else
    {
        return TRUE; // vacuous success, closing a NULL handle
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\shellacl.c ===
#include "priv.h"
#pragma  hdrstop


//---------------------------------------------------------------------------
//  GetUserToken - Gets the current process's user token and returns
//                        it. It can later be free'd with LocalFree.
//
//  REARCHITECT (reinerf) - stolen from shell32\securent.c, we should consolidate
//                     the code somewhere and export it 
//---------------------------------------------------------------------------
PTOKEN_USER GetUserToken(HANDLE hUser)
{
    PTOKEN_USER pUser;
    DWORD dwSize = 64;
    HANDLE hToClose = NULL;

    if (hUser == NULL)
    {
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hUser);
        hToClose = hUser;
    }

    pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwSize);
    if (pUser)
    {
        DWORD dwNewSize;
        BOOL fOk = GetTokenInformation(hUser, TokenUser, pUser, dwSize, &dwNewSize);
        if (!fOk && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            LocalFree((HLOCAL)pUser);

            pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwNewSize);
            if (pUser)
            {
                fOk = GetTokenInformation(hUser, TokenUser, pUser, dwNewSize, &dwNewSize);
            }
        }
        if (!fOk)
        {
            LocalFree((HLOCAL)pUser);
            pUser = NULL;
        }
    }

    if (hToClose)
    {
        CloseHandle(hToClose);
    }

    return pUser;
}

//
// checks to see if the SHELL_USER_SID is all zeros (flag which means we should really use the users current sid)
//
__inline BOOL IsCurrentUserShellSID(PSHELL_USER_SID psusID)
{
    SID_IDENTIFIER_AUTHORITY sidNULL = {0};

    if ((psusID->dwUserGroupID == 0)    &&
        (psusID->dwUserID == 0)         &&
        memcmp(&psusID->sidAuthority, &sidNULL, sizeof(SID_IDENTIFIER_AUTHORITY)) == 0)
    {
        return TRUE;
    }

    return FALSE;
}


//
// Sets the specified ACE in the ACL to have dwAccessMask permissions.
//
__inline BOOL MakeACEInheritable(PACL pAcl, int iIndex, DWORD dwAccessMask)
{
    ACE_HEADER* pAceHeader;

    if (GetAce(pAcl, iIndex, (LPVOID*)&pAceHeader))
    {
        pAceHeader->AceFlags |= dwAccessMask;
        return TRUE;
    }

    return FALSE;
}


//
// Helper function to generate a SECURITY_DESCRIPTOR with the specified rights
// 
// OUT: psd - A pointer to a uninitialized SECURITY_DESCRIPTOR struct to be inited and filled in
//            in by this function
//
// IN:  PSHELL_USER_PERMISSION  - An array of PSHELL_USER_PERMISSION pointers that specify what access to grant
//      cUserPerm               - The count of PSHELL_USER_PERMISSION pointers in the array above
// 
//
STDAPI_(SECURITY_DESCRIPTOR*) GetShellSecurityDescriptor(PSHELL_USER_PERMISSION* apUserPerm, int cUserPerm)
{
    BOOL fSuccess = TRUE;   // assume success
    SECURITY_DESCRIPTOR* pSD = NULL;
    PSID* apSids = NULL;
    int cAces = cUserPerm;  // one ACE for each entry to start with
    int iAceIndex = 0;      // helps us keep count of how many ACE's we have added (count as we go)
    PTOKEN_USER pUserToken = NULL;
    DWORD cbSidLength = 0;
    DWORD cbAcl;
    PACL pAcl;
    int i;

    ASSERT(!IsBadReadPtr(apUserPerm, sizeof(PSHELL_USER_PERMISSION) * cUserPerm));

    // healthy parameter checking
    if (!apUserPerm || cUserPerm <= 0)
    {
        return NULL;
    }

    // first find out how many additional ACE's we are going to need
    // because of inheritance
    for (i = 0; i < cUserPerm; i++)
    {
        if (apUserPerm[i]->fInherit)
        {
            cAces++;
        }

        // also check to see if any of these are using susCurrentUser, in which case
        // we want to get the users token now so we have it already
        if ((pUserToken == NULL) && IsCurrentUserShellSID(&apUserPerm[i]->susID))
        {
            pUserToken = GetUserToken(NULL);
            if (!pUserToken)    
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "Failed to get the users token.  Error = %d", dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }
        }
    }

    // alloc the array to hold all the SID's
    apSids = (PSID*)LocalAlloc(LPTR, cUserPerm * sizeof(PSID));
    
    if (!apSids)
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "Failed allocate memory for %i SID's.  Error = %d", cUserPerm, dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    // initialize the SID's
    for (i = 0; i < cUserPerm; i++)
    {
        DWORD cbSid;

        // check for the special case of susCurrentUser
        if (IsCurrentUserShellSID(&apUserPerm[i]->susID))
        {
            ASSERT(pUserToken);
            apSids[i] = pUserToken->User.Sid;
        }
        else
        {
            SID_IDENTIFIER_AUTHORITY sidAuthority = apUserPerm[i]->susID.sidAuthority;

            if (!AllocateAndInitializeSid(&sidAuthority,
                                          (BYTE)(apUserPerm[i]->susID.dwUserID ? 2 : 1),    // if dwUserID is nonzero, then there are two SubAuthorities
                                          apUserPerm[i]->susID.dwUserGroupID,
                                          apUserPerm[i]->susID.dwUserID,
                                          0, 0, 0, 0, 0, 0, &apSids[i]))
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "AllocateAndInitializeSid: Failed to initialze SID.  Error = %d", cUserPerm, dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }
        }

        // add up all the SID lengths for an easy ACL size computation later...
        cbSid = GetLengthSid(apSids[i]);

        cbSidLength += cbSid;
        
        if (apUserPerm[i]->fInherit)
        {
            // if we have an inherit ACE as well, we need to add in the size of the SID again
            cbSidLength += cbSid;
        }

    }

    // calculate the size of the ACL we will be building (note: used sizeof(ACCESS_ALLOWED_ACE) b/c all ACE's are the same
    // size (excepting wacko object ACE's which we dont deal with). 
    //
    // this makes the size computation easy, since the size of the ACL will be the size of all the ACE's + the size of the SID's.
    cbAcl = SIZEOF(ACL) + (cAces * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) + cbSidLength;

    // HACKHACK (reinerf)
    //
    // we allocate enough space for the SECURITY_DESCRIPTOR and the ACL together and pass them both back to the
    // caller to free. we need to to this since the SECURITY_DESCRIPTOR contains a pointer to the ACL
    pSD = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR, SIZEOF(SECURITY_DESCRIPTOR) + cbAcl);

    if (!pSD)
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "Failed to allocate space for the SECURITY_DESCRIPTOR and the ACL.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    // set the address of the ACL to right after the SECURITY_DESCRIPTOR in the 
    // block of memory we just allocated
    pAcl = (PACL)(pSD + 1);
    
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION))
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "InitializeAcl: Failed to init the ACL.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    for (i = 0; i < cUserPerm; i++)
    {
        BOOL bRet;

        // add the ACE's to the ACL
        if (apUserPerm[i]->dwAccessType == ACCESS_ALLOWED_ACE_TYPE)
        {
            bRet = AddAccessAllowedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwAccessMask, apSids[i]);
        }
        else
        {
            bRet = AddAccessDeniedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwAccessMask, apSids[i]);
        }

        if (!bRet)
        {
            DWORD dwLastError = GetLastError();
            TraceMsg(TF_WARNING, "AddAccessAllowed/DeniedAce: Failed to add SID.  Error = %d", dwLastError);
            fSuccess = FALSE;
            goto cleanup;
        }

        // sucessfully added an ace
        iAceIndex++;

        ASSERT(iAceIndex <= cAces);

        // if its an inherit ACL, also add another ACE for the inheritance part
        if (apUserPerm[i]->fInherit)
        {
            // add the ACE's to the ACL
            if (apUserPerm[i]->dwAccessType == ACCESS_ALLOWED_ACE_TYPE)
            {
                bRet = AddAccessAllowedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwInheritAccessMask, apSids[i]);
            }
            else
            {
                bRet = AddAccessDeniedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwInheritAccessMask, apSids[i]);
            }

            if (!bRet)
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "AddAccessAllowed/DeniedAce: Failed to add SID.  Error = %d", dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }

            if (!MakeACEInheritable(pAcl, iAceIndex, apUserPerm[i]->dwInheritMask))
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "MakeACEInheritable: Failed to add SID.  Error = %d", dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }

            // sucessfully added another ace
            iAceIndex++;
 
            ASSERT(iAceIndex <= cAces);
        }
    }

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "InitializeSecurityDescriptor: Failed to init the descriptor.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    if (!SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE))
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "SetSecurityDescriptorDacl: Failed to set the DACL.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

cleanup:
    if (apSids)
    {
        for (i = 0; i < cUserPerm; i++)
        {
            if (apSids[i])
            {
                // if this is one of the ones we allocated (eg not the users sid), free it
                if (!pUserToken || (apSids[i] != pUserToken->User.Sid))
                {
                    FreeSid(apSids[i]);
                }
            }
        }

        LocalFree(apSids);
    }

    if (pUserToken)
        LocalFree(pUserToken);

    if (!fSuccess && pSD)
    {
        LocalFree(pSD);
        pSD = NULL;
    }

    return pSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\stream.h ===
#ifndef _STREAM_H_
#define _STREAM_H_

class CMemStream : public IStream {
public:
        STDMETHOD (QueryInterface)(REFIID riid, void **ppvObj);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        STDMETHOD (Read)(void *pv, ULONG cb, ULONG *pcbRead);
        STDMETHOD (Write)(void const *pv, ULONG cb, ULONG *pcbWritten);
        STDMETHOD (Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
        STDMETHOD (SetSize)(ULARGE_INTEGER libNewSize);
        STDMETHOD (CopyTo)(IStream *, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
        STDMETHOD (Commit)(DWORD);
        STDMETHOD (Revert)();
        STDMETHOD (LockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
        STDMETHOD (UnlockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
        STDMETHOD (Stat)(STATSTG *, DWORD);
        STDMETHOD (Clone)(IStream **);

        LPBYTE  GrowBuffer(ULONG);
private:
        BOOL    WriteToReg();

public:
    UINT        cRef;           // Reference count
    LPBYTE      pBuf;           // Buffer pointer
    UINT        cbAlloc;        // The allocated size of the buffer
    UINT        cbData;         // The used size of the buffer
    UINT        iSeek;          // Where we are in the buffer.
    DWORD       grfMode;        // mode used at creation (for Stat, and to enforce)
    // Extra variables that are used for loading and saving to ini files.
    HKEY        hkey;           // Key for writing to registry.
    BITBOOL     fDontCloseKey;  // if caller passes in a key
    TCHAR       szValue[1];     // for reg stream
};

#endif /* _STREAM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\strmwrap.cpp ===
#include "priv.h"


// Stub - CStreamWrap moved to shdocvw

STDAPI SHCreateStreamWrapper(IStream *aStreams[], UINT cStreams, DWORD grfMode, IStream **ppstm)
{
    *ppstm = NULL;

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\shperf.c ===
#include "priv.h"
#include "shlwapip.h"
#include "mshtmdbg.h"

#define STOPWATCH_MAX_DESC                  256
#define STOPWATCH_MAX_TITLE                 192
#define STOPWATCH_MAX_BUF                  1024

// Perftags defines and typedefs
typedef PERFTAG (WINAPI *PFN_PERFREGISTER)(char *, char *, char *);
typedef void (WINAPIV *PFN_PERFLOGFN)(PERFTAG, void *, const char *, ...);
typedef char *(WINAPI *PFN_DECODEMESSAGE)(INT);

// IceCAP function typedefs
typedef void (WINAPI *PFN_ICAP)(void);

// MemWatch function typedefs
typedef HRESULT (WINAPI *PFN_MWCONFIG)(DWORD, DWORD, DWORD);
typedef HRESULT (WINAPI *PFN_MWBEGIN)(BOOL, BOOL);
typedef HRESULT (WINAPI *PFN_MWSNAPSHOT)();
typedef HRESULT (WINAPI *PFN_MWEND)(char *);
typedef HRESULT (WINAPI *PFN_MWMARK)(char *);
typedef HRESULT (WINAPI *PFN_MWEXIT)();

#ifndef NO_ETW_TRACING
#include <wmistr.h>
#include <evntrace.h>

typedef TRACEHANDLE (WINAPI *PFN_GTLOGHANDLE)(PVOID);
typedef ULONG       (WINAPI *PFN_REGTRACE)(WMIDPREQUEST,
                                           PVOID,
                                           LPCGUID,
                                           ULONG,
                                           PTRACE_GUID_REGISTRATION,
                                           LPCTSTR,
                                           LPCTSTR,
                                           PTRACEHANDLE
                                           );
typedef ULONG       (WINAPI *PFN_UNREGTRACE)(TRACEHANDLE);
typedef ULONG       (WINAPI *PFN_TRACE)(TRACEHANDLE, PEVENT_TRACE_HEADER);
#endif

// Stopwatch memory buffer
typedef struct _STOPWATCH
{
    DWORD dwId;     // Node identifier
    DWORD dwTID;    // Thread ID;
    DWORD dwType;   // Node type - start, lap, stop, emtpy
    DWORD dwCount;  // Tick count
    DWORD dwFlags;  // Node flags - memlog, debugout
    TCHAR szDesc[STOPWATCH_MAX_DESC];
} STOPWATCH, *PSTOPWATCH;

// Global stopwatch info data
typedef struct _STOPWATCHINFO
{
    DWORD dwStopWatchMode;
    DWORD dwStopWatchProfile;
    DWORD dwStopWatchListIndex;
    DWORD dwStopWatchListMax;
    DWORD dwStopWatchPaintInterval;

    // SPMODE_MSGTRACE data
    DWORD dwStopWatchMaxDispatchTime;
    DWORD dwStopWatchMaxMsgTime;
    DWORD dwStopWatchMsgInterval;
    DWORD dwcStopWatchOverflow;
    DWORD dwStopWatchLastLocation;
    DWORD dwStopWatchTraceMsg;
    DWORD dwStopWatchTraceMsgCnt;
    DWORD *pdwStopWatchMsgTime;

    // SPMODE_MEMWATCH config data and function pointers
    DWORD dwMemWatchPages;
    DWORD dwMemWatchTime;
    DWORD dwMemWatchFlags;
    BOOL fMemWatchConfig;
    HMODULE hModMemWatch;
    PFN_MWCONFIG pfnMemWatchConfig;
    PFN_MWBEGIN pfnMemWatchBegin;
    PFN_MWSNAPSHOT pfnMemWatchSnapShot;
    PFN_MWEND pfnMemWatchEnd;
    PFN_MWMARK pfnMemWatchMark;
    PFN_MWEXIT pfnMemWatchExit;

    // Perftag data and function pointers
    PERFTAG tagStopWatchStart;
    PERFTAG tagStopWatchStop;
    PERFTAG tagStopWatchLap;
    PFN_PERFREGISTER pfnPerfRegister;
    PFN_PERFLOGFN pfnPerfLogFn;
    PFN_DECODEMESSAGE pfnDecodeMessage;

#ifndef NO_ETW_TRACING
    DWORD dwEventTraceMode;
    PFN_GTLOGHANDLE pfnGetLogHandle;
    PFN_REGTRACE    pfnRegisterTraceGuids;
    PFN_UNREGTRACE  pfnUnRegisterTraceGuids;
    PFN_TRACE       pfnTraceEvent;
#endif

    LPTSTR pszClassNames;

    PSTOPWATCH pStopWatchList;

    // IceCAP data and function pointers
    HMODULE hModICAP;
    PFN_ICAP pfnStartCAPAll;
    PFN_ICAP pfnStopCAPAll;

    HANDLE hMapHtmPerfCtl;
    HTMPERFCTL *pHtmPerfCtl;    
} STOPWATCHINFO, *PSTOPWATCHINFO;

#ifndef NO_ETW_TRACING
#define c_szBrowserResourceName TEXT("Browse")

// Used to turn on/off event tracing.  Setting the registry key enable event
// tracing use, but doesn't turn it on.
// {5576F62E-4142-45a8-9516-262A510C13F0}
const GUID c_BrowserControlGuid = {
    0x5576f62e,
    0x4142,
    0x45a8,
    0x95, 0x16, 0x26, 0x2a, 0x51, 0xc, 0x13, 0xf0};

// Maps to the structure sent to ETW.  ETW definition in
// \nt\sdktools\trace\tracedmp\mofdata.guid
// {2B992163-736F-4a68-9153-95BC5F34D884}
const GUID c_BrowserTraceGuid = {
    0x2b992163,
    0x736f,
    0x4a68,
    0x91, 0x53, 0x95, 0xbc, 0x5f, 0x34, 0xd8, 0x84};

TRACE_GUID_REGISTRATION g_BrowserTraceGuidReg[] =
{
    { (LPGUID)&c_BrowserTraceGuid,
      NULL
    }
};

//
//  The mof fields point to the following data.
//    MOF_FIELD            MofData[0]; // Holds ptr to Url Name
//
typedef struct _ETW_BROWSER_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             MofData[1];
} ETW_BROWSER_EVENT, *PETW_BROWSER_EVENT;


static TRACEHANDLE s_hEtwBrowserRegHandle;
static TRACEHANDLE s_hEtwBrowserLogHandle;

// For SHInterlockedCompareExchange
static BOOL  s_fTRUE = TRUE;
static PVOID s_pvEtwBrowserTraceOnFlag = NULL;
static PVOID s_pvEtwBrowserRegistered = NULL;
static PVOID s_pvEtwBrowserRegistering = NULL;
#endif

PSTOPWATCHINFO g_pswi = NULL;

const TCHAR c_szDefClassNames[] = {STOPWATCH_DEFAULT_CLASSNAMES};

void StopWatch_SignalEvent();

//===========================================================================================
// INTERNAL FUNCTIONS
//===========================================================================================

//===========================================================================================
//===========================================================================================

void PerfCtlCallback(DWORD dwArg1, void * pvArg2)
{
    const TCHAR c_szFmtBrowserStop[] = TEXT("Browser Frame Stop (%s)");
    TCHAR szTitle[STOPWATCH_MAX_TITLE];
    TCHAR szText[STOPWATCH_MAX_TITLE + ARRAYSIZE(c_szFmtBrowserStop) + 1];
    LPTSTR ptr = szTitle;
#ifndef UNICODE    
    INT rc;
#endif
    if(g_pswi->dwStopWatchMode & SPMODE_BROWSER)  // Temp hack to deal with ansi,unicode.  This code will go away when we impl hook in mshtml.
    {
//        GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)-1);

#ifndef UNICODE    
        rc = WideCharToMultiByte(CP_ACP, 0, pvArg2, -1, szTitle, STOPWATCH_MAX_TITLE - 1, NULL, NULL);

        if(!rc)
            StrCpyN(szTitle, "ERROR converting wide to multi", ARRAYSIZE(szTitle) - 1);
#else
        ptr = (LPTSTR) pvArg2;
#endif
        wnsprintf(szText, ARRAYSIZE(szText), c_szFmtBrowserStop, ptr);
        StopWatch_Stop(SWID_BROWSER_FRAME, szText, SPMODE_BROWSER | SPMODE_DEBUGOUT);
        if((g_pswi->dwStopWatchMode & (SPMODE_EVENT | SPMODE_BROWSER)) == (SPMODE_EVENT | SPMODE_BROWSER))
        {
            StopWatch_SignalEvent();
        }
    }
}

#ifndef NO_ETW_TRACING
/*++
  Routine Name:
    ulEtwBrowserControlCallback()
 
  Routine Description:
    This is the function we provide to the ETW subsystem as a callback, it is used to 
    start and stop the trace events.
 
  Arguments:
    IN     WMIDPREQUESTCODE  RequestCode      : The function to provide (enable/disable)
    IN     PVOID             Context          : Not used by us.
    IN OUT ULONG            *InOutBufferSize  : The Buffersize
    IN OUT PVOID             Buffer           : The buffer to use for the events
 
  Returns ERROR_SUCCESS on success, or an error code. 
 
--*/
ULONG
ulEtwBrowserControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID pvContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID pvBuffer
    )
{
    ULONG Status;

    if (!s_pvEtwBrowserRegistered) {
        // Registration hasn't happened yet.
        return ERROR_GEN_FAILURE;
    }
    
    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
#if STOPWATCH_DEBUG
            OutputDebugString("shperf.c:ulEtwBrowserControlCallback enable\n");
#endif
            ASSERT(g_pswi->pfnGetLogHandle);
            s_hEtwBrowserLogHandle = g_pswi->pfnGetLogHandle( pvBuffer );
#if STOPWATCH_DEBUG
            if (s_hEtwBrowserLogHandle == INVALID_HANDLE_VALUE) {
                TCHAR szDbg[256];
                wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1,
                          "ulEtwBrowserControlCallback GLE=%u\n", GetLastError());
                OutputDebugString(szDbg);
            }
#endif
            SHInterlockedCompareExchange(&s_pvEtwBrowserTraceOnFlag, &s_fTRUE, NULL);
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
#if STOPWATCH_DEBUG
            OutputDebugString("shperf.c:ulEtwBrowserControlCallback disable\n");
#endif
            SHInterlockedCompareExchange(&s_pvEtwBrowserTraceOnFlag, NULL, &s_fTRUE);
            s_hEtwBrowserLogHandle = 0;
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = 0;
    return(Status);
}

/*++
  Routine Name:
    RegisterTracing()
 
  Routine Description:
    Registers us to the ETW tools
 
  Arguments:
 
  Returns ERROR_SUCCESS on success of all registrations.
--*/
ULONG RegisterTracing()
{
    ULONG Status = ERROR_SUCCESS;
    TCHAR szImagePath[MAX_PATH];

    Status = GetModuleFileName(NULL, szImagePath, sizeof(szImagePath)/sizeof(TCHAR));
    if (Status == 0) {
        Status = ERROR_FILE_NOT_FOUND;
    }
    else {
        if (g_pswi->dwEventTraceMode & SPTRACE_BROWSER) {
            PVOID fRegOn;

            // If browser tracing is not registered, register it, preventing
            // anybody else from trying to do this at the same time.

            fRegOn = SHInterlockedCompareExchange(&s_pvEtwBrowserRegistering, &s_fTRUE, NULL);
            if (!fRegOn) {
                if (!s_pvEtwBrowserRegistered) {
                    ASSERT(g_pswi->pfnRegisterTraceGuids);
                    Status = g_pswi->pfnRegisterTraceGuids(
                        ulEtwBrowserControlCallback,
                        NULL,                 
                        (LPGUID)&c_BrowserControlGuid,
                        1,
                        g_BrowserTraceGuidReg,
                        szImagePath,
                        c_szBrowserResourceName,
                        &s_hEtwBrowserRegHandle);
                    
                    if (Status == ERROR_SUCCESS) {
                        SHInterlockedCompareExchange(&s_pvEtwBrowserRegistered, &s_fTRUE, NULL);
                    }
#if STOPWATCH_DEBUG
                    else {
                        OutputDebugString("shperf.c:Registration of event tracing guids failed.\n");
                    }
#endif
                }
                SHInterlockedCompareExchange(&s_pvEtwBrowserRegistering, NULL, &s_fTRUE);
            }
        }
    }
    return Status;
}

/*++
  Routine Name:
    UnRegisterTracing()
 
  Routine Description:
    Deregisters us from the ETW tools
 
  Arguments:
 
  Returns ERROR_SUCCESS on success. a Winerror otherwise.
 
--*/
ULONG UnRegisterTracing()
{
    ULONG Status = ERROR_SUCCESS;

    // If browser tracing is registered, unregister it.
    if (s_pvEtwBrowserRegistered) {
        SHInterlockedCompareExchange(&s_pvEtwBrowserTraceOnFlag, NULL, &s_fTRUE);
        if(g_pswi && g_pswi->pfnUnRegisterTraceGuids) {
            Status = g_pswi->pfnUnRegisterTraceGuids(s_hEtwBrowserRegHandle);
        }
        if (Status == ERROR_SUCCESS) {
            SHInterlockedCompareExchange(&s_pvEtwBrowserRegistered, NULL, &s_fTRUE);
        }
#if STOPWATCH_DEBUG
        else {
            OutputDebugString("shperf.c:UnRegistration of event tracing guids failed.\n");
        }
#endif
    }
    
    return Status;
}

/*++
  Routine Name:  
    EventTraceHandler()
 
  Routine Description:
    If tracing is turned on, this sends the event to the WMI subsystem.
 
  Arguments:
    UCHAR            EventType      : Kind of trace event
    PVOID            Data           : Data associated with event
--*/
void WINAPI EventTraceHandler(UCHAR uchEventType, PVOID pvData)
{
    if ((g_pswi->dwEventTraceMode & SPTRACE_BROWSER)) 
    {
        if (s_pvEtwBrowserTraceOnFlag)
        {
            ETW_BROWSER_EVENT EtwEvent;
            ULONG Status;
            LPWSTR wszUrl = pvData;

            //
            // Record data.
            //
            ZeroMemory(&EtwEvent, sizeof(EtwEvent));
            EtwEvent.Header.Size  = sizeof(ETW_BROWSER_EVENT);
            EtwEvent.Header.Flags = (WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR);
            EtwEvent.Header.Class.Type = uchEventType;
            EtwEvent.Header.Guid  = c_BrowserTraceGuid;

            EtwEvent.MofData[0].DataPtr = (ULONG64)wszUrl;
            EtwEvent.MofData[0].Length  = (wszUrl
                                           ? (wcslen(wszUrl)+1)*sizeof(WCHAR)
                                           : 0);

            ASSERT(g_pswi->pfnTraceEvent);
            Status = g_pswi->pfnTraceEvent(
                s_hEtwBrowserLogHandle,
                (PEVENT_TRACE_HEADER) &EtwEvent);
        
#if STOPWATCH_DEBUG
            if (Status != ERROR_SUCCESS) {
                TCHAR szDbg[256];
                wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1,
                          "shperf.c:Call to trace event failed %I64x GLE=%u\n",
                          s_hEtwBrowserLogHandle, Status);
                OutputDebugString(szDbg);
            }
#endif
        }

        // Signal event when full web page is downloaded.
        if ((uchEventType == EVENT_TRACE_TYPE_BROWSE_LOADEDPARSED) &&
            (g_pswi->dwStopWatchMode & SPMODE_EVENT)) {
            StopWatch_SignalEvent();
        }
    }
}

// Called through a pointer in the shared memory map section.
void PerfCtlEvntCallback(DWORD dwArg1, void * pvArg2)
{
    EventTraceHandler((UCHAR)dwArg1, pvArg2);
}
#endif

//===========================================================================================
//===========================================================================================
HRESULT SetPerfCtl(DWORD dwFlags)
{
    if (dwFlags == HTMPF_CALLBACK_ONLOAD ||
        dwFlags == HTMPF_CALLBACK_ONEVENT)
    {
        char achName[sizeof(HTMPERFCTL_NAME) + 8 + 1];
        StringCchPrintfA(achName, ARRAYSIZE(achName), "%s%08lX", HTMPERFCTL_NAME, GetCurrentProcessId());

        if (g_pswi->hMapHtmPerfCtl == NULL)
            g_pswi->hMapHtmPerfCtl = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, achName);
        if (g_pswi->hMapHtmPerfCtl == NULL)
            return(E_FAIL);
        if (g_pswi->pHtmPerfCtl == NULL)
            g_pswi->pHtmPerfCtl = (HTMPERFCTL *)MapViewOfFile(g_pswi->hMapHtmPerfCtl, FILE_MAP_WRITE, 0, 0, 0);
        if (g_pswi->pHtmPerfCtl == NULL)
            return(E_FAIL);

        g_pswi->pHtmPerfCtl->dwSize  = sizeof(HTMPERFCTL);
        g_pswi->pHtmPerfCtl->dwFlags = dwFlags;
#ifndef NO_ETW_TRACING
        if (dwFlags == HTMPF_CALLBACK_ONEVENT) {
            RegisterTracing();
            // Used by clients, like mshtml, to log events.
            g_pswi->pHtmPerfCtl->pfnCall = PerfCtlEvntCallback;
        }
        else
#endif
            g_pswi->pHtmPerfCtl->pfnCall = PerfCtlCallback;

        g_pswi->pHtmPerfCtl->pvHost  = NULL;
    }

    return S_OK;
}


//===========================================================================================
//===========================================================================================
void StopWatch_SignalEvent()
{
    static HANDLE hEvent = NULL;

    if(hEvent == NULL)
    {
        TCHAR szEventName[256];
        wnsprintf(szEventName, ARRAYSIZE(szEventName), TEXT("%s%x"), TEXT("STOPWATCH_STOP_EVENT"), GetCurrentProcessId());
        hEvent = CreateEvent((LPSECURITY_ATTRIBUTES)NULL, FALSE, FALSE, szEventName);
    }
    if(hEvent != NULL)
        SetEvent(hEvent);
}

//===========================================================================================
//===========================================================================================
HRESULT DoMemWatchConfig(VOID)
{
    HRESULT hr = ERROR_SUCCESS;

    if(g_pswi->hModMemWatch == NULL)
    {
        if((g_pswi->hModMemWatch = LoadLibrary("mwshelp.dll")) != NULL)
        {
            g_pswi->pfnMemWatchConfig = (PFN_MWCONFIG) GetProcAddress(g_pswi->hModMemWatch, "MemWatchConfigure");
            g_pswi->pfnMemWatchBegin = (PFN_MWBEGIN) GetProcAddress(g_pswi->hModMemWatch, "MemWatchBegin");
            g_pswi->pfnMemWatchSnapShot = (PFN_MWSNAPSHOT) GetProcAddress(g_pswi->hModMemWatch, "MemWatchSnapShot");
            g_pswi->pfnMemWatchEnd = (PFN_MWEND) GetProcAddress(g_pswi->hModMemWatch, "MemWatchEnd");
            g_pswi->pfnMemWatchMark = (PFN_MWMARK) GetProcAddress(g_pswi->hModMemWatch, "MemWatchMark");
            g_pswi->pfnMemWatchExit = (PFN_MWEXIT) GetProcAddress(g_pswi->hModMemWatch, "MemWatchExit");
        
            if(g_pswi->pfnMemWatchConfig != NULL)
            {
                hr = g_pswi->pfnMemWatchConfig(g_pswi->dwMemWatchPages, g_pswi->dwMemWatchTime, g_pswi->dwMemWatchFlags);
                if(FAILED(hr))
                    g_pswi->dwStopWatchMode &= ~SPMODE_MEMWATCH;
                else
                    g_pswi->fMemWatchConfig = TRUE;
            }
        }
        else
        {
            g_pswi->hModMemWatch = (HMODULE)1;
        }
    }

    return(hr);
}

//===========================================================================================
// Function: VOID InitStopWatchMode(VOID)
//
// If HKLM\software\microsoft\windows\currentversion\explorer\performance\mode key value
// is set to one of the values described below, the stopwatch mode will be enabled by
// setting the global variable g_pswi->dwStopWatchMode.
//
// SPMODE_SHELL    - Allows the flushing of stopwatch timings to a log file
// SPMODE_DEBUGOUT  - Display timing via OutputDebugString. Only timings marked with SPMODE_DEBUGOUT
//                    through the StopWatch_* calls will be displayed.
// SPMODE_TEST      - Used to display test output.  This allow another level of SPMODE_DEBUGOUT
//                    like output.
//
// If HKLM\software\microsoft\windows\currentversion\explorer\performance\nodes key value
// is set, the size of the timing array will be set to this value.  The default is 100 nodes.
//===========================================================================================
#define REGKEY_PERFMODE        REGSTR_PATH_EXPLORER TEXT("\\Performance")

VOID InitStopWatchMode(VOID)
{
    HKEY hkeyPerfMode;
    DWORD dwVal = 0;
    DWORD cbBuffer;
    DWORD dwType;
    TCHAR szClassNames[256];
#if STOPWATCH_DEBUG
    TCHAR szDbg[256];
#endif

    if(NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_PERFMODE, 0L, MAXIMUM_ALLOWED, &hkeyPerfMode))
    {
        cbBuffer = SIZEOF(dwVal);
        if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("Mode"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
        {
            if((dwVal & SPMODES) == 0)    // Low word is mode, high word is paint timer interval
                dwVal |= SPMODE_SHELL;
                
            if((g_pswi = (PSTOPWATCHINFO)LocalAlloc(LPTR, SIZEOF(STOPWATCHINFO))) == NULL)
                dwVal = 0;
        }

        if(dwVal != 0)
        {
            g_pswi->dwStopWatchMode = dwVal;
            g_pswi->dwStopWatchListMax = STOPWATCH_MAX_NODES;
            g_pswi->dwStopWatchPaintInterval = STOPWATCH_DEFAULT_PAINT_INTERVAL;
            g_pswi->dwStopWatchMaxDispatchTime = STOPWATCH_DEFAULT_MAX_DISPATCH_TIME;
            g_pswi->dwStopWatchMaxMsgTime = STOPWATCH_DEFAULT_MAX_MSG_TIME;
            g_pswi->dwStopWatchMsgInterval = STOPWATCH_DEFAULT_MAX_MSG_INTERVAL;
            g_pswi->pszClassNames = (LPTSTR)c_szDefClassNames;
            g_pswi->dwMemWatchPages = MEMWATCH_DEFAULT_PAGES;
            g_pswi->dwMemWatchTime = MEMWATCH_DEFAULT_TIME;
            g_pswi->dwMemWatchFlags = MEMWATCH_DEFAULT_FLAGS;
#ifndef NO_ETW_TRACING
            g_pswi->dwEventTraceMode = 0;
#endif
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("Profile"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwStopWatchProfile = dwVal;
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("Nodes"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwStopWatchListMax = dwVal;
            cbBuffer = SIZEOF(szClassNames);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("ClassNames"), NULL, &dwType, (LPBYTE)&szClassNames, &cbBuffer))
            {
                if((g_pswi->pszClassNames = (LPTSTR)LocalAlloc(LPTR, SIZEOF(LPTSTR) * cbBuffer)) != NULL)
                    CopyMemory(g_pswi->pszClassNames, szClassNames, SIZEOF(LPTSTR) * cbBuffer);
            }
            cbBuffer = SIZEOF(dwVal);
            // begin - Remove this after StopWatch users convert to using PaintInterval key
            g_pswi->dwStopWatchPaintInterval = HIWORD(g_pswi->dwStopWatchMode) ?HIWORD(g_pswi->dwStopWatchMode) :STOPWATCH_DEFAULT_PAINT_INTERVAL;    // Use high word of mode reg key value for interval
            // end - Remove this after StopWatch users convert to using PaintInterval key
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("PaintInterval"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwStopWatchPaintInterval = dwVal;

            // Get MemWatch data
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MWPages"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwMemWatchPages = dwVal;
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MWTime"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwMemWatchTime = dwVal;
            cbBuffer = SIZEOF(dwVal);
            if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MWFlags"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                g_pswi->dwMemWatchFlags = dwVal;

#ifndef NO_ETW_TRACING
            if (g_pswi->dwStopWatchMode & SPMODE_EVENTTRACE) {
                // Load the ETW operations individually to make sure the system
                // this proc is running on supports them.
                HMODULE hMod;
                if ((hMod = LoadLibrary("advapi32.dll")) != NULL) {
                    g_pswi->pfnGetLogHandle = (PFN_GTLOGHANDLE) GetProcAddress(hMod, "GetTraceLoggerHandle");
                    g_pswi->pfnUnRegisterTraceGuids = (PFN_UNREGTRACE) GetProcAddress(hMod, "UnregisterTraceGuids");
                    g_pswi->pfnTraceEvent = (PFN_TRACE) GetProcAddress(hMod, "TraceEvent");
                    g_pswi->pfnRegisterTraceGuids =
#if defined(UNICODE) || defined(_UNICODE)
                        (PFN_REGTRACE) GetProcAddress(hMod, "RegisterTraceGuidsW");
#else
                        (PFN_REGTRACE) GetProcAddress(hMod, "RegisterTraceGuidsA");
#endif
                }
                else {
                    g_pswi->pfnGetLogHandle = NULL;
                    g_pswi->pfnUnRegisterTraceGuids = NULL;
                    g_pswi->pfnTraceEvent = NULL;
                    g_pswi->pfnRegisterTraceGuids = NULL;
                }

                if (!hMod                            ||
                    !g_pswi->pfnGetLogHandle         ||
                    !g_pswi->pfnUnRegisterTraceGuids ||
                    !g_pswi->pfnTraceEvent           ||
                    !g_pswi->pfnRegisterTraceGuids) {
                    // Event trace calls will never be made now.
#if STOPWATCH_DEBUG
                    wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, "~SPMODE_EVENTTRACE load procs from advapi32.dll failed.\n");
                    OutputDebugString(szDbg);
#endif
                    g_pswi->dwStopWatchMode &= ~SPMODE_EVENTTRACE;
                }
                else {
                    // Set type of event tracing before setting up the call back.
                    cbBuffer = SIZEOF(dwVal);
                    if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("EventTrace"), NULL,
                                                   &dwType, (LPBYTE)&dwVal, &cbBuffer)) {
                        g_pswi->dwEventTraceMode = dwVal;
                        // You can only have one callback, so don't allow browser
                        // stopwatch and browser event tracing.
                        g_pswi->dwStopWatchMode &= ~SPMODE_BROWSER;
                    }
                }
            }
#endif

            if(g_pswi->dwStopWatchMode & SPMODES)
            {
#ifndef NO_ETW_TRACING
                SetPerfCtl(g_pswi->dwStopWatchMode & SPMODE_EVENTTRACE
                           // See mshtmdbg.h
                           ? HTMPF_CALLBACK_ONEVENT
                           : HTMPF_CALLBACK_ONLOAD);
#else
                SetPerfCtl(HTMPF_CALLBACK_ONLOAD);
#endif
            }
            
            if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
            {
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MaxDispatchTime"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchMaxDispatchTime = dwVal;
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MaxMsgTime"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchMaxMsgTime = dwVal;
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("MsgInterval"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchMsgInterval = dwVal;
                cbBuffer = SIZEOF(dwVal);
                if(NO_ERROR == RegQueryValueEx(hkeyPerfMode, TEXT("TraceMsg"), NULL, &dwType, (LPBYTE)&dwVal, &cbBuffer))
                    g_pswi->dwStopWatchTraceMsg = dwVal;

                if((g_pswi->pdwStopWatchMsgTime = (DWORD *)LocalAlloc(LPTR, sizeof(DWORD) * (g_pswi->dwStopWatchMaxMsgTime / g_pswi->dwStopWatchMsgInterval))) == NULL)
                    g_pswi->dwStopWatchMode &= ~SPMODE_MSGTRACE;
            }

            if((g_pswi->pStopWatchList = (PSTOPWATCH)LocalAlloc(LPTR, sizeof(STOPWATCH)* g_pswi->dwStopWatchListMax)) == NULL) {
                g_pswi->dwStopWatchMode = 0;
#ifndef NO_ETW_TRACING
                // Just in case this didn't fail too.
                UnRegisterTracing();
#endif
            }
            if(g_pswi->dwStopWatchMode & SPMODE_PERFTAGS)
            {
                HMODULE hMod;
                if((hMod = LoadLibrary("mshtmdbg.dll")) != NULL)
                {
                    g_pswi->pfnPerfRegister = (PFN_PERFREGISTER) GetProcAddress(hMod, "DbgExPerfRegister");
                    g_pswi->pfnPerfLogFn = (PFN_PERFLOGFN) GetProcAddress(hMod, "DbgExPerfLogFn");
                    g_pswi->pfnDecodeMessage = (PFN_DECODEMESSAGE) GetProcAddress(hMod, "DbgExDecodeMessage");
                }
                else
                {
#if STOPWATCH_DEBUG
                    wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, "~SPMODE_PERFTAGS loadlib mshtmdbg.dll failed GLE=0x%x\n", GetLastError());
                    OutputDebugString(szDbg);
#endif
                    g_pswi->dwStopWatchMode &= ~SPMODE_PERFTAGS;
                }
                
                if(g_pswi->pfnPerfRegister != NULL)
                {
                    g_pswi->tagStopWatchStart = g_pswi->pfnPerfRegister("tagStopWatchStart", "StopWatchStart", "SHLWAPI StopWatch start time");
                    g_pswi->tagStopWatchStop = g_pswi->pfnPerfRegister("tagStopWatchStop", "StopWatchStop", "SHLWAPI StopWatch stop time");
                    g_pswi->tagStopWatchLap = g_pswi->pfnPerfRegister("tagStopWatchLap", "StopWatchLap", "SHLWAPI StopWatch lap time");
                }
            }
            
#ifdef STOPWATCH_DEBUG
            // Display option values
            {
                LPCTSTR ptr;
                
                wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, TEXT("StopWatch Mode=0x%x Profile=0x%x Nodes=%d PaintInterval=%d MemBuf=%d bytes\n"),
                    g_pswi->dwStopWatchMode, g_pswi->dwStopWatchProfile, g_pswi->dwStopWatchListMax, g_pswi->dwStopWatchPaintInterval, g_pswi->dwStopWatchListMax * sizeof(STOPWATCH));
                OutputDebugString(szDbg);

                OutputDebugString(TEXT("Stopwatch ClassNames="));
                ptr = g_pswi->pszClassNames;
                while(*ptr)
                {
                    wnsprintf(szDbg, ARRAYSIZE(szDbg) - 1, TEXT("'%s' "), ptr);
                    OutputDebugString(szDbg);
                    ptr = ptr + (lstrlen(ptr) + 1);
                }
                OutputDebugString(TEXT("\n"));
                
                if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
                {
                    wnsprintf(szDbg, ARRAYSIZE(szDbg)-1, TEXT("StopWatch MaxDispatchTime=%dms MaxMsgTime=%dms MsgInterval=%dms TraceMsg=0x%x MemBuf=%d bytes\n"),
                        g_pswi->dwStopWatchMaxDispatchTime, g_pswi->dwStopWatchMaxMsgTime, g_pswi->dwStopWatchMsgInterval, g_pswi->dwStopWatchTraceMsg, sizeof(DWORD) * (g_pswi->dwStopWatchMaxMsgTime / g_pswi->dwStopWatchMsgInterval));
                    OutputDebugString(szDbg);
                }
                
                if(g_pswi->dwStopWatchMode & SPMODE_MEMWATCH)
                {
                    wnsprintf(szDbg, ARRAYSIZE(szDbg)-1, TEXT("StopWatch MemWatch Pages=%d Time=%dms Flags=%d\n"),
                        g_pswi->dwMemWatchPages, g_pswi->dwMemWatchTime, g_pswi->dwMemWatchFlags);
                    OutputDebugString(szDbg);
                }
            }
#endif
        }       //         if(dwVal != 0)
        
        RegCloseKey(hkeyPerfMode);
    }
}

//===========================================================================================
// EXPORTED FUNCTIONS
//===========================================================================================

//===========================================================================================
// Function: DWORD WINAPI StopWatchMode(VOID)
//
// Returns:  The value of the global mode variable.  Modules should use this call, set their
//           own global, and use this global to minimize and overhead when stopwatch mode
//           is not enabled.
//===========================================================================================
DWORD WINAPI StopWatchMode(VOID)
{
    if(g_pswi != NULL)
        return(g_pswi->dwStopWatchMode);
    else
        return(0);
}


//===========================================================================================
//===========================================================================================
const TCHAR c_szBrowserStop[] = TEXT("Browser Frame Stop (%s)");

DWORD MakeStopWatchDesc(DWORD dwId, DWORD dwMarkType, LPCTSTR pszDesc, LPTSTR *ppszText, DWORD dwTextLen)
{
    LPSTR lpszFmt = NULL;
    DWORD dwRC = 0;
    
    switch(SWID(dwId))
    {
        case SWID_BROWSER_FRAME:
            lpszFmt = (LPSTR)c_szBrowserStop;
            break;
        default:
            return(dwRC);
    }

    if(((DWORD)(lstrlen(lpszFmt) + lstrlen(pszDesc)) - 1) < dwTextLen)
        dwRC = wnsprintf(*ppszText, dwTextLen - 1, lpszFmt, pszDesc);
    else
        StrCpyN(*ppszText, TEXT("ERROR:Desc too long!"), dwTextLen -1);

    return(dwRC);
}

#define STARTCAPALL 1
#define STOPCAPALL 2
#define iStartCAPAll() CallICAP(STARTCAPALL)
#define iStopCAPAll() CallICAP(STOPCAPALL)

//===========================================================================================
//===========================================================================================
VOID CallICAP(DWORD dwFunc)
{
    if(g_pswi->hModICAP == NULL)
    {
        if((g_pswi->hModICAP = LoadLibrary("icap.dll")) != NULL)
        {
            g_pswi->pfnStartCAPAll = (PFN_ICAP) GetProcAddress(g_pswi->hModICAP, "StartCAPAll");
            g_pswi->pfnStopCAPAll = (PFN_ICAP) GetProcAddress(g_pswi->hModICAP, "StopCAPAll");
        }
        else
        {
            g_pswi->hModICAP = (HMODULE)1;
        }
    }

    switch(dwFunc)
    {
        case STARTCAPALL:
            if(g_pswi->pfnStartCAPAll != NULL)
                g_pswi->pfnStartCAPAll();
            break;
        case STOPCAPALL:
            if(g_pswi->pfnStopCAPAll != NULL)
                g_pswi->pfnStopCAPAll();
            break;
    }
}

//===========================================================================================
//===========================================================================================
VOID CapBreak(BOOL fStart)
{
    if((g_pswi->dwStopWatchMode & SPMODE_PROFILE) || (g_pswi->pHtmPerfCtl->dwFlags & HTMPF_ENABLE_PROFILE))
    {
        if(fStart)
            iStartCAPAll();
        else
            iStopCAPAll();
    }

    if((g_pswi->dwStopWatchMode & SPMODE_MEMWATCH) || (g_pswi->pHtmPerfCtl->dwFlags & HTMPF_ENABLE_MEMWATCH))
    {
        if(g_pswi->hModMemWatch == NULL)
            DoMemWatchConfig();
            
        if(fStart)
        {
            if(g_pswi->pfnMemWatchBegin != NULL)
            {
                g_pswi->pfnMemWatchBegin(TRUE, FALSE);  // synchronous and don't use timer
            }
        }
        else
        {
            if(g_pswi->pfnMemWatchSnapShot != NULL)
            {
                g_pswi->pfnMemWatchSnapShot();
            }
            
            if(g_pswi->pfnMemWatchEnd != NULL)
            {
                CHAR szOutFile[MAX_PATH];
                DWORD dwLen;
                HRESULT hr;
#if STOPWATCH_DEBUG
                CHAR szDbg[256];
#endif
                *szOutFile = '\0';
                GetWindowsDirectoryA(szOutFile, ARRAYSIZE(szOutFile) - 1);
                dwLen = lstrlenA(szOutFile);
                if ((dwLen > 0) && (szOutFile[dwLen-1] == '\\'))
                {
                    // See if windows is installed in the root
                    szOutFile[dwLen-1] = '\0';
                }
                StringCchCatA(szOutFile, ARRAYSIZE(szOutFile), "\\shperf.mws");

                hr = g_pswi->pfnMemWatchEnd(szOutFile);
                
#if STOPWATCH_DEBUG
                switch(hr)
                {
                    case E_FAIL:
                        wnsprintfA(szDbg,  ARRAYSIZE(szDbg) - 1, "MemWatch SaveBuffer:%s failed. GLE:0x%x\n", szOutFile, GetLastError());
                        OutputDebugStringA(szDbg);
                        break;
                    case E_ABORT:
                        wnsprintfA(szDbg,  ARRAYSIZE(szDbg) - 1, "MemWatch SaveBuffer: No data to save.\n");
                        OutputDebugStringA(szDbg);
                        break;
                }
#endif
                if(g_pswi->pfnMemWatchExit != NULL)
                {
                    g_pswi->pfnMemWatchExit();
                }
            }
        }
    }
    
    if(g_pswi->dwStopWatchMode & SPMODE_DEBUGBREAK)
    {
        DebugBreak();
    }
}

//===========================================================================================
// Function: DWORD WINAPI StopWatch(
//               DWORD dwId,        // The unique identifier, SWID_*, used to associate start, lap, and
//                                  // stop timings for a given timing sequence.
//               LPCSTR pszDesc,    // Descriptive text for the timing.
//               DWORD dwMarkType,  // START_NODE, LAP_NODE, STOP_NODE
//               DWORD dwFlags,     // SPMODE_SHELL, SPMODE_DEBUGOUT, SPMODE_*. The timing call is used
//                                     only if g_pswi->dwStopWatchMode contains dwFlags
//               DWORD dwID)        // Unique ID (Thread ID or user-supplied value)
//
// Macros:   StopWatch_Start(dwId, pszDesc, dwFlags)
//           StopWatch_Lap(dwId, pszDesc, dwFlags)
//           StopWatch_Stop(dwId, pszDesc, dwFlags)
//
// Returns:  ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY if out of nodes
//===========================================================================================
DWORD _StopWatch(DWORD dwId, LPCTSTR pszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount, DWORD dwUniqueID)
{
    PSTOPWATCH psp;
#ifdef STOPWATCH_DEBUG
    PSTOPWATCH pspPrev;
#endif    
    DWORD dwDelta = 0;
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwIndex;
    TCHAR szText[STOPWATCH_MAX_DESC];
    LPTSTR psz;

    if((SWID(dwId) && g_pswi->dwStopWatchProfile) && (dwMarkType == STOP_NODE))
    {
        CapBreak(FALSE);
    }

    if((g_pswi->pStopWatchList != NULL) && ((dwFlags & g_pswi->dwStopWatchMode) & SPMODES))
    {
        ENTERCRITICAL;
        dwIndex = g_pswi->dwStopWatchListIndex++;
        LEAVECRITICAL;

        if(dwIndex < (g_pswi->dwStopWatchListMax-1))
        {
            psp = g_pswi->pStopWatchList + (dwIndex);

            psp->dwCount = (dwCount != 0 ?dwCount :GetPerfTime());       // Save the data
            psp->dwId = dwId;
            psp->dwTID = dwUniqueID ? dwUniqueID : GetCurrentThreadId();
            psp->dwType = dwMarkType;
            psp->dwFlags = dwFlags;

            psz = (LPTSTR)pszDesc;
            if(dwFlags & SPMODE_FORMATTEXT)
            {
                psz = (LPTSTR)szText;
                MakeStopWatchDesc(dwId, dwMarkType, pszDesc, &psz, ARRAYSIZE(szText));
            }
            
            StrCpyN(psp->szDesc, psz, ARRAYSIZE(psp->szDesc)-1);

            if((g_pswi->dwStopWatchMode & SPMODE_PERFTAGS) && (g_pswi->pfnPerfLogFn != NULL))
            {
                if(dwMarkType == START_NODE)
                    g_pswi->pfnPerfLogFn(g_pswi->tagStopWatchStart, IntToPtr(dwId), psz);
                    
                if(dwMarkType == STOP_NODE)
                    g_pswi->pfnPerfLogFn(g_pswi->tagStopWatchStop, IntToPtr(dwId), psz);

                if(dwMarkType == LAP_NODE)
                    g_pswi->pfnPerfLogFn(g_pswi->tagStopWatchLap, IntToPtr(dwId), psz);
            }
    
#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
            {
                const TCHAR c_szFmt_StopWatch_DbgOut[] = TEXT("StopWatch: 0x%x: %s: Time: %u ms\r\n");
                TCHAR szBuf[STOPWATCH_MAX_DESC + ARRAYSIZE(c_szFmt_StopWatch_DbgOut) + 40];    // 8=dwTID 10=dwDelta
                
                if(psp->dwType > START_NODE)   // Find the previous associated node to get delta time
                {
                    pspPrev = psp - 1;
                    while(pspPrev >= g_pswi->pStopWatchList)
                    {
                        if((SWID(pspPrev->dwId) == SWID(psp->dwId)) &&  // Found a match
                           (pspPrev->dwTID == psp->dwTID) &&
                           (pspPrev->dwType == START_NODE))
                        {
                            dwDelta = psp->dwCount - pspPrev->dwCount;
                            break;
                        }
                        pspPrev--;
                    }
                }

                wnsprintf((LPTSTR)szBuf, ARRAYSIZE(szBuf), c_szFmt_StopWatch_DbgOut, psp->dwTID, psp->szDesc, dwDelta);
                OutputDebugString(szBuf);
            }
#endif

            if((dwMarkType == STOP_NODE) && (g_pswi->dwStopWatchMode & SPMODE_FLUSH) && (SWID(dwId) == SWID_FRAME))
            {
                StopWatchFlush();
            }
        }
        else
        {
            psp = g_pswi->pStopWatchList + (g_pswi->dwStopWatchListMax-1);  // Set the last node to a message so the user knows we ran out or mem
            psp->dwId = 0;
            psp->dwType = OUT_OF_NODES;
            psp->dwFlags = dwFlags;
            wnsprintf(psp->szDesc, STOPWATCH_MAX_DESC, TEXT("Out of perf timing nodes."));

#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                OutputDebugString(psp->szDesc);
#endif

            dwRC = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if((SWID(dwId) && g_pswi->dwStopWatchProfile) && (dwMarkType == START_NODE))
    {
        CapBreak(TRUE);
    }

    return(dwRC);
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchA(DWORD dwId, LPCSTR pszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount)
{
#ifdef UNICODE
    INT rc;
    WCHAR wszDesc[STOPWATCH_MAX_DESC];

    rc = MultiByteToWideChar(CP_ACP, 0, pszDesc, -1, wszDesc, STOPWATCH_MAX_DESC);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)wszDesc, dwMarkType, dwFlags, dwCount, 0));
#else
    return(_StopWatch(dwId, (LPCTSTR)pszDesc, dwMarkType, dwFlags, dwCount, 0));
#endif
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchW(DWORD dwId, LPCWSTR pwszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount)
{
#ifndef UNICODE    
    INT rc;
    CHAR szDesc[STOPWATCH_MAX_DESC];

    rc = WideCharToMultiByte(CP_ACP, 0, pwszDesc, -1, szDesc, STOPWATCH_MAX_DESC, NULL, NULL);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)szDesc, dwMarkType, dwFlags, dwCount, 0));
#else
    return(_StopWatch(dwId, (LPCTSTR)pwszDesc, dwMarkType, dwFlags, dwCount, 0));
#endif
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchExA(DWORD dwId, LPCSTR pszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount, DWORD dwCookie)
{
#ifdef UNICODE
    INT rc;
    WCHAR wszDesc[STOPWATCH_MAX_DESC];

    rc = MultiByteToWideChar(CP_ACP, 0, pszDesc, -1, wszDesc, STOPWATCH_MAX_DESC);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)wszDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#else
    return(_StopWatch(dwId, (LPCTSTR)pszDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#endif
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI StopWatchExW(DWORD dwId, LPCWSTR pwszDesc, DWORD dwMarkType, DWORD dwFlags, DWORD dwCount, DWORD dwCookie)
{
#ifndef UNICODE    
    INT rc;
    CHAR szDesc[STOPWATCH_MAX_DESC];

    rc = WideCharToMultiByte(CP_ACP, 0, pwszDesc, -1, szDesc, STOPWATCH_MAX_DESC, NULL, NULL);
  
    if(!rc)
        return(ERROR_NOT_ENOUGH_MEMORY);

    return(_StopWatch(dwId, (LPCTSTR)szDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#else
    return(_StopWatch(dwId, (LPCTSTR)pwszDesc, dwMarkType, dwFlags, dwCount, dwCookie));
#endif
}

//===========================================================================================
// Function: DWORD WINAPI StopWatchFlush(VOID)
//
// This function will flush any SPMODE_SHELL nodes to windir\shperf.log.  Calling this function
// will also clear all nodes.
//
// Return:   ERROR_SUCCESS if the log file was generated
//           ERROR_NO_DATA if the timing array is empty
//           ERROR_INVALID_DATA if stopwatch mode is not enabled or the timing array does
//              not exist.
//===========================================================================================
DWORD WINAPI StopWatchFlush(VOID)
{
    PSTOPWATCH psp;
    PSTOPWATCH psp1 = NULL;
    BOOL fWroteStartData;
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwWritten;
    DWORD dwDelta;
    DWORD dwPrevCount;
    DWORD dwCummDelta;
    DWORD dwLen = 0;
    HANDLE hFile;
    SYSTEMTIME st;
    TCHAR szBuf[STOPWATCH_MAX_BUF];
    TCHAR szFileName[MAX_PATH];
#ifdef STOPWATCH_DEBUG
    TCHAR szDbg[512];
#endif

    if((!g_pswi->dwStopWatchMode) || (g_pswi->pStopWatchList == NULL))
    {
        SetLastError(ERROR_INVALID_DATA);
        return(ERROR_INVALID_DATA);
    }

    GetSystemTime(&st);

    if(g_pswi->dwStopWatchListIndex > 0)
    {
        ENTERCRITICAL;
        if(g_pswi->dwStopWatchListIndex > 0)
        {
            g_pswi->dwStopWatchListIndex = 0;

            if(g_pswi->dwStopWatchMode & SPMODES)
            {

#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                {
                    OutputDebugString(TEXT("Flushing shell perf data to shperf.log\r\n"));
                }
#endif
                // Used below as well to create msg trace log file
                dwLen = GetWindowsDirectory(szFileName, ARRAYSIZE(szFileName) - 1);
                szFileName[dwLen] = 0;
                if (dwLen && szFileName[dwLen-1] == TEXT('\\'))
                {
                    // See if windows is installed in the root
                    szFileName[dwLen-1] = TEXT('\0');
                }
                StringCchCat(szFileName, ARRAYSIZE(szFileName), TEXT("\\shperf.log"));

                if((hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
                {
                    SetFilePointer(hFile, 0, NULL, FILE_END);

                    psp = g_pswi->pStopWatchList;
                    while(psp->dwType != EMPTY_NODE)
                    {
#ifdef STOPWATCH_DEBUG
                        if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                        {
                            wnsprintf(szDbg, ARRAYSIZE(szDbg), TEXT("ID:%d TID:0x%x Type:%d Flgs:%d %s\r\n"),
                                psp->dwId, psp->dwTID, psp->dwType, psp->dwFlags, psp->szDesc);
                            OutputDebugString(szDbg);
                        }
#endif
                        if(psp->dwType == START_NODE)
                        {
                            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%02d%02d%02d%02d%02d%02d\t0x%x\t%s\t%lu\t"), 
                                st.wYear, st.wMonth, st.wDay,
                                st.wHour, st.wMinute, st.wSecond,
                                psp->dwId, psp->szDesc, psp->dwCount);

#ifdef STOPWATCH_DEBUG
                            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                                OutputDebugString(TEXT("Found Start Node\r\n"));
#endif

                            dwDelta = dwCummDelta = 0;
                            dwPrevCount = psp->dwCount;

                            psp1 = psp + 1;
                            fWroteStartData = FALSE;
                            while(psp1->dwType != EMPTY_NODE)
                            {
#ifdef STOPWATCH_DEBUG
                                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                                {
                                    wnsprintf(szDbg, ARRAYSIZE(szDbg), TEXT("  ID:%d TID:0x%x Type:%d Flgs:%d %s\r\n"),
                                        psp1->dwId, psp1->dwTID, psp1->dwType, psp1->dwFlags, psp1->szDesc);
                                    OutputDebugString(szDbg);
                                }
#endif
                                if((SWID(psp1->dwId) == SWID(psp->dwId)) && 
                                   (psp1->dwTID == psp->dwTID))     // Found a matching LAP or STOP node
                                {
                                    if(psp1->dwType != START_NODE)
                                    {
                                        dwDelta = psp1->dwCount - dwPrevCount;
                                        dwCummDelta += dwDelta;

                                        if(!fWroteStartData)
                                        {
                                            fWroteStartData = TRUE;
                                            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);  // Write out start node data
                                        }
                                        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\t%lu,%lu,%lu\t"), psp1->szDesc, psp1->dwCount, dwDelta, dwCummDelta);
                                        WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
                                        if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                                            OutputDebugString(TEXT("  Found Lap/Stop Node\r\n"));
#endif

                                        dwPrevCount = psp1->dwCount;

                                        if(psp1->dwType == STOP_NODE && !(g_pswi->dwStopWatchMode & SPMODE_MARS))
                                            break;
                                    }
                                    else    // We have another start node that matches our Id/TID and we haven't had a stop.  Log as a missing stop.
                                    {
                                        if(!fWroteStartData)
                                        {
                                            fWroteStartData = TRUE;
                                            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);  // Write out start node data
                                        }
                                        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("ERROR: missing stop time"), psp1->szDesc, psp1->dwCount, dwDelta, dwCummDelta);
                                        WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
                                        break;
                                    }
                                }
                
                                psp1++;
                            }

                            WriteFile(hFile, TEXT("\r\n"), 2, &dwWritten, NULL);
                        }
                        else if(psp->dwType == OUT_OF_NODES)
                        {
                            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%02d%02d%02d%02d%02d%02d\t0x%x\t%s\n"), 
                                st.wYear, st.wMonth, st.wDay,
                                st.wHour, st.wMinute, st.wSecond,
                                psp->dwId, psp->szDesc);
                            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
                        }
                        psp->dwType = EMPTY_NODE;
                        psp++;
                    }
                    FlushFileBuffers(hFile);
                    CloseHandle(hFile);
                }
                else
                {
#ifdef STOPWATCH_DEBUG
                    wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("CreateFile failed on '%s'.  GLE=%d\n"), szFileName, GetLastError());
                    OutputDebugString(szBuf);
#endif
                    dwRC = ERROR_NO_DATA;
                }
            }
            else    // !(g_pswi->dwStopWatchMode)
            {
                psp = g_pswi->pStopWatchList;
                while(psp->dwType != EMPTY_NODE)
                {
                    psp->dwType = EMPTY_NODE;
                    psp++;
                }
            }
        }           // (g_pswi->dwStopWatchListIndex > 0)
        LEAVECRITICAL;
    }

    if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
    {
        int i;

        StringCchCopy(&szFileName[dwLen], ARRAYSIZE(szFileName) - dwLen, TEXT("\\msgtrace.log"));

        if((hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(hFile, 0, NULL, FILE_END);
            
            for (i = 0; i < (int)(g_pswi->dwStopWatchMaxMsgTime / g_pswi->dwStopWatchMsgInterval); ++i)
            {
                wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("%02d%02d%02d%02d%02d%02d\tMsgTrace\t%4d - %4dms\t%d\r\n"),
                    st.wYear, st.wMonth, st.wDay,
                    st.wHour, st.wMinute, st.wSecond,
                    i * g_pswi->dwStopWatchMsgInterval, (i+1)*g_pswi->dwStopWatchMsgInterval-1, *(g_pswi->pdwStopWatchMsgTime + i));
                WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                    OutputDebugString(szBuf);
#endif
            }
              
            wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("%02d%02d%02d%02d%02d%02d\tMsgTrace\tmsgs >= %dms\t%d\r\n"), 
                st.wYear, st.wMonth, st.wDay,
                st.wHour, st.wMinute, st.wSecond,
                g_pswi->dwStopWatchMaxMsgTime, g_pswi->dwcStopWatchOverflow);
            WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                OutputDebugString(szBuf);
#endif

            if(g_pswi->dwStopWatchTraceMsg > 0)
            {
                wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("%02d%02d%02d%02d%02d%02d\tMsgTrace\tmsg 0x%x occured %d times.\r\n"), 
                    st.wYear, st.wMonth, st.wDay,
                    st.wHour, st.wMinute, st.wSecond,
                    g_pswi->dwStopWatchTraceMsg, g_pswi->dwStopWatchTraceMsgCnt);
                WriteFile(hFile, szBuf, lstrlen(szBuf), &dwWritten, NULL);
#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                    OutputDebugString(szBuf);
#endif
            }
            
            FlushFileBuffers(hFile);
            CloseHandle(hFile);
        }
        else
        {
#ifdef STOPWATCH_DEBUG
            wnsprintf(szBuf, ARRAYSIZE(szBuf) - 1, TEXT("CreateFile failed on '%s'.  GLE=%d\n"), szFileName, GetLastError());
            OutputDebugString(szBuf);
#endif
            dwRC = ERROR_NO_DATA;
        }
    }

    return(dwRC);
}

//===========================================================================================
// The following StopWatch messages are used to drive the timer msg handler.  The timer proc is used
// as a means of delaying while watching paint messages.  If the defined number of timer ticks has 
// passed without getting any paint messages, then we mark the time of the last paint message we've 
// saved as the stop time.
//===========================================================================================
VOID CALLBACK StopWatch_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    StopWatch_TimerHandler(hwnd, 1, SWMSG_TIMER, NULL);
}

//===========================================================================================
//===========================================================================================
BOOL WINAPI StopWatch_TimerHandler(HWND hwnd, UINT uInc, DWORD dwFlag, MSG* pmsg)
{
    static INT iNumTimersRcvd = 0;
    static DWORD dwCnt = 0;
    static BOOL bActive = FALSE;
    static BOOL bHaveFirstPaintMsg = FALSE;

    switch(dwFlag)
    {
        case SWMSG_PAINT:
            if(bActive)
            {
                dwCnt = GetPerfTime();  // Save tick for last paint message
                iNumTimersRcvd = 0;     // Reset timers received count

                if(!bHaveFirstPaintMsg)
                {
                    TCHAR szClassName[40];  // If the class matches and its the first paint msg mark a lap time
                    LPCTSTR ptr;
                    GetClassName(pmsg->hwnd, szClassName, ARRAYSIZE(szClassName)-1);

                    ptr = g_pswi->pszClassNames;
                    while(*ptr)
                    {
                        if(lstrcmpi(szClassName, ptr) == 0)
                        {
                            bHaveFirstPaintMsg = TRUE;
                            StopWatch_LapTimed(SWID_FRAME, TEXT("Shell Frame 1st Paint"), SPMODE_SHELL | SPMODE_DEBUGOUT, dwCnt);
                            break;
                        }
                        ptr = ptr + (lstrlen(ptr) + 1);
                    }
                }
            }
            break;

        case SWMSG_TIMER:
            iNumTimersRcvd += uInc;
            if(iNumTimersRcvd >= 3)     // If we've received this arbitrary # of timer msgs, mark stop time using the saved last paint tick count
            {
                const TCHAR c_szFmtShellStop[] = TEXT("Shell Frame Stop (%s)");
                TCHAR szTitle[STOPWATCH_MAX_TITLE];
                TCHAR szText[ARRAYSIZE(c_szFmtShellStop) + STOPWATCH_MAX_TITLE + 1];

                KillTimer(hwnd, ID_STOPWATCH_TIMER);
                GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)-1);
                wnsprintf(szText, ARRAYSIZE(szText), c_szFmtShellStop, szTitle);
                StopWatch_StopTimed(SWID_FRAME, szText, SPMODE_SHELL | SPMODE_DEBUGOUT, dwCnt);
                bHaveFirstPaintMsg = FALSE;
                bActive = FALSE;  // Done timing

                if((g_pswi->dwStopWatchMode & (SPMODE_EVENT | SPMODE_SHELL)) == (SPMODE_EVENT | SPMODE_SHELL))
                {
                    StopWatch_SignalEvent();
                }
            }
            break;

        case SWMSG_CREATE:
            dwCnt = GetPerfTime();      // Save initial tick in case we don't have a paint when we exceed the # of SWMSG_TIMER above
            iNumTimersRcvd = 0;
            bHaveFirstPaintMsg = FALSE;
            bActive = (BOOL)SetTimer(hwnd, ID_STOPWATCH_TIMER, g_pswi->dwStopWatchPaintInterval, StopWatch_TimerProc);   // Use timer to determine when painting is done
            break;

        case SWMSG_STATUS:
            break;
    }

    return(bActive);   // Timing status active or not
}

//===========================================================================================
// This function is used to key off of WM_KEYDOWN to start timing when navigating inplace
//===========================================================================================
VOID WINAPI StopWatch_CheckMsg(HWND hwnd, MSG msg, LPCSTR lpStr)
{
    TCHAR szText[80];
    
#ifdef STOPWATCH_DEBUG
    if(g_pswi->dwStopWatchMode & SPMODE_TEST)    // Used to verify message assumptions
    {
        wnsprintf((LPTSTR)szText, ARRAYSIZE(szText), TEXT("Hwnd=0x%08x Msg=0x%x\r\n"), msg.hwnd, msg.message);
        OutputDebugString(szText);
    }
#endif

    if(g_pswi->dwStopWatchMode & SPMODE_SHELL)
    {
        if(!StopWatch_TimerHandler(hwnd, 0, SWMSG_STATUS, &msg) &&
            (((msg.message == WM_KEYDOWN) && (msg.wParam == VK_RETURN)) ||
            ((msg.message == WM_KEYDOWN) && (msg.wParam == VK_BACK)))
            )  // Navigating within the same window
        {
            wnsprintf(szText, ARRAYSIZE(szText), TEXT("Shell Frame Same%s"), lpStr);
            StopWatch_TimerHandler(hwnd, 0, SWMSG_CREATE, &msg);
            StopWatch_Start(SWID_FRAME, szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }

    // Compute the time it took to get the message. Then increment approp MsgTime bucket
    if(g_pswi->dwStopWatchMode & SPMODE_MSGTRACE)
    {
        DWORD dwTick = GetTickCount();
        DWORD dwElapsed;
#ifdef STOPWATCH_DEBUG
        TCHAR szMsg[256];
#endif

        g_pswi->dwStopWatchLastLocation = 0;
        
        if(dwTick > msg.time)
        {
            dwElapsed = dwTick - msg.time;

            if(dwElapsed >= g_pswi->dwStopWatchMaxMsgTime)
            {
                ++g_pswi->dwcStopWatchOverflow;
                
#ifdef STOPWATCH_DEBUG
                if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
                {
                    TCHAR szClassName[40]; 
                    TCHAR szMsgName[20];
                
                    GetClassName(msg.hwnd, szClassName, ARRAYSIZE(szClassName) - 1);
                    if(g_pswi->pfnDecodeMessage != NULL)
                        StrCpyN(szMsgName, g_pswi->pfnDecodeMessage(msg.message), ARRAYSIZE(szMsgName) - 1);
                    else
                        wnsprintf(szMsgName, ARRAYSIZE(szMsgName) - 1, "0x%x", msg.message);
                    wnsprintf(szMsg, ARRAYSIZE(szMsg) - 1, TEXT("MsgTrace (%s) loc=%d, ms=%d >= %d, hwnd=%x, wndproc=%x, msg=%s, w=%x, l=%x\r\n"), 
                        szClassName, g_pswi->dwStopWatchLastLocation, dwElapsed, g_pswi->dwStopWatchMaxMsgTime, msg.hwnd, GetClassLongPtr(msg.hwnd, GCLP_WNDPROC), szMsgName, msg.wParam, msg.lParam);
                    OutputDebugString(szMsg);                                
                }
#endif
            }
            else
            {
                ++(*(g_pswi->pdwStopWatchMsgTime + (dwElapsed / g_pswi->dwStopWatchMsgInterval)));
            }
        }

        if(g_pswi->dwStopWatchTraceMsg == msg.message)
            ++g_pswi->dwStopWatchTraceMsgCnt;
            
        g_pswi->dwStopWatchLastLocation = 0;
    }
}

//===========================================================================================
//===========================================================================================
VOID WINAPI StopWatch_SetMsgLastLocation(DWORD dwLast)
{
    g_pswi->dwStopWatchLastLocation = dwLast;
}

//===========================================================================================
// Logs messages that took longer than g_pswi->dwStopWatchMaxDispatchTime to be dispatched
//===========================================================================================
DWORD WINAPI StopWatch_DispatchTime(BOOL fStartTime, MSG msg, DWORD dwStart)
{
    DWORD dwTime = 0;
    TCHAR szMsg[256];
    
    if(fStartTime)
    {
        if(g_pswi->dwStopWatchTraceMsg == msg.message)
            CapBreak(TRUE);

        StopWatch(SWID_MSGDISPATCH, TEXT("+Dispatch"), START_NODE, SPMODE_MSGTRACE | SPMODE_DEBUGOUT, dwStart);

        dwTime = GetPerfTime();

    }
    else
    {
        dwTime = GetPerfTime();
        
        if(g_pswi->dwStopWatchTraceMsg == msg.message)
            CapBreak(FALSE);
            
        if((dwTime - dwStart) >= g_pswi->dwStopWatchMaxDispatchTime)
        {
            TCHAR szClassName[40];
            TCHAR szMsgName[20];

            GetClassName(msg.hwnd, szClassName, ARRAYSIZE(szClassName) - 1);
            if(g_pswi->pfnDecodeMessage != NULL)
                StrCpyN(szMsgName, g_pswi->pfnDecodeMessage(msg.message), ARRAYSIZE(szMsgName) - 1);
            else
                wnsprintf(szMsgName, ARRAYSIZE(szMsgName) - 1, "0x%x", msg.message);
            wnsprintf(szMsg, ARRAYSIZE(szMsg) - 1, TEXT("-Dispatch (%s) ms=%d > %d, hwnd=%x, wndproc=%x, msg=%s(%x), w=%x, l=%x"), 
                szClassName, dwTime - dwStart, g_pswi->dwStopWatchMaxDispatchTime, msg.hwnd, GetClassLongPtr(msg.hwnd, GCLP_WNDPROC), szMsgName, msg.message, msg.wParam, msg.lParam);
                
            StopWatch(SWID_MSGDISPATCH, szMsg, STOP_NODE, SPMODE_MSGTRACE | SPMODE_DEBUGOUT, dwTime);

#ifdef STOPWATCH_DEBUG
            if(g_pswi->dwStopWatchMode & SPMODE_DEBUGOUT)
            {
                lstrcat(szMsg, "\n");
                OutputDebugString(szMsg);
            }
#endif
        }
    }
    return(dwTime);
}

//===========================================================================================
// Mark shell/browser frame creation start time
//===========================================================================================
VOID WINAPI StopWatch_MarkFrameStart(LPCSTR lpExplStr)
{
    TCHAR szText[80];
    DWORD dwTime = GetPerfTime();
    if(g_pswi->dwStopWatchMode & SPMODE_SHELL)
    {
        wnsprintf(szText, ARRAYSIZE(szText), TEXT("Shell Frame Start%s"), lpExplStr);
        StopWatch_StartTimed(SWID_FRAME, szText, SPMODE_SHELL | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_BROWSER)  // Used to get the start of browser total download time
    {
        StopWatch_LapTimed(SWID_BROWSER_FRAME, TEXT("Thread Start"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_JAVA)  // Used to get the start of java applet load time
    {
        StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Start"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
    }
}

//===========================================================================================
// Mark shell/browser navigate in same frame start time
//===========================================================================================
VOID WINAPI StopWatch_MarkSameFrameStart(HWND hwnd)
{
    DWORD dwTime = GetPerfTime();
    
    if(g_pswi->dwStopWatchMode & SPMODE_SHELL)
    {
        StopWatch_TimerHandler(hwnd, 0, SWMSG_CREATE, NULL);
        StopWatch_StartTimed(SWID_FRAME, TEXT("Shell Frame Same"), SPMODE_SHELL | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_BROWSER)  // Used to get browser total download time
    {
        StopWatch_StartTimed(SWID_BROWSER_FRAME, TEXT("Browser Frame Same"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
    }
    if(g_pswi->dwStopWatchMode & SPMODE_JAVA)  // Used to get java applet load time
    {
        StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Same"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
    }
}

//===========================================================================================
// When browser or java perf timing mode is enabled, use "Done" or "Applet Started" 
// in the status bar to get load time.
//===========================================================================================
VOID WINAPI StopWatch_MarkJavaStop(LPCSTR  lpStringToSend, HWND hwnd, BOOL fChType)
{
    const TCHAR c_szFmtJavaStop[] = TEXT("Java Applet Stop (%s)");
    TCHAR szTitle[STOPWATCH_MAX_TITLE];
    TCHAR szText[STOPWATCH_MAX_TITLE + ARRAYSIZE(c_szFmtJavaStop) + 1];

    if(g_pswi->dwStopWatchMode & SPMODE_JAVA)
    {
        if((lpStringToSend != NULL) && (lstrncmpW((LPWSTR)lpStringToSend, TEXTW("Applet started"), ARRAYSIZE(TEXTW("Applet started"))) == 0))
        {
            GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)-1);
            wnsprintf(szText, ARRAYSIZE(szText), c_szFmtJavaStop, szTitle);
            StopWatch_Stop(SWID_JAVA_APP, szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }
}

//===========================================================================================
//===========================================================================================
DWORD WINAPI GetPerfTime(VOID)
{
    static __int64 freq;
    __int64 curtime;

    if (!freq)
        QueryPerformanceFrequency((LARGE_INTEGER *)&freq);

    QueryPerformanceCounter((LARGE_INTEGER *)&curtime);

    ASSERT((((curtime * 1000) / freq) >> 32) == 0);
    
    return (DWORD)((curtime * 1000) / freq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\strings.c ===
//============================================================================
//
// DBCS and UNICODE aware string routines
//
//
//============================================================================

#include "priv.h"
#include "ids.h"
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()

#include <mluisupp.h>

#include "varutil.h"

BOOL UnicodeFromAnsi(LPWSTR *, LPCSTR, LPWSTR, int);

#define IS_DIGITA(ch)    InRange(ch, '0', '9')
#define IS_DIGITW(ch)    InRange(ch, L'0', L'9')


#define DM_INTERVAL 0

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

__inline BOOL IsAsciiA(char ch)
{
    return !(ch & 0x80);
}

__inline BOOL IsAsciiW(WCHAR ch)
{
    return ch < 128;
}

__inline char Ascii_ToLowerA(char ch)
{
    return (ch >= 'A' && ch <= 'Z') ? (ch - 'A' + 'a') : ch;
}

__inline WCHAR Ascii_ToLowerW(WCHAR ch)
{
    return (ch >= L'A' && ch <= L'Z') ? (ch - L'A' + L'a') : ch;
}


// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand thid

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


__inline BOOL ChrCmpW_inline(WCHAR w1, WCHAR wMatch)
{
    return(!(w1 == wMatch));
}


/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

#if defined(MWBIG_ENDIAN)
    sz2[0] = LOBYTE(wMatch);
    sz2[1] = HIBYTE(wMatch);
#else
    *(WORD *)sz2 = wMatch;
#endif
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return StrCmpIW(sz1, sz2);
}

LPWSTR Shlwapi_StrCpyW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    LPWSTR psz = pszDst;

    RIPMSG(NULL!=pszDst, "StrCpyW: Caller passed invalid pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCpyW: Caller passed invalid pszSrc");
    if (pszDst && pszSrc)
    {
        while (*pszDst++ = *pszSrc++)
            ;
    }

    return psz;
}

//***   StrCpyNX[AW] -- just like StrCpyN[AW], but returns ptr to EOS
// NOTES
//  do we really need 'A' version?  (for now we do for shell32 on 'old'
//  platforms that we test on but don't ship)
LPSTR StrCpyNXA(LPSTR pszDst, LPCSTR pszSrc, int cchMax)
{
    RIPMSG(cchMax >= 0, "StrCpyNXA: Caller passed bad cchMax");
    RIPMSG(cchMax < 0 || (pszDst && IS_VALID_WRITE_BUFFER(pszDst, char, cchMax)), "StrCpyNXA: Caller passed bad pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRA(pszSrc, -1), "StrCpyNXA: Caller passed bad pszSrc");

    // NOTE: Cannot use DEBUGWhackPathBuffer before copying because src and
    // dest might overlap.  Must delay whacking until after we're done.

    if (0 < cchMax)
    {
        if (!pszSrc)
            goto NullItOut;

        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if (!(*pszDst++ = *pszSrc++))
            {
                --pszDst;
                break;
            }
        }

        cchMax++;
        // in the cchMax>1 case, pszDst already points at the NULL, but reassigning it doesn't hurt
NullItOut:
        // Whack the unused part of the buffer
        DEBUGWhackPathBufferA(pszDst, cchMax);
        *pszDst = '\0';
    }

    return pszDst;
}

LPWSTR StrCpyNXW(LPWSTR pszDst, LPCWSTR pszSrc, int cchMax)
{
    RIPMSG(cchMax >= 0, "StrCpyNXW: Caller passed bad cchMax");
    RIPMSG(cchMax < 0 || (pszDst && IS_VALID_WRITE_BUFFER(pszDst, WCHAR, cchMax)), "StrCpyNXW: Caller passed bad pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCpyNXW: Caller passed bad pszSrc");

    // NOTE: Cannot use DEBUGWhackPathBuffer before copying because src and
    // dest might overlap.  Must delay whacking until after we're done.

    if (0 < cchMax)
    {
        if (!pszSrc) // a test app passed in a NULL src ptr and we faulted, let's not fault here.
            goto NullItOut;

        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if (!(*pszDst++ = *pszSrc++))
            {
                --pszDst;
                break;
            }
        }

        cchMax++;
        // in the cchMax>1 case, pszDst already points at the NULL, but reassigning it doesn't hurt
NullItOut:
        // Whack the unused part of the buffer
        DEBUGWhackPathBufferW(pszDst, cchMax);
        *pszDst = L'\0';
    }

    return pszDst;
}

LPWSTR StrCpyNW(LPWSTR pszDst, LPCWSTR pszSrc, int cchMax)
{
    StrCpyNXW(pszDst, pszSrc, cchMax);
    return pszDst;
}

LPWSTR Shlwapi_StrCatW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    LPWSTR psz = pszDst;

    RIPMSG(pszDst && IS_VALID_STRING_PTRW(pszDst, -1), "StrCatW: Caller passed invalid pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCatW: Caller passed invalid pszSrc");
    if (pszDst && pszSrc)
    {
        while (0 != *pszDst)
            pszDst++;

        while (*pszDst++ = *pszSrc++)
            ;
    }
    return psz;
}

LWSTDAPI_(LPWSTR) StrCatBuffW(LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize)
{
    RIPMSG(pszDest && IS_VALID_STRING_PTRW(pszDest, -1), "StrCatBuffW: Caller passed invalid pszDest");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCatBuffW: Caller passed invalid pszSrc");
    RIPMSG(cchDestBuffSize >= 0, "StrCatBuffW: Caller passed invalid cchDestBuffSize");
    RIPMSG(!(pszDest && IS_VALID_STRING_PTRW(pszDest, -1)) || cchDestBuffSize<0 || lstrlenW(pszDest)<cchDestBuffSize, "StrCatBuffW: Caller passed odd pszDest - string larger than cchDestBuffSize!");
    DEBUGWhackPathStringW(pszDest, cchDestBuffSize);

    if (pszDest && pszSrc)
    {
        LPWSTR psz = pszDest;

        // we walk forward till we find the end of pszDest, subtracting
        // from cchDestBuffSize as we go.
        while (*psz)
        {
            psz++;
            cchDestBuffSize--;
        }

        if (cchDestBuffSize > 0)
        {
            // call the shlwapi function here because win95 does not have lstrcpynW
            StrCpyNW(psz, pszSrc, cchDestBuffSize);
        }
    }
    return pszDest;
}

 
LWSTDAPI_(LPSTR) StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize)
{
    RIPMSG(pszDest && IS_VALID_STRING_PTRA(pszDest, -1), "StrCatBuffA: Caller passed invalid pszDest");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRA(pszSrc, -1), "StrCatBuffA: Caller passed invalid pszSrc");
    RIPMSG(cchDestBuffSize >= 0, "StrCatBuffA: Caller passed invalid cchDestBuffSize");
    RIPMSG(!(pszDest && IS_VALID_STRING_PTRA(pszDest, -1)) || cchDestBuffSize<0 || lstrlen(pszDest)<cchDestBuffSize, "StrCatBuffA: Caller passed odd pszDest - string larger than cchDestBuffSize!");
    DEBUGWhackPathStringA(pszDest, cchDestBuffSize);

    if (pszDest && pszSrc)
    {
        LPSTR psz = pszDest;
        
        // we walk forward till we find the end of pszDest, subtracting
        // from cchDestBuffSize as we go.
        while (*psz)
        {
            psz++;
            cchDestBuffSize--;
        }

        if (cchDestBuffSize > 0)
        {
            // Let kernel do the work for us. 
            //
            // WARNING: We might generate a truncated DBCS sting becuase kernel's lstrcpynA
            // dosent check for this. Ask me if I care.
            lstrcpynA(psz, pszSrc, cchDestBuffSize);
        }
    }

    return pszDest;
}
   

/* StrNCat(front, back, count) - append count chars of back onto front
 */
LPSTR Shlwapi_StrNCatA(LPSTR front, LPCSTR back, int cchMax)
{
    LPSTR start = front;

    RIPMSG(front && IS_VALID_STRING_PTRA(front, -1), "StrNCatA: Caller passed invalid front");
    RIPMSG(back && IS_VALID_STRING_PTRA(front, cchMax), "StrNCatA: Caller passed invalid back");
    RIPMSG(cchMax >= 0, "StrNCatA: Caller passed invalid cchMax");
    if (front && back)
    {
        while (*front++)
                    ;
        front--;

        lstrcpyn(front, back, cchMax);
    }
    return(start);    
}

LPWSTR Shlwapi_StrNCatW(LPWSTR front, LPCWSTR back, int cchMax)
{
    LPWSTR start = front;

    RIPMSG(front && IS_VALID_STRING_PTRW(front, -1), "StrNCatW: Caller passed invalid front");
    RIPMSG(back && IS_VALID_STRING_PTRW(front, cchMax), "StrNCatW: Caller passed invalid back");
    RIPMSG(cchMax >= 0, "StrNCatW: Caller passed invalid cchMax");
    if (front && back)
    {
        while (*front++)
                    ;
        front--;

        StrCpyNW(front, back, cchMax);
    }    
    return(start);    
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS)
{
    if (fMBCS) {
        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    } else {
        for ( ; *lpStart; lpStart++)
        {
            if ((BYTE)*lpStart == LOBYTE(wMatch)) {
                return((LPSTR)lpStart);
            }
        }
    }
    return (NULL);
}

LPSTR StrChrA(LPCSTR lpStart, WORD wMatch)
{
    CPINFO cpinfo;

    RIPMSG(lpStart && IS_VALID_STRING_PTR(lpStart, -1), "StrChrA: caller passed bad lpStart");
    if (!lpStart)
        return NULL;

    return _StrChrA(lpStart, wMatch, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

#ifdef ALIGNMENT_SCENARIO

LPWSTR StrChrSlowW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return NULL;
}
#endif

LPWSTR StrChrW(LPCWSTR lpStart, WCHAR wMatch)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrW: caller passed bad lpStart");
    if (!lpStart)
        return NULL;

    //
    //  raymondc
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    RIPMSG(!((ULONG_PTR)lpStart & 1), "StrChrW: caller passed UNALIGNED lpStart"); // Assert alignedness

#ifdef ALIGNMENT_SCENARIO
    //
    //  Since unaligned strings arrive so rarely, put the slow
    //  version in a separate function so the common case stays
    //  fast.  Believe it or not, we call StrChrW so often that
    //  it is now a performance-sensitive function!
    //
    if ((ULONG_PTR)lpStart & 1)
        return StrChrSlowW(lpStart, wMatch);
#endif

    for ( ; *lpStart; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrChrN - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */

#ifdef ALIGNMENT_SCENARIO

LPWSTR StrChrSlowNW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch, UINT cchMax)
{
    LPCWSTR lpSentinel = lpStart + cchMax;
    for ( ; *lpStart && lpStart < lpSentinel; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
}
#endif

LPWSTR StrChrNW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax)
{
    LPCWSTR lpSentinel = lpStart + cchMax;

    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrNW: caller passed bad lpStart");
    if (!lpStart)
        return NULL;

    //
    //  raymondc
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    RIPMSG(!((ULONG_PTR)lpStart & 1), "StrChrNW: caller passed UNALIGNED lpStart"); // Assert alignedness

#ifdef ALIGNMENT_SCENARIO
    //
    //  Since unaligned strings arrive so rarely, put the slow
    //  version in a separate function so the common case stays
    //  fast.  Believe it or not, we call StrChrW so often that
    //  it is now a performance-sensitive function!
    //
    if ((ULONG_PTR)lpStart & 1)
        return StrChrSlowNW(lpStart, wMatch, cchMax);
#endif

    for ( ; *lpStart && lpStart<lpSentinel; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}


/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTR(lpStart, -1), "StrRChrA: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart), "StrRChrA: caller passed bad lpEnd");
    // don't need to check for NULL lpStart

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

LPWSTR StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
    LPCWSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrRChrW: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenW(lpStart), "StrRChrW: caller passed bad lpEnd");
    // don't need to check for NULL lpStart

    if (!lpEnd)
        lpEnd = lpStart + lstrlenW(lpStart);

    for ( ; lpStart < lpEnd; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPWSTR)lpFound);
}

/*
 * StrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR StrChrIA(LPCSTR lpStart, WORD wMatch)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRA(lpStart, -1), "StrChrIA: caller passed bad lpStart");
    if (lpStart)
    {
        wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    }
    return (NULL);
}

LPWSTR StrChrIW(LPCWSTR lpStart, WCHAR wMatch)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrIW: caller passed bad lpStart");
    if (lpStart)
    {
        for ( ; *lpStart; lpStart++)
        {
            if (!ChrCmpIW(*lpStart, wMatch))
                return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrChrNI - Find first occurrence of character in string, case insensitive, counted
 *
 */
LPWSTR StrChrNIW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax)
{
    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrChrNIW: caller passed bad lpStart");
    if (lpStart)
    {
        LPCWSTR lpSentinel = lpStart + cchMax;
        
        for ( ; *lpStart && lpStart < lpSentinel; lpStart++)
        {
            if (!ChrCmpIW(*lpStart, wMatch))
                return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrRChrI - Find last occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTRA(lpStart, -1), "StrRChrIA: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart), "StrRChrIA: caller passed bad lpEnd");

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}


LPWSTR StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
    LPCWSTR lpFound = NULL;

    RIPMSG(lpStart && IS_VALID_STRING_PTRW(lpStart, -1), "StrRChrIW: caller passed bad lpStart");
    RIPMSG(!lpEnd || lpEnd <= lpStart + lstrlenW(lpStart), "StrRChrIW: caller passed bad lpEnd");

    if (!lpEnd)
        lpEnd = lpStart + lstrlenW(lpStart);

    for ( ; lpStart < lpEnd; lpStart++)
    {
        if (!ChrCmpIW(*lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPWSTR)lpFound);
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

         If psz contains no characters that are in the set of
         characters in pszSet, this function returns NULL.

         This function is DBCS-safe.

Returns: see above
Cond:    --
*/
LPSTR StrPBrkA(LPCSTR psz, LPCSTR pszSet)
{
    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "StrPBrkA: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRA(pszSet, -1), "StrPBrkA: caller passed bad pszSet");
    if (psz && pszSet)
    {
        while (*psz)
        {
            LPCSTR pszSetT;
            for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
            {
                if (*psz == *pszSetT)
                {
                    // Found first character that matches
                    return (LPSTR)psz;      // Const -> non-const
                }
            }
            psz = CharNextA(psz);
        }
    }
    return NULL;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

Returns: see above
Cond:    --
*/
LPWSTR WINAPI StrPBrkW(LPCWSTR psz, LPCWSTR pszSet)
{
    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "StrPBrkA: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRW(pszSet, -1), "StrPBrkA: caller passed bad pszSet");
    if (psz && pszSet)
    {
        while (*psz)
        {
            LPCWSTR pszSetT;
            for (pszSetT = pszSet; *pszSetT; pszSetT++)
            {
                if (*psz == *pszSetT)
                {
                    // Found first character that matches
                    return (LPWSTR)psz;     // Const -> non-const
                }
            }
            psz++;
        }
    }
    return NULL;
}


int WINAPI StrToIntA(LPCSTR lpSrc)
{
    RIPMSG(lpSrc && IS_VALID_STRING_PTRA(lpSrc, -1), "StrToIntA: Caller passed bad lpSrc");
    if (lpSrc)
    {
        int n = 0;
        BOOL bNeg = FALSE;

        if (*lpSrc == '-')
        {
            bNeg = TRUE;
            lpSrc++;
        }

        while (IS_DIGITA(*lpSrc))
        {
            n *= 10;
            n += *lpSrc - '0';
            lpSrc++;
        }
        return bNeg ? -n : n;
    }
    return 0;
}


int WINAPI StrToIntW(LPCWSTR lpSrc)
{
    RIPMSG(lpSrc && IS_VALID_STRING_PTRW(lpSrc, -1), "StrToIntW: Caller passed bad lpSrc");
    if (lpSrc)
    {
        int n = 0;
        BOOL bNeg = FALSE;

        if (*lpSrc == L'-')
        {
            bNeg = TRUE;
            lpSrc++;
        }

        while (IS_DIGITW(*lpSrc))
        {
            n *= 10;
            n += *lpSrc - L'0';
            lpSrc++;
        }
        return bNeg ? -n : n;
    }
    return 0;
}

/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *phRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

        dwFlags are STIF_ bitfield
Cond:    --
*/
BOOL WINAPI StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG *pllRet)
{
    BOOL bRet;

    RIPMSG(pszString && IS_VALID_STRING_PTRW(pszString, -1), "StrToInt64ExW: caller passed bad pszString");
    if (pszString)
    {
        LONGLONG n;
        BOOL bNeg = FALSE;
        LPCWSTR psz;
        LPCWSTR pszAdj;

        // Skip leading whitespace
        //
        for (psz = pszString; *psz == L' ' || *psz == L'\n' || *psz == L'\t'; psz++)
            ;

        // Determine possible explicit signage
        //
        if (*psz == L'+' || *psz == L'-')
        {
            bNeg = (*psz == L'+') ? FALSE : TRUE;
            psz++;
        }

        // Or is this hexadecimal?
        //
        pszAdj = psz+1;
        if ((STIF_SUPPORT_HEX & dwFlags) &&
            *psz == L'0' && (*pszAdj == L'x' || *pszAdj == L'X'))
        {
            // Yes

            // (Never allow negative sign with hexadecimal numbers)
            bNeg = FALSE;
            psz = pszAdj+1;

            pszAdj = psz;

            // Do the conversion
            //
            for (n = 0; ; psz++)
            {
                if (IS_DIGITW(*psz))
                    n = 0x10 * n + *psz - L'0';
                else
                {
                    WCHAR ch = *psz;
                    int n2;

                    if (ch >= L'a')
                        ch -= L'a' - L'A';

                    n2 = ch - L'A' + 0xA;
                    if (n2 >= 0xA && n2 <= 0xF)
                        n = 0x10 * n + n2;
                    else
                        break;
                }
            }

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }
        else
        {
            // No
            pszAdj = psz;

            // Do the conversion
            for (n = 0; IS_DIGITW(*psz); psz++)
                n = 10 * n + *psz - L'0';

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }

        if (pllRet)
        {
            *pllRet = bNeg ? -n : n;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

/*----------------------------------------------------------
 Purpose: ansi wrapper for StrToInt64ExW.

 Returns: see StrToInt64ExW
 Cond:    --
 */
BOOL WINAPI StrToInt64ExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    LONGLONG FAR * pllRet)
{
    BOOL bRet;

    RIPMSG(pszString && IS_VALID_STRING_PTRA(pszString, -1), "StrToInt64ExA: caller passed bad pszString");
    if (pszString)
    {
        // Most strings will simply use this temporary buffer, but UnicodeFromAnsi
        // will allocate a buffer if the supplied string is bigger.
        WCHAR szBuf[MAX_PATH];
        LPWSTR pwszString;

        bRet = UnicodeFromAnsi(&pwszString, pszString, szBuf, SIZECHARS(szBuf));
        if (bRet)
        {
            bRet = StrToInt64ExW(pwszString, dwFlags, pllRet);
            UnicodeFromAnsi(&pwszString, NULL, szBuf, 0);
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

/*----------------------------------------------------------
 Purpose: Calls StrToInt64ExA (the real work horse), and 
          then casts down to an int.
 Returns: see StrToInt64ExA
 */
BOOL WINAPI StrToIntExA(
    LPCSTR pszString, 
    DWORD  dwFlags, 
    int   *piRet)
{
    LONGLONG llVal;
    BOOL fReturn;

    RIPMSG(pszString && IS_VALID_STRING_PTRA(pszString, -1), "StrToIntExA: caller passed bad pszString");

    fReturn = StrToInt64ExA(pszString, dwFlags, &llVal);
    *piRet = fReturn ? (int)llVal : 0;
    return(fReturn);
}

/*----------------------------------------------------------
 Purpose: Calls StrToInt64ExW (the real work horse), and 
          then casts down to an int.
 Returns: see StrToInt64ExW
 */
BOOL WINAPI StrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
{
    LONGLONG llVal;
    BOOL fReturn;

    RIPMSG(pwszString && IS_VALID_STRING_PTRW(pwszString, -1), "StrToIntExW: caller passed bad pwszString");

    fReturn = StrToInt64ExW(pwszString, dwFlags, &llVal);
    *piRet = fReturn ? (int)llVal : 0;
    return(fReturn);
}

/*----------------------------------------------------------
 Purpose: Returns an integer value specifying the length of
 the substring in psz that consists entirely of
 characters in pszSet.  If psz begins with a character
 not in pszSet, then this function returns 0.

 This is a DBCS-safe version of the CRT strspn().

 Returns: see above
 Cond:    --
 */
int StrSpnA(LPCSTR psz, LPCSTR pszSet)
{
    LPCSTR pszT = psz;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "StrSpnA: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRA(pszSet, -1), "StrSpnA: caller passed bad pszSet");
    if (psz && pszSet)
    {
        // Go thru the string to be inspected
        for ( ; *pszT; pszT = CharNextA(pszT))
        {
            LPCSTR pszSetT;
            
            // Go thru the char set
            for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
            {
                if (*pszSetT == *pszT)
                {
                    if ( !IsDBCSLeadByte(*pszSetT) )
                    {
                        break;      // Chars match
                    }
                    else if (pszSetT[1] == pszT[1])
                    {
                        break;      // Chars match
                    }
                }
            }

            // End of char set?
            if (0 == *pszSetT)
            {
                break;      // Yes, no match on this inspected char
            }
        }
    }
    return (int)(pszT - psz);
}


/*----------------------------------------------------------
 Purpose: Returns an integer value specifying the length of
 the substring in psz that consists entirely of
 characters in pszSet.  If psz begins with a character
 not in pszSet, then this function returns 0.

 This is a DBCS-safe version of the CRT strspn().

 Returns: see above
 Cond:    --
 */
STDAPI_(int) StrSpnW(LPCWSTR psz, LPCWSTR pszSet)
{
    LPCWSTR pszT = psz;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "StrSpnW: caller passed bad psz");
    RIPMSG(pszSet && IS_VALID_STRING_PTRW(pszSet, -1), "StrSpnW: caller passed bad pszSet");
    if (psz && pszSet)
    {
        // Go thru the string to be inspected
        for ( ; *pszT; pszT++)
        {
            LPCWSTR pszSetT;

            // Go thru the char set
            for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
            {
                if (0 == *pszSetT)
                {
                    // Reached end of char set without finding a match
                    return (int)(pszT - psz);
                }
            }
        }
    }
    return (int)(pszT - psz);
}


// StrCSpn: return index to first char of lpStr that is present in lpSet.
// Includes the NUL in the comparison; if no lpSet chars are found, returns
// the index to the NUL in lpStr.
// Just like CRT strcspn.
//
int StrCSpnA(LPCSTR lpStr, LPCSTR lpSet)
{
    LPCSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRA(lpStr, -1), "StrCSpnA: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRA(lpSet, -1), "StrCSpnA: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrA(lpSet, READNATIVEWORD(lp)))
                return (int)(lp-lpStr);
            lp = AnsiNext(lp);
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    LPCWSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRW(lpStr, -1), "StrCSpnW: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRW(lpSet, -1), "StrCSpnW: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrW(lpSet, *lp))
                return (int)(lp-lpStr);
            lp++;
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

// StrCSpnI: case-insensitive version of StrCSpn.
//
int StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet)
{
    LPCSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRA(lpStr, -1), "StrCSpnIA: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRA(lpSet, -1), "StrCSpnIA: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrIA(lpSet, READNATIVEWORD(lp)))
                return (int)(lp-lpStr);
            lp = AnsiNext(lp);
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    LPCWSTR lp = lpStr;

    RIPMSG(lpStr && IS_VALID_STRING_PTRW(lpStr, -1), "StrCSpnIW: Caller passed bad lpStr");
    RIPMSG(lpSet && IS_VALID_STRING_PTRW(lpSet, -1), "StrCSpnIW: Caller passed bad lpSet");

    if (lpStr && lpSet)
    {
        // nature of the beast: O(lpStr*lpSet) work
        while (*lp)
        {
            if (StrChrIW(lpSet, *lp))
                return (int)(lp-lpStr);
            lp++;
        }
    }
    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}


/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS)
{
    if (lpStr1 && lpStr2)
    {
        LPCSTR lpszEnd = lpStr1 + nChar;
        char sz1[4];
        char sz2[4];

        if (fMBCS) {
            for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
                WORD w1;
                WORD w2;
        
                // If either pointer is at the null terminator already,
                // we want to copy just one byte to make sure we don't read 
                // past the buffer (might be at a page boundary).
        
                w1 = (*lpStr1) ? READNATIVEWORD(lpStr1) : 0;
                w2 = (*lpStr2) ? READNATIVEWORD(lpStr2) : 0;
        
                // (ChrCmpA returns FALSE if the characters match)
        
                // Do the characters match?
                if (ChrCmpA_inline(w1, w2)) 
                {
                    // No; determine the lexical value of the comparison
                    // (since ChrCmp just returns true/false).
        
                    // Since the character may be a DBCS character; we
                    // copy two bytes into each temporary buffer 
                    // (in preparation for the lstrcmp call).
        
                    (*(WORD *)sz1) = w1;
                    (*(WORD *)sz2) = w2;
        
                    // Add null terminators to temp buffers
                    *AnsiNext(sz1) = 0;
                    *AnsiNext(sz2) = 0;
                    return lstrcmpA(sz1, sz2);
                }
            }
        } else {
            for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
                if (*lpStr1 != *lpStr2) {
                    // No; determine the lexical value of the comparison
                    // (since ChrCmp just returns true/false).
                    sz1[0] = *lpStr1;
                    sz2[0] = *lpStr2;
                    sz1[1] = sz2[1] = '\0';
                    return lstrcmpA(sz1, sz2);
                }
            }
        }
    }
    
    return 0;
}

STDAPI_(int) StrCmpNA(LPCSTR psz1, LPCSTR psz2, int nChar)
{
    CPINFO cpinfo;

    RIPMSG(nChar == 0 || (psz1 && IS_VALID_STRING_PTRA(psz1, nChar)), "StrCmpNA: Caller passed bad psz1");
    RIPMSG(nChar == 0 || (psz2 && IS_VALID_STRING_PTRA(psz2, nChar)), "StrCmpNA: Caller passed bad psz2");
    RIPMSG(nChar >= 0, "StrCmpNA: caller passed bad nChar");

    return _StrCmpNA(psz1, psz2, nChar, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

// cch1 and cch2 are the maximum # of chars to compare

int _StrCmpLocaleW(DWORD dwFlags, LPCWSTR psz1, int cch1, LPCWSTR psz2, int cch2)
{
    int i = CompareStringW(GetThreadLocale(), dwFlags, psz1, cch1, psz2, cch2);
    if (!i)
    {
        i = CompareStringW(LOCALE_SYSTEM_DEFAULT, dwFlags, psz1, cch1, psz2, cch2);
    }
    return i - CSTR_EQUAL;
}

int _StrCmpLocaleA(DWORD dwFlags, LPCSTR psz1, int cch1, LPCSTR psz2, int cch2)
{
    int i = CompareStringA(GetThreadLocale(), dwFlags, psz1, cch1, psz2, cch2);
    if (!i)
    {
        i = CompareStringA(LOCALE_SYSTEM_DEFAULT, dwFlags, psz1, cch1, psz2, cch2);
    }
    return i - CSTR_EQUAL;
}


STDAPI_(int) StrCmpNW(LPCWSTR psz1, LPCWSTR psz2, int nChar)
{
    RIPMSG(nChar==0 || (psz1 && IS_VALID_STRING_PTRW(psz1, nChar)), "StrCmpNW: Caller passed bad psz1");
    RIPMSG(nChar==0 || (psz2 && IS_VALID_STRING_PTRW(psz2, nChar)), "StrCmpNW: Caller passed bad psz2");
    RIPMSG(nChar>=0, "StrCmpNA: caller passed bad nChar");

    return _StrCmpLocaleW(NORM_STOP_ON_NULL, psz1, nChar, psz2, nChar);
}

/*
 * Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */

int StrCmpNIA(LPCSTR psz1, LPCSTR psz2, int nChar)
{
    int nChar1, nChar2;

    RIPMSG(nChar==0 || (psz1 && IS_VALID_STRING_PTRA(psz1, nChar)), "StrCmpNIA: Caller passed bad psz1");
    RIPMSG(nChar==0 || (psz2 && IS_VALID_STRING_PTRA(psz2, nChar)), "StrCmpNIA: Caller passed bad psz2");
    RIPMSG(nChar>=0, "StrCmpNIA: caller passed bad nChar");

    // Include the (nChar && (!psz1 || !psz2)) cases here so we go through the
    // validation layer and return the appropriate invalid parameter error code
    // instead of faulting on Win95.
    //
    // NOTE!  That this means that StrCmpNI(NULL, NULL, 0) on NT returns -2
    // but StrCmpNI(NULL, NULL, 0) on Win9x returns 0.  This has always been
    // the case -- changing it is too scary for app compat reasons.
    //

    // NORM_STOP_ON_NULL is not supported by the ANSI version on NT
    // so we have to emulate it
    if (nChar && (!psz1 || !psz2))
    {
        // This is the error scenario we are forcing through
        nChar1 = nChar;
        nChar2 = nChar;
    }
    else
    {
        // nChar1 = min(nChar, lstrlen(psz1))
        // except that the "for" loop will not read more than nChar
        // characters from psz1 because psz1 might not be NULL-terminated
        for (nChar1 = 0; nChar1 < nChar && psz1[nChar1]; nChar1++) { }

        // And similarly for nChar2
        for (nChar2 = 0; nChar2 < nChar && psz2[nChar2]; nChar2++) { }
    }

    return _StrCmpLocaleA(NORM_IGNORECASE, psz1, nChar1, psz2, nChar2);
}

int StrCmpNIW(LPCWSTR psz1, LPCWSTR psz2, int nChar)
{
    RIPMSG(nChar==0 || (psz1 && IS_VALID_STRING_PTRW(psz1, nChar)), "StrCmpNIW: Caller passed bad psz1");
    RIPMSG(nChar==0 || (psz2 && IS_VALID_STRING_PTRW(psz2, nChar)), "StrCmpNIW: Caller passed bad psz2");
    RIPMSG(nChar>=0, "StrCmpNW: caller passed bad nChar");

    return _StrCmpLocaleW(NORM_IGNORECASE | NORM_STOP_ON_NULL, psz1, nChar, psz2, nChar);
}


/*
 * StrRStrI      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPSTR StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch)
{
    LPCSTR lpFound = NULL;

    RIPMSG(lpSource && IS_VALID_STRING_PTRA(lpSource, -1), "StrRStrIA: Caller passed bad lpSource");
    RIPMSG(!lpLast || (IS_VALID_STRING_PTRA(lpLast, -1) && lpLast>=lpSource && lpLast<=lpSource+lstrlenA(lpSource)), "StrRStrIA: Caller passed bad lpLast");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRA(lpSrch, -1) && *lpSrch, "StrRStrIA: Caller passed bad lpSrch");

    if (!lpLast)
        lpLast = lpSource + lstrlenA(lpSource);

    if (lpSource && lpSrch && *lpSrch)
    {
        WORD   wMatch;
        UINT   uLen;
        LPCSTR  lpStart;
        
        wMatch = READNATIVEWORD(lpSrch);
        wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));
        
        uLen = lstrlenA(lpSrch);
        lpStart = lpSource;
        while (*lpStart && (lpStart < lpLast))
        {
            if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
            {   
                if (StrCmpNIA(lpStart, lpSrch, uLen) == 0)
                    lpFound = lpStart;
            }   
            lpStart = AnsiNext(lpStart);
        }
    }
    return((LPSTR)lpFound);
}

LPWSTR StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch)
{
    LPCWSTR lpFound = NULL;

    RIPMSG(lpSource && IS_VALID_STRING_PTRW(lpSource, -1), "StrRStrIW: Caller passed bad lpSource");
    RIPMSG(!lpLast || (IS_VALID_STRING_PTRW(lpLast, -1) && lpLast>=lpSource && lpLast<=lpSource+lstrlenW(lpSource)), "StrRStrIW: Caller passed bad lpLast");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, -1) && *lpSrch, "StrRStrIW: Caller passed bad lpSrch");

    if (!lpLast)
        lpLast = lpSource + lstrlenW(lpSource);

    if (lpSource && lpSrch && *lpSrch)
    {
        WCHAR   wMatch;
        UINT    uLen;
        LPCWSTR  lpStart;

        wMatch = *lpSrch;
        uLen = lstrlenW(lpSrch);
        lpStart = lpSource;
        while (*lpStart && (lpStart < lpLast))
        {
            if (!ChrCmpIW(*lpStart, wMatch))
            {   
                if (StrCmpNIW(lpStart, lpSrch, uLen) == 0)
                    lpFound = lpStart;
            }   
            lpStart++;
        }
    }
    return((LPWSTR)lpFound);
}

/*
 * StrStr      - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRA(lpFirst, -1), "StrStrA: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRA(lpSrch, -1), "StrStrA: Caller passed bad lpSrch");

    if (lpFirst && lpSrch)
    {
        UINT uLen;
        WORD wMatch;
        CPINFO cpinfo;
        BOOL fMBCS = GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0];

        uLen = (UINT)lstrlenA(lpSrch);
        wMatch = READNATIVEWORD(lpSrch);

        for ( ; (lpFirst=_StrChrA(lpFirst, wMatch, fMBCS))!=0 && _StrCmpNA(lpFirst, lpSrch, uLen, fMBCS);
             lpFirst=AnsiNext(lpFirst))
            continue; /* continue until we hit the end of the string or get a match */
        return((LPSTR)lpFirst);
    }
    return(NULL);
}

LPWSTR StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, -1), "StrStrW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, -1), "StrStrW: Caller passed bad lpSrch");

    if (lpFirst && lpSrch)
    {
        UINT uLen;
        WCHAR wMatch;

        uLen = (UINT)lstrlenW(lpSrch);
        wMatch = *lpSrch;

        for ( ; (lpFirst=StrChrW(lpFirst, wMatch))!=0 && StrCmpNW(lpFirst, lpSrch, uLen);
             lpFirst++)
            continue; /* continue until we hit the end of the string or get a match */

        return (LPWSTR)lpFirst;
    }
    return NULL;
}

/*
 * StrStrN     - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
 
LPWSTR StrStrNW(LPCWSTR lpFirst, LPCWSTR lpSrch, UINT cchMax)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, cchMax), "StrStrW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, cchMax), "StrStrW: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen;
        WCHAR wMatch;
        LPCWSTR lpSentinel = lpFirst+cchMax;

        uLen = (UINT)lstrlenW(lpSrch);
        wMatch = *lpSrch;

        // the first two conditions in this loop signify failure when they eval to false,
        // while the third condition signifies success. We need to special case the second
        // condition at the end of the function because it doesn't automatically cause the
        // right value to be returned
        while((lpFirst=StrChrNW(lpFirst, wMatch, cchMax))!=0 && cchMax>=uLen &&StrCmpNW(lpFirst, lpSrch, uLen))
        {
            lpFirst++;
            cchMax=(UINT)(lpSentinel-lpFirst);
        }/* continue until we hit the end of the string or get a match */

        if(cchMax<uLen)
            return NULL;// we ran out of space
        return (LPWSTR)lpFirst;
    }
    return NULL;
}

/*
 * StrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRA(lpFirst, -1), "StrStrIA: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRA(lpSrch, -1), "StrStrIA: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen = (UINT)lstrlenA(lpSrch);
        WORD wMatch = READNATIVEWORD(lpSrch);

        for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 && StrCmpNIA(lpFirst, lpSrch, uLen);
             lpFirst=AnsiNext(lpFirst))
            continue; /* continue until we hit the end of the string or get a match */

        return (LPSTR)lpFirst;
    }
    return NULL;
}

LPWSTR StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, -1), "StrStrIW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, -1), "StrStrIW: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen = (UINT)lstrlenW(lpSrch);
        WCHAR wMatch = *lpSrch;

        for ( ; (lpFirst = StrChrIW(lpFirst, wMatch)) != 0 && StrCmpNIW(lpFirst, lpSrch, uLen);
             lpFirst++)
            continue; /* continue until we hit the end of the string or get a match */

        return (LPWSTR)lpFirst;
    }
    return NULL;
}

/*
 * StrStrNI   - Search for first occurrence of a substring, case insensitive, counted
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */

LPWSTR StrStrNIW(LPCWSTR lpFirst, LPCWSTR lpSrch, UINT cchMax)
{
    RIPMSG(lpFirst && IS_VALID_STRING_PTRW(lpFirst, cchMax), "StrStrNIW: Caller passed bad lpFirst");
    RIPMSG(lpSrch && IS_VALID_STRING_PTRW(lpSrch, cchMax), "StrStrNIW: Caller passed bad lpSrch");
    if (lpFirst && lpSrch)
    {
        UINT uLen = (UINT)lstrlenW(lpSrch);
        WCHAR wMatch = *lpSrch;
        LPCWSTR lpSentinel = lpFirst+cchMax;

        // the first two conditions in this loop signify failure when they eval to false,
        // while the third condition signifies success. We need to special case the second
        // condition at the end of the function because it doesn't automatically cause the
        // right value to be returned
        while((lpFirst = StrChrNIW(lpFirst, wMatch, cchMax)) != 0 && cchMax >= uLen && StrCmpNIW(lpFirst, lpSrch, uLen))
        {
            lpFirst++;
            cchMax = (UINT)(lpSentinel - lpFirst);
        }/* continue until we hit the end of the string or get a match */

        if(cchMax<uLen)
            return NULL;// we ran out of space
        return (LPWSTR)lpFirst;
    }
    return NULL;
}


LPSTR StrDupA(LPCSTR psz)
{
    LPSTR pszRet = NULL;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "StrDupA: Caller passed invalid psz");

    if (psz)
    {
        int cch = lstrlenA(psz) + 1;
        
        pszRet = (LPSTR)LocalAlloc(LPTR, cch * sizeof(char));
        if (pszRet)
        {
            StringCchCopyA(pszRet, cch, psz);
        }
    }

    return pszRet;
}

LPWSTR StrDupW(LPCWSTR psz)
{
    LPWSTR pszRet = NULL;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "StrDupW: Caller passed invalid psz");

    if (psz)
    {
        int cch = lstrlenW(psz) + 1;

        pszRet = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
        if (pszRet)
        {
            StringCchCopyW(pszRet, cch, psz);
        }
    }

    return pszRet;
}

void _StrOut(LPSTR pszDest, int cchDest, HMODULE hmod, UINT idRes, DWORD* pdwTimeS, int* pdigits, UINT iDiv)
{
    *pszDest = '\0';

    if (*pdigits)
    {
        DWORD dwCur = *pdwTimeS/iDiv;

        if (dwCur || iDiv==1) 
        {
            DWORD dwBase;
            CHAR szBuf[64], szTemplate[64];
            LPSTR pszBuf = szBuf;

            *pdwTimeS -= dwCur*iDiv;
            for (dwBase=1; dwCur/(dwBase*10); dwBase*=10);

            DebugMsg(DM_INTERVAL, TEXT("dwCur, dwBase, *pdwTimeS = %d, %d, %d"), dwCur, dwBase, *pdwTimeS);

            //
            // LATER: We could use atoi if we mathematically trancate
            //  the numbers based on digits.
            //
            for (;dwBase; dwBase/=10, pszBuf++) 
            {
                if (*pdigits) 
                {
                    DWORD i = dwCur/dwBase;
                    dwCur -= i*dwBase;
                    *pszBuf = '0'+(unsigned short)i;
                    (*pdigits)--;
                } 
                else 
                {
                    *pszBuf = '0';
                }
            }
            *pszBuf = '\0';

            MLLoadStringA(idRes, szTemplate, ARRAYSIZE(szTemplate));
            StringCchPrintfA(pszDest, cchDest, szTemplate, szBuf);
        }
    }
}

void _StrOutW(LPWSTR pszDest, int cchDest, HMODULE hmod, UINT idRes, DWORD* pdwTimeS, int* pdigits, UINT iDiv)
{
    *pszDest = L'\0';

    if (*pdigits)
    {
        DWORD dwCur = *pdwTimeS/iDiv;

        if (dwCur || iDiv==1) 
        {
            DWORD dwBase;
            WCHAR wszBuf[64], wszTemplate[64];
            LPWSTR pwszBuf = wszBuf;

            *pdwTimeS -= dwCur*iDiv;
            for (dwBase=1; dwCur/(dwBase*10); dwBase*=10);

            DebugMsg(DM_INTERVAL, TEXT("dwCur, dwBase, *pdwTimeS = %d, %d, %d"), dwCur, dwBase, *pdwTimeS);

            //
            // LATER: We could use atoi if we mathematically trancate
            //  the numbers based on digits.
            //
            for (;dwBase; dwBase/=10, pwszBuf++) 
            {
                if (*pdigits) 
                {
                    DWORD i = dwCur/dwBase;
                    dwCur -= i*dwBase;
                    *pwszBuf = L'0'+(unsigned short)i;
                    (*pdigits)--;
                } 
                else 
                {
                    *pwszBuf = L'0';
                }
            }
            *pwszBuf = L'\0';

            MLLoadStringW(idRes, wszTemplate, ARRAYSIZE(wszTemplate));
            StringCchPrintfW(pszDest, cchDest, wszTemplate, wszBuf);
        }
    }
}


BOOL _StrFromTimeInterval(LPSTR pszBuf, int cchBuf, DWORD dwTimeMS, int digits)
{
    char szTemp[128];
    DWORD dwTimeS = (dwTimeMS+500)/1000;

    DebugMsg(DM_INTERVAL, TEXT("dwTimeS = %d"), dwTimeS);

    _StrOut(szTemp, ARRAYSIZE(szTemp), g_hinst, IDS_HOUR, &dwTimeS, &digits, 3600);
    StringCchCopyA(pszBuf, cchBuf, szTemp);

    _StrOut(szTemp, ARRAYSIZE(szTemp), g_hinst, IDS_MIN, &dwTimeS, &digits, 60);
    StringCchCatA(pszBuf, cchBuf, szTemp);

    _StrOut(szTemp, ARRAYSIZE(szTemp), g_hinst, IDS_SEC, &dwTimeS, &digits, 1);
    StringCchCatA(pszBuf, cchBuf, szTemp);

    return TRUE;
}

BOOL _StrFromTimeIntervalW(LPWSTR pwszBuf, int cchBuf, DWORD dwTimeMS, int digits)
{
    WCHAR szTemp[128];
    DWORD dwTimeS = (dwTimeMS+500)/1000;

    DebugMsg(DM_INTERVAL, TEXT("dwTimeS = %d"), dwTimeS);

    _StrOutW(szTemp, ARRAYSIZE(szTemp), g_hinst, IDS_HOUR, &dwTimeS, &digits, 3600);
    StringCchCopyW(pwszBuf, cchBuf, szTemp);

    _StrOutW(szTemp, ARRAYSIZE(szTemp), g_hinst, IDS_MIN, &dwTimeS, &digits, 60);
    StringCchCatW(pwszBuf, cchBuf, szTemp);

    _StrOutW(szTemp, ARRAYSIZE(szTemp), g_hinst, IDS_SEC, &dwTimeS, &digits, 1);
    StringCchCatW(pwszBuf, cchBuf, szTemp);

    return TRUE;
}


//
//  This API converts a given time-interval (in msec) into a human readable
// string.
//
// Parameters:
//  pszOut   -- Specifies the string buffer. NULL is valid to query size.
//  cchMax   -- Specifies the size of buffer in char/WCHAR
//  dwTimeMS -- Specifies the time interval in msec
//  digits   -- Specifies the minimum number of digits to be displayed
//
// Returns:
//  Number of characters in the buffer (not including the terminator).
//
// Exmaples:
//  dwTimeMS digits     output
//   34000     3         34 sec
//   34000     2         34 sec
//   34000     1         30 sec
//   74000     3         1 min 14 sec
//   74000     2         1 min 10 sec
//   74000     1         1 min
//
int StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits)
{
    CHAR szBuf[256];
    int cchRet = 0;
    RIPMSG(!pszOut || IS_VALID_WRITE_BUFFER(pszOut, char, cchMax), "StrFromTimeIntervalA: Caller passed invalid pszOut");
    DEBUGWhackPathBufferA(pszOut, cchMax);
    if (_StrFromTimeInterval(szBuf, ARRAYSIZE(szBuf), dwTimeMS, digits)) 
    {
        if (pszOut) 
        {
            lstrcpynA(pszOut, szBuf, cchMax);
            cchRet = lstrlenA(pszOut);
        }
        else 
        {
            cchRet = lstrlenA(szBuf);
        }
    }
    return cchRet;
}

int StrFromTimeIntervalW(LPWSTR pwszOut, UINT cchMax, DWORD dwTimeMS, int digits)
{
    WCHAR wszBuf[256];
    int cchRet = 0;
    RIPMSG(!pwszOut || IS_VALID_WRITE_BUFFER(pwszOut, WCHAR, cchMax), "StrFromTimeIntervalW: Caller passed invalid pszOut");
    DEBUGWhackPathBufferW(pwszOut, cchMax);
    if (_StrFromTimeIntervalW(wszBuf, ARRAYSIZE(wszBuf), dwTimeMS, digits)) 
    {
        if (pwszOut) 
        {
            lstrcpynW(pwszOut, wszBuf, cchMax);
            cchRet = lstrlenW(pwszOut);
        }
        else 
        {
            cchRet = lstrlenW(wszBuf);
        }
    }
    return cchRet;
}

/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) 
{
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

    RIPMSG(lpString1 && IS_VALID_STRING_PTRA(lpString1, nChar), "StrIsIntlEqualA: Caller passed invalid lpString1");
    RIPMSG(lpString2 && IS_VALID_STRING_PTRA(lpString2, nChar), "StrIsIntlEqualA: Caller passed invalid lpString2");
    RIPMSG(nChar >= -1, "StrIsIntlEqualA: Caller passed invalid nChar");

    dwFlags |= NORM_STOP_ON_NULL;   // only supported on NT
    return 0 == _StrCmpLocaleA(dwFlags, lpString1, nChar, lpString2, nChar);
}

BOOL StrIsIntlEqualW(BOOL fCaseSens, LPCWSTR psz1, LPCWSTR psz2, int nChar) 
{
    RIPMSG(psz1 && IS_VALID_STRING_PTRW(psz1, nChar), "StrIsIntlEqualW: Caller passed invalid psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRW(psz2, nChar), "StrIsIntlEqualW: Caller passed invalid psz2");
    RIPMSG(nChar >= -1, "StrIsIntlEqualW: Caller passed invalid nChar");

    return 0 == _StrCmpLocaleW(fCaseSens ? NORM_STOP_ON_NULL : NORM_IGNORECASE | NORM_STOP_ON_NULL, 
        psz1, nChar, psz2, nChar);
}

// This is stolen from shell32 - util.c

#define LODWORD(_qw)    (DWORD)(_qw)

const short c_aOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

void Int64ToStr(LONGLONG n, LPWSTR lpBuffer)
{
    WCHAR szTemp[40];
    LONGLONG  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = L'0' + (WCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = L'\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT GetNLSGrouping(void)
{
    UINT grouping;
    LPWSTR psz;
    WCHAR szGrouping[32];

    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    grouping = 0;
    psz = szGrouping;
    for (;;)
    {
        if (*psz == L'0') break;             // zero - stop

        else if ((UINT)(*psz - L'0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - L'0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }
    return grouping;
}

// Sizes of various stringized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)

// takes a DWORD add commas etc to it and puts the result in the buffer
LPWSTR CommifyString(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[MAX_COMMA_NUMBER_SIZE], szSep[5];
    NUMBERFMTW nfmt;

    nfmt.NumDigits = 0;
    nfmt.LeadingZero = 0;
    nfmt.Grouping = GetNLSGrouping();
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder = 0;

    Int64ToStr(n, szNum);

    if (GetNumberFormatW(LOCALE_USER_DEFAULT, 0, szNum, &nfmt, pszBuf, cchBuf) == 0)
        StrCpyNW(pszBuf, szNum, cchBuf);

    return pszBuf;
}

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

LPWSTR StrFormatByteSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    RIPMSG(pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, WCHAR, cchBuf), "StrFormatByteSizeW: Caller passed invalid pszBuf");
    DEBUGWhackPathBufferW(pszBuf, cchBuf);
    if (pszBuf)
    {
        WCHAR szWholeNum[32], szOrder[32];
        int iOrder;

        // If the size is less than 1024, then the order should be bytes we have nothing
        // more to figure out
        if (n < 1024) 
        {
            wnsprintfW(szWholeNum, ARRAYSIZE(szWholeNum), L"%d", LODWORD(n));
            iOrder = 0;
        }
        else
        {
            UINT uInt, uLen, uDec;
            WCHAR szFormat[8];

            // Find the right order
            for (iOrder = 1; iOrder < ARRAYSIZE(c_aOrders) -1 && n >= 1000L * 1024L; n >>= 10, iOrder++);
                /* do nothing */

            uInt = LODWORD(n >> 10);
            CommifyString(uInt, szWholeNum, ARRAYSIZE(szWholeNum));
            uLen = lstrlenW(szWholeNum);
            if (uLen < 3)
            {
                uDec = LODWORD(n - (LONGLONG)uInt * 1024L) * 1000 / 1024;
                // At this point, uDec should be between 0 and 1000
                // we want get the top one (or two) digits.
                uDec /= 10;
                if (uLen == 2)
                    uDec /= 10;

                // Note that we need to set the format before getting the
                // intl char.
                StringCchCopyW(szFormat, ARRAYSIZE(szFormat), L"%02d");

                szFormat[2] = TEXT('0') + 3 - uLen;
                GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                               szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen);
                uLen = lstrlenW(szWholeNum);
                wnsprintfW(szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen, szFormat, uDec);
            }
        }

        MLLoadStringW(c_aOrders[iOrder], szOrder, ARRAYSIZE(szOrder));
        wnsprintfW(pszBuf, cchBuf, szOrder, szWholeNum);
    }
    return pszBuf;
}

// dw - the nubmer to be converted
// pszBuf - buffer for the resulting string
// cchBuf - Max characters in Buffer

LPSTR StrFormatByteSize64A(LONGLONG dw, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR szT[32];

    DEBUGWhackPathBuffer(pszBuf, cchBuf);

    StrFormatByteSizeW(dw, szT, SIZECHARS(szT));

    SHUnicodeToAnsi(szT, pszBuf, cchBuf);
    return pszBuf;
}

LPSTR StrFormatByteSizeA(DWORD dw, LPSTR pszBuf, UINT cchBuf)
{
    return StrFormatByteSize64A((LONGLONG)dw, pszBuf, cchBuf);
}

LPWSTR StrFormatKBSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    RIPMSG(pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, WCHAR, cchBuf), "StrFormatKBSizeW: Caller passed invalid pszBuf");
    DEBUGWhackPathBufferW(pszBuf, cchBuf);
    if (pszBuf)
    {
        static WCHAR s_szOrder[16] = {0};
        WCHAR szNum[64];

        if (s_szOrder[0] == TEXT('\0'))
            LoadStringW(HINST_THISDLL, IDS_ORDERKB, s_szOrder, ARRAYSIZE(s_szOrder));

        CommifyString((n + 1023) / 1024, szNum, ARRAYSIZE(szNum));

        wnsprintfW(pszBuf, cchBuf, s_szOrder, szNum);
    }
    return pszBuf;
}

LPSTR StrFormatKBSizeA(LONGLONG n, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[64];

    DEBUGWhackPathBufferA(pszBuf, cchBuf);

    StrFormatKBSizeW(n, szNum, ARRAYSIZE(szNum));

    SHUnicodeToAnsi(szNum, pszBuf, cchBuf);
    return pszBuf;
}

//  Win95 does not support the wide-char version of lstrcmp, lstrcmpi
//  Wrapper for lstrcmpW so it works on Win95

int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    RIPMSG(pwsz1 && IS_VALID_STRING_PTRW(pwsz1, -1), "StrCmpW: Caller passed invalid pwsz1");
    RIPMSG(pwsz2 && IS_VALID_STRING_PTRW(pwsz2, -1), "StrCmpW: Caller passed invalid pwsz2");

    return _StrCmpLocaleW(0, pwsz1, -1, pwsz2, -1);
}

// Wrapper for lstrcmpiW so it works on Win95

int StrCmpIW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    RIPMSG(pwsz1 && IS_VALID_STRING_PTRW(pwsz1, -1), "StrCmpIW: Caller passed invalid pwsz1");
    RIPMSG(pwsz2 && IS_VALID_STRING_PTRW(pwsz2, -1), "StrCmpIW: Caller passed invalid pwsz2");

    return _StrCmpLocaleW(NORM_IGNORECASE, pwsz1, -1, pwsz2, -1);
}


/*----------------------------------------------------------
Purpose: Trim the string pszTrimMe of any leading or trailing
         characters that are in pszTrimChars.

Returns: TRUE if anything was stripped

*/
STDAPI_(BOOL) StrTrimA(IN OUT LPSTR pszTrimMe, LPCSTR pszTrimChars)
{
    BOOL bRet = FALSE;

    RIPMSG(pszTrimMe && IS_VALID_STRING_PTRA(pszTrimMe, -1), "StrTrimA: Caller passed invalid pszTrimMe");
    RIPMSG(pszTrimChars && IS_VALID_STRING_PTRA(pszTrimChars, -1), "StrTrimA: Caller passed invalid pszTrimChars");
    if (pszTrimMe && pszTrimChars)
    {
        LPSTR psz;
        LPSTR pszStartMeat;
        LPSTR pszMark = NULL;
    
        /* Trim leading characters. */
        
        psz = pszTrimMe;
        
        while (*psz && StrChrA(pszTrimChars, READNATIVEWORD(psz)))
            psz = CharNextA(psz);
        
        pszStartMeat = psz;
        
        /* Trim trailing characters. */
        
        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)
        
        while (*psz)
        {
            if (StrChrA(pszTrimChars, READNATIVEWORD(psz)))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }
            psz = CharNextA(psz);
        }
        
        // Any trailing characters to clip?
        if (pszMark)
        {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
        }
        
        /* Relocate stripped string. */
        
        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchA(lstrlenA(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);
        
        ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    }
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Trim the string pszTrimMe of any leading or trailing
         characters that are in pszTrimChars.

Returns: TRUE if anything was stripped

*/
STDAPI_(BOOL) StrTrimW(IN OUT LPWSTR  pszTrimMe, LPCWSTR pszTrimChars)
{
    BOOL bRet = FALSE;

    RIPMSG(pszTrimMe && IS_VALID_STRING_PTRW(pszTrimMe, -1), "StrTrimW: Caller passed invalid pszTrimMe");
    RIPMSG(pszTrimChars && IS_VALID_STRING_PTRW(pszTrimChars, -1), "StrTrimW: Caller passed invalid pszTrimChars");
    if (pszTrimMe && pszTrimChars)
    {
        LPWSTR psz;
        LPWSTR pszStartMeat;
        LPWSTR pszMark = NULL;
    
        /* Trim leading characters. */
        
        psz = pszTrimMe;
        
        while (*psz && StrChrW(pszTrimChars, *psz))
            psz++;
        
        pszStartMeat = psz;
        
        /* Trim trailing characters. */
        
        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)
        
        while (*psz)
        {
            if (StrChrW(pszTrimChars, *psz))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }
            psz++;
        }
        
        // Any trailing characters to clip?
        if (pszMark)
        {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
        }
        
        /* Relocate stripped string. */
        
        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchW(lstrlenW(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);
        
        ASSERT(IS_VALID_STRING_PTRW(pszTrimMe, -1));
    }
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2
*/
LWSTDAPI_(int) StrCmpNCA(LPCSTR pch1, LPCSTR pch2, int n)
{
    if (n == 0)
        return 0;

    while (--n && *pch1 && *pch1 == *pch2)
    {
        pch1++;
        pch2++;
    }

    return *(unsigned char *)pch1 - *(unsigned char *)pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNCW(LPCWSTR pch1, LPCWSTR pch2, int n)
{
    if (n == 0)
        return 0;

    while (--n && *pch1 && *pch1 == *pch2)
    {
        pch1++;
        pch2++;
    }

    return *pch1 - *pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNICA(LPCSTR pch1, LPCSTR pch2, int n)
{
    int ch1, ch2;

    if (n != 0)
    {
        do {

            ch1 = *pch1++;
            if (ch1 >= 'A' && ch1 <= 'Z')
                ch1 += 'a' - 'A';

            ch2 = *pch2++;
            if (ch2 >= 'A' && ch2 <= 'Z')
                ch2 += 'a' - 'A';

        } while ( --n && ch1 && (ch1 == ch2) );

        return ch1 - ch2;
    }
    else
    {
        return 0;
    }
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNICW(LPCWSTR pch1, LPCWSTR pch2, int n)
{
    int ch1, ch2;

    if (n != 0)
    {

        do {

            ch1 = *pch1++;
            if (ch1 >= L'A' && ch1 <= L'Z')
                ch1 += L'a' - L'A';

            ch2 = *pch2++;
            if (ch2 >= L'A' && ch2 <= L'Z')
                ch2 += L'a' - L'A';

        } while ( --n && ch1 && (ch1 == ch2) );

        return ch1 - ch2;
    }
    else
    {
        return 0;
    }
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpCA(LPCSTR pch1, LPCSTR pch2)
{
    while (*pch1 && (*pch1 == *pch2))
    {
        ++pch1;
        ++pch2;
    }   

    return *(unsigned char *)pch1 - *(unsigned char *)pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpCW(LPCWSTR pch1, LPCWSTR pch2)
{
    while (*pch1 && (*pch1 == *pch2))
    {
        ++pch1;
        ++pch2;
    }   

    return *pch1 - *pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpICA(LPCSTR pch1, LPCSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= 'A' && ch1 <= 'Z')
            ch1 += 'a' - 'A';

        ch2 = *pch2++;
        if (ch2 >= 'A' && ch2 <= 'Z')
            ch2 += 'a' - 'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpICW(LPCWSTR pch1, LPCWSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= L'A' && ch1 <= L'Z')
            ch1 += L'a' - L'A';

        ch2 = *pch2++;
        if (ch2 >= L'A' && ch2 <= L'Z')
            ch2 += L'a' - L'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

LWSTDAPI StrRetToStrW(STRRET *psr, LPCITEMIDLIST pidl, WCHAR **ppsz)
{
    HRESULT hres = S_OK;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        *ppsz = psr->pOleStr;
        psr->pOleStr = NULL;   // avoid alias
        hres = *ppsz ? S_OK : E_FAIL;
        break;

    case STRRET_OFFSET:
        hres = SHStrDupA(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = SHStrDupA(psr->cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

LWSTDAPI StrRetToBSTR(STRRET *psr, LPCITEMIDLIST pidl, BSTR *pbstr)
{
    switch (psr->uType)
    {
    case STRRET_WSTR:
    {
        LPWSTR psz = psr->pOleStr;
        psr->pOleStr = NULL;  // avoid alias
        *pbstr = SysAllocString(psz);
        CoTaskMemFree(psz);
        break;
    }
    case STRRET_OFFSET:
        *pbstr = SysAllocStringA(STRRET_OFFPTR(pidl, psr));
        break;

    case STRRET_CSTR:
        *pbstr = SysAllocStringA(psr->cStr);
        break;

    default:
        *pbstr = NULL;
        return E_FAIL;
    }

    return (*pbstr) ? S_OK : E_OUTOFMEMORY;

}


HRESULT DupWideToAnsi(LPCWSTR pwsz, LPSTR *ppsz)
{
    UINT cch = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL) + 1;
    *ppsz = CoTaskMemAlloc(cch * sizeof(**ppsz));
    if (*ppsz)
    {
        SHUnicodeToAnsi(pwsz, *ppsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT DupAnsiToAnsi(LPCSTR psz, LPSTR *ppsz)
{
    int cch = lstrlenA(psz) + 1;

    *ppsz = (LPSTR)CoTaskMemAlloc(cch * sizeof(**ppsz));
    if (*ppsz) 
    {
        StringCchCopyA(*ppsz, cch, psz);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

LWSTDAPI StrRetToStrA(STRRET *psr, LPCITEMIDLIST pidl, CHAR **ppsz)
{
    HRESULT hres;
    LPWSTR pwsz;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        hres = DupWideToAnsi(psr->pOleStr, ppsz);
        pwsz = psr->pOleStr;
        psr->pOleStr = NULL;   // avoid alias
        CoTaskMemFree(pwsz);
        break;

    case STRRET_OFFSET:
        hres = DupAnsiToAnsi(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = DupAnsiToAnsi(psr->cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

STDAPI StrRetToBufA(STRRET *psr, LPCITEMIDLIST pidl, LPSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pszStr = psr->pOleStr;   // temp copy because SHUnicodeToAnsi may overwrite buffer
            if (pszStr)
            {
                SHUnicodeToAnsi(pszStr, pszBuf, cchBuf);
                CoTaskMemFree(pszStr);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;   
                psr->cStr[0] = 0;
                
                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToAnsi(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            SHAnsiToAnsi(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

STDAPI StrRetToBufW(STRRET *psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;
    
    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pwszTmp = psr->pOleStr;
            if (pwszTmp)
            {
                StrCpyNW(pszBuf, pwszTmp, cchBuf);
                CoTaskMemFree(pwszTmp);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;   
                psr->cStr[0] = 0;
                
                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToUnicode(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

// dupe a string using the task allocator for returing from a COM interface
//
STDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz)
{
    WCHAR *pwsz;
    DWORD cch;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "SHStrDupA: Caller passed invalid psz");

    if (psz)
    {
        cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
        pwsz = (WCHAR *)CoTaskMemAlloc((cch + 1) * SIZEOF(WCHAR));
    }
    else
        pwsz = NULL;

    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, *ppwsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

// dupe a string using the task allocator for returing from a COM interface
// Sometimes, due to structure packing, the pointer we get is not properly
// aligned for Win64, so we have to do UNALIGNED64.
//
STDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz)
{
    WCHAR *pwsz;
    int cb;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "SHStrDupW: Caller passed invalid psz");

    if (psz)
    {
        cb = (lstrlenW(psz) + 1) * SIZEOF(WCHAR);
        pwsz = (WCHAR *)CoTaskMemAlloc(cb);
    }
    else
        pwsz = NULL;
    
    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        CopyMemory(pwsz, psz, cb);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

 
STDAPI_(int) StrCmpLogicalW(PCWSTR psz1, PCWSTR psz2)
{
    int iRet = 0;
    int iCmpNum = 0;
    while (iRet == 0 && (*psz1 || *psz2))
    {
        int cch1 = 0;
        int cch2 = 0;
        BOOL fIsDigit1 = IS_DIGITW(*psz1);
        BOOL fIsDigit2 = IS_DIGITW(*psz2);
        ASSERT(fIsDigit1 == TRUE || fIsDigit1 == FALSE);
        ASSERT(fIsDigit2 == TRUE || fIsDigit2 == FALSE);
        //  using bit wise XOR as logical XOR
        //  if the numbers are mismatched then n
        if (fIsDigit1 ^ fIsDigit2)
        {
            iRet = _StrCmpLocaleW(NORM_IGNORECASE, psz1, -1, psz2, -1);
        }
        else if (fIsDigit1 && fIsDigit2)
        {
            int cchZero1 = 0;
            int cchZero2 = 0;

            // eat leading zeros
            while (*psz1 == TEXT('0'))
            {
                psz1++;
                cchZero1++;
            }

            while (*psz2 == TEXT('0'))
            {
                psz2++;
                cchZero2++;
            }
            
            while (IS_DIGITW(psz1[cch1])) 
                cch1++;

            while (IS_DIGITW(psz2[cch2])) 
                cch2++;

            if (cch1 != cch2)
            {
                iRet = cch1 > cch2 ? 1 : -1;
            }
            else 
            {
                //  remember the first numerical difference
                iRet = _StrCmpLocaleW(NORM_IGNORECASE, psz1, cch1, psz2, cch2);
                if (iRet == 0 && iCmpNum == 0 && cchZero1 != cchZero2)
                {
                    iCmpNum = cchZero2 > cchZero1 ? 1 : -1;
                }
            }
        }
        else
        {
            while (psz1[cch1] && !IS_DIGITW(psz1[cch1]))
                cch1++;

            while (psz2[cch2] && !IS_DIGITW(psz2[cch2]))
                cch2++;

            iRet = _StrCmpLocaleW(NORM_IGNORECASE, psz1, cch1, psz2, cch2);

        }

        //  at this point they should be numbers or terminators or different
        psz1 = &psz1[cch1];
        psz2 = &psz2[cch2];
    }

    if (iRet == 0 && iCmpNum)
        iRet = iCmpNum;
    
    return iRet;
}

STDAPI_(DWORD) StrCatChainW(LPWSTR pszDst, DWORD cchDst, DWORD ichAt, LPCWSTR pszSrc)
{
    RIPMSG(pszDst && IS_VALID_STRING_PTRW(pszDst, -1) && (DWORD)lstrlenW(pszDst)<cchDst && IS_VALID_WRITE_BUFFER(pszDst, WCHAR, cchDst), "StrCatChainW: Caller passed invalid pszDst");
    RIPMSG(pszSrc && IS_VALID_STRING_PTRW(pszSrc, -1), "StrCatChainW: Caller passed invalid pszSrc");
    
    if (ichAt == -1)
        ichAt = lstrlenW(pszDst);

    if (cchDst > 0)
    {
#ifdef DEBUG
        if (ichAt < cchDst)
            DEBUGWhackPathBufferW(pszDst+ichAt, cchDst-ichAt);
#endif
        while (ichAt < cchDst)
        {
            if (!(pszDst[ichAt] = *pszSrc++))
                break;
                
           ichAt++;
        }

        //  check to make sure we copied a NULL
        if (ichAt == cchDst)
            pszDst[ichAt-1] = 0;
    }

    return ichAt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\strtype.c ===
//+------------------------------------------------------------------------
//
//  File:       strtype.c
//
//  Contents:   widechar character type function (CT_CTYPE1) and (CT_CTYPE3)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------
#include "priv.h"

#define __BIT_SHIFT 0
#define __INDEX_SHIFT 5
#define __PAGE_SHIFT 8

#define __BIT_MASK 31
#define __INDEX_MASK 7

// straight lookup functions are inlined.

#define ISCHARFUNC(type, wch) \
    (adwData[abIndex[abType1##type[wch>>__PAGE_SHIFT]] \
                          [(wch>>__INDEX_SHIFT)&__INDEX_MASK]] \
            >> (wch&__BIT_MASK)) & 1 
    
const DWORD adwData[218] =
{
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
};

const BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

const BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL IsCharSpaceW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }
  
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

const BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

const BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL IsCharDigitW(WCHAR wch) { return ISCHARFUNC(Digit, wch); }

BOOL IsCharXDigitW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
}

const BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

const BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};


BOOL IsCharPunctW(WCHAR wch) { return ISCHARFUNC(Punct, wch); }


BOOL IsCharCntrlW(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL IsCharBlankW(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}


BOOL IsCharAlphaWrapW(WCHAR wch) { return ISCHARFUNC(Alpha, wch); }
BOOL IsCharUpperWrapW(WCHAR wch) { return ISCHARFUNC(Upper, wch); }
BOOL IsCharLowerWrapW(WCHAR wch) { return ISCHARFUNC(Lower, wch); }

BOOL IsCharAlphaNumericWrapW(WCHAR wch)
{
    return ISCHARFUNC(Alpha, wch) || ISCHARFUNC(Digit, wch);
}


static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
const aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};


//
//  CType 3 Flag Bits.
//
//  In the interest of reducing our table complexity, we've here a reduced
//  bitfield.  Only those bits currently used by IE4 are returned by
//  GetStringType3Ex().
//

// These are the flags are they are defined in winnls.h
//

// C3_NONSPACING    0x0001
// C3_DIACRITIC     0x0002
// C3_VOWELMARK     0x0004
// C3_SYMBOL        0x0008
// C3_KATAKANA      0x0010
// C3_HIRAGANA      0x0020
// C3_HALFWIDTH     0x0040
// C3_FULLWIDTH     0x0080
// C3_IDEOGRAPH     0x0100
// C3_KASHIDA       0x0200
// C3_LEXICAL       0x0400
// C3_ALPHA         0x8000

// The supported flags are encoded by shifting them to the right 3 bits.

// C3_SYMBOL       0x0001
// C3_KATAKANA     0x0002
// C3_HIRAGANA     0x0004
// C3_HALFWIDTH    0x0008
// C3_FULLWIDTH    0x0010
// C3_IDEOGRAPH    0x0020

// GetStringType3Ex returns the correct Win32 flags NOT the compressed flags.


BOOL 
GetStringType3ExW(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPWORD  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        WORD wCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                wCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                wCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                wCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                wCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    const struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    wCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    wCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = wCharType << 3;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\stream.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: stream.c
//
//  This file contains some of the stream support code that is used by
// the shell.  It also contains the shells implementation of a memory
// stream that is used by the cabinet to allow views to be serialized.
//
// History:
//  08-20-93 KurtE      Added header block and memory stream.
//
//---------------------------------------------------------------------------

#include "priv.h"
#include <new.h>
#include "nullstm.h"

// This code was stolen from shell32.  This is the BETTER_STRONGER_FASTER
// version (smaller and half the allocs), added after Win95 shipped.
#include "stream.h"

EXTERN_C HKEY SHRegDuplicateHKey(HKEY hkey);

// The Win95/NT4/IE4 code did not enforce the grfMode.  Turn this on to enforce:
//#define ENFORCE_GRFMODE // Note: I haven't tested compat issues with this turned on yet... [mikesh]


STDMETHODIMP CMemStream::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj=this;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CMemStream::AddRef()
{
    this->cRef++;
    return this->cRef;
}

BOOL CMemStream::WriteToReg()
{
    if (this->cbData)
    {
        return ERROR_SUCCESS == RegSetValueEx(this->hkey, 
            this->szValue[0] ? this->szValue : NULL, 0, REG_BINARY, 
            this->cbData ? this->pBuf : (LPBYTE)"", this->cbData);
    }
    else
    {
        DWORD dwRet = SHDeleteValue(this->hkey, NULL, this->szValue);

        // If the Stream is being stored in the default key, then
        // we should clean up the key. Otherwise, the caller
        // passed us the key, and they need it. It would be rude for us
        // to delete it. Fixes a Start Menu bug (NT#361333) where we would delete the
        // programs key where start menu stores it's stuff on a load, so we 
        // never persist anything. - lamadio (6.25.99)
        if (this->szValue[0] == TEXT('\0'))
        {
            SHDeleteEmptyKey(this->hkey, NULL);
        }

        return ERROR_SUCCESS == dwRet;
    }
}

STDMETHODIMP_(ULONG) CMemStream::Release()
{
    this->cRef--;
    if (this->cRef > 0)
        return this->cRef;

    // If this is backed up by the registry serialize the data
    if (this->hkey)
    {
        // Backed by the registry.
        // Write and cleanup.
        WriteToReg();
        RegCloseKey(this->hkey);
    }

    // Free the data buffer that is allocated to the stream
    if (this->pBuf)
        LocalFree(this->pBuf);

    LocalFree((HLOCAL)this);

    return 0;
}


STDMETHODIMP CMemStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_WRITE)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;
        return STG_E_ACCESSDENIED;
    }
#endif

    ASSERT(pv);

    // I guess a null read is ok.
    if (!cb)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;
        return S_OK;
    }

    if (this->iSeek >= this->cbData)
    {
        if (pcbRead != NULL)
            *pcbRead = 0;   // nothing read
    }

    else
    {
        if ((this->iSeek + cb) > this->cbData)
            cb = this->cbData - this->iSeek;

        // Now Copy the memory
        ASSERT(this->pBuf);
        CopyMemory(pv, this->pBuf + this->iSeek, cb);
        this->iSeek += (UINT)cb;

        if (pcbRead != NULL)
            *pcbRead = cb;
    }

    return S_OK;
}

LPBYTE CMemStream::GrowBuffer(ULONG cbNew)
{
    if (this->pBuf == NULL)
    {
        this->pBuf = (LPBYTE)LocalAlloc(LPTR, cbNew);
    }
    else
    {
        LPBYTE pTemp = (LPBYTE)LocalReAlloc(this->pBuf, cbNew, LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pTemp)
        {
            this->pBuf = pTemp;
        }
        else
        {
            TraceMsg(TF_ERROR, "Stream buffer realloc failed");
            return NULL;
        }
    }
    if (this->pBuf)
        this->cbAlloc = cbNew;

    return this->pBuf;
}

#define SIZEINCR    0x1000


STDMETHODIMP CMemStream::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ)
    {
        if (pcbWritten != NULL)
            *pcbWritten = 0;
        return STG_E_ACCESSDENIED;
    }
#endif

    // I guess a null write is ok.
    if (!cb)
    {
        if (pcbWritten != NULL)
            *pcbWritten = 0;
        return S_OK;
    }

    // See if the data will fit into our current buffer
    if ((this->iSeek + cb) > this->cbAlloc)
    {
        // enlarge the buffer
        // Give it a little slop to avoid a lot of reallocs.
        if (GrowBuffer(this->iSeek + (UINT)cb + SIZEINCR) == NULL)
            return STG_E_INSUFFICIENTMEMORY;
    }

    ASSERT(this->pBuf);

    // See if we need to fill the area between the data size and
    // the seek position
    if (this->iSeek > this->cbData)
    {
        ZeroMemory(this->pBuf + this->cbData, this->iSeek - this->cbData);
    }

    CopyMemory(this->pBuf + this->iSeek, pv, cb);  // buffer grown above
    this->iSeek += (UINT)cb;
    if (this->iSeek > this->cbData)
        this->cbData = this->iSeek;

    if (pcbWritten != NULL)
        *pcbWritten = cb;

    return S_OK;
}

STDMETHODIMP CMemStream::Seek(LARGE_INTEGER dlibMove,
               DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    LONG lNewSeek;

    // Note: curently not testing for error conditions for number wrap...
    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        lNewSeek = (LONG)dlibMove.LowPart;
        break;
    case STREAM_SEEK_CUR:
        lNewSeek = (LONG)this->iSeek + (LONG)dlibMove.LowPart;
        break;
    case STREAM_SEEK_END:
        lNewSeek = (LONG)this->cbData + (LONG)dlibMove.LowPart;
        break;
    default:
        return STG_E_INVALIDPARAMETER;
    }

    if (lNewSeek < 0)
        return STG_E_INVALIDFUNCTION;

    this->iSeek = (UINT)lNewSeek;

    if (plibNewPosition != NULL)
    {
        plibNewPosition->LowPart = (DWORD)lNewSeek;
        plibNewPosition->HighPart = 0;
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize(ULARGE_INTEGER libNewSize)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ)
    {
        return STG_E_ACCESSDENIED;
    }
#endif

    UINT cbNew = (UINT)libNewSize.LowPart;

    // See if the data will fit into our current buffer
    if (cbNew > this->cbData)
    {
        // See if we have to Enlarge the buffer.
        if (cbNew > this->cbAlloc)
        {
            // enlarge the buffer - Does not check wrap...
            // Give it a little slop to avoid a lot of reallocs.
            if (GrowBuffer(cbNew) == NULL)
                return STG_E_INSUFFICIENTMEMORY;
        }

        // Now fill some memory
        ZeroMemory(this->pBuf + this->cbData, cbNew - this->cbData);
    }

    // Save away the new size.
    this->cbData = cbNew;
    return S_OK;
}

STDMETHODIMP CMemStream::CopyTo(IStream *pstmTo,
             ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
#ifdef ENFORCE_GRFMODE
    if ((this->grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_WRITE)
    {
        if (pcbRead != NULL)
            ZeroMemory(pcbRead, sizeof(*pcbRead));
        if (pcbWritten != NULL)
            ZeroMemory(pcbWritten, sizeof(*pcbWritten));
        return STG_E_ACCESSDENIED;
    }
#endif

    HRESULT hres = S_OK;
    UINT cbRead = this->cbData - this->iSeek;
    ULONG cbWritten = 0;

    if (cb.HighPart == 0 && cb.LowPart < cbRead)
    {
        cbRead = cb.LowPart;
    }

    if (cbRead > 0)
    {
        hres = pstmTo->Write(this->pBuf + this->iSeek, cbRead, &cbWritten);
        this->iSeek += cbRead;
    }

    if (pcbRead)
    {
        pcbRead->LowPart = cbRead;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten)
    {
        pcbWritten->LowPart = cbWritten;
        pcbWritten->HighPart = 0;
    }

    return hres;
}

STDMETHODIMP CMemStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::LockRegion(ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb, DWORD dwLockType)

{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::UnlockRegion(ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// Trident calls this to determine the size of the structure.
// No reason to not support this one.
STDMETHODIMP CMemStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    ZeroMemory(pstatstg, sizeof(*pstatstg));

    // we have no name
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = this->cbData;
    // blow off modify, create, access times (we don't track anyway)
    pstatstg->grfMode = this->grfMode;
    // we're not transacting, so we have no lock modes
    // we're the null clsid already
    // we're not based on storage, so we have no state or storage bits
    
    return S_OK;
}

STDMETHODIMP CMemStream::Clone(IStream **ppstm)
{
    *ppstm = NULL;
    return E_NOTIMPL;
}

CMemStream *
CreateMemStreamEx(
    LPBYTE  pInit, 
    UINT    cbInit, 
    LPCTSTR pszValue)       OPTIONAL
{
    UINT cchValue = (pszValue ? lstrlen(pszValue) : 0);
    UINT l_cbAlloc = sizeof(CMemStream) + (cchValue * sizeof(TCHAR));   // null terminator for pszValue is taken care of by CMemStream.szValue[1]
    CMemStream *localthis = (CMemStream *)LocalAlloc(LPTR, l_cbAlloc);
    if (localthis) 
    {
        new (localthis) CMemStream;

        localthis->cRef = 1;

        // See if there is some initial data we should map in here.
        if ((pInit != NULL) && (cbInit > 0))
        {
            if (localthis->GrowBuffer(cbInit) == NULL)
            {
                // Could not allocate buffer!
                LocalFree((HLOCAL)localthis);
                return NULL;
            }

            localthis->cbData = cbInit;
            CopyMemory(localthis->pBuf, pInit, cbInit);
        }

        if (pszValue)
        {
            StringCchCopy(localthis->szValue, cchValue + 1, pszValue);
        }

        // We have no other value to set this to
        localthis->grfMode = STGM_READWRITE;

        return localthis;
    }
    return NULL;
}


STDAPI_(IStream *)
SHCreateMemStream(
    LPBYTE  pInit, 
    UINT    cbInit)
{
    CMemStream *localthis = CreateMemStreamEx(pInit, cbInit, NULL);
    if (localthis) 
        return localthis;
    return NULL;
}


//----------------------------------------------------------------------------
// Open a stream to the reg file given an open key.
// NB pszValue can be NULL.
//
// Win9x exported OpenRegStream which *always* returned a stream, even for read,
// even when there was no data there.  IE4 shell32 delegated to shlwapi's SHOpenRegStream
// which needs to support this sub-optimal behavior.  See NT5 bug 190878 (shell32 fault).
//
STDAPI_(IStream *)
SHOpenRegStreamW(
    HKEY    hkey, 
    LPCWSTR  pszSubkey, 
    LPCWSTR  pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = SHOpenRegStream2W(hkey, pszSubkey, pszValue, grfMode);
#ifndef UNIX
    if (!pstm)
        pstm = SHConstNullStream();
#endif
    return pstm;
}

STDAPI_(IStream *)
SHOpenRegStreamA(
    HKEY    hkey, 
    LPCSTR  pszSubkey, 
    LPCSTR  pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = SHOpenRegStream2A(hkey, pszSubkey, pszValue, grfMode);
#ifndef UNIX
    if (!pstm)
        pstm = SHConstNullStream();
#endif
    return pstm;
}

// We should add STGM_CREATE support to the shlwapi streams.  When saving out 
// streams, we currently create the stream with STGM_WRITE (but not STGM_CREATE) 
// so shlwapi goes to all the wasted trouble of reading the old stream data into 
// memory, only to throw it away when we write over it.
// 
// STGM_CREATE means "I don't care about the old values because I'm going to 
// overwrite them anyway."  (It really should be named STGM_TRUNCATEONOPEN.)
// 
STDAPI_(IStream *)
SHOpenRegStream2(
    HKEY    hkey, 
    LPCTSTR pszSubkey, 
    LPCTSTR pszValue,       OPTIONAL
    DWORD   grfMode)
{
    CMemStream *localthis;    // In bed with class...

    RIPMSG(IS_VALID_HANDLE(hkey, KEY), "SHOpenRegStream2: Caller passed invalid hkey");
    RIPMSG(!pszSubkey || IS_VALID_STRING_PTR(pszSubkey, -1), "SHOpenRegStream2: Caller passed invalid pszSubkey");
    RIPMSG(!pszValue || IS_VALID_STRING_PTR(pszValue, -1), "SHOpenRegStream2: Caller passed invalid pszValue");

    // Null keys are illegal.
    if (!hkey)
    {
        return NULL;
    }

    localthis = CreateMemStreamEx(NULL, 0, pszValue);
    if (!localthis)
        return NULL;       // Failed to allocate space

    localthis->grfMode = grfMode;

    // Get the hkey we're going to deal with
    //
    // Did the caller pass us a subkey, and does it contain a string?
    if (pszSubkey && *pszSubkey)
    {
        // Yes; Then try to bind to that key.

        // If this stream is one the user mentioned as wanting to write to
        // we need to save away the regkey and value.
        if ((grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) != STGM_READ)
        {
            // Store away the key.
            // write access required.
            if (RegCreateKeyEx(hkey, pszSubkey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &localthis->hkey, NULL) != ERROR_SUCCESS)
            {
                TraceMsg(TF_ERROR, "SHOpenRegStream: Unable to create key.");
                localthis->hkey = NULL; // be paranoid
            }
        }
        else if (RegOpenKeyEx(hkey, pszSubkey, 0, KEY_READ, &localthis->hkey) != ERROR_SUCCESS)
        {
            localthis->hkey = NULL; // be paranoid
        }
    }
    else
    {
        localthis->hkey = SHRegDuplicateHKey(hkey);
    }

    // we don't have an hkey, bail
    if (NULL == localthis->hkey)
    {
        localthis->Release();
        return NULL;
    }


    // Now see if we need to initialize the stream.
    if ((grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) != STGM_WRITE)
    {
        DWORD dwType;
        DWORD cbData;

        if ((RegQueryValueEx(localthis->hkey, pszValue, NULL, &dwType, NULL, &cbData) == ERROR_SUCCESS) && cbData)
        {
            if (localthis->GrowBuffer(cbData) != NULL)
            {
                ASSERT(localthis->cbAlloc >= cbData);

                // Get the data.
                RegQueryValueEx(localthis->hkey, pszValue, NULL, &dwType, localthis->pBuf, &cbData);

                localthis->cbData = cbData;
            }
            else
            {
                TraceMsg(TF_ERROR, "OpenRegStream: Unable to initialize stream to registry.");
                localthis->Release();
                return NULL;
            }
        }
    }

    // If the stream was opened read-only, then close the key so
    // CMemStream::Release won't try to write the "updates" back out to the
    // registry.
    if ((grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) == STGM_READ)
    {
        RegCloseKey(localthis->hkey);
        localthis->hkey = NULL;
    }

    return localthis;
}

#ifdef UNICODE
STDAPI_(IStream *)
SHOpenRegStream2A(
    HKEY    hkey, 
    LPCSTR  pszSubkey, 
    LPCSTR  pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = NULL;

    RIPMSG(IS_VALID_HANDLE(hkey, KEY), "SHOpenRegStream2A: Caller passed invalid hkey");
    RIPMSG(!pszSubkey || IS_VALID_STRING_PTRA(pszSubkey, -1), "SHOpenRegStream2A: Caller passed invalid pszSubkey");
    RIPMSG(!pszValue || IS_VALID_STRING_PTRA(pszValue, -1), "SHOpenRegStream2A: Caller passed invalid pszValue");

    WCHAR wszSubkey[MAX_PATH];
    if (pszSubkey)
    {
        if (!MultiByteToWideChar(CP_ACP, 0, pszSubkey, -1, wszSubkey, SIZECHARS(wszSubkey)))
            return NULL;
        pszSubkey = (LPCSTR)wszSubkey;
    }

    WCHAR wszValue[MAX_PATH];
    if (pszValue)
    {
        if (!MultiByteToWideChar(CP_ACP, 0, pszValue, -1, wszValue, SIZECHARS(wszValue)))
            return NULL;
        pszValue = (LPCSTR)wszValue;
    }

    pstm = SHOpenRegStream2W(hkey, (LPCWSTR)pszSubkey, (LPCWSTR)pszValue, grfMode);

    return pstm;
}
#else
STDAPI_(IStream *)
SHOpenRegStream2W(
    HKEY    hkey, 
    LPCWSTR pszSubkey, 
    LPCWSTR pszValue,       OPTIONAL
    DWORD   grfMode)
{
    IStream * pstm = NULL;

    RIPMSG(IS_VALID_HANDLE(hkey, KEY), "SHOpenRegStream2W: Caller passed invalid hkey");
    RIPMSG(!pszSubkey || IS_VALID_STRING_PTRW(pszSubkey, -1), "SHOpenRegStream2W: Caller passed invalid pszSubkey");
    RIPMSG(!pszValue || IS_VALID_STRING_PTRW(pszValue, -1), "SHOpenRegStream2W: Caller passed invalid pszValue");

    CHAR szSubkey[MAX_PATH];
    if (pszSubkey)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, pszSubkey, -1, szSubkey, SIZECHARS(szSubkey), NULL, NULL))
            return NULL;
        pszSubkey = (LPCWSTR)szSubkey;
    }

    CHAR szValue[MAX_PATH];
    if (pszValue)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, pszValue, -1, szValue, SIZECHARS(szValue), NULL, NULL))
            return NULL;
        pszValue = (LPCWSTR)szValue;
    }

    pstm = SHOpenRegStream2A(hkey, (LPCSTR)pszSubkey, (LPCSTR)pszValue, grfMode);

    return pstm;
}
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\threads.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    threads.h

Abstract:

    Win32 version of NT wait/timer/thread pool functions

Author:

    Richard L Firth (rfirth) 27-Feb-1998

Notes:

    Original code from NT5/gurdeep

Revision History:

    27-Feb-1998 rfirth
        Created

--*/

//
// manifests
//

#define TPS_IO_WORKER_SIGNATURE     0x49737054  // 'TpsI'
#define TPS_WORKER_SIGNATURE        0x4B737054  // 'TpsK'
#define TPS_TIMER_SIGNATURE         0x54737054  // 'TpsT'
#define TPS_WAITER_SIGNATURE        0x57577054  // 'TpsW'

#define MAX_WAITS   64

//
// global data
//

EXTERN_C BOOL g_bDllTerminating;
extern BOOL g_bTpsTerminating;
extern DWORD g_ActiveRequests;

//
// prototypes for internal functions
//

VOID
TerminateTimers(
    VOID
    );

VOID
TerminateWaiters(
    VOID
    );

VOID
TerminateWorkers(
    VOID
    );

//
// Prototypes for thread pool private functions
//

DWORD
StartThread(
    IN LPTHREAD_START_ROUTINE pfnFunction,
    OUT PHANDLE phThread,
    IN BOOL fSynchronize
    );

DWORD
TpsEnter(
    VOID
    );

#define TpsLeave() \
    ASSERT( 0 != g_ActiveRequests ); InterlockedDecrement((LPLONG)&g_ActiveRequests)

VOID
QueueNullFunc(
    IN HANDLE hThread
    );

#define THREAD_TYPE_WORKER      1
#define THREAD_TYPE_IO_WORKER   2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\time.cpp ===
#include "priv.h"

#include "ids.h"

#include <mluisupp.h>

#ifndef DATE_LTRREADING
#define DATE_LTRREADING           0x00000010    //FEATURE: figure out why we have to do this, and fix it. 
#define DATE_RTLREADING           0x00000020    
#endif

/*-------------------------------------------------------------------------
Purpose: Calls GetDateFormat and tries to replace the day with 
         a relative reference like "Today" or "Yesterday".

         Returns the count of characters written to pszBuf.
*/
int GetRelativeDateFormat(
    DWORD dwDateFlags, 
    DWORD * pdwFlags, 
    SYSTEMTIME * pstDate, 
    LPWSTR pszBuf, 
    int cchBuf)
{
    int cch;

    ASSERT(pdwFlags);
    ASSERT(pstDate);
    ASSERT(pszBuf);

    // Assume that no relative date is applied, so clear the bit
    // for now.
    *pdwFlags &= ~FDTF_RELATIVE;
    
    // Get the Win32 date format.  (GetDateFormat's return value includes
    // the null terminator.)
    cch = GetDateFormat(LOCALE_USER_DEFAULT, dwDateFlags, pstDate, NULL, pszBuf, cchBuf);
    if (0 < cch)
    {
        SYSTEMTIME stCurrentTime;
        int iDay = 0;   // 1 = today, -1 = yesterday, 0 = neither today nor yesterday.

        // Now see if the date merits a replacement to "Yesterday" or "Today".
        
        GetLocalTime(&stCurrentTime);      // get the current date 

        // Does it match the current day?
        if (pstDate->wYear == stCurrentTime.wYear   && 
            pstDate->wMonth == stCurrentTime.wMonth &&
            pstDate->wDay == stCurrentTime.wDay)
        {
            // Yes
            iDay = 1;
        }
        else 
        {
            // No; maybe it matches yesterday    
            FILETIME ftYesterday;
            SYSTEMTIME stYesterday;

            // Compute yesterday's date by converting to FILETIME,
            // subtracting one day, then converting back.
            SystemTimeToFileTime(&stCurrentTime, &ftYesterday);
            DecrementFILETIME(&ftYesterday, FT_ONEDAY);
            FileTimeToSystemTime(&ftYesterday, &stYesterday);

            // Does it match yesterday?
            if (pstDate->wYear == stYesterday.wYear   && 
                pstDate->wMonth == stYesterday.wMonth &&
                pstDate->wDay == stYesterday.wDay)
            {
                // Yes
                iDay = -1;
            }
        }

        // Should we try replacing the day?
        if (0 != iDay)
        {
            // Yes
            TCHAR szDayOfWeek[32];
            LPTSTR pszModifier;
            int cchDayOfWeek;

            cchDayOfWeek = MLLoadString((IDS_DAYSOFTHEWEEK + pstDate->wDayOfWeek), 
                                      szDayOfWeek, SIZECHARS(szDayOfWeek));

            // Search for the day of week text in the string we got back.
            // Depending on the user's regional settings, there might not
            // be a day in the long-date format...
            
            pszModifier = StrStr(pszBuf, szDayOfWeek);

            if (pszModifier)
            {
                // We found the day in the string, so replace it with
                // "Today" or "Yesterday"
                TCHAR szTemp[64];
                TCHAR szRelativeDay[32];
                int cchRelativeDay;
                int cchModifier;

                cchModifier = cchBuf - ((int)(pszModifier - pszBuf));

                // Save the tail end (the part after the "Monday" string) 
                StringCchCopy(szTemp, SIZECHARS(szTemp), &pszModifier[cchDayOfWeek]);
                
                // Load the appropriate string ("Yesterday" or "Today").
                // If the string is empty (localizers might need to do this
                // if this logic isn't locale-friendly), don't bother doing
                // anything.
                cchRelativeDay = MLLoadString((1 == iDay) ? IDS_TODAY : IDS_YESTERDAY, 
                                            szRelativeDay, SIZECHARS(szRelativeDay));
                if (0 < cchRelativeDay)
                {
                    // Make sure that we have enough room for the replacement
                    // (cch already accounts for the null terminator)
                    if (cch - cchDayOfWeek + cchRelativeDay <= cchBuf)
                    {
                        // copy the friendly name over the day of the week
                        StringCchCopy(pszModifier, cchModifier , szRelativeDay);

                        // put back the tail end
                        StringCchCat(pszModifier, cchModifier, szTemp);
                        cch = cch - cchDayOfWeek + cchRelativeDay;

                        *pdwFlags |= FDTF_RELATIVE;
                    }
                }
            }
        }
    }

    return cch;
}

#define LRM 0x200E // UNICODE Left-to-right mark control character
#define RLM 0x200F // UNICODE Left-to-right mark control character

/*-------------------------------------------------------------------------
Purpose: Constructs a displayname form of the file time.

         *pdwFlags may be NULL, in which case FDTF_DEFAULT is assumed.  Other
         valid flags are:

            FDTF_DEFAULT    "3/29/98 7:48 PM"
            FDTF_SHORTTIME  "7:48 PM"
            FDTF_SHORTDATE  "3/29/98"
            FDTF_LONGDATE   "Monday, March 29, 1998"
            FDTF_LONGTIME   "7:48:33 PM"
            FDTF_RELATIVE   only works with FDTF_LONGDATE.  If possible, 
                            replace the day with "Yesterday" or "Today":
                            "Yesterday, March 29, 1998"

         This function updates *pdwFlags to indicate which sections of the
         string were actually set.  For example, if FDTF_RELATIVE is passed
         in, but no relative date conversion was performed, then FDTF_RELATIVE
         is cleared before returning.

         If the date is the magic "Sorry, I don't know what date it is" value
         that FAT uses, then we return an empty string.

*/
STDAPI_(int) SHFormatDateTimeW(const FILETIME UNALIGNED *puft, DWORD *pdwFlags, LPWSTR pszBuf, UINT ucchBuf)
{
    int cchBuf = ucchBuf;
    int cchBufSav = cchBuf;
    FILETIME ftLocal, ftInput = *puft;       // allign the data

    ASSERT(IS_VALID_READ_PTR(puft, FILETIME));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, WCHAR, cchBuf));
    ASSERT(NULL == pdwFlags || IS_VALID_WRITE_PTR(pdwFlags, DWORD));

    DWORD dwFlags = 0; 
    FileTimeToLocalFileTime(&ftInput, &ftLocal);

    if (FILETIMEtoInt64(ftInput) == FT_NTFS_UNKNOWNGMT ||
        FILETIMEtoInt64(ftLocal) == FT_FAT_UNKNOWNLOCAL)
    {
        // This date is uninitialized.  Don't show a bogus "10/10/72" string.
        if (0 < cchBuf)
            *pszBuf = 0;
    }
    else if (0 < cchBuf)
    {
        int cch;
        SYSTEMTIME st;
        DWORD dwDateFlags = DATE_SHORTDATE;     // default
        DWORD dwTimeFlags = TIME_NOSECONDS;     // default

        dwFlags = pdwFlags ? *pdwFlags : FDTF_DEFAULT;

        // Initialize the flags we're going to use
        if (dwFlags & FDTF_LONGDATE)
            dwDateFlags = DATE_LONGDATE;
        else
            dwFlags &= ~FDTF_RELATIVE;      // can't show relative dates w/o long dates

        if (dwFlags & FDTF_LTRDATE)
            dwDateFlags |= DATE_LTRREADING;
        else if(dwFlags & FDTF_RTLDATE)
            dwDateFlags |= DATE_RTLREADING;

        if (dwFlags & FDTF_LONGTIME)
            dwTimeFlags &= ~TIME_NOSECONDS;

        FileTimeToSystemTime(&ftLocal, &st);

        cchBuf--;       // Account for null terminator first
        
        if (dwFlags & (FDTF_LONGDATE | FDTF_SHORTDATE))
        {
            // Get the date
            if (dwFlags & FDTF_RELATIVE)
                cch = GetRelativeDateFormat(dwDateFlags, &dwFlags, &st, pszBuf, cchBuf);
            else
                cch = GetDateFormat(LOCALE_USER_DEFAULT, dwDateFlags, &st, NULL, pszBuf, cchBuf);
            ASSERT(0 <= cch && cch <= cchBuf);

            if (0 < cch)
            {
                cch--;      // (null terminator was counted above, so don't count it again)
                ASSERT('\0'==pszBuf[cch]);
            }
            else
                dwFlags &= ~(FDTF_LONGDATE | FDTF_SHORTDATE);   // no date, so clear these bits
            cchBuf -= cch;
            pszBuf += cch;

            // Are we tacking on the time too?
            if (dwFlags & (FDTF_SHORTTIME | FDTF_LONGTIME))
            {
                // Yes; for long dates, separate with a comma, otherwise
                // separate with a space.
                if (dwFlags & FDTF_LONGDATE)
                {
                    WCHAR szT[8];
                    
                    cch = MLLoadString(IDS_LONGDATE_SEP, szT, SIZECHARS(szT));
                    StrCpyNW(pszBuf, szT, cchBuf);
                    int cchCopied = min(cchBuf, cch);
                    cchBuf -= cchCopied;
                    pszBuf += cchCopied;
                }
                else
                {
                    if (cchBuf>0)
                    {
                        *pszBuf++ = TEXT(' ');
                        *pszBuf = 0;          // (in case GetTimeFormat doesn't add anything)
                        cchBuf--;
                    }
                }
                // [msadek]; need to insert strong a Unicode control character to simulate
                // a strong run in the opposite base direction to enforce
                // correct display of concatinated string in all cases
                if (dwFlags & FDTF_RTLDATE)
                {
                    if (cchBuf>=2)
                    {
                        *pszBuf++ = LRM; // simulate an opposite run
                        *pszBuf++ = RLM; // force RTL display of the time part.
                        *pszBuf = 0;
                        cchBuf -= 2;
                    }
                }
                else if (dwFlags & FDTF_LTRDATE)
                {
                    if (cchBuf>=2)
                    {
                        *pszBuf++ = RLM; // simulate an opposite run
                        *pszBuf++ = LRM; // force LTR display of the time part.
                        *pszBuf = 0;
                        cchBuf -= 2;                    
                    }
                }
            }
        }

        if (dwFlags & (FDTF_SHORTTIME | FDTF_LONGTIME))
        {
            // Get the time
            cch = GetTimeFormat(LOCALE_USER_DEFAULT, dwTimeFlags, &st, NULL, pszBuf, cchBuf);
            if (0 < cch)
                cch--;      // (null terminator was counted above, so don't count it again)
            else
                dwFlags &= ~(FDTF_LONGTIME | FDTF_SHORTTIME);   // no time, so clear these bits
            cchBuf -= cch;
        }
    }

    if (pdwFlags)
        *pdwFlags = dwFlags;
        
    return cchBufSav - cchBuf;
}

STDAPI_(int) SHFormatDateTimeA(const FILETIME UNALIGNED *pft, DWORD *pdwFlags, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR wsz[256];
    int cchRet = SHFormatDateTimeW(pft, pdwFlags, wsz, SIZECHARS(wsz));
    if (0 < cchRet)
    {
        cchRet = SHUnicodeToAnsi(wsz, pszBuf, cchBuf);
    }
    else if (0 < cchBuf)
    {
        *pszBuf = 0;
    }
    return cchRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\tpstimer.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpstimer.cpp

Abstract:

    Contains Win32 thread pool services timer functions

    Contents:
        TerminateTimers
        SHCreateTimerQueue
        (IECreateTimerQueue)
        SHDeleteTimerQueue
        (IEDeleteTimerQueue)
        SHSetTimerQueueTimer
        (IESetTimerQueueTimer)
        (NTSetTimerQueueTimer)
        SHChangeTimerQueueTimer
        (IEChangeTimerQueueTimer)
        SHCancelTimerQueueTimer
        (IECancelTimerQueueTimer)
        (NTCancelTimerQueueTimer)
        (InitializeTimerThread)
        (TimerCleanup)
        (CreateDefaultTimerQueue)
        (DeleteDefaultTimerQueue)
        (CleanupDefaultTimerQueue)
        (TimerThread)
        (AddTimer)
        (ChangeTimer)
        (CancelTimer)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Notes:

    Code reworked in C++ from NT-specific C code written by Gurdeep Singh Pall
    (gurdeep)

Revision History:

    10-Feb-1998 rfirth
        Created

--*/

#include "priv.h"
#include "threads.h"
#include "tpsclass.h"

//
// functions
//

LWSTDAPI_(HANDLE)
SHCreateTimerQueue(
    VOID
    )
{
    return CreateTimerQueue();
}


LWSTDAPI_(BOOL)
SHDeleteTimerQueue(
    IN HANDLE hQueue
    )
{
    return DeleteTimerQueue(hQueue);
}

LWSTDAPI_(BOOL)
SHChangeTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod
    )
{
    return ChangeTimerQueueTimer(hQueue, hTimer, dwDueTime, dwPeriod);
}

LWSTDAPI_(BOOL)
SHCancelTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer
    )
{
    return DeleteTimerQueueTimer(hQueue, hTimer, INVALID_HANDLE_VALUE);
}

//  these we do alittle wrapping on.
LWSTDAPI_(HANDLE)
SHSetTimerQueueTimer(
    IN HANDLE hQueue,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    )
{
    //
    //  Translate the flags from TPS flags to WT flags.
    //
    DWORD dwWTFlags = 0;
    if (dwFlags & TPS_EXECUTEIO)    dwWTFlags |= WT_EXECUTEINIOTHREAD;
    if (dwFlags & TPS_LONGEXECTIME) dwWTFlags |= WT_EXECUTELONGFUNCTION;

    HANDLE hTimer;
    if (CreateTimerQueueTimer(&hTimer, hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, dwWTFlags))
    {
        return hTimer;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\tpsutil.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpsutil.cpp

Abstract:

    Comtains common utility functions for Win32 thread pool services

    Contents:
        StartThread
        TpsEnter
        QueueNullFunc
        (NullFunc)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Notes:

    Taken from NT-specific code written by Gurdeep Singh Pall (gurdeep)

Revision History:

    10-Feb-1998 rfirth
        Created

--*/

#include "priv.h"
#include "threads.h"

//
// private prototypes
//

PRIVATE
VOID
NullFunc(
    IN LPVOID pUnused
    );

//
// functions
//

DWORD
StartThread(
    IN LPTHREAD_START_ROUTINE pfnFunction,
    OUT PHANDLE phThread,
    IN BOOL fSynchronize
    )

/*++

Routine Description:

    This routine is used start a new thread in the pool. If required, we
    synchronize with the new thread using an auto-reset event that the new
    thread must signal once it has completed its initialization

Arguments:

    pfnFunction     - pointer to thread function to start

    phThread        - pointer to returned thread handle

    fSynchronize    - used to indicate if we need to synchronize with the new
                      thread before returning

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Out of memory

--*/

{
    HANDLE hSyncEvent = NULL;

    if (fSynchronize) {
        hSyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hSyncEvent == NULL) {
            return GetLastError();
        }
    }

    DWORD dwThreadId;
    HANDLE hThread;
    DWORD error = ERROR_SUCCESS;

    hThread = CreateThread(NULL,        // lpSecurityAttributes
                           0,           // dwStackSize (0 == same as init thread)
                           pfnFunction,
                           (LPVOID)hSyncEvent,
                           0,           // dwCreationFlags
                           &dwThreadId  // throw away
                           );
    if (hThread == NULL) {
        error = GetLastError();
    }
    if (hSyncEvent != NULL) {
        if (hThread != NULL) {

            DWORD status = WaitForSingleObject(hSyncEvent, INFINITE);

            if (status == WAIT_FAILED) {
                error = GetLastError();
            } else if (status == WAIT_TIMEOUT) {
                error = WAIT_TIMEOUT;
            } else if (status != WAIT_OBJECT_0) {
                error = ERROR_GEN_FAILURE; // ?
            }

            if (ERROR_SUCCESS != error)
            {
                CloseHandle(hThread);
                hThread = NULL;
            }
        }
        CloseHandle(hSyncEvent);
    }
    *phThread = hThread;
    return error;
}

DWORD
TpsEnter(
    VOID
    )

/*++

Routine Description:

    synchronize with thread shutting down via SHTerminateThreadPool(). If
    terminating because DLL is unloaded, return error else wait until
    termination completed

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_SHUTDOWN_IN_PROGRESS

--*/

{
    for (; ; ) {
        while (g_bTpsTerminating) {
            if (g_bDllTerminating) {
                return ERROR_SHUTDOWN_IN_PROGRESS; // error code?  looks valid -justmann
            }
            SleepEx(0, TRUE);
        }
        InterlockedIncrement((LPLONG)&g_ActiveRequests);
        if (!g_bTpsTerminating) {
            return ERROR_SUCCESS;
        }
        ASSERT( 0 != g_ActiveRequests );
        InterlockedDecrement((LPLONG)&g_ActiveRequests);
    }
}

VOID
QueueNullFunc(
    IN HANDLE hThread
    )

/*++

Routine Description:

    Queues NullFunc as an APC to hThread

Arguments:

    hThread - thread to queue for

Return Value:

    None.

--*/

{
    QueueUserAPC((PAPCFUNC)NullFunc, hThread, NULL);
}

PRIVATE
VOID
NullFunc(
    IN LPVOID pUnused
    )

/*++

Routine Description:

    NULL APC function. Used to allow TerminateThreadPool() to wake up dormant
    APC threads

Arguments:

    pUnused - unused argument pointer

Return Value:

    None.

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\tpswait.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpswait.cpp

Abstract:

    Contains Win32 thread pool services wait functions

    Contents:
        TerminateWaiters
        SHRegisterWaitForSingleObject
        SHUnregisterWait
        (InitializeWaitThreadPool)
        (FindWaitThreadInfo)
        (AddWait)
        (RemoveWait)
        (WaitThread)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Notes:

    Taken from NT-specific code written by Gurdeep Singh Pall (gurdeep)

Revision History:

    10-Feb-1998 rfirth
        Created

--*/

#include "priv.h"
#include "threads.h"
#include "tpsclass.h"
#include "tpswait.h"

//
// private prototypes
//

PRIVATE
DWORD
InitializeWaitThreadPool(
    VOID
    );

PRIVATE
DWORD
FindWaitThreadInfo(
    OUT CWaitThreadInfo * * pInfo
    );

PRIVATE
VOID
AddWait(
    IN OUT CWaitAddRequest * pRequest
    );

PRIVATE
VOID
RemoveWait(
    IN CWaitRemoveRequest * pRequest
    );

PRIVATE
VOID
WaitThread(
    IN HANDLE hEvent
    );

//
// global data
//

CDoubleLinkedList g_WaitThreads;
CCriticalSection_NoCtor g_WaitCriticalSection;
BOOL g_StartedWaitInitialization = FALSE;
BOOL g_CompletedWaitInitialization = FALSE;
BOOL g_bDeferredWaiterTermination = FALSE;

//
// functions
//

VOID
TerminateWaiters(
    VOID
    )

/*++

Routine Description:

    Terminate waiter threads and global variables

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_CompletedWaitInitialization) {
        g_WaitCriticalSection.Acquire();
        while (!g_WaitThreads.IsEmpty()) {

            CWaitThreadInfo * pInfo;

            pInfo = (CWaitThreadInfo *)g_WaitThreads.RemoveHead();

            HANDLE hThread = pInfo->GetHandle();

            pInfo->SetHandle(NULL);
            QueueNullFunc(hThread);
            SleepEx(0, FALSE);
        }
        g_WaitCriticalSection.Release();
        g_WaitCriticalSection.Terminate();
        g_StartedWaitInitialization = FALSE;
        g_CompletedWaitInitialization = FALSE;
    }
    if (TlsGetValue(g_TpsTls) == (LPVOID)TPS_WAITER_SIGNATURE) {
        g_bDeferredWaiterTermination = TRUE;
    }
}

LWSTDAPI_(HANDLE)
SHRegisterWaitForSingleObject(
    IN HANDLE hObject,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwWaitTime,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    This routine adds a new wait request to the pool of objects being waited on.

Arguments:

    hObject     - handle to the object to be waited on

    pfnCallback - routine called when the wait completes or a timeout occurs

    pContext    - opaque pointer passed in as an argument to pfnCallback

    dwWaitTime  - Timeout for the wait in milliseconds. 0 means dont timeout.

    lpszLibrary - if specified, name of library (DLL) to reference

    dwFlags     - flags modifying request:

                    SRWSO_NOREMOVE
                        - once the handle becomes signalled, do not remove it
                          from the handle array. Intended to be used with
                          auto-reset events which become unsignalled again as
                          soon as the waiting thread is made runnable

Return Value:

    HANDLE
        Success - Non-NULL handle of created wait object

        Failure - NULL. Call GetLastError() for error code

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    HANDLE hWait = NULL;
    DWORD error = ERROR_SUCCESS;

    if (g_bTpsTerminating) {
        error = ERROR_SHUTDOWN_IN_PROGRESS; // error code? looks valid - justmann
        goto exit;
    }

    if (dwFlags & SRWSO_INVALID_FLAGS) {
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //DWORD dwHandleFlags;
    //
    //if (!GetHandleInformation(hObject, &dwHandleFlags)) {
    //
    //    //
    //    // error == ERROR_SUCCESS returns GetHandleInformation() last error
    //    //
    //
    //    ASSERT(error == ERROR_SUCCESS);
    //
    //    goto exit;
    //}

    //
    // GetHandleInformation() doesn't work on Win95
    //

    if (WaitForSingleObject(hObject, 0) == WAIT_FAILED) {

        //
        // error == ERROR_SUCCESS returns WaitForSingleObject() last error
        //

        ASSERT(error == ERROR_SUCCESS);

        goto exit;
    }

    //
    // initialize wait thread pool if it isn't already done
    //

    if (!g_CompletedWaitInitialization) {
        error = InitializeWaitThreadPool();
        if (error != ERROR_SUCCESS) {
            goto exit;
        }
    }

    //
    // find or create a wait thread that can accomodate another wait request
    //

    CWaitThreadInfo * pInfo;

    error = FindWaitThreadInfo(&pInfo);
    if (error == ERROR_SUCCESS) {

        CWaitAddRequest request(hObject,
                                pfnCallback,
                                pContext,
                                dwWaitTime,
                                dwFlags,
                                pInfo
                                );

        //
        // queue an APC to the wait thread
        //

        BOOL bSuccess = QueueUserAPC((PAPCFUNC)AddWait,
                                     pInfo->GetHandle(),
                                     (ULONG_PTR)&request
                                     );

        ASSERT(bSuccess);

        if (bSuccess) {

            //
            // relinquish the timeslice until the other thread has initialized
            //

            request.WaitForCompletion();

            //
            // the returned handle is the address of the wait object copied to
            // the wait thread's stack
            //

            hWait = request.GetWaitPointer();
        }
        pInfo->Release();
    }

exit:

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
    }
    ASSERT( 0 != g_ActiveRequests );
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return hWait;
}

LWSTDAPI_(BOOL)
SHUnregisterWait(
    IN HANDLE hWait
    )

/*++

Routine Description:

    This routine removes the specified wait from the pool of objects being waited
    on. This routine will block until all callbacks invoked as a result of this
    wait have been executed. This function MUST NOT be invoked inside the
    callback routines.

Arguments:

    hWait   - 'handle' indentifying the wait request

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for error code

--*/

{
    InterlockedIncrement((LPLONG)&g_ActiveRequests);

    BOOL bSuccess = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hWait) {
        if (!g_bTpsTerminating) {

            CWaitThreadInfo * pInfo = ((CWait *)hWait)->GetThreadInfo();
            CWaitRemoveRequest request(hWait);

            //
            // lock the thread control block
            //

            pInfo->Acquire();

            //
            // queue an APC to the wait thread
            //

            if (QueueUserAPC((PAPCFUNC)RemoveWait,
                             pInfo->GetHandle(),
                             (ULONG_PTR)&request
                             )) {

                //
                // relinquish the timeslice until the other thread has initialized
                //

                request.WaitForCompletion();
                if (!(bSuccess = (request.GetWaitPointer() != NULL))) {
                    error = ERROR_OBJECT_NOT_FOUND; // error code? looks valid -justmann
                }
            }

            //
            // release lock to the thread control block
            //

            pInfo->Release();
        } else {
            error = ERROR_SHUTDOWN_IN_PROGRESS; // error code? looks valid -justmann
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
    }
    ASSERT( 0 != g_ActiveRequests );
    InterlockedDecrement((LPLONG)&g_ActiveRequests);
    return bSuccess;
}

//
// private functions
//

PRIVATE
DWORD
InitializeWaitThreadPool(
    VOID
    )

/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (!InterlockedExchange((LPLONG)&g_StartedWaitInitialization, TRUE)) {
        g_WaitCriticalSection.Init();
        g_WaitThreads.Init();
        g_CompletedWaitInitialization = TRUE;
    } else {

        //
        // relinquish the timeslice until the other thread has initialized
        //

        while (!g_CompletedWaitInitialization) {
            SleepEx(0, FALSE);  // Sleep(0) without an additional call/return
        }
    }
    return error;
}

PRIVATE
DWORD
FindWaitThreadInfo(
    OUT CWaitThreadInfo * * ppInfo
    )

/*++

Routine Description:

    Walks thru the list of wait threads and finds one which can accomodate
    another wait. If one is not found then a new thread is created.

    This routine returns with the thread's WaitThreadCriticalSecton owned if it
    is successful.

Arguments:

    ppInfo  - pointer to pointer to returned control block

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    HANDLE hThread = NULL;

    //
    // take exclusive lock to the wait threads list
    //

    g_WaitCriticalSection.Acquire();

    do {

        DWORD error;

        //
        // walk thru the list of Wait Threads and find a Wait thread that can
        // accomodate a new wait request
        //

        //
        // *Consider* finding a wait thread with least # of waits to facilitate
        // better load balancing of waits
        //

        for (CWaitThreadInfo * pInfo = (CWaitThreadInfo *)g_WaitThreads.Next();
             !g_WaitThreads.IsHead(pInfo);
             pInfo = (CWaitThreadInfo *)pInfo->Next()) {


            //
            // slight cheese: if hThread is not NULL then its because we just
            // created a new thread. We know we have g_WaitCriticalSection held
            // and no other thread can be accessing the new thread's control
            // block, so we can now write in the handle to be used in future
            // calls to QueueUserAPC. This saves us having to duplicate the
            // thread handle in the new thread
            //

            if (hThread != NULL) {
                pInfo->SetHandle(hThread);
            }

            //
            // take exclusive lock to the wait thread control block
            //

            pInfo->Acquire();

            //
            // wait threads can accomodate up to MAX_WAITS (WaitForMultipleObject
            // limit)
            //

            if (pInfo->IsAvailableEntry()) {

                //
                // found a thread with some wait slots available. Release lock
                // on the wait threads list
                //

                *ppInfo = pInfo;
                g_WaitCriticalSection.Release();
                return ERROR_SUCCESS;
            }

            //
            // release lock to thread control block
            //

            pInfo->Release();
        }

        //
        // if we reach here, we don't have any more wait threads so create more
        //

        error = StartThread((LPTHREAD_START_ROUTINE)WaitThread, &hThread, TRUE);

        //
        // if thread creation fails then return the failure to caller
        //

        if (error != ERROR_SUCCESS) {

            ASSERT(FALSE);

            g_WaitCriticalSection.Release();
            return error;
        }

        //
        // loop back now that we have created another thread and put new wait
        // request in new thread
        //

    } while(TRUE);
}

PRIVATE
VOID
AddWait(
    IN OUT CWaitAddRequest * pRequest
    )

/*++

Routine Description:

    This routine is used for adding waits to the wait thread. It is executed in
    an APC.

Arguments:

    pRequest    - pointer to request object

Return Value:

    None.

--*/

{
    if (!g_bTpsTerminating) {

        CWaitThreadInfo * pInfo = pRequest->GetThreadInfo();
        CWait * pWait = pInfo->GetFreeWaiter();

        //
        // copy relevant fields from request object. C++ knows how to pull CWait
        // object out of CWaitAddRequest object. Insert the wait request object in
        // the list of active waits, in increasing expiration time order
        //

        *pWait = *pRequest;
        pInfo->InsertWaiter(pWait);

        //
        // return to the caller the address of the wait object on the wait thread's
        // stack and indicate to the calling thread that this request is complete
        //

        pRequest->SetWaitPointer(pWait);
    }
    pRequest->SetComplete();
}

PRIVATE
VOID
RemoveWait(
    IN CWaitRemoveRequest * pRequest
    )

/*++

Routine Description:

    This routine is used for deleting the specified wait. It is executed in an
    APC.

Arguments:

    pRequest    - pointer to request object

Return Value:

    None.

--*/

{
    if (!g_bTpsTerminating) {
        if (!pRequest->GetWaitPointer()->GetThreadInfo()->RemoveWaiter(pRequest->GetWaitPointer())) {
            pRequest->SetWaitPointer(NULL);
        }
    }
    pRequest->SetComplete();
}

PRIVATE
VOID
WaitThread(
    IN HANDLE hEvent
    )

/*++

Routine Description:

    This routine is used for all waits in the wait thread pool

Arguments:

    hEvent  - event handle to signal once initialization is complete

Return Value:

    None.

--*/

{
    HMODULE hDll = LoadLibrary(g_cszShlwapi);

    ASSERT(hDll != NULL);
    ASSERT(g_TpsTls != 0xFFFFFFFF);

    TlsSetValue(g_TpsTls, (LPVOID)TPS_WAITER_SIGNATURE);

    CWaitThreadInfo waitInfo(&g_WaitThreads);

    SetEvent(hEvent);

    while (!g_bTpsTerminating || (g_ActiveRequests != 0)) {

        DWORD dwIndex = waitInfo.Wait(waitInfo.GetWaitTime());

        if (g_bTpsTerminating && (g_ActiveRequests == 0)) {
            break;
        }
        if (dwIndex == WAIT_TIMEOUT) {
            waitInfo.ProcessTimeouts();
#pragma warning(push)
#pragma warning(disable:4296)
        } else if ((dwIndex >= WAIT_OBJECT_0)
#pragma warning(pop)
                   && (dwIndex < (WAIT_OBJECT_0 + waitInfo.GetObjectCount()))) {
            waitInfo.ProcessCompletion(dwIndex);
        } else if ((dwIndex == 0xFFFFFFFF) && GetLastError() == ERROR_INVALID_HANDLE) {
            waitInfo.PurgeInvalidHandles();
        } else {

            ASSERT(dwIndex == WAIT_IO_COMPLETION);

        }
    }
    while (waitInfo.GetHandle() != NULL) {
        SleepEx(0, FALSE);
    }
    if (GetCurrentThreadId() == g_dwTerminationThreadId) {
        g_bTpsTerminating = FALSE;
        g_bDeferredWaiterTermination = FALSE;
        g_dwTerminationThreadId = 0;
    }
    FreeLibraryAndExitThread(hDll, ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\uniansi.c ===
//============================================================================
//
// UNICODE and ANSI conversion functions
//
//============================================================================

#include "priv.h"
#include <mlang.h>

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHAnsiToUnicodeNativeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   int | cchSrc |
 *
 *          Source buffer length, including terminating null.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeNativeCP(UINT uiCP,
                        LPCSTR pszSrc, int cchSrc,
                        LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(cchSrc == lstrlenA(pszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));
    ASSERT(pszSrc != NULL);
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszDst);
    ASSERT(cwchBuf);

    cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc, pwszDst, cwchBuf);
    if (cwchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cwchNeeded = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             NULL, 0);

        ASSERT(cwchRc == 0);        /* In case we fail later */
        if (cwchNeeded) {
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             pwsz, cwchNeeded);
                if (cwchRc) {
                    StrCpyNW(pwszDst, pwsz, cwchBuf);
                    cwchRc = cwchBuf;
                }
                LocalFree(pwsz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in MultiByteToWideChar");
    }

    return cwchRc;
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHAnsiToUnicodeInetCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified Internet code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be an Internet code page.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   int | cchSrc |
 *
 *          Source buffer length, including terminating null.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeInetCP(UINT uiCP,
                      LPCSTR pszSrc, int cchSrc,
                      LPWSTR pwszDst, int cwchBuf)
{
    int cchSrcT, cwchNeeded;
    int cwchRc = 0;             /* Assume failure */
    HRESULT hres;
    DWORD dwMode;

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(cchSrc == lstrlenA(pszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));
    ASSERT(pszSrc != NULL);
    ASSERT(uiCP == 1200 || uiCP == 65000 || uiCP == 65001);
    ASSERT(pwszDst);
    ASSERT(cwchBuf);

    cchSrcT = cchSrc;
    cwchNeeded = cwchBuf;

    dwMode = 0;
    hres = ConvertINetMultiByteToUnicode(&dwMode, uiCP, pszSrc,
                                         &cchSrcT, pwszDst, &cwchNeeded);
    if (SUCCEEDED(hres)) {
        if (cchSrcT >= cchSrc) {
            /*
             *  The output buffer was big enough; no double-buffering
             *  needed.
             */
            cwchRc = cwchNeeded;
        } else {
            /*
             *  The output buffer wasn't big enough.  Need to double-buffer.
             */
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                dwMode = 0;
                hres = ConvertINetMultiByteToUnicode(&dwMode, uiCP, pszSrc,
                                            &cchSrc, pwsz, &cwchNeeded);
                if (SUCCEEDED(hres)) {
                    StrCpyNW(pwszDst, pwsz, cwchBuf);
                    cwchRc = cwchBuf;
                }
                LocalFree(pwsz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in ConvertInetMultiByteToUnicode");
    }

    return cwchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicodeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified code page, which can be either a native
 *          Windows code page or an Internet code page.
 *          If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    RIPMSG(IS_VALID_STRING_PTRA(pszSrc, -1), "Caller of SHAnsiToUnicodeCP passed in a NULL pszSrc!");
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pszSrc == NULL) {
        pszSrc = "";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pwszDst && cwchBuf) {

        int cchSrc;

        pwszDst[0] = 0;         /* In case of error */

        cchSrc = lstrlenA(pszSrc) + 1;

        /*
         *  Decide what kind of code page it is.
         */
        switch (uiCP) {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // Fall through
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
            cwchRc = SHAnsiToUnicodeInetCP(uiCP, pszSrc, cchSrc, pwszDst, cwchBuf);
            break;

        default:
            cwchRc = SHAnsiToUnicodeNativeCP(uiCP, pszSrc, cchSrc, pwszDst, cwchBuf);
            break;
        }
    }

    return cwchRc;
}

// This function exists to make sure SHAnsiToAnsi and SHUnicodeToAnsi
// have the same return value.  Callers use SHTCharToAnsi and don't know
// when it callapses to SHAnsiToAnsi.
int SHAnsiToAnsi(LPCSTR pszSrc, LPSTR pszDst, int cchBuf)
{
    int cchRc = 0;          /* Assume failure */

    if (cchBuf)
    {
        // APP COMPAT! WARNING!  Sony PictureGear passes too-small buffers to
        // SHGetPathFromIDList (which uses SHAnsiToAnsi eventually), so we
        // must be careful to pass the actual buffer size to SHTruncateString
        // and not the theoretical maximum (rarely attained).

        LPSTR pszEnd = StrCpyNXA(pszDst, pszSrc, cchBuf);
        cchRc = (int)(pszEnd - pszDst) + 1;
        cchRc = SHTruncateString(pszDst, cchRc) + 1;
    }

    return cchRc;
}

// This function exists to make sure SHUnicodeToUnicode and SHUnicodeToAnsi
// have the same return value.  Callers use SHTCharToUnicode and don't know
// when it callapses to SHUnicodeToUnicode.
int SHUnicodeToUnicode(LPCWSTR pwzSrc, LPWSTR pwzDst, int cchBuf)
{
    return (int) (StrCpyNXW(pwzDst, pwzSrc, cchBuf) - pwzDst + 1); // size including terminator
}


/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicode |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *
 */

int
SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    return SHAnsiToUnicodeCP(CP_ACP, pszSrc, pwszDst, cwchBuf);
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHUnicodeToAnsiNativeCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   int | cwchSrc |
 *
 *          Number of characters in source buffer, including terminating
 *          null.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 */

int
SHUnicodeToAnsiNativeCP(UINT uiCP,
                        LPCWSTR pwszSrc, int cwchSrc,
                        LPSTR pszDst, int cchBuf)

{
    int cchRc = 0;          /* Assume failure */

#ifdef DEBUG
    BOOL fVerify = TRUE;
    BOOL fLossy;
    if (uiCP == CP_ACPNOVALIDATE) {
        // -1 means use CP_ACP, but do *not* verify
        // kind of a hack, but it's DEBUG and leaves 99% of callers unchanged
        uiCP = CP_ACP;
        fVerify = FALSE;
    }
#define USUALLY_NULL    (&fLossy)
#else
#define USUALLY_NULL    NULL
#endif

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(cwchSrc == lstrlenW(pwszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszSrc);
    ASSERT(pszDst);
    ASSERT(cchBuf);

    cchRc = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc, pszDst, cchBuf,
                                NULL, USUALLY_NULL);
    if (cchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cchNeeded = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc,
                                            NULL, 0, NULL, NULL);

        ASSERT(cchRc == 0);         /* In case we fail later */
        if (cchNeeded) {
            LPSTR psz = (LPSTR)LocalAlloc(LMEM_FIXED,
                                          cchNeeded * SIZEOF(CHAR));
            if (psz) {
                cchRc = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc,
                                            psz, cchNeeded, NULL, USUALLY_NULL);
                if (cchRc) {
                    // lstrcpyn doesn't check if it's chopping a DBCS char
                    // so we need to use SHTruncateString.
                    //
                    // Add 1 because SHTruncateString doesn't count
                    // the trailing null but we do
                    //
                    // Assert that we meet the preconditions for
                    // SHTruncateString to return a valid value.
                    //
                    ASSERT(cchRc > cchBuf);
                    cchRc = SHTruncateString(psz, cchBuf) + 1;
                    lstrcpynA(pszDst, psz, cchBuf);
                }
                LocalFree(psz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in WideCharToMultiByte");
    }

#ifdef DEBUG
    TBOOL(!fVerify || !fLossy);
#endif

    return cchRc;
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHUnicodeToAnsiInetCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified Internet code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be an Internet code page.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   int | cwchSrc |
 *
 *          Number of characters in source buffer, including terminating
 *          null.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 */

int
SHUnicodeToAnsiInetCP(UINT uiCP,
                      LPCWSTR pwszSrc, int cwchSrc,
                      LPSTR pszDst, int cchBuf)
{
    int cwchSrcT, cchNeeded;
    int cchRc = 0;          /* Assume failure */
    DWORD dwMode;
    HRESULT hres;

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(cwchSrc == lstrlenW(pwszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));
    ASSERT(uiCP == 1200 || uiCP == 65000 || uiCP == 65001);
    ASSERT(pwszSrc);
    ASSERT(pszDst);
    ASSERT(cchBuf);

    /*
     *  Note that not all encodings translate a null terminator into a null
     *  terminator, so we have to save the NUL for last.
     */

    cwchSrc--;                          /* Save the NUL for last */
    cwchSrcT = cwchSrc;
    cchNeeded = cchBuf - 1;             /* Save the NUL for last */

    dwMode = 0;                         /* Start fresh */
    hres = ConvertINetUnicodeToMultiByte(&dwMode, uiCP, pwszSrc,
                                         &cwchSrcT, pszDst, &cchNeeded);
    if (SUCCEEDED(hres)) {
        if (cwchSrcT >= cwchSrc) {
            /*
             *  The output buffer was big enough; no double-buffering
             *  needed.  Translate the NUL manually.
             */
            ASSERT(cchNeeded < cchBuf);
            pszDst[cchNeeded] = TEXT('\0');
            cchRc = cchNeeded + 1;
        } else {
            /*
             *  The output buffer wasn't big enough.  Need to double-buffer.
             */
            LPSTR psz = (LPSTR)LocalAlloc(LMEM_FIXED,
                                          cchNeeded * SIZEOF(CHAR));
            if (psz) {
                dwMode = 0;             /* Start fresh */
                hres = ConvertINetUnicodeToMultiByte(&dwMode, uiCP, pwszSrc,
                                            &cwchSrc, psz, &cchNeeded);
                if (SUCCEEDED(hres)) {
                    // lstrcpyn doesn't check if it's chopping a DBCS char
                    // so we need to use SHTruncateString.
                    //
                    // Add 1 because SHTruncateString doesn't count
                    // the trailing null but we do
                    //
                    // Assert that we meet the preconditions for
                    // SHTruncateString to return a valid value.
                    //
                    ASSERT(cchNeeded > cchBuf);
                    cchRc = SHTruncateString(psz, cchBuf) + 1;
                    lstrcpynA(pszDst, psz, cchBuf);
                }
                LocalFree(psz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in ConvertInetUnicodeToMultiByte");
    }

    return cchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHUnicodeToAnsiCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified code page, which can be either a native
 *          Windows code page or an Internet code page.
 *          If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 *
 */

int
SHUnicodeToAnsiCP(UINT uiCP, LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    int cchRc = 0;              /* Assume failure */
#ifdef DEBUG
#define GET_CP(uiCP)    (((uiCP) == CP_ACPNOVALIDATE) ? CP_ACP : (uiCP))
#else
#define GET_CP(uiCP)    uiCP
#endif

    RIPMSG(IS_VALID_STRING_PTRW(pwszSrc, -1), "Caller of SHUnicodeToAnsiCP passed in a NULL pwszSrc!");
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pwszSrc == NULL) {
        pwszSrc = L"";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pszDst && cchBuf) {

        int cwchSrc;

        pszDst[0] = 0;          /* In case of error */

        cwchSrc = lstrlenW(pwszSrc) + 1; /* Yes, Win9x has lstrlenW */

        /*
         *  Decide what kind of code page it is.
         */
        switch (GET_CP(uiCP)) {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // Fall through
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
            cchRc = SHUnicodeToAnsiInetCP(GET_CP(uiCP), pwszSrc, cwchSrc, pszDst, cchBuf);
            break;

        default:
            cchRc = SHUnicodeToAnsiNativeCP(uiCP, pwszSrc, cwchSrc, pszDst, cchBuf);
            break;
        }
    }

    return cchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHUnicodeToAnsi |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 *
 */

int
SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    return SHUnicodeToAnsiCP(CP_ACP, pwszSrc, pszDst, cchBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\tpswork.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpswork.cpp

Abstract:

    Contains Win32 thread pool services worker thread functions

    Contents:
        SHSetThreadPoolLimits
        SHTerminateThreadPool
        SHQueueUserWorkItem
        SHCancelUserWorkItems
        TerminateWorkers
        TpsEnter
        (InitializeWorkerThreadPool)
        (StartIOWorkerThread)
        (QueueIOWorkerRequest)
        (IOWorkerThread)
        (ExecuteIOWorkItem)

Author:

    Richard L Firth (rfirth) 10-Feb-1998

Environment:

    Win32 user-mode

Revision History:

    10-Feb-1998 rfirth
        Created

    12-Aug-1998 rfirth
        Rewritten for DEMANDTHREAD and LONGEXEC work items. Officially
        divergent from original which was based on NT5 base thread pool API

--*/

#include "priv.h"
#include "threads.h"
#include "tpsclass.h"

//
// private prototypes
//
struct WorkItem {
    LPTHREAD_START_ROUTINE  pfnCallback;
    LPVOID                  pContext;
    HMODULE                 hModuleToFree;
};

PRIVATE
VOID
ExecuteWorkItem(
    IN WorkItem *pItem
    );

//
// global data
//

BOOL g_bTpsTerminating = FALSE;

const char g_cszShlwapi[] = "SHLWAPI.DLL";

DWORD g_ActiveRequests = 0;
DWORD g_dwTerminationThreadId = 0;
BOOL g_bDeferredWorkerTermination = FALSE;



//
// functions
//

LWSTDAPI_(BOOL)
SHSetThreadPoolLimits(
    IN PSH_THREAD_POOL_LIMITS pLimits
    )

/*++

Routine Description:

    Change internal settings

Arguments:

    pLimits - pointer to SH_THREAD_POOL_LIMITS structure containing limits
              to set

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. See GetLastError() for more info

--*/

{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

LWSTDAPI_(BOOL)
SHTerminateThreadPool(
    VOID
    )

/*++

Routine Description:

    Required to clean up threads before unloading SHLWAPI

Arguments:

    None.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    if (InterlockedExchange((PLONG)&g_bTpsTerminating, TRUE)) {
        return TRUE;
    }

    //
    // wait until all in-progress requests have finished
    //

    while (g_ActiveRequests != 0) {
        SleepEx(0, FALSE);
    }

    //
    // kill all wait threads
    //

    TerminateWaiters();

    if (!g_bDeferredWaiterTermination) {
        g_dwTerminationThreadId = 0;
        g_bTpsTerminating = FALSE;
    } else {
        g_dwTerminationThreadId = GetCurrentThreadId();
    }
    return TRUE;
}

LWSTDAPI_(BOOL)
SHQueueUserWorkItem(
    IN LPTHREAD_START_ROUTINE pfnCallback,
    IN LPVOID pContext,
    IN LONG lPriority,
    IN DWORD_PTR dwTag,
    OUT DWORD_PTR * pdwId OPTIONAL,
    IN LPCSTR pszModule OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Queues a work item and associates a user-supplied tag for use by
    SHCancelUserWorkItems()

    N.B. IO work items CANNOT be cancelled due to the fact that they are
    queued as APCs and there is no OS support to revoke an APC

Arguments:

    pfnCallback - caller-supplied function to call

    pContext    - caller-supplied context argument to pfnCallback

    lPriority   - relative priority of non-IO work item. Default is 0

    dwTag       - caller-supplied tag for non-IO work item if TPS_TAGGEDITEM

    pdwId       - pointer to returned ID. Pass NULL if not required. ID will be
                  0 for an IO work item

    pszModule   - if specified, name of library (DLL) to load and free so that
                  the dll will reamin in our process for the lifetime of the work
                  item.

    dwFlags     - flags modifying request:

                    TPS_EXECUTEIO
                        - execute work item in I/O thread. If set, work item
                          cannot be tagged (and therefore cannot be subsequently
                          cancelled) and cannot have an associated priority
                          (both tag and priority are ignored for I/O work items)

                    TPS_TAGGEDITEM
                        - the dwTag field is meaningful

                    TPS_DEMANDTHREAD
                        - a thread will be created for this work item if one is
                          not currently available. DEMANDTHREAD work items are
                          queued at the head of the work queue. That is, they
                          get the highest priority

                    TPS_LONGEXECTIME
                        - caller expects this work item to take relatively long
                          time to complete (e.g. it could be in a UI loop). Work
                          items thus described remove a thread from the pool for
                          an indefinite amount of time

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. See GetLastError() for more info

--*/

{
    DWORD error;

    if (dwFlags & TPS_INVALID_FLAGS) {
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    error = TpsEnter();
    if (error != ERROR_SUCCESS) {
        goto exit;
    }

    ASSERT(!(dwFlags & TPS_EXECUTEIO));

    if (!(dwFlags & TPS_EXECUTEIO)) 
    {
        // Use NT Thread pool!

        WorkItem *pItem = new WorkItem;
        if (pItem)
        {
            pItem->pfnCallback = pfnCallback;
            pItem->pContext = pContext;
            if (pszModule && *pszModule)
            {
                pItem->hModuleToFree = LoadLibrary(pszModule);
            }
            ULONG uFlags = WT_EXECUTEDEFAULT;
            if (dwFlags & TPS_LONGEXECTIME)
                uFlags |= WT_EXECUTELONGFUNCTION;

            error = ERROR_SUCCESS;
            if (!QueueUserWorkItem((LPTHREAD_START_ROUTINE)ExecuteWorkItem, (PVOID)pItem, uFlags))
            {
                error = GetLastError();
                if (pItem->hModuleToFree)
                    FreeLibrary(pItem->hModuleToFree);

                delete pItem;
            }
        } 
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } 
    else
    { 
        error = ERROR_CALL_NOT_IMPLEMENTED;
    } 


    TpsLeave();

exit:

    BOOL success = TRUE;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;
    }
    return success;
}

LWSTDAPI_(DWORD)
SHCancelUserWorkItems(
    IN DWORD_PTR dwTagOrId,
    IN BOOL bTag
    )

/*++

Routine Description:

    Cancels one or more queued work items. By default, if ID is supplied, only
    one work item can be cancelled. If tag is supplied, all work items with same
    tag will be deleted

Arguments:

    dwTagOrId   - user-supplied tag or API-supplied ID of work item(s) to
                  cancel. Used as search key

    bTag        - TRUE if dwTagOrId is tag else ID

Return Value:

    DWORD
        Success - Number of work items successfully cancelled (0..0xFFFFFFFE)

        Failure - 0xFFFFFFFF. Use GetLastError() for more info

                    ERROR_SHUTDOWN_IN_PROGRESS
                        - DLL being unloaded/support terminated

--*/

{
    SetLastError(ERROR_ACCESS_DENIED);
    return 0xFFFFFFFF;
}

//
// private functions
//

PRIVATE
VOID
ExecuteWorkItem(
    IN WorkItem *pItem
    )

/*++

Routine Description:

    Executes a regular Work function. Runs in the NT thread pool

Arguments:

    pItem   - context information. Contains the worker function that needs to 
              be run and the hModule to free. We need to free it.

Return Value:

    None.

--*/

{
    HMODULE hModule = pItem->hModuleToFree;
    LPTHREAD_START_ROUTINE pfn = pItem->pfnCallback;
    LPVOID ctx = pItem->pContext;
    delete pItem;
#ifdef DEBUG
    HRESULT hrDebug = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (hrDebug == RPC_E_CHANGED_MODE)
    {
        ASSERTMSG(FALSE, "SHLWAPI Thread pool wrapper: Could not CoInitialize Appartment threaded. We got infected with an MTA!\n");
    }
    else
    {
        CoUninitialize();
    }
#endif

    // Do the work now
    pfn(ctx);

#ifdef DEBUG
    hrDebug = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (hrDebug == RPC_E_CHANGED_MODE)
    {
        ASSERTMSG(FALSE, "SHLWAPI Thread pool wrapper: Could not CoInitialize Appartment threaded. The task at %x forgot to CoUninitialize or "
                            "we got infected with an MTA!\n", pfn);
    }
    else
    {
        CoUninitialize();
    }
#endif

    if (hModule)
        FreeLibrary(hModule);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\uastrfnc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       uastrfnc.cpp
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA
//
//  Classes:
//
//  Functions:
//
//  History:    1-11-95   davepl   Created
//
//--------------------------------------------------------------------------

// NOTE (DavePl) None of these pay any heed to locale!

#include "priv.h"
#pragma  hdrstop

#ifdef ALIGNMENT_MACHINE

#ifdef UNIX
#define _alloca alloca
#endif /* UNIX */

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcpynW
//
//  Synopsis:   UNALIGNED UNICODE version of lstrcpyn
//
//  Arguments:  [lpString1]  -- dest string
//              [lpString2]  -- source string
//              [iMaxLength] -- max chars to copy
//
//  Returns:
//
//  History:    1-11-95   davepl   NT Port
//
//  Notes:
//
//--------------------------------------------------------------------------

UNALIGNED WCHAR *  ualstrcpynW(UNALIGNED WCHAR * lpString1,
                               UNALIGNED const WCHAR * lpString2,
                               int iMaxLength)
{
    UNALIGNED WCHAR * src;
    UNALIGNED WCHAR * dst;

    src = (UNALIGNED WCHAR *)lpString2;
    dst = lpString1;

    while(iMaxLength && *src)
    {
        *dst++ = *src++;
        iMaxLength--;
    }

    if ( iMaxLength )
    {
        *dst = '\0';
    }
    else
    {
        dst--;
        *dst = '\0';
    }
    return dst;
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcmpiW
//
//  Synopsis:   UNALIGNED UNICODE wrap of lstrcmpi
//
//  Arguments:  [dst] -- first string
//              [src] -- string to comapre to
//
//  Returns:
//
//  History:    1-11-95   davepl   Created
//              4-20-98   scotthan localized, bug 141655
//
//--------------------------------------------------------------------------
int ualstrcmpiW (UNALIGNED const WCHAR * dst, UNALIGNED const WCHAR * src)
{
    WCHAR  *pwszDst, *pwszSrc; 
    int    cb ;

    //  Make aligned copies on the stack if appropriate...
    //  PERF - not the most inefficient tact (scotthan)
    //  note: _alloca should always succeed, unless out of stack
    if( IS_ALIGNED( dst ) )
        pwszDst = (WCHAR*)dst ;
    else
    {
        cb = (ualstrlenW( dst ) + 1) * sizeof(WCHAR) ;
        pwszDst = (WCHAR*)_alloca( cb ) ;
        if (pwszDst)
        {
            CopyMemory( pwszDst, dst, cb ) ;
        }
    }

    if( IS_ALIGNED( src ) )
        pwszSrc = (WCHAR*)src ;
    else
    {
        cb = (ualstrlenW( src ) + 1) * sizeof(WCHAR) ;
        pwszSrc = (WCHAR*)_alloca( cb ) ;
        if (pwszSrc)
        {
            CopyMemory( pwszSrc, src, cb ) ;
        }
    }

    //  Call the aligned method.
    //  Note: if this ever runs on Win95, we should call StrCmpIW instead.
    return lstrcmpiW( pwszDst, pwszSrc ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcmpW
//
//  Synopsis:   UNALIGNED UNICODE wrap of lstrcmp
//
//  Arguments:  [dst] -- first string
//              [src] -- string to comapre to
//
//  Returns:
//
//  History:    1-11-95   davepl   Created
//              4-29-98   scotthan localized, bug 164091
//
//--------------------------------------------------------------------------
int ualstrcmpW (UNALIGNED const WCHAR * src, UNALIGNED const WCHAR * dst)
{
    WCHAR  *pwszDst, *pwszSrc; 
    int    cb ;

    //  Make aligned copies on the stack if appropriate...
    //  PERF - not the most inefficient tact (scotthan)
    //  note: _alloca should always succeed, unless out of stack
    if( IS_ALIGNED( dst ) )
        pwszDst = (WCHAR*)dst ;
    else
    {
        cb = (ualstrlenW( dst ) + 1) * sizeof(WCHAR) ;
        pwszDst = (WCHAR*)_alloca( cb ) ;
        if (pwszDst)
        {
            CopyMemory( pwszDst, dst, cb ) ;
        }
    }

    if( IS_ALIGNED( src ) )
        pwszSrc = (WCHAR*)src ;
    else
    {
        cb = (ualstrlenW( src ) + 1) * sizeof(WCHAR) ;
        pwszSrc = (WCHAR*)_alloca( cb ) ;
        if (pwszSrc)
        {
            CopyMemory( pwszSrc, src, cb ) ;
        }
    }

    //  Call the aligned method.
    //  Note: if this ever runs on Win95, we should call StrCmpW instead.
    return lstrcmpW( pwszDst, pwszSrc ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrlenW
//
//  Synopsis:   UNALIGNED UNICODE version of lstrlen
//
//  Arguments:  [wcs] -- string to return length of
//
//  Returns:
//
//  History:    1-11-95   davepl   NT Port
//
//  Notes:
//
//--------------------------------------------------------------------------

size_t ualstrlenW (UNALIGNED const WCHAR * wcs)
{
    UNALIGNED const WCHAR *eos = wcs;

    while( *eos++ )
    {
        NULL;
    }

    return( (size_t) (eos - wcs - 1) );
}

//+-------------------------------------------------------------------------
//
//  Function:   ualstrcpyW
//
//  Synopsis:   UNALIGNED UNICODE version of lstrcpy
//
//  Arguments:  [dst] -- string to copy to
//              [src] -- string to copy from
//
//  Returns:
//
//  History:    1-11-95   davepl   NT Port
//
//  Notes:
//
//--------------------------------------------------------------------------

UNALIGNED WCHAR * ualstrcpyW(UNALIGNED WCHAR * dst, UNALIGNED const WCHAR * src)
{
    UNALIGNED WCHAR * cp = dst;

    while( *cp++ = *src++ )
        NULL ;

    return( dst );
}

#endif // ALIGNMENT_MACHINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\tpsclass.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tpsclass.h

Abstract:

    Basic classes for Win32 thread pool services functions

    Contents:
        CCriticalSection_NoCtor
        CCriticalSection
        CDoubleLinkedListEntry
        CDoubleLinkedList
        CTimedListEntry
        CTimedList
        CPrioritizedListEntry
        CPrioritizedList

Author:

    Richard L Firth (rfirth) 11-Feb-1998

Notes:

    Some of these classes have no constructor so that we avoid requiring global
    object initialization (via main() e.g.) Therefore, these objects must be
    explicitly initialized through the Init() member

Revision History:

    11-Feb-1998 rfirth
        Created

--*/

// These linked-list helper macros and types are taken from
// ntdef.h and ntrtl.h.  We don't want to include those because
// we have no other reason, and including the nt headers as a
// win32 component causes compilation conflicts.

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
// data
//

extern const char g_cszShlwapi[];
extern DWORD g_ActiveRequests;
extern DWORD g_dwTerminationThreadId;
extern BOOL g_bTpsTerminating;
extern BOOL g_bDeferredWorkerTermination;
extern BOOL g_bDeferredWaiterTermination;
extern BOOL g_bDeferredTimerTermination;

EXTERN_C DWORD g_TpsTls;
EXTERN_C BOOL g_bDllTerminating;

//
// macros
//

#if !defined(ARRAY_ELEMENTS)
#define ARRAY_ELEMENTS(array)   (sizeof(array)/sizeof(array[0]))
#endif

#if !defined(LAST_ELEMENT)
#define LAST_ELEMENT(array)     (ARRAY_ELEMENTS(array) - 1)
#endif

#if !defined(FT2LL)
#define FT2LL(x)                (*(LONGLONG *)&(x))
#endif

//
// classes
//

//
// CCriticalSection_NoCtor - critical section class without constructor or
// destructor for use in global variables
//

class CCriticalSection_NoCtor {

private:

    CRITICAL_SECTION m_critsec;

public:

    VOID Init(VOID) {
        InitializeCriticalSection(&m_critsec);
    }

    VOID Terminate(VOID) {
        DeleteCriticalSection(&m_critsec);
    }

    VOID Acquire(VOID) {
        EnterCriticalSection(&m_critsec);
    }

    VOID Release(VOID) {
        LeaveCriticalSection(&m_critsec);
    }
};

//
// CCriticalSection
//

class CCriticalSection : public CCriticalSection_NoCtor {

public:

    CCriticalSection() {
        Init();
    }

    ~CCriticalSection() {
        Terminate();
    }
};

//
// CDoubleLinkedListEntry/CDoubleLinkedList
//

#define CDoubleLinkedList CDoubleLinkedListEntry

class CDoubleLinkedListEntry {

private:

    LIST_ENTRY m_List;

public:

    VOID Init(VOID) {
        InitializeListHead(&m_List);
    }

    CDoubleLinkedListEntry * Head(VOID) {
        return (CDoubleLinkedListEntry *)&m_List;
    }

    CDoubleLinkedListEntry * Next(VOID) {
        return (CDoubleLinkedListEntry *)m_List.Flink;
    }

    CDoubleLinkedListEntry * Prev(VOID) {
        return (CDoubleLinkedListEntry *)m_List.Blink;
    }

    BOOL IsHead(CDoubleLinkedListEntry * pEntry) {
        return pEntry == Head();
    }

    VOID InsertHead(CDoubleLinkedList * pList) {
        InsertHeadList(&pList->m_List, &m_List);
    }

    VOID InsertTail(CDoubleLinkedList * pList) {
        InsertTailList(&pList->m_List, &m_List);
    }

    VOID Remove(VOID) {
        RemoveEntryList(&m_List);
    }

    CDoubleLinkedListEntry * RemoveHead(VOID) {

        //
        // APPCOMPAT - (compiler?) for some reason, the line:
        //
        //  return (CDoubleLinkedListEntry *)RemoveHeadList(&List);
        //
        // returns the Flink pointer, but doesn't remove it from List
        //

        PLIST_ENTRY pEntry = RemoveHeadList(&m_List);

        return (CDoubleLinkedListEntry *)pEntry;
    }

    CDoubleLinkedListEntry * RemoveTail(VOID) {

        //
        // APPCOMPAT - see RemoveHead()
        //

        PLIST_ENTRY pEntry = RemoveTailList(&m_List);

        return (CDoubleLinkedListEntry *)pEntry;
    }

    BOOL IsEmpty(VOID) {
        return IsListEmpty(&m_List);
    }

    CDoubleLinkedListEntry * FindEntry(CDoubleLinkedListEntry * pEntry) {
        for (CDoubleLinkedListEntry * p = Next(); p != Head(); p = p->Next()) {
            if (p == pEntry) {
                return pEntry;
            }
        }
        return NULL;
    }
};

//
// CTimedListEntry/CTimedList
//

#define CTimedList CTimedListEntry

class CTimedListEntry : public CDoubleLinkedListEntry {

private:

    DWORD m_dwTimeStamp;
    DWORD m_dwWaitTime;

public:

    CTimedListEntry() {
    }

    CTimedListEntry(DWORD dwWaitTime) {
        m_dwTimeStamp = GetTickCount();
        m_dwWaitTime = dwWaitTime;
    }

    VOID Init(VOID) {
        CDoubleLinkedListEntry::Init();
        m_dwTimeStamp = 0;
        m_dwWaitTime = 0;
    }

    DWORD GetTimeStamp(VOID) const {
        return m_dwTimeStamp;
    }

    VOID SetTimeStamp(DWORD dwTimeStamp = GetTickCount()) {
        m_dwTimeStamp = dwTimeStamp;
    }

    DWORD GetWaitTime(VOID) const {
        return m_dwWaitTime;
    }

    VOID SetWaitTime(DWORD dwWaitTime) {
        m_dwWaitTime = dwWaitTime;
    }

    VOID SetExpirationTime(DWORD dwWaitTime) {
        SetTimeStamp();
        SetWaitTime(dwWaitTime);
    }

    BOOL IsTimedOut(DWORD dwTimeNow = GetTickCount()) const {
        return (m_dwWaitTime != INFINITE)
            ? (dwTimeNow >= (m_dwTimeStamp + m_dwWaitTime))
            : FALSE;
    }

    BOOL IsInfiniteTimeout(VOID) const {
        return (m_dwWaitTime == INFINITE);
    }

    DWORD ExpiryTime(VOID) const {
        return m_dwTimeStamp + m_dwWaitTime;
    }

    DWORD TimeToWait(DWORD dwTimeNow = GetTickCount()) {

        DWORD expiryTime = ExpiryTime();

        return IsInfiniteTimeout()
            ? INFINITE
            : ((dwTimeNow >= expiryTime)
                ? 0
                : expiryTime - dwTimeNow);
    }

    //BOOL InsertFront(CDoubleLinkedList * pList) {
    //
    //    DWORD dwExpiryTime = ExpiryTime();
    //    CTimedListEntry * pEntry;
    //
    //    for (pEntry = (CTimedListEntry *)pList->Next();
    //         pEntry != (CTimedListEntry *)pList->Head();
    //         pEntry = (CTimedListEntry *)pEntry->Next()) {
    //        if (dwExpiryTime < pEntry->ExpiryTime()) {
    //            break;
    //        }
    //    }
    //    InsertTail(pEntry);
    //    return this == pList->Next();
    //}

    BOOL InsertBack(CDoubleLinkedList * pList) {

        DWORD dwExpiryTime = ExpiryTime();
        CTimedListEntry * pEntry;

        for (pEntry = (CTimedListEntry *)pList->Prev();
             pEntry != (CTimedListEntry *)pList->Head();
             pEntry = (CTimedListEntry *)pEntry->Prev()) {
            if (dwExpiryTime >= pEntry->ExpiryTime()) {
                break;
            }
        }
        InsertTail(pEntry);
        return this == pList->Next();
    }
};

//
// CPrioritizedListEntry
//

class CPrioritizedListEntry : public CDoubleLinkedListEntry {

private:

    LONG m_lPriority;

public:

    CPrioritizedListEntry(LONG lPriority) {
        m_lPriority = lPriority;
    }

    LONG GetPriority(VOID) const {
        return m_lPriority;
    }

    VOID SetPriority(LONG lPriority) {
        m_lPriority = lPriority;
    }
};

//
// CPrioritizedList
//

class CPrioritizedList : public CDoubleLinkedList {

    //
    // PERF: this really needs to be a btree of list anchors
    //

public:

    VOID
    insert(
        IN CPrioritizedListEntry * pEntry,
        IN LONG lPriority
        ) {
        pEntry->SetPriority(lPriority);
        insert(pEntry);
    }

    VOID
    insert(
        IN CPrioritizedListEntry * pEntry
        ) {

        CPrioritizedListEntry * pCur;

        for (pCur = (CPrioritizedListEntry *)Next();
             pCur != (CPrioritizedListEntry *)Head();
             pCur = (CPrioritizedListEntry *)pCur->Next()) {

            if (pCur->GetPriority() < pEntry->GetPriority()) {
                break;
            }
        }
        pEntry->InsertHead((CDoubleLinkedListEntry *)pCur->Prev());
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\unicwrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       unicwrap.h
//
//  Contents:   Wrappers for all Unicode functions used in the Forms^3 project.
//
//----------------------------------------------------------------------------

#ifndef _UNICWRAP_HXX_
#define _UNICWRAP_HXX_

#include "cstrinout.h"

#endif // _UNICWRAP_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\unixstuff.h ===
#ifdef UNICODE
#define WNetGetResourceInformation WNetGetResourceInformationW 
#else
#define WNetGetResourceInformation WNetGetResourceInformationA
#endif

#ifdef __cplusplus
PRIVATE HRESULT UnixWininetCopyUrlForParse(PSHSTRW pstrDst, LPCWSTR pszSrc);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\unixstuff.c ===
/*
 * AR: Varma: REVIEW:
 * File contains wrappers for few symbols in shlwapi.src, that were exported
 * as an alias to other symbols. Chose wrappers instead of macros as they are
 * exported as an alias.
 */

#include "priv.h"

BOOL IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) {
    return StrIsIntlEqualA(fCaseSens, lpString1, lpString2, nChar);
}

BOOL IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar) {
    return StrIsIntlEqualW(fCaseSens, lpString1, lpString2, nChar);
}

STDAPI_(DWORD) SHDeleteOrphanKeyA( IN  HKEY    hkey, IN  LPCSTR  pszSubKey)
{
    return SHDeleteEmptyKeyA( hkey, pszSubKey );
}
 
STDAPI_(DWORD) SHDeleteOrphanKeyW( IN  HKEY    hkey, IN  LPCWSTR  pszSubKey)
{
    return SHDeleteEmptyKeyW( hkey, pszSubKey );
}
 
STDAPI_(BOOL) IsCharAlphaW(WCHAR wch) { return IsCharAlphaWrap(wch); }
STDAPI_(BOOL) IsCharAlphaNumericW(WCHAR wch) { return IsCharAlphaNumericWrap(wch); }
STDAPI_(BOOL) IsCharUpperW(WCHAR wch) { return IsCharUpperWrap(wch); }
STDAPI_(BOOL) IsCharLowerW(WCHAR wch) { return IsCharLowerWrap(wch); }


EXTERN_C HANDLE MapHandle(HANDLE hData, DWORD dwSource, DWORD dwDest, DWORD dwDesiredAccess, DWORD dwFlags)
{
    return SHMapHandle( hData, dwSource, dwDest, dwDesiredAccess, dwFlags );
}

int DrawTextExW(HDC hdc, LPWSTR lpchTextW, int cchTextW, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
    int    iResult = 0;
    LPSTR  lpchTextA = NULL;
    int    cchTextA = -1;

    cchTextA = WideCharToMultiByte(CP_ACP, 0, lpchTextW, cchTextW, NULL, 0, NULL, NULL);
    ASSERT(cchTextA > 0);

    lpchTextA = (LPSTR) LocalAlloc(LPTR, cchTextA+1);
    if (!lpchTextA)
       goto cleanup;

    iResult = WideCharToMultiByte(CP_ACP, 0, lpchTextW, cchTextW, lpchTextA, cchTextA, NULL, NULL);

    if (iResult <= 0)
       goto cleanup;
    
    iResult = DrawTextExA(hdc, lpchTextA, cchTextA, lprc, dwDTFormat, lpDTParams);

cleanup:

    if (lpchTextA)
       LocalFree(lpchTextA);

    return iResult;
}

int SHAnsiToAnsiOld(LPCSTR pszSrc, LPSTR pszDst, int cchBuf)
{
   return SHAnsiToAnsi( pszSrc, pszDst, cchBuf );
}

int SHUnicodeToUnicodeOld(LPCWSTR pszSrc, LPWSTR pszDst, int cchBuf)
{
   return SHUnicodeToUnicode( pszSrc, pszDst, cchBuf );
}

// HtmlHelp Stubs.
HWND WINAPI HtmlHelpA( HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData)
{
    MwNotYetImplemented("HtmlHelpA");
    return 0;
}

HWND WINAPI HtmlHelpW( HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD dwData)
{
    MwNotYetImplemented("HtmlHelpW");
    return 0;
}

HWND MLHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData, DWORD dwCrossCodePage)
{
    MwNotYetImplemented("MLHtmlHelpA");
    return 0;
}

HWND MLHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD dwData, DWORD dwCrossCodePage)
{
    MwNotYetImplemented("MLHtmlHelpW");
    return 0;
}

LWSTDAPI SHCreateStreamOnFileAOld(LPCSTR pszFile, DWORD grfMode, IStream** ppstm)
{
    return SHCreateStreamOnFileA(pszFile, grfMode, ppstm);
}

LWSTDAPI SHCreateStreamOnFileWOld(LPCWSTR pwszFile, DWORD grfMode, IStream** ppstm)
{
    return SHCreateStreamOnFileW(pwszFile, grfMode, ppstm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\srccpp\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\wsprintf.c ===
#include "priv.h"

#define DBCS_CHARSIZE   (2)

//  N versions of wsprintf and wvsprintf which take an output buffer size to prevent overflow
//  bugs.  Taken from the NT wsprintf source code.

//  _MBToWCS and _WCSToMB are actually macros which call ntrtl functions in the NT version.
int _MBToWCS(LPSTR pszIn, int cchIn, LPWSTR *ppwszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppwszOut))
    {
        cchIn++;
        cbAlloc = cchIn * sizeof(WCHAR);

        *ppwszOut = (LPWSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppwszOut)
        {
            cch = MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, *ppwszOut, cchIn);

            if (!cch)
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

int _WCSToMB(LPCWSTR pwszIn, int cchIn, LPSTR *ppszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppszOut))
    {
        cchIn++;
        cbAlloc = cchIn * DBCS_CHARSIZE;

        *ppszOut = (LPSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppszOut)
        {
            cch = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchIn,
                                      *ppszOut, cbAlloc, NULL, NULL);

            if (!cch)
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* SP_PutNumber
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
\***************************************************************************/

int SP_PutNumber(
    LPSTR lpstr,
    ULONG64 n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
                mod += uppercase;
            *lpstr++ = (char)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* SP_Reverse
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
\***************************************************************************/

void SP_Reverse(
    LPSTR lpFirst,
    LPSTR lpLast)
{
    char ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}

/***************************************************************************\
* SP_GetFmtValue
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

LPCSTR SP_GetFmtValue(
    LPCSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= '0' && *lpch <= '9') {
        ii *= 10;
        ii += (int)(*lpch - '0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* wvsprintfA (API)
*
* Windows version of vsprintf().  Does not support floating point or
* pointer types, and all strings are assumed to be FAR.  Supports only
* the left alignment flag.
*
* Takes pointers to an output buffer, where the string is built, a
* pointer to an input buffer, and a pointer to a list of parameters.
*
* The cdecl function wnsprintf() calls this function.
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 12-11-90 GregoryW     after %d format is parsed lpParms needs to be aligned
*                       to a dword boundary.
* 09-Aug-1991 mikeke    no it doesn't
* 11-19-91 DarrinM      Now wvsprintf and wsprintf treat parameters the same
*                       (as if they originated from a DWORD-aligned stack).
* 1-22-97 tnoonan       Converted to wvnsprintfA
\***************************************************************************/

LWSTDAPI_(int) wvnsprintfA(
    LPSTR lpOut,
    int cchLimitIn,
    LPCSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    char prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPSTR lpT, lpTMB = NULL;
    LPWSTR pwsz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == '%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == '-')
                    left++;
                else if (*lpFmt == '#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == '0') {
                fillch = '0';
                lpFmt++;
            } else
                fillch = ' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValue((LPCSTR)lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == '.') {
                lpFmt = SP_GetFmtValue((LPCSTR)++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if (*lpFmt == 'w') {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == 'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == 't') {
                size = 0;
                lpFmt++;
            } else if (*lpFmt == 'I') {
                if (*(lpFmt+1) == '3' && *(lpFmt+2) == '2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == '6' && *(lpFmt+2) == '4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == 'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == 'i') || (*lpFmt == 'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case 'i':
            case 'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case 'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = ' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, long);
                } else if (sign) {
                    val.l = (long)va_arg(varglist, short);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXDWORD;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * SP_PutNumber returns false if it runs out of space
                 */
                if (!SP_PutNumber(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out('0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != '0') {
                        if (sign) {
                            sign = 0;
                            out('-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out('0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out('-');

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out('-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case 'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case 'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case 'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = 'X';
                    else
                        prefix = 'x';
                goto donumeric;

            case 'C':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'c' ***/

            case 'c':
                /*
                 * if size == 0, "%c" or "%hc" or "%tc" was specified (CHAR)
                 * if size == 1, "%C" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0x0000;
                    pwsz = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    lpT = val.sz;
                    goto putstring;
                }

            case 'S':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 's' ***/

            case 's':
                /*
                 * if size == 0, "%s" or "%hs" or "%ts" was specified (LPSTR);
                 * if size == 1, "%S" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" was specified (LPWSTR)
                 */
                if (size) {
                    pwsz = va_arg(varglist, LPWSTR);
                    if (pwsz == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(pwsz);
                    }
putwstring:
                    cch = _WCSToMB(pwsz, cch, &lpTMB);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTMB;
                } else {
                    lpT = va_arg(varglist, LPSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(lpT);
                    }
                }
putstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTMB);
                     fAllocateMem = FALSE;
                }
                break;

            default:
normalch:
                if (IsDBCSLeadByte(*lpFmt)) {
                    out(*lpFmt++);
                    if (!*lpFmt)
                        break;      // lead byte with no trail byte
                }
                out(*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTMB);
    }

    return cchLimitIn - cchLimit;
}

/***************************************************************************\
* StringPrintfA (API)
*
* Windows version of sprintf
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 02-05-90 DarrinM      Cleaned up with STDARG.h vararg stuff.
* 1-22-97 tnoonan       Converted to wnsprintfA
\***************************************************************************/

LWSTDAPIV_(int) wnsprintfA(
    LPSTR lpOut,
    int cchLimitIn,
    LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvnsprintfA(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR lpstr,
    ULONG64 n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
* 1-22-97 tnoonan       Converted to wvnsprintfW
\***************************************************************************/

LWSTDAPI_(int) wvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPWSTR lpT, lpTWC = NULL;
    LPBYTE psz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == L'I') {
                if (*(lpFmt+1) == L'3' && *(lpFmt+2) == L'2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == L'6' && *(lpFmt+2) == L'4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == L'i') || (*lpFmt == L'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXDWORD;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * SP_PutNumberW returns FALSE if it runs out of space
                 */
                if (!SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(lpT);
                    }
                } else {
                    psz = va_arg(varglist, LPBYTE);
                    if (psz == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(psz);
                    }
putstring:
                    cch = _MBToWCS(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }
putwstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTWC);
                     fAllocateMem = FALSE;
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTWC);
    }

    return cchLimitIn - cchLimit;
}

LWSTDAPIV_(int) wnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\urlpars.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    urlpars.cpp

Abstract:

    Contains all the worker routines for Combine and Canonicalize

    Contents:
        (ConvertChar)

Author:

    Zeke Lucas (zekel) 16-Dez-96

    Ahsan Kabir (akabir): UrlCombine parser rewritten in July-Sept98

Environment:

    Win32(s) user-mode DLL

Revision History:

    there is about one percent of this derived
    from the Spyglass or MSHTML/WININET codebase

--*/

#include "priv.h"
#include <shstr.h>

#ifdef UNIX
#include <shlobj.h>
#endif

#include <intshcut.h>

#include <shlwapip.h>

#ifdef UNIX
#include "unixstuff.h"
#endif
#include <wininet.h>

#define DM_PERF     0           // perf stats

#define PF_LOGSCHEMEHITS    0x00000001

#ifndef CPP_FUNCTIONS
#define CPP_FUNCTIONS
#include <crtfree.h>
#endif

#define USE_FAST_PARSER
#ifdef DEBUG
//#define PROOFREAD_PARSES
#endif

// Same as in wininet; however, this is only theoretical, since urls aren't necessarily so
// constrained. However, this is true throughout the product, so we'll have to do this.

#define INTERNET_MAX_PATH_LENGTH    2048
#define INTERNET_MAX_SCHEME_LENGTH  32

#define HEX_ESCAPE L'%'
#define HEX_ESCAPE_A '%'

#define TERMSTR(pch)      *(pch) = L'\0'

// (WCHAR) 8 is backspace
#define DEADSEGCHAR       ((WCHAR) 8)
#define KILLSEG(pch)      *(pch) = DEADSEGCHAR

#define CR          L'\r'
#define LF          L'\n'
#define TAB         L'\t'
#define SPC         L' '
#define SLASH       L'/'
#define WHACK       L'\\'
#define QUERY       L'?'
#define POUND       L'#'
#define SEMICOLON   L';'
#define COLON       L':'
#define BAR         L'|'
#define DOT         L'.'
#define AT          L'@'

#define UPF_SCHEME_OPAQUE           0x00000001  //  should not be treated as heriarchical
#define UPF_SCHEME_INTERNET         0x00000002
#define UPF_SCHEME_NOHISTORY        0x00000004
#define UPF_SCHEME_CONVERT          0x00000008  //  treat slashes and whacks as equiv
#define UPF_SCHEME_DONTCORRECT      0x00000010  //  Don't try to autocorrect to this scheme


#define UPF_SEG_ABSOLUTE            0x00000100  //  the initial segment is the root
#define UPF_SEG_LOCKFIRST           0x00000200  //  this is for file parsing
#define UPF_SEG_EMPTYSEG            0x00000400  //  this was an empty string, but is still important
#define UPF_EXSEG_DIRECTORY         0x00001000  //  the final segment is a "directory" (trailing slash)

#define UPF_FILEISPATHURL           0x10000000  //  this is for file paths, dont unescape because they are actually dos paths
//
//  the masks are for inheritance purposes during BlendParts
//  if you inherit that part you inherit that mask
//
#define UPF_SCHEME_MASK             0x000000FF
#define UPF_SEG_MASK                0x00000F00
#define UPF_EXSEG_MASK              0x0000F000


//  right now these masks are unused, and can be recycled
#define UPF_SERVER_MASK             0x000F0000
#define UPF_QUERY_MASK              0x0F000000

extern "C" int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS);
extern "C" LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS);
typedef struct _UrlParts
{
    DWORD   dwFlags;
    LPWSTR  pszScheme;
    URL_SCHEME eScheme;
    LPWSTR  pszServer;
    LPWSTR  pszSegments;
    DWORD   cSegments;
    LPWSTR  pszExtraSegs;
    DWORD   cExtraSegs;
    LPWSTR  pszQuery;
    LPWSTR  pszFragment;
} URLPARTS, *PURLPARTS;


HRESULT SHUrlParse(LPCWSTR pszBase, LPCWSTR pszUrl, PSHSTRW pstrOut, DWORD dwFlags);
HRESULT SHUrlCreateFromPath(LPCWSTR pszPath, PSHSTRW pstrOut, DWORD dwFlags);

// Ansi wrappers might overwrite the unicode core's return value
// We should try to prevent that
HRESULT ReconcileHresults(HRESULT hr1, HRESULT hr2)
{
    return (hr2==S_OK) ? hr1 : hr2;
}



PRIVATE CONST WORD isSafe[96] =

/*   Bit 0       alphadigit     -- 'a' to 'z', '0' to '9', 'A' to 'Z'
**   Bit 1       Hex            -- '0' to '9', 'a' to 'f', 'A' to 'F'
**   Bit 2       valid scheme   -- alphadigit | "-" | "." | "+"
**   Bit 3       mark           -- "%" | "$"| "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")" | ","
*/
/*   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
//    {0, 8, 0, 0, 8, 8, 0, 8, 8, 8, 8, 4, 8,12,12, 0,    /* 2x   !"#$%&'()*+,-./  */
// IE4 BETA1: allow + through unmolested.  Should consider other options
// post beta1.  12feb97 tonyci
    {0, 8, 0, 0, 8, 8, 0, 8, 8, 8, 8, 12, 8,12,12, 0,    /* 2x   !"#$%&'()*+,-./  */
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 0, 8, 0, 0,    /* 3x  0123456789:;<=>?  */
     8, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 8,    /* 5X  PQRSTUVWXYZ[\]^_  */
     0, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 8, 0};   /* 7X  pqrstuvwxyz{|}~  DEL */

PRIVATE const WCHAR hex[] = L"0123456789ABCDEF";

PRIVATE inline BOOL IsSafe(WCHAR ch, WORD mask)
{
    if(((ch > 31 ) && (ch < 128) && (isSafe[ch - 32] & mask)))
        return TRUE;

    return FALSE;
}

#define IsAlphaDigit(c)         IsSafe(c, 1)
#define IsHex(c)                IsSafe(c, 2)
#define IsValidSchemeCharA(c)    IsSafe(c, 5)
#define IsSafePathChar(c)       ((c > 0xff) || IsSafe(c, 9))
#define IsUpper(c)              ((c) >= 'A' && (c) <= 'Z')

PRIVATE inline BOOL IsAsciiCharW(WCHAR ch)
{
    return (!(ch >> 8) && ((CHAR) ch));
}

PRIVATE inline WCHAR Ascii_ToLowerW(WCHAR ch)
{
    return (ch >= L'A' && ch <= L'Z') ? (ch - L'A' + L'a') : ch;
}

BOOL IsValidSchemeCharW(WCHAR ch)
{
    if(IsAsciiCharW(ch))
        return IsSafe( (CHAR) ch, 5);
    return FALSE;
}



WCHAR const c_szHttpScheme[]           = L"http";
WCHAR const c_szFileScheme[]           = L"file";
WCHAR const c_szFTPScheme[]            = L"ftp";
WCHAR const c_szGopherScheme[]         = L"gopher";
WCHAR const c_szMailToScheme[]         = L"mailto";
WCHAR const c_szNewsScheme[]           = L"news";
WCHAR const c_szNNTPScheme[]           = L"nntp";
WCHAR const c_szTelnetScheme[]         = L"telnet";
WCHAR const c_szWAISScheme[]           = L"wais";
WCHAR const c_szMkScheme[]             = L"mk";
WCHAR const c_szHttpsScheme[]          = L"https";
WCHAR const c_szLocalScheme[]          = L"local";
WCHAR const c_szShellScheme[]          = L"shell";
WCHAR const c_szJSScheme[]             = L"javascript";
WCHAR const c_szVSScheme[]             = L"vbscript";
WCHAR const c_szAboutScheme[]          = L"about";
WCHAR const c_szSnewsScheme[]          = L"snews";
WCHAR const c_szResScheme[]            = L"res";
WCHAR const c_szRootedScheme[]         = L"ms-shell-rooted";
WCHAR const c_szIDListScheme[]         = L"ms-shell-idlist";
WCHAR const c_szMsHelpScheme[]         = L"hcp";

const struct
{
    LPCWSTR pszScheme;
    URL_SCHEME eScheme;
    DWORD cchScheme;
    DWORD dwFlags;
} g_mpUrlSchemeTypes[] =
    {
    // Because we use a linear search, sort this in the order of
    // most common usage.
    { c_szHttpScheme,   URL_SCHEME_HTTP,      SIZECHARS(c_szHttpScheme) - 1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szFileScheme,   URL_SCHEME_FILE,      SIZECHARS(c_szFileScheme) - 1,     UPF_SCHEME_CONVERT},
    { c_szFTPScheme,    URL_SCHEME_FTP,       SIZECHARS(c_szFTPScheme) - 1,      UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szHttpsScheme,  URL_SCHEME_HTTPS,     SIZECHARS(c_szHttpsScheme) -1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT|UPF_SCHEME_DONTCORRECT},
    { c_szNewsScheme,   URL_SCHEME_NEWS,      SIZECHARS(c_szNewsScheme) - 1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szMailToScheme, URL_SCHEME_MAILTO,    SIZECHARS(c_szMailToScheme) - 1,   UPF_SCHEME_OPAQUE},
    { c_szGopherScheme, URL_SCHEME_GOPHER,    SIZECHARS(c_szGopherScheme) - 1,   UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szNNTPScheme,   URL_SCHEME_NNTP,      SIZECHARS(c_szNNTPScheme) - 1,     UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szTelnetScheme, URL_SCHEME_TELNET,    SIZECHARS(c_szTelnetScheme) - 1,   UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szWAISScheme,   URL_SCHEME_WAIS,      SIZECHARS(c_szWAISScheme) - 1,     0},
    { c_szMkScheme,     URL_SCHEME_MK,        SIZECHARS(c_szMkScheme) - 1,       UPF_SCHEME_NOHISTORY},
    { c_szShellScheme,  URL_SCHEME_SHELL,     SIZECHARS(c_szShellScheme) - 1,    UPF_SCHEME_OPAQUE},
    { c_szLocalScheme,  URL_SCHEME_LOCAL,     SIZECHARS(c_szLocalScheme) - 1,    0},
    { c_szJSScheme,     URL_SCHEME_JAVASCRIPT,SIZECHARS(c_szJSScheme) - 1,       UPF_SCHEME_OPAQUE|UPF_SCHEME_NOHISTORY},
    { c_szVSScheme,     URL_SCHEME_VBSCRIPT,  SIZECHARS(c_szVSScheme) - 1,       UPF_SCHEME_OPAQUE|UPF_SCHEME_NOHISTORY},
    { c_szSnewsScheme,  URL_SCHEME_SNEWS,     SIZECHARS(c_szSnewsScheme) - 1,    UPF_SCHEME_INTERNET|UPF_SCHEME_CONVERT},
    { c_szAboutScheme,  URL_SCHEME_ABOUT,     SIZECHARS(c_szAboutScheme) - 1,    UPF_SCHEME_OPAQUE|UPF_SCHEME_NOHISTORY},
    { c_szResScheme,    URL_SCHEME_RES,       SIZECHARS(c_szResScheme) - 1,      UPF_SCHEME_NOHISTORY},
    { c_szRootedScheme, URL_SCHEME_MSSHELLROOTED, SIZECHARS(c_szRootedScheme) - 1, 0},
    { c_szIDListScheme, URL_SCHEME_MSSHELLIDLIST, SIZECHARS(c_szIDListScheme) - 1, 0},
    { c_szMsHelpScheme, URL_SCHEME_MSHELP,    SIZECHARS(c_szMsHelpScheme) - 1,   0},
    };

PRIVATE int _StrCmpNMixed(LPCSTR psz, LPCWSTR pwz, DWORD cch)
{
    int iRet = 0;

    //
    //  we dont have to real mbcs conversion here because we are
    //  guaranteed to have only ascii chars here
    //

    for (;cch; psz++, pwz++, cch--)
    {
        WCHAR ch = *psz;
        if (ch != *pwz)
        {
            //
            //  this makes it case insensitive
            if (IsUpper(ch) && (ch + 32) == *pwz)
                continue;

            if(ch > *pwz)
                iRet = 1;
            else
                iRet = -1;
            break;
        }
    }

    return iRet;
}

//***   g_iScheme -- cache for g_mpUrlSchemeTypes
// DESCRIPTION
//  we call GetSchemeTypeAndFlags many times for the same scheme.  if
//  it's the 0th table entry, no biggee.  if it's a later entry linear
//  search isnt very good.  add a 1-element MRU cache.  even for the most common
//  (by far) case of "http" (0th entry), we *still* win due to the cheaper
//  StrCmpC and skipped loop.
// NOTES
//  g_iScheme refs/sets are atomic so no need for lock
int g_iScheme;      // last guy we hit

#ifdef DEBUG
int g_cSTTot, g_cSTHit, g_cSTHit0;
#endif

//
//  all of the pszScheme to nScheme functions are necessary at this point
//  because some parsing is vioent, and some is necessarily soft
//
PRIVATE URL_SCHEME
GetSchemeTypeAndFlagsW(LPCWSTR pszScheme, DWORD cchScheme, LPDWORD pdwFlags)
{
    DWORD i;

    ASSERT(pszScheme);


#ifdef DEBUG
    if ((g_cSTTot % 10) == 0)
        TraceMsg(DM_PERF, "gstaf: tot=%d hit=%d hit0=%d", g_cSTTot, g_cSTHit, g_cSTHit0);
#endif
    DBEXEC(TRUE, g_cSTTot++);
    // check cache 1st
    i = g_iScheme;
    if (cchScheme == g_mpUrlSchemeTypes[i].cchScheme
      && StrCmpNCW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme) == 0)
    {
        DBEXEC(TRUE, i == 0 ? g_cSTHit0++ : g_cSTHit++);
Lhit:
        if (pdwFlags)
            *pdwFlags = g_mpUrlSchemeTypes[i].dwFlags;

        // update cache (unconditionally)
        g_iScheme = i;

        return g_mpUrlSchemeTypes[i].eScheme;
    }

    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(cchScheme == g_mpUrlSchemeTypes[i].cchScheme
          && 0 == StrCmpNIW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme))
            goto Lhit;
    }

    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return URL_SCHEME_UNKNOWN;
}

PRIVATE URL_SCHEME
GetSchemeTypeAndFlagsA(LPCSTR pszScheme, DWORD cchScheme, LPDWORD pdwFlags)
{
    DWORD i;

    ASSERT(pszScheme);


    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(0 == _StrCmpNMixed(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme))
        {
            if (pdwFlags)
                *pdwFlags = g_mpUrlSchemeTypes[i].dwFlags;
            return g_mpUrlSchemeTypes[i].eScheme;
        }
    }

    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return URL_SCHEME_UNKNOWN;
}

/*----------------------------------------------------------
Purpose: Return the scheme ordinal type (URL_SCHEME_*) based on the
         URL string.


Returns: URL_SCHEME_ ordinal
Cond:    --
*/

PRIVATE inline BOOL IsSameSchemeW(LPCWSTR pszLocal, LPCWSTR pszGlobal, DWORD cch)
{
    ASSERT(pszLocal);
    ASSERT(pszGlobal);
    ASSERT(cch);

    return !StrCmpNIW(pszLocal, pszGlobal, cch);
}

PRIVATE BOOL IsSameSchemeA(LPCSTR pszLocal, LPCWSTR pszGlobal, DWORD cch)
{
    ASSERT(pszLocal);
    ASSERT(pszGlobal);
    ASSERT(cch);

    return !_StrCmpNMixed(pszLocal, pszGlobal, cch);
}


PRIVATE URL_SCHEME
SchemeTypeFromStringA(
   LPCSTR psz,
   DWORD cch)
{
   DWORD i;

   // psz is a counted string (by cch), not a null-terminated string,
   // so use IS_VALID_READ_BUFFER instead of IS_VALID_STRING_PTRA.
   ASSERT(IS_VALID_READ_BUFFER(psz, CHAR, cch));
   ASSERT(cch);
   // We use a linear search.  A binary search wouldn't pay off
   // because the list isn't big enough, and we can sort the list
   // according to the most popular protocol schemes and pay off
   // bigger.

   for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
   {
       if(cch == g_mpUrlSchemeTypes[i].cchScheme &&
           IsSameSchemeA(psz, g_mpUrlSchemeTypes[i].pszScheme, cch))
            return g_mpUrlSchemeTypes[i].eScheme;
   }

   return URL_SCHEME_UNKNOWN;
}


PRIVATE URL_SCHEME
SchemeTypeFromStringW(
   LPCWSTR psz,
   DWORD cch)
{
   DWORD i;

   // psz is a counted string (by cch), not a null-terminated string,
   // so use IS_VALID_READ_BUFFER instead of IS_VALID_STRING_PTRW.
   ASSERT(IS_VALID_READ_BUFFER(psz, WCHAR, cch));
   ASSERT(cch);

   // We use a linear search.  A binary search wouldn't pay off
   // because the list isn't big enough, and we can sort the list
   // according to the most popular protocol schemes and pay off
   // bigger.

   for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
   {
       if(cch == g_mpUrlSchemeTypes[i].cchScheme &&
           IsSameSchemeW(psz, g_mpUrlSchemeTypes[i].pszScheme, cch))
            return g_mpUrlSchemeTypes[i].eScheme;
   }

   return URL_SCHEME_UNKNOWN;
}

//
//  these are used during path fumbling that i do
//  each string between a path delimiter ( '/' or '\')
//  is a segment.  we dont ever really care about
//  empty ("") segments, so it is best to use
//  NextLiveSegment().
//
inline PRIVATE LPWSTR
NextSegment(LPWSTR psz)
{
    ASSERT (psz);
    return psz + lstrlenW(psz) + 1;
}

#define IsLiveSegment(p)    ((p) && (*p) != DEADSEGCHAR)

PRIVATE LPWSTR
NextLiveSegment(LPWSTR pszSeg, DWORD *piSeg, DWORD cSegs)
{
    if(pszSeg) do
    {
        //
        //  count the number of dead segments that we skip.
        //  if the segment isnt dead, then we can just skip one,
        //  the current one.
        //
        DWORD cSkip;
        for (cSkip = 0; (*pszSeg) == DEADSEGCHAR; pszSeg++, cSkip++);
        cSkip = cSkip ? cSkip : 1;

        if((*piSeg) + cSkip < cSegs)
        {

            pszSeg = NextSegment(pszSeg);
            (*piSeg) += cSkip;
        }
        else
            pszSeg = NULL;

    } while (pszSeg && (*pszSeg == DEADSEGCHAR));

    return pszSeg;
}

PRIVATE LPWSTR
LastLiveSegment(LPWSTR pszSeg, DWORD cSegs, BOOL fFailIfFirst)
{
    DWORD iSeg = 0;
    LPWSTR pszLast = NULL;
    BOOL fLastIsFirst = FALSE;

    if(cSegs)
    {
        if(IsLiveSegment(pszSeg))
        {
            pszLast = pszSeg;
            fLastIsFirst = TRUE;
        }

        while(pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs))
        {
            if(!pszLast)
                fLastIsFirst = TRUE;
            else
                fLastIsFirst = FALSE;

            pszLast = pszSeg;
        }

        if(fFailIfFirst && fLastIsFirst)
            pszLast = NULL;
    }

    return pszLast;
}

PRIVATE LPWSTR
FirstLiveSegment(LPWSTR pszSeg, DWORD *piSeg, DWORD cSegs)
{
    ASSERT(piSeg);

    *piSeg = 0;

    if(!pszSeg || !cSegs)
        return NULL;

    if(!IsLiveSegment(pszSeg))
        pszSeg = NextLiveSegment(pszSeg, piSeg, cSegs);

    return pszSeg;
}

inline BOOL IsDosDrive(LPCWSTR p)
{
    return (*p && p[1] == COLON);
}

inline BOOL IsDosPath(LPCWSTR p)
{
    return (*p == WHACK ||  IsDosDrive(p));
}

inline BOOL IsDriveUrl(const WCHAR *p)
{
    return (*p && p[1] == BAR);
}

inline BOOL IsDrive(LPCWSTR p)
{
    return (IsDosDrive(p) || IsDriveUrl(p));
}

inline BOOL IsSeparator(const WCHAR *p)
{
    return (*p == SLASH || *p == WHACK );
}

inline BOOL IsAbsolute(const WCHAR *p)
{
#ifndef UNIX
    return (IsSeparator(p) || IsDrive(p));
#else
    return (IsSeparator(p)) ;
#endif
}

#define IsUNC(pathW) PathIsUNCW(pathW)

inline BOOL IsDot(LPCWSTR p)     // if p == "." return TRUE
{
    return (*p == DOT && !p[1]);
}

inline BOOL IsDotDot(LPCWSTR p)  // if p == ".." return TRUE
{
    return (*p == DOT && p[1] == DOT && !p[2]);
}

//+---------------------------------------------------------------------------
//
//  Method:     ConvertChar
//
//  Synopsis:
//
//  Arguments:  [szStr] --
//              [cIn] --
//              [cOut] --
//
//  Returns:
//
//  History:    03-20-96    JoeS (Joe Souza)    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
static void ConvertChar(LPWSTR ptr, WCHAR cIn, WCHAR cOut, BOOL fProtectExtra)
{
    while (*ptr)
    {
        if (fProtectExtra && (*ptr == QUERY || *ptr == POUND ))
        {
            break;
        }

        if (*ptr == cIn)
        {
            *ptr = cOut;
        }

        ptr++;
    }
}

PUBLIC void WininetFixFileSlashes(WCHAR *p)
{
    // NB: This function assumes that p points to a file URL.
    // The file URL *MUST* be of the form "file://...".
    // HTParse() guarantees that this will be so.

    int schemelen = 0;

    schemelen = SIZECHARS(L"file://") - 1;

    /* In UNIX system, we don't need to convert the SLASH to WHACK */
    if (p && lstrlenW(p) > schemelen)
    {
#ifdef UNIX
        ConvertChar(p + schemelen, WHACK, SLASH, TRUE);
#else
        ConvertChar(p + schemelen, SLASH, WHACK, TRUE);
#endif
    }
}

//
//  in the URL spec, it says that all whitespace should be ignored
//  due to the fact that it is possible to introduce
//  new whitespace and eliminate other whitespace
//  however, we are only going to strip out TAB CR LF
//  because we consider SPACE's to be significant.
//

PRIVATE inline BOOL IsInsignificantWhite(WCHAR ch)
{
    return (ch == TAB ||
            ch == CR ||
            ch == LF);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)

PRIVATE void TrimAndStripInsignificantWhite(WCHAR *psz)
{
    ASSERT(psz);

    if(*psz)
    {

        LPCWSTR pszSrc = psz;
        LPWSTR pszDest = psz;
        LPWSTR pszLastSpace = NULL;

        // first trim the front side by just moving the source pointer.
        while(*pszSrc && IsWhite(*pszSrc)) {
            pszSrc++;
        }

        //
        // Copy the body stripping "insignificant" white spaces.
        // Remember the last white space to trim trailing space later.
        //
        while (*pszSrc)
        {
            if(IsInsignificantWhite(*pszSrc)) {
                pszSrc++;
            } else {
                if (IsWhite(*pszSrc)) {
                    if (pszLastSpace==NULL) {
                        pszLastSpace = pszDest;
                    }
                } else {
                    pszLastSpace = NULL;
                }

                *pszDest++ = *pszSrc++;
            }
        }

        // Trim the trailing space
        if (pszLastSpace) {
            *pszLastSpace = L'\0';
        } else {
            *pszDest = L'\0';
        }

    }
}


struct EXTKEY
{
    PCSTR  szExt;
    PCWSTR wszExt;
    DWORD cchExt;
};

const EXTKEY ExtTable[] = {
       {    ".html",        L".html",           ARRAYSIZE(".html") - 1 },
       {    ".htm",         L".htm",            ARRAYSIZE(".htm") - 1  },
       {    ".xml",         L".xml",            ARRAYSIZE(".xml") - 1  },
       {    ".doc",         L".doc",            ARRAYSIZE(".doc") - 1  },
       {    ".xls",         L".xls",            ARRAYSIZE(".xls") - 1  },
       {    ".ppt",         L".ppt",            ARRAYSIZE(".ppt") - 1  },
       {    ".rtf",         L".rtf",            ARRAYSIZE(".rtf") - 1  },
       {    ".dot",         L".dot",            ARRAYSIZE(".dot") - 1  },
       {    ".xlw",         L".xlw",            ARRAYSIZE(".xlw") - 1  },
       {    ".pps",         L".pps",            ARRAYSIZE(".pps") - 1  },
       {    ".xlt",         L".xlt",            ARRAYSIZE(".xlt") - 1  },
       {    ".hta",         L".hta",            ARRAYSIZE(".hta") - 1  },
       {    ".pot",         L".pot",            ARRAYSIZE(".pot") - 1  },
       {    ".pdf",         L".pdf",            ARRAYSIZE(".pdf") - 1  }
};

inline BOOL CompareExtA(PCSTR psz, DWORD_PTR cch)
{
    for (DWORD i=0; i < ARRAYSIZE(ExtTable); i++)
    {
        if (ExtTable[i].cchExt>cch)
            continue;

        if (!StrCmpNIA(psz - (LONG_PTR)ExtTable[i].cchExt, ExtTable[i].szExt, ExtTable[i].cchExt))
            return TRUE;
    }
    return FALSE;
}

inline BOOL CompareExtW(PCWSTR pwsz, DWORD_PTR cch)
{
    for (DWORD i=0; i < ARRAYSIZE(ExtTable); i++)
    {
        if (ExtTable[i].cchExt>cch)
            continue;

        if (!StrCmpNIW(pwsz - (LONG_PTR)ExtTable[i].cchExt, ExtTable[i].wszExt, ExtTable[i].cchExt))
            return TRUE;
    }
    return FALSE;
}


PRIVATE LPCSTR FindFragmentA(LPCSTR psz, BOOL fMBCS, BOOL fIsFile)
{
    CHAR *pch = _StrChrA(psz, POUND, fMBCS);
    if(pch && fIsFile)
    {
        CHAR *pchQuery = _StrChrA(psz, QUERY, fMBCS);
        if (pchQuery && (pchQuery < pch))
            goto exit;

        do
        {
            LONG_PTR cch = pch - psz;

            // REARCHITECT: we shouldn't hardcode ".htm".
            //  #s are significant in dospaths - zekel 9-JUL-97
            //  so we want to check the path in front and make sure
            //  that it is an html file.  we believe this heuristic should work
            //  in about 99% of all cases.
            //
            // if it is not an html file it is not a hash
            if (CompareExtA(pch, cch))
            {
                break;
            }
        } while (pch = _StrChrA(++pch, POUND, fMBCS));
    }
exit:
    return pch;
}

PRIVATE LPCWSTR FindFragmentW(LPCWSTR psz, BOOL fIsFile)
{
    WCHAR *pch = StrChrW(psz, POUND);
    if(pch && fIsFile)
    {
        WCHAR *pchQuery = StrChrW(psz, QUERY);
        if (pchQuery && (pchQuery < pch))
            goto exit;

        do
        {
            LONG_PTR cch = pch - psz;

            // REARCHITECT: we shouldn't hardcode ".htm".
            //  #s are significant in dospaths - zekel 9-JUL-97
            //  so we want to check the path in front and make sure
            //  that it is an html file.  we believe this heuristic should work
            //  in about 99% of all cases.
            //
            // if it is not an html file it is not a hash
            if (CompareExtW(pch, cch))
            {
                break;
            }

        } while (pch = StrChrW(++pch, POUND));
    }
exit:
    return pch;
}

PRIVATE VOID BreakFragment(LPWSTR *ppsz, PURLPARTS parts)
{
    ASSERT(ppsz);
    ASSERT(*ppsz);

    //
    //  Opaque URLs are not allowed to use fragments - zekel 27-feb-97
    //  Is it possible for an opaque URL to use a fragment?
    //  right now we assume not.  i suspect so but will leave it this way for now
    //  this is especially important to javascript and vbscript
    //  FEATURE: this might be worth investigation, but probably can't change this code
    //
    if(!**ppsz || parts->dwFlags & UPF_SCHEME_OPAQUE)
        return;

    WCHAR *pch = (LPWSTR) FindFragmentW(*ppsz, parts->eScheme == URL_SCHEME_FILE);

    if (pch)
    {
        TERMSTR(pch);
        parts->pszFragment = pch +1;
    }
}

PRIVATE inline BOOL IsUrlPrefixA(LPCSTR psz)
{
    //
    // Optimized for this particular case. Notice that most of it
    // will be lego-ized out anyway.
    //
    if (psz[0]=='u' || psz[0]=='U') {
        if (psz[1]=='r' || psz[1]=='R') {
            if (psz[2]=='l' || psz[2]=='L') {
                return TRUE;
            }
        }
    }
    return FALSE;
    // return !StrCmpNIA(psz, c_szURLPrefixA, c_cchURLPrefix);
}

PRIVATE inline BOOL IsUrlPrefixW(LPCWSTR psz)
{
    //
    // Optimized for this particular case. Notice that most of it
    // will be lego-ized out anyway.
    //
    if (psz[0]==L'u' || psz[0]==L'U') {
        if (psz[1]==L'r' || psz[1]==L'R') {
            if (psz[2]==L'l' || psz[2]==L'L') {
                return TRUE;
            }
        }
    }
    return FALSE;
    // return !StrCmpNIW(psz, c_szURLPrefixW, c_cchURLPrefix);
}

//
//  if FindScheme() succeeds, it returns a pointer to the scheme,
//  and the cch holds the count of chars for the scheme
//  if it fails, and cch is non-zero then cch is how much should be skipped.
//  this is to allow "URL:/foo/bar", a relative URL with the "URL:" prefix.
//
LPCSTR FindSchemeA(LPCSTR psz, LPDWORD pcchScheme)
{
    LPCSTR pch;
    DWORD cch;

    ASSERT(pcchScheme);
    ASSERT(psz);

    *pcchScheme = 0;

    for (pch = psz, cch = 0; *pch; pch++, cch++)
    {
        if (*pch == ':')
        {
            if (IsUrlPrefixA(psz))
            {
                psz = pch +1;

                //  set pcchScheme to skip past "URL:"
                *pcchScheme = cch + 1;

                //  reset cch for the scheme len
                cch = -1;
                continue;
            }
            else
            {
                //
                //  Scheme found if it is at least two characters
                if(cch > 1)
                {
                    *pcchScheme = cch;
                    return psz;
                }
                break;
            }
        }
        if(!IsValidSchemeCharA(*pch))
            break;
    }

    return NULL;
}

//
//  FindSchemeW() around for Perf reasons for ParseURL()
//  Any changes in either FindScheme() needs to reflected in the other
//
LPCWSTR FindSchemeW(LPCWSTR psz, LPDWORD pcchScheme, BOOL fAllowSemicolon = FALSE)
{
    LPCWSTR pch;
    DWORD cch;

    ASSERT(pcchScheme);
    ASSERT(psz);

    *pcchScheme = 0;

    for (pch = psz, cch = 0; *pch; pch++, cch++)
    {

        if (*pch == L':' ||

            // Autocorrect permits a semicolon typo
            (fAllowSemicolon && *pch == L';'))
        {
            if (IsUrlPrefixW(psz))
            {
                psz = pch +1;

                //  set pcchScheme to skip past "URL:"
                *pcchScheme = cch + 1;

                //  reset cch for the scheme len
                cch = -1;
                continue;
            }
            else
            {
                //
                //  Scheme found if it is at least two characters
                if(cch > 1)
                {
                    *pcchScheme = cch;
                    return psz;
                }
                break;
            }
        }
        if(!IsValidSchemeCharW(*pch))
            break;
    }

    return NULL;
}

PRIVATE DWORD
CountSlashes(LPCWSTR *ppsz)
{
    DWORD cSlashes = 0;
    LPCWSTR pch = *ppsz;

    while (IsSeparator(pch))
    {
        *ppsz = pch;
        pch++;
        cSlashes++;
    }

    return cSlashes;
}


PRIVATE LPCWSTR
FindDosPath(LPCWSTR psz)
{
    if (IsDosDrive(psz) || IsUNC(psz))
    {
        return psz;
    }
    else
    {
        DWORD cch;
        LPCWSTR pszScheme = FindSchemeW(psz, &cch);

        if (pszScheme && URL_SCHEME_FILE == GetSchemeTypeAndFlagsW(pszScheme, cch, NULL))
        {
            LPCWSTR pch = psz + cch + 1;
            DWORD c = CountSlashes(&pch);

            switch (c)
            {
            case 2:
                if(IsDosDrive(++pch))
                    return pch;
                break;

            case 4:
                return --pch;
            }
        }
    }
    return NULL;
}


/*+++

  WininetCopyUrlForParse()
    this copies the url and prepends a "file://" if necessary
    This should never be called except from wininet
    everyone else should be calling UrlCreateFromPath()

  Parameters
  IN -
    pszDst      the destination buffer
    pszSrc      source buffer

  OUT -
    pszDst      is filled with a Live URL

  Returns
  VOID

  NOTE - Assume "file:" if no scheme and it looks like fully-qualified file path.
---*/
static const WCHAR c_szFileSchemeString[] = L"file://";

PRIVATE HRESULT
WininetCopyUrlForParse(PSHSTRW pstrDst, LPCWSTR pszSrc)
{
#ifndef UNIX
    if (IsDrive(pszSrc) || IsUNC(pszSrc))
    {
        //
        // NOTE: the first SetStr will always succeed
        // because the default buffer is more than "file://"
        pstrDst->SetStr(c_szFileSchemeString);
        return pstrDst->Append(pszSrc);
    }
    else
#endif /* !UNIX */
        return pstrDst->SetStr(pszSrc);

}

PRIVATE HRESULT
CopyUrlForParse(LPCWSTR pszUrl, PSHSTRW pstrUrl, DWORD dwFlags)
{
    LPCWSTR pch;
    HRESULT hr;
    //
    //  now we will make copies of the URLs so that we can rip them apart
    //  WininetCopyUrlForParse() will prepend a file: if it wants...
    //

    if(dwFlags & URL_WININET_COMPATIBILITY)
    {
        hr = WininetCopyUrlForParse(pstrUrl, pszUrl);
    }
    else if(pch = FindDosPath(pszUrl))
    {
        hr = SHUrlCreateFromPath(pch, pstrUrl, dwFlags);
    }
    else
    {
        hr = pstrUrl->SetStr(pszUrl);
    }

    // Trim leading and trailing whitespace
    // Remove tab and CRLF characters.  Netscape does this.
    if(SUCCEEDED(hr))
        TrimAndStripInsignificantWhite(pstrUrl->GetInplaceStr());


    return hr;
}


PRIVATE VOID BreakScheme(LPWSTR *ppsz, PURLPARTS parts)
{
    if(!**ppsz || IsDrive(*ppsz))
        return;

    DWORD cch;

    //
    //  if FindScheme() succeeds, it returns a pointer to the scheme,
    //  and the cch holds the count of chars for the scheme
    //  if it fails, and cch is none zero then cch is how much should be skipped.
    //  this is to allow "URL:/foo/bar", a relative URL with the "URL:" prefix.
    //
    if(NULL != (parts->pszScheme = (LPWSTR) FindSchemeW(*ppsz, &cch)))
    {
        parts->pszScheme[cch] = '\0';
        CharLowerW(parts->pszScheme);

        //  put the pointer past the scheme for next Break()
        *ppsz = parts->pszScheme + cch + 1;


#ifdef DEBUG
        if (g_dwPrototype & PF_LOGSCHEMEHITS)
        {
            //  this is for logging of url schemes, to make sure that we have the right order
            int c = GetPrivateProfileIntW(L"SchemeHits", parts->pszScheme, 0, L"UrlPars.ini");
            WCHAR szc[25];
            StringCchPrintfW(szc, ARRAYSIZE(szc), L"%d", ++c);
            WritePrivateProfileStringW(L"SchemeHits", parts->pszScheme, szc, L"UrlPars.ini");
        }
#endif //DEBUG


        parts->eScheme = GetSchemeTypeAndFlagsW(parts->pszScheme, cch, &parts->dwFlags);
    }
    else if (cch)
        *ppsz += cch + 1;
}


PRIVATE VOID BreakQuery(LPWSTR *ppsz, PURLPARTS parts)
{
    WCHAR *pch;

    if(!**ppsz)
        return;

    if(parts->dwFlags & UPF_SCHEME_OPAQUE)
        return;

    pch = StrChrW(*ppsz, QUERY);

    //
    //  APPCOMPAT NETSCAPE COMPATBILITY - zekel - 27-JAN-97
    //  we will also get http://foo#frag?query
    //  even tho legally it should be http://foo?query#frag
    //  of course we will put it back together the right way.
    //
    if(!pch && parts->pszFragment)
        pch = StrChrW(parts->pszFragment, QUERY);

    //  found our query string...
    if (pch)
    {
        TERMSTR(pch);
        parts->pszQuery = pch + 1;
    }
}

PRIVATE VOID MkBreakServer(LPWSTR *ppsz, PURLPARTS parts)
{
    //
    //  NOTE:  we dont convert WHACKs to SLASHs because mk can be of the
    //  form <mk:@class:\\Server\Share\file.itl/path/in/the/file.gif
    //  and we want to preserve the DOS/UNC path as it is
    //

    if (**ppsz == TEXT('@'))
    {
        WCHAR *pch;
        // treat everything to separator as host
        //
        parts->pszServer = *ppsz;

        pch = StrChrW(*ppsz ,SLASH);
        if (pch)
        {
            parts->dwFlags |= UPF_SEG_ABSOLUTE;
            TERMSTR(pch);
            *ppsz = pch + 1;
        }
        else
            *ppsz += lstrlenW(*ppsz);
    }
}

PRIVATE VOID DefaultBreakServer(LPWSTR *ppsz, PURLPARTS parts)
{
    if (**ppsz == SLASH)
    {
        parts->dwFlags |= UPF_SEG_ABSOLUTE;

        (*ppsz)++;

        if (**ppsz == SLASH)
        {
            // we have a winner!
            WCHAR * pch;

            parts->pszServer = (*ppsz) + 1;

            pch = StrChrW(parts->pszServer, SLASH);

            if(pch)
            {
                TERMSTR(pch);
                *ppsz = pch + 1;
            }
            else
                *ppsz = *ppsz + lstrlenW(*ppsz);
        }
    }
    else if(parts->pszScheme)
        parts->dwFlags |= UPF_SCHEME_OPAQUE;
}

PRIVATE VOID FileBreakServer(LPWSTR *ppsz, PURLPARTS parts)
{
    LPWSTR pch;

    //  CountSlashes() will set *ppsz to the last slash
    DWORD cSlashes = CountSlashes((LPCWSTR *)ppsz);

    if(cSlashes || IsDrive(*ppsz))
        parts->dwFlags |= UPF_SEG_ABSOLUTE;

    switch (cSlashes)
    {
    case 0:
        break;

    case 4:
        // we identify file://\\UNC as a true DOS path with no escaped characters
        parts->dwFlags |= UPF_FILEISPATHURL;

        // fall through

    case 2:
        if(IsDrive((*ppsz) + 1))
        {
            //  this is a root drive
            TERMSTR(*ppsz);
            parts->pszServer = *ppsz;
            (*ppsz)++;
            // we identify file://C:\PATH as a true DOS path with no escaped characters
            parts->dwFlags |= UPF_FILEISPATHURL;
            break;
        } //else fallthru to UNC handling
        // fall through

    case 5:
    case 6:
        //
        // cases like "file:////..." or "file://///..."
        // we see this as a UNC path
        // lets set the server
        //
        parts->pszServer = ++(*ppsz);
        for(pch = *ppsz; *pch && !IsSeparator(pch); pch++);

        if(pch && *pch)
        {
            TERMSTR(pch);
            *ppsz = pch + 1;
        }
        else
            *ppsz = pch + lstrlenW(pch);
        break;

    case 1:
        //
        //we think of "file:/..." as on the local machine
        // so we have zero length pszServer
        //
    case 3:
        //
        //we think of file:///... as properly normalized on the local machine
        // so we have zero length pszServer
        //
    default:
        //  there is just too many, we pretend that there is just one and ignore
        //  the rest
        TERMSTR(*ppsz);
        parts->pszServer = *ppsz;
        (*ppsz)++;
        break;
    }

    //  detect file://localserver/c:/path
    if(parts->pszServer && !StrCmpIW(parts->pszServer, L"localhost"))
        parts->pszServer = NULL;
}

PRIVATE VOID BreakServer(LPWSTR *ppsz, PURLPARTS parts, BOOL fConvert)
{
    if(!**ppsz || parts->dwFlags & UPF_SCHEME_OPAQUE)
        return;

    //
    //  APPCOMPAT - we pretend that whacks are the equiv of slashes - zekel 17-MAR-97
    //  this is because the internet uses slashes and DOS
    //  uses whacks.  so for useability's sake we allow both.
    //  but not in all cases.  in particular, the "mk:" stream
    //  protocol depends upon the buggy behavior of one of IE30's
    //  many URL parsers treating relative URLs with whacks as one
    //  segment.
    //  NOTE:  IE30 had inconsistent behavior WRT URLs.  so we handled
    //  this case differently depending on when we saw, looked, touched, or
    //  played with these URLs.  wininet would always convert, but mshtml
    //  sometimes would other times not.
    //
    //  with MK: we cannot convert the base, or the relative
    //  but in breakpath we have to allow for the use of WHACK
    //  to indicate a root path
    //
    //  we dont have to fProtectExtra because query and fragments
    //  are already broken off if necessary.
    if (fConvert)
        ConvertChar(*ppsz, WHACK, SLASH, FALSE);

    switch(parts->eScheme)
    {
    case URL_SCHEME_FILE:
        FileBreakServer(ppsz, parts);
        break;

    case URL_SCHEME_MK:
        MkBreakServer(ppsz, parts);
        break;

    default:
        DefaultBreakServer(ppsz, parts);
        break;
    }
}

PRIVATE VOID DefaultBreakSegments(LPWSTR psz, PURLPARTS parts)
{
    WCHAR *pch;

    while (pch = StrChrW(psz, SLASH))
    {
        parts->cSegments++;
        TERMSTR(pch);
        psz = pch + 1;
    }

    if(!*psz || IsDot(psz) || IsDotDot(psz))
    {
        if (!*psz && parts->cSegments > 1)
            parts->cSegments--;

        parts->dwFlags |= UPF_EXSEG_DIRECTORY;
    }
}

PRIVATE VOID DefaultBreakPath(LPWSTR *ppsz, PURLPARTS parts)
{
    if(!**ppsz)
        return;

    //
    //  this will keep the drive letter from being backed up over
    //  during canonicalization.  if we want keep the UNC share
    //  from being backed up we should do it here
    //  or in FileBreakServer() similarly
    //
    if(IsDrive(*ppsz))
    {
        parts->dwFlags |= UPF_SEG_LOCKFIRST;
        // also convert "c|" to "c:"
    }

    parts->pszSegments = *ppsz;
    parts->cSegments = 1;

    if(!(parts->dwFlags & UPF_SCHEME_OPAQUE))
        DefaultBreakSegments(parts->pszSegments, parts);

}

PRIVATE VOID BreakPath(LPWSTR *ppsz, PURLPARTS parts)
{
    if(!**ppsz)
        return;

    if (parts->dwFlags & UPF_SCHEME_OPAQUE)
    {
        parts->pszSegments = *ppsz;
        parts->cSegments = 1;
    }
    else
    {
        //
        //  we only need to check for absolute when there was
        //  no server segment.  if there was a server segment,
        //  then absolute has already been set, and we need
        //  to preserve any separators that exist in the path
        //
        if(!parts->pszServer && IsSeparator(*ppsz))
        {
            parts->dwFlags |= UPF_SEG_ABSOLUTE;
            (*ppsz)++;
        }

        DefaultBreakPath(ppsz, parts);
    }
}


BOOL _ShouldBreakBase(PURLPARTS parts, LPCWSTR pszBase)
{
    if (pszBase)
    {
        if (!parts->pszScheme)
            return TRUE;

        DWORD cch;
        LPCWSTR pszScheme = FindSchemeW(pszBase, &cch);

        //  this means that this will only optimize on known schemes
        //  if both urls use URL_SCHEME_UNKNOWN...then we parse both.
        if (pszScheme && parts->eScheme == GetSchemeTypeAndFlagsW(pszScheme, cch, NULL))
            return TRUE;

    }

    return FALSE;
}

/*+++

  BreakUrl()
    Break a URL for its consituent parts

  Parameters
  IN -
            the URL to crack open, need not be fully qualified

  OUT -
    parts       absolute or relative may be nonzero (but not both).
                host, anchor and access may be nonzero if they were specified.
                Any which are nonzero point to zero terminated strings.

  Returns
    VOID

  Details -

  WARNING !! function munges the incoming buffer

---*/

#define BreakUrl(s, p)         BreakUrls(s, p, NULL, NULL, NULL, 0)

//
//  **BreakUrls()**
//  RETURNS
//  S_OK        if the two urls need to be blended
//  S_FALSE     if pszUrl is absolute, or there is no pszBase
//  failure     some sort of memory allocation error
//
PRIVATE HRESULT
BreakUrls(LPWSTR pszUrl, PURLPARTS parts, LPCWSTR pszBase, PSHSTRW pstrBase, PURLPARTS partsBase, DWORD dwFlags)
{
    HRESULT hr = S_FALSE;
    ASSERT(pszUrl && parts);

    ZeroMemory(parts, SIZEOF(URLPARTS));

    if(!*pszUrl)
        parts->dwFlags |= UPF_SEG_EMPTYSEG;

    //
    //  WARNING: this order is specific, according to the proposed standard
    //
    if(*pszUrl || pszBase)
    {
        BOOL fConvert;

        BreakScheme(&pszUrl, parts);
        BreakFragment(&pszUrl, parts);
        BreakQuery(&pszUrl, parts);

        //
        //  this is the first time that we need to access
        //  pszBase if it exists, so this is when we copy and parse
        //
        if (_ShouldBreakBase(parts, pszBase))
        {
            hr = CopyUrlForParse(pszBase, pstrBase, dwFlags);

            //  this will be some kind of memory error
            if(FAILED(hr))
                return hr;

            // ASSERT(hr != S_FALSE);

            BreakUrl(pstrBase->GetInplaceStr(), partsBase);
            fConvert = (partsBase->dwFlags & UPF_SCHEME_CONVERT);
        }
        else
            fConvert = (parts->dwFlags & UPF_SCHEME_CONVERT);

        BreakServer(&pszUrl, parts, fConvert);
        BreakPath(&pszUrl, parts);
    }

    return hr;
}


/*+++
  BlendParts()  & all dependant Blend* functions
        Blends the parts structures into one, taking the relavent
        bits from each one and dumping the unused data.

  Parameters
  IN -
    partsUrl        the primary or relative parts   - Takes precedence
    partsBase       the base or referrers parts

  OUT -
    partsOut        the combined result

  Returns
  VOID -

  NOTE:  this will frequently NULL out the entire partsBase.
---*/

PRIVATE VOID
BlendScheme(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    if(partsUrl->pszScheme)
    {
        LPCWSTR pszScheme = partsOut->pszScheme = partsUrl->pszScheme;
        URL_SCHEME eScheme = partsOut->eScheme = partsUrl->eScheme;

        partsOut->dwFlags |= (partsUrl->dwFlags & UPF_SCHEME_MASK);

        //
        //  this checks to make sure that these are the same scheme, and
        //  that the scheme is allowed to be used in relative URLs
        //  file: is not allowed to because of weirdness with drive letters
        //  and \\UNC\shares
        //
        if ((eScheme && (eScheme != partsBase->eScheme) || eScheme == URL_SCHEME_FILE) ||
            (!partsBase->pszScheme) ||
            (partsBase->pszScheme && StrCmpW(pszScheme, partsBase->pszScheme)))
        {
            //  they are different schemes.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszScheme = partsBase->pszScheme;
        partsOut->eScheme = partsBase->eScheme;
        partsOut->dwFlags |= (partsBase->dwFlags & UPF_SCHEME_MASK);
    }
}

PRIVATE VOID
BlendServer(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    ASSERT(partsUrl && partsBase && partsOut);

    //
    //  if we have different hosts then everything but the pszAccess is DUMPED
    //
    if(partsUrl->pszServer)
    {
        partsOut->pszServer = partsUrl->pszServer;
        // NOTUSED partsOut->dwFlags |= (partsUrl->dwFlags & UPF_SERVER_MASK);

        if ((partsBase->pszServer && StrCmpW(partsUrl->pszServer, partsBase->pszServer)))
        {
            //  they are different Servers.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszServer = partsBase->pszServer;
        // NOTUSED partsOut->dwFlags |= (partsBase->dwFlags & UPF_SERVER_MASK);
    }
}

PRIVATE VOID
BlendPath(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    ASSERT(partsUrl && partsBase && partsOut);

    if (partsUrl->dwFlags & UPF_SEG_ABSOLUTE)
    {
        if((partsBase->dwFlags & UPF_SEG_LOCKFIRST) &&
            !(partsUrl->dwFlags & UPF_SEG_LOCKFIRST))
        {
            // this keeps the drive letters when necessary
            partsOut->pszSegments = partsBase->pszSegments;
            partsOut->cSegments = 1;  // only keep the first segment
            partsOut->dwFlags |= (partsBase->dwFlags & UPF_SEG_MASK) ;

            partsOut->pszExtraSegs = partsUrl->pszSegments;
            partsOut->cExtraSegs = partsUrl->cSegments;
            partsOut->dwFlags |= (partsUrl->dwFlags & UPF_EXSEG_MASK);
        }
        else
        {


            //  just use the absolute path

            partsOut->pszSegments = partsUrl->pszSegments;
            partsOut->cSegments = partsUrl->cSegments;
            partsOut->dwFlags |= (partsUrl->dwFlags & (UPF_SEG_MASK |UPF_EXSEG_MASK) );
        }

        ZeroMemory(partsBase, SIZEOF(URLPARTS));

    }
    else if ((partsBase->dwFlags & UPF_SEG_ABSOLUTE))
    {
        //  Adopt path not name
        partsOut->pszSegments = partsBase->pszSegments;
        partsOut->cSegments = partsBase->cSegments;
        partsOut->dwFlags |= (partsBase->dwFlags & UPF_SEG_MASK );

        if(partsUrl->cSegments || partsUrl->dwFlags & UPF_SEG_EMPTYSEG)
        {
            //
            // this a relative path that needs to be combined
            //

            partsOut->pszExtraSegs = partsUrl->pszSegments;
            partsOut->cExtraSegs = partsUrl->cSegments;
            partsOut->dwFlags |= (partsUrl->dwFlags & UPF_EXSEG_MASK );

            if (!(partsBase->dwFlags & UPF_EXSEG_DIRECTORY))
            {
                //
                //  knock off the file name segment
                //  as long as the it isnt the first or the first is not locked
                //  or it isnt a dotdot.  in the case of http://site/dir/, dir/ is
                //  not actually killed, only the NULL terminator following it is.
                //
                LPWSTR pszLast = LastLiveSegment(partsOut->pszSegments, partsOut->cSegments, partsOut->dwFlags & UPF_SEG_LOCKFIRST);

                if(pszLast && !IsDotDot(pszLast))
                {
                    if(partsUrl->dwFlags & UPF_SEG_EMPTYSEG)
                        partsOut->dwFlags |= UPF_EXSEG_DIRECTORY;

                    KILLSEG(pszLast);
                }
            }
        }
        else
            partsOut->dwFlags |= (partsBase->dwFlags & UPF_EXSEG_MASK);
    }
    else if (partsUrl->cSegments)
    {
        partsOut->pszSegments = partsUrl->pszSegments;
        partsOut->cSegments = partsUrl->cSegments;
        partsOut->dwFlags |= (partsUrl->dwFlags & (UPF_SEG_MASK |UPF_EXSEG_MASK) );
    }
    else if (partsBase->cSegments)
    {
        partsOut->pszSegments = partsBase->pszSegments;
        partsOut->cSegments = partsBase->cSegments;
        partsOut->dwFlags |= (partsBase->dwFlags & (UPF_SEG_MASK |UPF_EXSEG_MASK) );

    }

    //  regardless, we want to zero if we have relative segs
    if (partsUrl->cSegments)
        ZeroMemory(partsBase, SIZEOF(URLPARTS));

}

PRIVATE VOID
BlendQuery(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    if(partsUrl->pszQuery)
    {
        LPCWSTR pszQuery = partsOut->pszQuery = partsUrl->pszQuery;

        // NOTUSED partsOut->dwFlags |= (partsUrl->dwFlags & UPF_Query_MASK);

        if ((partsBase->pszQuery && StrCmpW(pszQuery, partsBase->pszQuery)))
        {
            //  they are different Querys.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszQuery = partsBase->pszQuery;
        // NOTUSED partsOut->dwFlags |= (partsBase->dwFlags & UPF_Query_MASK);
    }
}

PRIVATE VOID
BlendFragment(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    if(partsUrl->pszFragment || partsUrl->cSegments)
    {
        LPCWSTR pszFragment = partsOut->pszFragment = partsUrl->pszFragment;

        // NOTUSED partsOut->dwFlags |= (partsUrl->dwFlags & UPF_Fragment_MASK);

        if ((partsBase->pszFragment && StrCmpW(pszFragment, partsBase->pszFragment)))
        {
            //  they are different Fragments.  DUMP partsBase.

            ZeroMemory(partsBase, SIZEOF(URLPARTS));
        }
    }
    else
    {
        partsOut->pszFragment = partsBase->pszFragment;
        // NOTUSED partsOut->dwFlags |= (partsBase->dwFlags & UPF_Fragment_MASK);
    }
}

PRIVATE VOID
BlendParts(PURLPARTS partsUrl, PURLPARTS partsBase, PURLPARTS partsOut)
{
    //
    //  partsUrl always takes priority over partsBase
    //

    ASSERT(partsUrl && partsBase && partsOut);

    ZeroMemory(partsOut, SIZEOF(URLPARTS));

    BlendScheme( partsUrl,  partsBase,  partsOut);
    BlendServer( partsUrl,  partsBase,  partsOut);
    BlendPath( partsUrl,  partsBase,  partsOut);
    BlendQuery( partsUrl,  partsBase,  partsOut);
    BlendFragment( partsUrl,  partsBase,  partsOut);

}

PRIVATE VOID
CanonServer(PURLPARTS parts)
{
    //
    //  we only do stuff if this server is an internet style
    //  server.  that way it uses FQDNs and IP port numbers
    //
    if (parts->pszServer && (parts->dwFlags & UPF_SCHEME_INTERNET))
    {

        LPWSTR pszName = StrRChrW(parts->pszServer, NULL, L'@');

        if(!pszName)
            pszName = parts->pszServer;

        //  this should just point to the FQDN:Port
        CharLowerW(pszName);

        //
        //  Ignore default port numbers, and trailing dots on FQDNs
        //  which will only cause identical adresses to look different
        //
        {
            WCHAR *pch = StrChrW(pszName, COLON);

            if (pch && parts->eScheme)
            {
                BOOL fIgnorePort = FALSE;

                //
                //  FEATURE we should actually be getting this from
                //  the services file to find out the default protocol port
                //  but we dont think that most people will change them - zekel 17-Dec-96
                //
                switch(parts->eScheme)
                {
                case URL_SCHEME_HTTP:
                        if(StrCmpW(pch, L":80") == 0)
                            fIgnorePort = TRUE;
                        break;

                case URL_SCHEME_FTP:
                        if(StrCmpW(pch, L":21") == 0)
                            fIgnorePort = TRUE;
                        break;

                case URL_SCHEME_GOPHER:
                        if(StrCmpW(pch, L":70") == 0)
                            fIgnorePort = TRUE;
                        break;

                case URL_SCHEME_HTTPS:
                        if(StrCmpW(pch, L":443") == 0)
                            fIgnorePort = TRUE;
                        break;

                default:
                    break;
                }
                if(fIgnorePort)
                    TERMSTR(pch);  // It is the default: ignore it
            }

        }
    }
}


PRIVATE VOID
CanonCombineSegs(PURLPARTS parts)
{
    ASSERT(parts);
    ASSERT(parts->pszExtraSegs && parts->cExtraSegs);

    LPWSTR pszLast = LastLiveSegment(parts->pszSegments, parts->cSegments, parts->dwFlags & UPF_SEG_LOCKFIRST);

    LPWSTR pszExtra = parts->pszExtraSegs;
    DWORD iExtra = 0;
    DWORD cExtras = parts->cExtraSegs;

    if(!IsLiveSegment(pszExtra))
        pszExtra = NextLiveSegment(pszExtra, &iExtra, cExtras);

    while(pszExtra && IsDotDot(pszExtra))
    {
        if (pszLast)
            KILLSEG(pszLast);

        KILLSEG(pszExtra);

        pszLast = LastLiveSegment(parts->pszSegments, parts->cSegments, parts->dwFlags & UPF_SEG_LOCKFIRST);
        pszExtra = NextLiveSegment(pszExtra, &iExtra, cExtras);
    }
}

PRIVATE VOID
CanonSegments(LPWSTR pszSeg,
              DWORD cSegs,
              BOOL fLockFirst)

{
    DWORD  iSeg = 0;
    LPWSTR pszLastSeg = NULL;
    LPWSTR pszFirstSeg = pszSeg;
    BOOL fLastIsFirst = TRUE;
    BOOL fFirstSeg = TRUE;

    ASSERT (pszSeg && cSegs);

    pszSeg = FirstLiveSegment(pszSeg, &iSeg, cSegs);

    while (pszSeg)
    {
        if(IsDot(pszSeg))
        {
            //  if it is just a "." we can discard the segment
            KILLSEG(pszSeg);
        }

        else if(IsDotDot(pszSeg))
        {
            //  if it is ".." then we discard it and the last seg

            //
            //  if we are at the first (root) or
            //  the last is the root and it is locked
            //  then we dont want to do anything
            //
            if(pszLastSeg && !IsDotDot(pszLastSeg) && !(fLastIsFirst && fLockFirst))
            {
                KILLSEG(pszLastSeg);
                pszLastSeg = NULL;
                KILLSEG(pszSeg);
            }
        }

        if(IsLiveSegment(pszSeg))
        {
            if(!pszLastSeg && fFirstSeg)
                fLastIsFirst = TRUE;
            else
                fLastIsFirst = FALSE;

            pszLastSeg = pszSeg;
            fFirstSeg = FALSE;
        }
        else
        {
            pszLastSeg = LastLiveSegment(pszFirstSeg, iSeg, fLockFirst);
        }

        pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);

    }
}

PRIVATE VOID
CanonPath(PURLPARTS parts)
{

    ASSERT(parts);

    if(parts->cSegments)
        CanonSegments(parts->pszSegments, parts->cSegments, (parts->dwFlags & UPF_SEG_LOCKFIRST));

    if(parts->cExtraSegs)
        CanonSegments(parts->pszExtraSegs, parts->cExtraSegs, FALSE);

    if(parts->cExtraSegs)
        CanonCombineSegs(parts);
}


PRIVATE VOID
CanonParts(PURLPARTS parts)
{
    ASSERT(parts);

    //CanonScheme(parts);
    CanonServer(parts);
    CanonPath(parts);
    //CanonQuery(parts);
    //CanonFragment(parts);
}

PRIVATE HRESULT
BuildScheme(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    if(parts->pszScheme)
    {
        hr = pstr->Append(parts->pszScheme);
        if(SUCCEEDED(hr))
            hr = pstr->Append(COLON);
    }

    return hr;

}

PRIVATE HRESULT
BuildServer(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    switch(parts->eScheme)
    {
    case URL_SCHEME_MK:
    // CraigC's "mk:" has no // but acts like it does
        break;

    case URL_SCHEME_FILE:
        if ((dwFlags & URL_WININET_COMPATIBILITY) || (dwFlags & URL_FILE_USE_PATHURL))
        {
            if(parts->pszServer && *parts->pszServer)
                hr = pstr->Append(L"////");
            else if (parts->pszSegments && IsDrive(parts->pszSegments))
                hr = pstr->Append(SLASH);
            else if (parts->dwFlags & UPF_SEG_ABSOLUTE)
                hr = pstr->Append(L"//");
        }
        else if (parts->dwFlags & UPF_SEG_ABSOLUTE)
            hr = pstr->Append(L"//");
        break;

    default:
        if(parts->pszServer && SUCCEEDED(hr))
            hr = pstr->Append(L"//");
        break;
    }

    if(parts->pszServer && SUCCEEDED(hr))
            hr = pstr->Append(parts->pszServer);

    return hr;
}

PRIVATE HRESULT
BuildSegments(LPWSTR pszSeg, DWORD cSegs, PSHSTRW pstr, BOOL fRoot, BOOL *pfSlashLast)
{
    DWORD iSeg = 0;
    HRESULT hr = S_FALSE;

    *pfSlashLast = FALSE;

    ASSERT(pszSeg && pstr);

    pszSeg = FirstLiveSegment(pszSeg, &iSeg, cSegs);

    if(!fRoot && pszSeg)
    {
        hr = pstr->Append(pszSeg);

        if(SUCCEEDED(hr))
            pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
        else
            pszSeg = NULL;
    }

    while (pszSeg)
    {
        hr = pstr->Append(SLASH);
        if(SUCCEEDED(hr) && *pszSeg)
        {
            hr = pstr->Append(pszSeg);
            *pfSlashLast = FALSE;
        }
        else
            *pfSlashLast = TRUE;

        if(SUCCEEDED(hr))
            pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
        else
            break;
    }

    return hr;

}


PRIVATE HRESULT
BuildPath(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;
    BOOL fSlashLast = FALSE;
    DWORD iSeg;
    LPWSTR pszSegFirst = NULL;

    ASSERT(parts && pstr);

    if(parts->cSegments)
    {
        hr = BuildSegments(parts->pszSegments, parts->cSegments, pstr, parts->dwFlags & UPF_SEG_ABSOLUTE, &fSlashLast);

        if (fSlashLast)
            pstr->Append(SLASH);


    }

    if(SUCCEEDED(hr) && parts->cExtraSegs)
    {
        BOOL f = fSlashLast;

        hr = BuildSegments(parts->pszExtraSegs, parts->cExtraSegs, pstr, !fSlashLast, &fSlashLast);

        if (fSlashLast)
            pstr->Append(SLASH);

        if (hr == S_FALSE)
            fSlashLast = f;

    }

    //  trailing slash on a server name for IIS
    if( !fSlashLast &&
        (
          (parts->dwFlags & UPF_EXSEG_DIRECTORY) ||
          //  if this is just a server name by itself
          (!FirstLiveSegment(parts->pszSegments, &iSeg, parts->cSegments) &&
          !FirstLiveSegment(parts->pszExtraSegs, &iSeg, parts->cExtraSegs) &&
          parts->dwFlags & UPF_SEG_ABSOLUTE)
        )
      )
      {
        hr = pstr->Append(SLASH);
      }

    return hr;
}



PRIVATE HRESULT
BuildQuery(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    if(parts->pszQuery)
    {
        hr = pstr->Append(QUERY);
        if(SUCCEEDED(hr))
            hr = pstr->Append(parts->pszQuery);
    }

    return hr;

}

PRIVATE HRESULT
BuildFragment(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(parts && pstr);

    if(parts->pszFragment)
    {
        hr = pstr->Append(POUND);
        if(SUCCEEDED(hr))
            hr = pstr->Append(parts->pszFragment);
    }

    return hr;

}

PRIVATE HRESULT
BuildUrl(PURLPARTS parts, DWORD dwFlags, PSHSTRW pstr)
{
    HRESULT hr;

    ASSERT(parts && pstr);

    if(
        (SUCCEEDED(hr = BuildScheme(parts, dwFlags, pstr)))      &&
        (SUCCEEDED(hr = BuildServer(parts, dwFlags, pstr)))      &&
        (SUCCEEDED(hr = BuildPath(parts, dwFlags, pstr)))        &&
        (SUCCEEDED(hr = BuildQuery(parts, dwFlags, pstr)))
        )
        hr = BuildFragment(parts, dwFlags, pstr);

    return hr;
}

/*+++

  SHUrlEscape()
    Escapes an URL
    right now, i am only escaping stuff in the Path part of the URL

  Parameters
  IN -
    pszUrl      URL to examine
    pstrOut     SHSTR destination
    dwFlags     the relevant URL_* flags,

  Returns
  HRESULT -
    SUCCESS     S_OK
    ERROR       only E_OUTOFMEMORY


  Helper Routines
    Escape*(part)           each part gets its own escape routine (ie EscapeScheme)
    EscapeSpaces            will only escape spaces (WININET compatibility mostly)
    EscapeSegmentsGetNeededSize     gets the required size of destination buffer for all path segments
    EscapeLiveSegment               does the work of escaping each path segment
---*/

PRIVATE HRESULT
EscapeSpaces(LPCWSTR psz, PSHSTRW pstr, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    LPCWSTR pch;
    DWORD cSpaces = 0;


    ASSERT(psz && pstr);


    pstr->Reset();

    for (pch = psz; *pch; pch++)
    {
        if (*pch == SPC)
            cSpaces++;
    }

    if(cSpaces)
    {
        hr = pstr->SetSize(lstrlenW(psz) + cSpaces * 2 + 1);
        if(SUCCEEDED(hr))
        {
            int cchRemaing = pstr->GetSize();
            LPWSTR pchOut = pstr->GetInplaceStr();

            for (pch = psz; *pch; pch++)
            {
                if ((*pch == POUND || *pch == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
                {
                    int cchCopied;

                    StringCchCopyW(pchOut, cchRemaing, pch);
                    cchCopied = lstrlenW(pchOut);
                    pchOut += cchCopied;
                    cchRemaing -= cchCopied;
                    break;
                }

                if (*pch == SPC)
                {
                    *pchOut++ = HEX_ESCAPE;
                    *pchOut++ = L'2';
                    *pchOut++ = L'0';

                    cchRemaing -= 3;
                }
                else
                {
                    *pchOut++ = *pch;
                    cchRemaing--;
                }

                ASSERT(cchRemaing >= 0);
            }

            TERMSTR(pchOut);
        }

    }
    else
    {
        hr = pstr->SetStr(psz);
    }

    return hr;
}


inline PRIVATE HRESULT
EscapeScheme(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszScheme = partsUrl->pszScheme;
    partsOut->eScheme = partsUrl->eScheme;

    return S_OK;
}

inline PRIVATE HRESULT
EscapeServer(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszServer = partsUrl->pszServer;

    return S_OK;
}

inline PRIVATE HRESULT
EscapeQuery(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszQuery = partsUrl->pszQuery;

    return S_OK;
}

inline PRIVATE HRESULT
EscapeFragment(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    ASSERT(partsUrl && partsOut);

    partsOut->pszFragment = partsUrl->pszFragment;

    return S_OK;
}

PRIVATE BOOL
GetEscapeStringSize(LPWSTR psz, DWORD dwFlags, LPDWORD pcch)

{
    BOOL fResize = FALSE;
    ASSERT(psz);
    ASSERT(pcch);


    for (*pcch = 0; *psz; psz++)
    {
        (*pcch)++;

        if(!IsSafePathChar(*psz) ||
            ((dwFlags & URL_ESCAPE_PERCENT) && (*psz == HEX_ESCAPE)))
        {
            fResize = TRUE;
            *pcch += 2;
        }

    }

    // for the NULL term
    (*pcch)++;

    return fResize;
}

PRIVATE DWORD
EscapeSegmentsGetNeededSize(LPWSTR pszSegments, DWORD cSegs, DWORD dwFlags)
{
    DWORD cchNeeded = 0;
    BOOL fResize = FALSE;
    LPWSTR pszSeg;
    DWORD iSeg;

    ASSERT(pszSegments && cSegs);

    pszSeg = FirstLiveSegment(pszSegments, &iSeg, cSegs);

    while (IsLiveSegment(pszSeg))
    {
        DWORD cch;

        if(GetEscapeStringSize(pszSeg, dwFlags, &cch))
            fResize = TRUE;
        cchNeeded += cch;

        pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
    }

    return fResize ? cchNeeded : 0;
}

PRIVATE VOID
EscapeString(LPCWSTR pszSeg, DWORD dwFlags, LPWSTR *ppchOut)
{
    LPWSTR pchIn;   // This pointer has been trusted to not modify it's contents, just iterate.
    LPWSTR pchOut = *ppchOut;
    WCHAR ch;

    for (pchIn = (LPWSTR)pszSeg; *pchIn; pchIn++)
    {
        ch = *pchIn;

        if (!IsSafePathChar(ch) ||
            ((dwFlags & URL_ESCAPE_PERCENT) && (ch == HEX_ESCAPE)))
        {
            *pchOut++ = HEX_ESCAPE;
            *pchOut++ = hex[(ch >> 4) & 15];
            *pchOut++ = hex[ch & 15];

        }
        else
            *pchOut++ = *pchIn;
    }

    TERMSTR(pchOut);

    // move past the terminator
    pchOut++;

    *ppchOut = pchOut;

}

PRIVATE HRESULT
EscapeSegments(LPWSTR pszSegments, DWORD cSegs, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    DWORD cchNeeded;

    HRESULT hr = S_OK;

    ASSERT(pszSegments && cSegs && partsOut && pstr);

    cchNeeded = EscapeSegmentsGetNeededSize(pszSegments, cSegs, dwFlags);

    if(cchNeeded)
    {
        ASSERT(pstr);

        hr = pstr->SetSize(cchNeeded);

        if(SUCCEEDED(hr))
        {
            LPWSTR pchOut = pstr->GetInplaceStr();
            LPWSTR pszSeg;
            DWORD iSeg;

            partsOut->pszSegments = pchOut;
            partsOut->cSegments = 0;

            pszSeg = FirstLiveSegment(pszSegments, &iSeg, cSegs);

            while (IsLiveSegment(pszSeg))
            {
                EscapeString(pszSeg, dwFlags, &pchOut);
                partsOut->cSegments++;

                pszSeg = NextLiveSegment(pszSeg, &iSeg, cSegs);
            }


        }

    }
    else
    {
        partsOut->cSegments = cSegs;
        partsOut->pszSegments = pszSegments;
    }


    return hr;
}

PRIVATE HRESULT
EscapePath(PURLPARTS partsUrl, DWORD dwFlags, PURLPARTS partsOut, PSHSTRW pstr)
{
    HRESULT hr = S_OK;

    ASSERT(partsUrl && partsOut && pstr);

    if(partsUrl->cSegments)
    {
        hr = EscapeSegments(partsUrl->pszSegments, partsUrl->cSegments, dwFlags, partsOut, pstr);

    }
    else
    {
        partsOut->cSegments = 0;
        partsOut->pszSegments = NULL;
    }

    return hr;
}

HRESULT
SHUrlEscape (LPCWSTR pszUrl,
             PSHSTRW pstrOut,
             DWORD dwFlags)
{
#ifdef TESTING_SPACES_ONLY
    return EscapeSpaces(pszUrl, pstrOut, dwFlags);
#else //TESTING_SPACES_ONLY

    SHSTRW strUrl;
    HRESULT hr;

    ASSERT(pszUrl && pstrOut);
    if(!pszUrl || !pstrOut)
        return E_INVALIDARG;

    //
    //  EscapeSpaces is remarkably poor,
    //  but so is this kind of functionality...
    //  it doesnt do any kind of real parsing, it
    //  only looks for spaces and escapes them...
    //
    if(dwFlags & URL_ESCAPE_SPACES_ONLY)
        return EscapeSpaces(pszUrl, pstrOut, dwFlags);

    //  We are just passed a segment so we only want to
    //  escape that and nothing else.  Don't look for
    //  URL pieces.
    if(dwFlags & URL_ESCAPE_SEGMENT_ONLY)
    {
        URLPARTS partsOut;
        SHSTRW strTemp;

        EscapeSegments((LPWSTR)pszUrl, 1, dwFlags, &partsOut, &strTemp);
        pstrOut->SetStr(partsOut.pszSegments);
        return S_OK;
    }

    pstrOut->Reset();

    hr = strUrl.SetStr(pszUrl);

    if(SUCCEEDED(hr))
    {
        URLPARTS partsUrl, partsOut;
        SHSTRW strPath;

        BreakUrl(strUrl.GetInplaceStr(), &partsUrl);

        ZeroMemory(&partsOut, SIZEOF(URLPARTS));
        //
        //  NOTE the only function here that is really active right now is the EscapePath
        //  if some other part needs to be escaped, then add a new SHSTR in the 4th param
        //  and change the appropriate subroutine
        //

        if(
            (SUCCEEDED(hr = EscapeScheme(&partsUrl, dwFlags, &partsOut, NULL)))
            && (SUCCEEDED(hr = EscapeServer(&partsUrl, dwFlags, &partsOut, NULL)))
            && (SUCCEEDED(hr = EscapePath(&partsUrl, dwFlags, &partsOut, &strPath)))
            && (SUCCEEDED(hr = EscapeQuery(&partsUrl, dwFlags, &partsOut, NULL)))
            && (SUCCEEDED(hr = EscapeFragment(&partsUrl, dwFlags, &partsOut, NULL)))
           )
        {
            partsOut.dwFlags = partsUrl.dwFlags;

            hr = BuildUrl(&partsOut, dwFlags, pstrOut);
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
#endif //TESTING_SPACES_ONLY
}


/*+++

  SHUrlUnescape()
    Unescapes a string in place.  this is ok because
    it should never grow

  Parameters
  IN -
    psz         string to unescape inplace
    dwFlags     the relevant URL_* flags,

  Returns
  HRESULT -
    SUCCESS     S_OK
    ERROR       DOESNT error right now


  Helper Routines
    HexToWord               takes a hexdigit and returns WORD with the right number or -1
    IsEscapedChar           looks at a ptr for "%XX" where X is a hexdigit
    TranslateEscapedChar    translates "%XX" to an 8 bit char
---*/

PRIVATE WORD
HexToWord(WCHAR ch)
{
    if(ch >= TEXT('0') && ch <= TEXT('9'))
        return (WORD) ch - TEXT('0');
    if(ch >= TEXT('A') && ch <= TEXT('F'))
        return (WORD) ch - TEXT('A') + 10;
    if(ch >= TEXT('a') && ch <= TEXT('f'))
        return (WORD) ch - TEXT('a') + 10;

    ASSERT(FALSE);  //we have tried to use a non-hex number
    return (WORD) -1;
}

PRIVATE BOOL inline
IsEscapedOctetW(LPCWSTR pch)
{
    return (pch[0] == HEX_ESCAPE && IsHex(pch[1]) && IsHex(pch[2])) ? TRUE : FALSE;
}

PRIVATE BOOL inline
IsEscapedOctetA(LPCSTR pch)
{
    return (pch[0] == HEX_ESCAPE_A && IsHex((WCHAR)pch[1]) && IsHex((WCHAR)pch[2])) ? TRUE : FALSE;
}

PRIVATE WCHAR
TranslateEscapedOctetW(LPCWSTR pch)
{
    WCHAR ch;
    ASSERT(IsEscapedOctetW(pch));

    pch++;
    ch = (WCHAR) HexToWord(*pch++) * 16; // hi nibble
    ch += HexToWord(*pch); // lo nibble

    return ch;
}

PRIVATE CHAR
TranslateEscapedOctetA(LPCSTR pch)
{
    CHAR ch;
    ASSERT(IsEscapedOctetA(pch));

    pch++;
    ch = (CHAR) HexToWord(*pch++) * 16; // hi nibble
    ch += HexToWord(*pch); // lo nibble

    return ch;
}


HRESULT SHUrlUnescapeA(LPSTR psz, DWORD dwFlags)
{
    CHAR *pchSrc = psz;
    CHAR *pchDst = psz;

    while (*pchSrc)
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            while (*pchDst++ = *pchSrc++) {};
            break;
        }

        if (IsEscapedOctetA(pchSrc))
        {
            CHAR ch =  TranslateEscapedOctetA(pchSrc);

            *pchDst++ = ch;

            pchSrc += 3; // enuff for "%XX"
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return S_OK;
}


HRESULT SHUrlUnescapeW(LPWSTR psz, DWORD dwFlags)
{
    WCHAR *pchSrc = psz;
    WCHAR *pchDst = psz;

    while (*pchSrc)
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            while (*pchDst++ = *pchSrc++) {};
            break;
        }

        if (IsEscapedOctetW(pchSrc))
        {
            WCHAR ch =  TranslateEscapedOctetW(pchSrc);
            
            *pchDst++ = ch;
            
            pchSrc += 3; // enuff for "%XX"
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return S_OK;
}

PRIVATE HRESULT
BuildDosPath(PURLPARTS parts, PSHSTRW pstrOut, DWORD dwFlags)
{
    HRESULT hr;
    //  this will disable a preceding slash when there is a drive
    if(parts->pszSegments && IsDrive(parts->pszSegments))
        parts->dwFlags = (parts->dwFlags & ~UPF_SEG_ABSOLUTE);


    //  if there is a zero length server then
    //  we skip building it
    if(parts->pszServer && !*parts->pszServer)
        parts->pszServer = NULL;


    //  this prevents all the special file goo checking
    parts->eScheme = URL_SCHEME_UNKNOWN;

    //
    //  then go ahead and put the path together
    if( (SUCCEEDED(hr = BuildServer(parts, dwFlags, pstrOut))) &&
        (!parts->cSegments || SUCCEEDED(hr = BuildPath(parts, dwFlags, pstrOut)))
      )
    {
        //  then decode it cuz paths arent escaped
        if (IsFlagSet(dwFlags, URL_FILE_USE_PATHURL))
            WininetFixFileSlashes(pstrOut->GetInplaceStr());
        else
#ifndef UNIX
            ConvertChar(pstrOut->GetInplaceStr(), SLASH, WHACK, TRUE);
#else
            ConvertChar(pstrOut->GetInplaceStr(), WHACK, SLASH, TRUE);
#endif

        if(IsFlagClear(parts->dwFlags, UPF_FILEISPATHURL))
            SHUrlUnescapeW(pstrOut->GetInplaceStr(), dwFlags);

        if(IsDriveUrl(*pstrOut))
        {
            LPWSTR pszTemp = pstrOut->GetInplaceStr();

            pszTemp[1] = COLON;
        }
    }

    return hr;

}
HRESULT
SHPathCreateFromUrl(LPCWSTR pszUrl, PSHSTRW pstrOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strUrl;

    ASSERT(pszUrl && pstrOut);

    pstrOut->Reset();
    hr = strUrl.SetStr(pszUrl);

    if(SUCCEEDED(hr))
    {
        URLPARTS partsUrl;

        //  first we need to break it open
        BreakUrl(strUrl.GetInplaceStr(), &partsUrl);

        //  then we make sure it is a file:
        if(partsUrl.eScheme == URL_SCHEME_FILE)
        {
            hr = BuildDosPath(&partsUrl, pstrOut, dwFlags);
        }
        else
            hr = E_INVALIDARG;
    }
    return hr;
}


HRESULT
SHUrlCreateFromPath(LPCWSTR pszPath, PSHSTRW pstrOut, DWORD dwFlags)
{
        HRESULT hr;
        SHSTRW strPath;
        ASSERT(pszPath && pstrOut);

        if(PathIsURLW(pszPath))
        {
            if(SUCCEEDED(hr = pstrOut->SetStr(pszPath)))
                return S_FALSE;
            else
                return hr;
        }


        pstrOut->Reset();
        hr = strPath.SetStr(pszPath);

        TrimAndStripInsignificantWhite(strPath.GetInplaceStr());

        if(SUCCEEDED(hr))
        {
            URLPARTS partsIn, partsOut;
            SHSTRW strEscapedPath, strEscapedServer;
            LPWSTR pch = strPath.GetInplaceStr();

            ZeroMemory(&partsIn, SIZEOF(URLPARTS));

            partsIn.pszScheme = (LPWSTR)c_szFileScheme;
            partsIn.eScheme = URL_SCHEME_FILE;
            partsIn.dwFlags = UPF_SCHEME_CONVERT;

            //  first break the path
            BreakFragment(&pch, &partsIn);
            BreakServer(&pch, &partsIn, TRUE);
            BreakPath(&pch, &partsIn);

            partsOut = partsIn;

            //  then escape the path if we arent using path URLs
            if (IsFlagClear(dwFlags, URL_FILE_USE_PATHURL))
            {
                hr = EscapePath(&partsIn, dwFlags | URL_ESCAPE_PERCENT, &partsOut, &strEscapedPath);

                if(SUCCEEDED(hr) && partsOut.pszServer)
                {
                    //
                    //  i am treating the pszServer exactly like a path segment
                    //

                    DWORD cchNeeded;

                    if(GetEscapeStringSize(partsOut.pszServer, dwFlags | URL_ESCAPE_PERCENT, &cchNeeded) &&
                        SUCCEEDED(hr = strEscapedServer.SetSize(cchNeeded)))
                    {
                        pch = strEscapedServer.GetInplaceStr();

                        EscapeString(partsOut.pszServer, dwFlags | URL_ESCAPE_PERCENT, &pch);
                        partsOut.pszServer = strEscapedServer.GetInplaceStr();
                    }
                }
            }

            if(!partsOut.pszServer && IsFlagSet(partsOut.dwFlags, UPF_SEG_ABSOLUTE))
                partsOut.pszServer = L"";

            //  then build the URL
            if(SUCCEEDED(hr))
            {
                if(URL_SCHEME_FILE == partsOut.eScheme && IsFlagSet(dwFlags, URL_FILE_USE_PATHURL))
                {
                    if (SUCCEEDED(hr = pstrOut->SetStr(c_szFileSchemeString)))
                        hr = BuildDosPath(&partsOut, pstrOut, dwFlags);
                }
                else
                    hr = BuildUrl(&partsOut, dwFlags, pstrOut);
            }

            if (SUCCEEDED(hr) && (IsFlagSet(dwFlags, URL_WININET_COMPATIBILITY)))
                WininetFixFileSlashes(pstrOut->GetInplaceStr());
        }

        return hr;
}


/*+++

  SHUrlParse()
    Canonicalize an URL
    or Combine and Canonicalize two URLs

  Parameters
  IN -
    pszBase     the base or referring URL, may be NULL
    pszUrl      the relative URL
    dwFlags     the relevant URL_* flags,

  Returns
  HRESULT -
    SUCCESS     S_OK
    ERROR       appropriate error, usually just E_OUTOFMEMORY;

  NOTE:  pszUrl will always take precedence over pszBase.

---*/
HRESULT SHUrlParse(LPCWSTR pszBase, LPCWSTR pszUrl, PSHSTRW pstrOut, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    URLPARTS partsUrl, partsOut, partsBase;

    SHSTRW strBase;
    SHSTRW strUrl;
    ASSERT(pszUrl);
    ASSERT(pstrOut);

    TraceMsgW(TF_URL | TF_FUNC, "entering SHUrlParse(%s, %s, 0x%X", pszBase,pszUrl ? pszUrl : L"NULL", dwFlags);

    pstrOut->Reset();

    //
    // Don't bother parsing if all we have in an inter-page link as the
    // pszUrl and no pszBase to parse
    //

    if (pszUrl[0] == POUND && (!pszBase || !*pszBase))
    {
        hr = pstrOut->SetStr(pszUrl);

        goto quit;
    }


    //
    //  for Perf reasons we want to parse the relative url first.
    //  if it is an absolute URL, we need never look at the base.
    //

    hr = CopyUrlForParse(pszUrl, &strUrl, dwFlags);

    if(FAILED(hr))
        goto quit;

    // -- Cybersitter compat ----
    // Some bug fix broke the original parser. No time to go back and
    // fix it, but since we know what to expect, we'll return this straight instead.
    // Basically, when we canonicalize ://, we produce :///
    if (!StrCmpW(strUrl, L"://"))
    {
        hr = pstrOut->SetStr(L":///");
        goto quit;
    }

    //
    //  BreakUrls will decide if it is necessary to look at the relative
    //
    hr = BreakUrls(strUrl.GetInplaceStr(), &partsUrl, pszBase, &strBase, &partsBase, dwFlags);

    if(FAILED(hr))
        goto quit;

    if(S_OK == hr)    {
        //
        //  this is where the real combination logic happens
        //  this first parts is the one that takes precedence
        //
        BlendParts(&partsUrl, &partsBase, &partsOut);
    }
    else
        partsOut = partsUrl;


    //
    //  we will now do the work of putting it together
    //  if these fail, it is because we are out of memory.
    //

    if (!(dwFlags & URL_DONT_SIMPLIFY))
        CanonParts(&partsOut);

    if(URL_SCHEME_FILE == partsOut.eScheme && IsFlagSet(dwFlags, URL_FILE_USE_PATHURL))
    {
        if (SUCCEEDED(hr = pstrOut->SetStr(c_szFileSchemeString)))
            hr = BuildDosPath(&partsOut, pstrOut, dwFlags);
    }
    else
        hr = BuildUrl(&partsOut, dwFlags, pstrOut);


    if(SUCCEEDED(hr))
    {
        if (dwFlags & URL_UNESCAPE)
            SHUrlUnescapeW(pstrOut->GetInplaceStr(), dwFlags);

        if (dwFlags & URL_ESCAPE_SPACES_ONLY || dwFlags & URL_ESCAPE_UNSAFE)
        {
            //
            //  we are going to reuse strUrl here
            //
            hr = strUrl.SetStr(*pstrOut);

            if(SUCCEEDED(hr))
                hr = SHUrlEscape(strUrl, pstrOut, dwFlags);
        }
    }

    if (SUCCEEDED(hr) &&
        (IsFlagSet(dwFlags, URL_WININET_COMPATIBILITY))  &&
        (partsOut.eScheme == URL_SCHEME_FILE))
        WininetFixFileSlashes(pstrOut->GetInplaceStr());


quit:


    if(FAILED(hr))
    {
        pstrOut->Reset();
        TraceMsg(TF_URL | TF_FUNC, TEXT("FAILED SHUrlParse() hr = 0x%X\n"), hr);
    }
    else
        TraceMsgW(TF_URL | TF_FUNC, "SUCCEEDED SHUrlParse() %s\n", (LPCWSTR)*pstrOut);


    return hr;

}

typedef struct _LOGON {
    LPWSTR pszUser;
    LPWSTR pszPass;
    LPWSTR pszHost;
    LPWSTR pszPort;
} LOGON, *PLOGON;

PRIVATE void
BreakLogon(LPWSTR psz, PLOGON plo)
{
    ASSERT(psz);
    ASSERT(plo);

    WCHAR *pch = StrChrW(psz, L'@');
    if(pch)
    {
        TERMSTR(pch);
        plo->pszHost = pch + 1;

        plo->pszUser = psz;
        pch = StrChrW(psz, COLON);
        if (pch)
        {
            TERMSTR(pch);
            plo->pszPass = pch + 1;
        }
    }
    else
        plo->pszHost = psz;

    pch = StrChrW(plo->pszHost, COLON);
    if (pch)
    {
        TERMSTR(pch);
        plo->pszPort = pch + 1;
    }
}

PRIVATE HRESULT
InternetGetPart(DWORD dwPart, PURLPARTS parts, PSHSTRW pstr, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    if(parts->pszServer)
    {
        LOGON lo = {0};

        BreakLogon(parts->pszServer, &lo);

        switch (dwPart)
        {
        case URL_PART_HOSTNAME:
            hr = pstr->Append(lo.pszHost);
            break;

        case URL_PART_USERNAME:
            hr = pstr->Append(lo.pszUser);
            break;

        case URL_PART_PASSWORD:
            hr = pstr->Append(lo.pszPass);
            break;

        case URL_PART_PORT:
            hr = pstr->Append(lo.pszPort);
            break;

        default:
            ASSERT(FALSE);
        }
    }
    return hr;
}

PRIVATE HRESULT
SHUrlGetPart(PSHSTRW pstrIn, PSHSTRW pstrOut, DWORD dwPart, DWORD dwFlags)
{
    ASSERT(pstrIn);
    ASSERT(pstrOut);
    ASSERT(dwPart);

    HRESULT hr = S_OK;

    URLPARTS parts;

    BreakUrl(pstrIn->GetInplaceStr(), &parts);

    if(dwFlags & URL_PARTFLAG_KEEPSCHEME)
    {
        hr = pstrOut->SetStr(parts.pszScheme);
        if(SUCCEEDED(hr))
            hr = pstrOut->Append(COLON);
    }
    else
        pstrOut->Reset();

    if(SUCCEEDED(hr))
    {
        switch (dwPart)
        {
        case URL_PART_SCHEME:
            hr = pstrOut->SetStr(parts.pszScheme);
            break;

        case URL_PART_HOSTNAME:
            if (parts.eScheme == URL_SCHEME_FILE)
            {
                hr = pstrOut->SetStr(parts.pszServer);
                break;
            }
            // else fall through
        case URL_PART_USERNAME:
        case URL_PART_PASSWORD:
        case URL_PART_PORT:
            if(parts.dwFlags & UPF_SCHEME_INTERNET)
            {
                hr = InternetGetPart(dwPart, &parts, pstrOut, dwFlags);
            }
            else
                hr = E_FAIL;
            break;

        case URL_PART_QUERY:
            hr = pstrOut->SetStr(parts.pszQuery);
            break;

        default:
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

#define c_szURLPrefixesKey "Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes"
const WCHAR c_szDefaultURLPrefixKey[]   = L"Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix";

PRIVATE inline LPCWSTR SkipLeadingSlashes(LPCWSTR psz)
{
    // Skip two leading slashes.

    if (psz[0] == SLASH && psz[1] == SLASH)
        psz += 2;

    return psz;
}

PRIVATE HRESULT
UrlGuessScheme(LPCWSTR pszUrl, PSHSTRW pstr)
{
    HRESULT hr = S_FALSE;

    ASSERT(pszUrl && pstr);

    HKEY hkeyPrefixes;

    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, c_szURLPrefixesKey, 0, KEY_QUERY_VALUE, &hkeyPrefixes)
        == ERROR_SUCCESS)
    {
        DWORD dwiValue;
        CHAR rgchValueName[MAX_PATH];
        DWORD cchValueName = SIZECHARS(rgchValueName);
        DWORD dwType;
        CHAR rgchPrefix[MAX_PATH];
        DWORD cbPrefix = SIZEOF(rgchPrefix);

        //  need to get past the initial two slashes if applicable
        pszUrl = SkipLeadingSlashes(pszUrl);

        for (dwiValue = 0;
             RegEnumValueA(hkeyPrefixes, dwiValue, rgchValueName,
                          &cchValueName, NULL, &dwType, (PBYTE)rgchPrefix,
                          &cbPrefix) == ERROR_SUCCESS;
             dwiValue++)
        {
            WCHAR wszValue[MAX_PATH];

            MultiByteToWideChar(CP_ACP, 0, rgchValueName, -1, wszValue, ARRAYSIZE(wszValue));

            //  we check to make sure that we match and there is something more
            if (!StrCmpNIW(pszUrl, wszValue, cchValueName) && pszUrl[cchValueName])
            {
                MultiByteToWideChar(CP_ACP, 0, rgchPrefix, -1, wszValue, ARRAYSIZE(wszValue));
                if(SUCCEEDED(hr = pstr->SetStr(wszValue)))
                    hr = pstr->Append(pszUrl);
                break;
            }

            cchValueName = SIZECHARS(rgchValueName);
            cbPrefix = SIZEOF(rgchPrefix);
        }

        RegCloseKey(hkeyPrefixes);
    }

    return(hr);
}

/*----------------------------------------------------------
Purpose: Grabs the default URL prefix in the registry and applies
         it to the given URL.

Returns: S_OK
         S_FALSE if there is no default prefix

*/
const WCHAR c_szDefaultScheme[] = L"http://";

HRESULT
UrlApplyDefaultScheme(
    LPCWSTR pszUrl,
    PSHSTRW pstr)
{
    HRESULT hr = S_FALSE;
    WCHAR szDef[MAX_PATH];
    DWORD cbSize = SIZEOF(szDef);

    ASSERT(pszUrl && pstr);
    ASSERT(!PathIsURLW(pszUrl));

    DWORD dwType;
    if (NO_ERROR == SHRegGetUSValueW(c_szDefaultURLPrefixKey, NULL, &dwType, (LPVOID)szDef, &cbSize, TRUE, (LPVOID)c_szDefaultScheme, SIZEOF(c_szDefaultScheme)))
    {
        pszUrl = SkipLeadingSlashes(pszUrl);

        if(SUCCEEDED(hr = pstr->SetStr(szDef)))
            hr = pstr->Append(pszUrl);
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Guesses a URL protocol based upon a list in the registry,
         compared to the first few characters of the given
         URL suffix.

Returns: S_OK if a URL protocol is determined
         S_FALSE if there were no problems but no prefix was prepended

*/
HRESULT
SHUrlApplyScheme(
    LPCWSTR pszUrl,
    PSHSTRW pstrOut,
    DWORD dwFlags)
{
    HRESULT hr = S_FALSE;

    ASSERT(IS_VALID_STRING_PTRW(pszUrl, -1));

    //
    // if there is already scheme there, we do nothing
    //  unless the caller insists.  this is to support
    //  a string that looks like www.foo.com:8001.
    //  this is a site that needs to be guessed at but
    //  it also could be a valid scheme since '.' and '-'
    //  are both valid scheme chars.
    //
    DWORD cch;
    if((dwFlags & URL_APPLY_FORCEAPPLY) || !FindSchemeW(pszUrl, &cch))
    {
        if(dwFlags & URL_APPLY_GUESSSCHEME)
            hr = UrlGuessScheme(pszUrl, pstrOut);

        if (hr != S_OK && (dwFlags & URL_APPLY_GUESSFILE))
        {
            LPCWSTR psz = FindDosPath(pszUrl);

            //  only change hr if we actually converted.
            if(psz && SUCCEEDED(SHUrlCreateFromPath(psz, pstrOut, 0)))
                hr = S_OK;
        }

        if (hr != S_OK && (dwFlags & URL_APPLY_DEFAULT || !dwFlags))
            hr = UrlApplyDefaultScheme(pszUrl, pstrOut);
    }

    return hr;
}



PRIVATE HRESULT
CopyOutA(PSHSTRA pstr, LPSTR psz, LPDWORD pcch)
{
    HRESULT hr;
    DWORD cch;
    ASSERT(pstr);
    ASSERT(psz);
    ASSERT(pcch);

    cch = pstr->GetLen();
    if ((*pcch > cch) && psz)
    {
        hr = StringCchCopyA(psz, *pcch, pstr->GetStr());
    }
    else
    {
        hr = E_POINTER;
    }

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}

//***   StrCopyOutW --
// NOTES
//  WARNING: must match semantics of CopyOutW! (esp. the *pcchOut part)
PRIVATE HRESULT
StrCopyOutW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut)
{
    HRESULT hr;
    DWORD cch;

    cch = lstrlenW(pszIn);
    if ((cch < *pcchOut) && pszOut)
    {
        hr = StringCchCopyW(pszOut, *pcchOut, pszIn);
    }
    else
    {
        hr = E_POINTER;
    }

    *pcchOut = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}

//***
// NOTES
//  WARNING: StrCopyOutW must match this func, so if you change this change
// it too
PRIVATE HRESULT
CopyOutW(PSHSTRW pstr, LPWSTR psz, LPDWORD pcch)
{
    HRESULT hr = S_OK;
    DWORD cch;
    ASSERT(pstr);
    ASSERT(psz);
    ASSERT(pcch);

    cch = pstr->GetLen();
    if((*pcch > cch) && psz)
    {
        StringCchCopyW(psz, *pcch, pstr->GetStr());
    }
    else
    {
        hr = E_POINTER;
    }

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}


LWSTDAPI
UrlCanonicalizeA(LPCSTR pszIn,
                LPSTR pszOut,
                LPDWORD pcchOut,
                DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlCanonicalizeA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlCanonicalizeA: Caller passed invalid pcchOut");
    RIPMSG(NULL==pcchOut || (pszOut && IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCanonicalizeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut == pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn
        || !pszOut
        || !pcchOut
        || !*pcchOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA("", pszIn, pszOut, pcchOut, dwFlags);
    }
    return hr;

}


LWSTDAPI
UrlEscapeA(LPCSTR pszIn,
           LPSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlEscapeA: Caller passed invalid pszin");
    RIPMSG(NULL!=pcchOut, "UrlEscapeA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlEscapeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszOut)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut)
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strUrl;

        if(SUCCEEDED(strUrl.SetStr(pszIn)))
            hr = SHUrlEscape(strUrl, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
    }

    if(SUCCEEDED(hr))
        hr = ReconcileHresults(hr, CopyOutA(&straOut, pszOut, pcchOut));

    return hr;
}

LWSTDAPI
UrlGetPartA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlGetPartA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlGetPartA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlGetPartA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut || dwPart == URL_PART_NONE)
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHUrlGetPart(&strwIn, &strwOut, dwPart, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
    }

    if(SUCCEEDED(hr))
        hr = ReconcileHresults(hr, CopyOutA(&straOut, pszOut, pcchOut));

    return hr;

}

LWSTDAPI_(BOOL) UrlIsA(LPCSTR pszURL, URLIS UrlIs)
{
    BOOL fRet = FALSE;

    RIPMSG(pszURL && IS_VALID_STRING_PTRA(pszURL, -1), "UrlIsA: Caller passed invalid pszURL");
    if(pszURL)
    {
        DWORD cchScheme, dwFlags;
        LPCSTR pszScheme = FindSchemeA(pszURL, &cchScheme);

        if(pszScheme)
        {
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsA(pszScheme, cchScheme, &dwFlags);

            switch (UrlIs)
            {
            case URLIS_URL:
                fRet = TRUE;
                break;

            case URLIS_OPAQUE:
                fRet = (dwFlags & UPF_SCHEME_OPAQUE);
                break;

            case URLIS_NOHISTORY:
                fRet = (dwFlags & UPF_SCHEME_NOHISTORY);
                break;

            case URLIS_FILEURL:
                fRet = (eScheme == URL_SCHEME_FILE);
                break;

            default:
                //  if it cant be done quck and dirty
                //  then we need to thunk to the wide version
                SHSTRW strUrl;
                if (SUCCEEDED(strUrl.SetStr(pszURL)))
                {
                    fRet = UrlIsW(strUrl, UrlIs);
                }
            }
        }
    }
    return fRet;
}

LWSTDAPI_(BOOL) UrlIsW(LPCWSTR pszURL, URLIS UrlIs)
{
    BOOL fRet = FALSE;

    RIPMSG(NULL!=pszURL && IS_VALID_STRING_PTRW(pszURL, -1), "UrlIsW: Caller passed invalid pszURL");
    if(pszURL)
    {
        DWORD cchScheme, dwFlags;
        LPCWSTR pszScheme = FindSchemeW(pszURL, &cchScheme);

        if(pszScheme)
        {
            SHSTRW str;
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsW(pszScheme, cchScheme, &dwFlags);

            switch (UrlIs)
            {
            case URLIS_URL:
                fRet = TRUE;
                break;

            case URLIS_OPAQUE:
                fRet = (dwFlags & UPF_SCHEME_OPAQUE);
                break;

            case URLIS_NOHISTORY:
                fRet = (dwFlags & UPF_SCHEME_NOHISTORY);
                break;

            case URLIS_FILEURL:
                fRet = (eScheme == URL_SCHEME_FILE);
                break;

            case URLIS_APPLIABLE:
                if (eScheme == URL_SCHEME_UNKNOWN)
                {
                    if (S_OK == UrlGuessScheme(pszURL, &str))
                        fRet = TRUE;
                }
                break;

            //  these cases need a broken URL
            case URLIS_DIRECTORY:
            case URLIS_HASQUERY:
                {
                    URLPARTS parts;

                    if (SUCCEEDED(str.SetStr(pszURL))
                    &&  SUCCEEDED(BreakUrl(str.GetInplaceStr(), &parts)))
                    {
                        switch(UrlIs)
                        {
                        case URLIS_DIRECTORY:
                            //  if the last seg has a trailing slash, or
                            //  if there are no path segments at all...
                            fRet = (!parts.cSegments || (parts.dwFlags & UPF_EXSEG_DIRECTORY));
                            break;

                        case URLIS_HASQUERY:
                            fRet = (parts.pszQuery && *parts.pszQuery);
                            break;

                        default:
                            ASSERT(FALSE);
                            break;
                        }
                    }
                }
                break;

            default:
                AssertMsg(FALSE, "UrlIs() called with invalid flag");

            }
        }
    }
    return fRet;
}


LWSTDAPI_(BOOL) UrlIsOpaqueA(LPCSTR pszURL)
{
    return UrlIsA(pszURL, URLIS_OPAQUE);
}

LWSTDAPI_(BOOL) UrlIsOpaqueW(LPCWSTR pszURL)
{
    return UrlIsW(pszURL, URLIS_OPAQUE);
}


LWSTDAPI_(BOOL) UrlIsNoHistoryA(LPCSTR pszURL)
{
    return UrlIsA(pszURL, URLIS_NOHISTORY);
}

LWSTDAPI_(BOOL) UrlIsNoHistoryW(LPCWSTR pszURL)
{
    return UrlIsW(pszURL, URLIS_NOHISTORY);
}

LWSTDAPI_(LPCSTR) UrlGetLocationA(LPCSTR pszURL)
{
    CPINFO cpinfo;
    BOOL fMBCS = (GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);

    RIPMSG(pszURL && IS_VALID_STRING_PTRA(pszURL, -1), "UrlGetLocationA: Caller passed invalid pszURL");
    if(pszURL)
    {
        DWORD cchScheme, dwFlags;
        LPCSTR pszScheme = FindSchemeA(pszURL, &cchScheme);
        if(pszScheme)
        {
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsA(pszScheme, cchScheme, &dwFlags);

            return (dwFlags & UPF_SCHEME_OPAQUE) ? NULL : FindFragmentA(pszURL, fMBCS, (eScheme == URL_SCHEME_FILE));
        }
    }
    return NULL;
}

LWSTDAPI_(LPCWSTR) UrlGetLocationW(LPCWSTR wzURL)
{
    RIPMSG(wzURL && IS_VALID_STRING_PTRW(wzURL, -1), "UrlGetLocationW: Caller passed invalid wzURL");
    if(wzURL)
    {
        DWORD cchScheme, dwFlags;
        LPCWSTR pszScheme = FindSchemeW(wzURL, &cchScheme);
        if(pszScheme)
        {
            URL_SCHEME eScheme = GetSchemeTypeAndFlagsW(pszScheme, cchScheme, &dwFlags);

            return (dwFlags & UPF_SCHEME_OPAQUE) ? NULL : FindFragmentW(wzURL, (eScheme == URL_SCHEME_FILE));
        }
    }
    return NULL;
}


LWSTDAPI_(int) UrlCompareA(LPCSTR psz1, LPCSTR psz2, BOOL fIgnoreSlash)
{
    RIPMSG(psz1 && IS_VALID_STRING_PTRA(psz1, -1), "UrlCompareA: Caller passed invalid psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRA(psz1, -1), "UrlCompareA: Caller passed invalid psz2");
    if (psz1 && psz2)
    {
        SHSTRW str1, str2;

        if(SUCCEEDED(str1.SetStr(psz1)) && SUCCEEDED(str2.SetStr(psz2)) &&
            SUCCEEDED(SHUrlUnescapeW(str1.GetInplaceStr(), 0)) && SUCCEEDED(SHUrlUnescapeW(str2.GetInplaceStr(), 0)) )
        {
            if(fIgnoreSlash)
            {
                LPWSTR pch;

                pch = str1.GetInplaceStr() + str1.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);

                pch = str2.GetInplaceStr() + str2.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);
            }

            return StrCmpW(str1, str2);
        }
    }

    return lstrcmpA(psz1, psz2);
}

LWSTDAPI
UrlUnescapeA(LPSTR pszUrl, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    RIPMSG(pszUrl && IS_VALID_STRING_PTRA(pszUrl, -1), "UrlUnescapeA: Caller passed invalid pszUrl");

    if(dwFlags & URL_UNESCAPE_INPLACE)
    {
        return SHUrlUnescapeA(pszUrl, dwFlags);
    }

    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlUnescapeA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlUnescapeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszUrl)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszUrl
        || !pcchOut
        || !*pcchOut
        || !pszOut)
    {
        return E_INVALIDARG;
    }

    SHSTRA str;
    HRESULT hr = str.SetStr(pszUrl);
    if(SUCCEEDED(hr))
    {
        SHUrlUnescapeA(str.GetInplaceStr(), dwFlags);
        hr = CopyOutA(&str, pszOut, pcchOut);
    }
    return hr;
}




LWSTDAPI
PathCreateFromUrlA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "PathCreateFromUrlA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "PathCreateFromUrlA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "PathCreateFromUrlA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHPathCreateFromUrl(strwIn, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = straOut.SetStr(strwOut);
    }

    if(SUCCEEDED(hr) )
        hr = CopyOutA(&straOut, pszOut, pcchOut);

    return hr;
}

LWSTDAPI
UrlCreateFromPathA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlCreateFromPathA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlCreateFromPathA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCreateFromPathA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHUrlCreateFromPath(strwIn, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
        {
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
        }
    }

    if(SUCCEEDED(hr) )
        hr = ReconcileHresults(hr, CopyOutA(&straOut, pszOut, pcchOut));

    return hr;

}

LWSTDAPI
UrlApplySchemeA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRA(pszIn, -1), "UrlApplySchemeA: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlApplySchemeA: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlApplySchemeA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwIn;

        if(SUCCEEDED(strwIn.SetStr(pszIn)))
            hr = SHUrlApplyScheme(strwIn, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(S_OK == (hr))
            hr = straOut.SetStr(strwOut);
    }

    if(S_OK == (hr))
        hr = CopyOutA(&straOut, pszOut, pcchOut);

    return hr;

}

// PERF_CACHE
//***   g_szUCCanon -- 1-element cache for UrlCanonicalizeW
// DESCRIPTION
//  it turns out a large # of our calls a) are for the same thing,
// and b) have pszOut(canon)=pszIn(raw).  so cache the most recent guy.
LONG g_lockUC;
WCHAR g_szUCCanon[64];      // post-canon guy (also used for pre-canon check)
DWORD g_dwUCFlags;

#ifdef DEBUG
int g_cUCTot, g_cUCHit;
#endif

LWSTDAPI
UrlCanonicalizeW(LPCWSTR pszUrl,
           LPWSTR pszCanonicalized,
           LPDWORD pcchCanonicalized,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strwOut;

    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "UrlCanonicalizeW: Caller passed invalid pszUrl");
    RIPMSG(NULL!=pcchCanonicalized && IS_VALID_WRITE_PTR(pcchCanonicalized, DWORD), "UrlCanonicalizeW: Caller passed invalid pcchCanonicalized");
    RIPMSG(NULL==pcchCanonicalized || (pszCanonicalized && IS_VALID_WRITE_BUFFER(pszCanonicalized, char, *pcchCanonicalized)), "UrlCanonicalizeW: Caller passed invalid pszCanonicalized");
#ifdef DEBUG
    if (pcchCanonicalized)
    {
        if (pszCanonicalized == pszUrl)
            DEBUGWhackPathStringW(pszCanonicalized, *pcchCanonicalized);
        else
            DEBUGWhackPathBufferW(pszCanonicalized, *pcchCanonicalized);
    }
#endif

    if (!pszUrl
        || !pszCanonicalized
        || !pcchCanonicalized
        || !*pcchCanonicalized)
    {
        hr = E_INVALIDARG;
    }
    else
    {
#ifdef DEBUG
        if ((g_cUCTot % 10) == 0)
            TraceMsg(DM_PERF, "uc: tot=%d hit=%d", g_cUCTot, g_cUCHit);
#endif

        DBEXEC(TRUE, g_cUCTot++);
        // try the cache 1st
        if (InterlockedExchange(&g_lockUC, 1) == 0) {
            hr = E_FAIL;
            if ((g_dwUCFlags==dwFlags)
                &&
                (!(dwFlags & URL_ESCAPE_PERCENT))
                &&
                StrCmpCW(pszUrl, g_szUCCanon) == 0)
            {
                DBEXEC(TRUE, g_cUCHit++);
                DWORD cchTmp = *pcchCanonicalized;
                hr = StrCopyOutW(g_szUCCanon, pszCanonicalized, pcchCanonicalized);
                if (FAILED(hr))
                    *pcchCanonicalized = cchTmp;    // restore!
            }
            InterlockedExchange(&g_lockUC, 0);
            if (SUCCEEDED(hr))
                return hr;
        }

        hr = UrlCombineW(L"", pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags);
        if (SUCCEEDED(hr) && *pcchCanonicalized < ARRAYSIZE(g_szUCCanon)) {
            if (InterlockedExchange(&g_lockUC, 1) == 0)
            {
                StringCchCopyW(g_szUCCanon, ARRAYSIZE(g_szUCCanon), pszCanonicalized);
                g_dwUCFlags = dwFlags;
                InterlockedExchange(&g_lockUC, 0);
            }
        }
    }

    return hr;
}

LWSTDAPI
UrlEscapeW(LPCWSTR pszUrl,
           LPWSTR pszEscaped,
           LPDWORD pcchEscaped,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strwOut;

    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "UrlEscapeW: Caller passed invalid pszUrl");
    RIPMSG(NULL!=pcchEscaped && IS_VALID_WRITE_PTR(pcchEscaped, DWORD), "UrlEscapeW: Caller passed invalid pcchEscaped");
    RIPMSG(pszEscaped && (NULL==pcchEscaped || IS_VALID_WRITE_BUFFER(pszEscaped, WCHAR, *pcchEscaped)), "UrlEscapeW: Caller passed invalid pszEscaped");
#ifdef DEBUG
    if (pcchEscaped)
    {
        if (pszEscaped==pszUrl)
            DEBUGWhackPathStringW(pszEscaped, *pcchEscaped);
        else
            DEBUGWhackPathBufferW(pszEscaped, *pcchEscaped);
    }
#endif

    if (!pszUrl || !pszEscaped ||
        !pcchEscaped || !*pcchEscaped)
        hr = E_INVALIDARG;
    else
    {
        hr = SHUrlEscape(pszUrl, &strwOut, dwFlags);
    }

    if(SUCCEEDED(hr) )
        hr = CopyOutW(&strwOut, pszEscaped, pcchEscaped);

    return hr;
}


LWSTDAPI_(int) UrlCompareW(LPCWSTR psz1, LPCWSTR psz2, BOOL fIgnoreSlash)
{
    RIPMSG(psz1 && IS_VALID_STRING_PTRW(psz1, -1), "UrlCompareW: Caller passed invalid psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRW(psz1, -1), "UrlCompareW: Caller passed invalid psz2");
    if (psz1 && psz2)
    {
        SHSTRW str1, str2;

        if( SUCCEEDED(str1.SetStr(psz1)) && SUCCEEDED(str2.SetStr(psz2)) &&
            SUCCEEDED(SHUrlUnescapeW(str1.GetInplaceStr(), 0)) && SUCCEEDED(SHUrlUnescapeW(str2.GetInplaceStr(), 0)))
        {
            if(fIgnoreSlash)
            {
                LPWSTR pch;

                pch = str1.GetInplaceStr() + str1.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);

                pch = str2.GetInplaceStr() + str2.GetLen() - 1;
                if(*pch == SLASH)
                    TERMSTR(pch);
            }

            return StrCmpW(str1, str2);
        }
    }

    return StrCmpW(psz1, psz2);
}



LWSTDAPI
UrlUnescapeW(LPWSTR pszUrl, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "UrlUnescapeW: Caller passed invalid pszUrl");

    if(dwFlags & URL_UNESCAPE_INPLACE)
    {
        return SHUrlUnescapeW(pszUrl, dwFlags);
    }

    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlUnescapeW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlUnescapeW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszUrl)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszUrl
        || !pcchOut
        || !*pcchOut
        || !pszOut)
    {
        return E_INVALIDARG;
    }

    SHSTRW str;
    HRESULT hr = str.SetStr(pszUrl);
    if(SUCCEEDED(hr))
    {
        SHUrlUnescapeW(str.GetInplaceStr(), dwFlags);
        hr = CopyOutW(&str, pszOut, pcchOut);
    }

    return hr;
}


LWSTDAPI
PathCreateFromUrlW
           (LPCWSTR pszIn,
           LPWSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "PathCreateFromUrlW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "PathCreateFromUrlW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "PathCreateFromUrlW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
        hr = SHPathCreateFromUrl(pszIn, &strOut, dwFlags);

    if(SUCCEEDED(hr) )
        hr = CopyOutW(&strOut, pszOut, pcchOut);

    return hr;

}

LWSTDAPI
UrlCreateFromPathW
           (LPCWSTR pszIn,
           LPWSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "UrlCreateFromPathW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlCreateFromPathW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlCreateFromPathW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
        hr = SHUrlCreateFromPath(pszIn, &strOut, dwFlags);

    if(SUCCEEDED(hr) )
        hr = ReconcileHresults(hr, CopyOutW(&strOut, pszOut, pcchOut));

    return hr;

}

LWSTDAPI
UrlGetPartW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags)
{
    SHSTRW strIn, strOut;
    HRESULT hr;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "UrlGetPartW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlGetPartW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlGetPartW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut || !dwPart)
        hr = E_INVALIDARG;
    else if (SUCCEEDED(hr = strIn.SetStr(pszIn)))
        hr = SHUrlGetPart(&strIn, &strOut, dwPart, dwFlags);

    if(SUCCEEDED(hr) )
        hr = CopyOutW(&strOut, pszOut, pcchOut);

    return hr;
}


LWSTDAPI
UrlApplySchemeW
           (LPCWSTR pszIn,
           LPWSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRW strOut;

    RIPMSG(pszIn && IS_VALID_STRING_PTRW(pszIn, -1), "UrlApplySchemeW: Caller passed invalid pszIn");
    RIPMSG(NULL!=pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "UrlApplySchemeW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL==pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "UrlApplySchemeW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut==pszIn)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (!pszIn || !pszOut ||
        !pcchOut || !*pcchOut )
        hr = E_INVALIDARG;
    else
        hr = SHUrlApplyScheme(pszIn, &strOut, dwFlags);

    if(S_OK == (hr))
        hr = CopyOutW(&strOut, pszOut, pcchOut);

    return hr;

}

//
//  this is the same table used by both URLMON and WININET's cache
//
const static BYTE Translate[256] =
{
    1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
    87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
    49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
    12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
    176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
    178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
    102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
    166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
    121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
    193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
    6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
    84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
    249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
    230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
    44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
    163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
};

PRIVATE void _HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    DWORD i, j;
    //  seed the hash
    for (i = cbHash; i-- > 0;)
        pbHash[i] = (BYTE) i;

    //  do the hash
    for (j = cbData; j-- > 0;)
    {
        for (i = cbHash; i-- > 0;)
            pbHash[i] = Translate[pbHash[i] ^ pbData[j]];
    }
}

LWSTDAPI
HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    RIPMSG(pbData && IS_VALID_READ_BUFFER(pbData, BYTE, cbData), "HashData: Caller passed invalid pbData");
    RIPMSG(pbHash && IS_VALID_WRITE_BUFFER(pbHash, BYTE, cbHash), "HashData: Caller passed invalid pbHash");
    if (pbData && pbHash)
    {
        _HashData(pbData, cbData, pbHash, cbHash);
        return S_OK;
    }
    return E_INVALIDARG;
}


LWSTDAPI
UrlHashA(LPCSTR psz, LPBYTE pb, DWORD cb)
{
    HRESULT hr = E_INVALIDARG;

    RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "UrlHashA: Caller passed invalid psz");
    RIPMSG(pb && IS_VALID_WRITE_BUFFER(pb, BYTE, cb), "UrlHashA: Caller passed invalid pb");
    if (psz && pb)
    {
        _HashData((LPBYTE) psz, lstrlenA(psz), pb, cb);
        return S_OK;
    }

    return hr;
}


LWSTDAPI
UrlHashW(LPCWSTR psz, LPBYTE pb, DWORD cb)
{
    HRESULT hr;

    RIPMSG(psz && IS_VALID_STRING_PTRW(psz, -1), "UrlHashW: Caller passed invalid psz");
    RIPMSG(pb && IS_VALID_WRITE_BUFFER(pb, BYTE, cb), "UrlHashW: Caller passed invalid pb");
    if (psz && pb)
    {
        SHSTRA str;
        if (SUCCEEDED( hr = str.SetStr(psz)))
            hr = UrlHashA(str, pb, cb);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



/***************************** ParseURL Functions *****************************/
//  these were originally in URL.DLL and then moved to shlwapi.
//  i just added them from url.c for reuse of code.
//  ParseURL now does no MBCS thunks, to keep it fast.
//
//  declarations for ParseURL() APIs
//

typedef const PARSEDURLA   CPARSEDURLA;
typedef const PARSEDURLA * PCPARSEDURLA;

typedef const PARSEDURLW   CPARSEDURLW;
typedef const PARSEDURLW * PCPARSEDURLW;


#ifdef DEBUG

BOOL
IsValidPCPARSEDURLA(
   LPCSTR pcszURL,
   PCPARSEDURLA pcpu)
{
   return(IS_VALID_READ_PTR(pcpu, CPARSEDURLA) &&
          (IS_VALID_STRING_PTRA(pcpu->pszProtocol, -1) &&
           EVAL(IsStringContainedA(pcszURL, pcpu->pszProtocol)) &&
           EVAL(pcpu->cchProtocol < (UINT)lstrlenA(pcpu->pszProtocol))) &&
          (IS_VALID_STRING_PTRA(pcpu->pszSuffix, -1) &&
           EVAL(IsStringContainedA(pcszURL, pcpu->pszSuffix)) &&
           EVAL(pcpu->cchSuffix <= (UINT)lstrlenA(pcpu->pszSuffix))) &&
          EVAL(pcpu->cchProtocol + pcpu->cchSuffix < (UINT)lstrlenA(pcszURL)));
}

BOOL
IsValidPCPARSEDURLW(
   LPCWSTR pcszURL,
   PCPARSEDURLW pcpu)
{
   return(IS_VALID_READ_PTR(pcpu, CPARSEDURLW) &&
          (IS_VALID_STRING_PTRW(pcpu->pszProtocol, -1) &&
           EVAL(IsStringContainedW(pcszURL, pcpu->pszProtocol)) &&
           EVAL(pcpu->cchProtocol < (UINT)lstrlenW(pcpu->pszProtocol))) &&
          (IS_VALID_STRING_PTRW(pcpu->pszSuffix, -1) &&
           EVAL(IsStringContainedW(pcszURL, pcpu->pszSuffix)) &&
           EVAL(pcpu->cchSuffix <= (UINT)lstrlenW(pcpu->pszSuffix))) &&
          EVAL(pcpu->cchProtocol + pcpu->cchSuffix < (UINT)lstrlenW(pcszURL)));
}

#endif


/*----------------------------------------------------------
Purpose: Parse the given path into the PARSEDURL structure.

  ******
  ******  This function must not do any extraneous
  ******  things.  It must be small and fast.
  ******

    Returns: NOERROR if a valid URL format
    URL_E_INVALID_SYNTAX if not

      Cond:    --
*/
STDMETHODIMP
ParseURLA(
          LPCSTR pcszURL,
          PPARSEDURLA ppu)
{
    HRESULT hr = E_INVALIDARG;

    RIP(IS_VALID_STRING_PTRA(pcszURL, -1));
    RIP(IS_VALID_WRITE_PTR(ppu, PARSEDURLA));

    if (pcszURL && ppu && SIZEOF(*ppu) == ppu->cbSize)
    {
        DWORD cch;
        hr = URL_E_INVALID_SYNTAX;      // assume error

        ppu->pszProtocol = FindSchemeA(pcszURL, &cch);

        if(ppu->pszProtocol)
        {
            ppu->cchProtocol = cch;

            // Determine protocol scheme number
            ppu->nScheme = SchemeTypeFromStringA(ppu->pszProtocol, cch);

            ppu->pszSuffix = ppu->pszProtocol + cch + 1;

            //
            //  APPCOMPAT - Backwards compatibility - zekel 28-feb-97
            //  ParseURL() believes in file: urls like "file://C:\foo\bar"
            //  and some pieces of code will use it to get the Dos Path.
            //  new code should always call PathCreateFromUrl() to
            //  get the dos path of a file: URL.
            //
            //  i am leaving this behavior in case some compat stuff is out there.
            //
            if (URL_SCHEME_FILE == ppu->nScheme &&
                '/' == ppu->pszSuffix[0] && '/' == ppu->pszSuffix[1])
            {
                // Yes; skip the "//"
                ppu->pszSuffix += 2;

#ifndef UNIX
                // FOR UNIX: If we have /vobs/build, we don't want to make
                // There might be a third slash.  Skip it.
                if ('/' == *ppu->pszSuffix)
                    ppu->pszSuffix++;
#endif

            }

            ppu->cchSuffix = lstrlenA(ppu->pszSuffix);

            hr = S_OK;
        }
    }

#ifdef DEBUG
    if (hr == S_OK)
    {
        CHAR rgchDebugProtocol[MAX_PATH];
        CHAR rgchDebugSuffix[MAX_PATH];

        // (+ 1) for null terminator.

        lstrcpynA(rgchDebugProtocol, ppu->pszProtocol,
            min(ppu->cchProtocol + 1, SIZECHARS(rgchDebugProtocol)));

        // (+ 1) for null terminator.

        lstrcpynA(rgchDebugSuffix, ppu->pszSuffix,
            min(ppu->cchSuffix + 1, SIZECHARS(rgchDebugSuffix)));

        TraceMsgA(TF_URL, "ParseURL(): Parsed protocol \"%s\" and suffix \"%s\" from URL \"%s\".",
            rgchDebugProtocol,
            rgchDebugSuffix,
            pcszURL);
    }
    else
    {
        TraceMsgA(TF_URL, "ParseURL(): Failed to parse \"%s\"", pcszURL);
    }
#endif


    ASSERT(FAILED(hr) ||
        EVAL(IsValidPCPARSEDURLA(pcszURL, ppu)));

    return(hr);
}


/*----------------------------------------------------------
Purpose: Parse the given path into the PARSEDURL structure.

  ******
  ******  This function must not do any extraneous
  ******  things.  It must be small and fast.
  ******

    Returns: NOERROR if a valid URL format
    URL_E_INVALID_SYNTAX if not

      Cond:    --
*/
STDMETHODIMP
ParseURLW(
          LPCWSTR pcszURL,
          PPARSEDURLW ppu)
{
    HRESULT hr = E_INVALIDARG;

    RIP(IS_VALID_STRING_PTRW(pcszURL, -1));
    RIP(IS_VALID_WRITE_PTR(ppu, PARSEDURLW));

    if (pcszURL && ppu && SIZEOF(*ppu) == ppu->cbSize)
    {
        DWORD cch;
        hr = URL_E_INVALID_SYNTAX;      // assume error

        ppu->pszProtocol = FindSchemeW(pcszURL, &cch);

        if(ppu->pszProtocol)
        {
            ppu->cchProtocol = cch;

            // Determine protocol scheme number
            ppu->nScheme = SchemeTypeFromStringW(ppu->pszProtocol, cch);

            ppu->pszSuffix = ppu->pszProtocol + cch + 1;

            //
            //  APPCOMPAT - Backwards compatibility - zekel 28-feb-97
            //  ParseURL() believes in file: urls like "file://C:\foo\bar"
            //  and some pieces of code will use it to get the Dos Path.
            //  new code should always call PathCreateFromUrl() to
            //  get the dos path of a file: URL.
            //
            //  i am leaving this behavior in case some compat stuff is out there.
            //
            if (URL_SCHEME_FILE == ppu->nScheme &&
                '/' == ppu->pszSuffix[0] && '/' == ppu->pszSuffix[1])
            {
                // Yes; skip the "//"
                ppu->pszSuffix += 2;

#ifndef UNIX
                // There might be a third slash.  Skip it.
                // IEUNIX - On UNIX, it's a root directory, so don't skip it!
                if ('/' == *ppu->pszSuffix)
                    ppu->pszSuffix++;
#endif
            }

            ppu->cchSuffix = lstrlenW(ppu->pszSuffix);

            hr = S_OK;
        }
    }


#ifdef DEBUG
    if (hr==S_OK)
    {
        WCHAR rgchDebugProtocol[MAX_PATH];
        WCHAR rgchDebugSuffix[MAX_PATH];

        // (+ 1) for null terminator.

        StrCpyNW(rgchDebugProtocol, ppu->pszProtocol,
            min(ppu->cchProtocol + 1, SIZECHARS(rgchDebugProtocol)));

        // (+ 1) for null terminator.

        StrCpyNW(rgchDebugSuffix, ppu->pszSuffix,
            min(ppu->cchSuffix + 1, SIZECHARS(rgchDebugSuffix)));

        TraceMsg(TF_URL, "ParseURL(): Parsed protocol \"%s\" and suffix \"%s\" from URL \"%s\".",
            rgchDebugProtocol,
            rgchDebugSuffix,
            pcszURL);
    }
    else
    {
        TraceMsg(TF_URL, "ParseURL(): Failed to parse \"%s\"", pcszURL);
    }
#endif

    ASSERT(FAILED(hr) ||
        EVAL(IsValidPCPARSEDURLW(pcszURL, ppu)));

    return(hr);
}

#ifdef USE_FAST_PARSER

// GetSchemeTypeAndFlagsSpecialW
// performs the same behavior as GetSchemeTypeAndFlagsW plus, when successful
// copies the canonicalised form of the scheme back.

PRIVATE URL_SCHEME
GetSchemeTypeAndFlagsSpecialW(LPWSTR pszScheme, DWORD cchScheme, LPDWORD pdwFlags)
{
    DWORD i;

    ASSERT(pszScheme);


#ifdef DEBUG
    if ((g_cSTTot % 10) == 0)
        TraceMsg(DM_PERF, "gstaf: tot=%d hit=%d hit0=%d", g_cSTTot, g_cSTHit, g_cSTHit0);
#endif
    DBEXEC(TRUE, g_cSTTot++);
    // check cache 1st
    i = g_iScheme;
    if (cchScheme == g_mpUrlSchemeTypes[i].cchScheme
      && StrCmpNCW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme) == 0)
    {
        DBEXEC(TRUE, i == 0 ? g_cSTHit0++ : g_cSTHit++);
Lhit:
        if (pdwFlags)
            *pdwFlags = g_mpUrlSchemeTypes[i].dwFlags;

        // update cache (unconditionally)
        g_iScheme = i;

        // We need to do this because the scheme might not be canonicalised
        memcpy(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme*sizeof(WCHAR));
        return g_mpUrlSchemeTypes[i].eScheme;
    }

    for (i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); i++)
    {
        if(cchScheme == g_mpUrlSchemeTypes[i].cchScheme
          && 0 == StrCmpNIW(pszScheme, g_mpUrlSchemeTypes[i].pszScheme, cchScheme))
            goto Lhit;
    }

    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return URL_SCHEME_UNKNOWN;
}



// URL_STRING --------------------------------------------------------------------------------------

// is a container for the combined URL. It attempts to construct a string from the information
// fed into it. If there is not enough buffer space available, it will measure how much additional
// space will be required to hold the string.

WCHAR wszBogus[] = L"";


// US_* are the various modes of transforming characters fed into the container.
// US_NOTHING   do nothing to the character.
// US_UNESCAPE  turn entries of the form %xx into the unescaped form
// US_ESCAPE_UNSAFE transform invalid path characters into %xx sequences
// US_ESCAPE_SPACES transform only spaces in to %20 sequences

enum
{
    US_NOTHING,
    US_UNESCAPE,
    US_ESCAPE_UNSAFE,
    US_ESCAPE_SPACES
};

class URL_STRING
{
protected:
    URL_SCHEME _eScheme;
    DWORD _ccWork, _ccMark, _ccLastWhite, _ccQuery, _ccFragment, _ccBuffer, _dwSchemeInfo;
    DWORD _dwOldFlags, _dwFlags, _dwMode;
    BOOL _fFixSlashes, _fExpecting, _fError;
    WCHAR _wchLast, _wszInternalString[256];
    PWSTR _pszWork;

    VOID baseAccept(WCHAR wch);
    VOID TrackWhiteSpace(WCHAR wch);

public:
    URL_STRING(DWORD dwFlags);
    ~URL_STRING();

    VOID CleanAccept(WCHAR wch);
    VOID Accept(WCHAR wch);
    VOID Accept(PWSTR a_psz);
    VOID Contract(BOOL fContractLevel = TRUE);
    VOID TrimEndWhiteSpace();

    PWSTR GetStart();
    LONG GetTotalLength();
    BOOL AnyProblems();

    VOID NoteScheme(URL_SCHEME a_eScheme, DWORD a_dwSchemeInfo);
    VOID AddSchemeNote(DWORD a_dwSchemeInfo);
    DWORD GetSchemeNotes();
    URL_SCHEME QueryScheme();

    VOID Mark();
    VOID ClearMark();
    VOID EraseMarkedText();
    DWORD CompareMarkWith(PWSTR psz);
    DWORD CompareLast(PCWSTR psz, DWORD cc);

    VOID EnableMunging();
    VOID DisableMunging();
    VOID DisableSlashFixing();
    VOID RestoreFlags();
    VOID AddFlagNote(DWORD dwFlag);

    VOID NotifyQuery();
    VOID NotifyFragment();
    VOID DropQuery();
    VOID DropFragment();
};

// -------------------------------------------------------------------------------

URL_STRING::URL_STRING(DWORD dwFlags)
{
    _ccBuffer = ARRAYSIZE(_wszInternalString);
    _ccWork = 1;
    _pszWork = _wszInternalString;
    _ccQuery = _ccFragment = _ccMark = 0;

    _eScheme = URL_SCHEME_UNKNOWN;
    _dwOldFlags = _dwFlags = dwFlags;
    _dwMode = US_NOTHING;

    _fFixSlashes = TRUE;
    _fError = _fExpecting = FALSE;
}

URL_STRING::~URL_STRING()
{
    if (_ccBuffer > ARRAYSIZE(_wszInternalString))
    {
        LocalFree(_pszWork);
    }
}

// -------------------------------------------------------------------------------
// These are the standard functions used for adding characters to an url.

VOID URL_STRING::baseAccept(WCHAR wch)
{
    _pszWork[_ccWork-1] = (_fFixSlashes
                    ? ((wch!=WHACK) ? wch : SLASH)
                    : wch);
    _ccWork++;
    if (_ccWork>_ccBuffer)
    {
        if (!_fError)
        {
            PWSTR psz = (PWSTR)LocalAlloc(LPTR, 2*_ccBuffer*sizeof(WCHAR));
            if (!psz)
            {
                _ccWork--;
                _fError = TRUE;
                return;
            }
            memcpy(psz, _pszWork, (_ccWork-1)*sizeof(WCHAR));
            if (_ccBuffer>ARRAYSIZE(_wszInternalString))
            {
                LocalFree(_pszWork);
            }
            _ccBuffer *= 2;
            _pszWork = psz;
        }
        else
        {
            _ccWork--;
        }
    }
}


VOID URL_STRING::TrackWhiteSpace(WCHAR wch)
{
    if (IsWhite(wch))
    {
        if (!_ccLastWhite)
        {
            _ccLastWhite = _ccWork;
        }
    }
    else
    {
        _ccLastWhite = 0;
    }
}


// -- URL_STRING::Accept ----------------------------
// Based on the current munging mode, transform the character into the
// desired form and add it to the string.

VOID URL_STRING::Accept(WCHAR wch)
{
    TrackWhiteSpace(wch);

    switch (_dwMode)
    {
    case US_NOTHING:
        break;

    case US_UNESCAPE:
        if (_fExpecting)
        {
            if (!IsHex(wch))
            {
                baseAccept(HEX_ESCAPE);
                if (_wchLast!=L'\0')
                {
                    baseAccept(_wchLast);
                }
                _fExpecting = FALSE;
                break;
            }
            else if (_wchLast!=L'\0')
            {
                wch = (HexToWord(_wchLast)*16) + HexToWord(wch);
                TrackWhiteSpace(wch);
                _fExpecting = FALSE;
                if ((wch==WHACK) && _fFixSlashes)
                {
                    _fFixSlashes = FALSE;
                    baseAccept(wch);
                    _fFixSlashes = TRUE;
                    return;
                }
                break;
            }
            else
            {
                _wchLast = wch;
            }
            return;
        }
        if (wch==HEX_ESCAPE)
        {
            _fExpecting = TRUE;
            _wchLast = L'\0';
            return;
        }
        break;

     case US_ESCAPE_UNSAFE:
        if ((wch==SLASH)
            ||
            (wch==WHACK && _fFixSlashes)
            ||
            (IsSafePathChar(wch) && (wch!=HEX_ESCAPE || !(_dwFlags & URL_ESCAPE_PERCENT))))
        {
            break;
        }

        baseAccept(L'%');
        baseAccept(hex[(wch >> 4) & 15]);
        baseAccept(hex[wch & 15]);
        return;

    case US_ESCAPE_SPACES:
        if (wch==SPC)
        {
            baseAccept(L'%');
            baseAccept(L'2');
            baseAccept(L'0');
            return;
        }
        break;
     default:
        ASSERT(FALSE);
    }
    baseAccept(wch);
}

// -- Accept --------------------------------
// Accept only a string
VOID URL_STRING::Accept(PWSTR psz)
{
    while (*psz)
    {
        Accept(*psz);
        psz++;
    }
}

// -- Contract
// Whenever we call Contract, we're pointing past the last separator. We want to
// omit the segment between this separator and the one before it.
// This should be used ONLY when we're examining the path segment of the urls.

VOID URL_STRING::Contract(BOOL fContractLevel)
{
    ASSERT(_ccWork && _ccMark);

    // _ccWork is 1 after wherever the next character will be placed
    // subtract +1 to derive what the last character in the url is
    DWORD _ccEnd = _ccWork-1 - 1;
    if (_eScheme!=URL_SCHEME_MK)
    {
        if (!fContractLevel && (_pszWork[_ccEnd]==SLASH || _pszWork[_ccEnd]==WHACK))
        {
            return;
        }
        do
        {
            _ccEnd--;
        }
        while ((_ccEnd>=_ccMark-1) && _pszWork[_ccEnd]!=SLASH && _pszWork[_ccEnd]!=WHACK);
    }
    else
    {
        if (!fContractLevel && (_pszWork[_ccEnd]==SLASH))
        {
            return;
        }
        do
        {
            _ccEnd--;
        }
        while ((_ccEnd>=_ccMark-1) && _pszWork[_ccEnd]!=SLASH);
    }
    if (_ccEnd<_ccMark-1)
    {
        _ccEnd = _ccMark-1;
    }
    else
    {
        _ccEnd++;
    }
    _ccWork = _ccEnd + 1;
}

VOID URL_STRING::TrimEndWhiteSpace()
{
    if (_ccLastWhite)
    {
        _ccWork = _ccLastWhite;
        _ccLastWhite = 0;
    }
}


VOID URL_STRING::CleanAccept(WCHAR wch)
{
    baseAccept(wch);
}


// -------------------------------------------------------------------------------
// These member functions return information about the url that is being formed

PWSTR URL_STRING::GetStart()
{
    return _pszWork;
}

LONG URL_STRING::GetTotalLength()
{
    return _ccWork - 1;
}

BOOL URL_STRING::AnyProblems()
{
    return _fError;
}

// -------------------------------------------------------------------------------

VOID URL_STRING::NoteScheme(URL_SCHEME a_eScheme, DWORD a_dwSchemeInfo)
{
    _eScheme = a_eScheme;
    _dwSchemeInfo = a_dwSchemeInfo;
    _fFixSlashes = a_dwSchemeInfo & UPF_SCHEME_CONVERT;
}

VOID URL_STRING::AddSchemeNote(DWORD a_dwSchemeInfo)
{
    _dwSchemeInfo |= a_dwSchemeInfo;
    _fFixSlashes = _dwSchemeInfo & UPF_SCHEME_CONVERT;
}

DWORD URL_STRING::GetSchemeNotes()
{
    return _dwSchemeInfo;
}

URL_SCHEME URL_STRING::QueryScheme()
{
    return _eScheme;
}

// -------------------------------------------------------------------------------

VOID URL_STRING::Mark()
{
    _ccMark = _ccWork;
}

VOID URL_STRING::ClearMark()
{
    _ccMark = 0;
}

VOID URL_STRING::EraseMarkedText()
{
    if (_ccMark)
    {
        _ccWork = _ccMark;
        _ccMark = 0;
    }
}

DWORD URL_STRING::CompareMarkWith(PWSTR psz)
{
    if (_ccMark)
    {
        *(_pszWork + _ccWork - 1) = L'\0';
        return (StrCmpW(_pszWork + _ccMark - 1, psz));
    }
    // In other words, return that the string isn't present.
    return 1;
}

DWORD URL_STRING::CompareLast(PCWSTR psz, DWORD cc)
{
    if (_ccWork > cc)
    {
        return StrCmpNIW(_pszWork + _ccWork - 1 - cc, psz, cc);
    }
    return 1;
}


// -------------------------------------------------------------------------------

VOID URL_STRING::NotifyQuery()
{
    if (!_ccQuery)
    {
        _ccQuery = _ccWork;
    }
}

VOID URL_STRING::NotifyFragment()
{
    if (!_ccFragment)
    {
        _ccFragment = _ccWork;
        CleanAccept(POUND);
    }
}

VOID URL_STRING::DropQuery()
{
    if (_ccQuery)
    {
        _ccWork = _ccQuery;
        _ccQuery = _ccFragment = 0;
    }
}

VOID URL_STRING::DropFragment()
{
    if (_ccFragment)
    {
        _ccWork = _ccFragment;
        _ccFragment = 0;
    }
}

// -------------------------------------------------------------------------------
// These member functions are for determining how the url's characters are going
// to be represented

VOID URL_STRING::EnableMunging()
{
    _dwMode = US_NOTHING;

    // For opaque urls, munge ONLY if we're explicitly asked to URL_ESCAPE or URL_UNESCAPE,
    // but NOT URL_ESCAPE_SPACES_ONLY

    // For query and fragment, never allow for URL_ESCAPE_UNSAFE and for
    //    others ONLY when URL_DONT_ESCAPE_EXTRA_INFO is specified

    if ((_dwSchemeInfo & UPF_SCHEME_OPAQUE)
        && (_dwFlags & URL_ESCAPE_SPACES_ONLY))
        return;

    if ((_ccQuery || _ccFragment)
        && ((_dwFlags & (URL_DONT_ESCAPE_EXTRA_INFO | URL_ESCAPE_UNSAFE))))
        return;

    if (_dwFlags & URL_UNESCAPE)
    {
        _dwMode = US_UNESCAPE;
    }
    else if (_dwFlags & URL_ESCAPE_UNSAFE)
    {
        _dwMode = US_ESCAPE_UNSAFE;
    }
    else if (_dwFlags & URL_ESCAPE_SPACES_ONLY)
    {
        _dwMode = US_ESCAPE_SPACES;
    }
}

VOID URL_STRING::DisableMunging()
{
    _dwMode = US_NOTHING;
}

VOID URL_STRING::DisableSlashFixing()
{
    _fFixSlashes = FALSE;
}

VOID URL_STRING::AddFlagNote(DWORD dwFlag)
{
    _dwFlags |= dwFlag;
}

VOID URL_STRING::RestoreFlags()
{
    ASSERT((_eScheme==URL_SCHEME_FILE) || (_dwFlags==_dwOldFlags));
    _dwFlags = _dwOldFlags;
    EnableMunging();
}

// -------------------------------------------------------------------------------


// URL ------------------------------------------------------------------------------------
// The URL class is used to examine the base and relative URLs to determine what
// will go into the URL_STRING container. The difference should be clear:
// URL instances look, but don't touch. URL_STRINGs are used solely to build urls.


class URL
{
private:
    PCWSTR _pszUrl, _pszWork;
    URL_SCHEME _eScheme;
    DWORD _dwSchemeNotes, _dwFlags;
    BOOL _fPathCompressionOn;
    BOOL _fIgnoreQuery;

    WCHAR SmallForm(WCHAR wch);
    BOOL IsAlpha(WCHAR ch);
    PCWSTR IsUrlPrefix(PCWSTR psz);
    BOOL IsLocalDrive(PCWSTR psz);
    BOOL IsQualifiedDrive(PCWSTR psz);
    BOOL DetectSymbols(WCHAR wch1, WCHAR wch2 = '\0', WCHAR wch3 = '\0');

    PCWSTR NextChar(PCWSTR psz);
    PCWSTR FeedUntil(PCWSTR psz, URL_STRING* pus, WCHAR wchDelim1 = '\0', WCHAR wchDelim2 = '\0', WCHAR wchDelim3 = '\0', WCHAR wchDelim4 = '\0');

    BOOL DetectFileServer();
    BOOL DetectMkServer();
    BOOL DefaultDetectServer();
    VOID FeedDefaultServer(URL_STRING* pus);
    VOID FeedFileServer(URL_STRING* pus);
    VOID FeedFtpServer(URL_STRING* pus);
    VOID FeedHttpServer(URL_STRING* pus);
    VOID FeedMkServer(URL_STRING* pus);
    PCWSTR FeedPort(PCWSTR psz, URL_STRING* pus);

public:
    VOID Setup(PCWSTR pszInUrl, DWORD a_dwFlags = 0);
    VOID Reset();
    BOOL IsReset();

    BOOL DetectAndFeedScheme(URL_STRING* pus, BOOL fReconcileSchemes = FALSE);
    VOID SetScheme(URL_SCHEME eScheme, DWORD dwFlag);
    URL_SCHEME GetScheme();
    VOID AddSchemeNote(DWORD dwFlag);
    DWORD GetSchemeNotes();

    BOOL DetectServer();
    BOOL DetectAbsolutePath();
    BOOL DetectPath();
    BOOL DetectQueryOrFragment();
    BOOL DetectQuery();
    BOOL DetectLocalDrive();
    BOOL DetectSlash();
    BOOL DetectAnything();
    WCHAR PeekNext();

    VOID FeedPath(URL_STRING* pus, BOOL fMarkServer = TRUE);
    PCWSTR CopySegment(PCWSTR psz, URL_STRING* pus, BOOL* pfContinue);
    DWORD DetectDots(PCWSTR* ppsz);
    VOID StopPathCompression();

    VOID FeedServer(URL_STRING* pus);
    VOID FeedLocalDrive(URL_STRING* pus);
    VOID FeedQueryAndFragment(URL_STRING* pus);
    VOID IgnoreQuery();
};

// -------------------------------------------------------------------------------

VOID URL::Setup(PCWSTR pszInUrl, DWORD a_dwFlags)
{
    while (*pszInUrl && IsWhite(*pszInUrl))
    {
        pszInUrl++;
    }
    _pszWork = _pszUrl = pszInUrl;
    _eScheme = URL_SCHEME_UNKNOWN;
    _dwSchemeNotes = 0;
    _dwFlags = a_dwFlags;
    _fPathCompressionOn = TRUE;
    _fIgnoreQuery = FALSE;
}

VOID URL::Reset()
{
    _pszWork = wszBogus;
}

BOOL URL::IsReset()
{
    return (_pszWork==wszBogus);
}

// -------------------------------------------------------------------------------

inline WCHAR URL::SmallForm(WCHAR wch)
{
    return (wch < L'A' || wch > L'Z') ? wch : (wch - L'A' + L'a');
}

inline BOOL URL::IsAlpha(WCHAR ch)
{
    return ((ch >= 'a') && (ch <= 'z'))
           ||
           ((ch >= 'A') && (ch <= 'Z'));
}


inline PCWSTR URL::IsUrlPrefix(PCWSTR psz)
{
    // We want to skip instances of "URL:"
    psz = NextChar(psz);
    if (*psz==L'u' || *psz==L'U')
    {
        psz = NextChar(psz+1);
        if (*psz==L'r' || *psz==L'R')
        {
            psz = NextChar(psz+1);
            if (*psz==L'l' || *psz==L'L')
            {
                psz = NextChar(psz+1);
                if (*psz==COLON)
                {
                    return NextChar(psz+1);
                }
            }
        }
    }
    return NULL;
}

inline BOOL URL::IsLocalDrive(PCWSTR psz)
{
    psz = NextChar(psz);
    return (IsAlpha(*psz)
            &&
            ((*NextChar(psz+1)==COLON) || (*NextChar(psz+1)==BAR)));
}

// -- IsQualifiedDrive --------
// On Win32 systems, a qualified drive is either
// i. <letter>:  or ii. \\UNC\
// Under unix, it's only /.

inline BOOL URL::IsQualifiedDrive(PCWSTR psz)
{
    psz = NextChar(psz);
    BOOL fResult = IsLocalDrive(psz);
    if (!fResult && *psz==WHACK)
    {
        psz = NextChar(psz+1);
        fResult = *psz==WHACK;
    }
    return fResult;
}

// -- DetectSymbols -------------
// This is used to help determine what part of the URL we have reached.
inline BOOL URL::DetectSymbols(WCHAR wch1, WCHAR wch2, WCHAR wch3)
{
    ASSERT(_pszWork);
    PCWSTR psz = NextChar(_pszWork);
    return (*psz && (*psz==wch1 || *psz==wch2 || *psz==wch3));
}

BOOL URL::DetectSlash()
{
    return DetectSymbols(SLASH, WHACK);
}

BOOL URL::DetectAnything()
{
    return (*NextChar(_pszWork)!=L'\0');
}

// -- NextChar -------------------------------------
// We use NextChar instead of *psz because we want to
// ignore characters such as TAB, CR, etc.
inline PCWSTR URL::NextChar(PCWSTR psz)
{
    while (IsInsignificantWhite(*psz))
    {
        psz++;
    }
    return psz;
}

WCHAR URL::PeekNext()
{
    return (*NextChar(NextChar(_pszWork)+1));
}


// -------------------------------------------------------------------------------

inline PCWSTR URL::FeedUntil(PCWSTR psz, URL_STRING* pus, WCHAR wchDelim1, WCHAR wchDelim2, WCHAR wchDelim3, WCHAR wchDelim4)
{
    psz = NextChar(psz);
    while (*psz && *psz!=wchDelim1 && *psz!=wchDelim2 && *psz!=wchDelim3 && *psz!=wchDelim4)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    return psz;
}

// -------------------------------------------------------------------------------

VOID URL::SetScheme(URL_SCHEME eScheme, DWORD dwFlag)
{
    _eScheme = eScheme;
    _dwSchemeNotes = dwFlag;
}

URL_SCHEME URL::GetScheme()
{
    return _eScheme;
}

VOID URL::AddSchemeNote(DWORD dwFlag)
{
    _dwSchemeNotes |= dwFlag;
}

DWORD URL::GetSchemeNotes()
{
    return _dwSchemeNotes;
}

BOOL URL::DetectAndFeedScheme(URL_STRING* pus, BOOL fReconcileSchemes)
{
    ASSERT(_pszWork);
    ASSERT(!fReconcileSchemes || (fReconcileSchemes && pus->QueryScheme()!=URL_SCHEME_FILE));

    PCWSTR psz = NextChar(_pszWork);
    BOOL fResult = (IsQualifiedDrive(_pszWork));
    if (fResult)
    {
        //
        // Detected a File URL that isn't explicitly marked as such, ie C:\foo,
        //   in this case, we need to confirm that we're not overwriting
        //   a fully qualified relative URL with an Accept("file:"), although
        //   if the relative URL is the same scheme as the base, we now
        //   need to make the BASE-file URL take precedence.
        //

        _eScheme = URL_SCHEME_FILE;

        if (!fReconcileSchemes)
        {
            pus->Accept((PWSTR)c_szFileScheme);
            pus->Accept(COLON);
            _dwSchemeNotes = g_mpUrlSchemeTypes[1].dwFlags;
            pus->NoteScheme(_eScheme, _dwSchemeNotes);
            pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        }
        else if (pus->QueryScheme() != URL_SCHEME_FILE)
        {
            Reset();
        }

        goto exit;
    }

    for (;;)
    {
        while (IsValidSchemeCharW(*psz))
        {
            psz = NextChar(psz + 1);
        }
        if (*psz!=COLON)
        {
            break;
        }
        if (IsUrlPrefix(_pszWork))
        {
        // However, we want to skip instances of URL:
            _pszWork = psz = NextChar(psz+1);
            continue;
        }

        DWORD ccScheme = 0;
        PCWSTR pszClone = NextChar(_pszWork);

        if (!fReconcileSchemes)
        {
            while (pszClone<=psz)
            {
                pus->Accept(SmallForm(*pszClone));
                ccScheme++;
                pszClone = NextChar(pszClone+1);
            }
            _pszWork = pszClone;
            // Subtract one for the colon
            ccScheme--;
            // BUG BUG Since we're smallifying the scheme above, we might be able to
            // avoid calling this func, call GetSchemeTypeAndFlags instead.
            _eScheme = GetSchemeTypeAndFlagsSpecialW(pus->GetStart(), ccScheme, &_dwSchemeNotes);
            pus->NoteScheme(_eScheme, _dwSchemeNotes);
        }
        else
        {
            PWSTR pszKnownScheme = pus->GetStart();
            while (pszClone<=psz && SmallForm(*pszClone)==*pszKnownScheme)
            {
                pszClone = NextChar(pszClone+1);
                pszKnownScheme++;
            }
            if (pszClone<=psz)
            {
                Reset();
            }
            else
            {
                _pszWork = pszClone;
            }
        }
        fResult = TRUE;
        break;
    }
 exit:
    return fResult;
}

// -------------------------------------------------------------------------------

BOOL URL::DetectServer()
{
    ASSERT(_pszWork);
    BOOL fRet;

    switch (_eScheme)
    {
    case URL_SCHEME_FILE:
        fRet = DetectFileServer();
        break;

    case URL_SCHEME_MK:
        fRet = DetectMkServer();
        break;

    default:
        fRet = DefaultDetectServer();
        break;
    }
    return fRet;
}

BOOL URL::DetectLocalDrive()
{
    return IsLocalDrive(_pszWork);
}

BOOL URL::DetectFileServer()
{
    ASSERT(_pszWork);
    PCWSTR psz = _pszWork;

    BOOL fResult = IsLocalDrive(_pszWork);
    if (fResult)
    {
        _dwSchemeNotes |= UPF_FILEISPATHURL;
    }
    else
    {
        fResult = DetectSymbols(SLASH, WHACK);
    }
    return fResult;
}

BOOL URL::DetectMkServer()
{
    ASSERT(_pszWork);
    PCWSTR psz = NextChar(_pszWork);
    BOOL fResult = (*psz==L'@');
    if (fResult)
    {
        _pszWork = NextChar(psz + 1);
    }
    return fResult;
}

BOOL URL::DefaultDetectServer()
{
    BOOL fResult = FALSE;
    if (DetectSymbols(SLASH, WHACK))
    {
        PCWSTR psz = NextChar(_pszWork + 1);
        fResult = ((*psz==SLASH) || (*psz==WHACK));
    }
    return fResult;
}

VOID URL::FeedServer(URL_STRING* pus)
{
    ASSERT(_pszWork);
    switch (_eScheme)
    {
    case URL_SCHEME_FILE:
        FeedFileServer(pus);
        break;

    case URL_SCHEME_MK:
        FeedMkServer(pus);
        break;

    case URL_SCHEME_FTP:
        FeedFtpServer(pus);
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
        FeedHttpServer(pus);
        break;

    default:
        FeedDefaultServer(pus);
        break;
    }
}

VOID URL::FeedMkServer(URL_STRING* pus)
{
    ASSERT(_pszWork);
    pus->EnableMunging();
    pus->Accept(L'@');
    _pszWork = FeedUntil(_pszWork, pus, SLASH);
    if (!*_pszWork)
    {
        pus->TrimEndWhiteSpace();
    }
    else
    {
        _pszWork = NextChar(_pszWork+1);
    }
    pus->Accept(SLASH);
}

VOID URL::FeedLocalDrive(URL_STRING* pus)
{
    pus->Accept(*NextChar(_pszWork));
    _pszWork = NextChar(_pszWork+1);
    pus->Accept(*_pszWork);
    _pszWork = NextChar(_pszWork+1);
    pus->DisableMunging();
}

VOID URL::FeedFileServer(URL_STRING* pus)
{
    PCWSTR psz = NextChar(_pszWork);

    while (*psz==SLASH || *psz==WHACK)
    {
        psz = NextChar(psz+1);
    }

    DWORD dwSlashes = (DWORD)(psz - _pszWork);
    switch (dwSlashes)
    {
    case 4:
        pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        _dwSchemeNotes |= UPF_FILEISPATHURL;
     // 4 to 6 slashes == 1 UNC
    case 2:
        if (IsLocalDrive(psz))
        {
            pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        }

    case 5:
    case 6:
        pus->Accept(SLASH);
        pus->Accept(SLASH);
         if (!IsLocalDrive(psz))
        {
            pus->EnableMunging();
            psz = FeedUntil(psz, pus, SLASH, WHACK);
            if (!*psz)
            {
                pus->TrimEndWhiteSpace();
                Reset();
            }
            else
            {
                _pszWork = NextChar(psz+1);
            }
        }
        else
        {
            _pszWork = psz;
        }
        pus->Accept(SLASH);
        break;

    // If there are no slashes, then it can't be a UNC.
    case 0:
        if (IsLocalDrive(psz))
        {
            pus->AddFlagNote(URL_ESCAPE_PERCENT | URL_ESCAPE_UNSAFE);
        }


    // We think of "file:/" and "file:///" to be on the local machine
    // And if there are more slashes than we typically handle, we'll treat them as 1.
    case 1:
    case 3:
    // This is a not-good-case
    default:
        pus->Accept(SLASH);
        pus->Accept(SLASH);
        pus->Accept(SLASH);
        _pszWork = NextChar(psz);
        break;
    }
}


VOID URL::FeedFtpServer(URL_STRING* pus)
{
    ASSERT(_pszWork);

    PCWSTR psz = NextChar(_pszWork);

    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }

    pus->EnableMunging();

    // The following is a grotesque and gruesome hack. We need to preserve case for
    // embedded username/password

    _pszWork = psz;

    BOOL fPossibleUserPasswordCombo = FALSE;
    while (*psz && *psz!=SLASH && *psz!=POUND && *psz!=QUERY)
    {
        if (*psz==L'@')
        {
            fPossibleUserPasswordCombo = TRUE;
            break;
        }
        psz = NextChar(psz+1);
    }

    psz = _pszWork;
    if (fPossibleUserPasswordCombo)
    {
        while (*psz!=L'@')
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }
    }

    // This still leaves the issue of slashes, colons, ?s, @s, and #s in passwords; I guess they
    // ought to be escaped. (You just can't win, sometimes.)

    while (*psz && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND)
    {
        pus->Accept(SmallForm(*psz));
        psz = NextChar(psz+1);
    }

    if (*psz==COLON)
    {
        psz = FeedPort(psz, pus);
    }
    pus->DisableMunging();

    _pszWork = psz;
    if (!*psz)
    {
        pus->TrimEndWhiteSpace();
        pus->Accept(SLASH);
    }
    else
    {
        if (*psz==QUERY || *psz==POUND)
        {
            pus->Accept(SLASH);
        }
        else
        {
            pus->Accept(*psz);
            _pszWork = NextChar(psz+1);
        }
    }
}


VOID URL::FeedHttpServer(URL_STRING* pus)
{
// This is a version of FeedDefaultServer, stripped of non-essentials.
// This includes a hack to enable username/password combos in http urls.

    ASSERT(_pszWork);

    PCWSTR psz = NextChar(_pszWork);

    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }

    pus->EnableMunging();

    // WARNING! FeedPort also calls Mark(). Must be careful that they don't overlap.
    pus->Mark();
    PCWSTR pszRestart = psz;
    
    while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND && *psz!=AT)
    {
        pus->Accept(SmallForm(*psz));
        psz = NextChar(psz+1);
    }

    if (*psz==COLON)
    {
        // We either have a port or a password. 
        PCWSTR pszPort = psz;
        do
        {
            psz = NextChar(psz+1);
        }
        while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND && *psz!=AT);
        if (*psz!=AT)
        {
            psz = FeedPort(pszPort, pus);
        }
    }

    if (*psz==AT)
    {
        // We've hit a username/password combo. So we have to undo our case-changing 
        psz = pszRestart;
        pus->EraseMarkedText();
        while (*psz!=AT)
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }

        // Now we carry on as before
        while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND)
        {
            pus->Accept(SmallForm(*psz));
            psz = NextChar(psz+1);
        }
        if (*psz==COLON)
        {
            psz = FeedPort(psz, pus);
        }
    }

    pus->ClearMark();
    pus->DisableMunging();

    _pszWork = psz;
    if (!*psz)
    {
        pus->TrimEndWhiteSpace();
        if ((_eScheme!=URL_SCHEME_UNKNOWN) && !(_dwSchemeNotes & UPF_SCHEME_OPAQUE))
        {
            pus->Accept(SLASH);
        }
    }
    else
    {
        if (*psz==QUERY || *psz==POUND)
        {
            pus->Accept(SLASH);
        }
        else
        {
            pus->Accept(*psz);
            _pszWork = NextChar(psz+1);
        }
    }
}


VOID URL::FeedDefaultServer(URL_STRING* pus)
{
    ASSERT(_pszWork);

    PCWSTR psz = NextChar(_pszWork);
    if (!(_dwSchemeNotes & UPF_SCHEME_INTERNET))
    {
        pus->DisableSlashFixing();
    }

    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (*psz==WHACK || *psz==SLASH)
    {
        pus->Accept(*psz);
        psz = NextChar(psz+1);
    }
    if (_dwSchemeNotes & UPF_SCHEME_INTERNET)
    {
        pus->EnableMunging();

        while (*psz && *psz!=WHACK && *psz!=SLASH && *psz!=COLON && *psz!=QUERY && *psz!=POUND)
        {
            pus->Accept(SmallForm(*psz));
            psz = NextChar(psz+1);
        }
        if (*psz==COLON)
        {
            psz = FeedPort(psz, pus);
        }
        pus->DisableMunging();
    }
    else
    {
        while (*psz && *psz!=SLASH)
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }
    }
    _pszWork = psz;
    if (!*psz)
    {
        pus->TrimEndWhiteSpace();
        if ((_eScheme!=URL_SCHEME_UNKNOWN) && !(_dwSchemeNotes & UPF_SCHEME_OPAQUE))
        {
            pus->Accept(SLASH);
        }
    }
    else
    {
        if (*psz==QUERY || *psz==POUND)
        {
            pus->Accept(SLASH);
        }
        else
        {
            pus->Accept(*psz);
            _pszWork = NextChar(psz+1);
        }
    }
}

PCWSTR URL::FeedPort(PCWSTR psz, URL_STRING* pus)
{
    BOOL fIgnorePort = FALSE;
    pus->Mark();
    psz = FeedUntil(psz, pus, SLASH, WHACK, POUND, QUERY);

    if (!(_dwFlags & URL_DONT_SIMPLIFY))
    {
        // Here, decide whether or not to ignore the port
        //  FEATURE we should actually be getting this from
        //  the services file to find out the default protocol port
        //  but we dont think that most people will change them - zekel 17-Dec-96
        switch(_eScheme)
        {
        case URL_SCHEME_HTTP:
            if (pus->CompareMarkWith(L":80")==0)
                fIgnorePort = TRUE;
            break;

        case URL_SCHEME_HTTPS:
            if (pus->CompareMarkWith(L":443")==0)
                fIgnorePort = TRUE;
            break;

        case URL_SCHEME_FTP:
            if (pus->CompareMarkWith(L":21")==0)
                fIgnorePort = TRUE;
            break;

        case URL_SCHEME_GOPHER:
            if (pus->CompareMarkWith(L":70")==0)
                fIgnorePort = TRUE;
            break;
        }
    }
    if (fIgnorePort)
    {
        pus->EraseMarkedText();
    }
    else
    {
        pus->ClearMark();
    }
    return psz;
}

// -------------------------------------------------------------------------------

BOOL URL::DetectAbsolutePath()
{
    BOOL fResult = FALSE;
    if (_dwSchemeNotes & UPF_SCHEME_OPAQUE)
    {
        fResult = TRUE;
    }
    else if (DetectSymbols(SLASH, WHACK))
    {
        fResult = TRUE;
        _pszWork = NextChar(_pszWork+1);
    }
    return fResult;
}

BOOL URL::DetectPath()
{
    return (*NextChar(_pszWork) && !DetectSymbols(QUERY, POUND));
}

VOID URL::FeedPath(URL_STRING* pus, BOOL fMarkServer)
{
    ASSERT(_pszWork);
    PCWSTR psz = NextChar(_pszWork);
    if (fMarkServer)
    {
        pus->Mark();
    }
    if (_dwSchemeNotes & UPF_SCHEME_OPAQUE)
    {
        _pszWork = FeedUntil(psz, pus);
        pus->TrimEndWhiteSpace();
    }
    else
    {
        DWORD cDots;
        BOOL fContinue = TRUE;
        do
        {
            cDots = 0;
            PCWSTR pszTmp = psz;
            if (_fPathCompressionOn)
            {
                cDots = DetectDots(&psz);
            }

            if (cDots)
            {
                if (cDots==2)
                {
                    pus->Contract();
                }
                continue;
            }
            psz = CopySegment(pszTmp, pus, &fContinue);
        }
        while (fContinue);
        _pszWork = psz;
        if (!*_pszWork)
        {
            pus->TrimEndWhiteSpace();
        }
    }
}

// pfContinue indicates whether there's anything following that would
// be of relevance to a path
PCWSTR URL::CopySegment(PCWSTR psz, URL_STRING* pus, BOOL* pfContinue)
{
    ASSERT(pfContinue);
    BOOL fStop = FALSE;
    psz = NextChar(psz);
    while (!fStop)
    {
        switch (*psz)
        {
        case POUND:
            if (_eScheme==URL_SCHEME_FILE)
            {
                // Since #s are valid for dos paths, we have to accept them except
                // for when they follow a .htm/.html file (See FindFragmentA/W)
                 // However, some inconsistencies may still arise...
                for (DWORD i=0; i < ARRAYSIZE(ExtTable); i++)
                {
                    if (!pus->CompareLast(ExtTable[i].wszExt, ExtTable[i].cchExt))
                        break;
                }
                // If we haven't found a matching file extension, we'll treat as a filename character.
                if (i==ARRAYSIZE(ExtTable))
                {
                    pus->Accept(*psz);
                    psz = NextChar(psz+1);
                    break;
                }
            }
            goto next;

        case QUERY:
            // We're going to support query as a legitimate character in file urls.
            // *sigh*
             if (_eScheme==URL_SCHEME_FILE)
            {
                if (_fIgnoreQuery)
                {
                    psz = wszBogus;
                }
                else
                {
                    pus->CleanAccept(*psz);
                    psz = NextChar(psz+1);
                    break;
                }
            }
        case L'\0':
        next:
            *pfContinue = FALSE;
            fStop = TRUE;
            break;

        case SLASH:
        case WHACK:
            fStop = TRUE;
            // fall through

        default:
            pus->Accept(*psz);
            psz = NextChar(psz+1);
            break;
        }
    }
    return psz;
}

DWORD URL::DetectDots(PCWSTR* ppsz)
{
    PCWSTR psz;
    if (ppsz)
    {
        psz = *ppsz;
    }
    else
    {
        psz = NextChar(_pszWork);
    }

    DWORD cDots = 0;
    if (*psz==DOT)
    {
        psz = NextChar(psz+1);
        cDots++;
        if (*psz==DOT)
        {
            psz = NextChar(psz+1);
            cDots++;
        }
        switch (*psz)
        {
        case WHACK:
            if (_eScheme==URL_SCHEME_MK)
            {
                cDots = 0;
            }

        case SLASH:
            psz = NextChar(psz+1);
            break;

        case QUERY:
        case POUND:
        case L'\0':
            break;
         default:
            cDots = 0;
            break;
        }
    }
    if (ppsz)
    {
        *ppsz = psz;
    }
    return cDots;
}

VOID URL::StopPathCompression()
{
    _fPathCompressionOn = FALSE;
}


// -------------------------------------------------------------------------------

BOOL URL::DetectQueryOrFragment()
{
    return (DetectSymbols(QUERY, POUND));
}

BOOL URL::DetectQuery()
{
    return (DetectSymbols(QUERY));
}

VOID URL::IgnoreQuery()
{
    ASSERT(_eScheme==URL_SCHEME_FILE);
    _fIgnoreQuery = TRUE;
}

VOID URL::FeedQueryAndFragment(URL_STRING* pus)
{
    ASSERT(_pszWork);
    if (_dwSchemeNotes & UPF_SCHEME_OPAQUE)
    {
        PCWSTR psz = NextChar(_pszWork);
        while (*psz)
        {
            pus->Accept(*psz);
            psz = NextChar(psz+1);
        }
        _pszWork = psz;
        return;
    }

    PCWSTR psz = NextChar(_pszWork);

    // This is okay since *psz must equal { ? | # }
    if (*psz==QUERY)
    {
        pus->CleanAccept(QUERY);
    }

    // By munging, I mean taking an URL of form http://a/b#c?d and producing http://a/b?d#c
    // We do this by default; however, we won't do this when we've been passed a fragment only
    // as a relative url

    // Query's always override.

    if (*psz==QUERY)
    {
        pus->DropQuery();
        pus->NotifyQuery();
        pus->EnableMunging();

        psz = NextChar(psz+1);
        while (*psz)
        {
            if (*psz==POUND)
            {
                pus->NotifyFragment();
            }
            else
            {
                pus->Accept(*psz);
            }
            psz = NextChar(psz+1);
        }
    }
    else
    {
        // This line of code will determine whether we've been passed a fragment for a relative url
        // For properly formed base urls, this won't matter.
        BOOL fMunge = psz!=NextChar(_pszUrl);

        pus->DropFragment();
        pus->NotifyFragment();
        pus->EnableMunging();

        psz = NextChar(psz+1);

        // The following line is bogus. It just keeps going until the end. Not good.
        // We MAY or MAY NOT fix this, depending on how much people scream at me.
        // This may be an issue for Netscape compatibility.

        // What we could do is: when either query or fragment would be blank, preserve as is.
        // This would minimise breaking compatibility across the board.
        // -- AKABIR, 09/28/98
        while ((*psz==QUERY && !fMunge) || *psz)
        {
            if (*psz==QUERY)
            {
                pus->CleanAccept(QUERY);
            }
            else
            {
                pus->Accept(*psz);
            }
            psz = NextChar(psz+1);
        }

        if (*psz==QUERY)
        {
            pus->DropFragment();
            pus->NotifyQuery();
            pus->CleanAccept(*psz);
            psz = NextChar(psz+1);
            while (*psz)
            {
                pus->Accept(*psz);
                psz = NextChar(psz+1);
            }
            pus->TrimEndWhiteSpace();

            pus->NotifyFragment();
            psz = NextChar(_pszWork);
            pus->CleanAccept(*psz);
            psz = NextChar(psz+1);
            while (*psz!=QUERY)
            {
                pus->Accept(*psz);
                psz = NextChar(psz+1);
            }
        }
    }
    pus->TrimEndWhiteSpace();
    pus->ClearMark();
}

// -------------------------------------------------------------------------------

HRESULT
BlendUrls(URL& urlBase, URL& urlRelative, URL_STRING* pusOut, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    // -- SCHEME --------------------------------------------------------------------------
    // Examine each url's scheme.
    // We won't continue to use urlBase IF
    // 1. their tokenized schemes are not identical
    // 2. the scheme is a file
    // 3. the actual string schemes are not identical

    //  this checks to make sure that these are the same scheme, and
    //  that the scheme is allowed to be used in relative URLs
    //  file: is not allowed to because of weirdness with drive letters
    //  and \\UNC\shares

    BOOL fBaseServerDetected = FALSE, fRelativeServerDetected = FALSE;
    BOOL fDetectAbsoluteRelPath = FALSE;
    BOOL fDetectedRelScheme = urlRelative.DetectAndFeedScheme(pusOut);
    BOOL fDetectedBaseScheme = FALSE;
    if (fDetectedRelScheme
        && ((pusOut->QueryScheme()==URL_SCHEME_FILE)
           || (urlRelative.GetSchemeNotes() & UPF_SCHEME_OPAQUE)))
    {
        urlBase.Reset();
    }
    else if ((fDetectedBaseScheme = urlBase.DetectAndFeedScheme(pusOut, fDetectedRelScheme)))
    {
        if (!fDetectedRelScheme)
        {
            urlRelative.SetScheme(urlBase.GetScheme(), urlBase.GetSchemeNotes());
        }
    }

    // We fall back on the original parser for those cases we don't handle yet.
    // (dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)
    if (((pusOut->QueryScheme()==URL_SCHEME_FILE)
         || (!(fDetectedRelScheme || fDetectedBaseScheme)))
        && ((dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)))
    {
        hr = E_FAIL;
        goto exit;
    }


    if ((pusOut->QueryScheme()==URL_SCHEME_UNKNOWN))
    {
        // BUG BUG For IE4 compat, we need to use the old parser. However
        // if we're passed URL_PLUGGABLE_PROTOCOL, we'll use this parser.

        if (!(dwFlags & URL_PLUGGABLE_PROTOCOL))
        {
            hr = E_FAIL;
            goto exit;
        }

        urlRelative.StopPathCompression();

            // Same schemes, so now we look at the base url to divine the opacity
        if (urlBase.DetectAnything() && !urlBase.IsReset())
        {
            if (!urlBase.DetectSlash())
            {
                if (!urlRelative.DetectQueryOrFragment())
                {
                    urlBase.Reset();
                }
                urlBase.AddSchemeNote(UPF_SCHEME_OPAQUE);
                urlRelative.AddSchemeNote(UPF_SCHEME_OPAQUE);
                pusOut->AddSchemeNote(UPF_SCHEME_OPAQUE);
            }
        }
        else if (!urlRelative.DetectSlash())
        {
            // If urlBase is reset, that means the schemes are different,
            // so we only have urlRelative to figure out opacity.

            urlRelative.AddSchemeNote(UPF_SCHEME_OPAQUE);
            pusOut->AddSchemeNote(UPF_SCHEME_OPAQUE);
        }
    }
    else if (pusOut->QueryScheme()==URL_SCHEME_FTP)
    {
        // For ftp urls, we'll assume that we're being passed properly formed urls.
        // Some ftp sites allow backslashes in their object filenames, so we should
        // allow access to these. Also, domain passwords would otherwise need escaping.
        pusOut->DisableSlashFixing();
    }

    if (dwFlags & URL_DONT_SIMPLIFY)
    {
        urlBase.StopPathCompression();
        urlRelative.StopPathCompression();
    }

    // -- SERVER --------------------------------------------------------------------------
    // Decide on the server to use.
    // Question: if urlBase and UrlRelative have the same explicit server, isn't it pointless
    // to continue looking at url base anyway?

    pusOut->EnableMunging();
    if (!(pusOut->GetSchemeNotes() & UPF_SCHEME_OPAQUE))
    {
        if (urlRelative.DetectServer()
            && !(urlBase.DetectServer() && (urlRelative.PeekNext()!=SLASH) && (urlRelative.PeekNext()!=WHACK)))
        {
            fRelativeServerDetected = TRUE;
            urlRelative.FeedServer(pusOut);
            urlBase.Reset();
        }
        else if (urlBase.DetectServer())
        {
            fBaseServerDetected = TRUE;
            urlBase.FeedServer(pusOut);
        }
    }

    // -- PATH ----------------------------------------------------------------------------
    // Figure out the path
    // If the relative url has a path, and it starts with a slash/whack, forget about the
    // base's path and stuff. Otherwise, inherit the base and attach the relative
    // Potential problem: when rel path is empty, we expect to knock of the last base segment

    if (pusOut->QueryScheme()==URL_SCHEME_FILE)
    {
        // Hack for back compat
        // If the relative url consists of a query string, we'll append that to
        // our resultant url, rather than the base's query string
        if (urlRelative.DetectQuery())
        {
            urlBase.IgnoreQuery();
        }
        else
        {

            BOOL fResult1 = urlRelative.DetectAbsolutePath();
            BOOL fResult2 = urlRelative.DetectLocalDrive();

            if (fResult2)
            {
                urlBase.Reset();
                urlRelative.FeedLocalDrive(pusOut);
                if (urlRelative.DetectAbsolutePath())
                {
                    pusOut->Accept(SLASH);
                }
            }
            else
            {
                if (urlBase.DetectLocalDrive())
                {
                    urlBase.FeedLocalDrive(pusOut);
                    if (fResult1)
                    {
                        pusOut->Accept(SLASH);
                        urlBase.Reset();
                    }
                    else if (urlBase.DetectAbsolutePath())
                    {
                        pusOut->Accept(SLASH);
                    }
                }
                else if (fResult1)
                {
                    if (fRelativeServerDetected)
                    {
                        pusOut->Accept(SLASH);
                    }
                    urlBase.Reset();
                }
            }
        }
    }
    else if (pusOut->QueryScheme()==URL_SCHEME_UNKNOWN)
    {
        if (pusOut->GetSchemeNotes() & UPF_SCHEME_OPAQUE)
        {
            if (!urlRelative.DetectAnything())
            {
                urlRelative.Reset();
            }
        }
        else
        {
        // This code fragment is for urls with unknown schemes, that are to be
        // treated hierarchically. Note that the authority (which has been passed in
        // already) is terminated with /, ?, or \0. The / is *optional*, and should be
        // appended if and only if the urls being combined call for it.
            if (urlBase.IsReset())
            {
            // At this point, we're examining only the relative url. We've been brought to
            // a stop by the presence of /, ? or \0. So
                if (urlRelative.DetectSlash() && !fDetectedRelScheme)
                {
                    pusOut->Accept(SLASH);
                }
            }
            else
            {
            // In this case, we have both the relative and base urls to look at.
            // What's the terminator for the base url
                if ((urlRelative.DetectSlash()
                        || (!urlBase.DetectAnything()
                           && urlRelative.DetectAnything()
                           && !urlRelative.DetectQuery()))
                    && !fDetectedRelScheme)
                {
                    pusOut->Accept(SLASH);
                }
            }
        }
    }

    pusOut->EnableMunging();

    if ((fBaseServerDetected && (fDetectAbsoluteRelPath = urlRelative.DetectAbsolutePath())))
    {
        if (!fRelativeServerDetected)
        {
            pusOut->RestoreFlags();
        }
        if (fDetectAbsoluteRelPath && urlRelative.DetectDots(NULL))
        {
            urlRelative.StopPathCompression();
        }
        urlRelative.FeedPath(pusOut);
        urlBase.Reset();
    }
    else if (urlBase.DetectPath())
    {
        urlBase.FeedPath(pusOut);
        // We don't want to contract the base path's free segment if
        // a. the scheme is opaque
        // b. the relative url has a path
        // c. the relative url has no path, just a fragment/query
        if (!(urlBase.GetSchemeNotes() & UPF_SCHEME_OPAQUE))
        {
            pusOut->RestoreFlags();

            if (urlRelative.DetectPath()
               || !urlRelative.DetectQueryOrFragment())
            {
                if (urlRelative.DetectPath() || !fDetectedRelScheme)
                {
                    pusOut->Contract(FALSE);
                }
                if (fDetectedRelScheme)
                {
                    urlRelative.StopPathCompression();
                }
                urlRelative.FeedPath(pusOut, FALSE);
                urlBase.Reset();
            }
            else
            {
                urlRelative.FeedPath(pusOut, FALSE);
            }
        }
        else
        {
            urlRelative.StopPathCompression();
            urlRelative.FeedPath(pusOut, FALSE);
        }
    }
    else if (urlRelative.DetectPath())
    {
        if (!fRelativeServerDetected)
        {
            pusOut->RestoreFlags();
        }
        else if (urlRelative.DetectDots(NULL))
        {
            urlRelative.StopPathCompression();
        }
        urlRelative.FeedPath(pusOut);
        urlBase.Reset();
    }
    pusOut->ClearMark();

    pusOut->DisableSlashFixing();
    // -- QUERY AND FRAGMENT -----------------------------------------------------------
    // Figure out the query
    if (urlBase.DetectQueryOrFragment())
    {
        urlBase.FeedQueryAndFragment(pusOut);
    }
    if (urlRelative.DetectQueryOrFragment())
    {
        urlRelative.FeedQueryAndFragment(pusOut);
    }
    pusOut->CleanAccept(L'\0');

    if (pusOut->AnyProblems())
    {
        hr = E_OUTOFMEMORY;
    }
exit:
    return hr;
}


HRESULT
FormUrlCombineResultW(LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    if ((dwFlags & URL_ESCAPE_UNSAFE)
        && (dwFlags & URL_ESCAPE_SPACES_ONLY))
    {
    // In the original parser, ESCAPE_SPACES_ONLY takes precedence over ESCAPE_UNSAFE
    // Deactivate UNSAFE
        dwFlags ^= URL_ESCAPE_UNSAFE;
    }

    DWORD dwTempFlags = dwFlags;
    if (dwFlags & URL_UNESCAPE)
    {
        if (dwFlags & URL_ESCAPE_UNSAFE)
        {
            dwTempFlags ^= URL_ESCAPE_UNSAFE;
        }
        if (dwFlags & URL_ESCAPE_SPACES_ONLY)
        {
            dwTempFlags ^= URL_ESCAPE_SPACES_ONLY;
        }
    }

    // Make a copy of the relative url if the client wants to either
    // a. unescape and escape the URL (since roundtripping is not guaranteed), or
    // b. use the same location for relative URL's buffer for the combined url
    HRESULT hr;
    URL curlBase, curlRelative;
    curlBase.Setup((PWSTR)pszBase);
    curlRelative.Setup((PWSTR)pszRelative);
    URL_STRING us(dwTempFlags);

    hr = BlendUrls(curlBase, curlRelative, &us, dwTempFlags);

    if (SUCCEEDED(hr))
    {
        DWORD ccBuffer = us.GetTotalLength();
        if ((dwFlags & URL_UNESCAPE)
            && (dwFlags & (URL_ESCAPE_UNSAFE | URL_ESCAPE_SPACES_ONLY)))
        {
            // No need to strip out URL_UNESCAPE
            hr = UrlEscapeW(us.GetStart(), pszCombined, pcchCombined, dwFlags);
            goto exit;
        }
        if (ccBuffer > *pcchCombined)
        {
            hr = E_POINTER;
        }
        else if (pszCombined)
        {
            memcpy(pszCombined, us.GetStart(), ccBuffer*sizeof(WCHAR));
            // We return only the number of characters, not buffer size required.
            ccBuffer--;
        }
        *pcchCombined = ccBuffer;
    }
    else if (hr==E_FAIL)
    {
//        ASSERT(((dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)));

        // We fall back on the original parser for those cases we don't handle yet.
        // We should do this if and only if the new parser
        // doesn't handle the flags cited above
        // or we're passed a pluggable protocol without the forcing flag.
        SHSTRW strwOut;
        hr = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
        if(SUCCEEDED(hr))
        {
            hr = ReconcileHresults(hr, CopyOutW(&strwOut, pszCombined, pcchCombined));
        }
    }

exit:
    return hr;
}

HRESULT
FormUrlCombineResultA(LPCSTR pszBase,
           LPCSTR pszRelative,
           LPSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    if ((dwFlags & URL_ESCAPE_UNSAFE)
        &&
        (dwFlags & URL_ESCAPE_SPACES_ONLY))
    {
    // In the original parser, ESCAPE_SPACES_ONLY takes precedence over ESCAPE_UNSAFE
    // Deactivate UNSAFE
        dwFlags ^= URL_ESCAPE_UNSAFE;
    }

    // Make a copy of the relative url if the client wants to either
    // a. unescape and escape the URL (since roundtripping is not guaranteed), or
    // b. use the same location for relative URL's buffer for the combined url
    SHSTRW strwBase;
    SHSTRW strwRelative;
    HRESULT hr;

    if (!(SUCCEEDED(strwBase.SetStr(pszBase)) && SUCCEEDED(strwRelative.SetStr(pszRelative))))
    {
        return E_OUTOFMEMORY;
    }

    DWORD dwTempFlags = dwFlags;
    if (dwFlags & URL_UNESCAPE)
    {
        if (dwFlags & URL_ESCAPE_UNSAFE)
        {
            dwTempFlags ^= URL_ESCAPE_UNSAFE;
        }
        if (dwFlags & URL_ESCAPE_SPACES_ONLY)
        {
            dwTempFlags ^= URL_ESCAPE_SPACES_ONLY;
        }
    }

    URL curlBase, curlRelative;
    curlBase.Setup(strwBase);
    curlRelative.Setup(strwRelative);
    URL_STRING us(dwTempFlags);

    hr = BlendUrls(curlBase, curlRelative, &us, dwTempFlags);

    if (SUCCEEDED(hr))
    {
        SHSTRA straOut;
        if ((dwFlags & URL_UNESCAPE)
            && (dwFlags & (URL_ESCAPE_UNSAFE | URL_ESCAPE_SPACES_ONLY)))
        {
            SHSTRW strwTemp;
            // No need to strip out URL_UNESCAPE
            hr = SHUrlEscape(us.GetStart(), &strwTemp, dwFlags);
            hr = ReconcileHresults(hr, straOut.SetStr(strwTemp));
        }
        else
        {
            hr = straOut.SetStr(us.GetStart());
        }
        if (SUCCEEDED(hr))
        {
            hr = CopyOutA(&straOut, pszCombined, pcchCombined);
        }
    }
    else if (hr==E_FAIL)
    {
//        ASSERT(((dwFlags & URL_FILE_USE_PATHURL) || (dwFlags & URL_WININET_COMPATIBILITY)));

        // We fall back on the original parser for those cases we don't handle yet.
        // We should do this if and only if the new parser
        // doesn't handle the flags cited above
        SHSTRW strwOut;

        hr = SHUrlParse(strwBase, strwRelative, &strwOut, dwFlags);
        if (SUCCEEDED(hr))
        {
            SHSTRA straOut;
            hr = ReconcileHresults(hr, straOut.SetStr(strwOut));
            if(SUCCEEDED(hr))
                hr = ReconcileHresults(hr, CopyOutA(&straOut, pszCombined, pcchCombined));
        }
    }

    return hr;
}


#ifdef PROOFREAD_PARSES

EXTERN_C DWORD g_dwProofMode;

enum
{
    PP_COMPARE,
    PP_ORIGINAL_ONLY,
    PP_NEW_ONLY
};

//#define SHOW_MESSAGEBOX

VOID LogData(PWSTR pszMsg)
{
    SHSTRA str;
    str.SetStr(pszMsg);
    CHAR szFileName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    CHAR szComputerName[MAX_PATH];
    HANDLE hResultsFile = NULL;
    strcpy(szFileName, "\\\\BANYAN\\IPTD\\AKABIR\\1315\\");
    if (!GetComputerNameA(szComputerName, &dwSize))
    {
        goto exit;
    }
    lstrcatA(szFileName, szComputerName);
    hResultsFile = CreateFileA( szFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL);
    if (INVALID_HANDLE_VALUE == hResultsFile)
        hResultsFile = NULL;
    if (hResultsFile)
    {
        if (SetFilePointer(hResultsFile, 0, NULL, FILE_END)==0xFFFFFFFF)
        {
            goto exit;
        }
        DWORD dwFoo;
        if (0==WriteFile(hResultsFile, (PVOID)(PSTR)str, lstrlenW(pszMsg), &dwFoo, NULL))
        {
            DWORD dwE = GetLastError();
        }
    }
exit:
    if (hResultsFile)
    {
        CloseHandle(hResultsFile);
    }
}

HRESULT ProofreadParses(HRESULT hr,
           LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           PDWORD pcchCombined,
           DWORD dwFlags,
           DWORD dwSize
           )
{
    static WCHAR szLast[2084];
    SHSTRW strwOut;

switch(g_dwProofMode)
{
case PP_COMPARE:
    {
    HRESULT hr2 = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
    WCHAR wstr[2084];
    DWORD ccLen = min(2084, dwSize), ccUrl = SUCCEEDED(hr) ? *pcchCombined : 0;
    if(SUCCEEDED(hr2))
    {
        hr2 = CopyOutW(&strwOut, wstr, &ccLen);
        if (hr2 == E_POINTER && hr == E_POINTER)
        {
            goto exitpoint;
        }
        // Check if cached combine equals the new parser's result
        if (!StrCmpW(pszCombined, szLast))
        {
            goto exitpoint;
        }
        // Check if cached combine equals the old parser's result
        if (!StrCmpW(wstr, szLast))
        {
            *pcchCombined = ccLen;
            StrCpyNW(pszCombined, wstr, ccLen + 1);
            hr = hr2;
            goto exitpoint;
        }
        if (SUCCEEDED(hr))
        {
            StrCpyNW(szLast, wstr, ccLen);

            if (!StrCmpW(wstr, pszCombined))
            {
                goto exitpoint;
            }

            DWORD dwBogus;
            if ((dwFlags & URL_ESCAPE_SPACES_ONLY) && !(dwFlags & URL_UNESCAPE))
            {
                PCWSTR psz = FindSchemeW(pszCombined, &dwBogus);
                DWORD dw;
                if (psz
                    &&
                    (URL_SCHEME_UNKNOWN
                        !=GetSchemeTypeAndFlagsW(psz, dwBogus, &dw))
                    &&
                    (dw & UPF_SCHEME_OPAQUE))
                {
                    goto exitpoint;
                }
            }

            // Filter
            // base: "http://foo/bar/"
            // rel:  ""
            // old:  "http://foo/bar"
            // new:  "http://foo/bar/"
            if ((*pszRelative==L'\0')
                &&
                (!StrCmpNW(pszCombined, wstr, ccLen))
                &&
                (ccUrl==(ccLen+1))
                &&
                (pszCombined[ccLen]==L'/'))
            {
                goto exitpoint;
            }

            // Filter
            // base: "http://foo/bar/what?ho"
            // rel:  ""
            // old:  "http://foo/bar/?ho"
            // new:  "http://foo/bar/"
            if ((*pszRelative==L'\0')
                &&
                (!StrCmpNW(pszCombined, wstr, ccUrl))
                &&
                (wstr[ccUrl]==QUERY))
            {
                goto exitpoint;
            }

            // Filter
            // base: "http://foo/bar/what?ho"
            // rel:  "/"
            // old:  "http://foo"
            // new:  "http://foo/"
            if ((*pszRelative==L'/')
                &&
                (!StrCmpNW(pszCombined, wstr, ccLen))
                &&
                (ccUrl==(ccLen+1))
                &&
                (pszCombined[ccLen]==L'/'))
            {
                goto exitpoint;
            }

            WCHAR wmsg[8192];
            wnsprintfW(wmsg,
                    ARRAYSIZE(wmsg),
                    L"Flags:%#x\nBase:\"%s\"\nRelative:\"%s\"\nOriginal result:\"%s\"\nNew result:\"%s\"\nUse original, not new, result?\n",
                    dwFlags,
                    pszBase,
                    pszRelative,
                    wstr,
                    pszCombined
                    );
#ifdef SHOW_MESSAGEBOX
            if (IDYES==MessageBoxW(
                NULL,
                wmsg,
                L"CONTACT AKABIR: URLCOMBINE FAILURE",
                MB_YESNO | MB_ICONERROR | MB_TASKMODAL))
            {
                StrCpyNW(pszCombined, wstr, dwSize);
                *pcchCombined = ccLen;
            }
            else
            {
                StrCpyNW(szLast, pszCombined, *pcchCombined);
            }
#endif
            LogData(wmsg);
        }
        else
        {
            WCHAR wmsg[8192];
            wnsprintfW(wmsg,
                    ARRAYSIZE(wmsg),
                    L"Flags:%#x\nBase:\"%s\"\nRelative:\"%s\"\nFAILED:%#x\nExpected:\"%s\"\n",
                    dwFlags,
                    pszBase,
                    pszRelative,
                    hr,
                    wstr);
#ifdef SHOW_MESSAGEBOX
            MessageBoxW(
                NULL,
                wmsg,
                L"CONTACT AKABIR: URLCOMBINE FAILURE",
                MB_OK | MB_ICONERROR | MB_TASKMODAL);
#endif
            StrCpyNW(pszCombined, wstr, dwSize);
            *pcchCombined = ccLen;
            LogData(wmsg);
        }
        hr = hr2;
    }
    }
    break;

case PP_NEW_ONLY:
    break;

case PP_ORIGINAL_ONLY:
    {
    hr = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
    if(SUCCEEDED(hr))
    {
        hr = CopyOutW(&strwOut, pszCombined, pcchCombined);
    }
    }
    break;
    }

exitpoint:
    return hr;
}

#endif //PROOFREAD_PARSES

LWSTDAPI
UrlCombineW(LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (pszBase && pszRelative && pcchCombined)
    {
        RIP(IS_VALID_STRING_PTRW(pszBase, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_STRING_PTRW(pszRelative, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_WRITE_PTR(pcchCombined, DWORD));
        RIP((!pszCombined || IS_VALID_WRITE_BUFFER(pszCombined, WCHAR, *pcchCombined)));

#ifdef PROOFREAD_PARSES
        DWORD dwSize = *pcchCombined;
#endif

        hr = FormUrlCombineResultW(pszBase, pszRelative, pszCombined, pcchCombined, dwFlags);

#ifdef PROOFREAD_PARSES
        hr = ProofreadParses(hr, pszBase, pszRelative, pszCombined, pcchCombined, dwFlags, dwSize);
#endif
    }
    return hr;
}

LWSTDAPI
UrlCombineA(LPCSTR pszBase,
           LPCSTR pszRelative,
           LPSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;

    if (!pszBase
        || !pszRelative
        || !pcchOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RIP(IS_VALID_STRING_PTRA(pszBase, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_STRING_PTRA(pszRelative, INTERNET_MAX_PATH_LENGTH));
        RIP(IS_VALID_WRITE_PTR(pcchOut, DWORD));
        RIP((!pszOut || IS_VALID_WRITE_BUFFER(pszOut, CHAR, *pcchOut)));

        hr = FormUrlCombineResultA(pszBase, pszRelative, pszOut, pcchOut, dwFlags);
    }

    return hr;
}

#else // end USE_FAST_PARSER

LWSTDAPI
UrlCombineW(LPCWSTR pszBase,
           LPCWSTR pszRelative,
           LPWSTR pszCombined,
           LPDWORD pcchCombined,
           DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    RIPMSG(pszBase && IS_VALID_STRING_PTRW(pszBase, -1), "UrlCombineW: Caller passed invalid pszBase");
    RIPMSG(pszRelative && IS_VALID_STRING_PTRW(pszRelative, -1), "UrlCombineW: Caller passed invalid pszRelative");
    RIPMSG(NULL!=pcchOut, "UrlCombineW: Caller passed invalid pcchOut");
    RIPMSG(NULL==pcchOut || (pszOut && IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCombineW: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut == pszBase || pszOut == pszRelative)
            DEBUGWhackPathStringW(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferW(pszOut, *pcchOut);
    }
#endif

    if (pszBase && pszRelative && pcchCombined)
    {
        SHSTRW strwOut;
        hr = SHUrlParse(pszBase, pszRelative, &strwOut, dwFlags);
        if(SUCCEEDED(hr))
        {
            hr = CopyOutW(&strwOut, pszCombined, pcchCombined);
        }
    }
    return hr;
}

LWSTDAPI
UrlCombineA(LPCSTR pszBase,
           LPCSTR pszRelative,
           LPSTR pszOut,
           LPDWORD pcchOut,
           DWORD dwFlags)
{
    HRESULT hr;
    SHSTRA straOut;

    RIPMSG(pszBase && IS_VALID_STRING_PTRA(pszBase, -1), "UrlCombineA: Caller passed invalid pszBase");
    RIPMSG(pszRelative && IS_VALID_STRING_PTRA(pszRelative, -1), "UrlCombineA: Caller passed invalid pszRelative");
    RIPMSG(NULL!=pcchOut, "UrlCombineA: Caller passed invalid pcchOut");
    RIPMSG(NULL==pcchOut || (pszOut && IS_VALID_WRITE_BUFFER(pszOut, char, *pcchOut)), "UrlCombineA: Caller passed invalid pszOut");
#ifdef DEBUG
    if (pcchOut)
    {
        if (pszOut == pszBase || pszOut == pszRelative)
            DEBUGWhackPathStringA(pszOut, *pcchOut);
        else
            DEBUGWhackPathBufferA(pszOut, *pcchOut);
    }
#endif

    if (!pszBase || !pszRelative || !pcchOut)
        hr = E_INVALIDARG;
    else
    {
        SHSTRW strwOut;
        SHSTRW strwBase;
        SHSTRW strwRelative;

        if(SUCCEEDED(strwBase.SetStr(pszBase)) && SUCCEEDED(strwRelative.SetStr(pszRelative)))
            hr = SHUrlParse((LPWSTR) strwBase, (LPWSTR)strwRelative, &strwOut, dwFlags);
        else
            hr = E_OUTOFMEMORY;

        if(SUCCEEDED(hr))
            hr = straOut.SetStr(strwOut);
    }

    if(SUCCEEDED(hr) )
        hr = CopyOutA(&straOut, pszOut, pcchOut);

    return hr;
}

#endif // !USE_FAST_PARSER


//
// Combines the desired scheme with the string after the scheme with a : in between.  For
// some protocols, a // is placed after the colon.
//

PRIVATE HRESULT ColonSlashSlashW
(
    LPCWSTR pszScheme,       // url protocol (lower-case)
    LPCWSTR pszAfterScheme,  // string to append after the protocol
    LPWSTR pszTranslatedUrl, // output buffer
    int cchMax               // size of output buffer
)
{
    StrCpyNW(pszTranslatedUrl, pszScheme, cchMax);

    // Append : after scheme and possibly a // as well.
    int cchScheme = lstrlenW(pszScheme);
    if (cchMax > cchScheme + 3)
    {
        pszTranslatedUrl[cchScheme] = L':';

        // Number of characters to skip over in the buffer (how many non alphanums originally
        // followed the protocol)
        int cchSkip = 0;

        // Number of characters past the protocol: to skip over in the URL (Do we insert slashes?)
        int cchSlashes = 0;


        // Modify this conditional to include any other protocols to always follow with ://
        // Right now, http, https and ftp are automatic
        if (!StrCmpW(pszScheme, L"http") || !StrCmpW(pszScheme, L"ftp") || !StrCmpW(pszScheme, L"https") )
        {
            //
            // When preparing to copy the contents of pszAfterScheme into pszUrl, we can
            // skip over as many as 3 non alpha numeric characters, since we are adding ://
            // to the protocol directly
            //
            while ((cchSkip < 3) && pszAfterScheme[cchSkip] && !IsCharAlphaNumericW(pszAfterScheme[cchSkip]))
            {
                cchSkip++;
            }
            pszTranslatedUrl[cchScheme+1] = L'/';
            pszTranslatedUrl[cchScheme+2] = L'/';
            pszTranslatedUrl[cchScheme+3] = L'\0';
            cchSlashes = 2;
        }
        else
        // some other protocol
        {
            // just skip over colon
            cchSkip = 1;
            pszTranslatedUrl[cchScheme+1] = L'\0';

        }

        // Copy the rest of the Url from the UrlBuffer into the Url
        StrCatBuffW(pszTranslatedUrl, pszAfterScheme + cchSkip, cchMax);
    }

    return S_OK;
}

//
// Scans the url for a scheme and if it does not match the known schemes, then
// a closest match is found.
//
LWSTDAPI
UrlFixupW
(
    LPCWSTR pcszUrl,         // URL to correct
    LPWSTR pszTranslatedUrl, // buffer for corrected url (can be same as pcszUrl)
    DWORD cchMax             // size of pszTranslatedUrl
    )
{
    HRESULT hr = S_OK;

    //
    // Find the scheme
    //
    WCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    ULONG cchScheme = 0;
    LPCWSTR pszScheme = FindSchemeW(pcszUrl, &cchScheme, TRUE);
    if (NULL == pszScheme || cchScheme > (ARRAYSIZE(szScheme)-1))
    {
        // No scheme found
        return S_FALSE;
    }

    for (ULONG cch=0; cch < cchScheme; ++cch, ++pszScheme)
    {
        szScheme[cch] = Ascii_ToLowerW(*pszScheme);
    }
    szScheme[cch] = L'\0';
    LPCWSTR pszAfterScheme = pszScheme;

    //
    // If input and output buffers are the same, copy the stuff after the scheme
    // to another buffer so it doesn't get clobbered when we recombine.
    //
    WCHAR szBuf[INTERNET_MAX_PATH_LENGTH];
    if (pcszUrl == pszTranslatedUrl)
    {
        StrCpyNW(szBuf, pszAfterScheme, ARRAYSIZE(szBuf));
        pszAfterScheme = szBuf;
    }

    //
    // See if it matches any of our known schemes
    //
    BOOL fKnownScheme = FALSE;
    for (ULONG i = 0; i < ARRAYSIZE(g_mpUrlSchemeTypes); ++i)
    {
        if (StrCmpW(szScheme, g_mpUrlSchemeTypes[i].pszScheme) == 0)
        {
            fKnownScheme = TRUE;
            break;
        }
    }

    //
    // If it matches a known scheme, then just fix :// if it's ftp or http
    //
    if (fKnownScheme ||

        // Check for pluggable protocols too
        NO_ERROR == SHGetValueW(HKEY_CLASSES_ROOT, szScheme, L"URL Protocol",
                               NULL, NULL, NULL))
    {
        ColonSlashSlashW(szScheme, pszAfterScheme, pszTranslatedUrl, cchMax);
        return S_OK;
    }

    //
    // Try to find a good match for the mispelled scheme
    //

    // These are weights used in the heuristic for the protocol matching
    // iFloor is roughly the minimum percentage of characters that must match in
    // order to make a change
    const int cFloor = 60;

    // A match in the first character has the greatest weight
    const int cCorrectFirstChar = 150;

    // Any other matched character
    const int cCorrectChar = 100;

    // The weight given to a character that only matches the preceding
    // or subsequent character in the protocol
    const int cOffByOneChar = 80;

    // We penalize characters that are off by one, but if we have already
    // observed the offset and subsequent characters continue the offset, we add this
    const int cOffsetBonus = 20;

    // The value of the best "match" found so far. Higher is a better match.
    int iBestEval = 0;

    // The protocol that's the best fit for the misspelled one
    LPCWSTR pszBestMatch = NULL;

    ULONG cchProt;
    for (ULONG j = 0; j < ARRAYSIZE(g_mpUrlSchemeTypes); ++j)
    {
        // Is this one we don't correct to?
        //
        // Note:  https is removed from this list.  The potential for an intended "http" to
        // be corrected to "https" is too high, and "http" is far more common.  All this
        // means is that if someone wants to get to an https site, they have to have it right.
        //
        if (IsFlagSet(g_mpUrlSchemeTypes[j].dwFlags, UPF_SCHEME_DONTCORRECT))
            continue;

        LPCWSTR pszProtocol = g_mpUrlSchemeTypes[j].pszScheme;
        cchProt = g_mpUrlSchemeTypes[j].cchScheme;

        // Evaluation of the fit of the currently tested protocol
        int iEval = 0;

        //
        // Keep track of the positive or negative offset in the protocol
        // such as "qhttp" instead of "http" or "elnet" instead of "telnet'
        //
        int iPosOffset = 0;
        int iNegOffset = 0;

        //
        // The first character has the most weight. "htp" corrects
        // to "http" and not "ftp"    "ftt" corrects to "ftp"
        //
        if (*szScheme == *pszProtocol)
        {
            iEval += cCorrectFirstChar;
        }

        // Check for a negative offset
        else if(*szScheme == pszProtocol[1])
        {
            iEval += cOffByOneChar;
            iNegOffset = 1;
        }

        //
        // We go through the characters in the protocol, even to the
        // terminating null if iPosOffset == 1 (it is never more than 1)
        // This is so the final "p" in "qhttp" gets a chance to be compared
        //
        for (i=1; i < cchProt + iPosOffset; i++)
        {
            // No points for null terminations matching
            if (szScheme[i] == L'\0')
                break;

            //
            // Check for adjacent character match
            //
            if (szScheme[i] == pszProtocol[i])
            {
                iEval += cCorrectChar;
            }
            else
            {
                if (szScheme[i] == pszProtocol[i - 1])
                {
                    iEval += cOffByOneChar;
                    if (iPosOffset)
                        iEval += cOffsetBonus;
                    else
                        iPosOffset = 1;
                }
                else
                {
                    if(szScheme[i] == pszProtocol[i + 1])
                    {
                        iEval += cOffByOneChar;
                        if (iNegOffset)
                            iEval += cOffsetBonus;
                        else
                            iNegOffset = 1;
                    }
                }
            }
        }

        // Divide the Evaluated value by the MAX(cchScheme, cchProt)
        iEval = iEval / (cchScheme > cchProt ? cchScheme : cchProt);

        // A new best match?
        if (iEval > iBestEval)
        {
            iBestEval = iEval;
            pszBestMatch = pszProtocol;

            //
            // If we found an unquestionably good match (only 1 non-firstchar typo),
            // break out of the loop
            //
            if (iEval >= 100)
                break;
         }
    }

    // If a good enough match was found, then correct url
    if (iBestEval >= cFloor)
    {
        ColonSlashSlashW(pszBestMatch, pszAfterScheme, pszTranslatedUrl,cchMax);
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}



// This is a port of InternetCrackUrl from wininet.
// NTRAID:108139 akabir We REALLY NEED TO CLEAN THIS CODE UP.
// RAID 109209

// A lot of the stuff is redundant with the other code available, but we 
// need to be careful not to cause any regressions. Thus, I'm leaving it in for now.

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPWSTR SchemeName;
    DWORD SchemeLength;
    SHINTERNET_SCHEME SchemeType;
    BOOL NeedSlashes;
} URL_SCHEME_INFO;

#define UrlUnescapeInPlaceW(pszUrl, dwFlags)    UrlUnescapeW(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)


// NOTE MEGA REDUNDANCY. We could use the similar table above and check for opaque. However
// we'd have to modify that table
PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,            0,  SHINTERNET_SCHEME_DEFAULT,    FALSE,  
    L"ftp",          3,  SHINTERNET_SCHEME_FTP,        TRUE,   
    L"gopher",       6,  SHINTERNET_SCHEME_GOPHER,     TRUE,   
    L"http",         4,  SHINTERNET_SCHEME_HTTP,       TRUE,   
    L"https",        5,  SHINTERNET_SCHEME_HTTPS,      TRUE,   
    L"file",         4,  SHINTERNET_SCHEME_FILE,       TRUE,   
    L"news",         4,  SHINTERNET_SCHEME_NEWS,       FALSE,  
    L"mailto",       6,  SHINTERNET_SCHEME_MAILTO,     FALSE,  
    L"socks",        5,  SHINTERNET_SCHEME_SOCKS,      FALSE,  
    L"javascript",   10, SHINTERNET_SCHEME_JAVASCRIPT, FALSE,  
    L"vbscript",     8,  SHINTERNET_SCHEME_VBSCRIPT,   FALSE,  
    L"res",          3,  SHINTERNET_SCHEME_RES,        TRUE
};

#define NUMBER_OF_URL_SCHEMES   ARRAYSIZE(UrlSchemeList)

// swiped from wininet\macros.h
#define IsDigit(c) (((c) >= L'0') && ((c) <= L'9'))
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

BOOL ScanSchemes(LPWSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (StrCmpNIW(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

#define ProbeWriteStringBufferW(a, b) ProbeWriteBuffer((LPVOID)a, (b*sizeof(WCHAR)));
#define PAGE_SIZE   4096


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {
        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
DecodeUrl(
    IN LPWSTR Url,
    IN DWORD UrlLength,
    OUT LPWSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
// NOTE We can replace this function with UrlUnescapeInPlace

    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {
        WCHAR ch;

        if (*Url == L'%') {

            //
            // REVIEW - would %00 ever appear in an URL?
            //
            if (IsHex(*(Url+1)) && IsHex(*(Url+2)))
            {
                ch = TranslateEscapedOctetW(Url);
                Url += 3;
            } else {
                return ERROR_INTERNET_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}




DWORD
DecodeUrlInSitu(
    IN LPWSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
// NOTE We can replace this function with UrlUnescapeInPlace
    DWORD stringLength = *BufferLength;
    return DecodeUrl(BufferAddress,
                     stringLength,
                     BufferAddress,
                     BufferLength);
}


DWORD
GetUrlAddressInfo(
    IN OUT LPWSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPWSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPWSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL

--*/

{
    LPWSTR pString;
    LPWSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString!=SLASH) && (*pString != L'\0') && (length != 0)) {
        if (*pString==HEX_ESCAPE) {
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //
            *partEscape = TRUE;
        }
        if (*pString==COLON) {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                // ISSUE Note that passwords might contain colons, and thus not work in this 
                // case
                return ERROR_INTERNET_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_INTERNET_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPWSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPWSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPWSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPWSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPSHINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPWSTR pAt;
    DWORD urlLength;
    LPWSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    WCHAR portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPWSTR pPortNumber;
    DWORD error;
    LPWSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = lstrlenW(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    for (DWORD i = 0; i < urlLength; ++i) {
        if (pUrl[i]==SLASH) {
            break;
        } else if (pUrl[i]==AT) {
            pAt = &pUrl[i];
            break;
        }
    }

    if (pAt != NULL) {
        DWORD addressPartLength;
        LPWSTR userName;
        DWORD userNameLength;
        LPWSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        ASSERT(addressPartLength == 0);
        ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {
                ASSERT(userName != NULL);
                ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {
            // convert the password in situ
            if (part2Escape) {
                ASSERT(userName != NULL);
                ASSERT(userNameLength != 0);
                ASSERT(password != NULL);
                ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {
        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {
            ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {
            ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_INTERNET_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {
        ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {
            DWORD i;
            DWORD port;

            ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!IsDigit(*pPortNumber)) {
                    return ERROR_INTERNET_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - L'0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535) 
                {
                    return ERROR_INTERNET_INVALID_URL;
                }
            }
            *lpPort = (SHINTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


DWORD
CrackUrl(
    IN OUT LPWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPSHINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPWSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPWSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPSHINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPWSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPWSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPWSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPWSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    SHINTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = lstrlenW(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength]!=COLON; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {
            //
            // no ':' in URL? Bogus (dude)
            //
            error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = SHINTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i)) 
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (StrCmpNIW(&lpszUrl[schemeLength], L"://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    if (schemeType == SHINTERNET_SCHEME_FILE)
        isGeneric = TRUE;

    if (schemeType == SHINTERNET_SCHEME_NEWS ||
        schemeType == SHINTERNET_SCHEME_UNKNOWN) {
        //
        //  urls can be hierarchical or opaque.  if the slashes
        //  exist, then we should assume hierarchical
        //  when we dont know the scheme or it is news:.
        //  otherwise it is opaque (isGeneric)
        //

        needSlashes = haveSlashes;
        isGeneric = !haveSlashes;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (SHINTERNET_SCHEME_RES == schemeType) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            PWSTR psz = lpszUrl;
            while (*lpszUrl && *lpszUrl!=SLASH)
                lpszUrl++;

            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = psz;
                *lpdwHostNameLength = (DWORD)(lpszUrl - psz);
                dwUrlLength -= *lpdwHostNameLength;
                error = DecodeUrlInSitu(*lpszHostName, lpdwHostNameLength);
            }
        } else if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}



BOOL
WINAPI
UrlCrackW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPSHURL_COMPONENTSW lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DWORD error = ERROR_SUCCESS;

    // validate parameters
    if (ARGUMENT_PRESENT(lpszUrl)) {
        if (!dwUrlLength) {
            error = ProbeStringW((LPWSTR)lpszUrl, &dwUrlLength);
        } else if (IsBadReadPtr((LPVOID)lpszUrl, dwUrlLength*sizeof(WCHAR))) {
            error = ERROR_INVALID_PARAMETER;
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }
    if (error != ERROR_SUCCESS) 
    {
        goto quit;
    }

    if (IsBadWritePtr(lpUrlComponents, sizeof(*lpUrlComponents))
        || (lpUrlComponents->dwStructSize != sizeof(*lpUrlComponents)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // we only allow two flags for this API
    //

    if (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPWSTR lpUrl;
    LPWSTR urlCopy;
    SHINTERNET_SCHEME schemeType;
    LPWSTR schemeName;
    DWORD schemeNameLength;
    LPWSTR hostName;
    DWORD hostNameLength;
    SHINTERNET_PORT nPort;
    LPWSTR userName;
    DWORD userNameLength;
    LPWSTR password;
    DWORD passwordLength;
    LPWSTR urlPath;
    DWORD urlPathLength;
    LPWSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)schemeName, schemeNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)hostName, hostNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)userName, userNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)password, passwordLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)urlPath, urlPathLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) {
        error = ProbeWriteStringBufferW((LPVOID)extraInfo, extraInfoLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        DWORD dw = dwUrlLength;
        if (!dw)
        {
            dw = lstrlenW(lpszUrl);
        }
        urlCopy = new WCHAR[dw+1];
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        memcpy(urlCopy, lpszUrl, (dw+1)*sizeof(WCHAR));
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPWSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy(lpUrlComponents->lpszScheme, schemeName, schemeNameLength*sizeof(WCHAR));
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszScheme, 0);
            }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy(lpUrlComponents->lpszHostName, hostName, hostNameLength*sizeof(WCHAR));
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszHostName, 0);
            }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy(lpUrlComponents->lpszUserName, userName, userNameLength*sizeof(WCHAR));
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszUserName, 0);
            }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy(lpUrlComponents->lpszPassword, password, passwordLength*sizeof(WCHAR));
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszPassword, 0);
            }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if(schemeType == SHINTERNET_SCHEME_FILE) 
        {
            //
            //  for file: urls we return the path component
            //  as a valid dos path.
            //

            copyFailure = FAILED(PathCreateFromUrlW(lpUrl, lpUrlComponents->lpszUrlPath, &(lpUrlComponents->dwUrlPathLength), 0));
        } 
        else if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy(lpUrlComponents->lpszUrlPath, urlPath, urlPathLength*sizeof(WCHAR));
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy(lpUrlComponents->lpszExtraInfo, extraInfo, extraInfoLength*sizeof(WCHAR));
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlaceW(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    
    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case SHINTERNET_SCHEME_FTP:
            nPort = INTERNET_DEFAULT_FTP_PORT;
            break;

        case SHINTERNET_SCHEME_GOPHER:
            nPort = INTERNET_DEFAULT_GOPHER_PORT;
            break;

        case SHINTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case SHINTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        delete [] urlCopy;
    }

quit:
//    return HRESULT_FROM_WIN32(error);
    if (error!=ERROR_SUCCESS)
    {
        SetLastError(error);
    }
    return error==ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\tpswait.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tpswait.h

Abstract:

    Wait classes. Moved out of tpsclass.h

    Contents:
        CWait
        CWaitRequest
        CWaitAddRequest
        CWaitRemoveRequest
        CWaitThreadInfo

Author:

    Richard L Firth (rfirth) 08-Aug-1998

Revision History:

    08-Aug-1998 rfirth
        Created

--*/

//
// forward declarations
//

class CWaitThreadInfo;

//
// classes
//

//
// CWait
//

class CWait : public CTimedListEntry {

private:

    HANDLE m_hObject;
    WAITORTIMERCALLBACKFUNC m_pCallback;
    LPVOID m_pContext;
    CWaitThreadInfo * m_pThreadInfo;
    DWORD m_dwFlags;

public:

    CWait(HANDLE hObject,
          WAITORTIMERCALLBACKFUNC pCallback,
          LPVOID pContext,
          DWORD dwWaitTime,
          DWORD dwFlags,
          CWaitThreadInfo * pInfo
          ) : CTimedListEntry(dwWaitTime) {
        m_hObject = hObject;
        m_pCallback = pCallback;
        m_pContext = pContext;
        m_pThreadInfo = pInfo;
        m_dwFlags = dwFlags;
    }

    CWait() {
    }

    CWait * Next(VOID) {
        return (CWait *)CTimedListEntry::Next();
    }

    CWaitThreadInfo * GetThreadInfo(VOID) const {
        return m_pThreadInfo;
    }

    VOID Execute(BOOL bTimeout) {

        //
        // execute function in this thread if required to do so, else we run
        // the callback in a non-I/O worker thread
        //

        //
        // APPCOMPAT - can't do this: the callback types for Wait & Work requests
        //          are different: one takes 2 parameters, the other one. We
        //          can't make this change until this issue is resolved with
        //          NT guys
        //

        //if (m_dwFlags & WT_EXECUTEINWAITTHREAD) {
            m_pCallback(m_pContext, bTimeout != 0);
        //} else {
        //
        //    //
        //    //  would have to allocate object from heap to hold callback
        //    //          function, context & bTimeout parameters in order to pass
        //    //          them to worker thread (we only have access to one APC
        //    //          parameter and we'd have to nominate different APC)
        //    //
        //
        //    Ie_QueueUserWorkItem((LPTHREAD_START_ROUTINE)m_pCallback,
        //                         m_pContext,
        //                         FALSE
        //                         );
        //}
    }

    HANDLE GetHandle(VOID) const {
        return m_hObject;
    }

    BOOL IsNoRemoveItem(VOID) {
        return (m_dwFlags & SRWSO_NOREMOVE) ? TRUE : FALSE;
    }
};

//
// CWaitRequest
//

class CWaitRequest {

private:

    BOOL m_bCompleted;
    CWait * m_pWait;

public:

    CWaitRequest() {
        m_bCompleted = FALSE;
    }

    CWaitRequest(CWait * pWait) {
        m_bCompleted = FALSE;
        m_pWait = pWait;
    }

    VOID SetComplete(VOID) {
        m_bCompleted = TRUE;
    }

    VOID WaitForCompletion(VOID) {
        while (!m_bCompleted) {
            SleepEx(0, TRUE);
        }
    }

    VOID SetWaitPointer(CWait * pWait) {
        m_pWait = pWait;
    }

    CWait * GetWaitPointer(VOID) const {
        return m_pWait;
    }
};

//
// CWaitAddRequest
//

class CWaitAddRequest : public CWait, public CWaitRequest {

public:

    CWaitAddRequest(HANDLE hObject,
                    WAITORTIMERCALLBACKFUNC pCallback,
                    LPVOID pContext,
                    DWORD dwWaitTime,
                    DWORD dwFlags,
                    CWaitThreadInfo * pInfo
                    ) :
                    CWait(hObject, pCallback, pContext, dwWaitTime, dwFlags, pInfo),
                    CWaitRequest()
    {
    }
};

//
// CWaitRemoveRequest
//

class CWaitRemoveRequest : public CWaitRequest {

public:

    CWaitRemoveRequest(HANDLE hWait) : CWaitRequest((CWait *)hWait) {
    }
};

//
// CWaitThreadInfo
//

class CWaitThreadInfo : public CDoubleLinkedList, public CCriticalSection {

private:

    HANDLE m_hThread;
    DWORD m_dwObjectCount;
    HANDLE m_Objects[MAXIMUM_WAIT_OBJECTS];
    CWait * m_pWaiters[MAXIMUM_WAIT_OBJECTS];
    CWait m_Waiters[MAXIMUM_WAIT_OBJECTS];
    CDoubleLinkedList m_FreeList;
    CDoubleLinkedList m_WaitList;

public:

    CWaitThreadInfo(CDoubleLinkedList * pList) {
        CDoubleLinkedList::Init();
        m_hThread = NULL;
        m_dwObjectCount = 0;
        m_FreeList.Init();
        m_WaitList.Init();
        for (int i = 0; i < ARRAY_ELEMENTS(m_Waiters); ++i) {
            m_Waiters[i].InsertTail(&m_FreeList);
        }
        InsertHead(pList);
    }

    VOID SetHandle(HANDLE hThread) {
        m_hThread = hThread;
    }

    HANDLE GetHandle(VOID) const {
        return m_hThread;
    }

    DWORD GetObjectCount(VOID) const {
        return m_dwObjectCount;
    }

    BOOL IsAvailableEntry(VOID) const {
        return m_dwObjectCount < ARRAY_ELEMENTS(m_Objects);
    }

    BOOL IsInvalidHandle(DWORD dwIndex) {

        ASSERT(dwIndex < m_dwObjectCount);

        //
        // GetHandleInformation() doesn't exist on Win95
        //
        //
        //DWORD dwHandleFlags;
        //
        //return !GetHandleInformation(m_Objects[dwIndex], &dwHandleFlags);

        DWORD status = WaitForSingleObject(m_Objects[dwIndex], 0);

        if ((status == WAIT_FAILED) && (GetLastError() == ERROR_INVALID_HANDLE)) {
//#if DBG
//char buf[128];
//wsprintf(buf, "IsInvalidHandle(%d): handle %#x is invalid\n", dwIndex, m_Objects[dwIndex]);
//OutputDebugString(buf);
//#endif
            return TRUE;
        }
        return FALSE;
    }

    VOID Compress(DWORD dwIndex, DWORD dwCount = 1) 
    {
        ASSERT(dwCount != 0);
        ASSERT((int)m_dwObjectCount > 0);
        ASSERT(m_dwObjectCount < MAXIMUM_WAIT_OBJECTS);

        if (((dwIndex + dwCount) < m_dwObjectCount) && (m_dwObjectCount < MAXIMUM_WAIT_OBJECTS))
        {
            RtlMoveMemory(&m_Objects[dwIndex],
                          &m_Objects[dwIndex + dwCount],
                          sizeof(m_Objects[0]) * (m_dwObjectCount - (dwIndex + dwCount))
                          );
            RtlMoveMemory(&m_pWaiters[dwIndex],
                          &m_pWaiters[dwIndex + dwCount],
                          sizeof(m_pWaiters[0]) * (m_dwObjectCount - (dwIndex + dwCount))
                          );
        }
        m_dwObjectCount -= dwCount;
    }

    VOID Expand(DWORD dwIndex)
    {
        ASSERT((int)m_dwObjectCount > 0);
        // The off by one is because we copying from dwIndex + 1 and our size to copy is
        // m_dwObjectCount - dwIndex
        if (m_dwObjectCount < MAXIMUM_WAIT_OBJECTS - 1)
        {
            RtlMoveMemory(&m_Objects[dwIndex],
                        &m_Objects[dwIndex + 1],
                        sizeof(m_Objects[0]) * (m_dwObjectCount - dwIndex)
                        );
            RtlMoveMemory(&m_pWaiters[dwIndex],
                        &m_pWaiters[dwIndex + 1],
                        sizeof(m_pWaiters[0]) * (m_dwObjectCount - dwIndex)
                        );
            ++m_dwObjectCount;
        }

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));
    }

    //DWORD BuildList(VOID) {
    //
    //    //
    //    // PERF: only rebuild from changed index
    //    //
    //
    //    m_dwObjectCount = 0;
    //    for (CWait * pWait = (CWait *)m_WaitList.Next();
    //         pWait = pWait->Next();
    //         !m_WaitList.IsHead(pWait)) {
    //        m_pWaiters[m_dwObjectCount] = pWait;
    //        m_Objects[m_dwObjectCount] = pWait->GetHandle();
    //        ++m_dwObjectCount;
    //    }
    //    return GetWaitTime();
    //}

    DWORD Wait(DWORD dwTimeout = INFINITE) {

        //
        // if no objects in list, sleep alertably for the timeout period
        //

        if (m_dwObjectCount == 0) {
            SleepEx(dwTimeout, TRUE);
            return WAIT_IO_COMPLETION;
        }

        //
        // else wait alertably for the timeout period
        //

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        return WaitForMultipleObjectsEx(m_dwObjectCount,
                                        m_Objects,
                                        FALSE,  // fWaitAll
                                        dwTimeout,
                                        TRUE    // fAlertable
                                        );
    }

    DWORD GetWaitTime(VOID) {

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        if (m_dwObjectCount != 0) {

            CWait * pWaiter = m_pWaiters[0];
            DWORD dwWaitTime = pWaiter->GetWaitTime();

            if (dwWaitTime != INFINITE) {

                DWORD dwTimeNow = GetTickCount();
                DWORD dwTimeStamp = pWaiter->GetTimeStamp();

                if (dwTimeNow > dwTimeStamp + dwWaitTime) {

                    //
                    // first object expired already
                    //

                    return 0;
                }

                //
                // number of milliseconds until next waiter expires
                //

                return (dwTimeStamp + dwWaitTime) - dwTimeNow;
            }
        }

        //
        // nothing in list
        //

        return INFINITE;
    }

    CWait * GetFreeWaiter(VOID) {
        return (CWait *)m_FreeList.RemoveHead();
    }

    VOID InsertWaiter(CWait * pWait) {

        DWORD dwIndex = 0;
        BOOL bAtEnd = TRUE;
        CDoubleLinkedListEntry * pHead = m_WaitList.Head();

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        if ((m_dwObjectCount != 0) && !pWait->IsInfiniteTimeout()) {

            //
            // not infinite timeout. Find place in list to insert this object
            //

            //
            // PERF: typically, new wait will be longer than most currently in
            //       list, so should start from end of non-infinite timeouts
            //       and work backwards
            //

            for (; dwIndex < m_dwObjectCount; ++dwIndex) {
                if (pWait->ExpiryTime() < m_pWaiters[dwIndex]->ExpiryTime()) {
                    pHead = m_pWaiters[dwIndex]->Head();
                    bAtEnd = (dwIndex == (m_dwObjectCount - 1));
                    break;
                }
            }
        }

        //
        // insert the new wait object at the correct location
        //

        pWait->InsertTail(pHead);
        if (!bAtEnd && (m_dwObjectCount != 0)) {
            Expand(dwIndex);
        } else {
            dwIndex = m_dwObjectCount;
            ++m_dwObjectCount;
        }

        //
        // update object list and pointer list
        //

        m_Objects[dwIndex] = pWait->GetHandle();
        m_pWaiters[dwIndex] = pWait;
    }

    VOID RemoveWaiter(CWait * pWait, DWORD dwIndex) {

        //
        // remove the waiter from the wait list and add it back to the
        // free list
        //

        pWait->Remove();
        pWait->InsertTail(&m_FreeList);

        //
        // if the object was not at the end of the list then compress
        // the list
        //

        if (dwIndex != (m_dwObjectCount - 1)) {
            Compress(dwIndex, 1);
        } else {
            --m_dwObjectCount;
        }
    }

    VOID RemoveWaiter(DWORD dwIndex) {

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        RemoveWaiter(m_pWaiters[dwIndex], dwIndex);
    }

    BOOL RemoveWaiter(CWait * pWait) {

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        for (DWORD dwIndex = 0; dwIndex < m_dwObjectCount; ++dwIndex) {
            if (m_pWaiters[dwIndex] == pWait) {
                RemoveWaiter(pWait, dwIndex);
                return TRUE;
            }
        }
        return FALSE;
    }

    VOID ProcessTimeouts(VOID) {

        DWORD dwTimeNow = GetTickCount();
        DWORD dwCount = 0;

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        while (dwCount < m_dwObjectCount) {

            CWait * pWait = m_pWaiters[dwCount];

            //
            // if waiter has expired, invoke its callback then remove it from
            // the wait list and add back to the free list
            //

            if (pWait->IsTimedOut(dwTimeNow)) {
                pWait->Execute(TRUE);
                pWait->Remove();
                pWait->InsertTail(&m_FreeList);
                ++dwCount;
            } else {

                //
                // quit loop at first non-timed-out entry
                //

                break;
            }
        }

        ASSERT(dwCount != 0);

        if (dwCount != 0) {
            Compress(0, dwCount);
        }
    }

    VOID PurgeInvalidHandles(VOID) {

        DWORD dwCount = 0;
        DWORD dwIndex = 0;
        DWORD dwIndexStart = 0;

        ASSERT(m_dwObjectCount <= ARRAY_ELEMENTS(m_Objects));

        while (dwIndex < m_dwObjectCount) {

            CWait * pWait = m_pWaiters[dwIndex];

            //
            // if handle has become invalid, invoke the callback then remove it
            // from the wait list and add back to the free list
            //

            if (IsInvalidHandle(dwIndex)) {
                pWait->Execute(FALSE);
                pWait->Remove();
                pWait->InsertTail(&m_FreeList);
                if (dwIndexStart == 0) {
                    dwIndexStart = dwIndex;
                }
                ++dwCount;
            } else if (dwCount != 0) {
                Compress(dwIndexStart, dwCount);
                dwIndex = dwIndexStart - 1;
                dwIndexStart = 0;
                dwCount = 0;
            }
            ++dwIndex;
        }
        if (dwCount != 0) {
            Compress(dwIndexStart, dwCount);
        }
    }

    VOID ProcessCompletion(DWORD dwIndex) {

        CWait * pWait = m_pWaiters[dwIndex];

        pWait->Execute(FALSE);
        if (!pWait->IsNoRemoveItem()) {
            RemoveWaiter(dwIndex);
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\srca\makefile.inc ===
$(O)\patha.c: ..\path.c
    echo #undef UNICODE > $@
    echo #undef _UNICODE >> $@
    type $** >> $@

$(O)\nativea.cpp: ..\native.cpp
    echo #undef UNICODE > $@
    echo #undef _UNICODE >> $@
    type $** >> $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\srcw\makefile.inc ===
$(O)\pathw.c: ..\path.c
    echo // This file expects to be compiled UNICODE > $@
    type $** >> $@

$(O)\nativew.cpp: ..\native.cpp
    echo // This file expects to be compiled UNICODE > $@
    type $** >> $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shlwapi\util.cpp ===
#include "priv.h"
#include <shlobj.h>
#include <shellp.h>
#include <ieguidp.h>
#include "ids.h"
#include <objbase.h>
#include <trayp.h>
#include <shdocvw.h>
#include <mshtmhst.h>
#include <shsemip.h>
#include <winnetp.h>
#include <inetreg.h>
#include <shguidp.h>
#include <shlguid.h>            // Defines: CLSID_ACLMRU
#include <htmlhelp.h>
#include <mluisupp.h>
#include <initguid.h>
#include <shimgdata.h>
#include <varutil.h>
#include <memt.h>

#define REGSTR_PATH_MESSAGEBOXCHECKA "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DontShowMeThisDialogAgain"
#define REGSTR_PATH_MESSAGEBOXCHECKW L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DontShowMeThisDialogAgain"


//  Raw accelerator table
typedef struct
{
    int     cEntries;
    ACCEL   rgacc[0];
} CA_ACCEL;


STDAPI_(HANDLE) SHLoadRawAccelerators(HINSTANCE hInst, LPCTSTR lpTableName)
{
    CA_ACCEL *pca = NULL;
    HACCEL hAcc = LoadAccelerators(hInst, lpTableName);    //  Load the accelerator resource
    if (hAcc)
    {
        //  Retrieve the number of entries
        int cEntries = CopyAcceleratorTable(hAcc, NULL, 0);
        if (cEntries > 0)
        {
            //  Allocate a counted array and copy the elements
            pca = (CA_ACCEL*)LocalAlloc(LPTR, sizeof(CA_ACCEL) + cEntries * sizeof(ACCEL));
            if (pca)
            {
                pca->cEntries = cEntries;
                if (cEntries != CopyAcceleratorTable(hAcc, pca->rgacc, cEntries))
                {
                    LocalFree(pca);
                    pca = NULL;
                }
            }
        }
        DestroyAcceleratorTable(hAcc);
    }
    
    return pca;
}

STDAPI_(BOOL) SHQueryRawAccelerator(HANDLE hcaAcc, IN BYTE fVirtMask, IN BYTE fVirt, IN WPARAM wKey, OUT OPTIONAL UINT* puCmdID)
{
    ASSERT(hcaAcc);
    CA_ACCEL* pca = (CA_ACCEL*)hcaAcc;
    
    if (puCmdID)
        *puCmdID = 0;

    for(int i = 0; i < pca->cEntries; i++)
    {
        if (fVirt == (pca->rgacc[i].fVirt & fVirtMask) && wKey == pca->rgacc[i].key)
        {
            if (puCmdID)
                *puCmdID = pca->rgacc[i].cmd;
            return TRUE;
        }
    }
    return FALSE;
}

STDAPI_(BOOL) SHQueryRawAcceleratorMsg(HANDLE hcaAcc, MSG* pmsg, OUT OPTIONAL UINT* puCmdID)
{
    if (WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)
    {
        #define TESTKEYSTATE(vk)   ((GetKeyState(vk) & 0x8000)!=0)

        BYTE fVirt = FVIRTKEY;
    
        if (TESTKEYSTATE(VK_CONTROL))
            fVirt |= FCONTROL;
        else if (TESTKEYSTATE(VK_SHIFT))
            fVirt |= FSHIFT;
        else if (TESTKEYSTATE(VK_MENU))
            fVirt |= FALT;

        return SHQueryRawAccelerator(hcaAcc, fVirt, fVirt, pmsg->wParam, puCmdID);
    }
    return FALSE;
}

STDAPI SHSetThreadRef(IUnknown *punk)
{
#ifdef DEBUG
    IUnknown* tmp;
    tmp = (IUnknown*)TlsGetValue(g_tlsThreadRef);
    ASSERT(NULL==tmp || NULL==punk);
#endif

    return TlsSetValue(g_tlsThreadRef, punk) ? S_OK : E_FAIL;
}

STDAPI SHGetThreadRef(IUnknown **ppunk)
{
    *ppunk = (IUnknown *)TlsGetValue(g_tlsThreadRef);
    if (*ppunk)
    {
        (*ppunk)->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDAPI SHSetOtherThreadsRef(IUnknown *punk)
{
#ifdef DEBUG
    IUnknown* tmp;
    tmp = (IUnknown*)TlsGetValue(g_tlsOtherThreadsRef);
    ASSERT(NULL==tmp || NULL==punk);
#endif

    return TlsSetValue(g_tlsOtherThreadsRef, punk) ? S_OK : E_FAIL;
}

// release a CTF_THREAD_REF reference earlier than the return of pfnThreadProc
STDAPI SHReleaseThreadRef()
{
    IUnknown* punk;
    punk = (IUnknown *)TlsGetValue(g_tlsOtherThreadsRef);
    if (punk)
    {
        TlsSetValue(g_tlsOtherThreadsRef, NULL);
        punk->Release();
        return S_OK;
    }

    RIPMSG(FALSE, "Why is caller SHRealeaseThreadRef()ing when they don't have a thread ref?");
    return S_FALSE;
}

// thread reference count object, this uses SHSetThreadRef()to let other code
// in this process hold a reference to this main thread, and thus the main thread in this process

class CRefThread : public IUnknown
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    CRefThread(LONG *pcRef);

private:
    ~CRefThread();

    LONG *_pcRef;
    UINT _idThread;
};


CRefThread::CRefThread(LONG *pcRef) 
{
    _idThread = GetCurrentThreadId();
    _pcRef = pcRef;
    *_pcRef = 1;

}

//
//  Note that this code tightens but does not close a race window.
//  Although we nuke the process reference, the class factory for
//  the web browser has yet to be deregistered, so if somebody decides
//  to create one, our class factory will wake up and create a
//  shell folder, which will flake out because it can't get a
//  process reference.
//
CRefThread::~CRefThread() 
{
    *_pcRef = 0;

    // get the other thread out of WaitMessage() or GetMessage()
    PostThreadMessage(_idThread, WM_NULL, 0, 0);
}


HRESULT CRefThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { { 0 }, };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CRefThread::AddRef()
{
    return InterlockedIncrement(_pcRef);
}

ULONG CRefThread::Release()
{
    ASSERT( 0 != *_pcRef );
    ULONG cRef = InterlockedDecrement(_pcRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI _CreateThreadRef(LONG *pcRef, IUnknown **ppunk)
{
    *ppunk = new CRefThread(pcRef);
    if (*ppunk)
        return S_OK;

    *pcRef = 0;
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

// call if you want to kick off an independant thread.. you don't want handles back, or ids
// and if the create fails, call synchronously

typedef struct
{
    LPTHREAD_START_ROUTINE pfnMain;
    LPTHREAD_START_ROUTINE pfnSync;
    HANDLE hSync;
    void *pvData;
    DWORD dwFlags;
    IUnknown *punkThreadRef;
    IUnknown *punkProcessRef;
    HMODULE hmodFree;
    HRESULT hrThreadStart;
} PRIVCREATETHREADDATA;

DWORD CALLBACK WrapperThreadProc(void *pv)
{
    // make a copy of the input buffer, this is sitting on the calling threads stack
    // once we signal him his copy will be invalid
    PRIVCREATETHREADDATA rgCreate = *((PRIVCREATETHREADDATA *)pv);
    HRESULT hrInit;
    LONG cThreadRef;
    IUnknown *punkThreadRef;
    DWORD dwRes = 0;
    
    if (rgCreate.dwFlags & CTF_REF_COUNTED)
    {
        rgCreate.hrThreadStart = _CreateThreadRef(&cThreadRef, &punkThreadRef);
        if (SUCCEEDED(rgCreate.hrThreadStart))
            rgCreate.hrThreadStart = SHSetThreadRef(punkThreadRef);
    }

    if (SUCCEEDED(rgCreate.hrThreadStart) && rgCreate.punkThreadRef)
    {
        rgCreate.hrThreadStart = SHSetOtherThreadsRef(rgCreate.punkThreadRef); // hand punkThreadRef off to our tls value
    }

    if (SUCCEEDED(rgCreate.hrThreadStart))
    {
        if (rgCreate.dwFlags & CTF_COINIT)
            hrInit = SHCoInitialize();

        // call the synchronous ThreadProc while the other thread is waiting on hSync
        if (rgCreate.pfnSync)
            rgCreate.pfnSync(rgCreate.pvData);
    }

    // poke our return value back before releasing the main thread
    ((PRIVCREATETHREADDATA *)pv)->hrThreadStart = rgCreate.hrThreadStart;

    SetEvent(rgCreate.hSync);   // release the main thread..

    if (SUCCEEDED(rgCreate.hrThreadStart))
    {
        // call the main thread proc
        dwRes = rgCreate.pfnMain(rgCreate.pvData);

        if ((rgCreate.dwFlags & CTF_REF_COUNTED) && punkThreadRef)
        {
            MSG msg;
            //  release our ref on ourselves.
            //  then pump until everyone else 
            //  has finished using our thread.
            //  this is important for COM objects
            //  that were created on this thread 
            //  but are being used by another thread
            punkThreadRef->Release();
            while (cThreadRef)
            {
                if (GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (rgCreate.punkThreadRef)
        {
            // If pfnMain hasn't released the thread reference yet, do it ourselves
            IUnknown* tmp;
            tmp = (IUnknown*)TlsGetValue(g_tlsOtherThreadsRef);
            if (tmp)
                SHReleaseThreadRef();
        }

        if (rgCreate.punkProcessRef)
            rgCreate.punkProcessRef->Release();

        if (rgCreate.dwFlags & CTF_COINIT)
            SHCoUninitialize(hrInit);

        if (rgCreate.hmodFree)
            FreeLibraryAndExitThread(rgCreate.hmodFree, dwRes);
    }
    
    return dwRes;
}


// Call if you want to kick off an independent thread and
// you don't care about the handle or thread ID.
//
// If the create fails, call synchronously.
//
// optionally call a secondary callback when the thread
// is created.
// returns: 
//      TRUE if pfnThreadProc was executed

STDAPI_(BOOL) SHCreateThread(
    LPTHREAD_START_ROUTINE pfnThreadProc,
    void *pvData,
    DWORD dwFlags,                          // CTF_*
    LPTHREAD_START_ROUTINE pfnCallback)     OPTIONAL
{
    BOOL bRet = FALSE;
    PRIVCREATETHREADDATA rgCreate = {0};  // can be on the stack since we sync the thread

    if ((dwFlags & CTF_INSIST) && pfnCallback)
    {
        ASSERTMSG(FALSE, "SHCreateThread: cannot specify CTF_INSIST and pfnCallback at the same time");
        return FALSE;
    }

    if (CTF_THREAD_REF & dwFlags)
    {
        if (FAILED(SHGetThreadRef(&rgCreate.punkThreadRef)))
        {
            TraceMsg(TF_WARNING, "SHCreateThread is failing since caller requested CTF_THREAD_REF but does not support thread references.");

            // The calling code is requesting a thread-ref, but the thread doesn't support it.
            // Whatever requires this thread-ref will break, so we must return FALSE here (and
            // let the caller work around it).
            return FALSE;
        }
    }

    if (CTF_PROCESS_REF & dwFlags)
    {
        SHGetInstanceExplorer(&rgCreate.punkProcessRef);
    }

    if (CTF_FREELIBANDEXIT & dwFlags)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery(pfnThreadProc, &mbi, sizeof(mbi)))
        {
            TCHAR szModule[MAX_PATH];
            if (GetModuleFileName((HMODULE)mbi.AllocationBase, szModule, ARRAYSIZE(szModule)))
            {
                rgCreate.hmodFree = LoadLibrary(szModule);
            }
        }
    }

    rgCreate.pfnMain = pfnThreadProc;
    rgCreate.pfnSync = pfnCallback;
    rgCreate.pvData = pvData;
    rgCreate.dwFlags = dwFlags;
    rgCreate.hSync = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (rgCreate.hSync)
    {
        DWORD idThread;
        HANDLE hThread = CreateThread(NULL, 0, WrapperThreadProc, &rgCreate, 0, &idThread);
        if (hThread)
        {
            // Some pfnCallback procs need to do SendMessage to the calling thread, others
            // want to do COM.  This COM thing is new, so reduce the risk of breaking things
            // by making it by-request only
            if (CTF_WAIT_ALLOWCOM & dwFlags)
                SHWaitForCOMSendMessageThread(rgCreate.hSync, INFINITE);
            else
                SHWaitForSendMessageThread(rgCreate.hSync, INFINITE);
            CloseHandle(hThread);

            // If the WrapperThreadProc failed to initialize itself, pretend we failed to create the thread
            bRet = SUCCEEDED(rgCreate.hrThreadStart);
        }
        CloseHandle(rgCreate.hSync);
    }

    if (!bRet)
    {
        if (rgCreate.punkThreadRef)
        {
            rgCreate.punkThreadRef->Release();
        }

        if (rgCreate.punkProcessRef)
        {
            rgCreate.punkProcessRef->Release();
        }

        if (rgCreate.hmodFree)
            FreeLibrary(rgCreate.hmodFree);

        if (dwFlags & CTF_INSIST)
        {
            // failed to create another thread... call synchronously
            pfnThreadProc(pvData);
            bRet = TRUE;
        }
    }

    return bRet;
}



STDAPI_(BOOL) SHIsLowMemoryMachine(DWORD dwType)
// Are we an 8 meg Win95 machine or 16 meg NT machine.
// Back in the old days...
{
    static int fLowMem = -1;

    if (ILMM_IE4 == dwType && fLowMem == -1)
    {
        MEMORYSTATUS ms;
        GlobalMemoryStatus(&ms);
        fLowMem = (ms.dwTotalPhys <= 16*1024*1024);
    }

    return fLowMem;
}

// SHTruncateString
//
// purpose: cut a string at the given length in dbcs safe manner.
//          the string may be truncated at cch-2 if the sz[cch] points
//          to a lead byte that would result in cutting in the middle
//          of double byte character.
//
// The character at sz[cchBufferSize-1] is not consulted, so you
// can call this after lstrcpyn (which forces sz[cchBufferSize-1]=0).
//
// If the source string is shorter than cchBufferSize-1 characters,
// we fiddle some bytes that have no effect, in which case the return
// value is random.
//
// update: made it faster for sbcs environment (5/26/97)
//         now returns adjusted cch            (6/20/97)
//
STDAPI_(int) SHTruncateString(CHAR *sz, int cchBufferSize)
{
    if (!sz || cchBufferSize <= 0) return 0;

    int cch = cchBufferSize - 1; // get index position to NULL out

    LPSTR psz = &sz[cch];

    while (psz >sz)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // Found non-leadbyte for the first time.
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or &sz[cch]
            psz++;
            break;
        }
    }
    if (((&sz[cch] - psz) & 1) && cch > 0)
    {
        // we're truncating the string in the middle of dbcs
        cch--;
    }
    sz[cch] = '\0';
    return cch;
}


//
//  Why do we use the unsafe version?
//
//  -   Unsafe is much faster.
//
//  -   The safe version isn't safe after all and serves only to mask
//      existing bugs.  The situation the safe version "saves" is if
//      two threads both try to atomicrelease the same object.  This
//      means that at the same moment, both threads think the object
//      is alive.  Change the timing slightly, and now one thread
//      atomicreleases the object before the other one, so the other
//      thread is now using an object after the first thread already
//      atomicreleased it.  Bug.
//
STDAPI_(void) IUnknown_AtomicRelease(void **ppunk)
{
#if 1 // Unsafe
    if (ppunk && *ppunk) 
    {
        IUnknown* punk = *(IUnknown**)ppunk;
        *ppunk = NULL;
        punk->Release();
    }
#else // Safe
    if (ppunk) 
    {
        IUnknown* punk = (IUnknown *)InterlockedExchangePointer(ppunk, NULL);
        if (punk) 
        {
            punk->Release();
        }
    }
#endif
}


STDAPI ConnectToConnectionPoint(IUnknown* punk, REFIID riidEvent, BOOL fConnect, IUnknown* punkTarget, DWORD* pdwCookie, IConnectionPoint** ppcpOut)
{
    // We always need punkTarget, we only need punk on connect
    if (!punkTarget || (fConnect && !punk))
        return E_FAIL;

    if (ppcpOut)
        *ppcpOut = NULL;

    IConnectionPointContainer *pcpc;
    HRESULT hr = punkTarget->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpc));
    if (SUCCEEDED(hr))
    {
        IConnectionPoint *pcp;
        hr = pcpc->FindConnectionPoint(riidEvent, &pcp);
        if (SUCCEEDED(hr))
        {
            if (fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punk, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
        }
        pcpc->Release();
    }
    return hr;
}

STDAPI IUnknown_QueryStatus(IUnknown *punk, const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = E_FAIL;
    if (punk) 
    {
        IOleCommandTarget* pct;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct));
        if (pct) 
        {
            hr = pct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
            pct->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_Exec(IUnknown* punk, const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = E_FAIL;
    if (punk) 
    {
        IOleCommandTarget* pct;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct));
        if (SUCCEEDED(hr)) 
        {
            hr = pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            pct->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_TranslateAcceleratorIO(IUnknown* punk, LPMSG lpMsg)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObject *pio;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObject, &pio));
        if (SUCCEEDED(hr))
        {
            hr = pio->TranslateAcceleratorIO(lpMsg);
            pio->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_UIActivateIO(IUnknown *punk, BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObject *pio;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObject, &pio));
        if (SUCCEEDED(hr))
        {
            hr = pio->UIActivateIO(fActivate, lpMsg);
            pio->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_OnFocusChangeIS(IUnknown *punk, IUnknown *punkSrc, BOOL fSetFocus)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObjectSite *pis;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObjectSite, &pis));
        if (SUCCEEDED(hr))
        {
            hr = pis->OnFocusChangeIS(punkSrc, fSetFocus);
            pis->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_HasFocusIO(IUnknown *punk)
{
    HRESULT hr = E_FAIL;

    if (punk != NULL)
    {
        IInputObject *pio;

        hr = punk->QueryInterface(IID_PPV_ARG(IInputObject, &pio));
        if (SUCCEEDED(hr))
        {
            hr = pio->HasFocusIO();
            pio->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_DoContextMenuPopup(IUnknown *punkSite, IContextMenu* pcm, UINT fFlags, POINT pt)
{
    IContextMenuSite* pcms;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SContextMenuSite, IID_PPV_ARG(IContextMenuSite, &pcms));
    if (SUCCEEDED(hr))
    {
        hr = pcms->DoContextMenuPopup(pcm, fFlags, pt);
        pcms->Release();
    }
    else
    {
#if 0 // REVIEW: do we want fall-back code?
        HWND hwnd;
        hr = IUnknown_GetWindow(punkSite, &hwnd);
        if (SUCCEEDED(hr))
        {
            HMENU hmenu = CreatePopupMenu();
            if (hmenu)
            {
                IShellBrowser* psb;
                if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
                {
                    HWND hwnd;
                    if (SUCCEEDED(psb->GetControlWindow(FCW_TREE, &hwnd)) && hwnd)
                    {
                        fFlags |= CMF_EXPLORE;
                    }
                    psb->Release();
                }

                if (GetKeyState(VK_SHIFT) < 0)
                {
                    fFlags |= CMF_EXTENDEDVERBS;
                }

                hr = pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fFlags);
                if (SUCCEEDED(hr))
                {
                    int idCmd = TrackPopupMenuEx(hmenu,
                                                 TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                                 pt.x,
                                                 pt.y,
                                                 hwnd,
                                                 NULL);

                    if (0 != idCmd)
                    {
                        idCmd -= CONTEXTMENU_IDCMD_FIRST;

                        CMINVOKECOMMANDINFOEX ici = {0};
                        ici.cbSize = sizeof(ici);
                        ici.fMask  = CMIC_MASK_ASYNCOK | CMIC_MASK_PTINVOKE;
                        ici.hwnd = hwnd;
                        ici.lpVerb = (LPCSTR)IntToPtr(idCmd);
                        ici.nShow = SW_SHOWDEFAULT;
                        ici.lpVerbW = (LPCWSTR)IntToPtr(idCmd);
                        ici.pt.x = pt.x;
                        ici.pt.y = pt.y;

                        if (GetKeyState(VK_SHIFT) < 0)
                            ici.fMask |= CMIC_MASK_SHIFT_DOWN;

                        if (GetKeyState(VK_CONTROL) < 0)
                            ici.fMask |= CMIC_MASK_CONTROL_DOWN;

                        hr = pcm->InvokeCommand(reinterpret_cast<LPCMINVOKECOMMANDINFO>(&ici));
                    }
                    else
                    {
                        hr = ERROR_CANCELLED;
                    }
                }
                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
#endif
    }
    return hr;
}


STDAPI_(DWORD) SHSetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle = GetWindowLong(hWnd, iWhich);
    DWORD dwNewStyle = (dwStyle & ~dwBits) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) 
    {
        SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
    return dwStyle;
}


// OpenRegStream API in SHELL32 returns an emtpy
// stream if we ask for read-only, if the entry does not exist.
// we need to detect that case.
//
const LARGE_INTEGER c_li0 = { 0, 0 };

STDAPI_(BOOL) SHIsEmptyStream(IStream* pstm)
{
#ifdef DEBUG
    // We always call this function when we open a new stream,
    // so we should always be at the beginning of the stream.
    //
    // We need this assert for the <NT5 shell case.
    //
    ULARGE_INTEGER liStart;
    pstm->Seek(c_li0, STREAM_SEEK_CUR, &liStart);
    ASSERT(0==liStart.HighPart && 0==liStart.LowPart);
#endif

    STATSTG st;
    if (SUCCEEDED(pstm->Stat(&st, STATFLAG_NONAME)))
    {
        if (st.cbSize.LowPart || st.cbSize.HighPart)
            return FALSE;
    }
    else
    {
        // Win95 IStream code did not implement stat, so check
        // emptiness by trying to read.
        //
        int iTmp;
        if (SUCCEEDED(IStream_Read(pstm, &iTmp, sizeof(iTmp))))
        {
            // The stream is indeed present, seek back to start
            //
            pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);

            return FALSE; // not empty
        }
    }

    return TRUE;
}


STDAPI_(void) SHSetParentHwnd(HWND hwnd, HWND hwndParent)
{
    HWND hwndOldParent = GetParent(hwnd);

    if (hwndParent != hwndOldParent)
    {
        //
        // Get the child flag correct!  If we don't do this and
        // somebody calls DialogBox on us while we are parented to NULL
        // and WS_CHILD, the desktop will be disabled, thereby causing
        // all mouse hit-testing to fail systemwide.
        // we also want to do this in the right order so the window
        // manager does the correct attachthreadinput if required...
        //

        if (hwndParent)
            SHSetWindowBits(hwnd, GWL_STYLE, WS_CHILD | WS_POPUP, WS_CHILD);

        SetParent(hwnd, hwndParent);

        if (!hwndParent)
            SHSetWindowBits(hwnd, GWL_STYLE, WS_CHILD | WS_POPUP, WS_POPUP);

        //
        // (jbeda) USER32 doesn't mirror the UIS bits correctly when windows
        //         are reparented.  They (mcostea) say that it would cause
        //         compat problems.  So to work around this, when
        //         we reparent, we grab the bits on the parent window
        //         and mirror them to the child.
        //
        {
            LRESULT lUIState;

            lUIState = SendMessage(hwndParent, WM_QUERYUISTATE, 0, 0);

            if (lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL))
            {
                SendMessage(hwnd, WM_UPDATEUISTATE,
                             MAKEWPARAM(UIS_SET, 
                               lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL)), 0);
            }

            if (~lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL))
            {
                SendMessage(hwnd, WM_UPDATEUISTATE,
                             MAKEWPARAM(UIS_CLEAR, 
                               ~lUIState & (UISF_HIDEFOCUS | UISF_HIDEACCEL)), 0);
            }
        }

    }
}


// IsSameObject checks for OLE object identity.
//
STDAPI_(BOOL) SHIsSameObject(IUnknown* punk1, IUnknown* punk2)
{
    if (!punk1 || !punk2)
    {
        return FALSE;
    }
    else if (punk1 == punk2)
    {
        // Quick shortcut -- if they're the same pointer
        // already then they must be the same object
        //
        return TRUE;
    }
    else
    {
        IUnknown* punkI1;
        IUnknown* punkI2;

        // Some apps don't implement QueryInterface! (SecureFile)
        HRESULT hr = punk1->QueryInterface(IID_PPV_ARG(IUnknown, &punkI1));
        if (SUCCEEDED(hr))
        {
            punkI1->Release();
            hr = punk2->QueryInterface(IID_PPV_ARG(IUnknown, &punkI2));
            if (SUCCEEDED(hr))
                punkI2->Release();
        }
        return SUCCEEDED(hr) && (punkI1 == punkI2);
    }
}

// pass the CLSID of the object you are about to bind to. this queries 
// the bind context to see if that guy should be avoided 
// this would be a good shlwapi service. 

STDAPI_(BOOL) SHSkipJunction(IBindCtx *pbc, const CLSID *pclsid) 
{ 
    IUnknown *punk; 
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_SKIP_BINDING_CLSID, &punk))) 
    { 
        CLSID clsid; 
        BOOL bSkip = SUCCEEDED(IUnknown_GetClassID(punk, &clsid)) && IsEqualCLSID(clsid, *pclsid); 
        punk->Release(); 
        return bSkip; 
    } 
    return FALSE; 
} 

STDAPI IUnknown_GetWindow(IUnknown* punk, HWND* phwnd)
{
    HRESULT hr = E_FAIL;
    *phwnd = NULL;

    if (punk) 
    {
        IOleWindow* pow;
        IInternetSecurityMgrSite* pisms;
        IShellView* psv;

        // How many ways are there to get a window?  Let me count the ways...
        hr = punk->QueryInterface(IID_PPV_ARG(IOleWindow, &pow));
        if (SUCCEEDED(hr))
        {
            hr = pow->GetWindow(phwnd);
            pow->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IInternetSecurityMgrSite, &pisms))))
        {
            hr = pisms->GetWindow(phwnd);
            pisms->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
        {
            hr = psv->GetWindow(phwnd);
            psv->Release();
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION:   IUnknown_EnableModless

    DESCRIPTION:
        Several interfaces implement the ::EnableModeless() or equivalent methods.
    This requires us to use a utility function to query the punk until one is
    implemented and then use it.
\*****************************************************************************/
HRESULT IUnknown_EnableModeless(IUnknown * punk, BOOL fEnabled)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IOleInPlaceActiveObject * poipao;
        IInternetSecurityMgrSite * pisms;
        IOleInPlaceFrame * poipf;
        IShellBrowser * psb;
        IDocHostUIHandler * pdhuh;

        // How many ways are there to enable modless?  Let me count the ways...
        hr = punk->QueryInterface(IID_PPV_ARG(IOleInPlaceActiveObject, &poipao));
        if (SUCCEEDED(hr))
        {
            hr = poipao->EnableModeless(fEnabled);
            poipao->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IInternetSecurityMgrSite, &pisms))))
        {
            hr = pisms->EnableModeless(fEnabled);
            pisms->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IOleInPlaceFrame, &poipf))))
        {
            hr = poipf->EnableModeless(fEnabled);
            poipf->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb))))
        {
            hr = psb->EnableModelessSB(fEnabled);
            psb->Release();
        }
        else if (SUCCEEDED(hr = punk->QueryInterface(IID_PPV_ARG(IDocHostUIHandler, &pdhuh))))
        {
            hr = pdhuh->EnableModeless(fEnabled);
            pdhuh->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_SetOwner(IUnknown* punk, IUnknown* punkOwner)
{
    HRESULT hr = E_FAIL;
    if (punk) 
    {
        IShellService* pss;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellService, &pss));
        if (SUCCEEDED(hr)) 
        {
            pss->SetOwner(punkOwner);
            pss->Release();
        }
    }
    return hr;
}

STDAPI IUnknown_SetSite(IUnknown *punk, IUnknown *punkSite)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IObjectWithSite *pows;

        hr = punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
        if (SUCCEEDED(hr))
        {
            hr = pows->SetSite(punkSite);
            ASSERT(SUCCEEDED(hr));
            pows->Release();
        }
        else
        {
            IInternetSecurityManager * pism;

            // The security guys should have used IObjectWithSite, but no....
            hr = punk->QueryInterface(IID_PPV_ARG(IInternetSecurityManager, &pism));
            if (SUCCEEDED(hr))
            {
                hr = pism->SetSecuritySite((IInternetSecurityMgrSite *) punkSite);
                ASSERT(SUCCEEDED(hr));
                pism->Release();
            }
        }
    }
    return hr;
}

STDAPI IUnknown_GetSite(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    *ppv = NULL;
    if (punk) 
    {
        IObjectWithSite *pows;
        hr = punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
        ASSERT(SUCCEEDED(hr) || pows == NULL);  // paranoia
        if (SUCCEEDED(hr)) 
        {
            hr = pows->GetSite(riid, ppv);
            // Note: The GetSite can legitimately fail if there is no site
            // or the site doesn't support the requested interface.
            ASSERT(SUCCEEDED(hr) || *ppv == NULL);
            pows->Release();
        }
    }
    return hr;
}

//
//      GetUIVersion()
//
//  returns the version of shell32
//  3 == win95 gold / NT4
//  4 == IE4 Integ / win98
//  5 == win2k
//  6 == Whistler
//
STDAPI_(UINT) GetUIVersion()
{
    static UINT s_uiShell32 = 0;
    if (s_uiShell32 == 0)
    {
        HINSTANCE hinst = GetModuleHandle(TEXT("SHELL32.DLL"));
        if (hinst)
        {
            DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnGetVersion && pfnGetVersion(&dllinfo) == NOERROR)
                s_uiShell32 = dllinfo.dwMajorVersion;
            else
                s_uiShell32 = 3;
        }
    }
    return s_uiShell32;
}



//***   IUnknown_GetClassID -- do punk->IPS::GetClassID
STDAPI IUnknown_GetClassID(IUnknown *punk, CLSID *pclsid)
{
    HRESULT hr = E_FAIL;

    ASSERT(punk);   // currently nobody does
    if (punk)
    {
        IPersist *p;
        hr = punk->QueryInterface(IID_PPV_ARG(IPersist, &p));

        //  sometimes we can do this since they dont answer the
        //  the QI for IPersist.  but we cant do it on NT4 plain
        //  since the net hood faults if the psf is just a \\server
        if (FAILED(hr))
        {
            //  used to do a try/except here for bad implementations
            IPersistFolder *pf;
            hr = punk->QueryInterface(IID_PPV_ARG(IPersistFolder, &pf));
            p = pf;
        }

        if (SUCCEEDED(hr))
        {
            hr = p->GetClassID(pclsid);
            p->Release();
        }

    }
    
    return hr;
}


STDAPI IUnknown_QueryService(IUnknown* punk, REFGUID guidService, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IServiceProvider *psp;
        hr = punk->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp));
        ASSERT(SUCCEEDED(hr) ? psp != NULL : psp == NULL);  // COM rules
        if (SUCCEEDED(hr))
        {
            hr = psp->QueryService(guidService, riid, ppvOut);
            psp->Release();
        }
    }

    return hr;
}

STDAPI IUnknown_QueryServiceForWebBrowserApp(IUnknown* punk, REFIID riid, void **ppvOut)
{
    IServiceProvider* psp;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_IServiceProvider, (LPVOID*)&psp);
    if (SUCCEEDED(hr))
    {
        hr = psp->QueryService(SID_SWebBrowserApp, riid, ppvOut);
        psp->Release();
    }
    else
        *ppvOut = NULL;

    return hr;
}

STDAPI IUnknown_ShowBrowserBar(IUnknown* punk, REFCLSID clsidBrowserBar, BOOL fShow)
{
    IWebBrowser2* pwb2;
    HRESULT hr = IUnknown_QueryServiceForWebBrowserApp(punk, IID_PPV_ARG(IWebBrowser2, &pwb2));
    if (SUCCEEDED(hr))
    {
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, clsidBrowserBar);

        VARIANT varClsid;
        V_VT(&varClsid)   = VT_BSTR;
        V_BSTR(&varClsid) = strClsid.wsz;

        VARIANT varShow;
        V_VT(&varShow)    = VT_BOOL;
        V_BOOL(&varShow)  = (fShow) ? VARIANT_TRUE : VARIANT_FALSE;

        VARIANT varEmpty = {0};

        hr = pwb2->ShowBrowserBar(&varClsid, &varShow, &varEmpty);

        pwb2->Release();
    }

    return hr;
}



#if defined(DEBUG) && 0 // defined(NOTYET)
//
// IUnknown_IsCanonical checks if the interface is the canonical IUnknown
// for the object.
//
//  S_OK    = yes it is
//  S_FALSE = no it isn't
//  error   = IUnknown implementation is buggy.
//
//  If you get an error back, it means that the IUnknown is incorrectly
//  implemented, and you probably should avoid doing anything with it.
//
STDAPI_(HRESULT) IUnknown_IsCanonical(IUnknown *punk)
{
    IUnknown *punkT;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IUnknown, &punkT));
    if (EVAL(SUCCEEDED(hr))) 
    {
        punkT->Release();
        if (punk == punkT) 
        {
            hr = S_OK;
        }
        else 
        {
            hr = S_FALSE;
        }
    }
    return hr;
}
#endif

//
//  QueryInterface that doesn't affect the refcount.  Use this when doing
//  funny aggregation games.
//
//  In order for this QI/Release trick to work, the punkOuter must be the
//  canonical IUnknown for the outer object.  It is the caller's
//  responsibility to ensure this.
//
//  punkOuter  - The controlling unknown (must be canonical)
//  punkTarget - The thing that receives the QI (must be controlled
//               by punkOuter)
//  riid       - The interface to get
//  ppvOut     - Where to put the result
//
//  On success, the interface is obtained from the punkTarget, and the
//  refcount generated by the QI is removed from the punkOuter.
//
//  If either punkOuter or punkTarget is NULL, we vacuously fail with
//  E_NOINTERFACE.
//
//  When querying from an outer to an inner, punkOuter is the outer, and
//  punkTarget is the inner.
//
//  When querying from an inner to an outer, punkOuter and punkTarget are
//  both the outer.
//
STDAPI SHWeakQueryInterface(IUnknown *punkOuter, IUnknown *punkTarget, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    if (punkOuter && punkTarget) 
    {
#if defined(DEBUG) && 0 // defined(NOTYET)
        // RaymondC hasn't yet fixed all our aggregatable classes, so this
        // assertion fires too often
        ASSERT(IUnknown_IsCanonical(punkOuter));
#endif
        hres = punkTarget->QueryInterface(riid, ppvOut);
        if (SUCCEEDED(hres)) 
        {
            punkOuter->Release();
            hres = S_OK;
        }
        else 
        {
            // Double-check that QI isn't buggy.
            ASSERT(*ppvOut == NULL);
        }

    }
    else 
    {
        hres = E_NOINTERFACE;
    }

    if (FAILED(hres)) 
    {
        *ppvOut = NULL;
    }

    return hres;
}

//
//  Release an interface that was obtained via SHWeakQueryInterface.
//
//  punkOuter - The controlling unknown
//  ppunk     - The IUnknown to release
//
STDAPI_(void) SHWeakReleaseInterface(IUnknown *punkOuter, IUnknown **ppunk)
{
    if (*ppunk) 
    {
        ASSERT(IS_VALID_CODE_PTR(punkOuter, IUnknown));
        punkOuter->AddRef();
        IUnknown_AtomicRelease((void **)ppunk);
    }
}

HRESULT IUnknown_SetOptions(IUnknown * punk, DWORD dwACLOptions)
{
    IACList2 * pal2;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IACList2, &pal2));
    if (SUCCEEDED(hr))
    {
        hr = pal2->SetOptions(dwACLOptions);
        pal2->Release();
    }

    return hr;
}

#define SZ_REGKEY_TYPEDCMDMRU       L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"
#define SZ_REGKEY_TYPEDURLMRU       L"Software\\Microsoft\\Internet Explorer\\TypedURLs"

HRESULT InitializeAndAddACLMRU(IObjMgr *pmulti, LPCWSTR pszRegKey)
{
    IUnknown *punk;

    HRESULT hr = CoCreateInstance(CLSID_ACLCustomMRU, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        IACLCustomMRU *pmru;
        
        hr = punk->QueryInterface(IID_PPV_ARG(IACLCustomMRU, &pmru));
        if (SUCCEEDED(hr))
        {
            hr = pmru->Initialize(pszRegKey, 26);
            if (SUCCEEDED(hr))
            {
                pmulti->Append(punk);
            }
            pmru->Release();
        }
        punk->Release();
    }

    return hr;
}

IUnknown * ACGetLists(DWORD dwFlags, DWORD dwACLOptions)
{
    IUnknown * punkACLMulti = NULL;
    HRESULT hr = CoCreateInstance(CLSID_ACLMulti, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkACLMulti));

    AssertMsg((CO_E_NOTINITIALIZED != hr), TEXT("SHAutoComplete() can not use AutoComplete because OleInitialize() was never called."));
    if (SUCCEEDED(hr))
    {
        IObjMgr * pomMulti;

        hr = punkACLMulti->QueryInterface(IID_PPV_ARG(IObjMgr, &pomMulti));
        if (SUCCEEDED(hr))
        {
            if (dwFlags & SHACF_URLMRU)
            {
                // ADD The MRU List-- add both URL and run dialog MRU
                hr = InitializeAndAddACLMRU(pomMulti, SZ_REGKEY_TYPEDCMDMRU);
                if (SUCCEEDED(hr))
                    hr = InitializeAndAddACLMRU(pomMulti, SZ_REGKEY_TYPEDURLMRU);
            }

            if (dwFlags & SHACF_URLHISTORY)
            {
                // ADD The History List
                IUnknown * punkACLHist;
                hr = CoCreateInstance(CLSID_ACLHistory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkACLHist));
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punkACLHist);
                    IUnknown_SetOptions(punkACLHist, dwACLOptions);
                    punkACLHist->Release();
                }
            }

            if ((dwFlags & SHACF_FILESYSTEM) ||
                (dwFlags & SHACF_FILESYS_DIRS) ||
                (dwFlags & SHACF_FILESYS_ONLY))
            {
                // ADD The ISF List
                IUnknown * punkACLISF;
                hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkACLISF));
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punkACLISF);
                    IUnknown_SetOptions(punkACLISF, dwACLOptions);
                    punkACLISF->Release();
                }
            }

            pomMulti->Release();
        }
    }

    return punkACLMulti;
}


#define SZ_REGKEY_AUTOCOMPLETE_TAB          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_AUTOCOMPLETE_TAB        TEXT("Always Use Tab")
#define BOOL_NOT_SET                        0x00000005
DWORD _UpdateAutoCompleteFlags(DWORD dwFlags, DWORD * pdwACLOptions)
{
    DWORD dwACOptions = 0;

    *pdwACLOptions = 0;
    if (!(SHACF_AUTOAPPEND_FORCE_OFF & dwFlags) &&
        ((SHACF_AUTOAPPEND_FORCE_ON & dwFlags) ||
        SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE)))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (!(SHACF_AUTOSUGGEST_FORCE_OFF & dwFlags) &&
        ((SHACF_AUTOSUGGEST_FORCE_ON & dwFlags) ||
        SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE)))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    if (SHACF_USETAB & dwFlags)
    {
        dwACOptions |= ACO_USETAB;
    }

    if (SHACF_FILESYS_DIRS & dwFlags)
    {
        *pdwACLOptions |= ACLO_FILESYSDIRS;
    }
    else if (SHACF_FILESYS_ONLY & dwFlags)
    {
        *pdwACLOptions |= ACLO_FILESYSONLY;
    }

    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 
    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;

    return dwACOptions;
}


/****************************************************\
    FUNCTION: SHAutoComplete

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.

    Caller needs to have called CoInitialize() or OleInitialize()
    and cannot call CoUninit/OleUninit until after
    WM_DESTROY on hwndEdit.
\****************************************************/
STDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags)
{
    IUnknown * punkACL;
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwACLOptions = 0;
    DWORD dwACOptions = _UpdateAutoCompleteFlags(dwFlags, &dwACLOptions);

    if (SHACF_DEFAULT == dwFlags)
        dwFlags = (SHACF_FILESYSTEM | SHACF_URLALL);

    punkACL = ACGetLists(dwFlags, dwACLOptions);
    if (punkACL)    // May fail on low memory.
    {
        IAutoComplete2 * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &pac));
        if (SUCCEEDED(hr))
        {
            if (SHPinDllOfCLSID(&CLSID_ACListISF) &&
                SHPinDllOfCLSID(&CLSID_AutoComplete))
            {
                hr = pac->Init(hwndEdit, punkACL, NULL, NULL);
                pac->SetOptions(dwACOptions);
            }
            else
            {
                hr = E_FAIL;
            }
            pac->Release();
        }

        punkACL->Release();
    }

    return hr;
}



//***   IOleCommandTarget helpers {

#define ISPOW2(i)   (((i) & ~((i) - 1)) == (i))

//***   IsQSForward -- (how) should i forward an IOleCT::Exec/QS command?
// ENTRY/EXIT
//  nCmdID  the usual; plus special value -1 means just check pguidCmdGroup
//  hr      S_OK|n if recognized (see below); o.w. OLECMDERR_E_NOTSUPPORTED
//      S_OK|+1  down
//      S_OK|+2  broadcast down
//      S_OK|-1  up
//      S_OK|-2  broadcast up (unused?)
// NOTES
//  WARNING: we never touch anything but the 1st field of rgCmds, so
//  IsExecForward can (and does!) lie and pass us '(OLECMD *) &nCmdID'.
//
STDAPI IsQSForward(const GUID *pguidCmdGroup, int cCmds, OLECMD *pCmds)
{
    int octd = 0;

    ASSERT(OCTD_DOWN > 0 && OCTD_DOWNBROADCAST > OCTD_DOWN);
    ASSERT(ISPOW2(OCTD_DOWN) && ISPOW2(OCTD_DOWNBROADCAST));
    ASSERT(OCTD_UP < 0);
    if (pguidCmdGroup == NULL) 
    {
        for (; cCmds > 0; pCmds++, cCmds--) 
        {
            switch (pCmds->cmdID) 
            {
            case OLECMDID_STOP:
            case OLECMDID_REFRESH:
            case OLECMDID_ENABLE_INTERACTION:
                // down (broadcast)
                octd |= OCTD_DOWNBROADCAST;
                break;

            case OLECMDID_CUT:
            case OLECMDID_COPY:
            case OLECMDID_PASTE:
            case OLECMDID_SELECTALL:
                // down (singleton)
                octd |= OCTD_DOWN;
                break;

            default:
                octd |= +4;
                break;
            }
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (; cCmds > 0; pCmds++, cCmds--)
        {
            switch (pCmds->cmdID)
            {
                case  SBCMDID_FILEDELETE:
                case  SBCMDID_FILEPROPERTIES:
                case  SBCMDID_FILERENAME:
                case  SBCMDID_CREATESHORTCUT:
                    octd |= OCTD_DOWN;
                    break;
            }
        }
    }

#ifdef DEBUG
    // make sure only one bit set

    if (!ISPOW2(octd)) 
    {
        // e.g. if we have both down and broadcast guys, the caller
        // will have to be careful to have his IOleCT::QS forward them
        // separately and then merge them together.
        ASSERT(0);  // probably best for caller to do 2 separate calls
        TraceMsg(DM_WARNING, "ief: singleton/broadcast mixture");
    }
#endif
    if (octd == 0 || (octd & 4)) 
    {
        // octd&4: if anyone is bogus, make them all be, to flesh out
        // bugs where the caller is passing us a mixture we can't handle
        return OLECMDERR_E_NOTSUPPORTED;
    }

    // aka (S_OK|octd)
    return MAKE_HRESULT(ERROR_SUCCESS, FACILITY_NULL, octd);
}


//***   MayQSForward -- forward IOleCT::QS if appropriate
//
STDAPI MayQSForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hrTmp;

    hrTmp = IsQSForward(pguidCmdGroup, cCmds, rgCmds);
    if (SUCCEEDED(hrTmp)) 
    {
        // we know how to forward
        if (HRESULT_CODE(hrTmp) > 0 && iUpDown > 0
          || HRESULT_CODE(hrTmp) < 0 && iUpDown < 0) 
        {
            // punk pts in the right direction for nCmdID
            return IUnknown_QueryStatus(punk, pguidCmdGroup, cCmds, rgCmds,
                pcmdtext);
        }
    }
    return OLECMDERR_E_NOTSUPPORTED;
}


//***   MayExecForward -- forward IOleCT::Exec if appropriate
// NOTES
//  should iUpDown be an int or an HRESULT?
STDAPI MayExecForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hrTmp;

    hrTmp = IsExecForward(pguidCmdGroup, nCmdID);
    if (SUCCEEDED(hrTmp)) 
    {
        // we know how to forward
        if (HRESULT_CODE(hrTmp) > 0 && iUpDown > 0
          || HRESULT_CODE(hrTmp) < 0 && iUpDown < 0) 
        {
            // punk pts in the right direction for nCmdID
            return IUnknown_Exec(punk, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut);
        }
    }
    return OLECMDERR_E_NOTSUPPORTED;
}


STDAPI_(HMENU) SHLoadMenuPopup(HINSTANCE hinst, UINT id)
{
    HMENU hMenuSub = NULL;
    HMENU hMenu = LoadMenuW(hinst, MAKEINTRESOURCEW(id));
    if (hMenu) 
    {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub) 
        {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }
        DestroyMenu(hMenu);
    }

    return hMenuSub;
}


//-----------------------------------------------------------------------------

typedef LRESULT (WINAPI *POSTORSENDMESSAGEPROC)(HWND, UINT, WPARAM, LPARAM);
struct propagatemsg
{
    HWND   hwndParent;
    int    iFlags;  // "int" for back compatibility; used to be "BOOL"
    UINT   uMsg;
    WPARAM wParam;
    LPARAM lParam;
    POSTORSENDMESSAGEPROC PostOrSendMessage;
};

BOOL CALLBACK PropagateCallback(HWND hwndChild, LPARAM lParam)
{
    struct propagatemsg *pmsg = (struct propagatemsg *)lParam;

    if ((pmsg->iFlags & SPM_ONELEVEL) && GetParent(hwndChild) != pmsg->hwndParent)
    {
        // Wrong parent; skip it
        return TRUE;
    }
    pmsg->PostOrSendMessage(hwndChild, pmsg->uMsg, pmsg->wParam, pmsg->lParam);

    return TRUE;
}

STDAPI_(void) SHPropagateMessage(HWND hwndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, int iFlags)
{
    if (!hwndParent)
        return;

    struct propagatemsg msg;
    msg.hwndParent = hwndParent;
    msg.iFlags = iFlags;
    msg.uMsg = uMsg;
    msg.wParam = wParam;
    msg.lParam = lParam;
    if (iFlags & SPM_SEND)
    {
        msg.PostOrSendMessage = IsWindowUnicode(hwndParent) ?
                                    SendMessageW : SendMessageA;
    }
    else
    {
        msg.PostOrSendMessage = (POSTORSENDMESSAGEPROC)
                                (IsWindowUnicode(hwndParent) ?
                                    PostMessageW : PostMessageA);
    }

    EnumChildWindows(hwndParent, /*(WNDENUMPROC)*/PropagateCallback, (LPARAM)&msg);
}

LRESULT SHDefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (IsWindowUnicode(hwnd)) 
    {
        return DefWindowProcW(hwnd, uMsg, wParam, lParam);
    }
    else 
    {
        return DefWindowProcA(hwnd, uMsg, wParam, lParam);
    }
}

// Returns the submenu of the given menu and ID.  Returns NULL if there
// is no submenu
STDAPI_(HMENU) SHGetMenuFromID(HMENU hmMain, UINT uID)
{
    HMENU hmenuRet = NULL;
    if (!hmMain)
        return NULL;

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    if (GetMenuItemInfo(hmMain, uID, FALSE, &mii))
        hmenuRet = mii.hSubMenu;
    return hmenuRet;
}


STDAPI_(int) SHMenuIndexFromID(HMENU hm, UINT id)
{
    for (int index = GetMenuItemCount(hm)-1; index>=0; index--)
    {
        // We have to use GetMenuItemInfo and not the simpler GetMenuItemID
        // because GetMenuItemID does not support submenus (grr).
        MENUITEMINFO mii;
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID;
        mii.cch = 0;        // just in case

        if (GetMenuItemInfo(hm, (UINT)index, TRUE, &mii)
            && (mii.wID == id))
        {
           break;
        }
    }

    return(index);
}


STDAPI_(void) SHRemoveAllSubMenus(HMENU hmenu)
{
    int cItems = GetMenuItemCount(hmenu);
    int i;

    for (i=cItems-1; i>=0; i--)
    {
        if (GetSubMenu(hmenu, i))
            RemoveMenu(hmenu, i, MF_BYPOSITION);
    }
}


STDAPI_(void) SHEnableMenuItem(HMENU hmenu, UINT id, BOOL fEnable)
{
    EnableMenuItem(hmenu, id, fEnable ?
        (MF_BYCOMMAND | MF_ENABLED) : (MF_BYCOMMAND| MF_GRAYED));
}


STDAPI_(void) SHCheckMenuItem(HMENU hmenu, UINT id, BOOL fChecked)
{
    CheckMenuItem(hmenu, id,
                  fChecked ? (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED));
}


//
//  IStream 'saner/simpler' Wrappers that dont use exactly the same params, and have simpler
//  output.  closer mirroring the way we use them.
//
// NOTES
//  'saner' means that it only returns SUCCEEDED when it reads everything
//  you asked for.  'simpler' means no 'pcbRead' param.
STDAPI IStream_Read(IStream *pstm, void *pv, ULONG cb)
{
    ASSERT(pstm);
    ULONG cbRead;
    HRESULT hr = pstm->Read(pv, cb, &cbRead);
    if (SUCCEEDED(hr) && cbRead != cb) 
    {
        hr = E_FAIL;
    }
    return hr;
}


STDAPI IStream_Write(IStream *pstm, LPCVOID pvIn, ULONG cbIn)
{
    ASSERT(pstm);
    DWORD cb;
    HRESULT hr = pstm->Write(pvIn, cbIn, &cb);
    if (SUCCEEDED(hr) && cbIn != cb)
        hr = E_FAIL;

    return hr;
}


STDAPI IStream_Reset(IStream *pstm)
{
    return pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
}

STDAPI IStream_Size(IStream *pstm, ULARGE_INTEGER *pui)
{
    ASSERT(pstm);
    ASSERT(pui);

    STATSTG st = {0};

    // WARNING: What if IStream::Stat is not implemented?
    // Win95/NT4/IE4's IStream had this problem.  Fixed
    // for NT5...
    //
    HRESULT hr = pstm->Stat(&st, STATFLAG_NONAME);
    if (SUCCEEDED(hr))
    {
        *pui = st.cbSize;
    }

    return hr;
}


STDAPI IStream_ReadPidl(IStream *pstm, LPITEMIDLIST *ppidlOut)
{
    *ppidlOut = NULL;

    DWORD cbPidl;
    HRESULT hr = IStream_Read(pstm, &cbPidl, sizeof(cbPidl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)CoTaskMemAlloc(cbPidl);
        if (pidl)
        {
            if (SUCCEEDED(hr = IStream_Read(pstm, pidl, cbPidl)))
            {
                // Validate that what we have is a well-formed pidl
                LPITEMIDLIST pidlEnd = _ILSkip(pidl, cbPidl - sizeof(USHORT));
                LPITEMIDLIST pidlT = pidl;
                while (pidlT <= pidlEnd && pidlT->mkid.cb)
                {
                    pidlT = _ILNext(pidlT);
                }

                if (pidlT == pidlEnd && pidlT->mkid.cb == 0)
                {
                    *ppidlOut = pidl;
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            }
            if (FAILED(hr))
            {
                // Cannot use ILFree because it might not be a valid pidl
                CoTaskMemFree(pidl);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDAPI IStream_WritePidl(IStream *pstm, LPCITEMIDLIST pidlWrite)
{
    HRESULT hr;
    
    ASSERT(pidlWrite);
    DWORD cbPidl = ILGetSize(pidlWrite);

    if (SUCCEEDED(hr = IStream_Write(pstm, &cbPidl, sizeof(cbPidl))) &&
        SUCCEEDED(hr = IStream_Write(pstm, pidlWrite, cbPidl)))
    {
        // woo-hoo, all written successfully
    }
    return hr;
}

STDAPI_(BOOL) SHRegisterClassA(const WNDCLASSA* pwc)
{
    WNDCLASSA wc;
    if (!GetClassInfoA(pwc->hInstance, pwc->lpszClassName, &wc)) 
    {
        return RegisterClassA(pwc);
    }
    return TRUE;
}

//
//  Warning!  This uses RegisterClassWrap, which means that if we
//  are an ANSI-only platform, your window class will be registered
//  as **ANSI**, not as UNICODE.  You window procedure needs to call
//  IsWindowUnicode() to determine how to interpret incoming string
//  parameters.
//
STDAPI_(BOOL) SHRegisterClassW(const WNDCLASSW* pwc)
{
    WNDCLASSW wc;
    if (!GetClassInfoW(pwc->hInstance, pwc->lpszClassName, &wc)) 
    {
        return RegisterClassW(pwc);
    }
    return TRUE;
}

//
//  SHUnregisterClasses unregisters an array of class names.
//
STDAPI_(void) SHUnregisterClassesA(HINSTANCE hinst, const LPCSTR *rgpszClasses, UINT cpsz)
{
    for (UINT i = 0; i < cpsz; i++) 
    {
        WNDCLASSA wc;
        if (GetClassInfoA(hinst, rgpszClasses[i], &wc)) 
        {
            UnregisterClassA(rgpszClasses[i], hinst);
        }
    }
}

STDAPI_(void) SHUnregisterClassesW(HINSTANCE hinst, const LPCWSTR *rgpszClasses, UINT cpsz)
{
    for (UINT i = 0; i < cpsz; i++) 
    {
        WNDCLASSW wc;
        if (GetClassInfoW(hinst, rgpszClasses[i], &wc)) 
        {
            UnregisterClassW(rgpszClasses[i], hinst);
        }
    }
}


//
// This structure is used by the UNICODE version of this function. So, the pointers point to
// wide characters strings.
typedef struct tagMBCINFOW {  // Used only between the routine and its DlgProc
    UINT    uType;
    LPCWSTR pwszText;
    LPCWSTR pwszTitle;
    LPCWSTR pwszRegPath;
    LPCWSTR pwszRegVal;
    
    DLGPROC pUserDlgProc;
    void * pUserData;
} MBCINFOW, *LPMBCINFOW;


void _MoveDlgItem(HDWP hdwp, HWND hDlg, int nItem, int x, int y)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, nItem);

    GetClientRect(hwnd, &rc);
    MapWindowPoints(hwnd, hDlg, (LPPOINT) &rc, 2);

    DeferWindowPos(hdwp, hwnd, 0, rc.left + x, rc.top + y, 0, 0,
        SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
}


void _AddIcon(HWND hDlg, LPRECT prcNextChild, UINT uType)
{
    HICON hic;

    switch (uType & MB_ICONMASK)
    {
    case MB_ICONHAND:
        hic = LoadIcon(NULL, IDI_ERROR);        // == IDI_HAND
        break;
    case MB_ICONQUESTION:
        hic = LoadIcon(NULL, IDI_QUESTION);
        break;
    case MB_ICONEXCLAMATION:
        hic = LoadIcon(NULL, IDI_WARNING);      // == IDI_EXCLAMATION
        break;
    case MB_ICONINFORMATION:
        hic = LoadIcon(NULL, IDI_INFORMATION);  // == IDI_ASTERISK
        break;
    default:
        hic = NULL;
        break;
    }
    if (hic)
    {
        prcNextChild->left += GetSystemMetrics(SM_CXICON) + 10;
        SendDlgItemMessage(hDlg, IDC_MBC_ICON, STM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) hic);
    }
}

void _RecalcWindowHeight(HWND hWnd, LPMBCINFOW lpmbci)
{
    HDC  hdc = GetDC(hWnd);
    RECT rc;
    HWND hwndText = GetDlgItem(hWnd,IDC_MBC_TEXT);
    HDWP hdwp;
    int  iHeightDelta, cx, cxIcon;
    HFONT hFontSave;

    hFontSave = (HFONT)SelectObject(hdc, GetWindowFont(hwndText));

    // Get the starting rect of the text area (for the width)
    GetClientRect(hwndText, &rc);
    MapWindowPoints(hwndText, hWnd, (LPPOINT) &rc, 2);

    // See if we need to add an icon, slide rc over if we do
    cxIcon = RECTWIDTH(rc);
    _AddIcon(hWnd, &rc, lpmbci->uType);
    cxIcon = RECTWIDTH(rc) - cxIcon;

    // Calc how high the static text area needs to be, given the above width
    iHeightDelta = RECTHEIGHT(rc);
    cx = RECTWIDTH(rc);
    //Note: We need to call the Wide version of DrawText here!
    DrawTextW(hdc, lpmbci->pwszText, -1, &rc, DT_CALCRECT | DT_LEFT | DT_WORDBREAK);
    iHeightDelta = RECTHEIGHT(rc) - iHeightDelta;

    cx = RECTWIDTH(rc) - cx; // Should only change for really long words w/o spaces
    if (cx < 0)
        cx = 0;

    if (hFontSave)
        SelectObject(hdc, hFontSave);
    ReleaseDC(hWnd, hdc);

    hdwp = BeginDeferWindowPos(6);
    if (hdwp)
    {
        DeferWindowPos(hdwp, hwndText, 0, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);

        _MoveDlgItem(hdwp, hWnd, IDC_MBC_CHECK, -cxIcon, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDCANCEL, cx, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDOK, cx, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDYES, cx, iHeightDelta);
        _MoveDlgItem(hdwp, hWnd, IDNO, cx, iHeightDelta);

        EndDeferWindowPos(hdwp);

        GetWindowRect(hWnd, &rc);
        SetWindowPos(hWnd, 0, rc.left - (cx/2), rc.top - (iHeightDelta/2), RECTWIDTH(rc)+cx, RECTHEIGHT(rc)+iHeightDelta, SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return;
}


void HideAndDisableWindow(HWND hwnd)
{
    ShowWindow(hwnd, SW_HIDE);
    EnableWindow(hwnd, FALSE);
}


//
// NOTE: This dialog proc is always UNICODE since both SHMessageBoxCheckA/W thunk to UNICODE and
//       use this procedure.
//
BOOL_PTR CALLBACK MessageBoxCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // we only handle the WM_INITDIALOG so that we can resize the dialog
        // approprately
        case WM_INITDIALOG:
        {
            LPMBCINFOW lpmbci = (LPMBCINFOW)lParam;
            HWND hwndYES = GetDlgItem(hDlg, IDYES);
            HWND hwndNO = GetDlgItem(hDlg, IDNO);
            HWND hwndCANCEL = GetDlgItem(hDlg, IDCANCEL);
            HWND hwndOK = GetDlgItem(hDlg, IDOK);

            _RecalcWindowHeight(hDlg, lpmbci);

            //Note: We need to call the Wide version of SetDlgItemText() here.
            SetDlgItemTextW(hDlg,IDC_MBC_TEXT,lpmbci->pwszText);
            if (lpmbci->pwszTitle)
                SetWindowTextW(hDlg,lpmbci->pwszTitle);
            if ((lpmbci->uType & MB_TYPEMASK) == MB_OKCANCEL)
            {
                SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                HideAndDisableWindow(hwndYES);
                HideAndDisableWindow(hwndNO);
                SetFocus(hwndOK);
            }
            else if ((lpmbci->uType & MB_TYPEMASK) == MB_OK)
            {
                RECT rc;

                SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                HideAndDisableWindow(hwndYES);
                HideAndDisableWindow(hwndNO);
                HideAndDisableWindow(hwndCANCEL);

                if (EVAL(GetClientRect(hwndCANCEL, &rc)))
                {
                    MapWindowPoints(hwndCANCEL, hDlg, (LPPOINT) &rc, 2);
                    EVAL(SetWindowPos(hwndOK, hDlg, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_SHOWWINDOW));
                }

                SetFocus(hwndOK);
            }
            else // MB_YESNO
            {
                SendMessage(hDlg, DM_SETDEFID, IDYES, 0);
                HideAndDisableWindow(hwndOK);
                HideAndDisableWindow(hwndCANCEL);
                SetFocus(hwndYES);
            }
            return (FALSE); // we set the focus, so return false
        }
    }
    
    // didnt handle this message
    return FALSE;
}


//
// NOTE: The MessageBoxCheckExDlgProc is both UNICODE and ANSI since it dosent really do any string
//       stuff. Our UNICODE/ANSI-ness is determined by our caller.
//
BOOL_PTR CALLBACK MessageBoxCheckExDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MBCINFOW* pmbci = NULL;
    HWND hwndCheckBox = GetDlgItem(hDlg, IDC_MESSAGEBOXCHECKEX);

    if (uMsg == WM_INITDIALOG)
    {
        pmbci = (MBCINFOW*)lParam;

        // we have to have this control or we're hopeless
        if (!hwndCheckBox)
        {
            AssertMsg(FALSE, "MessageBoxCheckEx dialog templates must have a control whos ID is IDC_MESSAGEBOXCHECKEX!!");
            EndDialog(hDlg, 0);
        }
        
        // we use the checkbox to hang our data off of, since the caller
        // might want to use hDlg to hang its data off of.
        SetWindowPtr(hwndCheckBox, GWLP_USERDATA, pmbci);
    }
    else
    {
        pmbci = (MBCINFOW*)GetWindowPtr(hwndCheckBox, GWLP_USERDATA);
    }

    // we get a few messages before we get the WM_INITDIALOG (such as WM_SETFONT)
    // and until we get the WM_INITDIALOG we dont have our pmbci pointer, we just
    // return false
    if (!pmbci)
        return FALSE;


    // now check to see if we have a user specified dlg proc
    if (pmbci->pUserDlgProc)
    {
        // for the messages below, we simply return what the "real" dialog proc
        // said since they do NOT return TRUE/FALSE (eg handled or not handled).
        if (uMsg == WM_CTLCOLORMSGBOX      ||
            uMsg == WM_CTLCOLOREDIT        ||
            uMsg == WM_CTLCOLORLISTBOX     ||
            uMsg == WM_CTLCOLORBTN         ||
            uMsg == WM_CTLCOLORDLG         ||
            uMsg == WM_CTLCOLORSCROLLBAR   ||
            uMsg == WM_CTLCOLORSTATIC      ||
            uMsg == WM_COMPAREITEM         ||
            uMsg == WM_VKEYTOITEM          ||
            uMsg == WM_CHARTOITEM          ||
            uMsg == WM_QUERYDRAGICON       ||
            uMsg == WM_INITDIALOG)
        {
            return pmbci->pUserDlgProc(hDlg, uMsg, wParam, (uMsg == WM_INITDIALOG) ? (LPARAM)(pmbci->pUserData) : lParam);
        }

        if ((pmbci->pUserDlgProc(hDlg, uMsg, wParam, lParam) != FALSE) &&
            (uMsg != WM_DESTROY))
        {
            // the "real" dialog proc handled it so we are done, except we always
            // need to handle the WM_DESTROY message so we can check the state of
            // the checkbox in order to set the registry key accordingly.
            return TRUE;
        }
    }

    switch (uMsg)
    {
        case WM_CLOSE:
            wParam = IDCANCEL;
            // fall through
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDYES:
                case IDCANCEL:
                case IDNO:
                    EndDialog(hDlg, (int) LOWORD(wParam));
                    break;
            }
            break;
        }

        case WM_DESTROY:
            if (IsDlgButtonChecked(hDlg, IDC_MESSAGEBOXCHECKEX) == BST_CHECKED)
            {
                // Note: we need to call the Wide version of this function,
                // since our pmbci is always UNICODE
                SHRegSetUSValueW(pmbci->pwszRegPath, pmbci->pwszRegVal, REG_SZ,
                                 L"no", sizeof(L"no"), SHREGSET_HKCU);
            }
            break;
    }
    return FALSE;
}

STDAPI_(HANDLE) CreateAndActivateContext(ULONG_PTR* pul)
{
    HANDLE hActCtx;
    ACTCTX act = {0};
    TCHAR szPath[MAX_PATH];

    GetModuleFileName(g_hinst, szPath, ARRAYSIZE(szPath));

    act.cbSize = sizeof(act);
    act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    act.lpResourceName = MAKEINTRESOURCE(123);
    act.lpSource = szPath;

    hActCtx = CreateActCtx(&act);

    if (hActCtx)
    {
        ActivateActCtx(hActCtx, pul);
    }

    return hActCtx;

}

STDAPI_(void) DeactivateAndDestroyContext(HANDLE hActCtx, ULONG_PTR ul)
{
    if (hActCtx != INVALID_HANDLE_VALUE)
    {
        if (ul != 0)
            DeactivateActCtx(0, ul);

        ReleaseActCtx(hActCtx);
    }
}


// MessageBoxCheckW puts up a simple dialog box, with a checkbox to control if the
// dialog is to be shown again (eg gives you "dont show me this dlg again" functionality).
//
// Call as you would MessageBox, but with three additional parameters:
// The value to return if they checked "never again", and the reg path and value
// to store whether it gets shown again.


// MessageBoxCheckEx allows the user to specify a template that will be used along with
// a dialog proc that will be called. The only must for the dialog template is that it has
// to have a checkbox control with ID IDC_MESSAGEBOXCHECKEX (this is the "dont show me this
// again" checkbox).
// 
// The default template looks something like the following:
//
//        DLG_MESSAGEBOXCHECK DIALOG DISCARDABLE  0, 0, 210, 55
//        STYLE DS_MODALFRAME | DS_NOIDLEMSG | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE
//        CAPTION "Error!"
//        FONT 8, "MS Shell Dlg"
//        BEGIN
//            ICON            0, IDC_MBC_ICON,5,5,18,20
//            LTEXT           "",IDC_MBC_TEXT,5,5,200,8
//            CONTROL         "&In the future, do not show me this dialog box",
//                             IDC_MESSAGEBOXCHECKEX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,5,20,155,10
//            PUSHBUTTON      "OK",IDOK,95,35,50,14
//            PUSHBUTTON      "Cancel",IDCANCEL,150,35,50,14
//        END

//
// This function is fully implemented in UNICODE and the ANSI version of this function is thunked
// to this UNICODE version.
//
STDAPI_(int) SHMessageBoxCheckW(HWND hwnd, LPCWSTR pwszText, LPCWSTR pwszTitle, UINT uType, int iDefault, LPCWSTR pwszRegVal)
{
    // -- browseui(unicode) uses this
    MBCINFOW mbci;

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueW(REGSTR_PATH_MESSAGEBOXCHECKW, pwszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    ASSERT(((uType & MB_TYPEMASK) == MB_OKCANCEL) || 
           ((uType & MB_TYPEMASK) == MB_YESNO) ||
           ((uType & MB_TYPEMASK) == MB_OK));
    ASSERT(pwszText != NULL);

    mbci.pwszText = pwszText;
    mbci.pwszTitle = pwszTitle;
    mbci.pwszRegPath = REGSTR_PATH_MESSAGEBOXCHECKW;
    mbci.pwszRegVal = pwszRegVal;
    mbci.uType = uType;
    mbci.pUserData = (LPVOID) &mbci;
    mbci.pUserDlgProc = MessageBoxCheckDlgProc;

    // we use the MessageBoxCheckExDlgProc as the main dlg proc, and allow the MessageBoxCheckDlgProc
    // to be the "user" dlg proc

    ULONG_PTR ul;
    HANDLE h = CreateAndActivateContext(&ul);


    int i = (int)DialogBoxParamW(HINST_THISDLL, MAKEINTRESOURCEW(DLG_MESSAGEBOXCHECK),
                                    hwnd, MessageBoxCheckExDlgProc, (LPARAM)&mbci);

    DeactivateAndDestroyContext(h, ul);

    return i;
}

//
//  This function simply thunks to the UNICODE version.
//
//
STDAPI_(int) SHMessageBoxCheckA(HWND hwnd, LPCSTR pszText, LPCSTR pszTitle, UINT uType, int iDefault, LPCSTR pszRegVal)
{
    LPWSTR  lpwszText = NULL, lpwszTitle = NULL;
    int     iTextBuffSize = 0, iTitleBuffSize = 0;
    WCHAR   wszRegVal[REGSTR_MAX_VALUE_LENGTH];

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueA(REGSTR_PATH_MESSAGEBOXCHECKA, pszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    // Since there is no MAX possible size for these strings, we dynamically allocate them.
    // Convert the input params into UNICODE.
    if (!(lpwszText = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(iTextBuffSize = lstrlen(pszText)+1))))
        goto End_MsgBoxCheck;
    if (!(lpwszTitle = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(iTitleBuffSize = lstrlen(pszTitle)+1))))
        goto End_MsgBoxCheck;

    // Conver the Ansi strings into Unicode strings.
    SHAnsiToUnicode(pszText, lpwszText, iTextBuffSize);
    SHAnsiToUnicode(pszTitle, lpwszTitle, iTitleBuffSize);
    SHAnsiToUnicode(pszRegVal, wszRegVal, ARRAYSIZE(wszRegVal));

    // Call the UNICODE version of this function.
    iDefault = SHMessageBoxCheckW(hwnd, lpwszText, lpwszTitle, uType, iDefault, wszRegVal);

    // Clean up and return.
End_MsgBoxCheck:
    if (lpwszText)
        LocalFree((HANDLE)lpwszText);
    if (lpwszTitle)
        LocalFree((HANDLE)lpwszTitle);

    return iDefault;
}


//
// This function calls directly to the helper function
//
STDAPI_(int) SHMessageBoxCheckExW(HWND hwnd, HINSTANCE hinst, LPCWSTR pwszTemplateName, DLGPROC pDlgProc, void *pData,
                                  int iDefault, LPCWSTR pwszRegVal)
{
    MBCINFOW mbci = {0};

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueW(REGSTR_PATH_MESSAGEBOXCHECKW, pwszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    mbci.pwszRegPath = REGSTR_PATH_MESSAGEBOXCHECKW;
    mbci.pwszRegVal = pwszRegVal;
    mbci.pUserDlgProc = pDlgProc;
    mbci.pUserData = pData;

    ULONG_PTR ul;
    HANDLE h = CreateAndActivateContext(&ul);


    // call the UNICODE function, since the users dlg proc (if it exists) is UNICODE
    int i = (int)DialogBoxParamW(hinst, pwszTemplateName, hwnd, MessageBoxCheckExDlgProc, (LPARAM)&mbci);

    DeactivateAndDestroyContext(h, ul);


    return i;
}


//
// This function thunks the strings and calls the helper function
//
STDAPI_(int) SHMessageBoxCheckExA(HWND hwnd, HINSTANCE hinst, LPCSTR pszTemplateName, DLGPROC pDlgProc, void *pData, 
                                  int iDefault, LPCSTR pszRegVal)
{
    WCHAR   wszRegVal[REGSTR_MAX_VALUE_LENGTH];
    MBCINFOW mbci = {0};

    // check first to see if the "dont show me this again" is set
    if (!SHRegGetBoolUSValueA(REGSTR_PATH_MESSAGEBOXCHECKA, pszRegVal, FALSE, /*default:*/TRUE))
        return iDefault;

    // Conver the Ansi strings into Unicode strings.
    SHAnsiToUnicode(pszRegVal, wszRegVal, ARRAYSIZE(wszRegVal));

    mbci.pwszRegPath = REGSTR_PATH_MESSAGEBOXCHECKW; // the MBCINFOW is always UNICODE
    mbci.pwszRegVal = wszRegVal;
    mbci.pUserDlgProc = pDlgProc;
    mbci.pUserData = pData;

    ULONG_PTR ul;
    HANDLE h = CreateAndActivateContext(&ul);


    // call the ANSI function since the users dlg proc (if it exists) is ANSI
    iDefault = (int)DialogBoxParamA(hinst, pszTemplateName, hwnd, MessageBoxCheckExDlgProc, (LPARAM)&mbci);

    DeactivateAndDestroyContext(h, ul);

    return iDefault;
}

// "I'm sorry, Dave, I can't let you do that."

LWSTDAPI_(void) SHRestrictedMessageBox(HWND hwnd)
{
    ShellMessageBoxW(MLGetHinst(),
                         hwnd, 
                         MAKEINTRESOURCEW(IDS_RESTRICTIONS), 
                         MAKEINTRESOURCEW(IDS_RESTRICTIONSTITLE), 
                         MB_OK | MB_ICONSTOP);
}

// in:
//      pdrop       thing to drop on
//      pdataobj    thing we are dropping
//      grfKeyState to force certain operations
//      ppt         [optional] point where the drop happens (screen coords)
//
// in/out
//      pdwEffect   [optional] effects allowed and returns what was performed.

STDAPI SHSimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                      const POINTL *ppt, DWORD *pdwEffect)
{
    POINTL pt;
    DWORD dwEffect;

    if (!ppt)
    {
        ppt = &pt;
        pt.x = 0;
        pt.y = 0;
    }

    if (!pdwEffect)
    {
        pdwEffect = &dwEffect;
        dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
    }

    DWORD dwEffectSave = *pdwEffect;    // drag enter returns the default effect

    HRESULT hr = pdrop->DragEnter(pdtobj, grfKeyState, *ppt, pdwEffect);
    if (*pdwEffect)
    {
        *pdwEffect = dwEffectSave;      // do Drop with the full set of bits
        hr = pdrop->Drop(pdtobj, grfKeyState, *ppt, pdwEffect);
    }
    else
    {
        pdrop->DragLeave();
        hr = S_FALSE;     // HACK? S_FALSE DragEnter said no
    }

    return hr;
}


STDAPI SHLoadFromPropertyBag(IUnknown* punk, IPropertyBag* ppg)
{
    IPersistPropertyBag* pppg;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IPersistPropertyBag, &pppg));
    if (SUCCEEDED(hr))
    {
        hr = pppg->Load(ppg, NULL);
        pppg->Release();
    }

    return hr;
}


//***   IUnknown_TranslateAcceleratorOCS -- do punk->IOCS::TranslateAccelerator
STDAPI IUnknown_TranslateAcceleratorOCS(IUnknown *punk, LPMSG lpMsg, DWORD grfMods)
{
    HRESULT hr = E_FAIL;

    if (punk) 
    {
        IOleControlSite *pocs;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs));
        if (SUCCEEDED(hr)) 
        {
            hr = pocs->TranslateAccelerator(lpMsg, grfMods);
            pocs->Release();
        }
    }

    return hr;
}


STDAPI IUnknown_OnFocusOCS(IUnknown *punk, BOOL fGotFocus)
{
    HRESULT hr = E_FAIL;

    if (punk) 
    {
        IOleControlSite *pocs;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs));
        if (SUCCEEDED(hr)) 
        {
            hr = pocs->OnFocus(fGotFocus);
            pocs->Release();
        }
    }

    return hr;
}


STDAPI IUnknown_HandleIRestrict(IUnknown * punk, const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult)
{
    *pdwRestrictionResult = RR_NOCHANGE;    // init to something reasonable in case of failure

    IRestrict * pr;
    HRESULT hr = IUnknown_QueryService(punk, SID_SRestrictionHandler, IID_PPV_ARG(IRestrict, &pr));
    if (SUCCEEDED(hr))
    {
        hr = pr->IsRestricted(pguidID, dwRestrictAction, pvarArgs, pdwRestrictionResult);
        pr->Release();
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Get color resolution of the current display

*/
STDAPI_(UINT) SHGetCurColorRes(void)
{
    HDC hdc;
    UINT uColorRes;

    hdc = GetDC(NULL);
    uColorRes = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);

    return uColorRes;
}

//
// If a folder returns QIF_DONTEXPANDFODLER from QueryInfo, the folder should
// not get expanded.  This is used by menu code to not expand channel folders.
//
STDAPI_(BOOL) SHIsExpandableFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    ASSERT(psf);
    ASSERT(pidl);

    BOOL fRet = TRUE;

    IQueryInfo* pqi;

    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IQueryInfo, &pqi))))
    {
        ASSERT(pqi);

        DWORD dwFlags;

        if (SUCCEEDED(pqi->GetInfoFlags(&dwFlags)))
        {
            fRet = !(dwFlags & QIF_DONTEXPANDFOLDER);
        }

        pqi->Release();
    }

    return fRet;
}


STDAPI_(DWORD) SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate
    do 
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_SENDMESSAGE);

        if (dwRet == (WAIT_OBJECT_0 + 1))
        {
            // There must be a pending SendMessage from either the
            // thread we are killing or some other thread/process besides
            // this one.  Do a PeekMessage to process the pending
            // SendMessage and try waiting again
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            // Calculate if we have any more time left in the timeout to
            // wait on.
            if (dwTimeout != INFINITE)
            {
                dwTimeout = dwEnd - GetTickCount();
                if ((long)dwTimeout <= 0)
                {
                    // No more time left, fail with WAIT_TIMEOUT
                    dwRet = WAIT_TIMEOUT;
                }
            }
        }

        // dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED
        // The thread must have exited, so we are happy
        //
        // dwRet == WAIT_TIMEOUT
        // The thread is taking too long to finish, so just
        // return and let the caller kill it

    } while (dwRet == (WAIT_OBJECT_0 + 1));

    return(dwRet);
}

STDAPI SHWaitForCOMSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
    DWORD dwIndex;
    return CoWaitForMultipleHandles(0, dwTimeout, 1, &hThread, &dwIndex); // COWAIT_ALERTABLE?
}


STDAPI_(BOOL) SHVerbExistsNA(LPCSTR szExtension, LPCSTR pszVerb, LPSTR pszCommand, DWORD cchCommand)
{
/*
    This Private API was being exported only for usage in shdocvw\dochost.cpp. We 
    don't use this function any more. 
    I searched in srch in index1, and there was no users execpt us. Just to make sure that
    this assert is added so as to .to find out if there are any other users of this api which
    I might have missed.
        -KishoreP 5/4/2000
*/
    ASSERT(!"This Private API has been Removed");
    return FALSE;
}


STDAPI_(void) SHFillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}


//***   SearchMapInt -- map int->int
//
STDAPI_(int) SHSearchMapInt(const int *src, const int *dst, int cnt, int val)
{
    for (; cnt > 0; cnt--, src++, dst++) 
    {
        if (*src == val)
            return *dst;
    }
    return -1;
}


STDAPI_(void) IUnknown_Set(IUnknown ** ppunk, IUnknown * punk)
{
    ASSERT(ppunk);

    if (*ppunk != punk)
    {
        IUnknown_AtomicRelease((void **)ppunk);

        if (punk)
        {
            punk->AddRef();
            *ppunk = punk;
        }
    }
}



/*----------------------------------------------------------
  Purpose: Removes '&'s from a string, returning the character after
           the last '&'.  Double-ampersands are collapsed into a single
           ampersand.  (This is important so "&Help && Support" works.)

           If a string has multiple mnemonics ("&t&wo") USER is inconsistent.
           DrawText uses the last one, but the dialog manager uses the first
           one.  So we use whichever one is most convenient.
*/
STDAPI_(CHAR) SHStripMneumonicA(LPSTR pszMenu)
{
    ASSERT(pszMenu);
    CHAR cMneumonic = pszMenu[0]; // Default is first char

    // Early-out:  Many strings don't have ampersands at all
    LPSTR pszAmp = StrChrA(pszMenu, '&');
    if (pszAmp)
    {
        LPSTR pszCopy = pszAmp;
        while (*pszAmp)
        {
            // Protect against string that ends in '&' - don't read past the end!
            if (*pszAmp == L'&' && pszAmp[1])
            {
                // ++ is safe here because & is never a DBCS lead byte
                pszAmp++;                   // Don't copy the ampersand itself
                if (*pszAmp != L'&')        // && is not a mnemonic
                {
                    cMneumonic = *pszAmp;
                }
            }
            *pszCopy++ = *pszAmp++;

            // If I just copied a lead byte and there is a trail byte,
            // then copy the trail byte, too.
            if (IsDBCSLeadByte(pszCopy[-1]) && *pszAmp)
            {
                *pszCopy++ = *pszAmp++;
            }
        }
        *pszCopy = 0;
    }


    return cMneumonic;
}


/*----------------------------------------------------------
  Purpose: Removes '&'s from a string, returning the character after
           the last '&'.  Double-ampersands are collapsed into a single
           ampersand.  (This is important so "&Help && Support" works.)

           If a string has multiple mnemonics ("&t&wo") USER is inconsistent.
           DrawText uses the last one, but the dialog manager uses the first
           one.  So we use whichever one is most convenient.
*/
STDAPI_(WCHAR) SHStripMneumonicW(LPWSTR pszMenu)
{
    ASSERT(pszMenu);
    WCHAR cMneumonic = pszMenu[0]; // Default is first char

    // Early-out:  Many strings don't have ampersands at all
    LPWSTR pszAmp = StrChrW(pszMenu, L'&');
    if (pszAmp)
    {
        LPWSTR pszCopy = pszAmp - 1;

        //  FAREAST some localized builds have an mnemonic that looks like
        //    "Localized Text (&L)"  we should remove that, too
        if (pszAmp > pszMenu && *pszCopy == L'(')
        {
            if (pszAmp[2]  == L')')
            {
                cMneumonic = *pszAmp;
                // move amp so that we arent past the potential terminator
                pszAmp += 3;
                pszAmp = pszCopy;
            }
        }
        else
        {
            //  move it up so that we copy on top of amp
            pszCopy++;
        }
            
        while (*pszAmp)
        {
            // Protect against string that ends in '&' - don't read past the end!
            if (*pszAmp == L'&' && pszAmp[1])
            {
                pszAmp++;                   // Don't copy the ampersand itself
                if (*pszAmp != L'&')        // && is not a mnemonic
                {
                    cMneumonic = *pszAmp;
                }
            }
            *pszCopy++ = *pszAmp++;
        }
        *pszCopy = 0;
    }

    return cMneumonic;
}


// don't use IsChild.  that walks down all children.
// faster to walk up the parent chain

//***   IsChildOrSelf -- is hwnd either a child of or equal to hwndParent?
// NOTES
//  HasFocus      is IsChildOrSelf(hwnd, GetFocus())
//  IsWindowOwner is IsChildOrSelf(hwnd, hwndOwner)
//  n.b. hwnd==0 is special and yields FALSE.  this is presumbably what
//  one wants for both HasFocus and IsWindowOwner.
//
// NOTE: S_OK means TRUE, S_FALSE meanse FALSE
//
STDAPI SHIsChildOrSelf(HWND hwndParent, HWND hwnd)
{
    // SHDOCVW likes to pass hwndParent == NULL.  Oops.
    // SHDOCVW even likes to pass hwndParent == hwnd == NULL.  Double oops.
    if (hwndParent == NULL || hwnd == NULL) 
    {
        return S_FALSE;
    }

    // Old code here used to walk the GetParent chain which is bogus
    // because GetParent will return the Window Owner when there is
    // no parent window. Bug 63233 got bit by this -- a dialog box
    // has no parent but it's owned by the window at the top of
    // the hwndParent chain. Since GetParent returns the window owner
    // if there is no parent, we'd incorrectly think we should translate
    // this message. I switched this to calling IsChild directly. Note:
    // in asking around it appears that this function was written
    // because of the mistaken assumption that IsChild was implemented
    // in a perf-unfriendly way. [mikesh 15 Oct 97]
    //
    return ((hwndParent == hwnd) || IsChild(hwndParent, hwnd)) ? S_OK : S_FALSE;
}


STDAPI IContextMenu_Invoke(IContextMenu* pcm, HWND hwndOwner, LPCSTR pVerb, UINT fFlags)
{
    HRESULT hres = S_OK;

    if (pcm)
    {
        UINT idCmd = 0;
        DECLAREWAITCURSOR;
        SetWaitCursor();

        HMENU hmenu = NULL;
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
            0,
            hwndOwner,
            NULL,
            NULL, NULL,
            SW_NORMAL,
        };

        if (!IS_INTRESOURCE(pVerb)) 
        {
#ifdef UNICODE
            ici.lpVerbW = pVerb;
            ici.lpVerb = makeansi(pVerb);
            ici.fMask |= CMIC_MASK_UNICODE;
#else
            ici.lpVerb = pVerb;
#endif
        }
        else 
        {
            hmenu = CreatePopupMenu();
            if (hmenu)
            {
                fFlags |= CMF_DEFAULTONLY;

                pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fFlags);

                idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                if (-1 != idCmd)
                {
                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                }
            }
        }

        // need to reset it so that user won't blow off the app starting  cursor
        // also so that if we won't leave the wait cursor up when we're not waiting
        // (like in a prop sheet or something that has a message loop
        ResetWaitCursor();

        // can't just check verb because it could be 0 if idCmd == CMD_ID_FIRST
        if ((-1 != idCmd) || ici.lpVerb) 
        {
            if (!hwndOwner)
                ici.fMask |= CMIC_MASK_FLAG_NO_UI;

            pcm->InvokeCommand(&ici);
            hres = (HRESULT)1;
        }

        if (hmenu)
            DestroyMenu(hmenu);
    }

    return hres;
}


//
// SetDefaultDialogFont
//
// purpose: set font to the given control of the dialog
//          with platform's default character set so that
//          user can see whatever string in the native
//          language on the platform.
//
// in:      hDlg - the parent window handle of the given control
//          idCtl - ID of the control
//
// note:    this will store created font with window property
//          so that we can destroy it later.
//
const TCHAR c_szPropDlgFont[]       = TEXT("PropDlgFont");

STDAPI_(void) SHSetDefaultDialogFont(HWND hDlg, int idCtl)
{
    HFONT hfont;
    HFONT hfontDefault;
    LOGFONT lf;
    LOGFONT lfDefault;

    hfont = GetWindowFont(hDlg);
    GetObject(hfont, sizeof(LOGFONT), &lf);

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfDefault, 0);
    
    if (lfDefault.lfCharSet == lf.lfCharSet)
    {
        // if the dialog already has correct character set
        // don't do anything.
        return;
    }

    // If we already have hfont created, use it.
    if (!(hfontDefault = (HFONT)GetProp(hDlg, c_szPropDlgFont)))
    {
        // assign the same height of the dialog font
        lfDefault.lfHeight = lf.lfHeight;
        if (!(hfontDefault=CreateFontIndirect(&lfDefault)))
        {
            // restore back in failure
            hfontDefault = hfont;
        }
        if (hfontDefault != hfont)
            SetProp(hDlg, c_szPropDlgFont, hfontDefault);
    }
    

    SetWindowFont(GetDlgItem(hDlg, idCtl), hfontDefault, FALSE);
}


//
// RemoveDefaultDialogFont
//
// purpose: Destroy the font we used to set gui default font
//          Also removes the window property used to store the font.
//
// in:      hDlg - the parent window handle of the given control
//
// note:
STDAPI_(void) SHRemoveDefaultDialogFont(HWND hDlg)
{
    HFONT hfont;
    if (hfont = (HFONT)GetProp(hDlg, c_szPropDlgFont))
    {
        DeleteObject(hfont);
        RemoveProp(hDlg, c_szPropDlgFont);
    }
}

// NOTE: since this is a worker window it probably doesn't care about
// system messages that are ansi/unicode, so only support an ansi version.
// If the pfnWndProc cares, it can thunk the messages. (Do this because
// Win95 doesn't support RegisterClassW.)
HWND SHCreateWorkerWindowA(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p)
{
    WNDCLASSA wc = {0};

    wc.lpfnWndProc      = DefWindowProcA;
    wc.cbWndExtra       = sizeof(void *);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_BTNFACE + 1);
    wc.lpszClassName    = "WorkerA";
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    SHRegisterClassA(&wc);

    HWND hwnd = CreateWindowExA(dwExStyle, "WorkerA", NULL, dwFlags,
                                  0, 0, 0, 0, hwndParent,
                                  (HMENU)hmenu, HINST_THISDLL, NULL);
    if (hwnd) 
    {
        SetWindowPtr(hwnd, 0, p);

        if (pfnWndProc)
            SetWindowPtr(hwnd, GWLP_WNDPROC, pfnWndProc);
    }

    return hwnd;
}

// WARNING: since this is a worker window it probably doesn't care about
// system messages that are ansi/unicode, default to an ansi version on Win95.
//
// this forces callers to be aware of the fact that they are getting into
// a mess if they want compatibility with Win95.
//
// If the pfnWndProc cares, it can thunk the messages. (Do this because
// Win95 doesn't support RegisterClassW.)
//

HWND SHCreateWorkerWindowW(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p)
{
    WNDCLASSW wc = {0};

    wc.lpfnWndProc      = DefWindowProcW;
    wc.cbWndExtra       = sizeof(void *);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_BTNFACE + 1);
    wc.lpszClassName    = L"WorkerW";
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    SHRegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(dwExStyle, L"WorkerW", NULL, dwFlags,
                                  0, 0, 0, 0, hwndParent,
                                  (HMENU)hmenu, HINST_THISDLL, NULL);
    if (hwnd) 
    {
        SetWindowPtr(hwnd, 0, p);

        // Note: Must explicitly use W version to avoid charset thunks
        if (pfnWndProc)
            SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR)pfnWndProc);

    }

    return hwnd;
}

#pragma warning(disable:4035)   // no return value

#undef SHInterlockedCompareExchange
STDAPI_(void *) SHInterlockedCompareExchange(void **ppDest, void *pExch, void *pComp)
{
#if defined(_X86_)
    _asm {
        mov     ecx,ppDest
        mov     edx,pExch
        mov     eax,pComp
        lock    cmpxchg [ecx],edx
    }
#else
    return InterlockedCompareExchangePointer(ppDest, pExch, pComp);
#endif
}

#pragma warning(default:4035)

#define REGSTR_PATH_POLICIESW    L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies"

STDAPI_(DWORD) SHRestrictionLookup(INT rest, LPCWSTR pszBaseKey, const SHRESTRICTIONITEMS *pRestrictions,
                                   DWORD* pdwRestrictionItemValues)
{
    int i;
    DWORD dw = 0;

    //
    // Loop through the restrictions
    //
    for (i=0; pRestrictions[i].pszKey; i++)
    {
        if (rest == pRestrictions[i].iFlag)
        {
            dw = pdwRestrictionItemValues[i];

            // Has this restriction been initialized yet?
            //
            if (dw == -1)
            {
                dw = SHGetRestriction(pszBaseKey, pRestrictions[i].pszKey, pRestrictions[i].pszValue);
                pdwRestrictionItemValues[i] = dw;
            }

            // Got the restriction we needed. Get out of here.
            break;
        }
    }

    return dw;

}

STDAPI_(DWORD) SHGetRestriction(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszRestriction)
{
    // Make sure the string is long enough to hold longest one...
    COMPILETIME_ASSERT(MAX_PATH > ARRAYSIZE(REGSTR_PATH_POLICIESW) + 40); // PathCombine *assumes* MAX_PATH
    WCHAR szSubKey[MAX_PATH];
    DWORD dwSize;

    // A sensible default
    DWORD dw = 0;

    //
    // This restriction hasn't been read yet.
    //
    if (!pszBaseKey) 
    {
        pszBaseKey = REGSTR_PATH_POLICIESW;
    }
    PathCombineW(szSubKey, pszBaseKey, pszGroup);

    // Check local machine first and let it override what the
    // HKCU policy has done.
    dwSize = sizeof(dw);
    if (ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE,
                                     szSubKey, pszRestriction,
                                     NULL, &dw, &dwSize))
    {
        // Check current user if we didn't find anything for the local machine.
        dwSize = sizeof(dw);
        SHGetValueW(HKEY_CURRENT_USER,
                    szSubKey, pszRestriction,
                    NULL, &dw, &dwSize);
    }

    return dw;
}


//  WhichPlatform
//      Determine if we're running on integrated shell or browser-only.

STDAPI_(UINT) WhichPlatform(void)
{
    HINSTANCE hinst;

    // Cache this info
    static UINT uInstall = PLATFORM_UNKNOWN;

    if (uInstall != PLATFORM_UNKNOWN)
        return uInstall;

    // Not all callers are linked to SHELL32.DLL, so we must use LoadLibrary.
    hinst = LoadLibraryA("SHELL32.DLL");
    if (hinst)
    {
        DWORD fValue;
        DWORD cbSize = sizeof(fValue);
        HKEY hKey;
        LONG lRes;

        // NOTE: GetProcAddress always takes ANSI strings!
        DLLGETVERSIONPROC pfnGetVersion =
            (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");

        uInstall = (NULL != pfnGetVersion) ? PLATFORM_INTEGRATED : PLATFORM_BROWSERONLY;

        // check that the registry reflects the right value... (this is so iexplore can check efficiently)
        lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"),
                            0, KEY_READ | KEY_WRITE, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = RegQueryValueEx(hKey, REGVAL_INTEGRATEDBROWSER,
                                    NULL, NULL,
                                    (LPBYTE) &fValue, &cbSize);

            if (lRes == ERROR_SUCCESS && uInstall == PLATFORM_BROWSERONLY)
            {
                // remove the value, we are now Browser only release
                RegDeleteValue(hKey, REGVAL_INTEGRATEDBROWSER);
            }
            else if (lRes != ERROR_SUCCESS && uInstall == PLATFORM_INTEGRATED)
            {
                // install the RegValue, we are integrated browser mode...
                fValue = TRUE;
                cbSize = sizeof(fValue);
                RegSetValueEx(hKey, REGVAL_INTEGRATEDBROWSER,
                               (DWORD) NULL, REG_DWORD,
                               (LPBYTE) &fValue, cbSize);
                // ignore the failure, if the key is not present, shdocvw will be loaded and this
                // function called anyway....
            }
            RegCloseKey(hKey);
        }
        else
        {
            // a machine without our regKey,
            TraceMsg(TF_WARNING, "WhichPlatform: failed to open 'HKLM\\Software\\Microsoft\\Internet Explorer'");
        }

        FreeLibrary(hinst);
    }

    return uInstall;
}


// Tray notification window class

CHAR const c_szTrayNotificationClass[] = WNDCLASS_TRAYNOTIFY;

BOOL DoRegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey,
                            LPCSTR pcszPath, LPCWSTR pcwszPath)
{
    BOOL bResult;
    HWND hwndTray;
    ASSERT((NULL != pcszPath) || (NULL != pcwszPath));

    hwndTray = FindWindowA(c_szTrayNotificationClass, 0);

    if (hwndTray)
    {
        if (wOldHotkey)
        {
            SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wOldHotkey, 0);

            TraceMsg(TF_FUNC, "RegisterGlobalHotkey(): Unregistered old hotkey %#04x.", wOldHotkey);
        }

        if (wNewHotkey)
        {
            ATOM atom = (NULL != pcszPath) ?
                            GlobalAddAtomA(pcszPath) :
                            GlobalAddAtomW(pcwszPath);
            ASSERT(atom);
            if (atom)
            {
                SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)atom);
                GlobalDeleteAtom(atom);
            }

            TraceMsg(TF_FUNC, "RegisterGlobalHotkey(): Registered new hotkey %#04x.",wNewHotkey);
        }

        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;

        TraceMsgA(TF_WARNING, "RegisterGlobalHotkey(): Unable to find Tray window of class %s to notify.",
                  c_szTrayNotificationClass);
    }

    return(bResult);
}


BOOL
RegisterGlobalHotkeyW(
    WORD wOldHotkey,
    WORD wNewHotkey,
    LPCWSTR pcwszPath)
{
    ASSERT(IsValidPathW(pcwszPath));

    return DoRegisterGlobalHotkey(wOldHotkey, wNewHotkey, NULL, pcwszPath);
}


BOOL
RegisterGlobalHotkeyA(
    WORD wOldHotkey,
    WORD wNewHotkey,
    LPCSTR pcszPath)
{
    ASSERT(IsValidPathA(pcszPath));

    return DoRegisterGlobalHotkey(wOldHotkey, wNewHotkey, pcszPath, NULL);
}


typedef struct {
    SHDLGPROC pfnDlgProc;
    VOID* pData;
} SHDIALOGDATA;
BOOL_PTR DialogBoxProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SHDIALOGDATA* pdd = (SHDIALOGDATA*)GetWindowPtr(hwnd, DWLP_USER);

    if (uMsg == WM_INITDIALOG) 
    {
        pdd = (SHDIALOGDATA*)lParam;
        SetWindowPtr(hwnd, DWLP_USER, pdd);
        lParam = (LPARAM)pdd->pData;
    }

    if (pdd && pdd->pfnDlgProc) 
    {
        // Must return bResult instead of unconditional TRUE because it
        // might be a WM_CTLCOLOR message.
        BOOL_PTR bResult = pdd->pfnDlgProc(pdd->pData, hwnd, uMsg, wParam, lParam);
        if (bResult)
            return bResult;
    }

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
    {
        int id = GET_WM_COMMAND_ID(wParam, lParam);
        HWND hwndCtrl = GetDlgItem(hwnd, id);
        if ((id != IDHELP) && SendMessage(hwndCtrl, WM_GETDLGCODE, 0, 0) & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON)) 
        {
            EndDialog(hwnd, id);
            return TRUE;
        }
        break;
    }
    }

    return FALSE;
}

STDAPI_(INT_PTR) SHDialogBox(HINSTANCE hInstance, LPCWSTR lpTemplateName,
    HWND hwndParent, SHDLGPROC lpDlgFunc, VOID* lpData)
{
    SHDIALOGDATA dd;
    dd.pfnDlgProc = lpDlgFunc;
    dd.pData = lpData;

    // we currently only support resource id #'s
    ASSERT(IS_INTRESOURCE(lpTemplateName));

    return DialogBoxParam(hInstance, (LPCTSTR)lpTemplateName, hwndParent, DialogBoxProc, (LPARAM)&dd);
}


//---------------------------------------------------------------------------

// NOTE!  SHInvokeDefaultCommand logs the action as user-initiated!

STDAPI SHInvokeDefaultCommand(HWND hwnd, IShellFolder* psf, LPCITEMIDLIST pidlItem)
{
    return SHInvokeCommand(hwnd, psf, pidlItem, NULL);
}

// NOTE!  SHInvokeDefaultCommand logs the action as user-initiated!

STDAPI SHInvokeCommand(HWND hwnd, IShellFolder* psf, LPCITEMIDLIST pidlItem, LPCSTR lpVerb)
{
    HRESULT hr = E_FAIL;
    if (psf)
    {
        IContextMenu *pcm;
        if (SUCCEEDED(psf->GetUIObjectOf(hwnd, 1, &pidlItem, IID_X_PPV_ARG(IContextMenu, 0, &pcm))))
        {
            DWORD dwFlags = CMIC_MASK_FLAG_LOG_USAGE;
            hr = SHInvokeCommandsOnContextMenu(hwnd, NULL, pcm, dwFlags, lpVerb ? &lpVerb : NULL, lpVerb ? 1 : 0);
            pcm->Release();
        }
    }
    return hr;
}

HRESULT SHInvokeCommandOnContextMenu(HWND hwnd, IUnknown* punk, IContextMenu *pcm, DWORD fMask, LPCSTR lpVerb)
{
    return SHInvokeCommandsOnContextMenu(hwnd, punk, pcm, fMask, lpVerb ? &lpVerb : NULL, lpVerb ? 1 : 0);
}

STDAPI SHInvokeCommandsOnContextMenu(HWND hwnd, IUnknown* punk, IContextMenu *pcm, DWORD fMask, const LPCSTR rgszVerbs[], UINT cVerbs)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (pcm)
    {
        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            if (punk)
                IUnknown_SetSite(pcm, punk);

            hr = pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, cVerbs ? 0 : CMF_DEFAULTONLY);
            if (SUCCEEDED(hr)) 
            {
                LPCSTR lpVerb = NULL;

                // set up the default verb case outside the loop
                UINT idCmd = -1;
                if (0 == cVerbs)
                {
                    idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                    if ((UINT)-1 != idCmd)
                        lpVerb = MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                }
                
                UINT i = 0;
                do {
                    if (cVerbs)
                        lpVerb = rgszVerbs[i];

                    // if idCmd == 0, then lpVerb would be Zero. So we need to check to
                    // see if idCmd is not -1.
                    if (lpVerb || idCmd != (UINT)-1)
                    {
                        CMINVOKECOMMANDINFOEX ici = { 0 };

                        ici.cbSize = sizeof(ici);
                        ici.fMask = fMask;
                        ici.hwnd = hwnd;
                        ici.lpVerb = lpVerb;
                        ici.nShow = SW_NORMAL;

                        // shell32 converted ASCII canonical name to Unicode, we do it faster in-line
                        // NOTE: should create an SHAsciiToUnicode function for this...
                        WCHAR szVerbW[128];
                        if (idCmd == (UINT)-1)
                        {
                            WCHAR wch = L'\0';
                            LPCSTR pSrc = lpVerb;
                            LPWSTR pDst = szVerbW;
                            UINT cch = ARRAYSIZE(szVerbW);
                            do {
                                *(LPSTR)&wch = *pSrc++;
                                *pDst++ = wch;
                            } while (wch && (wch <= (WCHAR)127));

                            // all of our calls are ASCII
                            RIPMSG(!wch, "Caller of SHInvokeCommandXXX passed in bogus canonical name");
                            if (!wch)
                            {
                                ici.lpVerbW = szVerbW;
                                ici.fMask |= CMIC_MASK_UNICODE;
                            }
                        }

                        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);

                        if (SUCCEEDED(hr))
                            break;

                        if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED) )
                            break;  // user aborted
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                } while (++i < cVerbs);
            }

            if (punk)
                IUnknown_SetSite(pcm, NULL);

            DestroyMenu(hmenu);
        }
    }

    return hr;
}

HRESULT SHForwardContextMenuMsg(IContextMenu* pcm, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL fAllowICM2)
{
    HRESULT hr = E_FAIL;
    if (pcm)
    {
        IContextMenu3 *pcm3;
        if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3))))
        {
            hr = pcm3->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
            pcm3->Release();
        }
        else if (fAllowICM2)
        {
            IContextMenu2 *pcm2;
            if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm2))))
            {
                hr = pcm2->HandleMenuMsg(uMsg, wParam, lParam);
                pcm2->Release();

                if (plResult)
                    *plResult = 0;

                if (SUCCEEDED(hr))
                    hr = S_FALSE; // so caller knows the return result is bogus
            }
        }
    }
    return hr;
}


int MessageBoxHelper(HINSTANCE hInst, HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzMessage, UINT idTitle, UINT nFlags)
{
    WCHAR wzTitle[MAX_PATH];
    UINT uiResult;

    ULONG_PTR ul;
    HANDLE h = CreateAndActivateContext(&ul);

    EVAL(LoadStringW(hInst, idTitle, wzTitle, ARRAYSIZE(wzTitle)));

    if (hwnd)
        IUnknown_EnableModless(punkEnableModless, TRUE);

    uiResult = MessageBoxW(hwnd, pwzMessage, wzTitle, nFlags);

    if (hwnd)
        IUnknown_EnableModless(punkEnableModless, TRUE);

    DeactivateAndDestroyContext(h, ul);

    return uiResult;
}


int MessageBoxDiskHelper(HINSTANCE hInst, HWND hwnd, IUnknown *punkEnableModless, UINT idMessage, UINT idTitle, UINT nFlags, BOOL fDrive, DWORD dwDrive)
{
    WCHAR wzMessage[MAX_PATH];

    EVAL(LoadStringW(hInst, idMessage, wzMessage, ARRAYSIZE(wzMessage)));

    if (fDrive)
    {
        WCHAR wzTemp[MAX_PATH];

        wnsprintfW(wzTemp, ARRAYSIZE(wzTemp), wzMessage, dwDrive);
        StrCpyNW(wzMessage, wzTemp, ARRAYSIZE(wzMessage));
    }

    return MessageBoxHelper(hInst, hwnd, punkEnableModless, wzMessage, idTitle, nFlags);
}

BOOL DoMediaPrompt(HWND hwnd, IUnknown *punkEnableModless, int nDrive, LPCWSTR pwzDrive, BOOL fOfferToFormat, DWORD dwError, UINT wFunc, BOOL * pfRetry)
{
    BOOL fDiskHasMedia = TRUE;  // Assume yes
    *pfRetry = FALSE;

    TraceMsg(TF_FUNC, "DOS Extended error %X", dwError);

    // FEATURE, flash (ROM?) drives return a different error code here
    // that we need to map to not formatted, talk to robwi...

    // Is it true that it's not ready or we can't format it?
    if ((dwError == ERROR_NOT_READY) || !fOfferToFormat)
    {
        // Yes, so do the disk insert w/o offering to format.
        fDiskHasMedia = FALSE;

        // drive not ready (no disk in the drive)
        if (hwnd &&
            (IDRETRY == MessageBoxDiskHelper(HINST_THISDLL,
                                             hwnd,
                                             punkEnableModless,
                                             IDS_DRIVENOTREADY,
                                             (IDS_FILEERROR + wFunc),
                                             (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_RETRYCANCEL),
                                             TRUE,
                                             (DWORD)(nDrive + TEXT('A')))))
        {
            *pfRetry = TRUE;    // The user wants to try again, bless their heart.
        }
        else
        {
            // The user was informed that media isn't present and they basically
            // informed us to cancel the operation.
            *pfRetry = FALSE;
        }
    }
    else if ((dwError == ERROR_GEN_FAILURE)         ||
             (dwError == ERROR_UNRECOGNIZED_MEDIA)  ||
             (dwError == ERROR_UNRECOGNIZED_VOLUME))
    {
        // general failue (disk not formatted)

        if (hwnd &&
            (MessageBoxDiskHelper(HINST_THISDLL,
                                  hwnd,
                                  punkEnableModless,
                                  IDS_UNFORMATTED,
                                  (IDS_FILEERROR + wFunc),
                                  (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_YESNO),
                                  TRUE,
                                  (DWORD)(nDrive + TEXT('A'))) == IDYES))
        {
            if (hwnd)
            {
                IUnknown_EnableModless(punkEnableModless, FALSE);
            }

            UINT uiFormat = SHFormatDrive(hwnd, nDrive, SHFMT_ID_DEFAULT, 0);
            if (hwnd)
            {
                IUnknown_EnableModless(punkEnableModless, TRUE);
            }

            switch (uiFormat)
            {
            case SHFMT_CANCEL:
                *pfRetry = FALSE;
                fDiskHasMedia = FALSE;
                break;

            case SHFMT_ERROR:
            case SHFMT_NOFORMAT:
                fDiskHasMedia = FALSE;  // We still don't have a formatted drive
                if (hwnd)
                {
                    MessageBoxDiskHelper(HINST_THISDLL,
                                         hwnd,
                                         punkEnableModless,
                                         IDS_NOFMT,
                                         (IDS_FILEERROR + wFunc), 
                                         (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK),
                                         TRUE,
                                         (DWORD)(nDrive + TEXT('A')));
                    *pfRetry = TRUE;
                }
                else
                {
                    // If we can't display UI, no need to try again.
                    *pfRetry = FALSE;
                }
                break;

            default:
                // Disk should now be formatted, verify
                *pfRetry = TRUE;
                fDiskHasMedia = TRUE;
                break;
            }
        }
        else
        {
            *pfRetry = FALSE;   // If we can't display UI, or no need to try again.
            fDiskHasMedia = FALSE;  // The user either wasn't given the option of formatting or decided not to format.
        }
    }
    else
    {
        if (hwnd)
        {
            MessageBoxDiskHelper(HINST_THISDLL, hwnd, punkEnableModless, IDS_NOSUCHDRIVE, (IDS_FILEERROR + wFunc),
                        (MB_SETFOREGROUND | MB_ICONHAND), TRUE, (DWORD)(nDrive + TEXT('A')));
            *pfRetry = FALSE;
            fDiskHasMedia = FALSE;
        }
        else
        {
            *pfRetry = FALSE;
            fDiskHasMedia = FALSE;
        }
    }

    return fDiskHasMedia;
}


BOOL CheckDiskForMedia(HWND hwnd, IUnknown *punkEnableModless, int nDrive, LPCWSTR pwzDrive, UINT wFunc, BOOL * pfRetry)
{
    BOOL fDiskHasMedia = TRUE;  // Assume yes because of the fall thru case. (Path Exists)

    *pfRetry = FALSE;   // If we fall thru and the destination path exists, don't retry.

    // REARCHITECT, we need to do the find first here instead of GetCurrentDirectory()
    // because redirected devices (network, cdrom) do not actually hit the disk
    // on the GetCurrentDirectory() call (dos busted)

    // Is it a CD-ROM Drive?
    if (RealDriveType(nDrive, FALSE) == DRIVE_CDROM)
    {
        // Is the CD not in and the caller wants UI?
        if (!PathFileExistsW(pwzDrive) && hwnd)
            fDiskHasMedia = DoMediaPrompt(hwnd, punkEnableModless, nDrive, pwzDrive, wFunc, FALSE, GetLastError(), pfRetry);
    }
    else
    {
        int iIsNet;

        // Is this some kind of net drive?
        if ((DriveType(nDrive) != DRIVE_FIXED) && (FALSE != (iIsNet = IsNetDrive(nDrive))))
        {
            // Yes, so see if the connection still exists.
            if (iIsNet == 1)
            {
                // Yes, it exists so we are done.
                *pfRetry = FALSE;
                fDiskHasMedia = TRUE;
            }
            else
            {
                // No, so try to restore the connection.
                DWORD dwError = WNetRestoreConnectionW(hwnd, pwzDrive);

                if (dwError != WN_SUCCESS)
                {
                    // Restoring the connection failed, so prepare to tell the 
                    // caller the bad news and then display UI to the user if appropriate.
                    *pfRetry = FALSE;
                    fDiskHasMedia = TRUE;

                    if (!(dwError == WN_CANCEL || dwError == ERROR_CONTINUE) && hwnd)
                    {
                        WCHAR wzMessage[128];

                        WNetGetLastErrorW(&dwError, wzMessage, ARRAYSIZE(wzMessage), NULL, 0);
                        IUnknown_EnableModless(punkEnableModless, FALSE);   // Cover me, I'm going to do UI
                        MessageBoxHelper(HINST_THISDLL, hwnd, punkEnableModless, wzMessage, (IDS_FILEERROR + wFunc),
                                        (MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND));
                        IUnknown_EnableModless(punkEnableModless, TRUE);
                    }
                }
                else
                {
                    // Restoring the connection worked.
                    *pfRetry = FALSE;
                    fDiskHasMedia = TRUE;
                }
            }
        }
        else
        {
            // No, so see if it's a floppy or unformatted drive.

            // Is the destination reachable?
            if (!PathFileExistsW(pwzDrive))
            {
                // No so ask the user about formatting or inserting the media.
                fDiskHasMedia = DoMediaPrompt(hwnd, punkEnableModless, nDrive, pwzDrive, TRUE, GetLastError(), wFunc, pfRetry);
            }
            else
            {
                ASSERT(FALSE == *pfRetry);      // Make sure the defaults are still true.
                ASSERT(TRUE == fDiskHasMedia);
            }
        }
    }

    return fDiskHasMedia;
}


// FUNCTION: SHCheckDiskForMedia
//
// DESCRIPTION:
// note: this has the side effect of setting the
// current drive to the new disk if it is successful
//
// The default impl being ansi isn't very good, but we need to 
// see if the unicode versions of the WNet APIs are impl on Win95.
//
// PARAMETERS:
// hwnd - NULL means no UI will be displayed.  Non-NULL means
// punkEnableModless - Make caller modal during UI. (OPTIONAL)
// pszPath - Path that needs verification.
// wFunc - Type of operation (FO_MOVE, FO_COPY, FO_DELETE, FO_RENAME - shellapi.h)
//
// Keep the return value a strict TRUE/FALSE because some callers rely on it.
BOOL SHCheckDiskForMediaW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, UINT wFunc)
{
    BOOL fDiskHasMedia = FALSE;  // Assume yes
    int nDrive = PathGetDriveNumberW(pwzPath);

    ASSERT(nDrive != -1);       // should not get a UNC here

    if (nDrive != -1)   // not supported on UNCs
    {
        WCHAR wzDrive[10];
        PathBuildRootW(wzDrive, nDrive);
        BOOL fKeepRetrying;

        do
        {
            fDiskHasMedia = CheckDiskForMedia(hwnd, punkEnableModless, nDrive, wzDrive, wFunc, &fKeepRetrying);          
        }
        while (fKeepRetrying);
    }
    return fDiskHasMedia;
}

BOOL SHCheckDiskForMediaA(HWND hwnd, IUnknown *punkEnableModless, LPCSTR pszPath, UINT wFunc)
{
    WCHAR wzPath[MAX_PATH];

    SHAnsiToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
    return SHCheckDiskForMediaW(hwnd, punkEnableModless, wzPath, wFunc);
}

HRESULT _FaultInIEFeature(HWND hwnd, uCLSSPEC *pclsspec, QUERYCONTEXT *pQ, DWORD dwFlags);

struct HELPCONT_FILE 
{
    const   CHAR *pszFile;
    int     nLength;
} g_helpConts[] =
{
{ "iexplore.chm", ARRAYSIZE("iexplore.chm") - 1 },
{ "iexplore.hlp", ARRAYSIZE("iexplore.hlp") - 1 },
{ "update.chm", ARRAYSIZE("update.chm") - 1 },
{ "update.cnt", ARRAYSIZE("update.cnt") - 1 },
{ "users.chm", ARRAYSIZE("users.chm") - 1 },
{ "users.hlp", ARRAYSIZE("users.hlp") - 1 },
{ "accessib.chm", ARRAYSIZE("accessib.chm") - 1 },
{ "ieeula.chm", ARRAYSIZE("ieeula.chm") - 1 },
{ "iesupp.chm", ARRAYSIZE("iesupp.chm") - 1 },
{ "msnauth.hlp", ARRAYSIZE("msnauth.hlp") - 1 },
{ "ratings.chm", ARRAYSIZE("ratings.chm") - 1 },
{ "ratings.hlp", ARRAYSIZE("ratings.hlp") - 1 }
};

HRESULT _JITHelpFileA(HWND hwnd, LPCSTR pszPath)
{
    if (!pszPath)
        return S_OK;

    HRESULT hr = S_OK;
    BOOL bMustJIT = FALSE;
    CHAR *pszFile = PathFindFileName(pszPath);
  
    for (int i = 0; i < ARRAYSIZE(g_helpConts); i++)
    {
        if (StrCmpNIA(g_helpConts[i].pszFile, pszFile, g_helpConts[i].nLength) == 0)
        {
            bMustJIT = TRUE;
            break;
        }
    }

    if (bMustJIT)
    {
        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };
        
        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_IEHelp;

        hr = _FaultInIEFeature(hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
    }

    return hr;
}

HRESULT _JITHelpFileW(HWND hwnd, LPCWSTR pwszFile)
{
    if (!pwszFile)
        return S_OK;

    CHAR szFile[MAX_PATH];

    SHUnicodeToAnsi(pwszFile, szFile, ARRAYSIZE(szFile));

    return _JITHelpFileA(hwnd, szFile);
}

BOOL _JITSetLastError(HRESULT hr)
{
    DWORD err;
    
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        err = HRESULT_CODE(hr);
    }
    else if (hr == E_ACCESSDENIED)
    {
        err = ERROR_ACCESS_DENIED;
    }
    else
    {
        err = ERROR_FILE_NOT_FOUND;
    }

    SetLastError(err);

    return FALSE;
}

HWND SHHtmlHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML)
{
    return SUCCEEDED(_JITHelpFileW(hwnd, pszFile)) ?
                (bUseML ? MLHtmlHelpW(hwnd, pszFile, uCommand, dwData, dwCrossCodePage) : 
                          HtmlHelpW(hwnd, pszFile, uCommand, dwData)) :
                NULL;
}

HWND SHHtmlHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML)
{
    return SUCCEEDED(_JITHelpFileA(hwnd, pszFile)) ?
                (bUseML ? MLHtmlHelpA(hwnd, pszFile, uCommand, dwData, dwCrossCodePage) : 
                          HtmlHelpA(hwnd, pszFile, uCommand, dwData)) :
                NULL;
}

BOOL SHWinHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML)
{
    HRESULT hr;
    return SUCCEEDED(hr = _JITHelpFileW(hwnd, pszFile)) ?
                (WinHelpW(hwnd, pszFile, uCommand, dwData)) :
                _JITSetLastError(hr);
}

BOOL SHWinHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML)
{
    HRESULT hr;
    return SUCCEEDED(hr = _JITHelpFileA(hwnd, pszFile)) ?
                (WinHelpA(hwnd,pszFile, uCommand, dwData)) :
                _JITSetLastError(hr);
}



/*****************************************************************************\
    FUNCTION: SHPersistDataObject

    DESCRIPTION:
        This funciton exists for IDataObjects that don't want OLE to use the
    default IDataObject implementation if OleFlushClipboard is called.
    How to use:
    1. This function should be called when the IDataObject::GetData() method
       is called with (FORMATETC.cfFormat ==
       RegisterClipboardFormat(CFSTR_PERSISTEDDATAOBJECT)).
    2. OleFlushClipboard copies pMedium to it's own implementation of IDataObject
       which doesn't work with the lindex parameter of FORMATETC or for private interfaces.
    3. OLE or the IDropTarget calls SHLoadPersistedDataObject().  The first
       param will be OLE's IDataObject impl, and the second param (out param)
       will be the original IDataObject.  The new IDataObject will contains
       the original state as long as it correctly implemented IPersistStream.

    PARAMETERS:
        pdoToPersist - This is the original IDataObject that implements IPersistStream.
        pMedium - This is contain the persisted state of this object.
                  CFSTR_PERSISTEDDATAOBJECT can be used to read the data.
\*****************************************************************************/
#define SIZE_PERSISTDATAOBJECT  (10 * 1024)

STDAPI SHPersistDataObject(/*IN*/ IDataObject * pdoToPersist, /*OUT*/ STGMEDIUM * pMedium)
{
    HRESULT hr = E_NOTIMPL;

    // We shipped IE 5.0 RTM with this and SHLoadPersistedDataObject().  We removed
    // the code after the OLE32.DLL guys moved the functionality into ole32.dll.
    // See the "OleClipboardPersistOnFlush" clipboard format.
    return hr;
}


/*****************************************************************************\
    FUNCTION: SHLoadPersistedDataObject

    DESCRIPTION:
        This funciton exists for IDataObjects that don't want OLE to use the
    default IDataObject implementation if OleFlushClipboard is called.
    How to use:
    1. SHPersistDataObject() was called when the IDataObject::GetData() method
       is called with (FORMATETC.cfFormat == RegisterClipboardFormat(CFSTR_PERSISTEDDATAOBJECT)).
    2. OleFlushClipboard copies pMedium to it's own implementation of IDataObject
       which doesn't work with the lindex parameter of FORMATETC or for private interfaces.
    3. OLE or the IDropTarget calls SHLoadPersistedDataObject().  The first
       param will be OLE's IDataObject impl, and the second param (out param)
       will be the original IDataObject.  The new IDataObject will contains
       the original state as long as it correctly implemented IPersistStream.

    PARAMETERS:
        pdo - This is OLE's IDataObject.
        ppdoToPersist - This is the original IDataObject or equal to pdo if
                        un-serializing the object didn't work.  It always has
                        it's own ref.
\*****************************************************************************/
STDAPI SHLoadPersistedDataObject(/*IN*/ IDataObject * pdo, /*OUT*/ IDataObject ** ppdoToPersist)
{
    // See SHPersistDataObject() for details
    return pdo->QueryInterface(IID_PPV_ARG(IDataObject, ppdoToPersist));
}

#ifndef SMTO_NOTIMEOUTIFNOTHUNG
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008
#endif

LWSTDAPI_(LRESULT) SHSendMessageBroadcastA(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ULONG_PTR lres = 0;
    DWORD dwFlags = SMTO_ABORTIFHUNG;

    dwFlags |= SMTO_NOTIMEOUTIFNOTHUNG;

    SendMessageTimeoutA(HWND_BROADCAST, uMsg, wParam, lParam, dwFlags, 30 * 1000, &lres);

    return (LRESULT) lres;
}

LWSTDAPI_(LRESULT) SHSendMessageBroadcastW(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ULONG_PTR lres = 0;
    DWORD dwFlags = SMTO_ABORTIFHUNG;

    dwFlags |= SMTO_NOTIMEOUTIFNOTHUNG;

    SendMessageTimeoutW(HWND_BROADCAST, uMsg, wParam, lParam, dwFlags, 30 * 1000, &lres);

    return (LRESULT) lres;
}

#define MODULE_NAME_SIZE    128
#define MODULE_VERSION_SIZE  15

//
//  If version is NULL, then we do it for all versions of the app.
//
//  If version begins with MAJORVERSION, then we check only the major version.
//  (CH_MAJORVERSION is the char version of same.)
//
#define MAJORVERSION TEXT("\1")
#define CH_MAJORVERSION TEXT('\1')

typedef struct tagAPPCOMPAT
{
    LPCTSTR pszModule;
    LPCTSTR pszVersion;
    DWORD  dwFlags;
} APPCOMPAT, *LPAPPCOMPAT;

typedef struct tagAPPCLASS
{
    LPCTSTR pstzWndClass;
    DWORD   dwFlags;
} APPCLASS, *LPAPPCLASS;

typedef struct tagWNDDAT
{
    const APPCLASS *rgAppClass;
    DWORD      cAppClass;
    DWORD      dwPid;
    int        irgFound;
} WNDDAT, *LPWNDDAT;


BOOL CALLBACK EnumWnd (HWND hwnd, LPARAM lParam)
{
    TCHAR sz[256];
    DWORD dwPid;
    int cch;
    LPWNDDAT pwd = (LPWNDDAT) lParam;

    if (GetClassName (hwnd, sz, ARRAYSIZE(sz)))
    {
        cch = lstrlen (sz);
        for (DWORD irg = 0; irg < pwd->cAppClass; irg++)
        {
            ASSERT(lstrlen(&(pwd->rgAppClass[irg].pstzWndClass[1])) == (int) pwd->rgAppClass[irg].pstzWndClass[0]);
            if (lstrncmp (sz, &(pwd->rgAppClass[irg].pstzWndClass[1]),
                 min(cch, (int) pwd->rgAppClass[irg].pstzWndClass[0])) == 0)
            {
                GetWindowThreadProcessId(hwnd, &dwPid);
                if (dwPid == pwd->dwPid)
                {
                    pwd->irgFound = irg;
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}

BOOL _IsAppCompatVersion(LPTSTR szModulePath, LPCTSTR pszVersionMatch)
{
    if (pszVersionMatch == NULL)            // Wildcard - match all versions
    {
        return TRUE;
    }
    else
    {
        CHAR  chBuffer[4096]; // hopefully this is enough... Star Office 5 requires 3172
        TCHAR* pszVersion = NULL;
        UINT  cb;
        DWORD  dwHandle;

        // get module version here!
        //
        //  Some apps use codepage 0x04E4 (1252 = CP_USASCII) and some use
        //  codepage 0x04B0 (1200 = CP_UNICODE).
        //
        // ...and then Star Office 5.00 uses 0407 instead of 0409.
        // ...and then recycle.exe uses 041D Swedish

        cb = GetFileVersionInfoSize(szModulePath, &dwHandle);
        if (cb <= ARRAYSIZE(chBuffer) &&
            GetFileVersionInfo(szModulePath, dwHandle, ARRAYSIZE(chBuffer), (void *)chBuffer) &&
            (VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\040904E4\\ProductVersion"), (void **) &pszVersion, &cb) ||
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\040704E4\\ProductVersion"), (void **) &pszVersion, &cb) ||
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\040904B0\\ProductVersion"), (void **) &pszVersion, &cb) ||
             //The following 040900000 was added for SnapShot.exe
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\04090000\\ProductVersion"), (void **) &pszVersion, &cb) ||
             VerQueryValue((void *)chBuffer, TEXT("\\StringFileInfo\\041D04B0\\ProductVersion"), (void **) &pszVersion, &cb)))
        {
            DWORD_PTR cchCmp = 0;
            if (pszVersionMatch[0] == CH_MAJORVERSION)
            {
                // Truncate at the first comma or period
                LPTSTR pszTemp = StrChr(pszVersion, TEXT(','));
                if (pszTemp)
                    *pszTemp = 0;

                pszTemp = StrChr(pszVersion, TEXT('.'));
                if (pszTemp)
                    *pszTemp = 0;

                pszVersionMatch++;
            }
            else
            {
                TCHAR *pch = StrChr(pszVersionMatch, TEXT('*'));
                if (pch)
                {
                    cchCmp = pch - pszVersionMatch;
                }
            }

            if ((cchCmp && StrCmpNI(pszVersion, pszVersionMatch, (int)cchCmp) == 0)
            || lstrcmpi(pszVersion, pszVersionMatch) == 0)
            {
                DebugMsg(TF_ALWAYS, TEXT("%s ver %s - compatibility hacks enabled"), PathFindFileName(szModulePath), pszVersion);
                return TRUE;
            }
        }
    }
    return FALSE;
}

typedef struct {
    DWORD flag;
    LPCTSTR psz;
} FLAGMAP;

DWORD _GetMappedFlags(HKEY hk, const FLAGMAP *pmaps, DWORD cmaps)
{
    DWORD dwRet = 0;
    for (DWORD i = 0; i < cmaps; i++)
    {
        if (NOERROR == SHGetValue(hk, NULL, pmaps[i].psz, NULL, NULL, NULL))
            dwRet |= pmaps[i].flag;
    }

    return dwRet;
}

#define ACFMAPPING(acf)     {ACF_##acf, TEXT(#acf)}

DWORD _GetRegistryCompatFlags(LPTSTR pszModulePath)
{
    DWORD dwRet = 0;
    LPCTSTR pszModule = PathFindFileName(pszModulePath);
    TCHAR sz[MAX_PATH];
    HKEY hkApp;

    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Applications\\%s"), pszModule);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkApp))
    {
        // Convert the module path into a directory so we can PathCombine it
        TCHAR szDir[MAX_PATH];
        lstrcpyn(szDir, pszModulePath, ARRAYSIZE(szDir));
        PathRemoveFileSpec(szDir);


        //
        //  HEADSUP!  Strange loop ahead!
        //
        //  We want the first RegOpenKeyEx to pass sz = NULL (so we look
        //  inside hkApp directly), and subsequent RegOpenKeyEx calls to
        //  pass the name of a subkey (so we look inside the subkeys).
        //
        //  So the first time through the loop, we set sz = NULL.
        //  At the bottom of the loop, we set sz = Next Enumerated Key.

        sz[0] = TEXT('\0');     /* Preinitialize for first iteration */
        DWORD dwIndex = 0;

        do {
            HKEY hkSub;
            if (ERROR_SUCCESS == RegOpenKeyEx(hkApp, sz, 0, KEY_QUERY_VALUE, &hkSub))
            {
                LPCTSTR pszValue;
                DWORD dw = sizeof(sz);

                if (NOERROR == SHGetValue(hkSub, NULL, TEXT("RequiredFile"), NULL, sz, &dw))
                {
                    pszValue = PathCombine(sz, szDir, sz);
                }
                else
                    pszValue = NULL;

                // If no RequiredFile or RequiredFile exists...
                if (pszValue == NULL || GetFileAttributes(pszValue) != 0xFFFFFFFF)
                {
                    if (NOERROR == SHGetValue(hkSub, NULL, TEXT("Version"), NULL, sz, &dw))
                        pszValue = sz;
                    else
                        pszValue = NULL;

                    if (_IsAppCompatVersion(pszModulePath, pszValue))
                    {
                        static const FLAGMAP rgAcfMaps[] = {
                            ACFMAPPING(CONTEXTMENU),
                            ACFMAPPING(CORELINTERNETENUM),
                            ACFMAPPING(OLDCREATEVIEWWND),
                            ACFMAPPING(WIN95DEFVIEW),
                            ACFMAPPING(DOCOBJECT),
                            ACFMAPPING(FLUSHNOWAITALWAYS),
                            ACFMAPPING(MYCOMPUTERFIRST),
                            ACFMAPPING(OLDREGITEMGDN),
                            ACFMAPPING(LOADCOLUMNHANDLER),
                            ACFMAPPING(ANSI),
                            ACFMAPPING(STAROFFICE5PRINTER),
                            ACFMAPPING(NOVALIDATEFSIDS),
                            ACFMAPPING(WIN95SHLEXEC),
                            ACFMAPPING(FILEOPENNEEDSEXT),
                            ACFMAPPING(WIN95BINDTOOBJECT),
                            ACFMAPPING(IGNOREENUMRESET),
                            ACFMAPPING(ANSIDISPLAYNAMES),
                            ACFMAPPING(FILEOPENBOGUSCTRLID),
                            ACFMAPPING(FORCELFNIDLIST),
                        };

                        dwRet |= _GetMappedFlags(hkSub, rgAcfMaps, ARRAYSIZE(rgAcfMaps));
                    }
                }

                RegCloseKey(hkSub);
            }
        } while (ERROR_SUCCESS == RegEnumKey(hkApp, dwIndex++, sz, ARRAYSIZE(sz)));

        RegCloseKey(hkApp);
    }

    return dwRet;
}
        
DWORD SHGetAppCompatFlags (DWORD dwFlagsNeeded)
{
    static BOOL  bInitialized = FALSE;
    static DWORD dwCachedProcessFlags = 0;
    static const APPCOMPAT aAppCompat[] = 
    {
        {TEXT("WPWIN7.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM},
        {TEXT("PRWIN70.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM},
        {TEXT("PS80.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("QPW.EXE"), MAJORVERSION TEXT("7"), ACF_CONTEXTMENU},
        {TEXT("QFINDER.EXE"), NULL, ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("PFIM80.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("UA80.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("PDXWIN32.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("SITEBUILDER.EXE"), NULL, ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("HOTDOG4.EXE"), NULL, ACF_DOCOBJECT},
        {TEXT("RNAAPP.EXE"), NULL, ACF_FLUSHNOWAITALWAYS},

        //
        //  PDEXPLO.EXE version "2, 0, 2, 0" requires ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST
        //  PDEXPLO.EXE version "1, 0, 0, 0" requires ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST
        //  PDEXPLO.EXE version "3, 0, 0, 1" requires                   ACF_MYCOMPUTERFIRST
        //  PDEXPLO.EXE version "3, 0, 3, 0" requires                   ACF_MYCOMPUTERFIRST
        //
        //  So I'm just going to key off the major versions.
        //
        {TEXT("PDEXPLO.EXE"), MAJORVERSION TEXT("2"), ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST},
        {TEXT("PDEXPLO.EXE"), MAJORVERSION TEXT("1"), ACF_CONTEXTMENU | ACF_MYCOMPUTERFIRST},
        {TEXT("PDEXPLO.EXE"), MAJORVERSION TEXT("3"), ACF_MYCOMPUTERFIRST | ACF_OLDREGITEMGDN},

        // SIZEMGR.EXE is part of the PowerDesk 98 suite, so we also key off
        // only the major version
        {TEXT("SIZEMGR.EXE"), MAJORVERSION TEXT("3"), ACF_OLDCREATEVIEWWND | ACF_OLDREGITEMGDN},

        {TEXT("SMARTCTR.EXE"), TEXT("96.0"), ACF_CONTEXTMENU},
        // new programs, old bugs
        {TEXT("WPWIN8.EXE"), NULL, ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},
        {TEXT("PRWIN8.EXE"), NULL, ACF_CORELINTERNETENUM | ACF_OLDREGITEMGDN},

        {TEXT("UE32.EXE"), TEXT("2.00.0.0"), ACF_OLDREGITEMGDN},
        {TEXT("PP70.EXE"),NULL, ACF_LOADCOLUMNHANDLER},
        {TEXT("PP80.EXE"),NULL, ACF_LOADCOLUMNHANDLER},
        {TEXT("PS80.EXE"),NULL, ACF_OLDREGITEMGDN},
        {TEXT("ABCMM.EXE"),NULL,ACF_LOADCOLUMNHANDLER},

        // We've found versions 8.0.0.153 and 8.0.0.227, so just use 8.*
        {TEXT("QPW.EXE"), MAJORVERSION TEXT("8"), ACF_CORELINTERNETENUM | ACF_OLDCREATEVIEWWND | ACF_OLDREGITEMGDN | ACF_ANSIDISPLAYNAMES },

        {TEXT("CORELDRW.EXE"), MAJORVERSION TEXT("7"), ACF_OLDREGITEMGDN},
        {TEXT("FILLER51.EXE"), NULL, ACF_OLDREGITEMGDN},
        
        //For Win95 and Win98
        {TEXT("AUTORUN.EXE"), TEXT("4.10.1998"),ACF_ANSI},
        {TEXT("AUTORUN.EXE"), TEXT("4.00.950"),ACF_ANSI},

        //Powerpoint
        {TEXT("POWERPNT.EXE"), MAJORVERSION TEXT("8"), ACF_WIN95SHLEXEC},

        //  msmoney
        {TEXT("MSMONEY.EXE"), TEXT("7.05.1107"), ACF_WIN95SHLEXEC},
        
        //Star Office 5.0
        {TEXT("soffice.EXE"), MAJORVERSION TEXT("5"), ACF_STAROFFICE5PRINTER},

        // All of the "Corel WordPerfect Office 2000" suite apps need ACF_WIN95DEFVIEW. Since the shipping
        // version (9.0.0.528) as well as their SR1 release (9.0.0.588) are both broken, we key off 
        // of the major version
        {TEXT("WPWIN9.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},
        {TEXT("QPW.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},
        {TEXT("PRWIN9.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},
        {TEXT("DAD9.EXE"), MAJORVERSION TEXT("9"), ACF_WIN95DEFVIEW},

        //
        //  WARNING DONT ADD NEW COMPATIBILITY HERE - ZekeL - 18-OCT-99
        //  Add new entries to the registry.  each component 
        //  that needs compatibility flags should register 
        //  during selfregistration.  (see the RegExternal
        //  section of selfreg.inx in shell32 for an example.)  
        //  all new flags should be added to the FLAGMAP array.
        //
        //  the register under:
        //  HKLM\SW\MS\Win\CV\ShellCompatibility\Applications
        //      \App.exe
        //          RequiredFile="OtherFile.dat" // optional
        //          Version = "1.0.0.1"  or "1.*" // version of App.exe
        //          //  NOTE version supports basic pattern matching,
        //          //  but doesnt currently support multiple versions
        //          //  for multiple versions, see below
        //          FLAGNAME    //  requires no value
        //
        //  If a RequiredFile is present, then it is PathCombine'd with
        //  the directory that App.exe is in and checked for existence.
        //  The file must exist for the app compat flag to be used.
        //  RequiredFile is strongly recommended to avoid false positives.
        //
        //  If the app name is generic (like "setup.exe" or "install.exe")
        //  then you must use the RequiredFile method to ensure
        //  that the app compat flag fires only for the app you care about.
        //
        //  To accomodate multiple entries for one EXE name (e.g., the
        //  multiple versions problem described above), we will
        //  also look inside all subdirectories of Applications\App.exe
        //  for a matching app compat flag.
        //
        //  For example, Starcraft 1.03 INSTALL.EXE uses this key layout:
        //
        //  HKLM\SW\MS\Win\CV\ShellCompatibility\Applications
        //      \install.exe            (name of exe)
        //          \Starcraft 1.03     (arbitrary unique string)
        //              RequiredFile="HELP\STAR.HTM" (unique file on CD)
        //              Version = "1.0.0.1" or "1.*" (same as above)
        //              FLAGNAME (same as above)
        //
    };

    static const APPCLASS aAppClass[] =
    {
            // note that the strings here are stz's....
        {TEXT("\x9""bosa_sdm_"),                           ACF_APPISOFFICE | ACF_STRIPFOLDERBIT},
        {TEXT("\x18""File Open Message Window"),           ACF_APPISOFFICE | ACF_STRIPFOLDERBIT},
    };

    if (dwFlagsNeeded & (ACF_PERPROCESSFLAGS))
    {
        if (!bInitialized)
        {    
          //
          //  Do this only for old apps.
          //
          //  Once an app marks itself as NT5-compatible, we stop doing
          //  NT4/Win5 app hacks for it.
          //
            if (GetProcessVersion(0) < MAKELONG(0, 5))
            {
                TCHAR  szModulePath[MODULE_NAME_SIZE];
                TCHAR* pszModuleName = NULL;
        
                if (GetModuleFileName(GetModuleHandle(NULL), szModulePath, ARRAYSIZE(szModulePath)))
                    pszModuleName = PathFindFileName(szModulePath);
        
                if (pszModuleName)
                {
                    for (int i=0; i < ARRAYSIZE(aAppCompat); i++)
                    {
                        if (lstrcmpi(aAppCompat[i].pszModule, pszModuleName) == 0)
                        {
                            if (_IsAppCompatVersion(szModulePath, aAppCompat[i].pszVersion))
                            {
                                dwCachedProcessFlags = aAppCompat[i].dwFlags;
                                break;
                            }
                        }
                    }

                    dwCachedProcessFlags |= _GetRegistryCompatFlags(szModulePath);
                }
            }
            bInitialized = TRUE;
        }
    }

    if ((dwFlagsNeeded & ACF_PERCALLFLAGS) &&
        !(dwCachedProcessFlags & ACF_KNOWPERPROCESS))
    {
        WNDDAT wd;
        wd.dwPid = GetCurrentProcessId();
        wd.irgFound = -1;
        wd.rgAppClass = aAppClass;
        wd.cAppClass = ARRAYSIZE(aAppClass);
        EnumWindows (EnumWnd, (LPARAM) &wd);

        if (wd.irgFound > -1)
        {
            dwCachedProcessFlags |= (aAppClass[wd.irgFound].dwFlags);
        }
        dwCachedProcessFlags |= ACF_KNOWPERPROCESS;
    }
    
    return dwCachedProcessFlags; 
}

// {9EAC43C0-53EC-11CE-8230-CA8A32CF5494}
//static const GUID GUID_WINAMP = 
//{ 0x9eac43c0, 0x53ec, 0x11ce, { 0x82, 0x30, 0xca, 0x8a, 0x32, 0xcf, 0x54, 0x94} };

// {E9779583-939D-11CE-8A77-444553540000}
static const GUID GUID_AECOZIPARCHIVE = 
{ 0xE9779583, 0x939D, 0x11ce, { 0x8a, 0x77, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };
// {49707377-6974-6368-2E4A-756E6F644A01}
static const GUID CLSID_WS_FTP_PRO_EXPLORER =
{ 0x49707377, 0x6974, 0x6368, {0x2E, 0x4A,0x75, 0x6E, 0x6F, 0x64, 0x4A, 0x01} };
// {49707377-6974-6368-2E4A-756E6F644A0A}
static const GUID CLSID_WS_FTP_PRO =
{ 0x49707377, 0x6974, 0x6368, {0x2E, 0x4A,0x75, 0x6E, 0x6F, 0x64, 0x4A, 0x0A} };
// {2bbbb600-3f0a-11d1-8aeb-00c04fd28d85}
static const GUID CLSID_KODAK_DC260_ZOOM_CAMERA =
{ 0x2bbbb600, 0x3f0a, 0x11d1, {0x8a, 0xeb, 0x00, 0xc0, 0x4f, 0xd2, 0x8d, 0x85} };
// {00F43EE0-EB46-11D1-8443-444553540000}
static const GUID GUID_MACINDOS =
{ 0x00F43EE0, 0xEB46, 0x11D1, { 0x84, 0x43, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };
static const GUID CLSID_EasyZIP = 
{ 0xD1069700, 0x932E, 0x11cf, { 0xAB, 0x59, 0x00, 0x60, 0x8C, 0xBF, 0x2C, 0xE0} };

static const GUID CLSID_PAGISPRO_FOLDER =
{ 0x7877C8E0, 0x8B13, 0x11D0, { 0x92, 0xC2, 0x00, 0xAA, 0x00, 0x4B, 0x25, 0x6F} };
// {61E285C0-DCF4-11cf-9FF4-444553540000}
static const GUID CLSID_FILENET_IDMDS_NEIGHBORHOOD =
{ 0x61e285c0, 0xdcf4, 0x11cf, { 0x9f, 0xf4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

// These guys call CoFreeUnusedLibraries inside their Release() handler, so
// if you are releasing the last object, they end up FreeLibrary()ing
// themselves!

// {b8777200-d640-11ce-b9aa-444553540000}
static const GUID CLSID_NOVELLX =
{ 0xb8777200, 0xd640, 0x11ce, { 0xb9, 0xaa, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

static const GUID CLSID_PGP50_CONTEXTMENU =  //{969223C0-26AA-11D0-90EE-444553540000}
{ 0x969223C0, 0x26AA, 0x11D0, { 0x90, 0xEE, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

static const GUID CLSID_QUICKFINDER_CONTEXTMENU = //  {CD949A20-BDC8-11CE-8919-00608C39D066}
{ 0xCD949A20, 0xBDC8, 0x11CE, { 0x89, 0x19, 0x00, 0x60, 0x8C, 0x39, 0xD0, 0x66} };

static const GUID CLSID_HERCULES_HCTNT_V1001 = // {921BD320-8CB5-11CF-84CF-885835D9DC01}
{ 0x921BD320, 0x8CB5, 0x11CF, { 0x84, 0xCF, 0x88, 0x58, 0x35, 0xD9, 0xDC, 0x01} };

//
// NOTICE - DONT ADD ANYMORE HARDCODED CLSIDS
// add them to the ShellCompatibility key.  register in the client DLL
//

#define OCFMAPPING(ocf)     {OBJCOMPATF_##ocf, TEXT(#ocf)}

DWORD _GetRegistryObjectCompatFlags(REFGUID clsid)
{
    DWORD dwRet = 0;
    TCHAR szGuid[GUIDSTR_MAX];
    TCHAR sz[MAX_PATH];
    HKEY hk;

    SHStringFromGUID(clsid, szGuid, ARRAYSIZE(szGuid));
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Objects\\%s"), szGuid);
    
    if (NOERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hk))
    {   
        static const FLAGMAP rgOcfMaps[] = {
            OCFMAPPING(OTNEEDSSFCACHE),
            OCFMAPPING(NO_WEBVIEW),
            OCFMAPPING(UNBINDABLE),
            OCFMAPPING(PINDLL),
            OCFMAPPING(NEEDSFILESYSANCESTOR),
            OCFMAPPING(NOTAFILESYSTEM),
            OCFMAPPING(CTXMENU_NOVERBS),
            OCFMAPPING(CTXMENU_LIMITEDQI),
            OCFMAPPING(COCREATESHELLFOLDERONLY),
            OCFMAPPING(NEEDSSTORAGEANCESTOR),
            OCFMAPPING(NOLEGACYWEBVIEW),
            };

        dwRet = _GetMappedFlags(hk, rgOcfMaps, ARRAYSIZE(rgOcfMaps));
        RegCloseKey(hk);
    }

    return dwRet;
}

typedef struct _CLSIDCOMPAT
{
    const GUID *pclsid;
    OBJCOMPATFLAGS flags;
}CLSIDCOMPAT, *PCLSIDCOMPAT;

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlags(IUnknown *punk, const CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;
    OBJCOMPATFLAGS ocf = 0;
    CLSID clsid;
    if (punk)
        hr = IUnknown_GetClassID(punk, &clsid);
    else if (pclsid)
    {
        clsid = *pclsid;
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        static const CLSIDCOMPAT s_rgCompat[] =
        {
            {&CLSID_WS_FTP_PRO_EXPLORER,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_PINDLL },
            {&CLSID_WS_FTP_PRO,
                OBJCOMPATF_UNBINDABLE},
            {&GUID_AECOZIPARCHIVE,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_KODAK_DC260_ZOOM_CAMERA,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_PINDLL},
            {&GUID_MACINDOS,
                OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_EasyZIP,            
                OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_PAGISPRO_FOLDER,
                OBJCOMPATF_NEEDSFILESYSANCESTOR},
            {&CLSID_FILENET_IDMDS_NEIGHBORHOOD,
                OBJCOMPATF_NOTAFILESYSTEM},
            {&CLSID_NOVELLX,
                OBJCOMPATF_PINDLL},
            {&CLSID_PGP50_CONTEXTMENU,
                OBJCOMPATF_CTXMENU_LIMITEDQI},
            {&CLSID_QUICKFINDER_CONTEXTMENU,
                OBJCOMPATF_CTXMENU_NOVERBS},
            {&CLSID_HERCULES_HCTNT_V1001,
                OBJCOMPATF_PINDLL},
            //
            //  WARNING DONT ADD NEW COMPATIBILITY HERE - ZekeL - 18-OCT-99
            //  Add new entries to the registry.  each component 
            //  that needs compatibility flags should register 
            //  during selfregistration.  (see the RegExternal
            //  section of selfreg.inx in shell32 for an example.)  
            //  all new flags should be added to the FLAGMAP array.
            //
            //  the register under:
            //  HKLM\SW\MS\Win\CV\ShellCompatibility\Objects
            //      \{CLSID}
            //          FLAGNAME    //  requires no value
            //
            //  NOTE: there is no version checking
            //  but we could add it as the data attached to 
            //  the flags, and compare with the version 
            //  of the LocalServer32 dll.
            //  
            {NULL, 0}
        };

        for (int i = 0; s_rgCompat[i].pclsid; i++)
        {
            if (IsEqualGUID(clsid, *(s_rgCompat[i].pclsid)))
            {
                //  we could check version based
                //  on what is in under HKCR\CLSID\{clsid}
                ocf = s_rgCompat[i].flags;
                break;
            }
        }

        ocf |= _GetRegistryObjectCompatFlags(clsid);

    }

    return ocf;
}

STDAPI IUnknown_ProfferServiceOld(IUnknown *punkSite, REFGUID sidWhere, 
                               REFGUID sidWhat, IServiceProvider *pService, 
                               DWORD *pdwCookie)
{
    IProfferService *pps;
    HRESULT hr = IUnknown_QueryService(punkSite, sidWhere, IID_PPV_ARG(IProfferService, &pps));
    if (SUCCEEDED(hr))
    {
        if (pService)
            hr = pps->ProfferService(sidWhat, pService, pdwCookie);
        else
            hr = pps->RevokeService(*pdwCookie);
        pps->Release();
    }
    return hr;
}


// helper to get up to service provider and to do register/unregister
// two forms:
//      pService != NULL, register, pdwCookie is [out] returns cookie
//      pService == NULL, unregister, *pdwCookie is [in] de-registers the service

STDAPI IUnknown_ProfferService(IUnknown *punkSite,
                               REFGUID sidWhat, IServiceProvider *pService, 
                               DWORD *pdwCookie)
{
    IProfferService *pps;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SProfferService, IID_PPV_ARG(IProfferService, &pps));
    if (SUCCEEDED(hr))
    {
        if (pService)
            hr = pps->ProfferService(sidWhat, pService, pdwCookie);
        else
        {
            hr = pps->RevokeService(*pdwCookie);
            *pdwCookie = 0;
        }
        pps->Release();
    }
    return hr;
}

HRESULT IUnknown_QueryServiceExec(IUnknown* punk, REFGUID guidService, const GUID *guid,
                                 DWORD cmdID, DWORD cmdParam, VARIANT* pvarargIn, VARIANT* pvarargOut)
{
    IOleCommandTarget* poct;
    HRESULT hres = IUnknown_QueryService(punk, guidService, IID_PPV_ARG(IOleCommandTarget, &poct));
    if (SUCCEEDED(hres))
    {
        hres = poct->Exec(guid, cmdID, cmdParam, pvarargIn, pvarargOut);
        poct->Release();
    }

    return hres;
}

HRESULT IUnknown_QueryServicePropertyBag(IUnknown* punk, DWORD dwFlags, REFIID riid, void** ppv)
{
    IShellBrowserService* psbs;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowserService, &psbs));
    if (SUCCEEDED(hr))
    {
        hr = psbs->GetPropertyBag(dwFlags, riid, ppv);

        psbs->Release();
    }

    return hr;
}


HRESULT SHConvertGraphicsFile(IN LPCWSTR pszSourceFile, IN LPCWSTR pszDestFile, IN DWORD dwFlags)
{
    HRESULT hr = S_OK;

    HRESULT hrInit = SHCoInitialize();

    if ((dwFlags & SHCGF_REPLACEFILE) && PathFileExistsW(pszDestFile))
    {
        if (!DeleteFileW(pszDestFile))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        if (PathFileExistsW(pszDestFile))
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
        else
        {
            IShellImageDataFactory * pImgFact;

            hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &pImgFact));
            if (SUCCEEDED(hr))
            {
                GUID guidDontCare;
                hr = pImgFact->GetDataFormatFromPath(pszDestFile, &guidDontCare);
                if (SUCCEEDED(hr))
                {
                    // Open image file
                    IShellImageData * pImage;
                    hr = pImgFact->CreateImageFromFile(pszSourceFile, &pImage);
                    if (SUCCEEDED(hr))
                    {
                        hr = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            // load the file
                            IPersistFile *ppfImg;
                            hr = pImage->QueryInterface(IID_PPV_ARG(IPersistFile, &ppfImg));
                            if (SUCCEEDED(hr))
                            {
                                // saving to a different extention automatically changes the file type
                                hr = ppfImg->Save(pszDestFile, TRUE);
                                ppfImg->Release();
                            }

                        }
                        pImage->Release();
                    }
                }
                pImgFact->Release();
            }
        }
    }
    
    SHCoUninitialize(hrInit);

    return hr;
}

void _ValidateShellNoRoam(HKEY hk)
{
    WCHAR szOld[MAX_COMPUTERNAME_LENGTH + 1] = L"";
    WCHAR szNew[MAX_COMPUTERNAME_LENGTH + 1] = L"";
    DWORD cb = sizeof(szOld);
    SHGetValueW(hk, NULL, NULL, NULL, szOld, &cb);
    cb = ARRAYSIZE(szNew);
    GetComputerNameW(szNew, &cb);
    if (StrCmpICW(szNew, szOld))
    {
        //  need to delete this key's kids
        SHDeleteKey(hk, NULL);
        SHSetValueW(hk, NULL, NULL, REG_SZ, szNew, CbFromCchW(lstrlenW(szNew)+1));
    }
}

void _ValidateMUICache(HKEY hk)
{
    LANGID lidOld = 0;
    //  if we are running on legacy platforms, we aggressively invalidate
    LANGID lidNew = GetUserDefaultUILanguage();
    DWORD cb = sizeof(lidOld);
    SHGetValueW(hk, NULL, L"LangID", NULL, &lidOld, &cb);

    if (lidOld != lidNew)
    {
        SHDeleteKey(hk, NULL);
        SHSetValueW(hk, NULL, L"LangID", REG_BINARY, &lidNew, sizeof(lidNew));
    }
}

typedef void (*PFNVALIDATE)(HKEY);

typedef struct 
{
    LPCWSTR psz;
    DWORD dwOption;
    PFNVALIDATE pfnValidate;
    HKEY hkCU;
    HKEY hkLM;
} SKCACHE;

#define SKENTRY(s)  {s, REG_OPTION_NON_VOLATILE, NULL, NULL, NULL}
#define SKENTRYOPT(s, o)  {s, o, NULL, NULL, NULL}
#define SKENTRYVAL(s, pfnV) {s, REG_OPTION_NON_VOLATILE, pfnV, NULL, NULL}

static SKCACHE s_skPath[] =
{
    SKENTRY(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), 
    SKENTRY(L"Software\\Microsoft\\Windows\\Shell"), 
    SKENTRYVAL(L"Software\\Microsoft\\Windows\\ShellNoRoam", _ValidateShellNoRoam), 
    SKENTRY(L"Software\\Classes"),
};

static SKCACHE s_skSub[] =
{
    SKENTRY(L"LocalizedResourceName"),
    SKENTRY(L"Handlers"),
    SKENTRY(L"Associations"),
    SKENTRYOPT(L"Volatile", REG_OPTION_VOLATILE),
    SKENTRYVAL(L"MUICache", _ValidateMUICache), 
    SKENTRY(L"FileExts"),
};

HKEY _OpenKey(HKEY hk, LPCWSTR psz, BOOL fCreate, DWORD dwOption)
{
    HKEY hkRet = NULL;
    DWORD err;
    if (fCreate && psz)
    {
        DWORD dwDisp;
        err = RegCreateKeyExW(hk, psz, 0, NULL, dwOption, MAXIMUM_ALLOWED, NULL, &hkRet, &dwDisp);
    }
    else
    {
        err = RegOpenKeyExW(hk, psz, 0, MAXIMUM_ALLOWED, &hkRet);
    }

    if (!hkRet)
    {
        //  if ERROR_KEY_DELETED
        //  should we invalidate our cache??
        //  cause we will fail forever...
        SetLastError(err);
    }
        
    return hkRet;
}

HKEY _OpenSKCache(HKEY hk, BOOL fHKLM, BOOL fNoCaching, BOOL fCreateSub, SKCACHE *psk, DWORD *pdwOption)
{
    HKEY hkSub = fHKLM ? psk->hkLM : psk->hkCU;
    *pdwOption = psk->dwOption;

    if (!hkSub || fNoCaching)
    {
        hkSub = _OpenKey(hk, psk->psz, fCreateSub, psk->dwOption);
        if (hkSub)
        {
            if (psk->pfnValidate)
                psk->pfnValidate(hkSub);

            if (!fNoCaching)
            {
                ENTERCRITICAL;
                HKEY *phk = fHKLM ? &psk->hkLM : &psk->hkCU;
                if (!*phk)
                {
                    *phk = hkSub;
                }
                else
                {
                    RegCloseKey(hkSub);
                    hkSub = *phk;
                }
                LEAVECRITICAL;
            }
        }
    }
    return hkSub;
}
    
#define HKEY_FROM_SKROOT(sk)    ((sk & SKROOT_MASK) == SKROOT_HKLM ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER)

HKEY _OpenShellKey(SHELLKEY sk, HKEY hkRoot, BOOL fNoCaching, BOOL fCreateSub, DWORD *pdwOption)
{
    BOOL fHKLM = (sk & SKROOT_MASK) == SKROOT_HKLM;
    ULONG uPath = (sk & SKPATH_MASK) >> 4;
    ULONG uSub = (sk & SKSUB_MASK) >> 12;

    ASSERT(uPath < ARRAYSIZE(s_skPath));
    HKEY hkPath = NULL;
    if (uPath < ARRAYSIZE(s_skPath))
    {
        hkPath = _OpenSKCache(hkRoot, fHKLM, fNoCaching, fCreateSub, &s_skPath[uPath], pdwOption);
    }
    else
        SetLastError(E_INVALIDARG);

    //  see if there is a sub value to add
    if (hkPath && uSub != SKSUB_NONE && --uSub < ARRAYSIZE(s_skSub))
    {
        HKEY hkSub = _OpenSKCache(hkPath, fHKLM, fNoCaching, fCreateSub, &s_skSub[uSub], pdwOption);
        if (fNoCaching)
            RegCloseKey(hkPath);
        hkPath = hkSub;
    }
    
    return hkPath;
}

HKEY _GetRootKey(SHELLKEY sk, BOOL *pfNoCaching)
{
    HKEY hkRoot = HKEY_FROM_SKROOT(sk);
    HANDLE hToken;
    if (hkRoot == HKEY_CURRENT_USER && OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        //  we dont support ARBITRARY tokens
        //  but RegOpenCurrentUser() opens the current thread token
        RegOpenCurrentUser(MAXIMUM_ALLOWED, &hkRoot);
        //  if we wanted to we would have to do something
        //  like shell32!GetUserProfileKey(hToken, &hkRoot);

        CloseHandle(hToken);
    }

    *pfNoCaching = HKEY_FROM_SKROOT(sk) != hkRoot;
    return hkRoot;
}

STDAPI_(HKEY) SHGetShellKey(SHELLKEY sk, LPCWSTR pszSubKey, BOOL fCreateSub)
{
    BOOL fNoCaching;
    HKEY hkRoot = _GetRootKey(sk, &fNoCaching);
    HKEY hkRet = NULL;
    if (hkRoot)
    {
        DWORD dwOption;
        HKEY hkPath = _OpenShellKey(sk, hkRoot, fNoCaching, fCreateSub, &dwOption); 

        //  this duplicates when there is no subkey
        if (hkPath)
        {
            hkRet = _OpenKey(hkPath, pszSubKey, fCreateSub, dwOption);

            if (fNoCaching)
                RegCloseKey(hkPath);
        }

        if (fNoCaching)
            RegCloseKey(hkRoot);
    }
    else
        SetLastError(ERROR_ACCESS_DENIED);

    return hkRet;
}

STDAPI_(void) InitShellKeys(BOOL fInit)
{
    if (!fInit)
    {
        int i;

        //  walk each array and close the cached keys
        for (i = 0; i < ARRAYSIZE(s_skPath); i++)
        {
            if (s_skPath[i].hkCU)
            {
                RegCloseKey(s_skPath[i].hkCU);
                s_skPath[i].hkCU = NULL;
            }

            if (s_skPath[i].hkLM)
            {
                RegCloseKey(s_skPath[i].hkLM);
                s_skPath[i].hkLM = NULL;
            }
        }

        for (i = 0; i < ARRAYSIZE(s_skSub); i++)
        {
            if (s_skSub[i].hkCU)
            {
                RegCloseKey(s_skSub[i].hkCU);
                s_skSub[i].hkCU = NULL;
            }

            if (s_skSub[i].hkLM)
            {
                RegCloseKey(s_skSub[i].hkLM);
                s_skSub[i].hkLM = NULL;
            }
        }
    }
}

STDAPI SKGetValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT DWORD * pdwType,            OPTIONAL
    OUT void *  pvData,             OPTIONAL
    OUT DWORD * pcbData)            OPTIONAL
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, FALSE);
    if (hk)
    {
        DWORD err = SHQueryValueExW(hk, pwszValue, NULL, pdwType, pvData, pcbData);
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SKSetValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,
    IN  DWORD   dwType,
    IN  LPCVOID pvData,
    IN  DWORD   cbData)
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, TRUE);
    if (hk)
    {
        // RegSetValueExW is not supported on Win95 but we have a thunking function.
        DWORD err = RegSetValueExW(hk, pwszValue, 0, dwType, (BYTE *)pvData, cbData);
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SKDeleteValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue)
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, TRUE);
    if (hk)
    {
        // RegSetValueExW is not supported on Win95 but we have a thunking function.
        DWORD err = RegDeleteValueW(hk, pwszValue);
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SKAllocValueW(
    IN  SHELLKEY sk,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT DWORD * pdwType,            OPTIONAL
    OUT void ** ppvData,
    OUT DWORD * pcbData)            OPTIONAL
{
    HKEY hk = SHGetShellKey(sk, pwszSubKey, FALSE);
    if (hk)
    {
        DWORD cbData;
        DWORD err = SHQueryValueExW(hk, pwszValue, NULL, NULL, NULL, &cbData);
        if (err == ERROR_SUCCESS)
        {
            //  we add an extra char incase we need a NULL terminator
            *ppvData = LocalAlloc(LPTR, cbData + sizeof(WCHAR));
            if (*ppvData)
            {
                err = SHQueryValueExW(hk, pwszValue, NULL, pdwType, *ppvData, &cbData);
                if (err == ERROR_SUCCESS)
                {
                    if (pcbData)
                        *pcbData = cbData;
                }
                else
                {
                    LocalFree(*ppvData);
                    *ppvData = NULL;
                }
            }
            else
                err = ERROR_NOT_ENOUGH_MEMORY;
        }
        
        RegCloseKey(hk);
        return HRESULT_FROM_WIN32(err);
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

//
// SHBoolSystemParametersInfo
//
// Wrapper around SystemParametersInfo to deal with various
// parameter semantics of boolean SPI's.
//
// The return value is just the result of the call to SPI.
// If you're querying for a value, you need to look at the
// value returned in pdwParam.
//
// Feel free to add more cases to the switch statement below
// if you need them.
//
STDAPI_(BOOL) SHBoolSystemParametersInfo(UINT uiAction, DWORD *pdwParam)
{
    //
    // Figure out the SPI parameters depending on uiAction.
    //

    UINT uiParam = 0;
    PVOID pvParam = NULL;

    ANIMATIONINFO aii;

    if (uiAction & (SPIF_BOOL | SPIF_DWORD))
    {
        if (uiAction & SPIF_SET)
        {
            pvParam = IntToPtr(*pdwParam);
        }
        else
        {
            pvParam = pdwParam;
        }
    }
    else
    {
        switch (uiAction)
        {
        case SPI_GETANIMATION:
        case SPI_SETANIMATION:
            aii.cbSize = uiParam = sizeof(ANIMATIONINFO);
            aii.iMinAnimate = *pdwParam;
            pvParam = &aii;
            break;

        case SPI_GETDRAGFULLWINDOWS:
        case SPI_GETFONTSMOOTHING:
            pvParam = pdwParam;
            break;

        case SPI_SETDRAGFULLWINDOWS:
        case SPI_SETFONTSMOOTHING:
            uiParam = *pdwParam;
            break;

        default:
            RIPMSG(0, "SHBoolSystemParametersInfo: unknown SPI_ %x, need to add code for this case", uiAction);
            return ERROR_INVALID_PARAMETER;
        }
    }
    

    //
    // do the SPI call
    //
    BOOL fRet = SystemParametersInfo(uiAction, uiParam, pvParam, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    //
    // copy return value if necessary
    //
    if (uiAction == SPI_GETANIMATION)
    {
        *pdwParam = aii.iMinAnimate;
    }

    return fRet;
}


// 
// Determine if the images represented by the two icons are the same
// (NOTE: this does not compare ICON masks, but this should never be a distinguishing factor)
//
STDAPI_(BOOL) SHAreIconsEqual(HICON hIcon1, HICON hIcon2)
{
    BOOL bRet = FALSE;

    ICONINFO ii1;
    if (hIcon1 && hIcon2 && GetIconInfo(hIcon1, &ii1))
    {
        ICONINFO ii2;
        if (GetIconInfo(hIcon2, &ii2))
        {
            BITMAP bm1 = {0};
            if (GetObject(ii1.hbmColor, sizeof(bm1), &bm1))
            {
                BITMAP bm2 = {0};
                if (GetObject(ii2.hbmColor, sizeof(bm2), &bm2))
                {
                    if ((bm1.bmWidth == bm2.bmWidth) && (bm1.bmHeight == bm2.bmHeight))
                    {
                        BITMAPINFO bmi = {0};
                        bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
                        bmi.bmiHeader.biWidth = bm1.bmWidth;
                        bmi.bmiHeader.biHeight = bm1.bmHeight;
                        bmi.bmiHeader.biPlanes = 1;
                        bmi.bmiHeader.biBitCount = 32;
                        bmi.bmiHeader.biCompression = BI_RGB;

                        HDC hdc = GetDC(NULL);
                        if (hdc)
                        {
                            ULONG* pulIcon1 = new ULONG[bm1.bmWidth * bm1.bmHeight];
                            if (pulIcon1)
                            {
                                if (GetDIBits(hdc, ii1.hbmColor, 0, bm1.bmHeight, (LPVOID)pulIcon1, &bmi, DIB_RGB_COLORS))
                                {
                                    ULONG* pulIcon2 = new ULONG[bm1.bmWidth * bm1.bmHeight];
                                    if (pulIcon2)
                                    {
                                        if (GetDIBits(hdc, ii2.hbmColor, 0, bm1.bmHeight, (LPVOID)pulIcon2, &bmi, DIB_RGB_COLORS))
                                        {
                                            bRet = (0 == memcmp(pulIcon1, pulIcon2, bm1.bmWidth * bm1.bmHeight * sizeof(ULONG)));
                                        }
                                        delete[] pulIcon2;
                                    }
                                }
                                delete[] pulIcon1;
                            }
                            ReleaseDC(NULL, hdc);
                        }
                    }
                }
            }
            DeleteObject(ii2.hbmColor);
            DeleteObject(ii2.hbmMask);
        }
        DeleteObject(ii1.hbmColor);
        DeleteObject(ii1.hbmMask);
    }

    return bRet;
}

//
//  CoCreateInstance that queries the app compat layer first, giving
//  it a chance to load any necessary shims in anticipation of the
//  bad DLL being loaded.
//

EXTERN_C DECLSPEC_IMPORT BOOL STDAPICALLTYPE
ApphelpCheckShellObject(
    IN  REFCLSID    ObjectCLSID,
    IN  BOOL        bShimIfNecessary,
    OUT ULONGLONG*  pullFlags
);

STDAPI SHCoCreateInstanceAC(REFCLSID rclsid, IUnknown *punkOuter,
                            DWORD dwClsCtx, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;
    ULONGLONG ullFlags;

    // Note that on downlevel, our delayload stub will save us
    if (!ApphelpCheckShellObject(rclsid, TRUE, &ullFlags))
    {
        // App compat says "Do not load under any circumstances!"
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    return CoCreateInstance(rclsid, punkOuter, dwClsCtx, riid, ppvOut);
}

int WINAPI Shell_GetCachedImageIndexWrapA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    ASSERTMSG(FALSE, "WHO IS CALLING THIS?  - get ZekeL");
    WCHAR szIconPath[MAX_PATH];
    SHAnsiToUnicode(pszIconPath, szIconPath, ARRAYSIZE(szIconPath));
    return Shell_GetCachedImageIndex((LPCWSTR)szIconPath, iIconIndex, uIconFlags);
}

LWSTDAPI CLSIDFromProgIDWrap(LPCOLESTR psz, LPCLSID pclsid)
{
    return CLSIDFromProgID(psz, pclsid);
}

LWSTDAPI CLSIDFromStringWrap(LPOLESTR psz, LPCLSID pclsid)
{
    return CLSIDFromString(psz, pclsid);
}

#define SZ_IEZONEMAP L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap"

STDAPI_(BOOL) IEHardened()
{
    BOOL fRet = FALSE;
    HKEY hKey = 0;

    if (RegOpenKeyExW(HKEY_CURRENT_USER, SZ_IEZONEMAP, 0, KEY_READ, &hKey) == ERROR_SUCCESS) 
    {
        DWORD dwValue = 0;
        DWORD dwSize = sizeof(dwValue);    
        if(ERROR_SUCCESS == RegQueryValueExW(hKey, L"IEharden", NULL, NULL, (LPBYTE)&dwValue, &dwSize))
        {
            fRet = (1 == dwValue);
        }

        RegCloseKey(hKey);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themebld.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-1998
#   All Rights Reserved.
#
##########################################################################


!if !defined(CCSHELL_DIR)
!error  CCSHELL_DIR must be defined in sources file
!endif

!INCLUDE $(CCSHELL_DIR)\COMMON.INC
THEME_DIR = $(CCSHELL_DIR)\themes

#
# Set private paths
#

INCLUDES = $(THEME_DIR)\inc;$(THEME_DIR)\themedir;$(INCLUDES)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE -DWIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\clipper\clipper.h ===
#if !defined(AFX_CLIPPER_H__C0921B21_C177_4FD2_A049_D548235D340A__INCLUDED_)
#define AFX_CLIPPER_H__C0921B21_C177_4FD2_A049_D548235D340A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_CLIPPER_H__C0921B21_C177_4FD2_A049_D548235D340A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\clipper\clipper.cpp ===
//--------------------------------------------------------------------------
// Clipper.cpp : test out theme drawing and fast clipping
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"

#define ASSERT(x)

#include "uxthemep.h"
#include "tmschema.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
#include "stdlib.h"
#include "stdio.h"
#include "autos.h"
//--------------------------------------------------------------------------
#define CLIPPER_FONTHEIGHT  55
//--------------------------------------------------------------------------
HINSTANCE hInst;        

HWND hwndMain;
HWND hwndTab;
HWND hwndDisplay;

TCHAR *pszMainWindowClass = L"Clipper";
TCHAR *pszDisplayWindowClass = L"ClipperDisplay";
//-----------------------------------------------------------------------------------
enum IMAGEFILEDRAW
{
    IF_REG,
    IF_TRANS,
    IF_ALPHA
};
//-----------------------------------------------------------------------------------
LPCWSTR szPageNames[] = 
{
    L"BorderFill",
    L"BorderFill-R",
    L"ImageFile",
    L"ImageFile-R",
    L"Glyph",
    L"Glyph-R",
    L"MultiImage",
    L"MultiImage-R",
    L"Text",
    L"Text-R",
    L"Borders",
    L"Borders-R",
    L"SourceSizing",
    L"SourceSizing-R",
};
//-----------------------------------------------------------------------------------
enum GROUPID
{
    GID_BORDERFILL,
    GID_IMAGEFILE,
    GID_GLYPH,
    GID_MULTIIMAGE,
    GID_TEXT,
    GID_BORDERS,
    GID_SRCSIZING,
};
//-----------------------------------------------------------------------------------
#define MAXGROUPS  ((ARRAYSIZE(szPageNames))/2)
#define MAXTESTITEMS 50
//-----------------------------------------------------------------------------------
// Foward declarations of functions included in this code module:
BOOL                            InitInstance(HINSTANCE, int);
LRESULT CALLBACK        MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK        DisplayWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK        About(HWND, UINT, WPARAM, LPARAM);

void CreateDrawObjects();
BOOL CreateAllWindows();
void RegisterWindowClasses();
//-----------------------------------------------------------------------------------
HRESULT MakeErrorLast() {return E_FAIL;}
//-----------------------------------------------------------------------------------
BOOL CaptureBitmaps();
BOOL WriteBitmapToFile(BITMAPINFOHEADER *pHdr, BYTE *pBits, LPCWSTR pszBaseName);
BOOL WriteBitmapHeader(HANDLE hOutFile, BYTE *pMemoryHdr, DWORD dwTotalPixelBytes);

void OnDisplayResize();
void PaintObjects(HDC hdc, RECT *prc, int iGroupId);
//-----------------------------------------------------------------------------------
SIZE szCell = {100, 60};
RECT rcDraw = {10, 10, 50, 45};        // where to draw within cell
//-----------------------------------------------------------------------------------
struct TESTITEM
{
    HTHEME hTheme;
    DWORD dwDtbFlags;

    WCHAR szName[MAX_PATH];
};
//-----------------------------------------------------------------------------------
//---- scrolling support ----
int iVertOffset = 0;
int iMaxVertOffset = 0;     // set by WM_SIZE
int iVertLineSize = 10;     // # of pixels
int iVertPageSize = 0;      // set by WM_SIZE
//-----------------------------------------------------------------------------------
int iItemCount[MAXGROUPS] = {0};
TESTITEM TestItems[MAXGROUPS][MAXTESTITEMS];

BOOL fCapturing = FALSE;
//-----------------------------------------------------------------------------------
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR lpCmdLine, int nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable;

    hInst = hInstance;
    RegisterWindowClasses();

    InitCommonControlsEx(NULL);

    if (!InitInstance (hInstance, nCmdShow)) 
    {
            return FALSE;
    }

    //---- parse cmdline params ----
    USES_CONVERSION;

    LPCSTR p = W2A(lpCmdLine);
    while (*p)
    {
        while (isspace(*p))
            p++;

        //---- parse switches ----
        if ((*p == '/') || (*p == '-'))
        {
            p++;

            if ((*p == 'c') || (*p == 'C'))
            {
                p++;
                fCapturing = TRUE;
            }
        }
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_CLIPPER);

    if (fCapturing)
    {
        CaptureBitmaps();
        return 0;
    }

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
        {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
        }
    }

    return static_cast<int>(msg.wParam);
}
//--------------------------------------------------------------------------
BOOL CaptureBitmaps()
{
    //---- paint each tab page to a memory dc & convert to a bitmap file ----
    HDC hdcClient = GetDC(NULL);

    RECT rt = {0, 0, 800, 600};     // currently captures all good info
    BITMAPINFOHEADER BitMapHdr = {sizeof(BITMAPINFOHEADER), WIDTH(rt), HEIGHT(rt), 1, 24, BI_RGB};

    //---- create a DIB to paint into ----
    BYTE *pBits;
    HBITMAP hBitmap = CreateDIBSection(hdcClient, (BITMAPINFO *)&BitMapHdr, DIB_RGB_COLORS,
       (void **)&pBits, NULL, 0);

    HDC hdcMemory = CreateCompatibleDC(hdcClient);
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdcMemory, hBitmap);

    //---- for each tab that we can draw ----
    for (int iTabNum=0; iTabNum < ARRAYSIZE(szPageNames); iTabNum++)
    {
        iVertOffset = 0;
        iVertPageSize = RECTHEIGHT(&rt);
        int iGroupId = iTabNum/2;

        //---- keep tester interested by sync. visuals ----
        TabCtrl_SetCurSel(hwndTab, iTabNum);
        OnDisplayResize();
        iVertPageSize = RECTHEIGHT(&rt);
        InvalidateRect(hwndDisplay, NULL, TRUE);

        if (iTabNum % 2)       // if its a mirrored page
            SetLayout(hdcMemory, LAYOUT_RTL);
        else
            SetLayout(hdcMemory, 0);
    
        //---- clear the background first ----
        HBRUSH hbr = CreateSolidBrush(RGB(255, 255, 255));
        FillRect(hdcMemory, &rt, hbr);

        //---- draw the objects/labels for this tab ----
        PaintObjects(hdcMemory, &rt, iGroupId);

        //---- now copy DIB bits to a bitmap file ----
        WriteBitmapToFile(&BitMapHdr, pBits, szPageNames[iTabNum]);
    }

    //---- clean up ----
    SelectObject(hdcMemory, hOldBitmap);
    DeleteDC(hdcMemory);
    DeleteObject(hBitmap);

    ReleaseDC(NULL, hdcClient);

    return TRUE;
}
//--------------------------------------------------------------------------
BOOL WriteBitmapToFile(BITMAPINFOHEADER *pHdr, BYTE *pBits, LPCWSTR pszBaseName)
{
    BOOL fWroteFile = FALSE;

    //---- get size of bitmap ----
    int iDibWidth = pHdr->biWidth;
    int iDibHeight = pHdr->biHeight;

    int iRawBytes = iDibWidth * 3;
    int iBytesPerRow = 4*((iRawBytes+3)/4);
    int iPixelBytesTotal = iBytesPerRow * iDibHeight;

    //---- create the bitmap file ----
    WCHAR szName[MAX_PATH];
    StringCchPrintfW(szName, ARRAYSIZE(szName), L"%s.bmp", pszBaseName);

    HANDLE hFileOutput = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (hFileOutput == INVALID_HANDLE_VALUE)
    {
        printf("\nError - could not open bitmap file for output: %s\n", szName);
        goto exit;
    }

    //---- write the bitmap FILE header ----
    if (! WriteBitmapHeader(hFileOutput, (BYTE *)pHdr, iPixelBytesTotal))
        goto exit;

    //---- write the bitmap MEMORY header ----
    DWORD dw;
    if (! WriteFile(hFileOutput, pHdr, sizeof(*pHdr), &dw, NULL))
        goto exit;

    //---- write the bitmap bits ----
    if (! WriteFile(hFileOutput, pBits, iPixelBytesTotal, &dw, NULL))
        goto exit;

    fWroteFile = TRUE;

exit:
    if (hFileOutput != INVALID_HANDLE_VALUE)
    {
        //---- close the file ----
        CloseHandle(hFileOutput);
    }

    return fWroteFile;
}
//---------------------------------------------------------------------------
BOOL WriteBitmapHeader(HANDLE hOutFile, BYTE *pMemoryHdr, DWORD dwTotalPixelBytes)
{
    BOOL fOK = FALSE;
    BYTE pbHdr1[] = {0x42, 0x4d};
    BYTE pbHdr2[] = {0x0, 0x0, 0x0, 0x0};
    int iFileLen;

    DWORD dw;

    //---- add bitmap hdr at front ----
    HRESULT hr = WriteFile(hOutFile, pbHdr1, sizeof(pbHdr1), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    //---- add length of data ----
    iFileLen = dwTotalPixelBytes + sizeof(BITMAPFILEHEADER);
    hr = WriteFile(hOutFile, &iFileLen, sizeof(int), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    hr = WriteFile(hOutFile, pbHdr2, sizeof(pbHdr2), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    //---- offset to bits (who's idea was *this* field?) ----
    int iOffset, iColorTableSize;
    DWORD dwSize;

    iOffset = sizeof(BITMAPFILEHEADER);
    dwSize = *(DWORD *)pMemoryHdr;
    iOffset += dwSize; 
    iColorTableSize = 0;

    switch (dwSize)
    {
        case sizeof(BITMAPCOREHEADER):
            BITMAPCOREHEADER *hdr1;
            hdr1 = (BITMAPCOREHEADER *)pMemoryHdr;
            if (hdr1->bcBitCount == 1)
                iColorTableSize = 2*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 4)
                iColorTableSize = 16*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 8)
                iColorTableSize = 256*sizeof(RGBTRIPLE);
            break;

        case sizeof(BITMAPINFOHEADER):
        case sizeof(BITMAPV4HEADER):
        case sizeof(BITMAPV5HEADER):
            BITMAPINFOHEADER *hdr2;
            hdr2 = (BITMAPINFOHEADER *)pMemoryHdr;
            if (hdr2->biClrUsed)
                iColorTableSize = hdr2->biClrUsed*sizeof(RGBQUAD);
            else
            {
                if (hdr2->biBitCount == 1)
                    iColorTableSize = 2*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 4)
                    iColorTableSize = 16*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 8)
                    iColorTableSize = 256*sizeof(RGBQUAD);
            }
            break;
    }

    iOffset += iColorTableSize;
    hr = WriteFile(hOutFile, &iOffset, sizeof(int), &dw, NULL);
    if (FAILED(hr))
        goto exit;

    fOK = TRUE;

exit:
    return fOK;
}
//--------------------------------------------------------------------------
void DrawTargetRect(HDC hdc, RECT *prc, COLORREF cr)
{
    //---- draw purple target dashed rect ----

    //---- prepare drawing objects ----
    HPEN hPen = CreatePen(PS_DOT, 1, cr);
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

    //---- draw that thing ----
    Rectangle(hdc, prc->left-1, prc->top-1, prc->right+1, prc->bottom+1);

    //---- restore DC ----
    SelectObject(hdc, hOldPen);
    SelectObject(hdc, hOldBrush);
    DeleteObject(hPen);
}
//--------------------------------------------------------------------------
void DrawClip(HTHEME hTheme, HDC hdc, RECT *prc, int iRowIndex, int iColIndex,
     DWORD dwDtbFlags)
{
    RECT rect, rcClip;
    int left = prc->left + (iColIndex+1)*szCell.cx;
    int top = prc->top + (iRowIndex+1)*szCell.cy;

    HRESULT hr = S_OK;

    SetRect(&rect, left + rcDraw.left, top + rcDraw.top, 
        left + rcDraw.right, top + rcDraw.bottom);

    //---- draw purple target dashed rect ----
    DrawTargetRect(hdc, &rect, RGB(128, 128, 255));

    switch (iColIndex)      // clipping type
    {
    case 0:         // no clipping
        break;

    case 1:         // over clipping
        rcClip = rect;
        rcClip.left -= 4;
        rcClip.right += 4;
        rcClip.top -= 4;
        rcClip.bottom += 4;
        break;

    case 2:         // exact clipping
        rcClip = rect;
        break;

    case 3:         // partial overlap 
        rcClip = rect;
        rcClip.left += 8;
        rcClip.right -= 8;
        rcClip.top += 8;
        rcClip.bottom -= 8;
        break;

    case 4:         // InOut1
        rcClip = rect;
        rcClip.left -= 3;
        rcClip.right = rcClip.left + 20;
        rcClip.top -= 3;
        rcClip.bottom = rcClip.top + 20;
        break;

    case 5:         // InOut2
        rcClip = rect;
        rcClip.left += 20;
        rcClip.right += 5;
        rcClip.top += 15;;
        rcClip.bottom += 5;
        break;

    case 6:         // out clip
        rcClip.left = rect.right + 6;
        rcClip.right = rcClip.left + 9;
        rcClip.top = rect.top - 2;
        rcClip.bottom = rect.bottom + 2;
        break;
    }

    //---- draw red clipping rect ----
    if (iColIndex)
    {
        HPEN hPen = CreatePen(PS_DOT, 1, RGB(255, 0, 0));
        HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
        HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

        Rectangle(hdc, rcClip.left-1, rcClip.top-1, rcClip.right+1, rcClip.bottom+1);

        SelectObject(hdc, hOldPen);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hPen);
    }

    DTBGOPTS DtbOpts = {sizeof(DtbOpts)};
    DtbOpts.dwFlags = dwDtbFlags;

    if (iColIndex)        // pass clipping rect
    {
        DtbOpts.dwFlags |= DTBG_CLIPRECT;
        DtbOpts.rcClip = rcClip;
    }

    hr = DrawThemeBackgroundEx(hTheme, hdc, 1, 2, &rect, &DtbOpts);
    if (FAILED(hr))
    {
        WCHAR buff[100];
        StringCchPrintfW(buff, ARRAYSIZE(buff), L"DrawThemeBackgroundEx err: hr=0x%x, irow=%d, icol=%d", 
            hr, iRowIndex, iColIndex);

        //MessageBox(NULL, buff, L"Error", MB_OK);
    }
}
//--------------------------------------------------------------------------
void DrawTextObjects(HTHEME hTheme, HDC hdc, RECT *prc, int iRowIndex, LPCWSTR pszName)
{
    int left = prc->left + 4;        // some padding away from edge
    int top = prc->top + iRowIndex*szCell.cy + 18;  // try to center

    //---- draw label in left cell ----
    TextOut(hdc, left, top, pszName, wcslen(pszName));

    left += szCell.cx;
    RECT rc = {left, top, left+szCell.cx*5, top+szCell.cy};

    //---- draw actual test text ----
    HRESULT hr = DrawThemeText(hTheme, hdc, 1, 2, L"Testing Text Drawing", -1, 0, 0, &rc);

    if (FAILED(hr))
    {
        WCHAR buff[100];
        StringCchPrintfW(buff, ARRAYSIZE(buff), L"DrawThemeText err: hr=0x%x, irow=%d", 
            hr, iRowIndex);

        MessageBox(NULL, buff, L"Error", MB_OK);
    }
}
//--------------------------------------------------------------------------
void DrawClips(HTHEME hTheme, HDC hdc, RECT *prc, int iRowIndex, LPCWSTR pszName,
    DWORD dwDtbFlags)
{
    //---- label object on left ----
    int left = prc->left + 4;        // some padding away from edge
    int top = prc->top + (iRowIndex+1)*szCell.cy + 18;  // try to center

    //---- manual page clipping ----
    if ((top + szCell.cy) < 0)
        return;
    if (top > iVertPageSize)
        return;

    TextOut(hdc, left, top, pszName, wcslen(pszName));

    //---- draw clipping variations ----
    for (int i=0; i <= 6; i++)
    {
        DrawClip(hTheme, hdc, prc, iRowIndex, i, dwDtbFlags);
    }
}
//--------------------------------------------------------------------------
void AddItem(CDrawBase *pObject, CTextDraw *pTextObj, LPCWSTR pszName, int iGroupId,
     DWORD dwOtdFlags=0, DWORD dwDtbFlags=0)
{
    HTHEME hTheme = NULL;
    
    if (iItemCount[iGroupId] >= MAXTESTITEMS)
        return;

    if (pObject)
    {
        if (pObject->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pTo = new CBorderFill;

            if (pTo)
            {
                CopyMemory(pTo, pObject, sizeof(CBorderFill));
                hTheme = CreateThemeDataFromObjects(pTo, NULL, dwOtdFlags);
            }
        }
        else            // imagefile
        {
            CMaxImageFile *pFrom = (CMaxImageFile *)pObject;
            CMaxImageFile *pTo = new CMaxImageFile;
            
            if (pTo)
            {
                //---- transfer CImageFile object & variable number of DIBINFO's ----
                DWORD dwLen = sizeof(CImageFile) + sizeof(DIBINFO)*pFrom->_iMultiImageCount;

                CopyMemory(pTo, pFrom, dwLen);

                hTheme = CreateThemeDataFromObjects(pTo, NULL, dwOtdFlags);
            }
        }
    }
    else            // text object
    {
        CTextDraw *pTo = new CTextDraw;

        if (pTo)
        {
            CopyMemory(pTo, pTextObj, sizeof(CTextDraw));
            hTheme = CreateThemeDataFromObjects(NULL, pTo, dwOtdFlags);
        }
    }

    if (hTheme)
    {
        int iIndex = iItemCount[iGroupId];
        TestItems[iGroupId][iIndex].hTheme = hTheme;
        TestItems[iGroupId][iIndex].dwDtbFlags = dwDtbFlags;

        StringCchCopyW(TestItems[iGroupId][iIndex].szName, ARRAYSIZE(TestItems[iGroupId][iIndex].szName), pszName);

        iItemCount[iGroupId]++;
    }
    else
    {
        MessageBox(NULL, L"Error creating hTheme from obj", L"Error", MB_OK);
    }
}
//--------------------------------------------------------------------------
void CreateBorderFillNoDraw()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._fNoDraw = TRUE;

    AddItem(&bfill, NULL, L"NoDraw", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillSquare()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_RECT;
    bfill._iBorderSize = 0;

    bfill._eFillType = FT_SOLID;
    bfill._crFill = RGB(128, 255, 255);

    AddItem(&bfill, NULL, L"Square", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillBorder()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_RECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;

    bfill._eFillType = FT_SOLID;
    bfill._crFill = RGB(128, 255, 255);

    AddItem(&bfill, NULL, L"Border", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillCircle()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_ROUNDRECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;
    bfill._iRoundCornerWidth = 80;
    bfill._iRoundCornerHeight = 80;

    bfill._eFillType = FT_SOLID;
    bfill._crFill = RGB(128, 255, 255);

    AddItem(&bfill, NULL, L"Circle", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillGradient()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_RECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;

    bfill._eFillType = FT_HORZGRADIENT;

    //---- gradients ----
    bfill._iGradientPartCount = 2;
    bfill._crGradientColors[0] = RGB(0, 0, 0);
    bfill._crGradientColors[1] = RGB(255, 255, 255);
    bfill._iGradientRatios[0] = 0;
    bfill._iGradientRatios[1] = 255;

    AddItem(&bfill, NULL, L"Gradient", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateBorderFillCircleGradient()
{
    CBorderFill bfill;
    memset(&bfill, 0, sizeof(bfill));

    //---- make a BorderFill obj with a border ----
    bfill._eBgType = BT_BORDERFILL;
    bfill._eBorderType = BT_ROUNDRECT;
    bfill._crBorder = RGB(255, 128, 128);
    bfill._iBorderSize = 3;
    bfill._iRoundCornerWidth = 80;
    bfill._iRoundCornerHeight = 80;

    bfill._eFillType = FT_HORZGRADIENT;

    //---- gradients ----
    bfill._iGradientPartCount = 2;
    bfill._crGradientColors[0] = RGB(0, 0, 0);
    bfill._crGradientColors[1] = RGB(255, 255, 255);
    bfill._iGradientRatios[0] = 0;
    bfill._iGradientRatios[1] = 255;

    AddItem(&bfill, NULL, L"CircleGradient", GID_BORDERFILL);
}
//--------------------------------------------------------------------------
void CreateImageFileBorder(SIZINGTYPE eSizeType, BOOL fSizeBorders, BOOL fForceSizeRect)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_BORDERTEST)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with STRETCH ----
    cif._eBgType = BT_IMAGEFILE;  
    
    if (fSizeBorders)
    {
        cif._fSourceGrow = TRUE;
        cif._fIntegralSizing = TRUE;
    }

    cif._fMirrorImage = TRUE;
    cif._iImageCount = 1;
    cif._eImageLayout = IL_VERTICAL;
    cif._ImageInfo.iSingleWidth = 18;
    cif._ImageInfo.iSingleHeight = 17;
    cif._ImageInfo.eSizingType = eSizeType;
    cif._ImageInfo.iMinDpi = 96;
    cif._szNormalSize.cx = 50;
    cif._szNormalSize.cy = 50;

    SetRect((RECT *)&cif._SizingMargins, 3, 3, 3, 3);

    DWORD dwOtdFlags = 0;
    
    if (fForceSizeRect) 
    {
        dwOtdFlags |= OTD_FORCE_RECT_SIZING; 
    }

    AddItem(&cif, NULL, L"BorderTest", GID_BORDERS, dwOtdFlags);
}
//--------------------------------------------------------------------------
void CreateImage(int iBgImageId, int iStateCount, SIZINGTYPE eSizeType, BOOL fSrcSizing, int iGroupId,
     LPCWSTR pszName, int lw, int rw, int th, int bh)
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    if (iBgImageId)
    {
        mif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(iBgImageId)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    }

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = iStateCount;
    mif._eImageLayout = IL_VERTICAL;
    mif._ImageInfo.eSizingType = eSizeType;
    mif._ImageInfo.iMinDpi = 96;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eGlyphType = GT_IMAGEGLYPH;

    //---- set Width/Height ----
    BITMAP bm;
    GetObject(mif._ImageInfo.hProcessBitmap, sizeof bm, &bm);

    mif._ImageInfo.iSingleWidth = bm.bmWidth;
    mif._ImageInfo.iSingleHeight = bm.bmHeight/iStateCount;

    mif._ImageInfo.szMinSize.cx = bm.bmWidth;
    mif._ImageInfo.szMinSize.cy = bm.bmHeight/iStateCount;

    SetRect((RECT *)&mif._SizingMargins, lw, rw, th, bh);
    SetRect((RECT *)&mif._ContentMargins, lw, rw, th, bh);

    DWORD dwOtdFlags = 0;
    
    if (fSrcSizing) 
    {
        dwOtdFlags |= OTD_FORCE_RECT_SIZING; 
    }

    AddItem(&mif, NULL, pszName, iGroupId, dwOtdFlags);
}
//--------------------------------------------------------------------------
void CreateProgressTrack()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    mif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_PROGRESS_TRACK)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 1;
    mif._eImageLayout = IL_VERTICAL;
    mif._ImageInfo.eSizingType = ST_TILE;
    mif._ImageInfo.iMinDpi = 96;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;

    //---- set Width/Height ----
    BITMAP bm;
    GetObject(mif._ImageInfo.hProcessBitmap, sizeof bm, &bm);

    mif._ImageInfo.iSingleWidth = bm.bmWidth;
    mif._ImageInfo.iSingleHeight = bm.bmHeight/1;

    mif._ImageInfo.szMinSize.cx = 10;
    mif._ImageInfo.szMinSize.cy = 10;

    mif._szNormalSize.cx = 100;
    mif._szNormalSize.cy = 18;

    mif._fSourceShrink = TRUE;

    SetRect((RECT *)&mif._SizingMargins, 4, 4, 3, 3);
    SetRect((RECT *)&mif._ContentMargins, 4, 4, 3, 3);

    AddItem(&mif, NULL, L"Progress", GID_SRCSIZING, 0);
}
//--------------------------------------------------------------------------
void CreateProgressChunk()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  

    mif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_PROGRESS_CHUNK)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    mif._fMirrorImage = TRUE;
    mif._iImageCount = 1;
    mif._eImageLayout = IL_VERTICAL;
    mif._ImageInfo.eSizingType = ST_TILE;
    mif._ImageInfo.iMinDpi = 96;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eGlyphType = GT_IMAGEGLYPH;

    //---- set Width/Height ----
    BITMAP bm;
    GetObject(mif._ImageInfo.hProcessBitmap, sizeof bm, &bm);

    mif._ImageInfo.iSingleWidth = bm.bmWidth;
    mif._ImageInfo.iSingleHeight = bm.bmHeight/1;

    mif._ImageInfo.szMinSize.cx = 10;
    mif._ImageInfo.szMinSize.cy = 10;

    mif._szNormalSize.cx = 100;
    mif._szNormalSize.cy = 18;

    SetRect((RECT *)&mif._SizingMargins, 0, 0, 6, 5);
    SetRect((RECT *)&mif._ContentMargins, 0, 0, 6, 5);

    AddItem(&mif, NULL, L"Progress", GID_SRCSIZING, 0);
}
//--------------------------------------------------------------------------
void CreateRadioImage()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 8;
    mif._eImageLayout = IL_VERTICAL;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eImageSelectType = IST_DPI;
    mif._iMultiImageCount = 3;
    mif._eTrueSizeScalingType = TSST_DPI;
    mif._fUniformSizing = TRUE;
    mif._eHAlign = HA_CENTER;
    mif._eVAlign = VA_CENTER;

    int iMinDpis[] = {96, 118, 185};

    //---- process multiple images ----
    for (int i=0; i < 3; i++)
    {
        DIBINFO *pdi = &mif.MultiDibs[i];

        int idnum = IDB_RADIO13 + i;

        pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        pdi->iMinDpi = iMinDpis[i];

        //---- get bitmap width/height ----
        BITMAP bm;
        GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

        pdi->iSingleWidth = bm.bmWidth;
        pdi->iSingleHeight = bm.bmHeight/8;

        pdi->szMinSize.cx = pdi->iSingleWidth;
        pdi->szMinSize.cy = pdi->iSingleHeight;
        
        pdi->eSizingType = ST_TRUESIZE;
        
        pdi->crTransparent = RGB(255, 0, 255);
        pdi->fTransparent = TRUE;
    }

    //---- set primary image ----
    mif._ImageInfo = mif.MultiDibs[0];

    AddItem(&mif, NULL, L"RadioButton", GID_SRCSIZING, OTD_FORCE_RECT_SIZING);
}
//--------------------------------------------------------------------------
void CreateCheckImage()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 12;
    mif._eImageLayout = IL_VERTICAL;
    mif._szNormalSize.cx = 60;
    mif._szNormalSize.cy = 40;
    mif._eImageSelectType = IST_DPI;
    mif._iMultiImageCount = 3;
    mif._eTrueSizeScalingType = TSST_DPI;
    mif._fUniformSizing = TRUE;
    mif._eHAlign = HA_CENTER;
    mif._eVAlign = VA_CENTER;

    int iMinDpis[] = {96, 118, 185};

    //---- process multiple images ----
    for (int i=0; i < 3; i++)
    {
        DIBINFO *pdi = &mif.MultiDibs[i];

        int idnum = IDB_CHECK13 + i;

        pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        pdi->iMinDpi = iMinDpis[i];

        //---- get bitmap width/height ----
        BITMAP bm;
        GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

        pdi->iSingleWidth = bm.bmWidth;
        pdi->iSingleHeight = bm.bmHeight/12;

        pdi->szMinSize.cx = pdi->iSingleWidth;
        pdi->szMinSize.cy = pdi->iSingleHeight;
        
        pdi->eSizingType = ST_TRUESIZE;
        
        pdi->fAlphaChannel =  TRUE;
    }

    //---- set primary image ----
    mif._ImageInfo = mif.MultiDibs[0];

    AddItem(&mif, NULL, L"CheckBox", GID_SRCSIZING, OTD_FORCE_RECT_SIZING);
}
//--------------------------------------------------------------------------
void CreateScrollGlyph()
{
    CMaxImageFile mif;
    memset(&mif, 0, sizeof(mif));

    //---- create a ImageFile object ----
    mif._eBgType = BT_IMAGEFILE;  
    mif._eGlyphType = GT_IMAGEGLYPH;
    mif._fMirrorImage = TRUE;
    mif._iImageCount = 16;
    mif._eImageLayout = IL_VERTICAL;
    mif._szNormalSize.cx = 30;
    mif._szNormalSize.cy = 10;
    mif._eImageSelectType = IST_NONE;
    mif._fUniformSizing = TRUE;
    mif._eHAlign = HA_CENTER;
    mif._eVAlign = VA_CENTER;

    SetRect((RECT *)&mif._SizingMargins, 5, 5, 5, 5);
    SetRect((RECT *)&mif._ContentMargins, 0, 0, 3, 3);

    //---- background image ----
    DIBINFO *pdi = &mif._ImageInfo;
    pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_SCROLL_ARROWS)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- get bitmap width/height ----
    BITMAP bm;
    GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

    pdi->iSingleWidth = bm.bmWidth;
    pdi->iSingleHeight = bm.bmHeight/16;

    pdi->szMinSize.cx = pdi->iSingleWidth;
    pdi->szMinSize.cy = pdi->iSingleHeight;

    pdi->iMinDpi = 96;
    
    pdi->eSizingType = ST_STRETCH;

    //---- glyph image ----
    pdi = &mif._GlyphInfo;
    mif._GlyphInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(IDB_SCROLL_GLPYHS)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    pdi->fTransparent =  TRUE;
    pdi->crTransparent = RGB(255, 0, 255);

    GetObject(pdi->hProcessBitmap, sizeof bm, &bm);
    pdi->iSingleWidth = bm.bmWidth;
    pdi->iSingleHeight = bm.bmHeight/16;

    pdi->szMinSize.cx = pdi->iSingleWidth;
    pdi->szMinSize.cy = pdi->iSingleHeight;
   
    pdi->iMinDpi = 96;
    pdi->eSizingType = ST_TRUESIZE;
    
    mif._fSourceShrink = TRUE;
    mif._fSourceGrow = TRUE;

    mif._eTrueSizeScalingType = TSST_SIZE;
    mif._iTrueSizeStretchMark = 100;

    //---- add it (without OTD_FORCE_RECT_SIZING) ----
    AddItem(&mif, NULL, L"ScrollBox", GID_SRCSIZING, 0);
}
//--------------------------------------------------------------------------
void CreateImageFileStretch(IMAGEFILEDRAW eDraw, int iGroupId)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_STRETCH;
    if (eDraw == IF_TRANS)
        idnum = IDB_STRETCH_TRANS;

    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with STRETCH ----
    cif._eBgType = BT_IMAGEFILE;    
    cif._fMirrorImage = TRUE;
    cif._iImageCount = 5;
    cif._eImageLayout = IL_VERTICAL;
    cif._ImageInfo.iSingleWidth = 20;
    cif._ImageInfo.iSingleHeight = 19;
    cif._ImageInfo.eSizingType = ST_STRETCH;

    if (eDraw == IF_TRANS)
    {
        cif._ImageInfo.fTransparent = TRUE;
        cif._ImageInfo.crTransparent = RGB(255, 0, 255);
    }

    SetRect((RECT *)&cif._SizingMargins, 4, 4, 4, 4);

    LPCWSTR p = L"Stretch";

    if (eDraw == IF_TRANS)
        p = L"Stretch+Trans";

    AddItem(&cif, NULL, p, iGroupId);
}
//--------------------------------------------------------------------------
void CreateImageFileTile(IMAGEFILEDRAW eDraw, int iGroupId)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_TILE;
    if (eDraw == IF_TRANS)
        idnum = IDB_TILE_TRANS;

    DIBINFO *pdi = &cif._ImageInfo;

    pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with TILE ----
    pdi->eSizingType = ST_TILE;
    cif._eBgType = BT_IMAGEFILE;    
    cif._fMirrorImage = TRUE;
    cif._iImageCount = 5;
    cif._eImageLayout = IL_VERTICAL;
    cif._ImageInfo.iSingleWidth = 20;
    cif._ImageInfo.iSingleHeight = 19;

    if (eDraw == IF_TRANS)
    {
        cif._ImageInfo.fTransparent = TRUE;
        cif._ImageInfo.crTransparent = RGB(255, 0, 255);
    }

    SetRect((RECT *)&cif._SizingMargins, 4, 4, 9, 9);

    LPCWSTR p = L"Tile";

    if (eDraw == IF_TRANS)
        p = L"Tile+Trans";

    AddItem(&cif, NULL, p, iGroupId);
}
//--------------------------------------------------------------------------
void CreateImageFileTrueSize(IMAGEFILEDRAW eDraw, int iGroupId)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_TRUE;
    if (eDraw == IF_TRANS)
        idnum = IDB_TRUE_TRANS;
    else if (eDraw == IF_ALPHA)
        idnum = IDB_TRUE_ALPHA;

    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- create a ImageFile object that sizes with STRETCH ----
    cif._eBgType = BT_IMAGEFILE;    
    cif._iImageCount = 8;
    cif._fMirrorImage = TRUE;
    cif._eImageLayout = IL_HORIZONTAL;
    cif._ImageInfo.iSingleWidth = 16;
    cif._ImageInfo.iSingleHeight = 16;
    cif._ImageInfo.eSizingType = ST_TRUESIZE;

    if (eDraw == IF_TRANS)
    {
        cif._ImageInfo.fTransparent = TRUE;
        cif._ImageInfo.crTransparent = RGB(255, 0, 255);
    }
    else if (eDraw == IF_ALPHA)
    {
        cif._ImageInfo.fAlphaChannel = TRUE;
    }

    LPCWSTR p = L"TrueSize";
    if (eDraw == IF_TRANS)
        p = L"True+Trans";
    else if (eDraw == IF_ALPHA)
        p = L"True+Alpha";

    AddItem(&cif, NULL, p, iGroupId);
}
//--------------------------------------------------------------------------
void CreateImageFileCharGlyph()
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_GLYPHBG;
    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- specify bg info ----
    cif._eBgType = BT_IMAGEFILE;    
    cif._fMirrorImage = TRUE;
    cif._iImageCount = 3;
    cif._eImageLayout = IL_HORIZONTAL;
    cif._ImageInfo.iSingleWidth = 16;
    cif._ImageInfo.iSingleHeight = 22;
    cif._ImageInfo.eSizingType = ST_STRETCH;

    SetRect((RECT *)&cif._SizingMargins, 1, 1, 1, 1);

    //---- specify the char/font info ----
    cif._eGlyphType = GT_FONTGLYPH;
    cif._crGlyphTextColor = RGB(0, 0, 255);
    cif._iGlyphIndex = 62;
    cif._lfGlyphFont.lfWeight = FW_NORMAL;
    cif._lfGlyphFont.lfHeight = CLIPPER_FONTHEIGHT;
    StringCchCopyW(cif._lfGlyphFont.lfFaceName, ARRAYSIZE(cif._lfGlyphFont.lfFaceName), L"marlett");

    //---- specify alignment ----
    cif._eHAlign = HA_CENTER;
    cif._eVAlign = VA_CENTER;

    LPCWSTR p = L"FontGlyph";
    AddItem(&cif, NULL, p, GID_GLYPH);
}
//--------------------------------------------------------------------------
void CreateImageFileImageGlyph(IMAGEFILEDRAW eDraw, BOOL fForceMirror)
{
    CImageFile cif;
    memset(&cif, 0, sizeof(cif));

    int idnum = IDB_GLYPHBG;
    cif._ImageInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- specify bg info ----
    cif._eBgType = BT_IMAGEFILE;  
    cif._fMirrorImage = TRUE;
    cif._eGlyphType = GT_IMAGEGLYPH;
    cif._iImageCount = 3;
    cif._eImageLayout = IL_HORIZONTAL;
    cif._ImageInfo.iSingleWidth = 16;
    cif._ImageInfo.iSingleHeight = 22;
    cif._ImageInfo.eSizingType = ST_STRETCH;

    SetRect((RECT *)&cif._SizingMargins, 1, 1, 1, 1);

    //---- specify glyph info ----
    WCHAR szName[MAX_PATH];
    
    if (eDraw == IF_REG)
    {
        idnum = IDB_GLYPH;
        StringCchCopyW(szName, ARRAYSIZE(szName), L"ImageGlyph");

        cif._GlyphInfo.iSingleWidth = 10;
        cif._GlyphInfo.iSingleHeight = 7;
    }
    else if (eDraw == IF_TRANS)
    {
        idnum = IDB_GLYPH_TRANS;
        StringCchCopyW(szName, ARRAYSIZE(szName), L"ImageTrans");

        cif._GlyphInfo.fTransparent = TRUE;
        cif._GlyphInfo.crTransparent = RGB(255, 0, 255);

        cif._GlyphInfo.iSingleWidth = 10;
        cif._GlyphInfo.iSingleHeight = 7;
    }
    else
    {
        idnum = IDB_GLYPH_ALPHA;
        StringCchCopyW(szName, ARRAYSIZE(szName), L"ImageAlpha");

        cif._GlyphInfo.fAlphaChannel = TRUE;

        cif._GlyphInfo.iSingleWidth = 16;
        cif._GlyphInfo.iSingleHeight = 16;
    }

    cif._GlyphInfo.hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)),
        IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    //---- specify alignment ----
    cif._eHAlign = HA_CENTER;
    cif._eVAlign = VA_CENTER;

    DWORD dwDtbFlags = 0;

    if (fForceMirror)
    {
        dwDtbFlags |= DTBG_MIRRORDC;
        StringCchCatW(szName, ARRAYSIZE(szName), L"+M");
    }

    AddItem(&cif, NULL, szName, GID_GLYPH, 0, dwDtbFlags);
}
//--------------------------------------------------------------------------
void CreateMultiImage()
{
    CMaxImageFile MaxIf;

    memset(&MaxIf, 0, sizeof(MaxIf));

    //---- specify general info ----
    MaxIf._eBgType = BT_IMAGEFILE;  
    MaxIf._fMirrorImage = TRUE;
    MaxIf._iImageCount = 8;
    MaxIf._eImageLayout = IL_VERTICAL;
    MaxIf._eImageSelectType = IST_SIZE;
    MaxIf._iMultiImageCount = 3;
    MaxIf._iTrueSizeStretchMark = 50;
    MaxIf._eTrueSizeScalingType = TSST_SIZE;
    MaxIf._fUniformSizing = TRUE;
    MaxIf._eHAlign = HA_CENTER;
    MaxIf._eVAlign = VA_CENTER;
    
    int iUsageSizes[] = {20, 24, 32};

    //---- specify alignment ----
    MaxIf._eHAlign = HA_CENTER;
    MaxIf._eVAlign = VA_CENTER;

    for (int i=0; i < MaxIf._iMultiImageCount; i++)
    {
        int idnum = IDB_MULTI1 + i;

        DIBINFO *pdi = &MaxIf.MultiDibs[i];

        pdi->hProcessBitmap = (HBITMAP)LoadImage(hInst, static_cast<LPCWSTR>(IntToPtr(idnum)), 
            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        pdi->szMinSize.cx = iUsageSizes[i];
        pdi->szMinSize.cy = iUsageSizes[i];

        //---- get bitmap width/height ----
        BITMAP bm;
        GetObject(pdi->hProcessBitmap, sizeof bm, &bm);

        pdi->iSingleWidth = bm.bmWidth;
        pdi->iSingleHeight = bm.bmHeight/8;
        pdi->eSizingType = ST_TRUESIZE;
        pdi->fAlphaChannel = TRUE;
    }

    //---- set primary image ----
    MaxIf._ImageInfo = MaxIf.MultiDibs[0];

    AddItem(&MaxIf, NULL, L"MultiImage", GID_MULTIIMAGE);
}
//--------------------------------------------------------------------------
void CreateTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 128, 128);        // red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    StringCchCopyW(td._lfFont.lfFaceName, ARRAYSIZE(td._lfFont.lfFaceName), L"arial");

    AddItem(NULL, &td, L"TextObj", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateShadowTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    StringCchCopyW(td._lfFont.lfFaceName, ARRAYSIZE(td._lfFont.lfFaceName), L"arial");

    //---- shadow ----
    td._ptShadowOffset.x = 2;
    td._ptShadowOffset.y = 2;
    td._crShadow = RGB(149, 0, 0);          // dark red
    td._eShadowType = TST_SINGLE;

    AddItem(NULL, &td, L"ShadowText", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateBorderTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    StringCchCopyW(td._lfFont.lfFaceName, ARRAYSIZE(td._lfFont.lfFaceName), L"arial");

    //---- border ----
    td._iBorderSize = 1;
    td._crBorder = RGB(128, 128, 255);      // light blue

    AddItem(NULL, &td, L"BorderText", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateBorderShadowTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    StringCchCopyW(td._lfFont.lfFaceName, ARRAYSIZE(td._lfFont.lfFaceName), L"arial");

    //---- shadow ----
    td._ptShadowOffset.x = 2;
    td._ptShadowOffset.y = 2;
    td._crShadow = RGB(149, 0, 0);          // dark red
    td._eShadowType = TST_SINGLE;

    //---- border ----
    td._iBorderSize = 1;
    td._crBorder = RGB(0, 0, 0);      // black

    AddItem(NULL, &td, L"BorderShadow", GID_TEXT);
}
//--------------------------------------------------------------------------
void CreateBlurShadowTextObj()
{
    CTextDraw td;
    memset(&td, 0, sizeof(td));

    //---- text ----
    td._crText = RGB(255, 139, 139);        // light red

    //---- font ----
    td._fHaveFont = TRUE;
    td._lfFont.lfWeight = FW_NORMAL;
    td._lfFont.lfHeight = CLIPPER_FONTHEIGHT;
    td._lfFont.lfQuality = ANTIALIASED_QUALITY;
    StringCchCopyW(td._lfFont.lfFaceName, ARRAYSIZE(td._lfFont.lfFaceName), L"arial");

    //---- shadow ----
    td._ptShadowOffset.x = 2;
    td._ptShadowOffset.y = 2;
    td._crShadow = RGB(149, 0, 0);          // dark red
    td._eShadowType = TST_CONTINUOUS;

    AddItem(NULL, &td, L"BlurShadow", GID_TEXT);
}
//--------------------------------------------------------------------------
void LabelClip(HDC hdc, RECT *prc, int iColIndex, LPCWSTR pszName)
{
    int left = prc->left + (iColIndex+1)*szCell.cx;
    int top = prc->top + 6;    // some padding from very top of window

    //---- manual page clipping ----
    if ((top + szCell.cy) < 0)
        return;
    if (top > iVertPageSize)
        return;

    TextOut(hdc, left, top, pszName, wcslen(pszName));
}
//--------------------------------------------------------------------------
void CreateDrawObjects()
{
    //---- borderfill group ----
    CreateBorderFillNoDraw();
    CreateBorderFillSquare();
    CreateBorderFillBorder();
    CreateBorderFillCircle();
    CreateBorderFillGradient();
    CreateBorderFillCircleGradient();

    //---- imagefile group ----
    CreateImageFileStretch(IF_REG, GID_IMAGEFILE);
    CreateImageFileStretch(IF_TRANS, GID_IMAGEFILE);
    CreateImageFileTile(IF_REG, GID_IMAGEFILE);
    CreateImageFileTile(IF_TRANS, GID_IMAGEFILE);

    CreateImageFileTrueSize(IF_REG, GID_IMAGEFILE);
    CreateImageFileTrueSize(IF_TRANS, GID_IMAGEFILE);
    CreateImageFileTrueSize(IF_ALPHA, GID_IMAGEFILE);

    //---- glyph group ----
    //CreateImageFileCharGlyph();
    CreateImageFileImageGlyph(IF_REG, FALSE);
    CreateImageFileImageGlyph(IF_TRANS, FALSE);
    CreateImageFileImageGlyph(IF_TRANS, TRUE);
    CreateImageFileImageGlyph(IF_ALPHA, FALSE);

    //---- MultiImage group ----
    CreateMultiImage();

    //---- text group ----
    CreateTextObj();
    CreateShadowTextObj();
    CreateBorderTextObj();
    CreateBorderShadowTextObj();
    CreateBlurShadowTextObj();

    //---- borders group ----
    CreateImageFileBorder(ST_TRUESIZE, FALSE, FALSE);
    CreateImageFileBorder(ST_STRETCH, FALSE, FALSE);
    CreateImageFileBorder(ST_STRETCH, TRUE, TRUE);
    CreateImageFileBorder(ST_TILE, TRUE, TRUE);

    //---- SrcSizing group ----
    CreateImage(IDB_PUSHBUTTON, 5, ST_STRETCH, TRUE, GID_SRCSIZING, L"PushButton",
        8, 8, 9, 9);

    CreateRadioImage();

    CreateCheckImage();

    CreateScrollGlyph();

    CreateProgressTrack();

    CreateProgressChunk();
}
//--------------------------------------------------------------------------
void CenterRect(POINT &ptCenter, int iSize, RECT *prc)
{
    int iSizeA = iSize/2;
    int iSizeB = iSize - iSizeA;

    prc->left = ptCenter.x - iSizeA;
    prc->right = ptCenter.x + iSizeB;
    
    prc->top = ptCenter.y - iSizeA;
    prc->bottom = ptCenter.y + iSizeB;
}
//--------------------------------------------------------------------------
void DrawMultiImages(HDC hdc, RECT *prc, HTHEME hTheme)
{
    SIZE szMyCell = {80, 80};

    int iRowIndex = 0;
    int iSizes[] = {12, 16, 20, 24, 32, 48, 64};

    //---- draw various sizes of image ----
    for (int iIndex=0; iIndex < ARRAYSIZE(iSizes); iIndex++)
    {
        int iSize = iSizes[iIndex];

        //---- label object on left ----
        int left = prc->left + 4;        // some padding away from edge
        int top = prc->top + (iRowIndex)*szMyCell.cy + 18;  // try to center

        //---- manual page clipping ----
        if ((top + szMyCell.cy) < 0)
            return;
        if (top > iVertPageSize)
            return;

        WCHAR szName[MAX_PATH];
        StringCchPrintfW(szName, ARRAYSIZE(szName), L"Size: %d", iSize);

        TextOut(hdc, left, top+15, szName, wcslen(szName));

        //---- draw image in all of its states ----
        int iPartId = BP_RADIOBUTTON;

        for (int iStateId=RBS_UNCHECKEDNORMAL; iStateId <= RBS_CHECKEDDISABLED; iStateId++)
        {
            left += szMyCell.cx;

            RECT rc = {left, top, left+szMyCell.cx, top+szMyCell.cy};

            //---- draw purple target dashed rect ----
            DrawTargetRect(hdc, &rc, RGB(128, 128, 255));

            //---- calc center pt ----
            POINT ptCenter = {left + szMyCell.cx/2, top + szMyCell.cy/2};

            //---- rect to draw into ----
            CenterRect(ptCenter, iSize, &rc);

            //---- draw red rect for "draw into" rect ----
            DrawTargetRect(hdc, &rc, RGB(255, 0, 0));

            HRESULT hr = DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rc, NULL);

            if (FAILED(hr))
            {
                WCHAR buff[100];
                StringCchPrintfW(buff, ARRAYSIZE(buff), L"DrawThemeBackground err: hr=0x%x, irow=%d, iPartId=%d", 
                    hr, iRowIndex, iPartId);

                //MessageBox(NULL, buff, L"Error", MB_OK);
            }
        }

        iRowIndex++;
    }
}
//--------------------------------------------------------------------------
void DrawBorders(HDC hdc, RECT *prc, TESTITEM *pTestItem)
{
    int top = prc->top + 4;
    int left = prc->left + 6;
    
    //---- message on top line ----
    WCHAR szBuff[100];
    StringCchCopyW(szBuff, ARRAYSIZE(szBuff), L"Image: BorderTest.bmp, 18x17, 24 bit, Sizing Margins: 3, 3, 3, 3");
    TextOut(hdc, left, top+15, szBuff, wcslen(szBuff));
    top += 44;

    //---- FIRST row: draw border test obj in 6 different sizes ----
    SIZE szMyCell = {120, 120};

    //---- manual page clipping ----
    if (((top + szMyCell.cy) >= 0) && (top <= iVertPageSize))
    {
        LPCWSTR pszLabels [] = { L"TrueSize", L"Stretch", L"Stretch", L"Stretch",
            L"Stretch", L"Stretch", L"Stretch"};
        SIZE szSizes[] = { {60, 40}, {60, 40}, {6, 40}, {3, 40}, {60, 6}, {60, 2}, {2, 3} };

        //---- draw various sizes of image ----
        for (int iIndex=0; iIndex < ARRAYSIZE(szSizes); iIndex++)
        {
            SIZE sz = szSizes[iIndex];

            //---- label object on top ----
            left = prc->left + iIndex*szMyCell.cx + 6;        // some padding away from edge

            StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), L"%s (%dx%d)", pszLabels[iIndex], sz.cx, sz.cy);

            TextOut(hdc, left, top+15, szBuff, wcslen(szBuff));

            //---- draw image ----
            RECT rc = {left, top+50, left+sz.cx, top+50+sz.cy};

            int i = (iIndex==0) ? 0 : 1;

            HRESULT hr = DrawThemeBackground(pTestItem[i].hTheme, hdc, 0, 0, &rc, NULL);

            if (FAILED(hr))
            {
                WCHAR buff[100];
                StringCchPrintfW(buff, ARRAYSIZE(buff), L"DrawThemeBackground err in DrawBorders: hr=0x%x, iIndex=%d", 
                    hr, iIndex);

                //MessageBox(NULL, buff, L"Error", MB_OK);
            }
        }
    }

    //---- SECOND row: draw 2 other border objects real big (test border scaling) ----
    top += szMyCell.cy;

    szMyCell.cx = 380;
    szMyCell.cy = 300;

    SIZE sz = {szMyCell.cx - 30, szMyCell.cy - (50 + 10)};

    //---- manual page clipping: first row ----
    if (((top + szMyCell.cy) >= 0) && (top <= iVertPageSize))
    {
        LPCWSTR pszLabels [] = { L"Border Scaling (stretch)", L"Border Scaling (tile)"};

        //---- draw various sizes of image ----
        for (int iIndex=0; iIndex < ARRAYSIZE(pszLabels); iIndex++)
        {
            //---- label object on top ----
            int left = prc->left + iIndex*szMyCell.cx + 6;        // some padding away from edge

            TextOut(hdc, left, top+15, pszLabels[iIndex], wcslen(pszLabels[iIndex]));

            //---- draw image ----
            RECT rc = {left, top+50, left+sz.cx, top+50+sz.cy};

            HRESULT hr = DrawThemeBackground(pTestItem[2+iIndex].hTheme, hdc, 0, 0, &rc, NULL);

            if (FAILED(hr))
            {
                WCHAR buff[100];
                StringCchPrintfW(buff, ARRAYSIZE(buff), L"DrawThemeBackground err in DrawBorders: hr=0x%x, iIndex=%d", 
                    hr, iIndex);

                //MessageBox(NULL, buff, L"Error", MB_OK);
            }
        }
    }
}
//--------------------------------------------------------------------------
void DrawSrcSizing(HDC hdc, RECT *prc, TESTITEM *pTestItem)
{
    SIZE szMyCell = {120, 110};

    int top = prc->top + 4;
    int left = prc->left + szMyCell.cx + 6;
    
    //---- labels on top line ----
    LPCWSTR TopLabels[] = {L"Small", L"Regular", L"Large", L"High DPI"};

    SIZE szStretchSizes[] = { {50, 6}, {75, 23}, {90, 65}, {340, 100} };
    SIZE szTrueSizes[] = { {10, 6}, {13, 13}, {30, 30}, {340, 100} };

    int iStates[] = {5, 6, 6, 0, 0};

    for (int i=0; i < ARRAYSIZE(TopLabels); i++)
    {
        TextOut(hdc, left, top, TopLabels[i], wcslen(TopLabels[i]));
        left += szMyCell.cx;
    }

    top += 30;

    //---- draw rows ----
    for (int iRow=0; iRow < 5; iRow++)
    {
        //---- draw name on left ----
        left = prc->left + 6;
        
        WCHAR *pszName = pTestItem[iRow].szName;

        TextOut(hdc, left, top-5, pszName, wcslen(pszName));

        for (int iSize=0; iSize < ARRAYSIZE(szStretchSizes); iSize++)
        {
            left += szMyCell.cx;
            SIZE *psz;

            if ((iRow > 0) && (iRow < 4))
            {
                psz = &szTrueSizes[iSize];
            }
            else
            {
                psz = &szStretchSizes[iSize];
            }

            RECT rc = {left, top, left + psz->cx, top + psz->cy};
            
            HTHEME hTheme = pTestItem[iRow].hTheme;

            if (hTheme)
            {
                DrawThemeBackground(hTheme, hdc, 0, iStates[iRow], &rc, NULL);
                if (iRow == 4)      // progress control
                {
                    RECT rcContent;

                    GetThemeBackgroundContentRect(hTheme, hdc, 
                        0, 0, &rc, &rcContent);
                    
                    DrawThemeBackground(pTestItem[5].hTheme, hdc, 0, iStates[iRow], &rcContent, NULL);
                }
            }

        }

        top += szMyCell.cy;
    }
}
//--------------------------------------------------------------------------
void PaintObjects(HDC hdc, RECT *prc, int iGroupId)
{
    //---- select in a fixed size font for resolution-independent bits ----
    HFONT hfFixedSize = CreateFont(18, 6, 0, 0, FW_NORMAL, 0, 0, 0, ANSI_CHARSET, 
        0, 0, 0, 0, L"MS Sans Serif");
    HFONT hOldFont = (HFONT)SelectObject(hdc, hfFixedSize);

    RECT rc = *prc;

    rc.top -= iVertOffset;
    rc.bottom -= iVertOffset;

    if (iGroupId == GID_TEXT)      // text object
    {
        for (int i=0; i < iItemCount[iGroupId]; i++)
        {
            DrawTextObjects(TestItems[iGroupId][i].hTheme, hdc, &rc, i, 
                TestItems[iGroupId][i].szName);
        }
    }
    else if (iGroupId == GID_MULTIIMAGE)
    {
        DrawMultiImages(hdc, prc, TestItems[iGroupId][0].hTheme);
    }
    else if (iGroupId == GID_BORDERS)
    {
        DrawBorders(hdc, prc, TestItems[iGroupId]);
    }
    else if (iGroupId == GID_SRCSIZING)
    {
        DrawSrcSizing(hdc, prc, TestItems[iGroupId]);
    }
    else
    {
        LabelClip(hdc, &rc, 0, L"NoClip");   
        LabelClip(hdc, &rc, 1, L"OverClip");
        LabelClip(hdc, &rc, 2, L"ExactClip");
        LabelClip(hdc, &rc, 3, L"PartialClip");
        LabelClip(hdc, &rc, 4, L"InOut1");
        LabelClip(hdc, &rc, 5, L"InOut2");
        LabelClip(hdc, &rc, 6, L"OutClip");

        for (int i=0; i < iItemCount[iGroupId]; i++)
        {
            DrawClips(TestItems[iGroupId][i].hTheme, hdc, &rc, i, 
                TestItems[iGroupId][i].szName, TestItems[iGroupId][i].dwDtbFlags);
        }
    }

    //---- restore the font ----
    SelectObject(hdc, hOldFont);

    DeleteObject(hfFixedSize);
}
//--------------------------------------------------------------------------
void RegisterWindowClasses()
{
        WNDCLASSEX wcex;
        wcex.cbSize = sizeof(WNDCLASSEX); 

    //---- register MAIN window class ----
        wcex.style                      = 0;
        wcex.lpfnWndProc        = MainWndProc;
        wcex.cbClsExtra         = 0;
        wcex.cbWndExtra         = 0;
        wcex.hInstance          = hInst;
        wcex.hIcon                      = LoadIcon(hInst, (LPCTSTR)IDI_CLIPPER);
        wcex.hCursor            = LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground      = (HBRUSH)(COLOR_WINDOW+1);
        wcex.lpszMenuName       = (LPCWSTR)IDC_CLIPPER;
        wcex.lpszClassName      = pszMainWindowClass;
        wcex.hIconSm            = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

        RegisterClassEx(&wcex);

    //---- register DISPLAY window class ----
        wcex.style                      = CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc        = DisplayWndProc;
        wcex.cbClsExtra         = 0;
        wcex.cbWndExtra         = 0;
        wcex.hInstance          = hInst;
        wcex.hIcon                      = LoadIcon(hInst, (LPCTSTR)IDI_CLIPPER);
        wcex.hCursor            = LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground      = (HBRUSH)(COLOR_WINDOW+1);
        wcex.lpszMenuName       = (LPCWSTR)IDC_CLIPPER;
        wcex.lpszClassName      = pszDisplayWindowClass;
        wcex.hIconSm            = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

        RegisterClassEx(&wcex);
}
//--------------------------------------------------------------------------
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   CreateDrawObjects();

   if (! CreateAllWindows())
       return FALSE;

   ShowWindow(hwndMain, nCmdShow);
   UpdateWindow(hwndMain);

   return TRUE;
}
//--------------------------------------------------------------------------
void HandleVScroll(int message, WPARAM wParam, LPARAM lParam)
{
    int iOldVertOffset = iVertOffset;

    if (message == WM_VSCROLL)
    {
        switch (LOWORD(wParam))
        {
            case SB_LINEUP:
                iVertOffset -= iVertLineSize;
                break;

            case SB_LINEDOWN:
                iVertOffset += iVertLineSize;
                break;

            case SB_PAGEUP:
                iVertOffset -= iVertPageSize;
                break;

            case SB_PAGEDOWN:
                iVertOffset += iVertPageSize;
                break;

            case SB_THUMBPOSITION:
                iVertOffset = HIWORD(wParam);
                break;
        }
    }
    else        // mouse wheel
    {
        iVertOffset -= (GET_WHEEL_DELTA_WPARAM(wParam)/10);
    }

    //---- keep in valid range ----
    if (iVertOffset < 0)
    {
        iVertOffset = 0;
    }
    else if (iVertOffset > iMaxVertOffset)
    {
        iVertOffset = iMaxVertOffset;
    }

    //---- scroll or repaint, as needed ----
    if (iVertOffset != iOldVertOffset)
    {
        SetScrollPos(hwndDisplay, SB_VERT, iVertOffset, TRUE);

        int iDiff = (iVertOffset - iOldVertOffset);

        if (abs(iDiff) >= iVertPageSize)
        {
            InvalidateRect(hwndDisplay, NULL, TRUE);
        }
        else
        {
            ScrollWindowEx(hwndDisplay, 0, -iDiff, NULL, NULL, NULL, 
                NULL, SW_INVALIDATE | SW_ERASE);
        }
    }
}
//--------------------------------------------------------------------------
void OnDisplayResize()
{
    int iTabNum = TabCtrl_GetCurSel(hwndTab);
    if (iTabNum < 0)
        iTabNum = 0;

    int iGroupId = iTabNum/2;

    RECT rc;
    GetClientRect(hwndDisplay, &rc);
    iVertPageSize = RECTHEIGHT(&rc);

    iMaxVertOffset = ((iItemCount[iGroupId]+1)*szCell.cy) - iVertPageSize;
    if (iMaxVertOffset < 0)
        iMaxVertOffset = 0;

    if (iVertOffset > iMaxVertOffset)
        iVertOffset = iMaxVertOffset;

    //---- set scrolling info ----
    SetScrollRange(hwndDisplay, SB_VERT, 0, iMaxVertOffset, FALSE);
    SetScrollPos(hwndDisplay, SB_VERT, iVertOffset, TRUE);
}
//--------------------------------------------------------------------------
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        int wmId, wmEvent;
    int iWidth, iHeight;

        switch (message) 
        {
                case WM_COMMAND:
                        wmId    = LOWORD(wParam); 
                        wmEvent = HIWORD(wParam); 
                        // Parse the menu selections:
                        switch (wmId)
                        {
                                case IDM_ABOUT:
                                   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, About);
                                   break;
                                case IDM_EXIT:
                                   DestroyWindow(hWnd);
                                   break;
                                default:
                                   return DefWindowProc(hWnd, message, wParam, lParam);
                        }
                        break;

       case WM_NOTIFY: 
            NMHDR *phdr;
            phdr = (NMHDR *)lParam;
            if (phdr->code == TCN_SELCHANGE)    // tab selection
            {
                iVertOffset = 0;
                OnDisplayResize();
                InvalidateRect(hwndDisplay, NULL, TRUE);
            }
            break; 

        case WM_SIZE:
            iWidth = LOWORD(lParam);
            iHeight = HIWORD(lParam);

            MoveWindow(hwndTab, 0, 0, iWidth, iHeight, TRUE);

            RECT rc;
            SetRect(&rc, 0, 0, iWidth, iHeight);
            TabCtrl_AdjustRect(hwndTab, FALSE, &rc);

            MoveWindow(hwndDisplay, rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc), TRUE);
            break;

        case WM_MOUSEWHEEL:
            HandleVScroll(message, wParam, lParam);
            return 0;

                case WM_DESTROY:
                        PostQuitMessage(0);
                        break;

                default:
                        return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//--------------------------------------------------------------------------
LRESULT CALLBACK DisplayWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        int wmId, wmEvent;
        PAINTSTRUCT ps;
        HDC hdc;

    int iTabNum = TabCtrl_GetCurSel(hwndTab);
    if (iTabNum < 0)
        iTabNum = 0;

    int iGroupId = iTabNum/2;

        switch (message) 
        {
            case WM_COMMAND:
                    wmId    = LOWORD(wParam); 
                    wmEvent = HIWORD(wParam); 
                    // Parse the menu selections:
                    switch (wmId)
                    {
                            case IDM_ABOUT:
                               DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, About);
                               break;
                            case IDM_EXIT:
                               DestroyWindow(hWnd);
                               break;
                            default:
                               return DefWindowProc(hWnd, message, wParam, lParam);
                    }
                    break;

            case WM_PAINT:
                RECT rt;

                hdc = BeginPaint(hWnd, &ps);

                if (iTabNum % 2)       // if its a mirrored page
                    SetLayout(hdc, LAYOUT_RTL);
                else
                    SetLayout(hdc, 0);

                GetClientRect(hWnd, &rt);
                    
                PaintObjects(hdc, &rt, iGroupId);

                EndPaint(hWnd, &ps);
                break;

            case WM_VSCROLL:
                HandleVScroll(message, wParam, lParam);
                return 0;

            case WM_SIZE:
                OnDisplayResize();
                break;

            case WM_DESTROY:
                PostQuitMessage(0);
                break;

            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//--------------------------------------------------------------------------
BOOL CreateAllWindows()
{
    TCITEM tci = {0};
    BOOL fOk = FALSE;
    int i;

    //---- create main window ----
    hwndMain = CreateWindow(pszMainWindowClass, L"Clipper", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInst, NULL);
    if (! hwndMain)
        goto exit;

    //---- create tab control covering main client area ----
    RECT rc;
    GetClientRect(hwndMain, &rc);
                        
    hwndTab = CreateWindowEx(0, WC_TABCONTROL, L"", 
        WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|TCS_MULTILINE|TCS_HOTTRACK|WS_VISIBLE,
        rc.left, rc.top, (int)RECTWIDTH(&rc), (int)RECTHEIGHT(&rc), hwndMain, NULL, hInst, NULL);
    if (! hwndTab)
        goto exit;

    //---- create the display window in the tab control "display area" ----
    hwndDisplay = CreateWindow(pszDisplayWindowClass, L"", WS_CHILD|WS_VSCROLL|WS_VISIBLE,
        rc.left, rc.top, (int)RECTWIDTH(&rc), (int)RECTHEIGHT(&rc), hwndTab, NULL, hInst, NULL);
    if (! hwndDisplay)
        goto exit;

    //---- add tab pages ----
    tci.mask = TCIF_TEXT;

    TabCtrl_SetPadding(hwndTab, 7, 3);

    for (i=0; i < ARRAYSIZE(szPageNames); i++)
    {
        tci.pszText = (LPWSTR)szPageNames[i];
        SendMessage(hwndTab, TCM_INSERTITEM, i, (LPARAM)&tci);
    }

    fOk = TRUE;

exit:
    return fOk;
}
//--------------------------------------------------------------------------
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
        switch (message)
        {
                case WM_INITDIALOG:
                                return TRUE;

                case WM_COMMAND:
                        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
                        {
                                EndDialog(hDlg, LOWORD(wParam));
                                return TRUE;
                        }
                        break;
        }

    return FALSE;
}
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\imagecon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ImageCon.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\imagecon\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set 
//---------------------------------------------------------------------------
#ifndef _STDAFX_H_
#define _STDAFX_H_
//---------------------------------------------------------------------------
#define _iswupper(_c)    ( iswctype(_c,_UPPER) )
#define _iswlower(_c)    ( iswctype(_c,_LOWER) )
#define _iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define _iswxdigit(_c)   ( iswctype(_c,_HEX) )
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define STRICT
#define _ATL_NO_ATTRIBUTES
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#include "log.h"
#include "errors.h"
#include "utils.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
#define STRSAFE_LIB
#include <strsafe.h>
//---------------------------------------------------------------------------
#endif //_STDAFX_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\clipper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CLIPPER.RC
//
#define IDR_MAINFRAME				128
#define IDD_CLIPPER_DIALOG		    102
#define IDD_ABOUTBOX				103
#define IDS_APP_TITLE				103
#define IDM_ABOUT					104
#define IDM_EXIT					105
#define IDS_HELLO					106
#define IDI_CLIPPER	                107
#define IDI_SMALL					108
#define IDC_CLIPPER	                109
#define IDC_MYICON					2
#define IDC_STATIC	                -1

#define IDB_STRETCH                 110
#define IDB_STRETCH_TRANS           111

#define IDB_TILE                    112
#define IDB_TILE_TRANS              113

#define IDB_TRUE                    114
#define IDB_TRUE_TRANS              115
#define IDB_TRUE_ALPHA              116

#define IDB_GLYPHBG                 117

#define IDB_GLYPH                   118
#define IDB_GLYPH_TRANS             119
#define IDB_GLYPH_ALPHA             120

#define IDB_MULTI1                  121
#define IDB_MULTI2                  122
#define IDB_MULTI3                  123
#define IDB_MULTI4                  124

#define IDB_BORDERTEST              125

#define IDB_PUSHBUTTON              130
#define IDB_CHECKBOX                131

#define IDB_RADIO13                 140
#define IDB_RADIO16                 141
#define IDB_RADIO25                 142

#define IDB_CHECK13                 150
#define IDB_CHECK16                 151
#define IDB_CHECK25                 152

#define IDB_PROGRESS_TRACK          160
#define IDB_PROGRESS_CHUNK          161

#define IDB_SCROLL_ARROWS           170
#define IDB_SCROLL_GLPYHS           171


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        180
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           150
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\clipper\stdafx.h ===
//---------------------------------------------------------------------------
// stdafx.h : include file for standard system include files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <atlbase.h>

#include <uxthemep.h>
#include <tmschema.h>

#define  STRSAFE_LIB
#include <strsafe.h>

//---------------------------------------------------------------------------
#define WIDTH(rc) ((rc).right - (rc).left)
#define HEIGHT(rc) ((rc).bottom - (rc).top)

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\imagecon\imagecon.cpp ===
//---------------------------------------------------------------------------
//  ImageCon.cpp - converts from one file format to another
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <uxthemep.h>
#include <utils.h>
#include "SimpStr.h"
#include "Scanner.h"
#include "shlwapip.h"
#include "themeldr.h"
//---------------------------------------------------------------------------
void PrintUsage()
{
    wprintf(L"\nUsage: imagecon <input name> <output name> \n");
    wprintf(L"\n");
}
//---------------------------------------------------------------------------
extern "C" WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE previnst, 
    LPTSTR pszCmdLine, int nShowCmd)
{
    //---- initialize globals from themeldr.lib ----
    ThemeLibStartUp(FALSE);

    WCHAR szOutput[_MAX_PATH+1] = {0};
    WCHAR szInput[_MAX_PATH+1] = {0};
    BOOL fQuietRun = FALSE;

    if (! fQuietRun)
    {
        wprintf(L"Microsoft (R) Image Converter (Version .1)\n");
        wprintf(L"Copyright (C) Microsoft Corp 2000. All rights reserved.\n");
    }

    CScanner scan(pszCmdLine);

    BOOL gotem = scan.GetFileName(szInput, ARRAYSIZE(szInput));
    if (gotem)
        gotem = scan.GetFileName(szOutput, ARRAYSIZE(szOutput));

    if (! gotem)
    {
        PrintUsage(); 
        return 1;
    }

    HRESULT hr = S_OK;

    if (! FileExists(szInput))
        hr = MakeError32(STG_E_FILENOTFOUND);       
    else
    {
        //---- protect ourselves from crashes ----
        try
        {
            hr = SHConvertGraphicsFile(szInput, szOutput, SHCGF_REPLACEFILE);
        }
        catch (...)
        {
            hr = MakeError32(E_FAIL);
        }
    }

    if ((SUCCEEDED(hr)) && (! FileExists(szOutput)))
        hr = MakeError32(E_FAIL);

    if (FAILED(hr))
    {
        LPWSTR pszMsgBuff = NULL;

        if( !FileExists( szInput ) )
        {
            wprintf( L"\nFile not found: '%s'\n", szInput );
        }
        else if( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM 
                               | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, 
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&pszMsgBuff, 0, NULL) )
        {
            printf("Error in converting: %S", pszMsgBuff);
            LocalFree(pszMsgBuff);
        }
        else
        {
            wprintf( L"\nError in converting image file.\n");
        }

        return 1;
    }

    printf("Converted image file to: %S\n", szOutput);
    return 0;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\cfile.h ===
//---------------------------------------------------------------------------
//    cfile.h - file read/write (ansi/unicode) helper class
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#ifndef CFILE_H
#define CFILE_H
//---------------------------------------------------------------------------
class CSimpleFile
{
public:
    HANDLE _hFile;
    BOOL _fAnsi;

    CSimpleFile()
    {
        _hFile = INVALID_HANDLE_VALUE;
        _fAnsi = FALSE;
    }

    BOOL IsOpen()
    {
        return _hFile != INVALID_HANDLE_VALUE;
    }

    HRESULT Create(LPCWSTR lpsz, BOOL fAnsi=FALSE)
    {
        _fAnsi = fAnsi;

        _hFile = CreateFile(lpsz, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
        if (_hFile == INVALID_HANDLE_VALUE)
            return MakeErrorLast();
        
        return S_OK;
    }

    HRESULT Open(LPCWSTR lpsz, BOOL fAnsi=FALSE, BOOL fExclusive=FALSE)
    {
        _fAnsi = fAnsi;

        DWORD dwShare = 0;
        if (! fExclusive)
            dwShare = FILE_SHARE_READ;

        _hFile = CreateFile(lpsz, GENERIC_READ, dwShare, NULL, OPEN_EXISTING, 0, NULL);
        if (_hFile == INVALID_HANDLE_VALUE)
            return MakeErrorLast();
        
        return S_OK;
    }

    HRESULT Append(LPCWSTR lpsz, BOOL fAnsi=FALSE)
    {
        _fAnsi = fAnsi;

        _hFile = CreateFile(lpsz, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
        if (_hFile == INVALID_HANDLE_VALUE)
            return MakeErrorLast();

        // cannot rely on retval from SetFilePointer() so must use GetLastError()
        SetLastError(0);  
        SetFilePointer(_hFile, 0, NULL, FILE_END);
        if (GetLastError() != NO_ERROR)
            return MakeErrorLast();

        return S_OK;
    }

    DWORD GetFileSize(DWORD* pdw = NULL)
    {
        return ::GetFileSize(_hFile, pdw);
    }

    HRESULT Printf(LPCWSTR fmtstr, ...)
    {
        va_list args;
        va_start(args, fmtstr);

        WCHAR msgbuff[2048];

        //---- format caller's string ----
        StringCchVPrintfW(msgbuff, ARRAYSIZE(msgbuff), fmtstr, args);
        va_end(args);

        return Write((void*)msgbuff, lstrlen(msgbuff)*sizeof(WCHAR));
    }

    HRESULT OutLine(LPCWSTR fmtstr, ...)
    {
        va_list args;
        va_start(args, fmtstr);

        WCHAR msgbuff[2048];

        //---- format caller's string ----
        StringCchVPrintfW(msgbuff, ARRAYSIZE(msgbuff), fmtstr, args);
        va_end(args);

        //---- add a CR/LF at end ----
        StringCchCatW(msgbuff, ARRAYSIZE(msgbuff), L"\r\n");

        return Write((void*)msgbuff, lstrlen(msgbuff)*sizeof(WCHAR));
    }

    ~CSimpleFile()
    {
        Close();
    }

    void Close()
    {
        if (_hFile != INVALID_HANDLE_VALUE)
            CloseHandle(_hFile);

        _hFile = INVALID_HANDLE_VALUE;
    }

    HRESULT Write(void* pv, DWORD dwBytes)
    {
        HRESULT hr = S_OK;

        DWORD dw;
        if (_fAnsi)
        {
            USES_CONVERSION;
            LPSTR p = W2A((LPCWSTR)pv);
            if (! WriteFile(_hFile, p, dwBytes/sizeof(WCHAR), &dw, NULL))
                hr = MakeErrorLast();
        }
        else
        {
            if (! WriteFile(_hFile, pv, dwBytes, &dw, NULL))
                hr = MakeErrorLast();
        }

        return hr;
    }

    HRESULT Read(void* lpBuffer, DWORD n, DWORD* lpcb)
    {
        HRESULT hr = S_OK;

        if (_fAnsi)
        {
            ASSERT(FALSE); // you don't want to be here.  Here's why (exercise for the reader):

#if 0
            LPSTR pszAnsiBuff = new CHAR[n+1];

            if (pszAnsiBuff)
            {
                if (ReadFile(_hFile, pszAnsiBuff, n, lpcb, NULL))
                {
                    //  Copy out as unicode.
                    USES_CONVERSION;
                    pszAnsiBuff[*lpcb] = 0;      // zero terminate

                    // THIS IS UNACCEPTABLE:
                    #error I'm an idiot.
                    LPCWSTR pwsz = A2W(pszAnsiBuff);
                    
                    // CALLER GETS SCREWED HERE (half of the contents of the file):
                    CopyMemory(lpBuffer, pwsz, lstrlen(pwsz));  // no room for NULL
                }
                else
                {
                    hr = MakeErrorLast();
                }

                delete [] pszAnsiBuff;
            }
            else
            {
                hr = MakeError32(E_OUTOFMEMORY);
            }
#endif 0

        }
        else
        {
            if (! ReadFile(_hFile, lpBuffer, n, lpcb, NULL))
                hr = MakeErrorLast();
        }

        return hr;
    }
};
//---------------------------------------------------------------------------
#endif      // CFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\autos.h ===
//-------------------------------------------------------------------------
//	Autos.h - resource holder classes that automatically return their resource
//            resources in the destructors.  These can be declared on the stack
//            to free resources whenever the enclosing block is exited or 
//            as class member variables that free the associated resources
//            when the containing object is destroyed.
//-------------------------------------------------------------------------
#ifndef _AUTOS_H_
#define _AUTOS_H_
//-------------------------------------------------------------------------
#include "errors.h"
#include "utils.h"
//-------------------------------------------------------------------------
class COptionalDC
{
public:
    COptionalDC(HDC hdcOpt)
    {
        _hdc = hdcOpt;
        _fReleaseDC = FALSE;

        if (! _hdc)
        {
            _hdc = GetWindowDC(NULL);
            if (_hdc)
            {
                _fReleaseDC = TRUE;
            }
        }
    }

    operator HDC()
    {
        return _hdc;
    }

    ~COptionalDC()
    {
        if (_fReleaseDC)
        {
            ReleaseDC(NULL, _hdc);
        }
    }

private:
    HDC _hdc;
    BOOL _fReleaseDC;
};
//-------------------------------------------------------------------------
template <class T>
class CAutoGDI 
{
public:
    CAutoGDI(T Value=NULL)
    {
        _Handle = Value;
    }

    ~CAutoGDI()
    {
        if (_Handle)
            DeleteObject(_Handle);
    }

    T & operator = (T Value) 
    {
        if (_Handle)
            DeleteObject(_Handle);

        _Handle = Value;

        return _Handle;
    }

    operator T() const
    {
        return _Handle;
    }


protected:
    T _Handle;
};
//------------------------------------------------------------------------------------
class CAutoDC
{
public:
    CAutoDC(HDC Value=NULL)
    {
        _hdc = Value;

        _fOldPen = FALSE;
        _fOldBrush = FALSE;
        _fOldBitmap = FALSE;
        _fOldFont = FALSE;
        _fOldRegion = FALSE;
    }

    ~CAutoDC()
    {
        RestoreObjects();
    }

    HDC & operator = (HDC &Value) 
    {
        if (_hdc)
            RestoreObjects();

        _hdc = Value;

        return _hdc;
    }

    operator HDC() const
    {
        return _hdc;
    }

    void RestoreObjects()
    {
        if (_fOldBitmap)
        {
            SelectObject(_hdc, _hOldBitmap);
            _fOldBitmap = FALSE;
        }

        if (_fOldFont)
        {
            SelectObject(_hdc, _hOldFont);
            _fOldFont = FALSE;
        }

        if (_fOldPen)
        {
            SelectObject(_hdc, _hOldPen);
            _fOldPen = FALSE;
        }

        if (_fOldBrush)
        {
            SelectObject(_hdc, _hOldBrush);
            _fOldBrush = FALSE;
        }

        if (_fOldRegion)
        {
            SelectObject(_hdc, _hOldRegion);
            _fOldRegion = FALSE;
        }
    }

    inline HBITMAP SelectBitmap(HBITMAP hValue)
    {
        if (! _fOldBitmap)
        {
            _fOldBitmap = TRUE;
            _hOldBitmap = (HBITMAP)SelectObject(_hdc, hValue);
            return _hOldBitmap;
        }
        return (HBITMAP)SelectObject(_hdc, hValue);
    }

    inline HFONT SelectFont(HFONT hValue)
    {
        if (! _fOldFont)
        {
            _fOldFont = TRUE;
            _hOldFont = (HFONT)SelectObject(_hdc, hValue);
            return _hOldFont;
        }
        return (HFONT)SelectObject(_hdc, hValue);
    }

    inline HBRUSH SelectBrush(HBRUSH hValue)
    {
        if (! _fOldBrush)
        {
            _fOldBrush = TRUE;
            _hOldBrush = (HBRUSH)SelectObject(_hdc, hValue);
            return _hOldBrush;
        }

        return (HBRUSH) SelectObject(_hdc, hValue);
    }

    inline HPEN SelectPen(HPEN hValue)
    {
        if (! _fOldPen)
        {
            _fOldPen = TRUE;
            _hOldPen = (HPEN)SelectObject(_hdc, hValue);
            return _hOldPen;
        }
        return (HPEN)SelectObject(_hdc, hValue);
    }

    inline HRGN SelectRegion(HRGN hValue)
    {
        if (! _fOldRegion)
        {
            _fOldRegion = TRUE;
            _hOldRegion = (HRGN)SelectObject(_hdc, hValue);
            return _hOldRegion;
        }
        return (HRGN)SelectObject(_hdc, hValue);
    }


protected:
    HDC _hdc;

    BOOL _fOldBitmap;
    BOOL _fOldFont;
    BOOL _fOldBrush;
    BOOL _fOldPen;
    BOOL _fOldRegion;

    HBITMAP _hOldBitmap;
    HFONT _hOldFont;
    HBRUSH _hOldBrush;
    HPEN _hOldPen;
    HRGN _hOldRegion;
};
//------------------------------------------------------------------------------------
class CAutoCS
{
public:
    CAutoCS(CRITICAL_SECTION *pcs)
    {
        _pcs = pcs;
        SAFE_ENTERCRITICALSECTION(_pcs);
    }

    ~CAutoCS()
    {
        SAFE_LEAVECRITICALSECTION(_pcs);
    }

protected:
    CRITICAL_SECTION *_pcs;
};
//------------------------------------------------------------------------------------
class CSaveClipRegion
{
public:
    CSaveClipRegion()
    {
        _hRegion = NULL;
        _fSaved = FALSE;
    }

    HRESULT Save(HDC hdc)
    {
        HRESULT hr;
        int iRetVal;

        if (! _hRegion)
        {
            _hRegion = CreateRectRgn(0, 0, 1, 1);      
            if (! _hRegion)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }

        iRetVal = GetClipRgn(hdc, _hRegion);
        if (iRetVal == -1)
        {
            hr = MakeErrorLast();
            goto exit;
        }

        if (iRetVal == 0)       // no previous region
        {
            DeleteObject(_hRegion);
            _hRegion = NULL;
        }

        _fSaved = TRUE;
        hr = S_OK;

exit:
        return hr;

    }

    HRESULT Restore(HDC hdc)
    {
        if (_fSaved)
        {
            //---- works for both NULL and valid _hRegion ----
            SelectClipRgn(hdc, _hRegion);
        }

        return S_OK;
    }


    ~CSaveClipRegion()
    {
        if (_hRegion)
        {
            DeleteObject(_hRegion);
            _hRegion = NULL;
        }
    }

protected:
    HRGN _hRegion;
    BOOL _fSaved;
};
//------------------------------------------------------------------------------------
template <class T>
class CAutoArrayPtr
{
public:
    CAutoArrayPtr(T *pValue=NULL)
    {
        _pMem = pValue;
    }

    ~CAutoArrayPtr()
    {
        if (_pMem)
            delete [] _pMem;
    }

    T * operator = (T *pValue) 
    {
        if (_pMem)
            delete [] _pMem;

        _pMem = pValue;
        return _pMem;
    }

    T & operator [] (int iIndex) const
    {
        return _pMem[iIndex];
    }

    operator T*() const
    {
        return _pMem;
    }

    bool operator!() const
	{
		return (_pMem == NULL);
	}

	T** operator&()
	{
		return &_pMem;
	}

protected:
    T *_pMem;
};
//------------------------------------------------------------------------------------
#endif      // _AUTOS_H_
//------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\logopts.h ===
//-----------------------------------------------------------------
//   LogOpts.h - logging options
//-----------------------------------------------------------------
#ifdef MAKE_LOG_STRINGS          // this file in #include-ed twice

#define BEGIN_LOG_OPTIONS()         static const LOGNAMEINFO LogNames[] = {
#define LOGOPT(val, key, desc)      {key, desc},
#define END_LOG_OPTIONS()           };

#else

#define BEGIN_LOG_OPTIONS()         enum LogOptions {
#define LOGOPT(val, key, desc)      val,
#define END_LOG_OPTIONS()           };

#endif
//-----------------------------------------------------------------
BEGIN_LOG_OPTIONS()

    //---- log options ----
    LOGOPT(LO_BREAK,      "Break",      "Controls whether DebugBreak()'s are enabled")
    LOGOPT(LO_CONSOLE,    "Console",    "log msgs to the debugger console")
    LOGOPT(LO_LOGFILE,    "LogFile",    "log msgs to c:\themes.log")
    LOGOPT(LO_TIMERID,    "TimerId",    "msgs contain a relative timer")
    LOGOPT(LO_CLOCKID,    "ClockId",    "msgs contain the clock time")
    LOGOPT(LO_SRCID,      "SrcId",      "msgs contain their source file name & line number")
    LOGOPT(LO_APPID,      "AppId",      "msgs contain their app name")
    LOGOPT(LO_THREADID,   "ThreadId",   "msgs contain their thread id")
    LOGOPT(LO_USERCOUNT,  "UserCount",  "msgs contain open USER handle count")
    LOGOPT(LO_GDICOUNT,   "GdiCount",   "msgs contain open GDI handle count")
    LOGOPT(LO_MEMUSAGE,   "MemUsage",   "msgs contain memory usage")
    LOGOPT(LO_HEAPCHECK,  "HeapCheck",  "heap is validated as each msg is displayed")
    LOGOPT(LO_SHUTDOWN,   "ShutDown",   "Force early uxtheme ShutDown() code on top win close")

    //---- msg filter presets ----
    LOGOPT(LO_ALL,      "All",          "turn on/off all msg filters")

    //---- msg filters (*** MUST ADD TO LOG_XXX DEFINES BELOW ***) ----
    LOGOPT(LO_ASSERT,   "Assert",       "log assert msg & DebugBreak()")
    LOGOPT(LO_ERROR,    "Error",        "log error msg & DebugBreak()")
    LOGOPT(LO_ALWAYS,   "Always",       "always log but don't break")
    LOGOPT(LO_PERF,     "Perf",         "perf related msgs")
    LOGOPT(LO_PARAMS,   "Params",       "log bad API params")

    LOGOPT(LO_TMAPI,    "TMAPI",        "monitor all uxthem API entry/exit")
    LOGOPT(LO_TMLOAD,   "TMLoad",       "track theme file load/unloads")
    LOGOPT(LO_TMCHANGE, "TMChange",     "monitor events during theme load/unloads")
    LOGOPT(LO_TMCHANGEMSG, "TMChangeMsg",     "monitor msgs sent/received during theme changes")
    LOGOPT(LO_TMSTARTUP,"TMStartUp",    "log thread/process startup/shutdown calls")
    LOGOPT(LO_TMOPEN,   "TMOPEN",       "_OpenThemeData() & CloseThemeData() calls")
    LOGOPT(LO_TMHANDLE, "TMHANDLE",     "track calls to open/close theme file handles")
    LOGOPT(LO_TMBITMAP, "TMBITMAP",     "track calls to bitmap creation and use")
    LOGOPT(LO_TMBRUSHES,"TMBRUSHES",    "track calls to brushes creation and use")
    LOGOPT(LO_TM,       "TM",           "general theme manager events")
    LOGOPT(LO_CACHE,    "Cache",        "trace Caching API's")
    LOGOPT(LO_RFBUG,    "RfBug",        "trace info relating to roland's current bug")
    LOGOPT(LO_TILECNT,  "TileCnt",      "count # of tiling bitblt calls needed")
    LOGOPT(LO_BADHTHEME,"BadHTheme",    "log any illegal HTHEME handles in public api's")

    LOGOPT(LO_WINDUMP,  "WinDump",      "dump of windows by process")
    LOGOPT(LO_COMPOSITE,"Composite",    "WS_EX_COMPOSITED related processing")
    LOGOPT(LO_CAPTION,  "Caption",      "Experimental caption drawing")

    LOGOPT(LO_NCATTACH, "NCAttach",     "monitor events during NC window attach/detach")
    LOGOPT(LO_NCMSGS,   "NCMsgs",       "monitor all nc theme msgs that we process")
    LOGOPT(LO_NCMETRICS, "NCMetrics",   "info about NC metrics calcs")
    LOGOPT(LO_NCTRACE,  "NCTrace",      "entry/exit tracing in key NC functions")

END_LOG_OPTIONS()
//---------------------------------------------------------------------------
#undef BEGIN_LOG_OPTIONS
#undef LOGOPT
#undef END_LOG_OPTIONS
//---------------------------------------------------------------------------
#define LOGPARAMS            __FILE__, __LINE__

//---- use these msg filters for calls to Log() ----

#define LOG_ASSERT           LO_ASSERT, LOGPARAMS, 0
#define LOG_ERROR            LO_ERROR, LOGPARAMS, 0
#define LOG_ALWAYS           LO_ALWAYS, LOGPARAMS, 0
#define LOG_PERF             LO_PERF, LOGPARAMS, 0
#define LOG_PARAMS           LO_PARAMS, LOGPARAMS, 0

#define LOG_TMAPI            LO_TMAPI, LOGPARAMS, 0
#define LOG_TMLOAD           LO_TMLOAD, LOGPARAMS, 0
#define LOG_TMSTARTUP        LO_TMSTARTUP, LOGPARAMS, 0
#define LOG_TMCHANGE         LO_TMCHANGE, LOGPARAMS, 0
#define LOG_TMCHANGEMSG      LO_TMCHANGEMSG, LOGPARAMS, 0
#define LOG_TMOPEN           LO_TMOPEN, LOGPARAMS, 0
#define LOG_TMHANDLE         LO_TMHANDLE, LOGPARAMS, 0
#define LOG_TMBITMAP         LO_TMBITMAP, LOGPARAMS, 0
#define LOG_TMBRUSHES        LO_TMBRUSHES, LOGPARAMS, 0
#define LOG_TM               LO_TM, LOGPARAMS, 0
#define LOG_CACHE            LO_CACHE, LOGPARAMS, 0
#define LOG_RFBUG            LO_RFBUG, LOGPARAMS, 0
#define LOG_TILECNT          LO_TILECNT, LOGPARAMS, 0
#define LOG_BADHTHEME        LO_BADHTHEME, LOGPARAMS, 0

#define LOG_WINDUMP          LO_WINDUMP, LOGPARAMS, 0
#define LOG_COMPOSITE        LO_COMPOSITE, LOGPARAMS, 0
#define LOG_CAPTION          LO_CAPTION, LOGPARAMS, 0

#define LOG_NCATTACH         LO_NCATTACH, LOGPARAMS, 0
#define LOG_NCMSGS           LO_NCMSGS, LOGPARAMS, 0
#define LOG_NCMETRICS        LO_NCMETRICS, LOGPARAMS, 0
#define LOG_NCTRACE          LO_NCTRACE, LOGPARAMS, 0
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\scanner.h ===
//---------------------------------------------------------------------------
//  Scanner.h - supports parsing lines & text files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define ISNUMSTART(p)   ((isdigit(*p)) || (*p == '-') || (*p == '+'))
#define IS_NAME_CHAR(p) ((isalnum(*p)) || (*p == '_') || (*p == '-'))
//---------------------------------------------------------------------------
#define MAX_ID_LEN      _MAX_PATH
#define MAX_INPUT_LINE  255
//---------------------------------------------------------------------------
class CScanner
{
public:
    CScanner(LPCWSTR pszTextToScan=NULL);
    ~CScanner();
    HRESULT AttachFile(LPCWSTR pszFileName);
    BOOL AttachLine(LPCWSTR pszLine);
    BOOL AttachMultiLineBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName);
    BOOL GetId(LPWSTR pszIdBuff, DWORD dwMaxLen=MAX_ID_LEN);
    BOOL GetIdPair(LPWSTR pszIdBuff, LPWSTR pszValueBuff, DWORD dwMaxLen=MAX_ID_LEN);
    BOOL GetKeyword(LPCWSTR pszKeyword);
    BOOL GetFileName(LPWSTR pszBuff, DWORD dwMaxLen);
    BOOL GetNumber(int *piVal);
    BOOL IsNameChar(BOOL fOkToSkip=TRUE);
    BOOL IsFileNameChar(BOOL fOkToSkip);
    BOOL IsNumStart();
    BOOL GetChar(const WCHAR val);
    BOOL EndOfLine();
    BOOL EndOfFile();
    BOOL ForceNextLine();
    BOOL SkipSpaces();              // called by CScanner before all checking routines
    BOOL ReadNextLine();
    void UseSymbol(LPCWSTR pszSymbol);

protected:
    void ResetAll(BOOL fPossiblyAllocated);

public:
    //---- data ----
    const WCHAR *_p;              // accessible for special comparisons
    const WCHAR *_pSymbol;        // if not null, use this instead of _p
    WCHAR _szLineBuff[MAX_INPUT_LINE+1];
    WCHAR _szFileName[_MAX_PATH+1];
    LPCWSTR _pszMultiLineBuffer;
    LPWSTR _pszFileText;
    int _iLineNum;
    BOOL _fEndOfFile;
    BOOL _fBlankSoFar;
    BOOL _fUnicodeInput;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\errors.h ===
//---------------------------------------------------------------------------
//    errors.h - support for creating and reporting errors
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#ifndef ERRORS_H
#define ERRORS_H
//---------------------------------------------------------------------------
typedef struct            // records theme api's last error return code
{
    DWORD dwParseErrCode;  
    WCHAR szMsgParam1[MAX_PATH];
    WCHAR szMsgParam2[MAX_PATH];
    WCHAR szFileName[MAX_PATH];
    WCHAR szSourceLine[MAX_PATH];
    int iLineNum;
} TMERRINFO;
//---------------------------------------------------------------------------
extern DWORD _tls_ErrorInfoIndex;
//---------------------------------------------------------------------------
TMERRINFO *GetParseErrorInfo(BOOL fOkToCreate);

HRESULT MakeParseError(DWORD dwParseErrCode, OPTIONAL LPCWSTR pszMsgParam1=NULL, OPTIONAL LPCWSTR pszMsgParam2=NULL,
    OPTIONAL LPCWSTR pszSourceName=NULL, OPTIONAL LPCWSTR pszSourceLine=NULL, int iLineNum=0);
//---------------------------------------------------------------------------
#define WIN32_EXIT(code)        if (code) {hr=HRESULT_FROM_WIN32(code); goto exit;} else
#define SET_LAST_ERROR(hr)      SetLastError((DWORD) hr)
//---------------------------------------------------------------------------
HRESULT MakeError32(HRESULT hr);
HRESULT MakeErrorLast();
HRESULT MakeErrorParserLast();
//---------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\log.h ===
//---------------------------------------------------------------------------
//    log.h - theme logging routines
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#ifndef LOG_H
#define LOG_H
//---------------------------------------------------------------------------
#include "logopts.h"        // log options as enums
//---------------------------------------------------------------------------
#ifdef DEBUG
#define LOGGING 1
#endif
//-----------------------------------------------------------------
//---- set this to "GetMemUsage", "GetUserCount", or "GetGdiCount" ----
//---- it controls which resource is tracked across entry/exit calls ----
#define ENTRY_EXIT_FUNC        GetGdiCount()
#define ENTRY_EXIT_NAME        L"GdiCount()"
//-----------------------------------------------------------------
//   Note: 
//      For builds without DEBUG defined (FRE builds), calling
//      code will reference an underscore version of all public 
//      logging routines (_xxx()).  These functions are defined
//      as inline with little or no code (no code means no caller 
//      code is generated).
//
//      For DEBUG defined (CHK) builds, the calling code connects
//      with the normally named logging routines.
//
//      This is done to keep calling code to a minimum for FRE
//      builds, to avoid LOG2(), LOG3() type defines that vary
//      with param count, and to keep build system happy when
//      mixing FRE and CHK callers and libraries.
//-----------------------------------------------------------------
//---- these are used for CHK builds only but must be defined for both ----
void Log(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryCode, LPCWSTR pszFormat, ...);
BOOL LogStartUp();
BOOL LogShutDown();
void LogControl(LPCSTR pszOptions, BOOL fEcho);
void TimeToStr(UINT uRaw, WCHAR *pszBuff, ULONG cchBuff);
DWORD StartTimer();
DWORD StopTimer(DWORD dwStartTime);
HRESULT OpenLogFile(LPCWSTR pszLogFileName);
void CloseLogFile();
int GetMemUsage();
int GetUserCount();
int GetGdiCount();
BOOL LogOptionOn(int iLogOption);
//-----------------------------------------------------------------
#ifdef LOGGING

#define LogEntry(pszFunc)              \
    LOGENTRYCODE;  Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY (%s=%d)", pszFunc, \
    ENTRY_EXIT_NAME, _iEntryValue);
 
#define LogEntryC(pszFunc, pszClass)    \
    LOGENTRYCODE;  Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY, class=%s (%s=%d)", \
    pszFunc, pszClass, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogEntryW(pszFunc)              \
    LOGENTRYCODEW;   Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY (%s=%d)", pszFunc, \
    ENTRY_EXIT_NAME, _iEntryValue);

#define LogEntryCW(pszFunc, pszClass)    \
    LOGENTRYCODEW; Log(LO_TMAPI, LOGPARAMS, 1, L"%s ENTRY, class=%s (%s=%d)", \
    pszFunc, pszClass, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogEntryNC(pszFunc)            \
    LOGENTRYCODE;  Log(LO_NCTRACE, LOGPARAMS, 1, L"%s ENTRY (%s=%d)", \
    pszFunc, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogEntryMsg(pszFunc, hwnd, umsg)            \
    LOGENTRYCODE;  Log(LO_NCMSGS, LOGPARAMS, 1, L"%s ENTRY (hwnd=0x%x, umsg=0x%x, %s=%d)", \
    pszFunc, hwnd, umsg, ENTRY_EXIT_NAME, _iEntryValue); 

#define LogExit(pszFunc)                    LOGEXIT(pszFunc, LO_TMAPI)
#define LogExitC(pszFunc, cls)              LOGEXITCLS(pszFunc, LO_TMAPI, cls)
#define LogExitNC(pszFunc)                  LOGEXIT(pszFunc, LO_NCTRACE)
#define LogExitMsg(pszFunc)                 LOGEXIT(pszFunc, LO_NCMSGS)

#define LOGEXIT(pszFunc, filter)  \
{    \
    LOGEXITCODE;   \
    if (_iEntryValue != _ExitValue) \
        Log(filter, LOGPARAMS, -1, L"%s EXIT [%s delta: %d]", pszFunc, ENTRY_EXIT_NAME, _ExitValue-_iEntryValue);  \
    else   \
        Log(filter, LOGPARAMS, -1, L"%s EXIT", pszFunc);  \
}

#define LOGEXITCLS(pszFunc, filter, cls)  \
{    \
    LOGEXITCODE;   \
    if (_iEntryValue != _ExitValue) \
        Log(filter, LOGPARAMS, -1, L"%s EXIT, class=%s [%s delta: %d]", pszFunc, cls, ENTRY_EXIT_NAME, _ExitValue-_iEntryValue);  \
    else   \
        Log(filter, LOGPARAMS, -1, L"%s EXIT, class=%s", pszFunc, cls);  \
}

#ifndef _X86_
#define DEBUG_BREAK        if (LogOptionOn(LO_BREAK)) DebugBreak(); else
#else
#define DEBUG_BREAK        if (LogOptionOn(LO_BREAK)) __asm {int 3} else
#endif

//---- change this when you want to track something different for entry/exit ----
#define LOGENTRYCODE        int _iEntryValue = ENTRY_EXIT_FUNC
#define LOGENTRYCODEW       _iEntryValue = ENTRY_EXIT_FUNC
#define LOGEXITCODE         int _ExitValue = ENTRY_EXIT_FUNC

#else

//---- for FRE builds, connect to the inline routines ----
#define Log             _Log
#define LogStartUp      _LogStartUp
#define LogShutDown     _LogShutDown
#define LogControl      _LogControl
#define TimeToStr       _TimeToStr
#define StartTimer      _StartTimer
#define StopTimer       _StopTimer
#define OpenLogFile     _OpenLogFile
#define CloseLogFile    _CloseLogFile
#define LogOptionOn     _LogOptionOn
#define GetMemUsage     _GetMemUsage
#define GetUserCount    _GetUserCount
#define GetGdiCount     _GetGdiCount

#define LogEntry(pszFunc)   
#define LogEntryC(pszFunc, pszClass) 
#define LogEntryW(pszFunc)   
#define LogEntryCW(pszFunc, pszClass)   
#define LogExit(pszFunc)    
#define LogExitC(pszFunc, pszClass)    
#define LogExitW(pszFunc, pszClass)    
#define LogEntryNC(pszFunc) 
#define LogExitNC(pszFunc)  
#define LogEntryMsg(pszFunc, hwnd, umsg)   
#define LogExitMsg(x)

#define DEBUG_BREAK     (0)

//---- for FRE builds, make these guys gen no or minimum code ----
inline void _Log(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryExitCode, LPCWSTR pszFormat, ...) {}
inline BOOL _LogStartUp() {return TRUE;}
inline BOOL _LogShutDown() {return TRUE;}
inline void _LogControl(LPCSTR pszOptions, BOOL fEcho) {}
inline void _TimeToStr(UINT uRaw, WCHAR *pszBuff, ULONG cchBuf) {}
inline DWORD _StartTimer() {return 0;}
inline DWORD _StopTimer(DWORD dwStartTime) {return 0;}
inline HRESULT _OpenLogFile(LPCWSTR pszLogFileName) {return E_NOTIMPL;}
inline void _CloseLogFile() {}
inline BOOL _LogOptionOn(int iIndex) {return FALSE;}
inline BOOL _pszClassName(int iIndex) {return FALSE;}
inline int GetMemUsage() {return 0;}
inline int GetUserCount() {return 0;}
inline int GetGdiCount() {return 0;}

#endif
//---------------------------------------------------------------------------
#undef ASSERT
#define ATLASSERT(exp) _ASSERTE(exp)
#define ASSERT(exp)    _ASSERTE(exp)
#define _ATL_NO_DEBUG_CRT
//---------------------------------------------------------------------------
#ifdef LOGGING

#   ifndef _ASSERTE
#       define _ASSERTE(exp)   if (! (exp)) { Log(LOG_ASSERT, L#exp); DEBUG_BREAK; } else
#   endif  _ASSERTE
#   define CLASSPTR(x)     ((x) ? ((CRenderObj *)x)->_pszClassName : L"")  
#   define SHARECLASS(x)   (LPCWSTR)x->_pszClassName
#else
#   ifndef _ASSERTE
#       define _ASSERTE(exp)    (0)
#   endif  _ASSERTE
#   define CLASSPTR(x) NULL
#   define SHARECLASS(x) NULL
#endif
//---------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\loader.h ===
//---------------------------------------------------------------------------
//  Loader.h - loads the theme data into shared memory
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Parser.h"
#include "TmSchema.h"
#include "ThemeFile.h"
//---------------------------------------------------------------------------
#define THEMEDATA_VERSION   0x00010006
//---------------------------------------------------------------------------
#define TM_FONTCOUNT    (TMT_LASTFONT - TMT_FIRSTFONT + 1)
#define TM_SIZECOUNT    (TMT_LASTSIZE - TMT_FIRSTSIZE + 1)
#define TM_BOOLCOUNT    (TMT_LASTBOOL - TMT_FIRSTBOOL + 1)
#define TM_STRINGCOUNT  (TMT_LASTSTRING - TMT_FIRSTSTRING + 1)
#define TM_INTCOUNT     (TMT_LASTINT - TMT_FIRSTINT + 1)
//---------------------------------------------------------------------------
class CRenderObj;       // forward
class CImageFile;       // forward
struct DIBINFO;   // forward
//---------------------------------------------------------------------------
struct THEMEMETRICS
{
    //---- subset of system metrics ----
    LOGFONT lfFonts[TM_FONTCOUNT];
    COLORREF crColors[TM_COLORCOUNT];
    int iSizes[TM_SIZECOUNT];
    BOOL fBools[TM_BOOLCOUNT];

    //---- special theme metrics ----
    int iStringOffsets[TM_STRINGCOUNT];
    int iInts[TM_INTCOUNT];
};
//---------------------------------------------------------------------------
struct LOADTHEMEMETRICS : THEMEMETRICS
{
    CWideString wsStrings[TM_STRINGCOUNT];
};

//---------------------------------------------------------------------------
// Signatures for quick cache file validation
const CHAR kszBeginCacheFileSignature[] = "BEGINTHM";
const CHAR kszEndCacheFileSignature[] = "ENDTHEME";
const UINT kcbBeginSignature = sizeof kszBeginCacheFileSignature - 1;
const UINT kcbEndSignature = sizeof kszEndCacheFileSignature - 1;

//---------------------------------------------------------------------------
// Theme section flags
#define SECTION_READY           1
#define SECTION_GLOBAL          2
#define SECTION_HASSTOCKOBJECTS 4

//---------------------------------------------------------------------------
struct THEMEHDR
{
    //---- theme validity ----
    CHAR szSignature[kcbBeginSignature];        // "BEGINTHM"
    DWORD dwVersion;            // THEMEDATA_VERSION
    DWORD dwFlags;              // must have SECTION_READY to be usable
    DWORD dwCheckSum;           // byte-additive total of all bytes following THEMEHDR
    FILETIME ftModifTimeStamp;  // Last modification time of the .msstyles file

    DWORD dwTotalLength;        // total number of bytes of all data (incl. header & begin/end sigs)

    //---- theme id ----
    int iDllNameOffset;         // dll filename of this theme
    int iColorParamOffset;      // color param theme was loaded with
    int iSizeParamOffset;       // size param theme was loaded with
    DWORD dwLangID;             // User lang ID theme was loaded with
    int iLoadId;                // sequential number for each loaded file (workstation local)

    //---- main sections ----
    DWORD iStringsOffset;       // offset to strings
    DWORD iStringsLength;       // total bytes in string section
    DWORD iSectionIndexOffset;  // offset to Section Index
    DWORD iSectionIndexLength;  // length of section indexes
    
    DWORD iGlobalsOffset;           // offset to [globals] section (for globals parts)
    DWORD iGlobalsTextObjOffset;    // offset to text obj for [globals] section
    DWORD iGlobalsDrawObjOffset;    // offset to draw obj for [globals] section

    DWORD iSysMetricsOffset;    // offset to [SysMetrics] section (for theme metrics API support)
};

//---------------------------------------------------------------------------
struct DRAWOBJHDR       // preceeds each draw obj
{
    int iPartNum;
    int iStateNum;
};
//---------------------------------------------------------------------------
struct RGNDATAHDR       // preceeds each draw obj
{
    int iPartNum;
    int iStateNum;
    int iFileIndex;   // for multiple image selection (HDC scaling)
};
//---------------------------------------------------------------------------
//   Shared Theme Data layout:
//
//      // ----- header ----
//      THEMEHDR ThemeHdr;
//
//      // ----- string section ----
//      DWORD dwStringsLength;  // length of string section
//      WCHAR [];               // strings
//
//      // ----- index section ----
//      DWORD dwIndexLengh;     // length of index section
//      DWORD dwIndexCount;     // count of APPCLASSLIVE entries
//      APPCLASSLIVE [];
//
//      // ----- theme data section ----
//      DWORD dwDataLength;     // length of theme data section
//      BYTE [];                // actual theme data
//
//      // ----- end signature
//      CHAR[8];                // ENDTHEME signature
//---------------------------------------------------------------------------
//   A class section within the "theme data section" consists of the
//   following ENTRYs:
//
//      <part jump table>
//
//      <optional state jump table>
//      <property/value entries>
//
//      for each packed drawobject:
//
//          <TMT_RGNLIST entries>      (associated with each DIB)
//          <TMT_DRAWOBJ entry>
//
//      <TMT_TEXTOBJ entries>
//      
//      <end of class marker>
//---------------------------------------------------------------------------
// an ENTRY consists of (all 1-byte aligned):
//
//      WORD usTypeNum;             // declared type id
//      BYTE ePrimVal;              // equiv. primitive type
//      BYTE bFiller;               // # of bytes added after data to align it
//      DWORD dwDataLen;            // includes filler bytes
//      //---- entry data follows ----
//
//---------------------------------------------------------------------------
//  The data for a part jump table ENTRY (TMT_PARTJUMPTABLE) consists of:
//
//      <offset of first drawobj: long>
//      <PartCount (1 + MaxPart): BYTE>
//      <offset to each part's entries: long[]>
//---------------------------------------------------------------------------
//  The data for a state jump table ENTRY (TMT_STATEJUMPTABLE) consists of:
//
//      <StateCount (1 + MaxState): BYTE>
//      <offset to each state's entries: long[]>
//---------------------------------------------------------------------------
//  The data for a rgn list ENTRY (TMT_RGNLIST) consists of:
//
//      <StateCount (1 + MaxState): BYTE>
//      <offset to each state's custom rgn data: long[]>
//---------------------------------------------------------------------------
//  The custom rgn data ENTRY (TMT_RGNDATA) consists of:    
//
//      RGNDATAHDR RgnDataHdr;
//      BYTE Data[];
//---------------------------------------------------------------------------
#define MAX_SHAREDMEM_SIZE (3000*1000)            // 1.5 meg (yikes!)
//---------------------------------------------------------------------------
#ifdef _WIN64
#define ALIGN_FACTOR   8
#else
#define ALIGN_FACTOR   4   
#endif
//---------------------------------------------------------------------------
#define MAX_ENTRY_NESTING  5      // max # of nested entry levels
//---------------------------------------------------------------------------
#define ENTRYHDR_SIZE     (sizeof(SHORT) + sizeof(BYTE) + sizeof(BYTE) + sizeof(int))
//---------------------------------------------------------------------------
struct UNPACKED_ENTRYHDR      // (hdr's in theme are PACKED)
{
    WORD usTypeNum;             // declared type id
    BYTE ePrimVal;              // equiv. primitive type
    BYTE bFiller;               // # of bytes added after data to align it
    DWORD dwDataLen;            // includes filler bytes
};
//---------------------------------------------------------------------------
inline void FillAndSkipHdr(MIXEDPTRS &u, UNPACKED_ENTRYHDR *pHdr)
{
    pHdr->usTypeNum = *u.ps++;
    pHdr->ePrimVal = *u.pb++;
    pHdr->bFiller = *u.pb++;
    pHdr->dwDataLen = *u.pi++;
}
//---------------------------------------------------------------------------
struct PART_STATE_INDEX
{
    int iPartNum;          // 0=parent part
    int iStateNum;
    int iIndex;
    int iLen;
};
//---------------------------------------------------------------------------
struct APPCLASSLIVE        
{
    //---- note: cannot use ptrs since image shared by diff addr-mapping processes ----
    DWORD dwAppNameIndex;
    DWORD dwClassNameIndex;
    int iIndex;
    int iLen;
};
//---------------------------------------------------------------------------
struct APPCLASSLOCAL
{
    CWideString csAppName;
    CWideString csClassName;
    int iMaxPartNum;
    CSimpleArray<PART_STATE_INDEX> PartStateIndexes;
    int iPackedSize;        // total size of section (incl strings) if packed

    APPCLASSLIVE LiveIndex;     // updated during copy to live
}; 
//---------------------------------------------------------------------------
HRESULT InitThemeMetrics(LOADTHEMEMETRICS *tm);
void SetSystemMetrics(THEMEMETRICS *tm, BOOL fSyncLoad);
HRESULT PersistSystemColors(THEMEMETRICS *tm);
//---------------------------------------------------------------------------
class CThemeLoader : IParserCallBack
{
public:
    CThemeLoader();
    ~CThemeLoader();

    HRESULT LoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, OUT HANDLE *pHandle, BOOL fGlobalTheme);

    HRESULT SetWindowThemeInfo(HWND hwnd, LPCWSTR pszThemeIdList); 
    
    HRESULT LoadClassDataIni(HINSTANCE hInst, LPCWSTR pszColorName,
        LPCWSTR pszSizeName, LPWSTR pszFoundIniName, DWORD dwMaxIniNameChars, LPWSTR *ppIniData);

    //---- IParserCallBack ----
    HRESULT AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum, int iIndex, int iLen);

    HRESULT AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen);
    int GetNextDataIndex();

protected:
    //---- helpers ----
    HRESULT PackAndLoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, HINSTANCE hInst);
    HRESULT CopyLocalThemeToLive(int iTotalLength, LPCWSTR pszThemeName, 
        LPCWSTR pszColorParam, LPCWSTR pszSizeParam);
    void FreeLocalTheme();
    HRESULT PackMetrics();
    HRESULT PackThemeStructs();

    BOOL KeyDrawPropertyFound(int iStateDataOffset);
    BOOL KeyTextPropertyFound(int iStateDataOffset);

    HRESULT PackDrawObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, int iStateId);
    HRESULT PackTextObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, int iStateId);

    HRESULT PackDrawObjects(MIXEDPTRS &u, CRenderObj *pRender, int iMaxPart, BOOL fGlobals);
    HRESULT PackTextObjects(MIXEDPTRS &u, CRenderObj *pRender, int iMaxPart, BOOL fGlobals);

    HRESULT CopyPartGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iPartNum, 
        int *piPartJumpTable, int iPartZeroIndex, int iGlobalsIndex, BOOL fGlobalsGroup);

    int GetPartOffset(CRenderObj *pRender, int iPartNum);

    HRESULT CopyClassGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iGlobalsIndex, int iClassNameOffset);
    int GetMaxState(APPCLASSLOCAL *ac, int iPartNum);

    HRESULT AddIndexInternal(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum, int iIndex, int iLen);

    BOOL IndexExists(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum);

    HRESULT AddMissingParent(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum);

    HRESULT EmitEntryHdr(MIXEDPTRS &u, SHORT propnum, BYTE privnum);
    int EndEntry(MIXEDPTRS &u);

    HRESULT PackImageFileInfo(DIBINFO *pdi, CImageFile *pImageObj, MIXEDPTRS &u, 
        CRenderObj *pRender, int iPartId, int iStateId);
    
    HRESULT AllocateThemeFileBytes(BYTE *upb, DWORD dwAdditionalLen);

    // Helper functions to alloc and emit sized data
    HRESULT EmitAndCopyBlock(MIXEDPTRS &u, void *pSrc, DWORD dwLen);
    HRESULT EmitString(MIXEDPTRS &u, LPCWSTR pSrc, DWORD dwLen, int *piOffSet);
    HRESULT EmitObject(MIXEDPTRS &u, SHORT propnum, BYTE privnum, void *pHdr, DWORD dwHdrLen, void *pObj, DWORD dwObjLen);

    //---- private data ----
    CWideString _wsThemeFileName;
    int _iGlobalsOffset;
    int _iSysMetricsOffset;
    
    //---- ptrs to packed objs for [globals] section ----
    int _iGlobalsTextObj;       // we always create this obj
    int _iGlobalsDrawObj;       // we always create this obj

    //---- local copy of theme data while being built ----
    BYTE *_pbLocalData;
    int _iLocalLen;
    CSimpleArray<APPCLASSLOCAL> _LocalIndexes;

    //---- used for updating entry hdrs ----
    BYTE *_pbEntryHdrs[MAX_ENTRY_NESTING];          // points to current hdr
    int _iEntryHdrLevel;

    //---- shared memory copy of theme data ----
    CUxThemeFile _LoadingThemeFile;

    //---- theme metrics ----
    LOADTHEMEMETRICS _LoadThemeMetrics;

    //---- Global creation flag
    BOOL _fGlobalTheme;

    //---- Machine page size for VirtualAlloc optimization
    DWORD _dwPageSize;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\parser.h ===
//---------------------------------------------------------------------------
//  Parser.h - parses a "themes.ini" file and builds the ThemeInfo entries
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Scanner.h"
#include "Utils.h"
#include "CFile.h"
#include "SimpStr.h"
//---------------------------------------------------------------------------
//  TMT_XXX ranges:
//      1 - 49   SpecialPropVals (see below)
//      50 - 60  Primitive Properties
//      61 - xx  enum definitions & regular Properties 
//---------------------------------------------------------------------------
enum SpecialPropVals        // strings not needed for these
{
    TMT_THEMEMETRICS = 1,   // THEMEMETRICS struct in shared data
    TMT_DIBDATA,            // bitmap file converted to DIB data 
    TMT_DIBDATA1,           // bitmap file converted to DIB data 
    TMT_DIBDATA2,           // bitmap file converted to DIB data 
    TMT_DIBDATA3,           // bitmap file converted to DIB data 
    TMT_DIBDATA4,           // bitmap file converted to DIB data 
    TMT_DIBDATA5,           // bitmap file converted to DIB data 
    TMT_GLYPHDIBDATA,       // NTL pcode generated from NTL source file
    TMT_NTLDATA,            // NTL pcode generated from NTL source file
    TMT_PARTJUMPTABLE,      // seen if more than 1 part defined for class
    TMT_STATEJUMPTABLE,     // seen if more than 1 state defined for part
    TMT_JUMPTOPARENT,       // seen at end of every section (index=-1 means stop)

    //  THE FOLLOWING THREE PROPERTIES ARE PERSISTED; FOR BACKWARD COMPAT, 
    //  DO NOT UPSET THEIR VALUES!
    TMT_ENUMDEF,            // enum definition (not yet a property)   
    TMT_ENUMVAL,            // enum value definition
    TMT_ENUM,               // enum property

    TMT_DRAWOBJ,            // packed struct (CBorderFill and CImageFile objs)
    TMT_TEXTOBJ,            // packed struct (CTextObj)
    TMT_RGNLIST,            // state jump table to access custom region data entries
    TMT_RGNDATA,            // custom region data for an imagefile/state
    TMT_ENDOFCLASS,         // end of data for a class section
    TMT_STOCKDIBDATA,
    TMT_UNKNOWN, 
};
//---------------------------------------------------------------------------
#define HUE_SUBCNT 5
#define COLOR_SUBCNT 5
//---------------------------------------------------------------------------
#define MAX_PROPERTY_VALUE      1024
//---------------------------------------------------------------------------
#define ENUM_SECTION_NAME   L"enums"
#define TYPE_SECTION_NAME   L"types"

#define INI_MACRO_SYMBOL    L'#'
#define SUBST_TABLE_INCLUDE L"Include"

#define GLOBALS_SECTION_NAME   L"globals"
#define SYSMETRICS_SECTION_NAME   L"SysMetrics"

#define MYAPP_NAME          L"ThemeSel"
#define OUTFILE_NAME        L"tmdefs.h"
#define PREDEFINES_NAME     L"themes.inc"
//---------------------------------------------------------------------------
typedef BYTE PRIMVAL;        // first 10 TMT_XXX defines
//---------------------------------------------------------------------------
class IParserCallBack           // Parser Caller must implement
{
public:
    virtual HRESULT AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
        int iPartNum, int iStateNum, int iIndex, int iLen) = 0;
    virtual HRESULT AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, 
        DWORD dwLen) = 0;
    virtual int GetNextDataIndex() = 0;
};
//---------------------------------------------------------------------------
struct ENUMVAL
{
    CWideString csName;
    int iValue;
    int iSymbolIndex;
};
//---------------------------------------------------------------------------
struct SYMBOL
{
    CWideString csName;
    SHORT sTypeNum;             // the property number of this property
    PRIMVAL ePrimVal;           // all enums = ENUM_PRIMNUM
};
//---------------------------------------------------------------------------
// Stock objects data
//---------------------------------------------------------------------------
struct TMBITMAPHEADER       // Stock bitmap info, can be followed with a BITMAPINFOHEADER struct
{
    DWORD dwSize;           // Size of the structure
    BOOL fFlipped;          // TRUE if the bitmap is flipped (stock or not)
    HBITMAP hBitmap;        // Stock bitmap handle, if NULL then a BITMAPINFOHEADER follows
    DWORD dwColorDepth;     // Bitmap color depth
    BOOL fTrueAlpha;        // TRUE if the bitmap has a non-empty alpha chanel
};
// Pointer to the BITMAPINFOHEADER following the structure
#define BITMAPDATA(p) (reinterpret_cast<BITMAPINFOHEADER*>((BYTE*) p + p->dwSize))
// Size in bytes preceding the BITMAPINFOHEADER data
#define TMBITMAPSIZE (sizeof(TMBITMAPHEADER))
//---------------------------------------------------------------------------
class CThemeParser
{
public:
    CThemeParser(BOOL fGlobalTheme = FALSE);

    HRESULT ParseThemeFile(LPCWSTR pszFileName, LPCWSTR pszColorParam, 
        IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack=NULL, 
        LPARAM lFnParam=NULL, DWORD dwParseFlags=0);

    HRESULT ParseThemeBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName,
        LPCWSTR pszColorParam, HINSTANCE hInstThemeDll, IParserCallBack *pCallBack, 
        THEMEENUMPROC pNameCallBack=NULL, LPARAM lFnParam=NULL, 
        DWORD dwParseFlags=0, LPCWSTR pszDocProperty=NULL, OUT LPWSTR pszResult=NULL,
        DWORD dwMaxResultChars=0);

    HRESULT GetPropertyNum(LPCWSTR pszName, int *piPropNum);

    void CleanupStockBitmaps();

protected:
    //---- helpers ----
    HRESULT SourceError(int iMsgResId, LPCWSTR pszParam1=NULL, LPCWSTR pszParam2=NULL);
    HRESULT ParseDocSection();
    HRESULT ParseClassSection(LPCWSTR pszFirstName);
    HRESULT InitializeSymbols();
    HRESULT AddSymbol(LPCWSTR pszName, SHORT sTypeNum, PRIMVAL ePrimVal);
    HRESULT ParseClassSectionName(LPCWSTR pszFirstName, LPWSTR szAppSym, ULONG cchAppSym);
    HRESULT ValidateEnumSymbol(LPCWSTR pszName, int iSymType, int *pIndex=NULL);
    HRESULT ParseClassLine(int *piSymType=NULL, int *piValue=NULL, LPWSTR pszBuff=NULL, DWORD dwMaxBuffChars=0);
    int GetSymbolIndex(LPCWSTR pszName);
    HRESULT ParseThemeScanner(IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack, 
        LPARAM lFnParam, DWORD dwParseFlags);
    HRESULT ParseColorSchemeSection();
    COLORREF ApplyColorSubstitution(COLORREF crOld);
    HRESULT ParseSizeSection();
    HRESULT ParseFileSection();
    HRESULT ParseSubstSection();
    HRESULT PackageImageData(LPCWSTR szFileNameR, LPCWSTR szFileNameG, LPCWSTR szFileNameB, int iDibPropNum);
    HRESULT LoadResourceProperties();
    void EmptyResourceProperties();
    HRESULT GetResourceProperty(LPCWSTR pszPropName, LPWSTR pszValueBuff,
        int cchMaxValueChars);

    //---- primitive value parsers ----
    HRESULT ParseEnumValue(int iSymType);
    HRESULT ParseStringValue(int iSymType, LPWSTR pszBuff=NULL, DWORD dwMaxBuffChars=0);
    HRESULT ParseIntValue(int iSymType, int *piValue=NULL);
    HRESULT ParseBoolValue(int iSymType, LPCWSTR pszPropertyName);
    HRESULT ParseColorValue(int iSymType, COLORREF *pcrValue=NULL, COLORREF *pcrValue2=NULL);
    HRESULT ParseMarginsValue(int iSymType);
    HRESULT ParseIntListValue(int iSymType);
    HRESULT ParseFileNameValue(int iSymType, LPWSTR pszBuff=NULL, DWORD dwMaxBuffChars=0);
    HRESULT ParseSizeValue(int iSymType);
    HRESULT ParsePositionValue(int iSymType);
    HRESULT ParseRectValue(int iSymType, LPCWSTR pszPropertyName);
    HRESULT ParseFontValue(int iSymType, LPCWSTR pszPropertyName);
    HRESULT AddThemeData(int iTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen);
    HRESULT ParseSizeInfoUnits(int iVal, LPCWSTR pszDefaultUnits, int *piPixels);
    HRESULT GetIntList(int *pInts, LPCWSTR *pParts, int iCount, 
        int iMin, int iMax);
    HRESULT GenerateEmptySection(LPCWSTR pszSectionName, int iPartId, int iStateId);

    //---- private data ----
    CScanner _scan;
    CSimpleFile _outfile;
    int _iEnumCount;
    int _iTypeCount;
    int _iFontNumber;           // for using resource-based strings as font values
    BOOL _fGlobalTheme;
    BOOL _fGlobalsDefined;
    BOOL _fClassSectionDefined;
    BOOL _fDefiningColorScheme;
    BOOL _fUsingResourceProperties;
    UCHAR _uCharSet;

    //---- current section info ----
    int _iPartId;
    int _iStateId;
    WCHAR _szClassName[MAX_PATH];
    WCHAR _szBaseSectionName[MAX_PATH];          // of current section
    WCHAR _szFullSectionName[MAX_PATH];          // of current section

    CSimpleArray<ENUMVAL> _EnumVals;
    CSimpleArray<SYMBOL> _Symbols;
    CSimpleArray<HBITMAP> _StockBitmapCleanupList;
    IParserCallBack *_pCallBackObj;
    THEMEENUMPROC _pNameCallBack;
    LPARAM _lNameParam;
    DWORD _dwParseFlags;
    WCHAR _ColorParam[MAX_PATH+1];
    HINSTANCE _hinstThemeDll;
    LPCWSTR _pszDocProperty;
    LPWSTR _pszResult;      // for querying doc property
    DWORD _dwMaxResultChars;

    //---- color substitution table ----
    int _iColorCount;
    COLORREF _crFromColors[5];
    COLORREF _crToColors[5];
    COLORREF _crBlend;

    //---- hue substitution table ----
    int _iHueCount;
    BYTE _bFromHues[5];
    BYTE _bToHues[5];

    //---- theme metrics table ----
    BOOL _fDefiningMetrics;
    BOOL _fMetricsDefined;

    //---- resource properties ----
    CSimpleArray<CWideString> _PropertyNames;
    CSimpleArray<CWideString> _PropertyValues;
    CSimpleArray<int> _iPropertyIds;

    WCHAR _szResPropValue[2*MAX_PATH];
    int _iResPropId;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\stringtable.h ===
//--------------------------------------------------------------------
//   StringTable.h - shared error strings for theme modules
//--------------------------------------------------------------------
#define IDC_MYICON                      2
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_SMALL                       108
#define IDC_UXTHEME                     109
#define IDS_UXTHEME                     109

#define IDR_MAINFRAME                   128
#define IDB_TOPLEFT                     134
#define IDB_BOTTOMLEFT                  135
#define IDB_TOPRIGHT                    136
#define IDB_BOTTOMRIGHT                 137
#define IDB_LEFT                        138
#define IDB_RIGHT                       139
#define IDB_TOP                         140
#define IDB_BOTTOM                      141
#define IDB_SAMPLE                      151

//---- do NOT renumber these (bad for localization teams) ----

//---- only PARSER Errors are allowed as custom error codes ----

#define PARSER_IDS_TYPE_DEFINED_TWICE          115
#define PARSER_IDS_MISSING_SECTION_LBRACKET    122
#define PARSER_IDS_NOT_ENUM_VALNAME            123
#define PARSER_IDS_EXPECTED_TRUE_OR_FALSE      124
#define PARSER_IDS_CS_MUST_BE_BEFORE_GLOBLS    125
#define PARSER_IDS_CS_MUST_BE_BEFORE_CLASSES   126

#define PARSER_IDS_UNKNOWN_SECTION_NAME        129
#define PARSER_IDS_EXPECTED_DOUBLE_COLON       130
#define PARSER_IDS_MISSING_SECT_HDR_NAME       131
#define PARSER_IDS_ENUM_NOT_DEFINED            132
#define PARSER_IDS_MISSING_SECT_HDR_PART       133
#define PARSER_IDS_MISSING_SECT_HDR_STATE      134
#define PARSER_IDS_EXPECTED_RPAREN             135
#define PARSER_IDS_EXPECTED_END_OF_SECTION     136
#define PARSER_IDS_ENUM_VALNAME_EXPECTED       137
#define PARSER_IDS_INT_EXPECTED                138
#define PARSER_IDS_BOOL_EXPECTED               139
#define PARSER_IDS_BAD_COLOR_VALUE             140
#define PARSER_IDS_BAD_MARGINS_VALUE           141
#define PARSER_IDS_ILLEGAL_SIZE_VALUE          146
#define PARSER_IDS_ILLEGAL_RECT_VALUE          147
#define PARSER_IDS_UNKNOWN_SIZE_UNITS          148
#define PARSER_IDS_LBRACKET_EXPECTED           149
#define PARSER_IDS_SYS_COLOR_EXPECTED          150
#define PARSER_IDS_RBRACKET_EXPECTED           151
#define PARSER_IDS_END_OF_LINE_EXPECTED        152
#define PARSER_IDS_UNKNOWN_SYS_COLOR           153
#define PARSER_IDS_INVALID_SYSFONT             154
#define PARSER_IDS_EXPECTED_SYSFONT_ID         155
#define PARSER_IDS_UNKNOWN_SYSFONT_ID          156
#define PARSER_IDS_UNKNOWN_FONT_FLAG           157
#define PARSER_IDS_EXPECTED_PROP_NAME          158
#define PARSER_IDS_EXPECTED_EQUALS_SIGN        159
#define PARSER_IDS_UNKNOWN_PROP                160
#define PARSER_IDS_EXTRA_PROP_TEXT             161
#define PARSER_IDS_CS_NAME_EXPECTED            162
#define PARSER_IDS_ILLEGAL_CS_PROPERTY         163
#define PARSER_IDS_GLOBALS_MUST_BE_FIRST       164
#define PARSER_IDS_EXPECTED_DOT_SN             165
#define PARSER_IDS_CHARSETFIRST                166
#define PARSER_IDS_CHARSET_GLOBALS_ONLY        167
#define PARSER_IDS_BADSECT_THEMES_INI          168
#define PARSER_IDS_BADSECT_CLASSDATA           169
#define PARSER_IDS_ILLEGAL_SS_PROPERTY         170
#define PARSER_IDS_SS_NAME_EXPECTED            171
#define PARSER_IDS_NOOPEN_IMAGE                173
#define PARSER_IDS_FS_NAME_EXPECTED            172
#define PARSER_IDS_THEME_TOO_BIG               174
#define PARSER_IDS_METRICS_MUST_COME_BEFORE_CLASSES 176
#define PARSER_IDS_PARTS_NOT_DEFINED           177
#define PARSER_IDS_STATES_NOT_DEFINED          178

#define PARSER_IDS_NOT_ALLOWED_SYSMETRICS      197
#define PARSER_IDS_PARTSTATE_ALREADY_DEFINED   205
#define PARSER_IDS_INTERNAL_TM_ERROR           207
#define PARSER_IDS_UNKNOWN_BITNAME             208
#define PARSER_IDS_VALUE_NAME_EXPECTED         209
#define PARSER_IDS_UNKNOWN_VALUE_NAME          210
#define PARSER_IDS_VALUE_PART_SPECIFIED_TWICE  211
#define PARSER_IDS_NUMBER_EXPECTED             213
#define PARSER_IDS_NUMBER_OUT_OF_RANGE         214
#define PARSER_IDS_UNKNOWN_STATE               215
#define PARSER_IDS_STATE_MUST_BE_DEFINED       222
#define PARSER_IDS_COLOR_EXPECTED              223
#define PARSER_IDS_BAD_RES_PROPERTY            233
#define PARSER_IDS_BAD_SUBST_SYMBOL            234
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\syscolors.h ===
//---------------------------------------------------------------------------
//   syscolors.h
//---------------------------------------------------------------------------
extern WCHAR *pszSysColorNames[];
extern const int iSysColorSize;

#ifdef SYSCOLOR_STRINGS

WCHAR *pszSysColorNames[] = 
{
   L"Scrollbar",        // 0
   L"Background",       // 1
   L"ActiveTitle",      // 2
   L"InactiveTitle",    // 3
   L"Menu",             // 4
   L"Window",           // 5
   L"WindowFrame",      // 6
   L"MenuText",         // 7
   L"WindowText",       // 8
   L"TitleText",        // 9
   L"ActiveBorder",     // 10
   L"InactiveBorder",   // 11
   L"AppWorkspace",     // 12
   L"Hilight",          // 13
   L"HilightText",      // 14
   L"ButtonFace",       // 15
   L"ButtonShadow",     // 16
   L"GrayText",         // 17
   L"ButtonText",       // 18
   L"InactiveTitleText",     // 19
   L"ButtonHilight",         // 20
   L"ButtonDkShadow",        // 21
   L"ButtonLight",           // 22
   L"InfoText",              // 23
   L"InfoWindow",            // 24
   L"ButtonAlternateFace",   // 25
   L"HotTrackingColor",      // 26
   L"GradientActiveTitle",   // 27
   L"GradientInactiveTitle", // 28
   L"MenuHilight",           // 29
   L"MenuBar",               // 30
};

const int iSysColorSize = ARRAYSIZE(pszSysColorNames);
#endif
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\themefile.h ===
//---------------------------------------------------------------------------
//  ThemeFile.h - manages loaded theme files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
class CUxThemeFile      // changed from "CThemeFile" to avoid conflict with
{                       // class of same name in themeui
    //---- methods ----
public:
    CUxThemeFile();
    ~CUxThemeFile();

    HRESULT CreateFile(int iLength, BOOL fReserve = FALSE);
    HRESULT CreateFromSection(HANDLE hSection);
    HRESULT OpenFromHandle(HANDLE handle, DWORD dwDesiredAccess = FILE_MAP_READ, BOOL fCleanupOnFailure = FALSE);
    HRESULT ValidateThemeData(BOOL fFullCheck);
    bool IsReady();
    bool IsGlobal();
    bool HasStockObjects();
    
    HANDLE Handle()
    {
        if (this)
            return _hMemoryMap;

        return NULL;
    }

    void CloseFile();
    void Reset();
    HANDLE Unload();
    BOOL ValidateObj();

    //---- data ----
    char _szHead[8];
    BYTE *_pbThemeData;         // ptr to shared memory block
    HANDLE _hMemoryMap;         // handle to memory mapped file
    char _szTail[4];
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\simpstr.h ===
//---------------------------------------------------------------------------
//   SimpStr.h - defines simple string classes
//---------------------------------------------------------------------------
#ifndef _SIMPSTR_H_
#define _SIMPSTR_H_
//---------------------------------------------------------------------------
class CWideString           // simplified version of CString
{
protected:
    void Init(LPCWSTR pszString = NULL)
    {
        _pWideString = NULL;

        if (pszString)
        {
            int len = lstrlen(pszString) + 1;

            if (len > 0)
            {
                _pWideString = new WCHAR[len];

                if (_pWideString)
                {
                    lstrcpyn(_pWideString, pszString, len);
                }
            }
        }
    }
    
public:
    //--------------------------------------------------------------
    CWideString(LPCWSTR pszString=NULL)
    {
        Init(pszString);
    }

    //--------------------------------------------------------------
    CWideString(CWideString &wsCopy)
    {
        Init(wsCopy._pWideString);
    }

    //--------------------------------------------------------------
    ~CWideString()
    {
        if (_pWideString)
            delete [] _pWideString;
    }

    //--------------------------------------------------------------
    CWideString & operator = (CWideString &wsNew)
    {
        //---- delete our old string ----
        if (_pWideString)
        {
            delete [] _pWideString;
        }

        Init(wsNew._pWideString);

        return *this;
    }

    //--------------------------------------------------------------
    CWideString & operator = (LPCWSTR pNewString)
    {
        //---- delete our old string ----
        if (_pWideString)
        {
            delete [] _pWideString;
        }

        Init(pNewString);

        return *this;
    }
    //--------------------------------------------------------------
    operator LPCWSTR() const
    {
        return _pWideString;
    }

    //--------------------------------------------------------------
    int GetLength()
    {
        int iLen = 0;

        if (_pWideString)
        {
            iLen = lstrlen(_pWideString);
        }
        
        return iLen;
    }
    //--------------------------------------------------------------

protected:
    LPWSTR _pWideString;
};
//---------------------------------------------------------------------------
template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
        //---- always call the dtr ----
#if _MSC_VER >= 1200
		m_aT[nIndex].~T();
#else
        T* MyT;
        MyT = &m_aT[nIndex];
        MyT->~T();
#endif

        if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		}

		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
				m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(m_aT + nIndex) Wrapper(t);
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;  // not found
	}
};
#endif      // _SIMPSTR_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\signing.h ===
//  --------------------------------------------------------------------------
//  Module Name: Signing.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  A class to handle signing on themes.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

#ifndef     _ThemeSignature_
#define     _ThemeSignature_

#include <wincrypt.h>

int GetIndexFromDate(void);
BOOL StrToInt64ExInternalW(LPCWSTR pszString, DWORD dwFlags, LONGLONG *pllRet);


//  --------------------------------------------------------------------------
//  CThemeSignature
//
//  Purpose:    This class knows about signing and verification of themes. It
//              has the public and private keys encapsulated within it. This
//              is information that nobody needs to know. It provides three
//              public functions to do the work.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------

class   CThemeSignature
{
private:
    typedef enum
    {
        KEY_NONE        =   0,
        KEY_PUBLIC,
        KEY_PRIVATE
    } KEY_TYPES;

public:
    CThemeSignature(void);
    CThemeSignature(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize);
    ~CThemeSignature (void);
public:
    HRESULT         Verify (const WCHAR *pszFilename, bool fNoSFCCheck);
    HRESULT         Sign (const WCHAR *pszFilename);
private:
    bool            HasProviderAndHash (void)   const;
    bool            IsProtected (const WCHAR *pszFilename)  const;
    HRESULT         CreateKey (KEY_TYPES keyType);
    HRESULT         CalculateHash (HANDLE hFile, KEY_TYPES keyType);
    HRESULT         SignHash (void);
    HRESULT         ReadSignature (HANDLE hFile, void *pvSignature);
    HRESULT         WriteSignature (const WCHAR *pszFilename, const void *pvSignature, DWORD dwSignatureSize);
    HRESULT         CreateExportKey (DWORD dwBlobType, void*& pvKey, DWORD& dwKeySize);
    void            PrintKey (const void *pvKey, DWORD dwKeySize);
    void            _Init(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize);

private:
    HCRYPTPROV      _hCryptProvider;
    HCRYPTHASH      _hCryptHash;
    HCRYPTKEY       _hCryptKey;
    void*           _pvSignature;
    DWORD           _dwSignatureSize;

    const BYTE *    _pvPrivateKey;              // May be NULL
    DWORD           _cbPrivateKeySize;

    static  const WCHAR     s_szDescription[];
    static  const WCHAR     s_szThemeDirectory[];
    static  const WCHAR*    s_szKnownThemes[];
    static  const BYTE      s_keyPublic2[];

    const BYTE * _GetPublicKey(void);
    HRESULT _CheckLocalKey(void);
};

HRESULT CheckThemeFileSignature(LPCWSTR pszName);

#endif  /*  _ThemeSignature_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\tmreg.h ===
//---------------------------------------------------------------------------
//  TmReg.h - theme manager registry access routines
//---------------------------------------------------------------------------
#pragma once
//  --------------------------------------------------------------------------
//  CCurrentUser
//
//  Purpose:    Manages obtaining HKEY_CURRENT_USER even when impersonation
//              is in effect to ensure that the correct user hive is
//              referenced.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

class   CCurrentUser
{
    private:
                CCurrentUser (void);
    public:
                CCurrentUser (REGSAM samDesired);
                ~CCurrentUser (void);

                operator HKEY (void)    const;
    private:
        HKEY    _hKeyCurrentUser;
};

//---------------------------------------------------------------------------
//  Theme registry keys (exposed ones in uxthemep.h)
//---------------------------------------------------------------------------
//---- key root ----
#define THEMEMGR_REGKEY              L"Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"
#define THEMES_REGKEY                L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes"

//---- theme active/loaded before ----
#define THEMEPROP_THEMEACTIVE        L"ThemeActive"
#define THEMEPROP_LOADEDBEFORE       L"LoadedBefore"

//---- local machine -to- current user propogation keys ----
#define THEMEPROP_LMVERSION          L"LMVersion"
#define THEMEPROP_LMOVERRIDE         L"LMOverRide"

//---- theme identification ----
#define THEMEPROP_DLLNAME            L"DllName"
#define THEMEPROP_COLORNAME          L"ColorName"
#define THEMEPROP_SIZENAME           L"SizeName"
#define THEMEPROP_LANGID             L"LastUserLangID"

//---- theme loading options ----
#define THEMEPROP_COMPOSITING        L"Compositing"
#define THEMEPROP_DISABLECACHING     L"DisableCaching"

//---- obsolete loading options ----
#define THEMEPROP_TARGETAPP          L"TargetApp"
#define THEMEPROP_EXCLUDETARGETAPP   L"ExcludeTarget"
#define THEMEPROP_DISABLEFRAMES      L"DisableFrames"
#define THEMEPROP_DISABLEDIALOGS     L"DisableDialogs"

//---- debug logging ----
#define THEMEPROP_LOGCMD             L"LogCmd"
#define THEMEPROP_BREAKCMD           L"BreakCmd"
#define THEMEPROP_LOGAPPNAME         L"LogAppName"

//---- custom app theming ----
#define THEMEPROP_CUSTOMAPPS         L"Apps"

#ifdef  __TRAP_360180__
#define THEMEPROP_TRAP360180         L"ShrinkTrap"
#endif  __TRAP_360180__


//---- themeui values ----
#define CONTROLPANEL_APPEARANCE_REGKEY  L"Control Panel\\Appearance"

#define REGVALUE_THEMESSETUPVER      L"SetupVersion"
#define THEMEPROP_WHISTLERBUILD      L"WCreatedUser"
#define THEMEPROP_CURRSCHEME         L"Current"                 // This key is stored under CU,"Control Panel\Appearance"
#define THEMEPROP_NEWCURRSCHEME      L"NewCurrent"              // This key is stored under CU,"Control Panel\Appearance" and will be set to the Whistler selected Appearance scheme.

#define SZ_INSTALL_VS                L"/InstallVS:'"
#define SZ_USER_INSTALL              L"/UserInstall"
#define SZ_DEFAULTVS_OFF             L"DefaultVisualStyleOff"
#define SZ_INSTALLVISUALSTYLE        L"InstallVisualStyle"
#define SZ_INSTALLVISUALSTYLECOLOR   L"InstallVisualStyleColor"
#define SZ_INSTALLVISUALSTYLESIZE    L"InstallVisualStyleSize"

//---- policy values ----
#define SZ_POLICY_SETVISUALSTYLE     L"SetVisualStyle"
#define SZ_THEME_POLICY_KEY          L"System"

//---------------------------------------------------------------------------
HRESULT GetCurrentUserThemeInt(LPCWSTR pszValueName, int iDefaultValue, int *piValue);
HRESULT SetCurrentUserThemeInt(LPCWSTR pszValueName, int iValue);

HRESULT GetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD dwMaxBuffChars);
HRESULT SetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszValue);

HRESULT GetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD dwMaxBuffChars);
HRESULT SetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT SetCurrentUserThemeStringExpand(LPCWSTR pszValueName, LPCWSTR pszValue);

HRESULT DeleteCurrentUserThemeValue(LPCWSTR pszKeyName);
BOOL IsRemoteThemeDisabled();
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\sysmetrics.h ===
//---------------------------------------------------------------------------
//   sysmetrics.h
//---------------------------------------------------------------------------
WCHAR *pszSysMetricIntNames[] = 
{
   L"BorderWidth",       
   L"ScrollBarWidth",    
   L"ScrollBarHeight",   
   L"CaptionBarWidth",   
   L"CaptionBarHeight",  
   L"SmCaptionBarWidth", 
   L"SmCaptionBarHeight", 
   L"MenuBarWidth",       
   L"MenuBarHeight",      
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\themeldr.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation 1991-2000
//
// File   : ThemeLdr.h - defines private library routines for loading themes
//                       (used by msgina.dll)
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _THEMELDR_H_                   
#define _THEMELDR_H_                   
//---------------------------------------------------------------------------
#include "uxthemep.h"       // for various DWORD flags (not functions)
//---------------------------------------------------------------------------
// Define API decoration 
#if (! defined(_THEMELDR_))
#define TLAPI          EXTERN_C HRESULT STDAPICALLTYPE
#define TLAPI_(type)   EXTERN_C type STDAPICALLTYPE
#else
#define TLAPI          STDAPI
#define TLAPI_(type)   STDAPI_(type)
#endif
//---------------------------------------------------------------------------
//---- functions used by packthem (from themeldr.lib) ----

BOOL ThemeLibStartUp(BOOL fThreadAttach);
BOOL ThemeLibShutDown(BOOL fThreadDetach);

HRESULT _GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo);

HRESULT _ParseThemeIniFile(LPCWSTR pszFileName,  
    DWORD dwParseFlags, OPTIONAL THEMEENUMPROC pfnCallBack, OPTIONAL LPARAM lparam);

//---------------------------------------------------------------------------
#endif // _THEMELDR_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\tmutils.h ===
//-------------------------------------------------------------------------
//	TmUtils.h - theme manager shared utilities
//-------------------------------------------------------------------------
#ifndef _TMUTILS_H_
#define _TMUTILS_H_
//-------------------------------------------------------------------------
#include "themefile.h"
//-------------------------------------------------------------------------
#define DIBDATA(infohdr) (((BYTE *)(infohdr)) + infohdr->biSize + \
	infohdr->biClrUsed*sizeof(RGBQUAD))

#define THEME_OFFSET(x)         int(x - _LoadingThemeFile._pbThemeData)
#define THEMEFILE_OFFSET(x)     int(x - pThemeFile->_pbThemeData)
//------------------------------------------------------------------------------------
class CMemoryDC
{
public:
    CMemoryDC();
    ~CMemoryDC();
    HRESULT OpenDC(HDC hdcSource, int iWidth, int iHeight);
    void CloseDC();
    operator HDC() {return _hdc;}

    HBITMAP _hBitmap;

protected:
    //---- private data ----
    HDC _hdc;
    HBITMAP _hOldBitmap;
};
//------------------------------------------------------------------------------------
class CBitmapPixels
{
public:
    CBitmapPixels();
    ~CBitmapPixels();

    //---- "OpenBitmap()" returns a ptr to pixel values in bitmap. ----
    //---- Rows go from bottom to top; Colums go from left to right. ----
    //---- IMPORTANT: pixel DWORDS have RGB bytes reversed from COLORREF ----
    HRESULT OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32, 
        DWORD OUT **pPixels, OPTIONAL OUT int *piWidth=NULL, OPTIONAL OUT int *piHeight=NULL, 
        OPTIONAL OUT int *piBytesPerPixel=NULL, OPTIONAL OUT int *piBytesPerRow=NULL, 
        OPTIONAL OUT int *piPreviousBytesPerPixel = NULL, OPTIONAL UINT cbBytesBefore = 0);

    void CloseBitmap(HDC hdc, HBITMAP hBitmap);

    //---- Pointer to the total buffer (including cbBytesBefore)
    BYTE *Buffer();

    //---- public data ----
    BITMAPINFOHEADER *_hdrBitmap;

protected:
    //---- private data ----
    int _iWidth;
    int _iHeight;
    BYTE* _buffer;
};
//------------------------------------------------------------------------------------
HRESULT LoadThemeLibrary(LPCWSTR pszThemeName, HINSTANCE *phInst);

LPCWSTR ThemeString(CUxThemeFile *pThemeFile, int iOffset);

HRESULT GetThemeNameId(CUxThemeFile *pThemeFile, LPWSTR pszFileNameBuff, UINT cchFileNameBuff,
    LPWSTR pszColorParam, UINT cchColorParam, LPWSTR pszSizeParam, UINT cchSizeParam, int *piSysMetricsIndex, LANGID *pwLangID);
BOOL ThemeMatch (CUxThemeFile *pThemeFile, LPCWSTR pszThemeName, LPCWSTR pszColorName, LPCWSTR pszSizeName, LANGID wLangID);

HRESULT _EnumThemeSizes(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth);
HRESULT _EnumThemeColors(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth);

HRESULT GetSizeIndex(HINSTANCE hInst, LPCWSTR pszSize, int *piIndex);
HRESULT GetColorSchemeIndex(HINSTANCE hInst, LPCWSTR pszSize, int *piIndex);
HRESULT FindComboData(HINSTANCE hDll, COLORSIZECOMBOS **ppCombos);
HRESULT GetThemeSizeId(int iSysSizeId, int *piThemeSizeId);
int GetLoadIdFromTheme(CUxThemeFile *pThemeFile);
//---------------------------------------------------------------------------
#endif  //  _TMUTILS_H_
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\packthem\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PackThem.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\packthem\localsign.cpp ===
/*****************************************************************************\
    FILE: localsign.cpp

    DESCRIPTION:
        This code will sign and verify the signature of a Visual Style file.

    BryanSt 8/1/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"
#include <signing.h>
#include <stdio.h>
#include <windows.h>
#include "signing.h"
#include "localsign.h"
#include <shlwapip.h>




const BYTE * _GetPrivateKey(void)
{
    const BYTE * pKeyToReturn = NULL;

    pKeyToReturn = s_keyPrivate1;

    return pKeyToReturn;
}


/*****************************************************************************\
    Public Fuctions
\*****************************************************************************/
HRESULT SignTheme(IN LPCWSTR pszFileName, int nWeek)
{
    DWORD               dwErrorCode;
    const BYTE * pPrivateKey = _GetPrivateKey();

    CThemeSignature     themeSignature(s_keyPrivate1, SIZE_PRIVATE_KEY);

    dwErrorCode = themeSignature.Sign(pszFileName);
    return(HRESULT_FROM_WIN32(dwErrorCode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\inc\utils.h ===
//---------------------------------------------------------------------------
//    utils.h - theme code utilities
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include <uxthemep.h>
#include <commctrl.h>

#include <math.h>
//---------------------------------------------------------------------------
#define THEMEDLL_EXT        L".msstyles"
#define DEFAULT_THEME       L".\\luna\\luna.msstyles"

#define CONTAINER_NAME      L"themes.ini"
#define CONTAINER_RESNAME   L"themes_ini"

#define USUAL_CLASSDATA_NAME   L"default.ini"

//---------------------------------------------------------------------------
#define RESOURCE         // marks vars as being needed to be freed at block exit
//---------------------------------------------------------------------------
#ifdef DEBUG
#define _DEBUG
inline int _DebugExceptionFilter( LONG ecode, EXCEPTION_POINTERS* pep, LPSTR pszMsg, LONG lExceptionRet )
{
    CHAR szBuf[512];
#ifdef _STRSAFE_H_INCLUDED_         
    StringCchPrintfA(szBuf, sizeof(szBuf)/sizeof(*szBuf), 
#else _STRSAFE_H_INCLUDED_         
    wsprintfA(szBuf,  
#endif _STRSAFE_H_INCLUDED_         
    "\n%s\nEXCEPTION INFO: code: %08lx, record (.exr): %08lx, context (.cxr): %08lx\n\n", 
     pszMsg, ecode, pep->ExceptionRecord, pep->ContextRecord); 
     OutputDebugStringA(szBuf);         
    return lExceptionRet;
}
#define DEBUG_TRY()                               __try {
#define DEBUG_EXCEPT(pszAssertMsg)                } __except(_DebugExceptionFilter(_exception_code(), (EXCEPTION_POINTERS*)_exception_info(), \
                                                                                   pszAssertMsg, EXCEPTION_EXECUTE_HANDLER)) {\
                                                    DebugBreak();}

#else  // DEBUG
#define DEBUG_TRY()                     
#define DEBUG_EXCEPT(pszAssertMsg)      
#endif // DEBUG
//---------------------------------------------------------------------------
#define COMBOENTRY(combo, color, size) \
    (combo->sFileNums[size*combo->cColorSchemes + color])
//---------------------------------------------------------------------------
#define SAFE_ATOM_DELETE(x) if (1) {GlobalDeleteAtom(x); x = 0;} else
#define SAFE_DELETE_GDIOBJ(hgdiobj) if((hgdiobj)) {DeleteObject(hgdiobj); (hgdiobj)=NULL;}
//---------------------------------------------------------------------------
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif  ARRAYSIZE

#define WIDTH(r) ((r).right - (r).left)
#define HEIGHT(r) ((r).bottom - (r).top)

#ifndef RECTWIDTH
#define RECTWIDTH(prc)  ((prc)->right - (prc)->left)
#endif  RECTWIDTH

#ifndef RECTHEIGHT
#define RECTHEIGHT(prc)  ((prc)->bottom - (prc)->top)
#endif  RECTHEIGHT

#ifndef BOOLIFY
#define BOOLIFY(val)     ((val) ? TRUE : FALSE)
#endif  BOOLIFY

#ifndef TESTFLAG
#define TESTFLAG(field,bits)  (((field)&(bits)) ? TRUE : FALSE)
#endif  TESTFLAG

//---------------------------------------------------------------------------
#ifdef __cplusplus
#define SAFE_DELETE(p)          { delete (p); (p)=NULL; }
#define SAFE_DELETE_ARRAY(prg)  { delete [] (prg); (prg)=NULL; }
#endif //__cplusplus
//---------------------------------------------------------------------------
#define VALID_CRITICALSECTION(pcs)       ((pcs)!=NULL && (pcs)->DebugInfo != NULL)
#define SAFE_ENTERCRITICALSECTION(pcs)   {if(VALID_CRITICALSECTION(pcs)) {EnterCriticalSection(pcs);}}
#define SAFE_LEAVECRITICALSECTION(pcs)   {if(VALID_CRITICALSECTION(pcs)) {LeaveCriticalSection(pcs);}}
#define SAFE_DELETECRITICALSECTION(pcs)  {if(VALID_CRITICALSECTION(pcs)) {\
                                            DeleteCriticalSection(pcs); ZeroMemory(pcs, sizeof(*(pcs)));}}

BOOL TokenHasPrivilege( IN OPTIONAL HANDLE hToken, DWORD dwPrivilege );
//---------------------------------------------------------------------------
#define RED(c)      GetRValue(c)
#define GREEN(c)    GetGValue(c)
#define BLUE(c)     GetBValue(c)
#define ALPHACHANNEL(c) BYTE((c) >> 24)
//---------------------------------------------------------------------------
#define REVERSE3(c) ((RED(c) << 16) | (GREEN(c) << 8) | BLUE(c))
//---------------------------------------------------------------------------
#define LAST_SYSCOLOR   (COLOR_MENUBAR)     // last color defined in winuser.h

#define TM_COLORCOUNT   (LAST_SYSCOLOR+1)   // # of colors we care about
//---------------------------------------------------------------------------
#define ULONGAT(p) (*((LONG *)(p)))
//---------------------------------------------------------------------------
#define THEME_DPI    96

#define DPISCALE(val, DcDpi)  MulDiv(val, DcDpi, THEME_DPI)

#define ROUND(flNum) (int(floor((flNum)+.5)))
//---------------------------------------------------------------------------
inline BOOL DpiDiff(HDC hdc, OUT int *piDcDpiH, OUT int *piDcDpiV = NULL)
{
    BOOL fDiff = FALSE;
    BOOL fGotDc = (hdc != NULL);

    if (! fGotDc)
        hdc = GetWindowDC(NULL);

    if (hdc)
    {
        *piDcDpiH = GetDeviceCaps(hdc, LOGPIXELSX);

        if (piDcDpiV)
        {
            *piDcDpiV = GetDeviceCaps(hdc, LOGPIXELSY);
        }

        if (! fGotDc)
            ReleaseDC(NULL, hdc);

        fDiff = (*piDcDpiH != THEME_DPI);
    }

    return fDiff;
}
//---------------------------------------------------------------------------
typedef BOOL (WINAPI *IMAGE_DRAWPROC) (IMAGELISTDRAWPARAMS* pimldp);
typedef int  (WINAPI *PFNDRAWSHADOWTEXT)(HDC hdc, LPCTSTR pszText, UINT cch, RECT* prc, 
    DWORD dwFlags, COLORREF crText, COLORREF crShadow, int ixOffset, int iyOffset);
//---------------------------------------------------------------------------
#if 1       // testing DrawThemeIcon()
typedef HIMAGELIST (WINAPI *IMAGE_LOADPROC) (HINSTANCE hi, LPCTSTR lpbmp,
   int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

typedef BOOL (WINAPI *IMAGE_DESTROYPROC) (HIMAGELIST himl);

#endif
//---------------------------------------------------------------------------
struct COLORSIZECOMBOS         // binary resource in package
{
    WORD cColorSchemes;     // number of color schemes defined
    WORD cSizes;            // number of sizes defined
    SHORT sFileNums[1];     // 2 dim array (colors x sizes)
};
//---------------------------------------------------------------------------
union MIXEDPTRS
{
    BYTE *pb;
    char *pc;
    WORD *pw;
    SHORT *ps;
    WCHAR *px;
    int *pi;
    DWORD *pdw;
    POINT *ppt;
    SIZE *psz;
    RECT *prc;
};
//---------------------------------------------------------------------------
enum GRIDNUM
{
    GN_LEFTTOP = 0,
    GN_MIDDLETOP = 1,
    GN_RIGHTTOP = 2,
    GN_LEFTMIDDLE = 3,
    GN_MIDDLEMIDDLE = 4,
    GN_RIGHTMIDDLE = 5,
    GN_LEFTBOTTOM = 6,
    GN_MIDDLEBOTTOM = 7,
    GN_RIGHTBOTTOM = 8
};
//---------------------------------------------------------------------------
extern IMAGE_DRAWPROC ImageList_DrawProc;
extern HINSTANCE g_hInst;
extern PFNDRAWSHADOWTEXT CCDrawShadowText;

extern int g_iScreenDpi;
//---------------------------------------------------------------------------
inline bool IsSpace(WCHAR wch)
{
    WORD w = 0;
    GetStringTypeW(CT_CTYPE1, &wch, 1, &w);
    return (w & C1_SPACE) ? true : false;
}
//---------------------------------------------------------------------------
inline bool IsHexDigit(WCHAR wch)
{
    WORD w = 0;
    GetStringTypeW(CT_CTYPE1, &wch, 1, &w);
    return (w & C1_XDIGIT) ? true : false;
}
//---------------------------------------------------------------------------
inline bool IsDigit(WCHAR wch)
{
    WORD w = 0;
    GetStringTypeW(CT_CTYPE1, &wch, 1, &w);
    return (w & C1_DIGIT) ? true : false;
}

// A string compare that explicitely only works on english characters
int AsciiStrCmpI(const WCHAR *dst, const WCHAR *src);

//---------------------------------------------------------------------------
HRESULT SafeStringCchCopyW( LPWSTR pszDest, ULONG cchDest, LPCWSTR pszSrc );
HRESULT SafeStringCmpIW( LPCWSTR psz1, LPCWSTR psz2, UINT cchMax, OUT int* piCompare );
void ApplyStringProp(HWND hwnd, LPCWSTR psz, ATOM atom);
//---------------------------------------------------------------------------
BOOL UtilsStartUp();
BOOL UtilsShutDown();

BOOL IsUnicode(LPCSTR pszBuff, int *piUnicodeStartOffset);
BOOL FileExists(LPCTSTR pszFullNameAndPath);
BOOL lstrtoken(LPWSTR psz, WCHAR wch);
//---------------------------------------------------------------------------
HANDLE CmdLineRun(LPCTSTR pszExeName, LPCTSTR pszCmdLine=NULL, BOOL fHide=TRUE);
//---------------------------------------------------------------------------
HRESULT SyncCmdLineRun(LPCTSTR pszExeName, LPCTSTR pszParams=NULL);
HRESULT TextToFile(LPCWSTR szFileName, LPCWSTR szText);

HRESULT GetPtrToResource(HINSTANCE hInst, LPCWSTR pszResType, LPCWSTR pszResName,
    OUT void **ppBytes, OPTIONAL OUT DWORD *pdwBytes=NULL);

HRESULT GetResString(HINSTANCE hInst, LPCWSTR pszResType, int id, LPWSTR pszBuff,
    DWORD dwMaxBuffChars);

HRESULT AllocateTextResource(HINSTANCE hInst, LPCWSTR pszResName, LPWSTR *ppszText);

//---- uses LocalAlloc() to put text file into a string; use LocalFree() to release ----

HRESULT AllocateTextFile(LPCWSTR szFileName, OUT LPWSTR *ppszFileText,
    OUT OPTIONAL BOOL *pfWasAnsi);

HRESULT AddPathIfNeeded(LPCWSTR pszFileName, LPCWSTR pszPath, OUT LPWSTR pszFullName, ULONG cchFullName);
HRESULT AnsiToUnicode(LPSTR pszSource, LPWSTR pszDest, DWORD dwMaxDestChars);
BOOL UnExpandEnvironmentString(LPCWSTR pszPath, LPCWSTR pszEnvVar, LPWSTR pszResult, UINT cbResult);

HRESULT EnsureUxCtrlLoaded();
HRESULT RegistryIntWrite(HKEY hKey, LPCWSTR pszValueName, int iValue);
HRESULT RegistryStrWrite(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT RegistryStrWriteExpand(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT RegistryIntRead(HKEY hKey, LPCWSTR pszValueName, int *piValue);
HRESULT RegistryStrRead(HKEY hKey, LPCWSTR pszValueName, LPWSTR pszBuff, DWORD dwMaxChars);
BOOL PreMultiplyAlpha(DWORD *pPixelBuff, UINT iWidth, UINT iHeight);
BOOL IsBiDiLocalizedSystem(void);
DWORD MinimumDisplayColorDepth (void);
bool CheckMinColorDepth(HINSTANCE hInst, DWORD dwCurMinDepth, int iIndex = -1);

void SafeSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
//---------------------------------------------------------------------------
BOOL    AsciiScanStringList( LPCWSTR pwszString, LPCWSTR* rgpwszList, int cStrings,
                        BOOL fIgnoreCase );
HICON  _GetWindowIcon(HWND hwnd, BOOL fPerferLargeIcon);

BOOL GetWindowDesktopName(HWND hwnd, LPWSTR pszName, DWORD dwMaxChars);

int FontPointSize(int iFontHeight);
//---------------------------------------------------------------------------
inline BOOL IsWindowProcess( HWND hwnd, DWORD dwProcessId )
{
    DWORD dwPid = 0;
    GetWindowThreadProcessId(hwnd, &dwPid);
    return dwProcessId == dwPid;
}
//---------------------------------------------------------------------------
void RGBtoHLS(COLORREF crColor, WORD *pfHue, WORD *pfSat, WORD *pfLum);
COLORREF HLStoRGB(WORD bHue, WORD bLum, WORD bSat);
int string2number(LPCWSTR psz);
//---------------------------------------------------------------------------
inline void MIRROR_POINT( IN const RECT& rcWindow, IN OUT POINT& pt )
{
    pt.x = rcWindow.right + rcWindow.left - pt.x;
}

//-------------------------------------------------------------------------//
inline void MIRROR_RECT( IN const RECT& rcWindow, IN OUT RECT& rc )
{
    DWORD dwWidth = RECTWIDTH(&rc);
    rc.right = rcWindow.right + rcWindow.left - rc.left;
    rc.left  = rc.right - dwWidth;
}
//-------------------------------------------------------------------------//
inline BOOL IsMirrored(HDC hdc)
{
    BOOL fMirrored = FALSE;

    DWORD dwVal = GetLayout(hdc);
    if ((dwVal != GDI_ERROR) && (dwVal & LAYOUT_RTL))
        fMirrored = TRUE;

    return fMirrored;
}
//-------------------------------------------------------------------------//
inline BOOL IsFlippingBitmaps(HDC hdc)
{
    BOOL fFlipping = FALSE;

    DWORD dwVal = GetLayout(hdc);
    if ((dwVal != GDI_ERROR) && (dwVal & LAYOUT_RTL))
    {
        if (! (dwVal & LAYOUT_BITMAPORIENTATIONPRESERVED))
            fFlipping = TRUE;
    }

    return fFlipping;
}
//---------------------------------------------------------------------------
inline void ScaleFontForScreenDpi(LOGFONT *plf)
{
    //---- scale from 96 dpi to current logical screen dpi ----
    if (plf->lfHeight < 0)          // specified in points
    {
        plf->lfHeight = MulDiv(plf->lfHeight, g_iScreenDpi, THEME_DPI);
    }
}
//---------------------------------------------------------------------------
inline int ScaleSizeForScreenDpi(int iValue)
{
    //---- scale from 96 dpi to current logical screen dpi ----
    return MulDiv(iValue, g_iScreenDpi, THEME_DPI);
}
//---------------------------------------------------------------------------
void ScaleFontForHdcDpi(HDC hdc, LOGFONT *plf);
int ScaleSizeForHdcDpi(HDC hdc, int iValue);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\packthem\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set 
//---------------------------------------------------------------------------
#ifndef _STDAFX_H_
#define _STDAFX_H_
//---------------------------------------------------------------------------
#define _iswupper(_c)    ( iswctype(_c,_UPPER) )
#define _iswlower(_c)    ( iswctype(_c,_LOWER) )
#define _iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define _iswxdigit(_c)   ( iswctype(_c,_HEX) )
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define STRICT
#define _ATL_NO_ATTRIBUTES
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "errors.h"
#include "utils.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 

#define STRSAFE_LIB
#include <strsafe.h>
//---------------------------------------------------------------------------
#endif //_STDAFX_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\packthem\packthem.cpp ===
//---------------------------------------------------------------------------
//  PackThem.cpp - packs up theme files into a theme DLL 
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <uxthemep.h>
#include <utils.h>
#include "SimpStr.h"
#include "Scanner.h"
#include "shlwapip.h"
#include "parser.h"
#include "TmSchema.h"
#include "signing.h"
#include "localsign.h"
#include "ThemeLdr.h"
#include "TmUtils.h"
#include "StringTable.h"

HRESULT ParseTheme(LPCWSTR pszThemeName);

//---------------------------------------------------------------------------
struct FILEINFO
{
    CWideString wsName;
    BOOL fIniFile;
};
//---------------------------------------------------------------------------
#define MAX_COLORS   50
#define MAX_SIZES    20
#define TEMP_FILENAME_BASE    L"$temp$"
#define kRESFILECHAR L'$'
//---------------------------------------------------------------------------
enum PACKFILETYPE
{
    PACK_INIFILE,
    PACK_IMAGEFILE,
    PACK_NTLFILE,
    PACK_OTHER
};
//---------------------------------------------------------------------------
CSimpleArray<FILEINFO> FileInfo;

CSimpleArray<CWideString> ColorSchemes;
CSimpleArray<CWideString> ColorDisplays;
CSimpleArray<CWideString> ColorToolTips;

CSimpleArray<int> MinDepths;

CSimpleArray<CWideString> SizeNames;
CSimpleArray<CWideString> SizeDisplays;
CSimpleArray<CWideString> SizeToolTips;

typedef struct
{
    CWideString sName;
    int iFirstIndex;
    UINT cItems;
} sSubstTable;
CSimpleArray<sSubstTable> SubstNames;
CSimpleArray<CWideString> SubstIds;
CSimpleArray<CWideString> SubstValues;

CSimpleArray<CWideString> BaseResFileNames;
CSimpleArray<CWideString> ResFileNames;
CSimpleArray<CWideString> OrigFileNames;

CSimpleArray<CWideString> PropValuePairs;
//---------------------------------------------------------------------------
SHORT Combos[MAX_SIZES][MAX_COLORS];

int g_iMaxColor;
int g_iMaxSize;
int g_LineCount = 0;
int iTempBitmapNum = 1;

BOOL g_fQuietRun = FALSE;             // don't show needless output
BOOL g_fKeepTempFiles = FALSE;
FILE *ConsoleFile = NULL;

WCHAR g_szInputDir[_MAX_PATH+1];
WCHAR g_szTempPath[_MAX_PATH+1];
WCHAR g_szBaseIniName[_MAX_PATH+1];
WCHAR g_szCurrentClass[_MAX_PATH+1];

//---------------------------------------------------------------------------
#define DOCPROPCNT (1+TMT_LAST_RCSTRING_NAME - TMT_FIRST_RCSTRING_NAME)

CWideString DocProperties[DOCPROPCNT];
//---------------------------------------------------------------------------
HRESULT ReportError(HRESULT hr, LPWSTR pszDefaultMsg) 
{
    WCHAR szErrorMsg[2*_MAX_PATH+1];
    PARSE_ERROR_INFO Info = {sizeof(Info)};
    
    BOOL fGotMsg = FALSE;

    if (THEME_PARSING_ERROR(hr))
    {
        if (SUCCEEDED(_GetThemeParseErrorInfo(&Info)))
        {
            StringCchCopyW(szErrorMsg, ARRAYSIZE(szErrorMsg), Info.szMsg);
            fGotMsg = TRUE;
        }
    }

    if (! fGotMsg)
    {
        StringCchCopyW(szErrorMsg, ARRAYSIZE(szErrorMsg), pszDefaultMsg);
    }

    if (*Info.szFileName)        // input file error
    {
        fwprintf(ConsoleFile, L"%s(%d): error - %s\n", 
            Info.szFileName, Info.iLineNum, szErrorMsg);
        fwprintf(ConsoleFile, L"%s\n", Info.szSourceLine);
    }
    else                    // general error 
    {
        fwprintf(ConsoleFile, L"%s(): error - %s\n", 
            g_szInputDir, szErrorMsg);
    }

    SET_LAST_ERROR(hr);
    return hr;
}
//---------------------------------------------------------------------------
void MakeResName(LPCWSTR pszName, LPWSTR pszResName, ULONG cchResName, bool bUseClassName = false)
{
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];
    LPWSTR pszBaseName = szBaseName;

    *szDrive = *szDir = *pszBaseName = *szExt = 0;

    //---- isolate base name (no path) ----
    _wsplitpath(pszName, szDrive, szDir, szBaseName, szExt);

    if (*pszBaseName == kRESFILECHAR) // Don't put $ in resource names
    {
        pszBaseName++;
    }

    //---- replace the "." with a '_' ----
    //---- if a file section name without .ini, append _INI so that the extracted files has .ini extension
    if (*szExt)
    {
        StringCchPrintfW(pszResName, cchResName, L"%s%s_%s", bUseClassName ? g_szCurrentClass : L"", pszBaseName, szExt+1);
    } else
    {
        StringCchPrintfW(pszResName, cchResName, L"%s%s_INI", bUseClassName ? g_szCurrentClass : L"", pszBaseName);
    }

    //---- all uppercase ----
    CharUpperBuff(pszResName, lstrlen(pszResName));

    //---- replace any spaces with underscores ----
    WCHAR *q = pszResName;       
    while (*q)
    {
        if (*q == ' ')
            *q = '_';
        q++;
    }
}
//---------------------------------------------------------------------------
HRESULT BuildThemeDll(LPCWSTR pszRcName, LPCWSTR pszResName, LPCWSTR pszDllName)
{
    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"compiling resources\n");

    HRESULT hr = SyncCmdLineRun(L"rc.exe", pszRcName);
    if (FAILED(hr))
        return ReportError(hr, L"Error during resource compiliation");

    //---- run LINK to create the DLL ----
    WCHAR szParams[2*_MAX_PATH+1];

    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"linking theme dll\n");

    StringCchPrintfW(szParams, ARRAYSIZE(szParams), L"/out:%s /machine:ix86 /dll /noentry %s", pszDllName, pszResName);
    hr = SyncCmdLineRun(L"link.exe", szParams);
    if (FAILED(hr))
        return ReportError(hr, L"Error during DLL linking");

    return S_OK;
}
//---------------------------------------------------------------------------
void OutputDashLine(FILE *outfile)
{
    fwprintf(outfile, L"//----------------------------------------------------------------------\n");
}
//---------------------------------------------------------------------------
inline void ValueLine(FILE *outfile, LPCWSTR pszName, LPCWSTR pszValue)
{
    fwprintf(outfile, L"            VALUE \"%s\", \"%s\\0\"\n", pszName, pszValue);
}
//---------------------------------------------------------------------------
HRESULT OutputVersionInfo(FILE *outfile, LPCWSTR pszFileName, LPCWSTR pszBaseName)
{
    fwprintf(outfile, L"1 PACKTHEM_VERSION\n");
    fwprintf(outfile, L"BEGIN\n");
    fwprintf(outfile, L"    %d\n", PACKTHEM_VERSION);
    fwprintf(outfile, L"END\n");
    OutputDashLine(outfile);

    WCHAR *Company = L"Microsoft";
    WCHAR *Copyright = L"Copyright  2000";
    WCHAR szDescription[2*_MAX_PATH+1];
    
    StringCchPrintfW(szDescription, ARRAYSIZE(szDescription), L"%s Theme for Windows", pszBaseName);

    fwprintf(outfile, L"1 VERSIONINFO\n");
    fwprintf(outfile, L"    FILEVERSION 1,0,0,1\n");
    fwprintf(outfile, L"    PRODUCTVERSION 1,0,0,1\n");
    fwprintf(outfile, L"    FILEFLAGSMASK 0x3fL\n");
    fwprintf(outfile, L"    FILEFLAGS 0x0L\n");
    fwprintf(outfile, L"    FILEOS 0x40004L\n");
    fwprintf(outfile, L"    FILETYPE 0x1L\n");
    fwprintf(outfile, L"    FILESUBTYPE 0x0L\n");

    fwprintf(outfile, L"BEGIN\n");
    fwprintf(outfile, L"    BLOCK \"StringFileInfo\"\n");
    fwprintf(outfile, L"    BEGIN\n");
    fwprintf(outfile, L"        BLOCK \"040904b0\"\n");

    fwprintf(outfile, L"        BEGIN\n");
    
    ValueLine(outfile, L"Comments", L"");
    ValueLine(outfile, L"CompanyName", Company);
    ValueLine(outfile, L"FileDescription", szDescription);
    ValueLine(outfile, L"FileVersion", L"1, 0, 0, 1");
    ValueLine(outfile, L"InternalName", pszFileName);
    ValueLine(outfile, L"LegalCopyright", Copyright);
    ValueLine(outfile, L"LegalTrademarks", L"");
    ValueLine(outfile, L"OriginalFilename", pszFileName);
    ValueLine(outfile, L"PrivateBuild", L"");
    ValueLine(outfile, L"ProductName", szDescription);
    ValueLine(outfile, L"ProductVersion", L"1, 0, 0, 1");
    ValueLine(outfile, L"SpecialBuild", L"");

    fwprintf(outfile, L"        END\n");
    fwprintf(outfile, L"    END\n");
    fwprintf(outfile, L"    BLOCK \"VarFileInfo\"\n");
    fwprintf(outfile, L"    BEGIN\n");
    fwprintf(outfile, L"        VALUE \"Translation\", 0x409, 1200\n");
    fwprintf(outfile, L"    END\n");
    fwprintf(outfile, L"END\n");

    OutputDashLine(outfile);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT RemoveTempFiles(LPCWSTR szRcName, LPCWSTR szResName)
{
    DeleteFile(szRcName);
    DeleteFile(szResName);

    //---- find & delete all temp files in temp directory ----
    HANDLE hFile = NULL;
    BOOL   bFile = TRUE;
    WIN32_FIND_DATA wfd;
    WCHAR szPattern[_MAX_PATH+1];
    WCHAR szTempName[_MAX_PATH+1];

    StringCchPrintfW(szPattern, ARRAYSIZE(szPattern), L"%s\\%s*.*", g_szTempPath, TEMP_FILENAME_BASE); 

    for( hFile = FindFirstFile( szPattern, &wfd ); hFile != INVALID_HANDLE_VALUE && bFile;
         bFile = FindNextFile( hFile, &wfd ) )
    {
        StringCchPrintfW(szTempName, ARRAYSIZE(szTempName), L"%s\\%s", g_szTempPath, wfd.cFileName);
    
        DeleteFile(szTempName);
    }

    if (hFile)      
    {
        FindClose( hFile );
    }

    // Remove files generated by the substitution tables
    for (int i = 0; i < SubstNames.GetSize(); i++)
    {
        StringCchPrintfW(szTempName, ARRAYSIZE(szTempName), L"%s\\$%s.ini", g_szTempPath, SubstNames[i].sName);
        DeleteFile(szTempName);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
int GetSubstTableIndex(LPCWSTR pszTableName)
{
    // Search for an existing subst table
    for (int i = 0; i < SubstNames.GetSize(); i++)
    {
        if (0 == AsciiStrCmpI(SubstNames[i].sName, pszTableName))
            return i;
    }
    return -1;
}
//---------------------------------------------------------------------------
HRESULT GetSubstValue(LPCWSTR pszIniFileName, LPCWSTR pszName, LPWSTR pszResult, ULONG cchResult)
{
    UINT cTablesCount = SubstNames.GetSize();

    if (pszIniFileName && pszIniFileName[0] == kRESFILECHAR)
    {
        pszIniFileName++;
    }

    for (UINT i = 0; i < cTablesCount; i++)      
    {
        if (0 == AsciiStrCmpI(SubstNames[i].sName, pszIniFileName))
        {
            for (UINT j = SubstNames[i].iFirstIndex; j < SubstNames[i].iFirstIndex + SubstNames[i].cItems; j++) 
            {
                if (0 == AsciiStrCmpI(SubstIds[j], pszName))
                {
                    StringCchCopyW(pszResult, cchResult, SubstValues[j]);
                    return S_OK;
                }
            }
        }
    }

    return MakeError32(E_FAIL);      // unknown sizename
}
//---------------------------------------------------------------------------
LPWSTR FindSymbolToken(LPWSTR pSrc, int nLen)
{
    LPWSTR p = wcschr(pSrc, INI_MACRO_SYMBOL);

    // Skip single #s
    while (p != NULL && (p - pSrc < nLen - 1) && *(p + 1) != INI_MACRO_SYMBOL)
    {
        p = wcschr(p + 1, INI_MACRO_SYMBOL);
    }
    return p;
}

LPWSTR ReallocTextBuffer(LPWSTR pSrc, UINT *pnLen)
{
    *pnLen *= 2; // Double the size each time

    LPWSTR pszNew = (LPWSTR) LocalReAlloc(pSrc, *pnLen * sizeof(WCHAR), 0);
    if (!pszNew)
    {
        LocalFree(pSrc);
        return NULL;
    }
    return pszNew;
}

LPWSTR SubstituteSymbols(LPWSTR szTableName, LPWSTR pszText)
{
    UINT   iSymbol;
    WCHAR  szSymbol[MAX_INPUT_LINE+1];

    UINT   cchText = wcslen(pszText);
    UINT   cchTextNew = cchText * 2; // Reserve some additional space
    UINT   nBlockSize;

    LPWSTR pszNew = (LPWSTR) LocalAlloc(0, cchTextNew * sizeof(WCHAR));
    LPWSTR pszDest = pszNew;

    LPWSTR pszSrc = FindSymbolToken(pszText, cchText);
    LPWSTR pszOldSrc = pszText;

    HRESULT hr;

    if (!pszNew)
        return NULL;

    while (pszSrc != NULL)
    {
        nBlockSize = UINT(pszSrc - pszOldSrc); 
        // Check for enough space after substitution
        if (pszDest + nBlockSize >= pszNew + cchTextNew &&
            NULL == (pszNew = ReallocTextBuffer(pszNew, &cchTextNew)))
        {
            return NULL;
        }

        // Copy from the last # to the new one
        CopyMemory(pszDest, pszOldSrc, nBlockSize * sizeof(WCHAR));  // don't want the terminating NULL!
        pszDest += nBlockSize;
        pszSrc += 2; // Skip the ##

        // Copy the symbol name
        iSymbol = 0;
        while (IsCharAlphaNumericW(*pszSrc) || (*pszSrc == '_') || (*pszSrc == '-'))
        {
            szSymbol[iSymbol++] = *pszSrc++;
        }
        szSymbol[iSymbol] = 0;

        // Get the symbol value
        hr = GetSubstValue(szTableName, szSymbol, szSymbol, ARRAYSIZE(szSymbol));
        if (FAILED(hr))
        {
            // There's a problem, abort and return the buffer untouched
            LocalFree(pszNew);

            WCHAR szErrorText[MAX_INPUT_LINE + 1];
            StringCchPrintfW(szErrorText, ARRAYSIZE(szErrorText), L"Substitution symbol not found: %s", szSymbol);

            ReportError(hr, szErrorText);
            return NULL;
        }

        // Make sure we have enough room for one symbol
        if (pszDest + MAX_INPUT_LINE + 1 >= pszNew + cchTextNew &&
            NULL == (pszNew = ReallocTextBuffer(pszNew, &cchTextNew)))
        {
            return NULL;
        }

        // Copy the symbol value to the new text
        iSymbol = 0;
        while (szSymbol[iSymbol] != 0)
        {
            *pszDest++ = szSymbol[iSymbol++];
        }

        // Advance to the next iteration
        pszOldSrc = pszSrc;
        pszSrc = FindSymbolToken(pszSrc, cchText - UINT(pszSrc - pszText));
    }

    if (pszDest == pszNew)
    {
        // We did nothing, return NULL
        LocalFree(pszNew);
        return NULL;
    }

    // Copy the remainder text (after the last #)
    if (pszDest + wcslen(pszOldSrc) >= pszNew + cchTextNew &&
        NULL == (pszNew = ReallocTextBuffer(pszNew, &cchTextNew)))
    {
        return NULL;
    }
    StringCchCopyW(pszDest, lstrlenW(pszOldSrc) + 1, pszOldSrc);

    return pszNew;
}

//---------------------------------------------------------------------------
HRESULT OutputResourceLine(LPCWSTR pszFilename, FILE *outfile, PACKFILETYPE ePackFileType)
{
    HRESULT hr;

    //---- did we already process this filename? ----
    UINT cNames = FileInfo.GetSize();
    for (UINT c=0; c < cNames; c++)
    {
        if (lstrcmpi(FileInfo[c].wsName, pszFilename)==0)
            return S_OK;
    }

    WCHAR szTempName[_MAX_PATH+1];
    WCHAR szResName[_MAX_PATH];
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];
    WCHAR *pszBaseName = szBaseName, *filetype;
    LPWSTR pszText;
    BOOL fWasAnsi;
    BOOL fFileChecked = FALSE;
    
    WCHAR szOrigName[_MAX_PATH];
    StringCchCopyW(szOrigName, ARRAYSIZE(szOrigName), pszFilename);

    _wsplitpath(pszFilename, szDrive, szDir, pszBaseName, szExt);

    if (ePackFileType == PACK_INIFILE)
    {
        //---- translate to UNICODE, if needed ----
        hr = AllocateTextFile(pszFilename, &pszText, &fWasAnsi);
        if (FAILED(hr))
            return hr;
    
        if (*pszBaseName == kRESFILECHAR)
        {
            pszBaseName++;
        }

        // If this an INI file with a subst table, process the substitution
        for (int i = 0; i < SubstNames.GetSize(); i++)
        {
            if (0 == AsciiStrCmpI(SubstNames[i].sName, pszBaseName))
            {
                SetLastError(0);
                LPWSTR pszNewText = SubstituteSymbols(pszBaseName, pszText);
                if (pszNewText != NULL)
                {
                    LPWSTR pszTemp = pszText;

                    pszText = pszNewText;
                    LocalFree(pszTemp);
                }
                hr = GetLastError();
                if (SUCCEEDED(hr))
                {
                    HRESULT hr = TextToFile(pszFilename, pszText); // Local hr, ignore failure later

                    if (SUCCEEDED(hr))
                    {
                        fWasAnsi = FALSE; // We don't need another temp file
                    }
                }
                break;
            }
        }

        if (SUCCEEDED(hr) && fWasAnsi)       // write out as temp file
        {
            DWORD len = lstrlen(g_szTempPath);
            
            if ((len) && (g_szTempPath[len-1] == '\\'))
                StringCchPrintfW(szTempName, ARRAYSIZE(szTempName), L"%s%s%d%s", g_szTempPath, TEMP_FILENAME_BASE, iTempBitmapNum++, L".uni");
            else
                StringCchPrintfW(szTempName, ARRAYSIZE(szTempName), L"%s\\%s%d%s", g_szTempPath, TEMP_FILENAME_BASE, iTempBitmapNum++, L".uni");

            hr = TextToFile(szTempName, pszText);
            pszFilename = szTempName;       // use this name in .rc file
        }

        LocalFree(pszText);

        if (FAILED(hr)) 
            return hr;

        fFileChecked = TRUE;
    }
    
    if (! fFileChecked)
    {
        //---- ensure the file is accessible ----
        if (_waccess(pszFilename, 0) != 0)
        {
            fwprintf(ConsoleFile, L"Error - cannot access file: %s\n", pszFilename);

            return MakeError32(E_FAIL);          // cannot access (open) file
        }
    }

    bool bUseClassName = false;

    if (ePackFileType == PACK_IMAGEFILE)
    {
        filetype = L"BITMAP";
        bUseClassName = true;
    }
    else if (ePackFileType == PACK_NTLFILE)
    {
        filetype = L"NTL";
    }
    else if (AsciiStrCmpI(szExt, L".ini")==0)
    {
        filetype = L"TEXTFILE";
    }
    else if (AsciiStrCmpI(szExt, L".wav")==0)
    {
        filetype = L"WAVE";
        bUseClassName = true;
    }
    else
    {
        filetype = L"CUSTOM";
        bUseClassName = true;
    }
     
    MakeResName(szOrigName, szResName, ARRAYSIZE(szResName), bUseClassName);
    
    //---- replace all single backslashes with double ones ----
    WCHAR DblName[_MAX_PATH+1];
    WCHAR *d = DblName;
    LPCWSTR p = pszFilename;
    while (*p)
    {
        if (*p == '\\')
            *d++ = '\\';

        *d++ = *p++;
    }
    *d = 0;

    //---- output the line to the .rc file ----
    fwprintf(outfile, L"%-30s \t %s DISCARDABLE \"%s\"\n", szResName, filetype, DblName);

    FILEINFO fileinfo;
    fileinfo.wsName = pszFilename;
    fileinfo.fIniFile = (ePackFileType == PACK_INIFILE);

    FileInfo.Add(fileinfo);

    g_LineCount++;

    return S_OK;
}
//---------------------------------------------------------------------------
void ClearCombos()
{
    for (int s=0; s < MAX_SIZES; s++)
    {
        for (int c=0; c < MAX_COLORS; c++)
        {
            Combos[s][c] = -1;          // -1 means no file supports this combo
        }
    }

    g_iMaxColor = -1;
    g_iMaxSize = -1;
}
//---------------------------------------------------------------------------
HRESULT OutputCombos(FILE *outfile)
{
    if ((g_iMaxColor < 0) || (g_iMaxSize < 0))      // no combos found
        return ReportError(E_FAIL, L"No size/color combinations found");

    fwprintf(outfile, L"COMBO COMBODATA\n");
    fwprintf(outfile, L"BEGIN\n");
    fwprintf(outfile, L"    %d, %d    // cColors, cSizes\n", g_iMaxColor+1, g_iMaxSize+1);

    for (int s=0; s <= g_iMaxSize; s++)
    {
        for (int c=0; c <= g_iMaxColor; c++)
        {
            fwprintf(outfile, L"    %d, ", Combos[s][c]);
        }

        fwprintf(outfile, L"   // size=%d row\n", s);
    }

    fwprintf(outfile, L"END\n");
    OutputDashLine(outfile);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT GetFileIndex(LPCWSTR pszName, int *piIndex)
{
    int cCount = ResFileNames.GetSize();

    for (int i=0; i < cCount; i++)      
    {
        if (lstrcmpi(ResFileNames[i], pszName)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(E_FAIL);      // unknown filename
}
//---------------------------------------------------------------------------
HRESULT GetColorIndex(LPCWSTR pszName, int *piIndex)
{
    int cCount = ColorSchemes.GetSize();

    for (int i=0; i < cCount; i++)      
    {
        if (lstrcmpi(ColorSchemes[i], pszName)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(E_FAIL);      // unknown colorname
}
//---------------------------------------------------------------------------
HRESULT GetSizeIndex(LPCWSTR pszName, int *piIndex)
{
    int cCount = SizeNames.GetSize();

    for (int i=0; i < cCount; i++)      
    {
        if (lstrcmpi(SizeNames[i], pszName)==0)
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(E_FAIL);      // unknown sizename
}
//---------------------------------------------------------------------------
HRESULT ApplyCombos(LPCWSTR pszResFileName, LPCWSTR pszColors, LPCWSTR pszSizes)
{
    //---- get index of pszResFileName ----
    int iFileNum;
    HRESULT hr = GetFileIndex(pszResFileName, &iFileNum);
    if (FAILED(hr))
        return hr;
    
    //---- parse colors in pszColors ----
    CScanner scan(pszColors);
    WCHAR szName[_MAX_PATH+1];
    int iColors[MAX_COLORS];
    int cColors = 0;

    while (1)
    {
        if (! scan.GetId(szName))
            return MakeError32(E_FAIL);      // bad color list

        //---- get index of szName ----
        int index;
        HRESULT hr = GetColorIndex(szName, &index);
        if (FAILED(hr))
            return hr;

        if (cColors == MAX_COLORS)
            return MakeError32(E_FAIL);      // too many colors specified

        iColors[cColors++] = index;

        if (scan.EndOfLine())
            break;

        if (! scan.GetChar(L','))
            return MakeError32(E_FAIL);      // names must be comma separated
    }


    //---- parse sizes in pszSizes ----
    scan.AttachLine(pszSizes);
    int iSizes[MAX_SIZES];
    int cSizes = 0;

    while (1)
    {
        if (! scan.GetId(szName))
            return MakeError32(E_FAIL);      // bad color list

        //---- get index of szName ----
        int index;
        HRESULT hr = GetSizeIndex(szName, &index);
        if (FAILED(hr))
            return hr;

        if (cSizes == MAX_SIZES)
            return MakeError32(E_FAIL);      // too many sizes specified

        iSizes[cSizes++] = index;

        if (scan.EndOfLine())
            break;

        if (! scan.GetChar(L','))
            return MakeError32(E_FAIL);      // names must be comma separated
    }

    //---- now form all combos of specified colors & sizes ----
    for (int c=0; c < cColors; c++)     // for each color
    {
        int color = iColors[c];

        for (int s=0; s < cSizes; s++)      // for each size
        {
            int size = iSizes[s];

            Combos[size][color] = (SHORT)iFileNum;

            //---- update our max's ----
            if (size > g_iMaxSize)
                g_iMaxSize = size;

            if (color > g_iMaxColor)
                g_iMaxColor = color;
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
void WriteProperty(CSimpleArray<CWideString> &csa, LPCWSTR pszSection, LPCWSTR pszPropName,
    LPCWSTR pszValue)
{
    WCHAR szBuff[MAX_PATH*2];

    StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), L"%s@[%s]%s=%s", g_szBaseIniName, pszSection, pszPropName, pszValue);

    csa.Add(CWideString(szBuff));
}
//---------------------------------------------------------------------------
BOOL FnCallBack(enum THEMECALLBACK tcbType, LPCWSTR pszName, LPCWSTR pszName2, 
     LPCWSTR pszName3, int iIndex, LPARAM lParam)
{
    HRESULT hr = S_OK;
    int nDefaultDepth = 15;

    switch (tcbType)
    {
        case TCB_FILENAME:
            WCHAR szFullName[_MAX_PATH+1];

            hr = AddPathIfNeeded(pszName, g_szInputDir, szFullName, ARRAYSIZE(szFullName));
            if (FAILED(hr))
            {
                SET_LAST_ERROR(hr);
                return FALSE;
            }

            if ((iIndex == TMT_IMAGEFILE) || (iIndex == TMT_GLYPHIMAGEFILE) || (iIndex == TMT_STOCKIMAGEFILE))
                hr = OutputResourceLine(szFullName, (FILE *)lParam, PACK_IMAGEFILE);
            else if ((iIndex >= TMT_IMAGEFILE1) && (iIndex <= TMT_IMAGEFILE5))
                hr = OutputResourceLine(szFullName, (FILE *)lParam, PACK_IMAGEFILE);
            else
                hr = MakeError32(E_FAIL);        // unexpected type

            if (FAILED(hr))
            {
                SET_LAST_ERROR(hr);
                return FALSE;
            }
            break;

        case TCB_FONT:
            WriteProperty(PropValuePairs, pszName2, pszName3, pszName);
            break;

        case TCB_MIRRORIMAGE:
            {
                LPCWSTR p;
            
                if (lParam)
                    p = L"1";
                else
                    p = L"0";
    
                WriteProperty(PropValuePairs, pszName2, pszName3, p);
            }
            break;

        case TCB_LOCALIZABLE_RECT:
            {
                WCHAR szBuff[100];
                RECT *prc = (RECT *)lParam;

                StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), L"%d, %d, %d, %d", prc->left, prc->top, prc->right, prc->bottom);

                WriteProperty(PropValuePairs, pszName2, pszName3, szBuff);
            }
            break;

        case TCB_COLORSCHEME:
            ColorSchemes.Add(CWideString(pszName));
            ColorDisplays.Add(CWideString(pszName2));
            ColorToolTips.Add(CWideString(pszName3));
            break;

        case TCB_SIZENAME:
            SizeNames.Add(CWideString(pszName));
            SizeDisplays.Add(CWideString(pszName2));
            SizeToolTips.Add(CWideString(pszName3));
            break;

        case TCB_SUBSTTABLE:
        {
            int iTableIndex = GetSubstTableIndex(pszName);

            if (iTableIndex == -1) // Not found, add one
            {
                sSubstTable s;
                s.sName = pszName;
                s.iFirstIndex = -1;
                s.cItems = 0;

                SubstNames.Add(s);
                iTableIndex = SubstNames.GetSize() - 1;
            }
            if (0 == AsciiStrCmpI(pszName2, SUBST_TABLE_INCLUDE))
            {
                int iSecondTableIndex = GetSubstTableIndex(pszName3);

                if (iSecondTableIndex == -1)
                {
                    SET_LAST_ERROR(MakeError32(ERROR_NOT_FOUND));
                    return FALSE;
                }
                else
                {
                    // Copy the symbols in the new table
                    for (UINT iSymbol = SubstNames[iSecondTableIndex].iFirstIndex; 
                        iSymbol < SubstNames[iSecondTableIndex].iFirstIndex + SubstNames[iSecondTableIndex].cItems;
                        iSymbol++)
                    {
                        if (SubstNames[iTableIndex].iFirstIndex == -1)
                        {
                            SubstNames[iTableIndex].iFirstIndex = SubstValues.GetSize();
                        }
                        SubstNames[iTableIndex].cItems++;
                        SubstIds.Add(CWideString(SubstIds[iSymbol]));
                        SubstValues.Add(CWideString(SubstValues[iSymbol]));
                    }
                }
            } 
            else if (pszName2 != NULL && pszName3 != NULL)
            {
                // If the table was pre-created, update it
                if (SubstNames[iTableIndex].iFirstIndex == -1)
                {
                    SubstNames[iTableIndex].iFirstIndex = SubstValues.GetSize();
                }
                SubstNames[iTableIndex].cItems++;
                SubstIds.Add(CWideString(pszName2));
                SubstValues.Add(CWideString(pszName3));
            }
            break;
        }

        case TCB_NEEDSUBST:
            GetSubstValue(pszName, pszName2, (LPWSTR) pszName3, MAX_INPUT_LINE);
            break;

        case TCB_CDFILENAME:
            WCHAR szResName[_MAX_PATH+1];
            MakeResName(pszName, szResName, ARRAYSIZE(szResName));

            ResFileNames.Add(CWideString(szResName));
            MinDepths.Add(nDefaultDepth);
            BaseResFileNames.Add(CWideString(pszName));
            OrigFileNames.Add(CWideString(pszName2));
            break;

        case TCB_CDFILECOMBO:
            MakeResName(pszName, szResName, ARRAYSIZE(szResName));

            hr = ApplyCombos(szResName, pszName2, pszName3);
            if (FAILED(hr))
            {
                SET_LAST_ERROR(hr);
                return FALSE;
            }
            break;
 
        case TCB_DOCPROPERTY:
            if ((iIndex < 0) || (iIndex >= ARRAYSIZE(DocProperties)))
                return FALSE;
            DocProperties[iIndex] = pszName;
            break;

        case TCB_MINCOLORDEPTH:
            MakeResName(pszName, szResName, ARRAYSIZE(szResName));

            int iRes;
            
            if (SUCCEEDED(GetFileIndex(szResName, &iRes)))
            {
                MinDepths[iRes] = iIndex;
            }
            break;
    }

    SET_LAST_ERROR(hr);
    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT OpenOutFile(FILE *&outfile, LPCWSTR pszRcName, LPCWSTR pszBaseName)
{
    if (! outfile)          // first time thru
    {
        //---- open out file ----
        outfile = _wfopen(pszRcName, L"wt");
        if (! outfile)
        {
            fwprintf(ConsoleFile, L"Error - cannot open file: %s\n", pszRcName);

            return MakeError32(E_FAIL);
        }

        OutputDashLine(outfile);
        fwprintf(outfile, L"// %s.rc - used to build the %s theme DLL\n", pszBaseName, pszBaseName);
        OutputDashLine(outfile);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT ProcessContainerFile(LPCWSTR pszDir, LPCWSTR pszInputName, FILE *&outfile)
{
    HRESULT hr;
    
    //---- output .ini filename as a resource ----
    WCHAR szFullName[_MAX_PATH+1];
    StringCchPrintfW(szFullName, ARRAYSIZE(szFullName), L"%s\\%s", pszDir, pszInputName);

    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"processing container file: %s\n", szFullName);

    hr = OutputResourceLine(szFullName, outfile, PACK_INIFILE);
    if (FAILED(hr))
    {
        ReportError(hr, L"Error reading themes.ini file");
        goto exit;
    }

    OutputDashLine(outfile);
    int oldcnt = g_LineCount;

    //---- scan the themes.ini files for color, size, & file sections; write 'em to the .rc file ----
    DWORD flags = PTF_CONTAINER_PARSE | PTF_CALLBACK_COLORSECTION | PTF_CALLBACK_SIZESECTION
        | PTF_CALLBACK_FILESECTION | PTF_CALLBACK_DOCPROPERTIES | PTF_CALLBACK_SUBSTTABLE;


    WCHAR szErrMsg[4096];

    hr = _ParseThemeIniFile(szFullName, flags, FnCallBack, (LPARAM)outfile);
    if (FAILED(hr))
    {
        ReportError(hr, L"Error parsing themes.ini file");
        goto exit;
    }

    if (g_LineCount > oldcnt)
        OutputDashLine(outfile);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT ProcessClassDataFile(LPCWSTR pszFileName, FILE *&outfile, LPCWSTR pszResFileName, LPCWSTR pszInputDir)
{
    HRESULT hr;
    WCHAR szFullName[MAX_PATH];
    WCHAR szTempName[MAX_PATH];
    LPWSTR pBS = NULL;

    hr = SafeStringCchCopyW(g_szCurrentClass, ARRAYSIZE(g_szCurrentClass), pszFileName);        // make avail to everybody
    if (SUCCEEDED(hr))
    {
        pBS = wcschr(g_szCurrentClass, L'\\');

        if (pBS)
        {
            *pBS = L'_';
            *(pBS + 1) = L'\0';
        }
    }
    if (pBS == NULL) // If there's no '\', don't use the class name
    {
        g_szCurrentClass[0] = 0;
    }

    hr = SafeStringCchCopyW(g_szInputDir, ARRAYSIZE(g_szInputDir), pszInputDir );        // make avail to everybody
    if (FAILED(hr))
        goto exit;

    hr = AddPathIfNeeded(pszFileName, pszInputDir, szFullName, ARRAYSIZE(szFullName));
    if (FAILED(hr))
        goto exit;

    //---- extract base ini name ----
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT];
    _wsplitpath(szFullName, szDrive, szDir, g_szBaseIniName, szExt);
    
    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"processing classdata file: %s\n", pszFileName);

    //---- Create a temporary INI file with the substituted values
    UINT cTablesCount = SubstNames.GetSize();
    for (UINT i = 0; i < cTablesCount; i++)
    {
        if (0 == AsciiStrCmpI(SubstNames[i].sName, pszResFileName))
        {
            // Section used in the string table
            StringCchCopyW(g_szBaseIniName, ARRAYSIZE(g_szBaseIniName), SubstNames[i].sName);
            // Create the temp file
            DWORD len = lstrlen(g_szTempPath);
            
            if ((len) && (g_szTempPath[len-1] == '\\'))
                StringCchPrintfW(szTempName, ARRAYSIZE(szTempName), L"%s$%s%s", g_szTempPath, pszResFileName, szExt);
            else
                StringCchPrintfW(szTempName, ARRAYSIZE(szTempName), L"%s\\$%s%s", g_szTempPath, pszResFileName, szExt);
         
            if (lstrcmpi(szFullName, szTempName))
            {
                CopyFile(szFullName, szTempName, FALSE);
                SetFileAttributes(szTempName, FILE_ATTRIBUTE_NORMAL);
                StringCchCopyW(szFullName, ARRAYSIZE(szFullName), szTempName);
            }
            break;
        }
    }

    //---- output .ini filename as a resource ----
    hr = OutputResourceLine(szFullName, outfile, PACK_INIFILE);
    if (FAILED(hr))
        goto exit;

    OutputDashLine(outfile);
    int oldcnt;
    oldcnt = g_LineCount;

    //---- scan the classdata .ini file for valid filenames & fonts; write 'em to the .rc file ----
    WCHAR szErrMsg[4096];
    DWORD flags;
    flags = PTF_CLASSDATA_PARSE | PTF_CALLBACK_FILENAMES | PTF_CALLBACK_LOCALIZATIONS 
        | PTF_CALLBACK_MINCOLORDEPTH;

    hr = _ParseThemeIniFile(szFullName, flags, FnCallBack, (LPARAM)outfile);
    if (FAILED(hr))
    {
        ReportError(hr, L"Error parsing classdata .ini file");
        goto exit;
    }

    if (g_LineCount > oldcnt)
        OutputDashLine(outfile);

    hr = S_OK;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT ProcessClassDataFiles(FILE *&outfile, LPCWSTR pszInputDir)
{
    int cNames = OrigFileNames.GetSize();

    for (int i=0; i < cNames; i++)
    {
        HRESULT hr = ProcessClassDataFile(OrigFileNames[i], outfile, BaseResFileNames[i], pszInputDir);
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT OutputStringTable(FILE *outfile, CWideString *ppszStrings, UINT cStrings, int iBaseNum,
    LPCWSTR pszTitle, BOOL fLocalizable=TRUE, BOOL fMinDepths=FALSE)
{
    if (! cStrings)
        return S_OK;

    if (fLocalizable)
    {
        fwprintf(outfile, L"STRINGTABLE DISCARDABLE       // %s\n", pszTitle);
    }
    else            // custom resource type
    {
        fwprintf(outfile, L"1 %s DISCARDABLE\n", pszTitle);
    }

    fwprintf(outfile, L"BEGIN\n");

    for (UINT c=0; c < cStrings; c++)
    {
        LPCWSTR p = ppszStrings[c];
        if (! p)
            p = L"";

        if (fLocalizable)
            fwprintf(outfile, L"    %d \t\"%s\"\n", iBaseNum, p);
        else
        {
            if (fMinDepths)
            {
                fwprintf(outfile, L"    %d,\n", MinDepths[c]);
            }
            else
            {
                fwprintf(outfile, L"    L\"%s\\0\",\n", p);
            }

            if (c == cStrings-1)        // last entry
            {
                if (fMinDepths)
                {
                    fwprintf(outfile, L"    0\n");
                }
                else
                {
                    fwprintf(outfile, L"    L\"\\0\",\n");
                }
            }
        }

        iBaseNum++;
    }

    fwprintf(outfile, L"END\n");
    OutputDashLine(outfile);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT OutputAllStringTables(FILE *outfile)
{
    //---- output all non-localizable strings ----
    if (ColorSchemes.GetSize())
    {
        OutputStringTable(outfile, &ColorSchemes[0], ColorSchemes.GetSize(), 
            0, L"COLORNAMES", FALSE);
    }

    if (SizeNames.GetSize())
    {
        OutputStringTable(outfile, &SizeNames[0], SizeNames.GetSize(), 
            0, L"SIZENAMES", FALSE);
    }

    if (ResFileNames.GetSize())
    {
        OutputStringTable(outfile, &ResFileNames[0], ResFileNames.GetSize(), 
            0, L"FILERESNAMES", FALSE);
    }

    if (MinDepths.GetSize())
    {
        OutputStringTable(outfile, &ResFileNames[0], ResFileNames.GetSize(), 
            0, L"MINDEPTH", FALSE, TRUE);
    }

    if (OrigFileNames.GetSize())
    {
        OutputStringTable(outfile, &OrigFileNames[0], OrigFileNames.GetSize(), 
            0, L"ORIGFILENAMES", FALSE);
    }

    //---- output all localizable strings ----
    if (ColorDisplays.GetSize())
    {
        OutputStringTable(outfile, &ColorDisplays[0], ColorDisplays.GetSize(), 
            RES_BASENUM_COLORDISPLAYS, L"Color Display Names");
    }

    if (ColorToolTips.GetSize())
    {
        OutputStringTable(outfile, &ColorToolTips[0], ColorToolTips.GetSize(), 
            RES_BASENUM_COLORTOOLTIPS, L"Color ToolTips");
    }

    if (SizeDisplays.GetSize())
    {
        OutputStringTable(outfile, &SizeDisplays[0], SizeDisplays.GetSize(), 
            RES_BASENUM_SIZEDISPLAYS, L"Size Display Names");
    }

    if (SizeToolTips.GetSize())
    {
        OutputStringTable(outfile, &SizeToolTips[0], SizeToolTips.GetSize(), 
            RES_BASENUM_SIZETOOLTIPS, L"Size ToolTips");
    }

    OutputStringTable(outfile, &DocProperties[0], ARRAYSIZE(DocProperties), 
        RES_BASENUM_DOCPROPERTIES, L"Doc PropValuePairs");

    OutputStringTable(outfile, &PropValuePairs[0], PropValuePairs.GetSize(), 
        RES_BASENUM_PROPVALUEPAIRS, L"PropValuePairs");

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL WriteBitmapHeader(CSimpleFile &cfOut, BYTE *pBytes, DWORD dwBytes)
{
    BOOL fOK = FALSE;
    BYTE pbHdr1[] = {0x42, 0x4d};
    BYTE pbHdr2[] = {0x0, 0x0, 0x0, 0x0};
    int iFileLen;

    //---- add bitmap hdr at front ----
    HRESULT hr = cfOut.Write(pbHdr1, sizeof(pbHdr1));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    //---- add length of data ----
    iFileLen = dwBytes + sizeof(BITMAPFILEHEADER);
    hr = cfOut.Write(&iFileLen, sizeof(int));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    hr = cfOut.Write(pbHdr2, sizeof(pbHdr2));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    //---- offset to bits (who's idea was *this* field?) ----
    int iOffset, iColorTableSize;
    DWORD dwSize;

    iOffset = sizeof(BITMAPFILEHEADER);
    dwSize = *(DWORD *)pBytes;
    iOffset += dwSize; 
    iColorTableSize = 0;

    switch (dwSize)
    {
        case sizeof(BITMAPCOREHEADER):
            BITMAPCOREHEADER *hdr1;
            hdr1 = (BITMAPCOREHEADER *)pBytes;
            if (hdr1->bcBitCount == 1)
                iColorTableSize = 2*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 4)
                iColorTableSize = 16*sizeof(RGBTRIPLE);
            else if (hdr1->bcBitCount == 8)
                iColorTableSize = 256*sizeof(RGBTRIPLE);
            break;

        case sizeof(BITMAPINFOHEADER):
        case sizeof(BITMAPV4HEADER):
        case sizeof(BITMAPV5HEADER):
            BITMAPINFOHEADER *hdr2;
            hdr2 = (BITMAPINFOHEADER *)pBytes;
            if (hdr2->biClrUsed)
                iColorTableSize = hdr2->biClrUsed*sizeof(RGBQUAD);
            else
            {
                if (hdr2->biBitCount == 1)
                    iColorTableSize = 2*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 4)
                    iColorTableSize = 16*sizeof(RGBQUAD);
                else if (hdr2->biBitCount == 8)
                    iColorTableSize = 256*sizeof(RGBQUAD);
            }
            break;
    }

    iOffset += iColorTableSize;
    hr = cfOut.Write(&iOffset, sizeof(int));
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }

    fOK = TRUE;

exit:
    return fOK;
}
//---------------------------------------------------------------------------
BOOL CALLBACK ResEnumerator(HMODULE hModule, LPCWSTR pszType, LPWSTR pszResName, LONG_PTR lParam)
{
    HRESULT hr;
    BOOL fAnsi = (BOOL)lParam;
    BOOL fText = FALSE;
    RESOURCE BYTE *pBytes = NULL;
    CSimpleFile cfOut;
    DWORD dwBytes;

    if (pszType != RT_BITMAP)
        fText = TRUE;

    hr = GetPtrToResource(hModule, pszType, pszResName, (void **)&pBytes, &dwBytes);
    if (FAILED(hr))
    {
        ReportError(hr, L"error reading file resources");
        goto exit;
    }

    //---- convert name to filename ----
    WCHAR szFileName[_MAX_PATH+1];
    StringCchCopyW(szFileName, ARRAYSIZE(szFileName), pszResName);
    WCHAR *q;
    q = wcsrchr(szFileName, '_');
    if (q)
        *q = '.';
        
    if (! fText)
        fAnsi = FALSE;          // don't translate if binary data

    hr = cfOut.Create(szFileName, fAnsi);
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot create output file");
        goto exit;
    }

    if (! fText)
    {
        if (! WriteBitmapHeader(cfOut, pBytes, dwBytes))
            goto exit;
    }

    hr = cfOut.Write(pBytes, dwBytes);
    if (FAILED(hr))
    {
        ReportError(hr, L"Cannot write to output file");
        goto exit;
    }
    
exit:
    return (SUCCEEDED(hr));
}
//---------------------------------------------------------------------------
void WriteBitmap(LPWSTR pszFileName, BITMAPINFOHEADER* pbmi, DWORD* pdwData)
{
    DWORD dwLen = pbmi->biWidth * pbmi->biHeight;

    CSimpleFile cfOut;
    cfOut.Create(pszFileName, FALSE);

    BITMAPFILEHEADER bmfh = {0};
    bmfh.bfType = 'MB';
    bmfh.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + (dwLen * sizeof(DWORD));
    bmfh.bfOffBits = sizeof(BITMAPINFOHEADER) + sizeof(BITMAPFILEHEADER);
    cfOut.Write(&bmfh, sizeof(BITMAPFILEHEADER));
    cfOut.Write(pbmi, sizeof(BITMAPINFOHEADER));
    cfOut.Write(pdwData, dwLen * sizeof(DWORD));
}

HRESULT ColorShift(LPWSTR pszFileName, int cchFileName)
{
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HBITMAP hbm = (HBITMAP)LoadImage(0, pszFileName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE | LR_LOADFROMFILE);
        if (hbm)
        {
            BITMAP bm;
            GetObject(hbm, sizeof(bm), &bm);

            DWORD dwLen = bm.bmWidth * bm.bmHeight;
            DWORD* pPixelQuads = new DWORD[dwLen];
            if (pPixelQuads)
            {
                BITMAPINFO bi = {0};
                bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                bi.bmiHeader.biWidth = bm.bmWidth;
                bi.bmiHeader.biHeight = bm.bmHeight;
                bi.bmiHeader.biPlanes = 1;
                bi.bmiHeader.biBitCount = 32;
                bi.bmiHeader.biCompression = BI_RGB;

                if (GetDIBits(hdc, hbm, 0, bm.bmHeight, pPixelQuads, &bi, DIB_RGB_COLORS))
                {
                    pszFileName[lstrlen(pszFileName) - 4] = 0;

                    WCHAR szFileNameR[MAX_PATH];
                    StringCchPrintfW(szFileNameR, ARRAYSIZE(szFileNameR), L"%sR.bmp", pszFileName);
                    WCHAR szFileNameG[MAX_PATH];
                    StringCchPrintfW(szFileNameG, ARRAYSIZE(szFileNameG), L"%sG.bmp", pszFileName);
                    WCHAR szFileNameB[MAX_PATH];
                    StringCchPrintfW(szFileNameB, ARRAYSIZE(szFileNameB), L"%sB.bmp", pszFileName);
                    
                    WriteBitmap(szFileNameB, &bi.bmiHeader, pPixelQuads);

                    DWORD *pdw = pPixelQuads;
                    for (DWORD i = 0; i < dwLen; i++)
                    {
                        COLORREF crTemp = *pdw;
                        if (crTemp != RGB(255, 0, 255))
                        {
                            crTemp = (crTemp & 0xff000000) | RGB(GetGValue(crTemp), GetBValue(crTemp), GetRValue(crTemp));
                        }
                        *pdw = crTemp;
                        pdw++;
                    }

                    WriteBitmap(szFileNameR, &bi.bmiHeader, pPixelQuads);

                    pdw = pPixelQuads;
                    for (DWORD i = 0; i < dwLen; i++)
                    {
                        COLORREF crTemp = *pdw;
                        if (crTemp != RGB(255, 0, 255))
                        {
                            crTemp = (crTemp & 0xff000000) | RGB(GetGValue(crTemp), GetBValue(crTemp), GetRValue(crTemp));
                        }
                        *pdw = crTemp;
                        pdw++;
                    }

                    WriteBitmap(szFileNameG, &bi.bmiHeader, pPixelQuads);
                }

                delete[] pPixelQuads;
            }
            DeleteObject(hbm);
        }
        ReleaseDC(NULL, hdc);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
HRESULT UnpackTheme(LPCWSTR pszFileName, BOOL fAnsi)
{
    HRESULT hr = S_OK;

    //---- load the file as a resource only DLL ----
    RESOURCE HINSTANCE hInst = LoadLibraryEx(pszFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hInst)
    {
        //---- enum all bitmaps & write as files ----
        if (! EnumResourceNames(hInst, RT_BITMAP, ResEnumerator, LPARAM(fAnsi)))
            hr = GetLastError();

        //---- enum all .ini files & write as files ----
        if (! EnumResourceNames(hInst, L"TEXTFILE", ResEnumerator, LPARAM(fAnsi)))
            hr = GetLastError();

        //---- close the file ----
        if (hInst)
            FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT PackTheme(LPCWSTR pszInputDir, LPWSTR pszOutputName, DWORD cchOutputName)
{
    //---- is it a valid dir ----
    DWORD dwMask = GetFileAttributes(pszInputDir);
    if ((dwMask == 0xffffffff) || (! (dwMask & FILE_ATTRIBUTE_DIRECTORY)))
    {
        fwprintf(ConsoleFile, L"\nError - not a valid directory name: %s\n", pszInputDir);
        return MakeError32(E_FAIL);
    }

    //---- build: szDllName ----
    WCHAR szDllName[_MAX_PATH+1];
    BOOL fOutputDir = FALSE;

    if (! *pszOutputName)                     // not specified - build from pszInputDir
    {
        WCHAR szFullDir[_MAX_PATH+1];
        WCHAR *pszBaseName;

        DWORD val = GetFullPathName(pszInputDir, ARRAYSIZE(szFullDir), szFullDir, &pszBaseName);
        if (! val)
            return MakeErrorLast();

        //---- make output dir same as input dir ----
        StringCchPrintfW(szDllName, ARRAYSIZE(szDllName), L"%s\\%s%s", pszInputDir, pszBaseName, THEMEDLL_EXT);
    }
    else        // get full name of output file
    {
        DWORD val = GetFullPathName(pszOutputName, ARRAYSIZE(szDllName), szDllName, NULL);
        if (! val)
            return MakeErrorLast();

        fOutputDir = TRUE;            // don't remove temp files
    }

    // Give the caller the path so the file can be signed.
    StringCchCopyW(pszOutputName, cchOutputName, szDllName);

    //--- delete the old target in case we have errors ----
    DeleteFile(pszOutputName);

    //---- build: g_szTempPath, szDllRoot, szRcName, and szResName ----
    WCHAR szDllRoot[_MAX_PATH+1];
    WCHAR szResName[_MAX_PATH+1];
    WCHAR szRcName[_MAX_PATH+1];
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];

    _wsplitpath(szDllName, szDrive, szDir, szBaseName, szExt);

    _wmakepath(szDllRoot, L"", L"", szBaseName, szExt);
    _wmakepath(szRcName, szDrive, szDir, szBaseName, L".rc");
    _wmakepath(szResName, szDrive, szDir, szBaseName, L".res");

    if (fOutputDir)
        _wmakepath(g_szTempPath, szDrive, szDir, L"", L"");
    else
        StringCchCopyW(g_szTempPath, ARRAYSIZE(g_szTempPath), L".");

    FILE *outfile = NULL;
    OpenOutFile(outfile, szRcName, szBaseName);

    ClearCombos();

    //---- process the main container file ----
    HRESULT hr = ProcessContainerFile(pszInputDir, CONTAINER_NAME, outfile);
    if (FAILED(hr))
        goto exit;

    //---- process all classdata files that were defined in container file ----
    hr = ProcessClassDataFiles(outfile, pszInputDir);
    if (FAILED(hr))
        goto exit;

    //---- output all string tables ----
    hr = OutputAllStringTables(outfile);
    if (FAILED(hr))
        goto exit;

    hr = OutputCombos(outfile);
    if (FAILED(hr))
        goto exit;

    hr = OutputVersionInfo(outfile, szDllRoot, szBaseName);
    if (FAILED(hr))
        goto exit;

    fclose(outfile);
    outfile = NULL;

    hr = BuildThemeDll(szRcName, szResName, szDllName);

exit:
    if (outfile)
        fclose(outfile);

    if (ConsoleFile != stdout)
        fclose(ConsoleFile);

    if (! g_fKeepTempFiles)
        RemoveTempFiles(szRcName, szResName);

    if (SUCCEEDED(hr))
    {
        if (! g_fQuietRun)
            fwprintf(ConsoleFile, L"Created %s\n", szDllName);
        return S_OK;
    }

    if (! g_fQuietRun)
        fwprintf(ConsoleFile, L"Error occured - theme DLL not created\n");
    return hr; 
}
//---------------------------------------------------------------------------
void PrintUsage()
{
    fwprintf(ConsoleFile, L"\nUsage: \n\n");
    fwprintf(ConsoleFile, L"    packthem [-o <output name> ] [-k] [-q] <dirname>\n");
    fwprintf(ConsoleFile, L"      -m    specifies the (full path) name of the image file you want to color shift\n");
    fwprintf(ConsoleFile, L"      -o    specifies the (full path) name of the output file\n");
    fwprintf(ConsoleFile, L"      -k    specifies that temp. files should be kept (not deleted)\n");
    fwprintf(ConsoleFile, L"      -d    do not sign the file when building it\n");
    fwprintf(ConsoleFile, L"      -q    quite mode (don't print header and progress msgs)\n\n");

    fwprintf(ConsoleFile, L"    packthem -u [-a] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -u    unpacks the packed file into its separate files in current dir\n");
    fwprintf(ConsoleFile, L"      -a    writes .ini files as ANSI (defaults to UNICODE)\n\n");

    fwprintf(ConsoleFile, L"    packthem -p [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -p    Parses the localized packed file and reports errors\n\n");

    fwprintf(ConsoleFile, L"    packthem [-c] [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -c    check the signature of the already created file\n\n");

    fwprintf(ConsoleFile, L"    packthem [-s] [-q] <packed filename> \n");
    fwprintf(ConsoleFile, L"      -s    sign the already created file\n\n");
}
//---------------------------------------------------------------------------
enum eOperation
{
    opPack = 1,
    opUnPack,
    opSign,
    opCheckSignature,
    opParse,
    opColorShift
};
//---------------------------------------------------------------------------
extern "C" WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE previnst, 
    LPTSTR pszCmdLine, int nShowCmd)
{
    //---- initialize globals from themeldr.lib ----
    ThemeLibStartUp(FALSE);

    //---- initialize our globals ----
    HRESULT hr = S_OK;
    int nWeek = -1;

    UtilsStartUp();        
    LogStartUp();

    WCHAR szOutputName[_MAX_PATH+1] = {0};
    int retval = 1;             // error, until prove otherwise

    BOOL fAnsi = FALSE; 
    BOOL fSkipSigning = FALSE;
    eOperation Operation = opPack;

    LPCWSTR p = pszCmdLine;
    szOutputName[0] = 0;    // Much faster than ={0};

    //---- default to console until something else is specified ----
    if (! ConsoleFile)
    {
        ConsoleFile = stdout;
    }

    while ((*p == '-') || (*p == '/'))
    {
        p++;
        WCHAR sw = *p;

        if (isupper(sw))
            sw = (WCHAR)tolower(sw);

        if (sw == 'e')
        {
            ConsoleFile = _wfopen(L"packthem.err", L"wt");
            g_fQuietRun = TRUE;
            p++;
        }
        else if (sw == 'o')
        {
            WCHAR *q = szOutputName;
            p++;        // skip over switch
            while (iswspace(*p))
                p++;
            while ((*p) && (! iswspace(*p)))
                *q++ = *p++;

            *q = 0;     // terminate the output name
        }
        else if (sw == 'k')
        {
            g_fKeepTempFiles = TRUE;
            p++;
        }
        else if (sw == 'q')
        {
            g_fQuietRun = TRUE;
            p++;
        }
        else if (sw == 'm')
        {
            Operation = opColorShift;

            WCHAR *q = szOutputName;
            p++;        // skip over switch
            while (iswspace(*p))
                p++;
            while ((*p) && (! iswspace(*p)))
                *q++ = *p++;

            *q = 0;     // terminate the output name
        }
        else if (sw == 'u')
        {
            Operation = opUnPack;
            p++;
        }
        else if (sw == 'd')
        {
            fSkipSigning = TRUE;
            p++;
        }
        else if (sw == 'c')
        {
            Operation = opCheckSignature;
            p++;
        }
        else if (sw == 's')
        {
            Operation = opSign;
            p++;
        }
        else if (sw == 'a')
        {
            fAnsi = TRUE;
            p++;
        }
        else if (sw == 'w')
        {
            fAnsi = TRUE;
            p++;

            LARGE_INTEGER uli;
            WCHAR szWeek[3];

            szWeek[0] = p[0];
            szWeek[1] = p[1];
            szWeek[2] = 0;
            if (StrToInt64ExInternalW(szWeek, 0, &(uli.QuadPart)) &&
                (uli.QuadPart > 0))
            {
                nWeek = (int)uli.LowPart;
            }

            while ((L' ' != p[0]) && (0 != p[0]))
            {
                p++;
            }
        }
        else if (sw == 'p')
        {
            Operation = opParse;
            p++;
        }
        else if (sw == '?')
        {
            PrintUsage();
            retval = 0;
            goto exit;
        }
        else
        {
            fwprintf(ConsoleFile, L"Error - unrecognized switch: %s\n", p);
            goto exit;
        }

        while (iswspace(*p))
            p++;
    }

    LPCWSTR pszInputDir;
    pszInputDir = p;

    if (! g_fQuietRun)
    {
        fwprintf(ConsoleFile, L"Microsoft (R) Theme Packager (Version %d)\n", PACKTHEM_VERSION);
        fwprintf(ConsoleFile, L"Copyright (C) Microsoft Corp 2000. All rights reserved.\n");
    }

    //---- any cmdline arg specified? ----
    if (Operation != opColorShift)
    {
        if ((! pszInputDir) || (! *pszInputDir))
        {
            PrintUsage(); 
            goto exit;
        }
    }

    switch (Operation)
    {
    case opPack:
        hr = PackTheme(pszInputDir, szOutputName, ARRAYSIZE(szOutputName));
        if (SUCCEEDED(hr) && !fSkipSigning)
        {
            hr = SignTheme(szOutputName, nWeek);
            if (!g_fQuietRun)
            {
                if (SUCCEEDED(hr))
                {
                    wprintf(L"Creating the signature succeeded\n");
                }
                else
                {
                    wprintf(L"The signature failed to be created.  hr=%#08lx\n", hr);
                }
            }
        }
        break;
    case opUnPack:
        hr = UnpackTheme(pszInputDir, fAnsi);
        break;
    case opSign:
        // We don't sign it again if the signature is already valid.
        if (FAILED(CheckThemeFileSignature(pszInputDir)))
        {
            // Needs signing.
            hr = SignTheme(pszInputDir, nWeek);
            if (!g_fQuietRun)
            {
                if (SUCCEEDED(hr))
                {
                    wprintf(L"Creating the signature succeeded\n");
                }
                else
                {
                    wprintf(L"The signature failed to be created.  hr=%#08lx\n", hr);
                }
            }
        }
        else
        {
            if (!g_fQuietRun)
            {
                wprintf(L"The file was already signed and the signature is still valid.");
            }
        }
        break;
    case opCheckSignature:
        hr = CheckThemeFileSignature(pszInputDir);
        if (!g_fQuietRun)
        {
            if (SUCCEEDED(hr))
            {
                wprintf(L"The signature is valid\n");
            }
            else
            {
                wprintf(L"The signature is not valid.  hr=%#08lx\n", hr);
            }
        }
        break;
    case opParse:
        hr = ParseTheme(pszInputDir);
        if (FAILED(hr))
        {
            ReportError(hr, L"Error during parsing");
            goto exit;
        } else
        {
            wprintf(L"No errors parsing theme file\n");
        }
        break;
    case opColorShift:
        hr = ColorShift(szOutputName, ARRAYSIZE(szOutputName));
        break;

    default:
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto exit;
        }
        break;
    };

    retval = 0;     // all OK

exit:
    UtilsShutDown();
    LogShutDown();

    return retval;
}
//---------------------------------------------------------------------------
HRESULT LoadClassDataIni(HINSTANCE hInst, LPCWSTR pszColorName,
    LPCWSTR pszSizeName, LPWSTR pszFoundIniName, DWORD dwMaxIniNameChars, LPWSTR *ppIniData)
{
    COLORSIZECOMBOS *combos;
    HRESULT hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        return hr;

    int iSizeIndex = 0;
    int iColorIndex = 0;

    if ((pszColorName) && (* pszColorName))
    {
        hr = GetColorSchemeIndex(hInst, pszColorName, &iColorIndex);
        if (FAILED(hr))
            return hr;
    }

    if ((pszSizeName) && (* pszSizeName))
    {
        hr = GetSizeIndex(hInst, pszSizeName, &iSizeIndex);
        if (FAILED(hr))
            return hr;
    }

    int filenum = COMBOENTRY(combos, iColorIndex, iSizeIndex);
    if (filenum == -1)
        return MakeError32(ERROR_NOT_FOUND);

    //---- locate resname for classdata file "filenum" ----
    hr = GetResString(hInst, L"FILERESNAMES", filenum, pszFoundIniName, dwMaxIniNameChars);
    if (SUCCEEDED(hr))
    {
        hr = AllocateTextResource(hInst, pszFoundIniName, ppIniData);
    }

    return hr;
}
//---------------------------------------------------------------------------
// Parse the theme to detect localization errors
HRESULT ParseTheme(LPCWSTR pszThemeName)
{
    // Dummy callback class needed by the parser
    class CParserCallBack: public IParserCallBack
    {
        HRESULT AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
            int iPartNum, int iStateNum, int iIndex, int iLen) { return S_OK; };
        HRESULT AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen) { return S_OK; };
        int GetNextDataIndex() { return 0; };
    };

    CParserCallBack *pParserCallBack = NULL;
    CThemeParser *pParser = NULL;

    HRESULT hr;
    HINSTANCE hInst = NULL;
    WCHAR *pDataIni = NULL;
    WCHAR szClassDataName[_MAX_PATH+1];

    //---- load the Color Scheme from "themes.ini" ----
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;
    
    pParser = new CThemeParser(FALSE);
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    pParserCallBack = new CParserCallBack;
    if (!pParserCallBack)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    THEMENAMEINFO tniColors;
    THEMENAMEINFO tniSizes;

    for (DWORD c = 0; ; c++)
    {
        if (FAILED(_EnumThemeColors(hInst, pszThemeName, NULL, c, &tniColors, FALSE)))
            break;

        for (DWORD s = 0 ; ; s++)
        {
            if (FAILED(_EnumThemeSizes(hInst, pszThemeName, tniColors.szName, s, &tniSizes, FALSE)))
                break;

            //---- load the classdata file resource into memory ----
            hr = LoadClassDataIni(hInst, tniColors.szName, tniSizes.szName, szClassDataName, ARRAYSIZE(szClassDataName), &pDataIni);
            if (FAILED(hr))
                goto exit;

            //---- parse & build binary theme ----
            hr = pParser->ParseThemeBuffer(pDataIni, szClassDataName, NULL, hInst, 
                pParserCallBack, FnCallBack, NULL, PTF_CLASSDATA_PARSE);
            if (FAILED(hr))
                goto exit;

            if (pDataIni)
            {
                delete [] pDataIni;
                pDataIni = NULL;
            }
        }
    }

exit:

    if (hInst)
        FreeLibrary(hInst);
    
    if (pDataIni)
        delete [] pDataIni;

    if (pParser)
        delete pParser;

    if (pParserCallBack)
        delete pParserCallBack;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\packthem\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PackThem.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\packthem\localsign.h ===
/*****************************************************************************\
    FILE: localsign.h

    DESCRIPTION:
        This code will sign and verify the signature of a Visual Style file.

    BryanSt 8/1/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef PACKTHEM_SIGNING_H
#define PACKTHEM_SIGNING_H

#include <utils.h>
#include <shlwapip.h>
#include "localsign.h"
#include "..\inc\signing.h"



HRESULT SignTheme(IN LPCWSTR pszFileName, int nWeek);
HRESULT CheckSignatureThemeInternal(IN LPCWSTR pszFileName);
HRESULT GenerateKeys(IN LPCWSTR pszFileName);

/*****************************************************************************\
    WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING

    Do NOT let this private key be included in anything except packthem.exe

    WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING

    You can create new key pairs by running "packthem.exe -g gofaster"
\*****************************************************************************/

const BYTE s_keyPrivate1[]    =   //  Private Key: #1
{
    0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x32, 0x00,
    0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x73, 0xAA, 0xFD, 0xFE, 0x2E, 0x34,
    0x75, 0x3B, 0xC2, 0x20, 0x72, 0xFC, 0x50, 0xCC, 0xD4, 0xE0, 0xDE, 0xC7, 0xA6,
    0x46, 0xC6, 0xDC, 0xE6, 0x6B, 0xF0, 0x58, 0x11, 0x88, 0x66, 0x54, 0x5F, 0x3D,
    0x81, 0x8C, 0xEF, 0x5F, 0x89, 0x51, 0xE4, 0x9C, 0x3F, 0x57, 0xA6, 0x22, 0xA9,
    0xE7, 0x0F, 0x4B, 0x56, 0x81, 0xD1, 0xA6, 0xBA, 0x24, 0xFF, 0x93, 0x17, 0xFE,
    0x64, 0xEF, 0xE5, 0x11, 0x90, 0x00, 0xDC, 0x37, 0xC2, 0x84, 0xEE, 0x7B, 0x12,
    0x43, 0xA4, 0xAF, 0xC3, 0x69, 0x57, 0xD1, 0x92, 0x96, 0x8E, 0x55, 0x0F, 0xE1,
    0xCD, 0x0F, 0xAE, 0xEA, 0xE8, 0x01, 0x83, 0x65, 0x32, 0xF1, 0x80, 0xDB, 0x08,
    0xD6, 0x01, 0x84, 0xB1, 0x09, 0x80, 0x3C, 0x27, 0x83, 0x9F, 0x16, 0x92, 0x86,
    0x4C, 0x8E, 0x15, 0xC7, 0x94, 0xE4, 0x27, 0xFF, 0x2B, 0xA4, 0x28, 0xDE, 0x9C,
    0x43, 0x5B, 0x5E, 0x14, 0xB6, 0x5D, 0x33, 0x83, 0x8F, 0x62, 0x33, 0xAE, 0x99,
    0x1F, 0xA3, 0xE3, 0x41, 0xC9, 0x46, 0x76, 0xAA, 0x93, 0x74, 0x5A, 0xCA, 0x0D,
    0xEE, 0xCA, 0x84, 0xF5, 0xF6, 0xA4, 0x70, 0xD8, 0x5D, 0x58, 0x7B, 0xA2, 0xD3,
    0x74, 0x57, 0xF0, 0x04, 0x05, 0xBE, 0xF0, 0x3C, 0xBB, 0xAB, 0x8E, 0x2C, 0x70,
    0xDC, 0x5B, 0x0C, 0x6E, 0x10, 0xC7, 0x75, 0xA4, 0x8F, 0x87, 0xDF, 0x20, 0x62,
    0x26, 0xAF, 0xC8, 0xE5, 0x0F, 0xC8, 0x11, 0x91, 0xAC, 0xC3, 0x00, 0x1D, 0x05,
    0x07, 0xB6, 0x1D, 0xB7, 0x9E, 0x7B, 0xB8, 0xE1, 0x20, 0x1B, 0x9D, 0xCB, 0x68,
    0xA5, 0x4C, 0x8F, 0x4E, 0x70, 0xCC, 0x2E, 0xF0, 0x71, 0xE8, 0x13, 0xF4, 0x58,
    0xA8, 0x60, 0x2E, 0x23, 0x13, 0x13, 0x60, 0x4C, 0xC5, 0xBC, 0x80, 0xC3, 0xA5,
    0x84, 0xA1, 0x25, 0xD4, 0x69, 0x31, 0x28, 0xEE, 0x38, 0xD1, 0x04, 0x5A, 0x36,
    0x61, 0xDA, 0xCA, 0xC5, 0x18, 0xB7, 0xAF, 0xE9, 0x69, 0xD3, 0xC1, 0x9C, 0x8B,
    0xB2, 0x53, 0xB1, 0x85, 0xDA, 0x2C, 0xBF, 0xDA, 0xB9, 0xBD, 0x8B, 0xCE, 0x1D,
    0x62, 0x8D, 0x49, 0x61, 0x70, 0xC3, 0x9D, 0x68, 0xBB, 0xA9, 0xBF, 0x66, 0x3B,
    0x87, 0x49, 0x8F, 0x98, 0xF4, 0x32, 0x68, 0xCB, 0xE4, 0xB7, 0x5B, 0xFF, 0xB4,
    0xA2, 0x77, 0xF4, 0x4F, 0xA7, 0xCA, 0x6C, 0xDD, 0x34, 0x69, 0xE8, 0xA1, 0x1C,
    0x37, 0x8C, 0x67, 0x7B, 0x87, 0xEC, 0x96, 0x48, 0x6C, 0x95, 0xA9, 0xDF, 0x8E,
    0xDE, 0xFB, 0x7D, 0x43, 0xEE, 0x6B, 0x29, 0x4B, 0x1D, 0x47, 0x9B, 0x2B, 0xA7,
    0x0C, 0x3E, 0xC