      while (pwndT && pdesk == pwndT->head.rpdesk) {
            if (pwndT == pdesk->spwndMessage) {
                return FALSE;
            }
            pwndT = pwndT->spwndParent;
        }
    }

    return TRUE;
}


/***************************************************************************\
* SetTiledRect
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
VOID SetTiledRect(
    PWND        pwnd,
    LPRECT      lprc,
    PMONITOR    pMonitor)
{
    POINT   pt;
    RECT    rcT;

    UserAssert(pMonitor->cWndStack >= 0);

    /*
     * Get available desktop area, minus minimized spacing area.
     */
    GetRealClientRect(PWNDDESKTOP(pwnd), &rcT, GRC_MINWNDS, pMonitor);

    /*
     * Increment the count of stacked windows.
     */
    pMonitor->cWndStack++;
    /*
     * We want the left edge of the new window to align with the
     * right edge of the old window's system menu. And we want the
     * top edge of the new window to align with the bottom edge of the
     * selected caption area (caption height - cyBorder) of the old
     * window.
     */
#define X_TILED (SYSMET(CXSIZEFRAME) + SYSMET(CXSIZE))
#define Y_TILED (SYSMET(CYSIZEFRAME) + SYSMET(CYSIZE))

    pt.x = pMonitor->cWndStack * X_TILED;
    pt.y = pMonitor->cWndStack * Y_TILED;

    /*
     * If below upper top left 1/4 of free area, reset.
     */
    if (    (pt.x > ((rcT.right-rcT.left) / 4)) ||
            (pt.y > ((rcT.bottom-rcT.top) / 4)) ) {

        pMonitor->cWndStack = 0;
        pt.x = X_TILED;
        pt.y = Y_TILED;
    }

#undef X_TILED
#undef Y_TILED
    /*
     * Get starting position
     */
    pt.x += rcT.left;
    pt.y += rcT.top;

    lprc->left      = pt.x;
    lprc->top       = pt.y;
    lprc->right     = pt.x + MultDiv(rcT.right-rcT.left, 3, 4);
    lprc->bottom    = pt.y + MultDiv(rcT.bottom-rcT.top, 3, 4);

}


/***************************************************************************\
* xxxAdjustSize
*
* Make sure that *lpcx and *lpcy are within the legal limits.
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
VOID xxxAdjustSize(
    PWND pwnd,
    LPINT lpcx,
    LPINT lpcy)
{
    POINT ptmin, ptmax;
    MINMAXINFO mmi;

    CheckLock(pwnd);

    /*
     * If this window is sizeable or if this window is tiled, check size.
     */
    if (TestwndTiled(pwnd) || TestWF(pwnd, WFSIZEBOX)) {
        /*
         * Get size info from pwnd.
         */
        xxxInitSendValidateMinMaxInfo(pwnd, &mmi);

        if (TestWF(pwnd, WFMINIMIZED)) {
            ptmin = mmi.ptReserved;
            ptmax = mmi.ptMaxSize;
        } else {
            ptmin = mmi.ptMinTrackSize;
            ptmax = mmi.ptMaxTrackSize;
        }

        //
        // Make sure we're less than the max, and greater than the min
        //
        *lpcx = max(ptmin.x, min(*lpcx, ptmax.x));
        *lpcy = max(ptmin.y, min(*lpcy, ptmax.y));
    }
}

#if DBG
/***************************************************************************\
* VerifyWindowLink
*
* History:
* 10/28/96 GerardoB     Added
\***************************************************************************/
VOID VerifyWindowLink(
    PWND pwnd,
    PWND pwndParent,
    BOOL fLink)
{
    BOOL fFirstFound = FALSE;
    BOOL fInFound = FALSE;
    PWND pwndNext = pwndParent->spwndChild;
    PWND pwndFirst = pwndNext;

    while (pwndNext != NULL) {
        if (pwndFirst == pwndNext) {
            if (fFirstFound) {
                RIPMSG1(RIP_ERROR, "Loop in %#p spwndNext chain", pwnd);
                return;
            } else {
                fFirstFound = TRUE;
            }
        }

        if (pwndNext == pwnd) fInFound = TRUE;
        pwndNext = pwndNext->spwndNext;
    }

    if (fLink && !fInFound) {
        RIPMSG1(RIP_ERROR, "pwnd 0x%p not found in spwndNext chain", pwnd);
    }
}
#endif

/***************************************************************************\
* LinkWindow
*
* History:
\***************************************************************************/
VOID LinkWindow(
    PWND pwnd,
    PWND pwndInsert,
    PWND pwndParent)
{
    if (pwndParent->spwndChild == pwnd) {
        RIPMSG0(RIP_WARNING, "Attempting to link a window to itself");
        return;
    }

    UserAssert(pwnd != pwndInsert);
    UserAssert((pwnd->spwndParent == NULL) || (pwnd->spwndParent == pwndParent));

    if (pwndInsert == PWND_TOP) {

        /*
         * We are at the top of the list.
         */
LinkTop:
#if DBG
        /*
         * If the first child is topmost, so must be pwnd, but only for
         * top-level windows.
         *
         * IME or IME related windows are the exceptions, because ImeSetTopmost
         * and its friends do most of the relinking on its own: When LinkWindow
         * is called, it's possible TOPMOST flags are left in intermediate
         * state. By the time the all window relinking finishes, TOPMOST flags
         * have been taken care of and they are just fine.
         */
        if (pwndParent == PWNDDESKTOP(pwndParent) &&
                pwndParent->spwndChild &&
                FSwpTopmost(pwndParent->spwndChild) &&
                pwndParent != PWNDMESSAGE(pwndParent) &&
                // Check if the target is IME related window
                !TestCF(pwnd, CFIME) && pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]) {

            /*
             * There are few cases that cause the z-ordering code to leave the
             * WFTOGGLETOPMOST bit set. One is when SWP_NOOWNERZORDER is used
             * when changing the topmost state of a window; in this case,
             * ZOrderByOwner2 doesn't add ownees to the psmwp list, still
             * SetTopMost sets the bit on all the ownees.
             *
             * Another case is when SetWindowPos gets re-entered on the same
             * window. It's too late to attempt to fix this ancient behavior
             * (2/24/99) so let's turn off the assert for now.
             */
            if (!FSwpTopmost(pwnd)) {
                RIPMSG1(RIP_WARNING, "LinkWindow pwnd:%p is not FSwpTopmost", pwnd);
            }
        }
#endif // DBG

        if (pwndParent->spwndChild != NULL) {
            Lock(&pwndParent->spwndChild->spwndPrev, pwnd);
            Lock(&pwnd->spwndNext, pwndParent->spwndChild);
        }
        Lock(&(pwndParent->spwndChild), pwnd);
        UserAssert(pwnd->spwndPrev == NULL);
    } else {
        if (pwndInsert == PWND_BOTTOM) {

            /*
             * Find bottom-most window.
             */
            if (((pwndInsert = pwndParent->spwndChild) == NULL) ||
                TestWF(pwndInsert, WFBOTTOMMOST))
                goto LinkTop;

            /*
             * Since we know (ahem) that there's only one bottommost window,
             * we can't possibly insert after it. Either we're inserting
             * the bottomost window, in which case it's not in the linked
             * list currently, or we're inserting some other window.
             */

            while (pwndInsert->spwndNext != NULL) {
                if (TestWF(pwndInsert->spwndNext, WFBOTTOMMOST)) {
#if DBG
                    UserAssert(pwnd != pwndInsert->spwndNext);
                    if (TestWF(pwnd, WFBOTTOMMOST))
                        UserAssert(FALSE);
#endif
                    break;
                }

                pwndInsert = pwndInsert->spwndNext;
            }
        }

        UserAssert(pwnd != pwndInsert);
        UserAssert(pwnd != pwndInsert->spwndNext);
        UserAssert(!TestWF(pwndInsert, WFDESTROYED));
        UserAssert(TestWF(pwnd, WFCHILD) || !TestWF(pwnd, WEFTOPMOST) || TestWF(pwndInsert, WEFTOPMOST) || TestWF(pwnd, WFTOGGLETOPMOST) || (pwndParent != PWNDDESKTOP(pwndInsert)));
        UserAssert(pwnd->spwndParent == pwndInsert->spwndParent);

        if (pwndInsert->spwndNext != NULL) {
            Lock(&pwndInsert->spwndNext->spwndPrev, pwnd);
            Lock(&pwnd->spwndNext, pwndInsert->spwndNext);
        }
        Lock(&pwnd->spwndPrev, pwndInsert);
        Lock(&pwndInsert->spwndNext, pwnd);
    }

    if (TestWF(pwnd, WEFLAYERED))
        TrackLayeredZorder(pwnd);

#if DBG
    VerifyWindowLink (pwnd, pwndParent, TRUE);
#endif

}


/***************************************************************************\
* xxxDestroyWindow (API)
*
* Destroy the specified window. The window passed in is not thread locked.
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 02-07-91 DavidPe      Added Win 3.1 WH_CBT support.
* 02-11-91 JimA         Added access checks.
\***************************************************************************/
BOOL xxxDestroyWindow(
    PWND pwnd)
{
    PMENUSTATE  pMenuState, pmnsEnd;
    PTHREADINFO pti = PtiCurrent();
    TL tlpwnd, tlpwndFocus, tlpwndParent;
    PWND pwndFocus;
    BOOL fAlreadyDestroyed;
    DWORD dwDisableHooks;

    dwDisableHooks = 0;
    ThreadLockWithPti(pti, pwnd, &tlpwnd);

    /*
     * First, if this handle has been marked for destruction, that means it
     * is possible that the current thread is not its owner! (meaning we're
     * being called from a handle unlock call). In this case, set the owner
     * to be the current thread so inter-thread send messages occur.
     */
    fAlreadyDestroyed = HMIsMarkDestroy(pwnd);
    if (fAlreadyDestroyed) {
        /*
         * UserAssert(dwInAtomicOperation > 0);
         * This Assert ensures that we are here only because of an unlock
         * on a previously destroyed window. We BEGIN/ENDATOMICHCHECK in
         * HMDestroyUnlockedObject to ensure we don't leave the crit sect
         * unexpectedly, which gives us dwInAtomicCheck > 0. We set
         * TIF_DISABLEHOOKS to prevent a callback in Unlock
         * However, it is currently possible destroy the same window handle
         * twice, since we don't (yet) fail to revalidate zombie handles:
         * GerardoB may change this, at which time we should probably restore
         * this Assert, and test #76902 (close winmsd.exe) again. (preventing
         * hooks in a second destroy of a zombie window should be OK) - IanJa
         */
        // UserAssert(dwInAtomicOperation > 0);

        if (HMPheFromObject(pwnd)->pOwner != pti) {
            UserAssert(PsGetCurrentThreadWin32Thread());
            HMChangeOwnerThread(pwnd, pti);
        }
        dwDisableHooks = pti->TIF_flags & TIF_DISABLEHOOKS;
        pti->TIF_flags |= TIF_DISABLEHOOKS;
    } else {
        /*
         * Ensure that we can destroy the window. JIMA: no other process or thread
         * should be able to destroy any other process or thread's window.
         */
        if (pti != GETPTI(pwnd)) {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_WARNING,
                    "Access denied in xxxDestroyWindow");

            goto FalseReturn;
        }
    }

    /*
     * First ask the CBT hook if we can destroy this window.
     * If this object has already been destroyed OR this thread is currently
     * in cleanup mode, *do not* make any callbacks via hooks to the client
     * process.
     */
    if (!fAlreadyDestroyed && !(pti->TIF_flags & TIF_INCLEANUP) &&
            IsHooked(pti, WHF_CBT)) {
        if (xxxCallHook(HCBT_DESTROYWND, (WPARAM)HWq(pwnd), 0, WH_CBT)) {
            goto FalseReturn;
        }
    }

    /*
     * If the window we are destroying is in menu mode, end the menu
     */
    pMenuState = GetpMenuState(pwnd);
    if ((pMenuState != NULL)
            && (pwnd == pMenuState->pGlobalPopupMenu->spwndNotify)) {

        MNEndMenuStateNotify(pMenuState);
        /*
         * Signal all states to end. The window(s) will be unlocked when
         *  the menu exits; we cannot unlock it now because the menu
         *  code could fault.
         */
        pmnsEnd = pMenuState;
        do {
            UserAssert(pwnd == pMenuState->pGlobalPopupMenu->spwndNotify);
            pMenuState->fInsideMenuLoop = FALSE;
            pMenuState = pMenuState->pmnsPrev;
        } while (pMenuState != NULL) ;

        /*
         * All states have been signaled to exit, so once we callback
         *  we cannot count on pmnsEnd->pmnsPrev to be valid. Thus
         *  we simply end the current menu here and let the others go
         *  on their own. No state points to pwnd anymore so that
         *  should be OK.
         */
        if (!pmnsEnd->fModelessMenu) {
            xxxEndMenu(pmnsEnd);
        }
    }

    if (ghwndSwitch == HWq(pwnd)) {
        ghwndSwitch = NULL;
    }

    if (!TestWF(pwnd, WFCHILD) && (pwnd->spwndOwner == NULL)) {
        if (TestWF(pwnd, WFHASPALETTE)) {
            xxxFlushPalette(pwnd);
        }
    }

    /*
     * Disassociate thread state if this is top level and owned by a different
     * thread. This is done to begin with so these windows z-order together.
     */
    if (pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME] &&
        !TestwndChild(pwnd) && pwnd->spwndOwner != NULL &&
            GETPTI(pwnd->spwndOwner) != GETPTI(pwnd)) {
        /*
         * No need to zzzDeferWinEventNotify() - there is an xxx call just below
         */
        zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwnd->spwndOwner), FALSE);
    }

    /*
     * If we are a child window without the WS_NOPARENTNOTIFY style, send
     * the appropriate notification message.
     *
     * NOTE: Although it would appear that we are illegally cramming a
     * a WORD (WM_DESTROY) and a DWORD (pwnd->spmenu) into a single LONG
     * (wParam) this isn't really the case because we first test if this
     * is a child window. The pMenu field in a child window is really
     * the window's id and only the LOWORD is significant.
     */
    if (TestWF(pwnd, WFCHILD) && !TestWF(pwnd, WEFNOPARENTNOTIFY) &&
            pwnd->spwndParent != NULL) {

        ThreadLockAlwaysWithPti(pti, pwnd->spwndParent, &tlpwndParent);
        xxxSendMessage(pwnd->spwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd));
        ThreadUnlock(&tlpwndParent);
    }

    /*
     * Mark this window as beginning the destroy process. This is necessary
     * to prevent window-management calls such as ShowWindow or SetWindowPos
     * from coming in and changing the visible-state of the window
     * once we hide it. Otherwise, if the app attempts to make it
     * visible, then we can get our vis-rgns messed up once we truely
     * destroy the window.
     *
     * Don't mark the mother desktop with this bit. The xxxSetWindowPos()
     * will fail for this window, and thus possibly cause an assertion
     * in the xxxFreeWindow() call when we check for the visible-bit.
     */
    if (pwnd->spwndParent && (pwnd->spwndParent->head.rpdesk != NULL)) {
        SetWF(pwnd, WFINDESTROY);
    }

    /*
     * Hide the window.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        if (TestWF(pwnd, WFCHILD)) {
            xxxShowWindow(pwnd, SW_HIDE | TEST_PUDF(PUDF_ANIMATE));
        } else {
            /*
             * Hide this window without activating anyone else.
             */
            xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW |
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER |
                    (fAlreadyDestroyed ? SWP_DEFERDRAWING : 0));
        }

        /*
         * Under low memory conditions, the above attempt to hide could fail.
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            RIPMSG0(RIP_WARNING, "xxxDestroyWindow: normal hide failed");
            SetVisible(pwnd, SV_UNSET);

            /*
             * Invalidate windows below so they redraw properly.
             */
            xxxRedrawWindow(NULL, &pwnd->rcWindow, NULL, RDW_INVALIDATE |
                    RDW_ERASE | RDW_ALLCHILDREN);

        }
    } else if (IsTrayWindow(pwnd)) {
        PostShellHookMessages(HSHELL_WINDOWDESTROYED,
                              (LPARAM)PtoHq( pwnd ));
    }

    /*
     * Destroy any owned windows.
     * [msadek], the check for FNID_GHOST is to fix bug# 380208, 382758
     * where we recieve QEVENT_HUNGTHREAD for the owner window first.
     * since we post the event multiple times (once for each owned window)
     * We are guranteed to go through xxxDestroyWindow for owned windows too.
     */
    if (!TestWF(pwnd, WFCHILD) && (GETFNID(pwnd) != FNID_GHOST)) {
        xxxDW_DestroyOwnedWindows(pwnd);

        /*
         * And remove the window hot-key, if it has one
         */
        DWP_SetHotKey(pwnd, 0);
    }

    /*
     * If the window has already been destroyed, don't muck with
     * activation because we may already be in the middle of
     * an activation event. Changing activation now may cause us
     * to leave our critical section while holding the display lock.
     * This will result in a deadlock if another thread gets the
     * critical section before we do and attempts to lock the
     * display.
     */
    if (!fAlreadyDestroyed) {
        PWND pwndActivate = NULL;
        TL tlpwndActivate;
        UINT cmdActivate;

        /*
         * If hiding the active window, activate someone else.
         * This call is strategically located after DestroyOwnedWindows() so we
         * don't end up activating our owner window.
         *
         * If the window is a popup, try to activate his creator not the top
         * window in the Z list.
         */
        if (pwnd == pti->pq->spwndActive) {
            if (TestWF(pwnd, WFPOPUP) && pwnd->spwndOwner) {
                pwndActivate = pwnd->spwndOwner;
                cmdActivate = AW_TRY;
            } else {
                pwndActivate = pwnd;
                cmdActivate = AW_SKIP;
            }
        } else if ((pti->pq->spwndActive == NULL) && (gpqForeground == pti->pq)) {
            pwndActivate = pwnd;
            cmdActivate = AW_SKIP;
        }

        if (pwndActivate) {
            ThreadLockAlwaysWithPti(pti, pwndActivate, &tlpwndActivate);

            if (!xxxActivateWindow(pwndActivate, cmdActivate) ||
                    ((cmdActivate == AW_SKIP) && (pwnd == pti->pq->spwndActive))) {
                if ((cmdActivate == AW_SKIP) || (pwnd == pti->pq->spwndActive)) {
                    Unlock(&pti->pq->spwndActive);
                    pwndFocus = Unlock(&pti->pq->spwndFocus);
                    if (IS_IME_ENABLED() && pwndFocus != NULL) {
                        ThreadLockAlwaysWithPti(pti, pwndFocus, &tlpwndFocus);
                        xxxFocusSetInputContext(pwndFocus, FALSE, FALSE);
                        ThreadUnlock(&tlpwndFocus);
                    }
                    if (pti->pq == gpqForeground) {
                        xxxWindowEvent(EVENT_OBJECT_FOCUS, NULL, OBJID_CLIENT,
                                INDEXID_CONTAINER, 0);
                        xxxWindowEvent(EVENT_SYSTEM_FOREGROUND, NULL, OBJID_WINDOW,
                                INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
                    }
                    zzzInternalDestroyCaret();
                }
            }

            ThreadUnlock(&tlpwndActivate);
        }
    }

    /*
     * Fix last active popup.
     */
    {
        PWND pwndOwner = pwnd->spwndOwner;

        if (pwndOwner != NULL) {
            while (pwndOwner->spwndOwner != NULL) {
                pwndOwner = pwndOwner->spwndOwner;
            }

            if (pwnd == pwndOwner->spwndLastActive) {
                /*
                 * If pwndOwner is marked for destruction, locking it here
                 * will prevent it from ever being freed, thus preventing
                 * the associated session memory from going away. Just
                 * unlock pwndOwner->spwndLastActive in this case.
                 * [msadek- 03/02/2002]
                 */
                if (HMIsMarkDestroy(pwndOwner)) {
                    Unlock(&pwndOwner->spwndLastActive);
                } else {
                    Lock(&(pwndOwner->spwndLastActive), pwnd->spwndOwner);
                }
            }
        }
    }

    if (!fAlreadyDestroyed) {
        /*
         * Note we do this BEFORE telling the app the window is dying. Note
         * also that we do NOT loop through the children generating DESTROY
         * events. DESTROY of a parent implies DESTROY of all children (see
         * Windows NT Bug #71846).
         */
        if (!TestWF(pwnd, WFDESTROYED)) {
            xxxWindowEvent(EVENT_OBJECT_DESTROY, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);
        }

    /*
     * Send destroy messages before the WindowLockStart in case
     * he tries to destroy windows as a result.
     */
        xxxDW_SendDestroyMessages(pwnd);
    }

    /*
     * Check the owner of IME window again.
     * If thread is destroying, don't bother to check.
     */
    if (IS_IME_ENABLED() && !(pti->TIF_flags & TIF_INCLEANUP) &&
            pti->spwndDefaultIme != NULL &&
            !TestCF(pwnd, CFIME) &&
            pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]) {

        if (fAlreadyDestroyed) {
            RIPMSG2(RIP_VERBOSE,
                    "xxxDestroyWindow: in final destruction of 0x%p, ime=0x%p",
                    pwnd,
                    pti->spwndDefaultIme);
        } else {
            if (!TestWF(pwnd, WFCHILD)) {
                if (ImeCanDestroyDefIME(pti->spwndDefaultIme, pwnd)) {
                    TAGMSG1(DBGTAG_IMM, "xxxDestroyWindow: destroying (1) the default IME window=%p", pti->spwndDefaultIme);
                    xxxDestroyWindow(pti->spwndDefaultIme);
                }
            } else if (pwnd->spwndParent != NULL) {
                if (ImeCanDestroyDefIMEforChild(pti->spwndDefaultIme, pwnd)) {
                    TAGMSG1(DBGTAG_IMM, "xxxDestroyWindow: destroying (2) the default IME window=%p", pti->spwndDefaultIme);
                    xxxDestroyWindow(pti->spwndDefaultIme);
                }
            }
        }
    }

    if ((pwnd->spwndParent != NULL) && !fAlreadyDestroyed) {

        /*
         * TestwndChild() on checks to WFCHILD bit. Make sure this
         * window wasn't SetParent()'ed to the desktop as well.
         */
        if (TestwndChild(pwnd) && (pwnd->spwndParent != PWNDDESKTOP(pwnd)) &&
                (GETPTI(pwnd) != GETPTI(pwnd->spwndParent))) {
            /*
             * pwnd is threadlocked, so no need to DeferWinEventNotify()
             */
            CheckLock(pwnd);
            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwnd->spwndParent), FALSE);
        }

        UnlinkWindow(pwnd, pwnd->spwndParent);
    }

    /*
     * This in intended to check for a case where we destroy the window,
     * but it's still listed as the active-window in the queue. This
     * could cause problems in window-activation (see xxxActivateThisWindow)
     * where we attempt to activate another window and in the process, try
     * to deactivate this window (bad).
     */
#if DBG
    if (pwnd == pti->pq->spwndActive) {
        RIPMSG1(RIP_WARNING, "xxxDestroyWindow: pwnd == pti->pq->spwndActive (%#p)", pwnd);
    }
#endif

    /*
     * Set the state as destroyed so any z-ordering events will be ignored.
     * We cannot NULL out the owner field until WM_NCDESTROY is send or
     * apps like Rumba fault  (they call GetParent after every message)
     */
    SetWF(pwnd, WFDESTROYED);

    /*
     * FreeWindow performs a ThreadUnlock.
     */
    xxxFreeWindow(pwnd, &tlpwnd);

    if (fAlreadyDestroyed) {
        pti->TIF_flags = (pti->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
    }
    return TRUE;

FalseReturn:
    if (fAlreadyDestroyed) {
        pti->TIF_flags = (pti->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
    }
    ThreadUnlock(&tlpwnd);
    return FALSE;
}


/***************************************************************************\
* xxxDW_DestroyOwnedWindows
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 07-22-91 darrinm      Re-ported from Win 3.1 sources.
\***************************************************************************/
VOID xxxDW_DestroyOwnedWindows(
    PWND pwndParent)
{
    PWND pwnd, pwndDesktop;
    PDESKTOP pdeskParent;
    PWND pwndDefaultIme = GETPTI(pwndParent)->spwndDefaultIme;

    CheckLock(pwndParent);

    if ((pdeskParent = pwndParent->head.rpdesk) == NULL)
        return;
    pwndDesktop = pdeskParent->pDeskInfo->spwnd;

    /*
     * During shutdown, the desktop owner window will be
     * destroyed. In this case, pwndDesktop will be NULL.
     */
    if (pwndDesktop == NULL)
        return;

    pwnd = pwndDesktop->spwndChild;

    while (pwnd != NULL) {
        if (pwnd->spwndOwner == pwndParent) {
            /*
             * We don't destroy the IME window here
             * unless the thread is doing cleanup.
             */
            if (IS_IME_ENABLED() && !(GETPTI(pwndParent)->TIF_flags & TIF_INCLEANUP) &&
                    pwnd == pwndDefaultIme) {
                Unlock(&pwnd->spwndOwner);
                pwnd = pwnd->spwndNext;
                continue;
            }

            /*
             * If the window doesn't get destroyed, set its owner to NULL.
             * A good example of this is trying to destroy a window created
             * by another thread or process, but there are other cases.
             */
            if (!xxxDestroyWindow(pwnd)) {
                Unlock(&pwnd->spwndOwner);
            }

            /*
             * Start the search over from the beginning since the app could
             * have caused other windows to be created or activation/z-order
             * changes.
             */
            pwnd = pwndDesktop->spwndChild;
        } else {
            pwnd = pwnd->spwndNext;
        }
    }
}


/***************************************************************************\
* xxxDW_SendDestroyMessages
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
VOID xxxDW_SendDestroyMessages(
    PWND pwnd)
{
    PWND pwndChild;
    PWND pwndNext;
    TL tlpwndNext;
    TL tlpwndChild;
    PWINDOWSTATION pwinsta;

    CheckLock(pwnd);

    /*
     * Be sure the window gets any resulting messages before being destroyed.
     */
    xxxCheckFocus(pwnd);

    pwinsta = _GetProcessWindowStation(NULL);
    if (pwinsta != NULL && pwnd == pwinsta->spwndClipOwner) {
        /*
         * Pass along the pwnd which is the reason we are dismissing the
         * clipboard. We want to later make sure the owner is still this
         * window after we make callbacks and clear the owner
         */
        xxxDisownClipboard(pwnd);
    }

    /*
     * Send the WM_DESTROY message.
     */
#if _DBG
    if (pwnd == PtiCurrent()->spwndDefaultIme) {
        TAGMSG2(DBGTAG_IMM, "xxxDW_SendDestroyMessages: sending WM_DESTROY message to def IME=%p, pti=%p", pwnd, PtiCurrent());
    }
#endif
    xxxSendMessage(pwnd, WM_DESTROY, 0L, 0L);

    /*
     * Now send destroy message to all children of pwnd.
     * Enumerate down (pwnd->spwndChild) and sideways (pwnd->spwndNext).
     * We do it this way because parents often assume that child windows still
     * exist during WM_DESTROY message processing.
     */
    pwndChild = pwnd->spwndChild;

    while (pwndChild != NULL) {

        pwndNext = pwndChild->spwndNext;

        ThreadLock(pwndNext, &tlpwndNext);

        ThreadLockAlways(pwndChild, &tlpwndChild);
        xxxDW_SendDestroyMessages(pwndChild);
        ThreadUnlock(&tlpwndChild);
        pwndChild = pwndNext;

        /*
         * The unlock may nuke the next window. If so, get out.
         */
        if (!ThreadUnlock(&tlpwndNext))
            break;
    }

    xxxCheckFocus(pwnd);
}


/***************************************************************************\
* xxxFW_DestroyAllChildren
*
* History:
* 11-06-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
VOID xxxFW_DestroyAllChildren(
    PWND pwnd)
{
    PWND pwndChild;
    TL tlpwndChild;
    PTHREADINFO pti;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);

    while (pwnd->spwndChild != NULL) {
        pwndChild = pwnd->spwndChild;

        /*
         * ThreadLock prior to the unlink in case pwndChild
         * is already marked as destroyed.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, pwndChild, &tlpwndChild);

        /*
         * Propagate the VISIBLE flag. We need to do this so that
         * when a child window gets destroyed we don't try to hide it
         * if the WFVISIBLE flag is set.
         */
        if (TestWF(pwndChild, WFVISIBLE)) {
            SetVisible(pwndChild, SV_UNSET);
        }

        UnlinkWindow(pwndChild, pwnd);

        /*
         * Set the state as destroyed so any z-ordering events will be ignored.
         * We cannot NULL out the owner field until WM_NCDESTROY is send or
         * apps like Rumba fault  (they call GetParent after every message)
         */
        SetWF(pwndChild, WFDESTROYED);

        /*
         * If the window belongs to another thread, post
         * an event to let it know it should be destroyed.
         * Otherwise, free the window.
         */
        pti = GETPTI(pwndChild);
        if (pti != ptiCurrent) {
            PostEventMessage(pti, pti->pq, QEVENT_DESTROYWINDOW,
                             NULL, 0,
                             (WPARAM)HWq(pwndChild), 0);
            ThreadUnlock(&tlpwndChild);
        } else {
            /*
             * FreeWindow performs a ThreadUnlock.
             */
            xxxFreeWindow(pwndChild, &tlpwndChild);
        }
    }
}

/***************************************************************************\
* UnlockNotifyWindow
*
* Walk down a menu and unlock all notify windows.
*
* History:
* 18-May-1994 JimA      Created.
\***************************************************************************/
VOID UnlockNotifyWindow(
    PMENU pmenu)
{
    PITEM pItem;
    int   i;

    /*
     * Go down the item list and unlock submenus.
     */
    pItem = pmenu->rgItems;
    for (i = pmenu->cItems; i--; ++pItem) {

        if (pItem->spSubMenu != NULL)
            UnlockNotifyWindow(pItem->spSubMenu);
    }

    Unlock(&pmenu->spwndNotify);
}

/***************************************************************************\
* xxxFreeWindow
*
* History:
* 19-Oct-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/
VOID xxxFreeWindow(
    PWND pwnd,
    PTL  ptlpwndFree)
{
    PDCE           *ppdce;
    PDCE           pdce;
    UINT           uDCERelease;
    PMENU          pmenu;
    PQMSG          pqmsg;
    PPCLS          ppcls;
    WORD           fnid;
    TL             tlpdesk;
    PWINDOWSTATION pwinsta = _GetProcessWindowStation(NULL);
    PTHREADINFO    pti  = PtiCurrent();
    PPROCESSINFO   ppi;
    PMONITOR       pMonitor;
    TL             tlpMonitor;

    UNREFERENCED_PARAMETER(ptlpwndFree);

    CheckLock(pwnd);

    /*
     * If the pwnd is any of the global shell-related windows,
     * then we need to unlock them from the deskinfo.
     */
    if (pwnd->head.rpdesk != NULL) {
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndShell)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndShell);
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndBkGnd)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndBkGnd);
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndTaskman)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndTaskman);
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndProgman)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndProgman);
        if (TestWF(pwnd,WFSHELLHOOKWND)) {
            _DeregisterShellHookWindow(pwnd);
        }

        if (TestWF(pwnd, WFMSGBOX)) {
            pwnd->head.rpdesk->pDeskInfo->cntMBox--;
            ClrWF(pwnd, WFMSGBOX);
        }
    }

    /*
     * First, if this handle has been marked for destruction, that means it
     * is possible that the current thread is not its owner! (meaning we're
     * being called from a handle unlock call). In this case, set the owner
     * to be the current thread so inter-thread send messages don't occur.
     */
    if (HMIsMarkDestroy(pwnd))
        HMChangeOwnerThread(pwnd, pti);

    /*
     * Blow away the children.
     *
     * DestroyAllChildren() will still destroy windows created by other
     * threads! This needs to be looked at more closely: the ultimate
     * "right" thing to do is not to destroy these windows but just
     * unlink them.
     */
    xxxFW_DestroyAllChildren(pwnd);
    xxxSendMessage(pwnd, WM_NCDESTROY, 0, 0L);

    pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
    ThreadLockAlwaysWithPti(pti, pMonitor, &tlpMonitor);
    xxxRemoveFullScreen(pwnd, pMonitor);
    ThreadUnlock(&tlpMonitor);

    /*
     * If this is one of the built in controls which hasn't been cleaned
     * up yet, do it now. If it lives in the kernel, call the function
     * directly, otherwise call back to the client. Even if the control
     * is sub- or super-classed, use the window procs associated with
     * the function id.
     */
    fnid = GETFNID(pwnd);
    if ((fnid >= FNID_WNDPROCSTART) && !(pwnd->fnid & FNID_CLEANEDUP_BIT)) {

       if (fnid <= FNID_WNDPROCEND) {

           FNID(fnid)(pwnd, WM_FINALDESTROY, 0, 0, 0);

       } else if (fnid <= FNID_CONTROLEND && !(pti->TIF_flags & TIF_INCLEANUP)) {

           CallClientWorkerProc(pwnd,
                                    WM_FINALDESTROY,
                                    0,
                                    0,
                                    (PROC)FNID_TO_CLIENT_PFNWORKER(fnid));
       }

       pwnd->fnid |= FNID_CLEANEDUP_BIT;
    }

    pwnd->fnid |= FNID_DELETED_BIT;

    /*
     * Check to clear the most recently active window in owned list.
     */
    if (pwnd->spwndOwner && (pwnd->spwndOwner->spwndLastActive == pwnd)) {
        Lock(&(pwnd->spwndOwner->spwndLastActive), pwnd->spwndOwner);
    }

    /*
     * The windowstation may be NULL if we are destroying a desktop
     * or windowstation. If this is the case, this thread will not
     * be using the clipboard.
     */
    if (pwinsta != NULL) {

        if (pwnd == pwinsta->spwndClipOpen) {
            Unlock(&pwinsta->spwndClipOpen);
            pwinsta->ptiClipLock = NULL;
        }

        if (pwnd == pwinsta->spwndClipViewer) {
            Unlock(&pwinsta->spwndClipViewer);
        }
    }

    if (IS_IME_ENABLED() && pwnd == pti->spwndDefaultIme)
        Unlock(&pti->spwndDefaultIme);

    if (pwnd == pti->pq->spwndFocus)
        Unlock(&pti->pq->spwndFocus);

    if (pwnd == pti->pq->spwndActivePrev)
        Unlock(&pti->pq->spwndActivePrev);

    if (pwnd == gspwndActivate)
        Unlock(&gspwndActivate);

    if (pwnd->head.rpdesk != NULL) {

        if (pwnd == pwnd->head.rpdesk->spwndForeground)
            Unlock(&pwnd->head.rpdesk->spwndForeground);

        if (pwnd == pwnd->head.rpdesk->spwndTray)
            Unlock(&pwnd->head.rpdesk->spwndTray);

        if (pwnd == pwnd->head.rpdesk->spwndTrack) {
            /*
             * Remove tooltip, if any
             */
            if (GETPDESK(pwnd)->dwDTFlags & DF_TOOLTIPSHOWING) {
                PWND pwndTooltip = GETPDESK(pwnd)->spwndTooltip;
                TL tlpwndTooltip;

                ThreadLockAlways(pwndTooltip, &tlpwndTooltip);
                xxxResetTooltip((PTOOLTIPWND)pwndTooltip);
                ThreadUnlock(&tlpwndTooltip);
            }

            Unlock(&pwnd->head.rpdesk->spwndTrack);
            pwnd->head.rpdesk->dwDTFlags &= ~DF_MOUSEMOVETRK;
        }
    }

    if (pwnd == pti->pq->spwndCapture)
        xxxReleaseCapture();

    if (FAnyShadows()) {
        if (TestCF(pwnd, CFDROPSHADOW)) {
            xxxRemoveShadow(pwnd);
        } else if (pwnd->pcls->atomClassName == gatomShadow) {
            CleanupShadow(pwnd);
        }
    }

    /*
     * This window won't be needing any more input.
     */
    if (pwnd == gspwndMouseOwner)
        Unlock(&gspwndMouseOwner);

    /*
     * It also won't have any mouse cursors over it.
     */
    if (pwnd == gspwndCursor)
        Unlock(&gspwndCursor);

    DestroyWindowsTimers(pwnd);
    DestroyWindowsHotKeys(pwnd);

    /*
     * Make sure this window has no pending sent messages.
     */
    ClearSendMessages(pwnd);

    /*
     * Remove the associated GDI sprite.
     */
    if (TestWF(pwnd, WEFLAYERED)) {
        UnsetLayeredWindow(pwnd);
    }

    if (TestWF(pwnd, WEFCOMPOSITED)) {
        UnsetRedirectedWindow(pwnd, REDIRECT_COMPOSITED);
    }

#ifdef REDIRECTION
    if (TestWF(pwnd, WEFEXTREDIRECTED)) {
        UnsetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
    }
#endif // REDIRECTION

    /*
     * Blow away any update region lying around.
     */
    if (NEEDSPAINT(pwnd)) {

        DecPaintCount(pwnd);

        DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);
        pwnd->hrgnUpdate = NULL;
        ClrWF(pwnd, WFINTERNALPAINT);
    }

    /*
     * Decrememt queue's syncpaint count if necessary.
     */
    if (NEEDSSYNCPAINT(pwnd)) {
        ClrWF(pwnd, WFSENDNCPAINT);
        ClrWF(pwnd, WFSENDERASEBKGND);
    }

    /*
     * Clear both flags to ensure that the window is removed
     * from the hung redraw list.
     */
    ClearHungFlag(pwnd, WFREDRAWIFHUNG);
    ClearHungFlag(pwnd, WFREDRAWFRAMEIFHUNG);

    /*
     * If there is a WM_QUIT message in this app's message queue, call
     * PostQuitMessage() (this happens if the app posts itself a quit message.
     * WinEdit2.0 posts a quit to a window while receiving the WM_DESTROY
     * for that window - it works because we need to do a PostQuitMessage()
     * automatically for this thread.
     */
    if (pti->mlPost.pqmsgRead != NULL) {

        /*
         * try to get rid of WM_DDE_ACK too.
         */
        if ((pqmsg = FindQMsg(pti,
                              &(pti->mlPost),
                              pwnd,
                              WM_QUIT,
                              WM_QUIT, TRUE)) != NULL) {

            _PostQuitMessage((int)pqmsg->msg.wParam);
        }
    }

    if (!TestwndChild(pwnd) && pwnd->spmenu != NULL) {
        pmenu = (PMENU)pwnd->spmenu;
        if (UnlockWndMenu(pwnd, &pwnd->spmenu))
            _DestroyMenu(pmenu);
    }

    if (pwnd->spmenuSys != NULL) {
        pmenu = (PMENU)pwnd->spmenuSys;
        if (pmenu != pwnd->head.rpdesk->spmenuDialogSys) {
            if (UnlockWndMenu(pwnd, &pwnd->spmenuSys)) {
                _DestroyMenu(pmenu);
            }
        } else {
            UnlockWndMenu(pwnd, &pwnd->spmenuSys);
        }
    }

    /*
     * If it was using either of the desktop system menus, unlock it
     */
    if (pwnd->head.rpdesk != NULL) {
        if (pwnd->head.rpdesk->spmenuSys != NULL &&
                pwnd == pwnd->head.rpdesk->spmenuSys->spwndNotify) {

            UnlockNotifyWindow(pwnd->head.rpdesk->spmenuSys);
        } else if (pwnd->head.rpdesk->spmenuDialogSys != NULL &&
                pwnd == pwnd->head.rpdesk->spmenuDialogSys->spwndNotify) {

            UnlockNotifyWindow(pwnd->head.rpdesk->spmenuDialogSys);
        }

    }


    /*
     * Tell Gdi that the window is going away.
     */
    if (gcountPWO != 0) {
        PVOID pwo = InternalRemoveProp(pwnd, PROP_WNDOBJ, TRUE);
        if (pwo != NULL) {
            GreLockDisplay(gpDispInfo->hDev);
            GreDeleteWnd(pwo);
            gcountPWO--;
            GreUnlockDisplay(gpDispInfo->hDev);
        }
    }

#ifdef HUNGAPP_GHOSTING

    /*
     * RemoveGhost handles the case when pwnd is the hung window that has a
     * corresponding ghost window and the case when pwnd is the ghost itself.
     */
    RemoveGhost(pwnd);

#endif // HUNGAPP_GHOSTING

    /*
     * Scan the DC cache to find any DC's for this window. If any are there,
     * then invalidate them. We don't need to worry about calling SpbCheckDC
     * because the window has been hidden by this time.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        pdce = *ppdce;
        if (pdce->DCX_flags & DCX_INVALID) {
            goto NextEntry;
        }

        if ((pdce->pwndOrg == pwnd) || (pdce->pwndClip == pwnd)) {

            if (!(pdce->DCX_flags & DCX_CACHE)) {

                if (TestCF(pwnd, CFCLASSDC)) {

                    GreLockDisplay(gpDispInfo->hDev);

                    if (pdce->DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN))
                        DeleteHrgnClip(pdce);

                    MarkDCEInvalid(pdce);
                    pdce->pwndOrg  = NULL;
                    pdce->pwndClip = NULL;
                    pdce->hrgnClip = NULL;

                    /*
                     * Remove the vis rgn since it is still owned - if we did
                     * not, gdi would not be able to clean up properly if the
                     * app that owns this vis rgn exist while the vis rgn is
                     * still selected.
                     */
                    GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);
                    GreUnlockDisplay(gpDispInfo->hDev);

                } else if (TestCF(pwnd, CFOWNDC)) {
                    DestroyCacheDC(ppdce, pdce->hdc);
                } else {
                    UserAssert(FALSE);
                }

            } else {

                /*
                 * If the DC is checked out, release it before
                 * we invalidate. Note, that if this process is exiting
                 * and it has a dc checked out, gdi is going to destroy that
                 * dc. We need to similarly remove that dc from the dc cache.
                 * This is not done here, but in the exiting code.
                 *
                 * The return for ReleaseDC() could fail, which would
                 * indicate a delayed-free (DCE_NUKE).
                 */
                uDCERelease = DCE_RELEASED;

                if (pdce->DCX_flags & DCX_INUSE) {
                    uDCERelease = ReleaseCacheDC(pdce->hdc, FALSE);
                } else if (!GreSetDCOwner(pdce->hdc, OBJECT_OWNER_NONE)) {
                    uDCERelease = DCE_NORELEASE;
                }

                if (uDCERelease != DCE_FREED) {

                    if (uDCERelease == DCE_NORELEASE) {

                        /*
                         * We either could not release this dc or could not set
                         * its owner. In either case it means some other thread
                         * is actively using it. Since it is not too useful if
                         * the window it is calculated for is gone, mark it as
                         * INUSE (so we don't give it out again) and as
                         * DESTROYTHIS (so we just get rid of it since it is
                         * easier to do this than to release it back into the
                         * cache). The W32PF_OWNERDCCLEANUP bit means "look for
                         * DESTROYTHIS flags and destroy that dc", and the bit
                         * gets looked at in various strategic execution paths.
                         */
                        pdce->DCX_flags = DCX_DESTROYTHIS | DCX_INUSE | DCX_CACHE;
                        pti->ppi->W32PF_Flags |= W32PF_OWNDCCLEANUP;

                    } else {

                        /*
                         * We either released the DC or changed its owner
                         * successfully. Mark the entry as invalid so it can
                         * be given out again.
                         */
                        MarkDCEInvalid(pdce);
                        pdce->hrgnClip = NULL;
                    }

                    /*
                     * We shouldn't reference this window anymore. Setting
                     * these to NULL here will make sure that even if we were
                     * not able to release the DC here, we won't return this
                     * window from one of the DC matching functions.
                     */
                    pdce->pwndOrg  = NULL;
                    pdce->pwndClip = NULL;

                    /*
                     * Remove the visrgn since it is still owned - if we did
                     * not, gdi would not be able to clean up properly if the
                     * app that owns this visrgn exist while the visrgn is
                     * still selected.
                     */
                    GreLockDisplay(gpDispInfo->hDev);
                    GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);
                    GreUnlockDisplay(gpDispInfo->hDev);
                }
            }
        }

        /*
         * Step to the next DC. If the DC was deleted, there
         * is no need to calculate address of the next entry.
         */
        if (pdce == *ppdce)
NextEntry:
            ppdce = &pdce->pdceNext;
    }

    /*
     * Clean up the spb that may still exist - like child window spb's.
     */
    if (pwnd == gspwndLockUpdate) {
        FreeSpb(FindSpb(pwnd));
        Unlock(&gspwndLockUpdate);
        gptiLockUpdate = NULL;
    }

    if (TestWF(pwnd, WFHASSPB)) {
        FreeSpb(FindSpb(pwnd));
    }

    /*
     * Blow away the window clipping region. If the window is maximized, don't
     * blow away the monitor region. If the window is the desktop, don't blow
     * away the screen region.
     */
    if (    pwnd->hrgnClip != NULL &&
            !TestWF(pwnd, WFMAXFAKEREGIONAL) &&
            GETFNID(pwnd) != FNID_DESKTOP) {

        GreDeleteObject(pwnd->hrgnClip);
        pwnd->hrgnClip = NULL;
    }

    /*
     * Clean up any memory allocated for scroll bars...
     */
    if (pwnd->pSBInfo) {
        DesktopFree(pwnd->head.rpdesk, (HANDLE)(pwnd->pSBInfo));
        pwnd->pSBInfo = NULL;
    }

    /*
     * Free any callback handles associated with this window.
     * This is done outside of DeleteProperties because of the special
     * nature of callback handles as opposed to normal memory handles
     * allocated for a thread.
     */

    /*
     * Blow away the title
     */
    if (pwnd->strName.Buffer != NULL) {
        DesktopFree(pwnd->head.rpdesk, pwnd->strName.Buffer);
        pwnd->strName.Buffer = NULL;
        pwnd->strName.Length = 0;
    }

    /*
     * Blow away any properties connected to the window.
     */
    if (pwnd->ppropList != NULL) {
        TL tlpDdeConv;
        PDDECONV pDdeConv;
        PDDEIMP pddei;

        /*
         * Get rid of any icon properties.
         */
        DestroyWindowSmIcon(pwnd);
        InternalRemoveProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);

        pDdeConv = (PDDECONV)_GetProp(pwnd, PROP_DDETRACK, PROPF_INTERNAL);
        if (pDdeConv != NULL) {
            ThreadLockAlwaysWithPti(pti, pDdeConv, &tlpDdeConv);
            xxxDDETrackWindowDying(pwnd, pDdeConv);
            ThreadUnlock(&tlpDdeConv);
        }
        pddei = (PDDEIMP)InternalRemoveProp(pwnd, PROP_DDEIMP, PROPF_INTERNAL);
        if (pddei != NULL) {
            pddei->cRefInit = 0;
            if (pddei->cRefConv == 0) {
                /*
                 * If this is not 0 it is referenced by one or more DdeConv
                 * structures so DON'T free it yet!
                 */
                UserFreePool(pddei);
            }
        }
    }

    /*
     * Unlock everything that the window references.
     * After we have sent the WM_DESTROY and WM_NCDESTROY message we
     * can unlock & NULL the owner field so no other windows get z-ordered
     * relative to this window. Rhumba faults if we NULL it before the
     * destroy. (It calls GetParent after every message).
     *
     * We special-case the spwndParent window. In this case, if the
     * window being destroyed is a desktop window, unlock the parent.
     * Otherwise, we lock in the desktop-window as the parent so that
     * if we aren't freed in this function, we will ensure that we
     * won't fault when doing things like clipping-calculations. We'll
     * unlock this once we know we're truly going to free this window.
     */
    if (pwnd->head.rpdesk != NULL &&
            pwnd != pwnd->head.rpdesk->pDeskInfo->spwnd) {
        Lock(&pwnd->spwndParent, pwnd->head.rpdesk->pDeskInfo->spwnd);
    } else {
        Unlock(&pwnd->spwndParent);
    }

    Unlock(&pwnd->spwndChild);
    Unlock(&pwnd->spwndOwner);
    Unlock(&pwnd->spwndLastActive);

    /*
     * Decrement the Window Reference Count in the Class structure.
     */
    DereferenceClass(pwnd);

    /*
     * Mark the object for destruction before this final unlock. This way
     * the WM_FINALDESTROY will get sent if this is the last thread lock.
     * We're currently destroying this window, so don't allow unlock recursion
     * at this point (this is what HANDLEF_INDESTROY will do for us).
     */
    HMMarkObjectDestroy(pwnd);
    HMPheFromObject(pwnd)->bFlags |= HANDLEF_INDESTROY;

    /*
     * Unlock the window... This shouldn't return FALSE because HANDLEF_DESTROY
     * is set, but just in case... if it isn't around anymore, return because
     * pwnd is invalid.
     */
    if (!ThreadUnlock(ptlpwndFree)) {
        return;
    }

    /*
     * Try to free the object. The object won't free if it is locked - but
     * it will be marked for destruction. If the window is locked, change
     * it's wndproc to xxxDefWindowProc().
     *
     * HMMarkObjectDestroy() will clear the HANDLEF_INDESTROY flag if the
     * object isn't about to go away (so it can be destroyed again!)
     */
    if (HMMarkObjectDestroy(pwnd)) {

        /*
         * Delete the window's property list. Wait until now in case some
         * thread keeps a property pointer around across a callback.
         */
        if (pwnd->ppropList != NULL) {
            DeleteProperties(pwnd);
        }

#if DBG
        /*
         * If we find the window is visible at the time we free it, then
         * somehow the app was made visible on a callback (we hide it
         * during xxxDestroyWindow(). This screws up our vis-window
         * count for the thread, so we need to assert it.
         */
        if (TestWF(pwnd, WFINDESTROY) && TestWF(pwnd, WFVISIBLE))
            RIPMSG1(RIP_WARNING, "xxxFreeWindow: Window should not be visible (pwnd == %#p)", pwnd);
#endif

        pti->cWindows--;

        /*
         * Since we're freeing the memory for this window, we need
         * to unlock the parent (which is the desktop for zombie windows).
         */
        Unlock(&pwnd->spwndParent);

        ThreadLockDesktop(pti, pwnd->head.rpdesk, &tlpdesk, LDLT_FN_FREEWINDOW);
        HMFreeObject(pwnd);
        ThreadUnlockDesktop(pti, &tlpdesk, LDUT_FN_FREEWINDOW);
        return;
    }

    /*
     * Turn this into an object that the app won't see again - turn
     * it into an icon title window - the window is still totally
     * valid and useable by any structures that has this window locked.
     */
    pwnd->lpfnWndProc = xxxDefWindowProc;
    if (pwnd->head.rpdesk)
        ppi = pwnd->head.rpdesk->rpwinstaParent->pTerm->ptiDesktop->ppi;
    else
        ppi = PpiCurrent();
    ppcls = GetClassPtr(gpsi->atomSysClass[ICLS_ICONTITLE], ppi, hModuleWin);

    UserAssert(ppcls);
    pwnd->pcls = *ppcls;

    /*
     * Since pwnd is marked as destroyed, there should be no client-side
     * code which can validate it. So we do not need to search for a clone
     * class of the right desktop -- just use the base class and bump the
     * WndReferenceCount. This also helps if we are in a low-memory situation
     * and cannot alloc another clone.
     */

    pwnd->pcls->cWndReferenceCount++;

    SetWF(pwnd, WFSERVERSIDEPROC);

    /*
     * Clear the palette bit so that WM_PALETTECHANGED will not be sent
     * again when the window is finally destroyed.
     */
    ClrWF(pwnd, WFHASPALETTE);

    /*
     * Clear its child bits so no code assumes that if the child bit
     * is set, it has a parent. Change spmenu to NULL - it is only
     * non-zero if this was child.
     */
    ClrWF(pwnd, WFTYPEMASK);
    SetWF(pwnd, WFTILED);
    pwnd->spmenu = NULL;
}

/***************************************************************************\
* UnlinkWindow
*
* History:
* 19-Oct-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/
VOID UnlinkWindow(
    PWND pwnd,
    PWND pwndParent)
{
    if (pwndParent->spwndChild == pwnd) {
        UserAssert(pwnd->spwndPrev == NULL);
        Lock(&pwndParent->spwndChild, pwnd->spwndNext);
    } else if (pwnd->spwndPrev != NULL) {
        Lock(&pwnd->spwndPrev->spwndNext, pwnd->spwndNext);
    }

    if (pwnd->spwndNext != NULL) {
        Lock(&pwnd->spwndNext->spwndPrev, pwnd->spwndPrev);
        Unlock(&pwnd->spwndNext);
    }

    Unlock(&pwnd->spwndPrev);

#if DBG
    VerifyWindowLink(pwnd, pwndParent, FALSE);
#endif
}

/***************************************************************************\
* DestroyCacheDCEntries
*
* Destroys all cache dc entries currently in use by this thread.
*
* 24-Feb-1992 ScottLu   Created.
\***************************************************************************/
VOID DestroyCacheDCEntries(
    PTHREADINFO pti)
{
    PDCE *ppdce;
    PDCE pdce;

    /*
     * Before any window destruction occurs, we need to destroy any dcs
     * in use in the dc cache. When a dc is checked out, it is marked owned,
     * which makes gdi's process cleanup code delete it when a process
     * goes away. We need to similarly destroy the cache entry of any dcs
     * in use by the exiting process.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        /*
         * If the dc owned by this thread, remove it from the cache. Because
         * DestroyCacheEntry destroys gdi objects, it is important that
         * USER be called first in process destruction ordering.
         *
         * Only destroy this dc if it is a cache dc, because if it is either
         * an owndc or a classdc, it will be destroyed for us when we destroy
         * the window (for owndcs) or destroy the class (for classdcs).
         */
        pdce = *ppdce;
        if (pti == pdce->ptiOwner) {

            if (pdce->DCX_flags & DCX_CACHE)
                DestroyCacheDC(ppdce, pdce->hdc);
        }

        /*
         * Step to the next DC. If the DC was deleted, there's no need to
         * calculate address of the next entry.
         */
        if (pdce == *ppdce) {
            ppdce = &pdce->pdceNext;
        }
    }
}

/***************************************************************************\
* PatchThreadWindows
*
* This patches a thread's windows so that their window procs point to
* server only windowprocs. This is used for cleanup so that app aren't
* called back while the system is cleaning up after them.
*
* 24-Feb-1992 ScottLu   Created.
\***************************************************************************/
VOID PatchThreadWindows(
    PTHREADINFO pti)
{
    PHE  pheT;
    PHE  pheMax;
    PWND pwnd;

    /*
     * First do any preparation work: windows need to be "patched" so that
     * their window procs point to server only windowprocs, for example.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

        /*
         * Make sure this object is a window, it hasn't been marked for
         * destruction, and that it is owned by this thread.
         */
        if (pheT->bType != TYPE_WINDOW)
            continue;

        if (pheT->bFlags & HANDLEF_DESTROY) {
            continue;
        }

        if ((PTHREADINFO)pheT->pOwner != pti) {
            continue;
        }

        /*
         * Don't patch the window based on the class it was created from -
         * because apps can sometimes sub-class a class - make a random class,
         * then call ButtonWndProc with windows of that class by using
         * the CallWindowProc() api. So patch the wndproc based on what
         * wndproc this window has been calling.
         */
        pwnd = (PWND)pheT->phead;

        if ((pwnd->fnid >= (WORD)FNID_WNDPROCSTART) &&
            (pwnd->fnid <= (WORD)FNID_WNDPROCEND)) {

            pwnd->lpfnWndProc = STOCID(pwnd->fnid);

            if (pwnd->lpfnWndProc == NULL) {
                pwnd->lpfnWndProc = xxxDefWindowProc;
            }
        } else {
            pwnd->lpfnWndProc = xxxDefWindowProc;
        }

        /*
         * This is a server side window now...
         */
        SetWF(pwnd, WFSERVERSIDEPROC);
        ClrWF(pwnd, WFANSIPROC);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\classchg.c ===
/****************************** Module Header ******************************\
* Module Name: class.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains RegisterClass and the related window class management
* functions.
*
* History:
*  12-20-94  FritzS
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL VisWindow(PWND,DWORD);


/***************************************************************************\
* xxxSetClassIconEnum
\***************************************************************************/
BOOL xxxSetClassIconEnum(
    PWND pwnd,
    LPARAM lParam)
{
    CheckLock(pwnd);

    if (pwnd->pcls == (PCLS)lParam) {
        /*
         * If the window doesn't have a small icon or it comes from
         * WM_QUERYDRAGICON, redraw the title. In the WM_QUERYDRAGICON
         * case, get rid of the small icon so redrawing the title will
         * create it if necessary.
         */
        if (TestWF(pwnd, WFSMQUERYDRAGICON)) {
            DestroyWindowSmIcon(pwnd);
        }

        if (!_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp),PROPF_INTERNAL)) {
            xxxRedrawTitle(pwnd, DC_ICON);
        }
    }

    return TRUE;
}

/***************************************************************************\
* SetClassIcon
*
* Changes the big/small icon of a class.  Called from SetClassWord().
\***************************************************************************/
PCURSOR xxxSetClassIcon(
    PWND pwnd,
    PCLS pcls,
    PCURSOR pCursor,
    int gcw)
{
    PTHREADINFO pti = PtiCurrent();
    PCURSOR pCursorOld;
    HCURSOR hCursorOld;
    TL tlpwndChild;
    BOOL fRedraw;

    CheckLock(pwnd);

    /*
     * Save old icon.
     */
    pCursorOld = ((gcw == GCLP_HICON) ? pcls->spicn : pcls->spicnSm);
    if (pCursorOld != pCursor) {
        fRedraw = TRUE;

        hCursorOld = PtoH(pCursorOld);

        /*
         * Set new icon.
         */
        if (gcw == GCLP_HICON) {
            /*
             * Destroy private cached small icon first.
             */
            if (pcls->spicnSm && !DestroyClassSmIcon(pcls)) {
                fRedraw = FALSE;
            }

            Lock(&(pcls->spicn), pCursor);

        } else {

            /*
             * We don't allow apps to see the small icons we create from
             * their big icons.  They can see their own.  Saves memory
             * leak problems and is easier.
             */
            if (pcls->CSF_flags & CSF_CACHEDSMICON) {
                DestroyClassSmIcon(pcls);
                hCursorOld = NULL;
            }

            Lock(&(pcls->spicnSm), pCursor);
        }

        if (pcls->spicn && !pcls->spicnSm) {
            xxxCreateClassSmIcon(pcls);
        }

        if (fRedraw) {
            if (pcls->cWndReferenceCount > 1) {
                ThreadLock(pti->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
                xxxInternalEnumWindow(pti->rpdesk->pDeskInfo->spwnd->spwndChild,
                                      xxxSetClassIconEnum,
                                      (LPARAM)pcls,
                                      BWL_ENUMLIST);
                ThreadUnlock(&tlpwndChild);
            } else {
                xxxSetClassIconEnum(pwnd, (LPARAM)pcls);
            }
        }

        /*
         * Revalidate the old cursor
         */
        if (hCursorOld != NULL) {
            pCursorOld = HMRevalidateHandleNoRip(hCursorOld);
        } else {
            pCursorOld = NULL;
        }
    }

    return pCursorOld;
}

/***************************************************************************\
* DestroyClassSmIcon
*
* Destroys the small icon of a class if we've created a cached one.
\***************************************************************************/
BOOL DestroyClassSmIcon(
    PCLS pcls)
{
    /*
     * If we don't have a cached icon, then no work.
     */
    if (pcls->CSF_flags & CSF_CACHEDSMICON) {
        if (pcls->spicnSm) {
            _DestroyCursor(pcls->spicnSm, CURSOR_ALWAYSDESTROY);
            Unlock(&pcls->spicnSm);
        }
        pcls->CSF_flags &= ~CSF_CACHEDSMICON;
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxCreateClassSmIcon
*
* Creates a cached class small icon from a class big icon.
\***************************************************************************/
VOID xxxCreateClassSmIcon(
    PCLS pcls)
{
    PCURSOR pcur;

    UserAssert(pcls->cWndReferenceCount > 0);
    UserAssert(pcls->spicn);
    UserAssert(!pcls->spicnSm);

    pcur = xxxClientCopyImage(PtoH(pcls->spicn),
            pcls->spicn->rt == PTR_TO_ID(RT_ICON) ? IMAGE_ICON : IMAGE_CURSOR,
            SYSMET(CXSMICON),
            SYSMET(CYSMICON),
            LR_DEFAULTCOLOR | LR_COPYFROMRESOURCE);

    Lock(&pcls->spicnSm, pcur);
    if (pcls->spicnSm) {
        pcls->CSF_flags |= CSF_CACHEDSMICON;
    }
}

/***************************************************************************\
* xxxSetWindowStyle
*
* Changes the style bits of a window. Called from SetWindowLong(). This
* sends two messages, a changing and a changed. Upon receipt of a
* WM_STYLECHANGING message, a window can muck with the style bits for
* validation purposes. The WM_STYLECHANGED message is simply after the
* fact.
\***************************************************************************/
LONG xxxSetWindowStyle(
    PWND pwnd,
    int gwl,
    DWORD styleNew)
{
    STYLESTRUCT sty;
    BOOL fWasChild, fIsChild, fBefore, fAfter;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    sty.styleOld = ((gwl == GWL_STYLE) ? pwnd->style : pwnd->ExStyle);
    sty.styleNew = styleNew;

    /*
     * Note that we don't do validation before _and_ after.  It is sufficient
     * to do our stuff at the end.
     */

    /*
     * We break Quicken 2.0 if we send the messages. That's why we version
     * switch them.
     *
     * Send a WM_STYLECHANGING message to the window, so it can muck with
     * the style bits.  Like validate some stuff.
     */
    if (TestWF(pwnd, WFWIN40COMPAT)) {
        xxxSendMessage(pwnd, WM_STYLECHANGING, gwl, (LPARAM)(LPSTYLESTRUCT)&sty);
    }

    /*
     * Now do our own validation.
     */
    if (gwl == GWL_STYLE) {
        BOOL fWasVisWindow;

        /*
         * If this is an edit control that has ES_PASSWORD set and
         * the caller does not own it and is trying to reset it,
         * fail the call.
         */
        if (PpiCurrent() != GETPTI(pwnd)->ppi && IS_EDIT(pwnd) &&
            (sty.styleOld & ES_PASSWORD) && !(sty.styleNew & ES_PASSWORD)) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Access denied in xxxSetWindowStyle");
            return 0;
        }

        /* Listbox ownerdraw style check was moved to the client side (client\ntstubs.c) */

        /*
         * Do proper validation on style bits.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            sty.styleNew |= WS_CLIPSIBLINGS;
        }

        /*
         * If the clipping-ness is changing, invalidate the dc cache.
         */
        if ((sty.styleNew & (WS_CLIPCHILDREN | WS_CLIPSIBLINGS)) !=
            (sty.styleOld & (WS_CLIPCHILDREN | WS_CLIPSIBLINGS))) {

            /*
             * No need to DeferWinEventNotify() - pwnd is locked
             */
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
        }

        /*
         * This breaks all Paradox dialogs 1.0-5.0 that have combos.  They
         * enumerate all child windows, add on minimized, then sit in a peek
         * loop.  After that they enumerate all child windows and remove
         * WS_MINIMIZE--except the code below won't let them.
         *
         * Result is weird painting and an inability to use the dialog any
         * more short of dismissing it
         *
         * Temp fix:  Check for child window first.
         */

        /*
         * if this window is REALLY minimized (minimized bit is set and caption
         * present bit is removed), then don't allow app to remove the minimize
         * bit -- this fixes FoxBlow's attempt at being the OS -- jeffbog
         */
        if (!TestWF(pwnd, WFCHILD) &&
                TestWF(pwnd, WFMINIMIZED) &&
                !TestWF(pwnd, WFCPRESENT) &&
                !(sty.styleNew & WS_MINIMIZE)) {

            sty.styleNew |= WS_MINIMIZE;
        }

        /*
         * If we're changing the child bit, deal with spmenu appropriately.
         * If we're turning into a child, change spmenu to an id. If we're
         * turning into a top level window, turn spmenu into a menu.
         */
        fWasChild = TestwndChild(pwnd);

        pwnd->style = sty.styleNew;

        fIsChild = TestwndChild(pwnd);

        /*
         * If we turned into a top level window, change spmenu to NULL.
         * If we turned into a child from a top level window, unlock spmenu.
         */
        if (fWasChild && !fIsChild) {
            pwnd->spmenu = NULL;
        }

        if (!fWasChild && fIsChild) {
            ClrWF(pwnd, WFMPRESENT);
            UnlockWndMenu(pwnd, &pwnd->spmenu);
        }

        /*
         * If the visible, child, or minimized style is changing,
         * then update the cVisWindows count
         */
        fWasVisWindow = VisWindow(pwnd, sty.styleOld);
        if (fWasVisWindow != VisWindow(pwnd, sty.styleNew)) {

            if (fWasVisWindow) {
                DecVisWindows(pwnd);
            } else {
                IncVisWindows(pwnd);
            }
        }
    } else {
        /*
         * First, see if the app might be setting bits that it really
         * doesn't know about.  If so, replace those bits with the
         * current values.
         */
        if (GetAppCompatFlags2(VER40) & GACF2_NO50EXSTYLEBITS) {
            sty.styleNew &= WS_EX_VALID40;
        } else {
            /*
             * Don't let aplications set unused extended bits.
             */
            if (sty.styleNew & ~WS_EX_ALLVALID) {
                RIPMSGF1(RIP_WARNING,
                         "Trying to set reserved exStyle bits 0x%x",
                         sty.styleNew);
            }

            sty.styleNew &= WS_EX_ALLVALID;
        }

        /*
         * Is someone trying to toggle the WS_EX_TOPMOST style bit?
         */
        if ((sty.styleOld & WS_EX_TOPMOST) != (sty.styleNew & WS_EX_TOPMOST)) {
            RIPMSG0(RIP_WARNING, "Can't change WS_EX_TOPMOST with SetWindowLong");

            /*
             * BACKWARDS COMPATIBILITY HACK
             * If stuff is getting stored in the high word, then it must be
             * Lotus 123-W sticking a FAR pointer in this field.  So don't
             * modify it.
             */
            if (TestWF(pwnd, WFWIN40COMPAT) || !HIWORD(sty.styleNew)) {
                /*
                 * Don't let the bit be flipped.
                 */
                sty.styleNew &= ~WS_EX_TOPMOST;
                sty.styleNew |= (sty.styleOld & WS_EX_TOPMOST);
            }
        }

        /*
         * Check pwnd->ExStyle directly since sty.styleOld can now be
         * different from the real state of the window, because of the
         * callbacks in this function from the time sty.styleOld was
         * remembered and up to now. We must call the layering functions
         * based on the real state of the layering bit.
         */
        fBefore = (pwnd->ExStyle & WS_EX_LAYERED);
        fAfter = (sty.styleNew & WS_EX_LAYERED);

        if (fBefore && !fAfter) {
            UnsetLayeredWindow(pwnd);
        } else if (!fBefore && fAfter) {
            if (!xxxSetLayeredWindow(pwnd, TRUE)) {
                return 0;
            }
        }

        fBefore = (pwnd->ExStyle & WS_EX_COMPOSITED);
        fAfter = (sty.styleNew & WS_EX_COMPOSITED);

        if (!fBefore && fAfter) {
            /*
             * If we are turning WS_EX_COMPOSITED on, none of our parents
             * should already have WS_EX_COMPOSITED turned on.  If any do,
             * since we were explicitely trying to turn this style on, fail
             * the call.
             */

            if (GetStyleWindow(pwnd->spwndParent, WEFCOMPOSITED) != NULL) {
                return 0;
            }
        }

        if (fBefore && !fAfter) {
            UnsetRedirectedWindow(pwnd, REDIRECT_COMPOSITED);
        } else if (!fBefore && fAfter) {
            if (!SetRedirectedWindow(pwnd, REDIRECT_COMPOSITED)) {
                return 0;
            }

            /*
             * We have successfully turned WS_EX_COMPOSITED on for ourself, so
             * need to ensure that none of our child have WS_EX_COMPOSITED also
             * turned on.
             */

            xxxTurnOffCompositing(pwnd, TRUE);
        }

#ifdef REDIRECTION
        {

            BOOL fVisrgnChange = FALSE;
            fBefore = (pwnd->ExStyle & WS_EX_EXTREDIRECTED);
            fAfter = (sty.styleNew & WS_EX_EXTREDIRECTED);

            if (fBefore && !fAfter) {
                UnsetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
                fVisrgnChange = TRUE;
            } else if (!fBefore && fAfter) {
                if (!SetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED)) {
                    return 0;
                }
                fVisrgnChange = TRUE;
            }

            if (fVisrgnChange) {
                BEGINATOMICCHECK();
                zzzInvalidateDCCache(pwnd, IDC_DEFAULT | IDC_NOMOUSE);
                ENDATOMICCHECK();
            }
        }
#endif

        /*
         * The bits we use internally should be preserved
         */
        pwnd->ExStyle = sty.styleNew | (pwnd->ExStyle & ~WS_EX_ALLVALID);
        if ((sty.styleOld ^ sty.styleNew)
            & (WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LAYOUTRTL)) {
            xxxRedrawFrame(pwnd);
        }
    }

    /*
     * See if we still need the 3D edge since the window styles changed.
     */
    if (NeedsWindowEdge(pwnd->style, pwnd->ExStyle, TestWF(pwnd, WFWIN40COMPAT))) {
        SetWF(pwnd, WEFWINDOWEDGE);
    } else {
        ClrWF(pwnd, WEFWINDOWEDGE);
    }

    /*
     * Send a WM_STYLECHANGED message.
     */
    if (TestWF(pwnd, WFWIN40COMPAT)) {
        xxxSendMessage(pwnd, WM_STYLECHANGED, gwl, (LPARAM)(LPSTYLESTRUCT)&sty);
    }

    return sty.styleOld;
}

/***************************************************************************\
* VisWindow
*
* Based on style, determines if this is considered to be "visible" by
* queue foreground styles.
\***************************************************************************/
BOOL VisWindow(
    PWND pwnd,
    DWORD style)
{
    return (FTopLevel(pwnd) && !(style & WS_MINIMIZE) && (style & WS_VISIBLE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\cleanup.c ===
/****************************** Module Header ******************************\
* Module Name: cleanup.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code used to clean up after a dying thread.
*
* History:
* 02-15-91 DarrinM      Created.
* 01-16-92 IanJa        Neutralized ANSI/UNICODE (debug strings kept ANSI)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* PseudoDestroyClassWindows
*
* Walk the window tree from hwndParent looking for windows of class
* wndClass. If one is found, destroy it.
*
*
* WARNING windows actually destroys these windows. We only zombie-ize them
* so this call does not have to be an xxx call.
*
* History:
* 25-Mar-1994 JohnC from win 3.1
\***************************************************************************/
VOID PseudoDestroyClassWindows(
    PWND pwndParent,
    PCLS pcls)
{
    PWND pwnd;
    PTHREADINFO pti;

    pti = PtiCurrent();

    /*
     * Recursively walk the window list and zombie any windows of this class.
     */
    for (pwnd = pwndParent->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {
        /*
         * If this window belongs to this class then zombie it if it was
         * created by this message thread.
         */
        if (pwnd->pcls == pcls && pti == GETPTI(pwnd)) {
            /*
             * Zombie-ize the window.
             *
             * Remove references to the client side window proc because that
             * WOW selector has been freed.
             */
            RIPMSG1(RIP_WARNING, "USER: Wow Window not destroyed: 0x%p", pwnd);

            if (!TestWF(pwnd, WFSERVERSIDEPROC)) {
                pwnd->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientA.pfnDefWindowProc;
            }
        }

        /*
         * Recurse downward to look for any children that might be of this
         * class.
         */
        if (pwnd->spwndChild != NULL) {
            PseudoDestroyClassWindows(pwnd, pcls);
        }
    }
}

/***************************************************************************\
* _WOWModuleUnload
*
* Go through all the windows owned by the dying queue and do the following:
*
* 1. Restore Standard window classes have their window procs restored
*    to their original value, in case they were subclassed.
*
* 2. App window classes have their window procs set to DefWindowProc
*    so that we don't execute any app code.
*
* Array of original window proc addresses, indexed by ICLS_* value is in
* globals.c now -- gpfnwp.
*
* This array is initialized in code in init.c.
\***************************************************************************/
VOID _WOWModuleUnload(
    HANDLE hModule)
{
    PPROCESSINFO ppi = PpiCurrent();
    PHE pheT, pheMax;
    PPCLS ppcls;
    int i;

    UserAssert(gpfnwp[0]);

    /*
     * PseudoDestroy windows with wndprocs from this hModule.
     *
     * If its a wow16 wndproc, check if the hMod16 is this module and Nuke
     * matches.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        PTHREADINFO ptiTest = (PTHREADINFO)pheT->pOwner;
        PWND pwnd;
        if (pheT->bType == TYPE_WINDOW &&
            (ptiTest->TIF_flags & TIF_16BIT) &&
            ptiTest->ppi == ppi) {

            pwnd = (PWND)pheT->phead;
            if (!TestWF(pwnd, WFSERVERSIDEPROC) &&
                IsWOWProc(pwnd->lpfnWndProc) &&
                (pwnd->hMod16 == (WORD)(ULONG_PTR)hModule)) {
                pwnd->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientA.pfnDefWindowProc;
            }
        }
    }

    /*
     * Destroy private classes identified by hInstance that are not
     * referenced by any windows. Mark in-use classes for later destruction.
     */
    ppcls = &(ppi->pclsPrivateList);
    for (i = 0; i < 2; ++i) {
        while (*ppcls != NULL) {

            PWC pwc;
            PCLS pcls;

            if (HIWORD((ULONG_PTR)(*ppcls)->hModule) == (WORD)(ULONG_PTR)hModule) {
                if ((*ppcls)->cWndReferenceCount == 0) {
                    DestroyClass(ppcls);
                    /*
                     * DestroyClass does *ppcls = pcls->pclsNext; so we just
                     * want to continue here.
                     */
                } else {
                    /*
                     * Zap all the windows around that belong to this class.
                     */
                    PseudoDestroyClassWindows(PtiCurrent()->rpdesk->pDeskInfo->spwnd, *ppcls);

                    (*ppcls)->CSF_flags |= CSF_WOWDEFERDESTROY;
                    ppcls = &((*ppcls)->pclsNext);
                }

                continue;
            }

            pcls = *ppcls;

            if ((pcls->CSF_flags & CSF_WOWCLASS) && ((WORD)(ULONG_PTR)hModule == (pwc = PWCFromPCLS(pcls))->hMod16)) {
                ATOM atom;
                int iSel;

                /*
                 * See if the window's class atom matches any of the system
                 * ones. If so, jam in the original window proc. Otherwise,
                 * use DefWindowProc.
                 */
                atom = (*ppcls)->atomClassName;
                for (iSel = ICLS_BUTTON; iSel < ICLS_MAX; iSel++) {
                    if ((gpfnwp[iSel]) && (atom == gpsi->atomSysClass[iSel])) {
                        (*ppcls)->lpfnWndProc = (WNDPROC_PWND)gpfnwp[iSel];
                        break;
                    }
                }

                if (iSel == ICLS_MAX) {
                    (*ppcls)->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientW.pfnDefWindowProc;
                }
            }

            ppcls = &((*ppcls)->pclsNext);
        }

        /*
         * Destroy public classes identified by hInstance that are not
         * referenced by any windows. Mark in-use classes for later
         * destruction.
         */
        ppcls = &(ppi->pclsPublicList);
    }
}


/***************************************************************************\
* _WOWCleanup
*
* Private API to allow WOW to cleanup any process-owned resources when a WOW
* thread exits or when a DLL is unloaded.
*
* Note that at module cleanup, hInstance = the module handle and hTaskWow is
* NULL. On task cleanup, hInstance = the hInst/hTask combined which matches
* the value passed in hModule to WowServerCreateCursorIcon and hTaskWow !=
* NULL.
*
* History:
* 09-02-92 JimA         Created.
\***************************************************************************/
VOID _WOWCleanup(
    HANDLE hInstance,
    DWORD hTaskWow)
{
    PPROCESSINFO ppi = PpiCurrent();
    PPCLS ppcls;
    PHE pheT, pheMax;
    int i;

    if (hInstance != NULL) {
        PWND pwnd;

        /*
         * Task cleanup.
         */
        hTaskWow = (DWORD)LOWORD(hTaskWow);

        /*
         * Task exit called by wow. This loop will Pseudo-Destroy windows
         * created by this task.
         */
        pheMax = &gSharedInfo.aheList[giheLast];
        for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
            PTHREADINFO ptiTest = (PTHREADINFO)pheT->pOwner;
            if (pheT->bType == TYPE_WINDOW &&
                (ptiTest->TIF_flags & TIF_16BIT) &&
                ptiTest->ptdb &&
                ptiTest->ptdb->hTaskWow == hTaskWow &&
                ptiTest->ppi == ppi) {

                pwnd = (PWND) pheT->phead;
                if (!TestWF(pwnd, WFSERVERSIDEPROC)) {
                    pwnd->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientA.pfnDefWindowProc;
                }
            }
        }

        return;
    }

    /*
     * If we get here, we are in thread cleanup and all of the thread's
     * windows have been destroyed or disassociated with any classes. If a
     * class marked for destruction at this point still has windows they
     * must belong to a dll.
     */

    /*
     * Destroy private classes marked for destruction.
     */
    ppcls = &(ppi->pclsPrivateList);
    for (i = 0; i < 2; ++i) {
        while (*ppcls != NULL) {
            if ((*ppcls)->hTaskWow == hTaskWow &&
                    ((*ppcls)->CSF_flags & CSF_WOWDEFERDESTROY)) {
                if ((*ppcls)->cWndReferenceCount == 0) {
                    DestroyClass(ppcls);
                } else {
                    RIPMSG0(RIP_ERROR, "Windows remain for a WOW class marked for destruction");
                    ppcls = &((*ppcls)->pclsNext);
                }
            } else {
                ppcls = &((*ppcls)->pclsNext);
            }
        }

        /*
         * Destroy public classes marked for destruction.
         */
        ppcls = &(ppi->pclsPublicList);
    }

    /*
     * Destroy menus, cursors, icons and accel tables identified by hTaskWow.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        /*
         * Check against free before we look at ppi because pq is stored in
         * the object itself, which won't be there if TYPE_FREE.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * Destroy those objects created by this task.
         *
         * Do not destroy CALLPROCDATA objects. These should only get nuked
         * when the process goes away or when the class is nuked.
         */
        if (!(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) ||
            (PPROCESSINFO)pheT->pOwner != ppi ||
            ((PPROCOBJHEAD)pheT->phead)->hTaskWow != hTaskWow ||
            pheT->bType == TYPE_CALLPROC) {
            continue;
        }

        /*
         * Make sure this object isn't already marked to be destroyed - we'll
         * do no good if we try to destroy it now since it is locked.
         */
        if (pheT->bFlags & HANDLEF_DESTROY) {
            continue;
        }

        /*
         * Destroy this object.
         */
        HMDestroyUnlockedObject(pheT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\dc.c ===
/****************************** Module Header ******************************\
* Module Name: dc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains User's DC APIs and related functions.
*
* History:
* 23-Oct-1990 DarrinM   Created.
* 07-Feb-1991 MikeKe    Added Revalidation code (None).
* 17-Jul-1991 DarrinM   Recreated from Win 3.1 source.
* 21-Jan-1992 IanJa     ANSI/Unicode neutral (null op).
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * DBG Related Information.
 */
#if DBG
BOOL fDisableCache;                 // TRUE to disable DC cache.
#endif

/***************************************************************************\
* DecrementFreeDCECount
*
\***************************************************************************/
__inline VOID DecrementFreeDCECount(
    VOID)
{
    UserAssert(gnDCECount >= 0);

    gnDCECount--;
}

/***************************************************************************\
* IncrementFreeDCECount
*
\***************************************************************************/
__inline VOID IncrementFreeDCECount(
    VOID)
{
    UserAssert(gnDCECount >= 0);

    gnDCECount++;
}

/***************************************************************************\
* SetMonitorRegion
*
* The region is in meta dc coordinates, so convert to monitor coords.
\***************************************************************************/
VOID SetMonitorRegion(
    PMONITOR pMonitor,
    HRGN hrgnDst,
    HRGN hrgnSrc)
{
    if (IntersectRgn(hrgnDst, hrgnSrc, pMonitor->hrgnMonitor) == ERROR) {
        GreSetRectRgn(hrgnDst, 0, 0, 0, 0);
        return;
    }

    GreOffsetRgn(hrgnDst, -pMonitor->rcMonitor.left, -pMonitor->rcMonitor.top);
}

/***************************************************************************\
* ResetOrg
*
* Resets the origin of the DC associated with *pdce, and selects
* a new visrgn.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID ResetOrg(
    HRGN hrgn,
    PDCE pdce,
    BOOL fSetVisRgn)
{
    RECT rc;
    PWND pwndLayer;

    /*
     * For compatibility purposes, make sure that the DC's for the
     * desktop windows originate at the primary monitor, i.e. (0,0).
     */
    if (GETFNID(pdce->pwndOrg) == FNID_DESKTOP) {
        rc.left = rc.top = 0;
        rc.right = SYSMET(CXVIRTUALSCREEN);
        rc.bottom = SYSMET(CYVIRTUALSCREEN);
    } else if (pdce->DCX_flags & DCX_WINDOW) {
        rc = pdce->pwndOrg->rcWindow;
    } else {
        rc = pdce->pwndOrg->rcClient;
    }

    if (pdce->pMonitor != NULL) {
        OffsetRect(&rc, -pdce->pMonitor->rcMonitor.left,
                -pdce->pMonitor->rcMonitor.top);

        if (hrgn != NULL) {
            SetMonitorRegion(pdce->pMonitor, hrgn, hrgn);
        }
    }

    if (((pwndLayer = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED)) != NULL)
        && (pdce->DCX_flags & DCX_REDIRECTED)) {

        int x = pwndLayer->rcWindow.left;
        int y = pwndLayer->rcWindow.top;

        /*
         * For layered redirection DCs, the surface origin is the
         * window origin, so offset both the rectangle and the
         * region appropriately.
         */
        OffsetRect(&rc, -x, -y);
        if (hrgn != NULL) {
            GreOffsetRgn(hrgn, -x, -y);
        }

    } else if (GetStyleWindow(pdce->pwndOrg, WEFLAYERED) != NULL) {
        /*
         * Layered windows can only draw to the screen via the redirection
         * DCs or UpdateLayeredWindow, so select an empty visrgn into this
         * screen DC.
         */
        if (hrgn != NULL) {
            GreSetRectRgn(hrgn, 0, 0, 0, 0);
        }
    }

    GreSetDCOrg(pdce->hdc, rc.left, rc.top, (PRECTL)&rc);

    if (fSetVisRgn) {
        GreSelectVisRgn(pdce->hdc, hrgn, SVR_DELETEOLD);
    }
}

/***************************************************************************\
* GetDC (API)
*
* Standard call to GetDC().
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
HDC _GetDC(
    PWND pwnd)
{
    /*
     * Special case for NULL: For backward compatibility we want to return
     * a window DC for the desktop that does not exclude its children.
     */
    if (pwnd == NULL) {

        PDESKTOP pdesk = PtiCurrent()->rpdesk;

        if (pdesk) {
            return _GetDCEx(pdesk->pDeskInfo->spwnd,
                            NULL,
                            DCX_WINDOW | DCX_CACHE);
        }

        /*
         * The thread has no desktop.  Fail the call.
         */
        return NULL;
    }

    return _GetDCEx(pwnd, NULL, DCX_USESTYLE);
}

/***************************************************************************\
* _ReleaseDC (API)
*
* Release the DC retrieved from GetDC().
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL _ReleaseDC(
    HDC hdc)
{
    CheckCritIn();

    return (ReleaseCacheDC(hdc, FALSE) == DCE_NORELEASE ? FALSE : TRUE);
}

/***************************************************************************\
* _GetWindowDC (API)
*
* Retrive a DC for the window.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 25-Jan-1996 ChrisWil  Allow rgnClip so that WM_NCACTIVATE can clip.
\***************************************************************************/
HDC _GetWindowDC(
    PWND pwnd)
{
    return _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
}

/***************************************************************************\
* UserSetDCVisRgn
*
* Set the visrgn for the DCE. If the window has a (hrgnClipPublic), we use
* that instead of the (hrgnClip) since it's a public-object. The other is
* created and owned by the user-thread and can't be used if say we're in the
* hung-app-drawing (different process). Both regions should be equalent in
* data.
*
* History:
* 10-Nov-1992 DavidPe   Created.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/
VOID UserSetDCVisRgn(
    PDCE pdce)
{
    HRGN hrgn = NULL;
    HRGN hrgnClipPublic;
    BOOL fTempPublic;
    PWND pwndLayer;

    /*
     * If the visrgn calculated is empt, set the flag DCX_PWNDORGINVISIBLE,
     * otherwise clear it (it could've been set earlier on).
     */
    if (!CalcVisRgn(&hrgn, pdce->pwndOrg, pdce->pwndClip, pdce->DCX_flags)) {
        pdce->DCX_flags |= DCX_PWNDORGINVISIBLE;
    } else {
        pdce->DCX_flags &= ~DCX_PWNDORGINVISIBLE;
    }


    /*
     * For redirected windows, hrgnClipPublic was offset to 0,0 in _GetDCEx()
     * because all coordinates in the DC being used are relative to the
     * bitmap and not the screen.  But the region we just got from CalcVisRgn()
     * is in screen coordinates.  So we need to offset hrgnClipPublic back into
     * screen coordinates so that we can properly intersect it.
     */
    if ((pdce->hrgnClipPublic > HRGN_SPECIAL_LAST) &&
        ((pwndLayer = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED)) != NULL)) {

        hrgnClipPublic = CreateEmptyRgnPublic();
        CopyRgn(hrgnClipPublic, pdce->hrgnClipPublic);
        GreOffsetRgn(hrgnClipPublic, pwndLayer->rcWindow.left, pwndLayer->rcWindow.top);

        fTempPublic = TRUE;
    } else {
        hrgnClipPublic = pdce->hrgnClipPublic;
        fTempPublic = FALSE;
    }


    /*
     * Deal with INTERSECTRGN and EXCLUDERGN.
     */
    if (pdce->DCX_flags & DCX_INTERSECTRGN) {

        UserAssert(hrgnClipPublic != HRGN_FULL);

        if (hrgnClipPublic == NULL) {
            SetEmptyRgn(hrgn);
        } else {
            IntersectRgn(hrgn, hrgn, hrgnClipPublic);
        }

    } else if (pdce->DCX_flags & DCX_EXCLUDERGN) {

        UserAssert(hrgnClipPublic != NULL);

        if (hrgnClipPublic == HRGN_FULL) {
            SetEmptyRgn(hrgn);
        } else {
            SubtractRgn(hrgn, hrgn, hrgnClipPublic);
        }
    }

    ResetOrg(hrgn, pdce, TRUE);

    if (fTempPublic) {
        GreDeleteObject(hrgnClipPublic);
    }
}

/***************************************************************************\
* UserGetClientRgn
*
* Return a copy of the client region and rectangle for the given hwnd.
*
* The caller must enter the user critical section before calling this function.
*
* History:
* 27-Sep-1993 WendyWu   Created.
\***************************************************************************/

HRGN UserGetClientRgn(
    HWND   hwnd,
    LPRECT lprc,
    BOOL   bWindowInsteadOfClient)
{
    HRGN hrgnClient = (HRGN)NULL;
    PWND pwnd;

    /*
     * Must be in critical section.
     */
    CheckCritIn();

    if (pwnd = ValidateHwnd(hwnd)) {

        if (bWindowInsteadOfClient) {

            /*
             * Never clip children for WO_RGN_WINDOW so that NetMeeting
             * gets the unioned window area:
             */

            CalcVisRgn(&hrgnClient,
                       pwnd,
                       pwnd,
                       DCX_WINDOW |
                       (TestWF(pwnd, WFCLIPSIBLINGS) ? DCX_CLIPSIBLINGS : 0));
        } else {
            CalcVisRgn(&hrgnClient,
                       pwnd,
                       pwnd,
                       DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);
        }

        *lprc = pwnd->rcClient;
    }

    return hrgnClient;
}

/***************************************************************************\
* UserGetHwnd
*
* Return a hwnd and the associated pwo for the given display hdc.
*
* It returns FALSE if no hwnd corresponds to the hdc is found or if the
* hwnd has incorrect styles for a device format window.
*
* The caller must enter the user critical section before calling this function.
*
* History:
* 27-Sep-1993 WendyWu   Created.
\***************************************************************************/

BOOL UserGetHwnd(
    HDC   hdc,
    HWND  *phwnd,
    PVOID *ppwo,
    BOOL  bCheckStyle)
{
    PWND pwnd;
    PDCE pdce;

    /*
     * Must be in critical section.
     */
    CheckCritIn();

    /*
     * Find pdce and pwnd for this DC.
     *
     * Note: the SAMEHANDLE macro strips out the user defined bits in the
     * handle before doing the comparison.  This is important because when
     * GRE calls this function, it may have lost track of the OWNDC bit.
     */
    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

        if (pdce->hdc == hdc) // this should be undone once SAMEHANDLE is fixed for kmode
            break;
    }

    /*
     * Return FALSE If it is not in the pdce list.
     */
    if ((pdce == NULL) || (pdce->pwndOrg == NULL))
        return FALSE;

    pwnd = pdce->pwndOrg;

    /*
     * The window style must be clipchildren and clipsiblings.
     * the window's class must not be parentdc
     */
    if (bCheckStyle) {

        if (    !TestWF(pwnd, WFCLIPCHILDREN) ||
                !TestWF(pwnd, WFCLIPSIBLINGS) ||
                TestCF(pwnd, CFPARENTDC)) {

            RIPMSG0(RIP_WARNING, "UserGetHwnd: Bad OpenGL window style or class");
            return FALSE;
        }
    }

    /*
     * Return the hwnd with the correct styles for a device format window.
     */
    *phwnd = HW(pwnd);
    *ppwo  = _GetProp(pwnd, PROP_WNDOBJ, TRUE);

    return TRUE;
}

/***************************************************************************\
* UserAssociateHwnd
*
* Associate a gdi WNDOBJ with hwnd.  The caller must enter the user
* critical section before calling this function.
*
* If 'pwo' is NULL, the association is removed.
*
* History:
* 13-Jan-1994 HockL     Created.
\***************************************************************************/

VOID UserAssociateHwnd(
    HWND  hwnd,
    PVOID pwo)
{
    PWND pwnd;

    /*
     * Must be in critical section.
     */
    CheckCritIn();

    if (pwnd = ValidateHwnd(hwnd)) {

        if (pwo != NULL) {
            if (InternalSetProp(pwnd, PROP_WNDOBJ, pwo, PROPF_INTERNAL | PROPF_NOPOOL))
                gcountPWO++;
        } else {
            if (InternalRemoveProp(pwnd, PROP_WNDOBJ, TRUE))
                gcountPWO--;
        }
    }
}

/***************************************************************************\
* UserReleaseDC
*
* Enter's the critical section and calls _ReleaseDC.
*
* History:
* 25-Jan-1996 ChrisWil  Created comment block.
\***************************************************************************/

BOOL UserReleaseDC(
    HDC hdc)
{
    BOOL b;

    EnterCrit();
    b = _ReleaseDC(hdc);
    LeaveCrit();

    return b;
}

/***************************************************************************\
* InvalidateDce
*
* If the DCE is not in use, removes all information and marks it invalid.
* Otherwise, it resets the DCE flags based on the window styles and
* recalculates the vis rgn.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID InvalidateDce(
    PDCE pdce)
{
    GreLockDisplay(gpDispInfo->hDev);

    if (!(pdce->DCX_flags & DCX_INUSE)) {

        /*
         * Accumulate any bounds for this CE
         * since we're about to mark it invalid.
         */
        SpbCheckDce(pdce);

        MarkDCEInvalid(pdce);

        pdce->pwndOrg        = NULL;
        pdce->pwndClip       = NULL;
        pdce->hrgnClip       = NULL;
        pdce->hrgnClipPublic = NULL;

        /*
         * Remove the vis rgn since it is still owned - if we did not,
         * gdi would not be able to clean up properly if the app that
         * owns this vis rgn exist while the vis rgn is still selected.
         */
        GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);

    } else {

        PWND pwndOrg  = pdce->pwndOrg;
        PWND pwndClip = pdce->pwndClip;

        /*
         * In case the window's clipping style bits changed,
         * reset the DCE flags from the window style bits.
         * Note that minimized windows never exclude their children.
         */
        pdce->DCX_flags &= ~(DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);

        /*
         * Chicago stuff...
         */
        if (TestCF(pwndOrg, CFPARENTDC) &&
            (TestWF(pwndOrg, WFWIN31COMPAT) || !TestWF(pwndClip, WFCLIPCHILDREN)) &&
            (TestWF(pwndOrg, WFVISIBLE) == TestWF(pwndClip, WFVISIBLE))) {

            if (TestWF(pwndClip, WFCLIPSIBLINGS))
                pdce->DCX_flags |= DCX_CLIPSIBLINGS;

        } else {

            if (TestWF(pwndOrg, WFCLIPCHILDREN) && !TestWF(pwndOrg, WFMINIMIZED))
                pdce->DCX_flags |= DCX_CLIPCHILDREN;

            if (TestWF(pwndOrg, WFCLIPSIBLINGS))
                pdce->DCX_flags |= DCX_CLIPSIBLINGS;
        }

        /*
         * Mark that any saved visrgn needs to be recomputed.
         */
        pdce->DCX_flags |= DCX_SAVEDRGNINVALID;

        UserSetDCVisRgn(pdce);
    }

    GreUnlockDisplay(gpDispInfo->hDev);
}

/***************************************************************************\
* DeleteHrgnClip
*
* Deletes the clipping regions in the DCE, restores the saved visrgn,
* and invalidates the DCE if saved visrgn is invalid.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID DeleteHrgnClip(
    PDCE pdce)
{
    /*
     * Clear these flags first in case we get a DCHook() callback...
     */
    pdce->DCX_flags &= ~(DCX_EXCLUDERGN | DCX_INTERSECTRGN);

    /*
     * Blow away pdce->hrgnClip and clear the associated flags.
     * Do not delete hrgnClip if DCX_NODELETERGN is set!
     */
    if (!(pdce->DCX_flags & DCX_NODELETERGN)) {
        DeleteMaybeSpecialRgn(pdce->hrgnClip);
    } else {
        pdce->DCX_flags &= ~DCX_NODELETERGN;
    }

    DeleteMaybeSpecialRgn(pdce->hrgnClipPublic);

    pdce->hrgnClip       = NULL;
    pdce->hrgnClipPublic = NULL;

    /*
     * If the saved visrgn was invalidated by an InvalidateDce()
     * while we had it checked out, then invalidate the entry now.
     */
    if (pdce->DCX_flags & DCX_SAVEDRGNINVALID) {
        InvalidateDce(pdce);

        /*
         * We've just gone through InvalidateDce, so the visrgn in the
         * DC has been properly reset. Simply nuke the old saved visrgn.
         */
        if (pdce->hrgnSavedVis != NULL) {
            GreDeleteObject(pdce->hrgnSavedVis);
            pdce->hrgnSavedVis = NULL;
        }
    } else {
        /*
         * The saved visrgn is still valid, select it back into the
         * DC so the entry may be re-used without recomputing.
         */
        if (pdce->hrgnSavedVis != NULL) {
            GreSelectVisRgn(pdce->hdc, pdce->hrgnSavedVis, SVR_DELETEOLD);
            pdce->hrgnSavedVis = NULL;
        }
    }
}

/***************************************************************************\
* GetDCEx (API)
*
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

HDC _GetDCEx(
    PWND  pwnd,
    HRGN  hrgnClip,
    DWORD DCX_flags)
{
    HRGN  hrgn;
    HDC   hdcMatch;
    PWND  pwndClip;
    PWND  pwndOrg;
    PDCE  pdce;
    PDCE  *ppdce;
    PDCE  *ppdceNotInUse;
    DWORD DCX_flagsMatch;
    BOOL  bpwndOrgVisible;
    PWND  pwndLayer;
    HBITMAP hbmLayer;
    BOOL  fVisRgnError = FALSE;

    /*
     * Lock the device while we're playing with visrgns.
     */
    GreLockDisplay(gpDispInfo->hDev);

    if (pwnd == NULL)
        pwnd = PtiCurrent()->rpdesk->pDeskInfo->spwnd;

    hdcMatch = NULL;
    pwndOrg  = pwndClip = pwnd;

    bpwndOrgVisible = IsVisible(pwndOrg);

    if (PpiCurrent()->W32PF_Flags & W32PF_OWNDCCLEANUP) {
        DelayedDestroyCacheDC();
    }

    /*
     * If necessary, compute DCX flags from window style.
     */
    if (DCX_flags & DCX_USESTYLE) {

        DCX_flags &= ~(DCX_CLIPSIBLINGS | DCX_CLIPCHILDREN | DCX_PARENTCLIP);

        if (!(DCX_flags & DCX_WINDOW)) {

            if (TestCF(pwndOrg, CFPARENTDC))
                DCX_flags |= DCX_PARENTCLIP;

            /*
             * If the DCX_CACHE flag is present, override OWNDC/CLASSDC.
             * Otherwise, calculate from appropriate style bits.
             */
            if (!(DCX_flags & DCX_CACHE) && !TestCF(pwndOrg, CFOWNDC)) {
                if (TestCF(pwndOrg, CFCLASSDC)) {
                    /*
                     * Look for a non-cache entry that matches hdc...
                     */
                    if (pwndOrg->pcls->pdce != NULL) {
                        hdcMatch = pwndOrg->pcls->pdce->hdc;
                    }
                } else {
                    DCX_flags |= DCX_CACHE;
                }
            }

            if (TestWF(pwndOrg, WFCLIPCHILDREN))
                DCX_flags |= DCX_CLIPCHILDREN;

            if (TestWF(pwndOrg, WFCLIPSIBLINGS))
                DCX_flags |= DCX_CLIPSIBLINGS;

            /*
             * Minimized windows never exclude their children.
             */
            if (TestWF(pwndOrg, WFMINIMIZED)) {
                DCX_flags &= ~DCX_CLIPCHILDREN;

                if (pwndOrg->pcls->spicn)
                    DCX_flags |= DCX_CACHE;
            }

        } else {
            if (TestWF(pwndClip, WFCLIPSIBLINGS))
                DCX_flags |= DCX_CLIPSIBLINGS;

            DCX_flags |= DCX_CACHE;

            /*
             * Window DCs never exclude children.
             */
        }
    }

    /*
     * Deal with all the Win 3.0-compatible clipping rules:
     *
     * DCX_NOCLIPCHILDREN overrides:
     *      DCX_PARENTCLIP/CS_OWNDC/CS_CLASSDC
     * DCX_PARENTCLIP overrides:
     *      DCX_CLIPSIBLINGS/DCX_CLIPCHILDREN/CS_OWNDC/CS_CLASSDC
     */
    if (DCX_flags & DCX_NOCLIPCHILDREN) {
        DCX_flags &= ~(DCX_PARENTCLIP | DCX_CLIPCHILDREN);
        DCX_flags |= DCX_CACHE;
    }

    /*
     * Deal with layered windows.
     */
    if ((pwndLayer = GetStyleWindow(pwndOrg, WEFPREDIRECTED)) != NULL &&
            (hbmLayer = GetRedirectionBitmap(pwndLayer)) != NULL) {

        /*
         * Get a layered redirection DC.
         */
        DCX_flags |= DCX_REDIRECTED;

        /*
         * When the window we're getting the DC for is the layered and
         * redirected window, don't allow to clip to its parent, since
         * clipping must not exceed the size of the backing bitmap.
         */
        if (pwndOrg == pwndLayer) {
            DCX_flags &= ~DCX_PARENTCLIP;
        }

        /*
         * Convert hrgnClip from screen to the redirection DC coordinates.
         */
        if (hrgnClip > HRGN_SPECIAL_LAST) {

            if (DCX_flags & DCX_NODELETERGN) {

                HRGN hrgnClipSave = hrgnClip;
                hrgnClip = CreateEmptyRgnPublic();
                CopyRgn(hrgnClip, hrgnClipSave);
                DCX_flags &= ~DCX_NODELETERGN;
            }

            GreOffsetRgn(hrgnClip, -pwndLayer->rcWindow.left,
                    -pwndLayer->rcWindow.top);
        }
    } else {
        pwndLayer = NULL;
        hbmLayer = NULL;
    }

    if (DCX_flags & DCX_PARENTCLIP) {

        PWND pwndParent;

        /*
         * If this window has no parent.  This can occur if the app is
         * calling GetDC in response to a CBT_CREATEWND callback.  In this
         * case, the parent is not yet setup.
         */
        if (pwndOrg->spwndParent == NULL)
            pwndParent = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
        else
            pwndParent = pwndOrg->spwndParent;

        /*
         * Always get the DC from the cache.
         */
        DCX_flags |= DCX_CACHE;

        /*
         * We can't use a shared DC if the visibility of the
         * child does not match the parent's, or if a
         * CLIPSIBLINGS or CLIPCHILDREN DC is requested.
         *
         * In 3.1, we pay attention to the CLIPSIBLINGS and CLIPCHILDREN
         * bits of CS_PARENTDC windows, by overriding CS_PARENTDC if
         * either of these flags are requested.
         *
         * BACKWARD COMPATIBILITY HACK
         *
         * If parent is CLIPCHILDREN, get a cache DC, but don't
         * use parent's DC.  Windows PowerPoint depends on this
         * behavior in order to draw the little gray rect between
         * its scroll bars correctly.
         */
        if (!(DCX_flags & (DCX_CLIPSIBLINGS | DCX_CLIPCHILDREN)) &&
                (TestWF(pwndOrg, WFWIN31COMPAT) || !TestWF(pwndParent, WFCLIPCHILDREN)) &&
                TestWF(pwndParent, WFVISIBLE) == TestWF(pwndOrg, WFVISIBLE)) {

            pwndClip = pwndParent;

#if DBG
            if (DCX_flags & DCX_CLIPCHILDREN)
                RIPMSG0(RIP_WARNING, "WS_CLIPCHILDREN overridden by CS_PARENTDC");
            if (DCX_flags & DCX_CLIPSIBLINGS)
                RIPMSG0(RIP_WARNING, "WS_CLIPSIBLINGS overridden by CS_PARENTDC");
#endif
            /*
             * Make sure flags reflect hwndClip rather than hwndOrg.
             * But, we must never clip the children (since that's who
             * wants to do the drawing!)
             */
            DCX_flags &= ~(DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);
            if (TestWF(pwndClip, WFCLIPSIBLINGS))
                DCX_flags |= DCX_CLIPSIBLINGS;
        }
    }

    /*
     * Make sure we don't return an OWNDC if the calling thread didn't
     * create this window - need to returned cached always in this case.
     *
     * Win95 does not contain this code.  Why?
     */
    if (!(DCX_flags & DCX_CACHE)) {
        if (pwndOrg == NULL || GETPTI(pwndOrg) != PtiCurrent())
            DCX_flags |= DCX_CACHE;
    }

    DCX_flagsMatch = DCX_flags & DCX_MATCHMASK;

    if (!(DCX_flags & DCX_CACHE)) {

        /*
         * Handle CS_OWNDC and CS_CLASSDC cases specially.  Based on the
         * supplied match information, we need to find the appropriate DCE.
         */
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

            if (pdce->DCX_flags & DCX_CACHE)
                continue;

            /*
             * Look for the entry that matches hdcMatch or pwndOrg...
             */
            if (!(pdce->pwndOrg == pwndOrg || pdce->hdc == hdcMatch))
                continue;

            /*
             * NOTE: The "Multiple-BeginPaint()-of-OWNDC-Window" Conundrum
             *
             * There is a situation having to do with OWNDC or CLASSDC window
             * DCs that can theoretically arise that is handled specially
             * here and in ReleaseCacheDC().  These DCs are identified with
             * the DCX_CACHE bit CLEAR.
             *
             * In the case where BeginPaint() (or a similar operation) is
             * called more than once without an intervening EndPaint(), the
             * DCX_INTERSECTRGN (or DCX_EXCLUDERGN) bit may already be set
             * when we get here.
             *
             * Theoretically, the correct thing to do is to save the current
             * hrgnClip, and set up the new one here.  In ReleaseCacheDC, the
             * saved hrgnClip is restored and the visrgn recomputed.
             *
             * All of this is only necessary if BOTH calls involve an
             * hrgnClip that causes the visrgn to be changed (i.e., the
             * simple hrgnClip test clears the INTERSECTRGN or EXCLUDERGN bit
             * fails), which is not at all likely.
             *
             * When this code encounters this multiple-BeginPaint case it
             * punts by honoring the new EXCLUDE/INTERSECTRGN bits, but it
             * first restores the DC to a wide-open visrgn before doing so.
             * This means that the first EndPaint() will restore the visrgn
             * to a wide-open DC, rather than clipped to the first
             * BeginPaint()'s update rgn.  This is a good punt, because worst
             * case an app does a bit more drawing than it should.
             */
            if ((pdce->DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN)) &&
                    (DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN))) {

                RIPMSG0(RIP_WARNING, "Nested BeginPaint() calls, please fix Your app!");
                DeleteHrgnClip(pdce);
            }

            if (pdce->DCX_flags & DCX_REDIRECTED) {
                /*
                 * We're giving out the same DC again. Since it may not have
                 * been released, transfer any accumulated bits if needed.
                 */
                UpdateRedirectedDC(pdce);

                /*
                 * As this point, the DC may get converted back to a screen
                 * DC, so we must select the screen surface back into the DC.
                 */
                UserVerify(GreSelectRedirectionBitmap(pdce->hdc, NULL));
            }

            /*
             * If we matched exactly, no recomputation necessary
             * (we found a CS_OWNDC or a CS_CLASSDC that is already set up)
             * Otherwise, we have a CS_CLASSDC that needs recomputation.
             */
            if (    pdce->pwndOrg == pwndOrg &&
                    bpwndOrgVisible &&
                    (pdce->DCX_flags & DCX_REDIRECTED) == (DCX_flags & DCX_REDIRECTED) &&
                    !(pdce->DCX_flags & DCX_PWNDORGINVISIBLE)) {

                goto HaveComputedEntry;
            }

            goto RecomputeEntry;
        }

        RIPMSG1(RIP_WARNING, "Couldn't find DC for %p - bad code path", pwndOrg);

NullExit:

        GreUnlockDisplay(gpDispInfo->hDev);
        return NULL;

    } else {

        /*
         * Make a quick pass through the cache, looking for an
         * exact match.
         */
SearchAgain:

#if DBG
        if (fDisableCache) {
            goto SearchFailed;
        }
#endif

        /*
         * CONSIDER (adams): Put this check into the loop above so we don't
         * touch all these pages twice?
         */
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

            /*
             * If we find an entry that is not in use and whose clip flags
             * and clip window match, we can use it.
             *
             * NOTE: DCX_INTERSECT/EXCLUDERGN cache entries always have
             * DCX_INUSE set, so we'll never erroneously match one here.
             */
            UserAssert(!(pdce->DCX_flags & (DCX_INTERSECTRGN | DCX_EXCLUDERGN)) ||
                       (pdce->DCX_flags & DCX_INUSE));

            if ((pdce->pwndClip == pwndClip) &&
                pdce->pMonitor == NULL &&
                (DCX_flagsMatch == (pdce->DCX_flags & (DCX_MATCHMASK | DCX_INUSE | DCX_INVALID)))) {

                /*
                 * Special case for icon - bug 9103 (win31)
                 */
                if (TestWF(pwndClip, WFMINIMIZED) &&
                    (pdce->pwndOrg != pdce->pwndClip)) {
                    continue;
                }

                /*
                 * If the pwndOrg of the DC we found is not visible and
                 * the pwndOrg we're looking for is visble, then
                 * the visrgn is no good, we can't reuse it so keep
                 * looking.
                 */
                if (bpwndOrgVisible && pdce->DCX_flags & DCX_PWNDORGINVISIBLE) {
                    continue;
                }

                /*
                 * Set INUSE before performing any GDI operations, just
                 * in case DCHook() has a mind to recalculate the visrgn...
                 */
                pdce->DCX_flags |= DCX_INUSE;

                /*
                 * We found an entry with the proper visrgn.
                 * If the origin doesn't match, update the CE and reset it.
                 */
                if (pwndOrg != pdce->pwndOrg) {
                    /*
                     * Need to flush any dirty rectangle stuff now.
                     */
                    SpbCheckDce(pdce);

                    pdce->pwndOrg = pwndOrg;
                    ResetOrg(NULL, pdce, FALSE);
                }

                goto HaveComputedEntry;
            }
        }

#if DBG
SearchFailed:
#endif

        /*
         * Couldn't find an exact match.  Find some invalid or non-inuse
         * entry we can reuse.
         */
        ppdceNotInUse = NULL;
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

            /*
             * Skip non-cache entries
             */
            if (!(pdce->DCX_flags & DCX_CACHE))
                continue;

            /*
             * Skip monitor-specific entires
             */
            if (pdce->pMonitor != NULL)
                continue;

            if (pdce->DCX_flags & DCX_INVALID) {
                break;
            } else if (!(pdce->DCX_flags & DCX_INUSE)) {

                /*
                 * Remember the non-inuse one, but keep looking for an invalid.
                 */
                ppdceNotInUse = ppdce;
            }
        }

        /*
         * If we broke out of the loop, we found an invalid entry to reuse.
         * Otherwise see if we found a non-inuse entry to reuse.
         */
        if (pdce == NULL && ((ppdce = ppdceNotInUse) == NULL)) {

            /*
             * Create another DCE if we need it.
             */
            if (!CreateCacheDC(pwndOrg,
                               DCX_INVALID | DCX_CACHE |
                               (DCX_flags & DCX_REDIRECTED),
                               NULL)) {
                goto NullExit;
            }

            goto SearchAgain;
        }

        /*
         * We've chosen an entry to reuse: now fill it in and recompute it.
         */
        pdce = *ppdce;

RecomputeEntry:

        /*
         * Any non-invalid entries that we reuse might still have some bounds
         * that need to be used to invalidate SPBs.  Apply them here.
         */
        if (!(pdce->DCX_flags & DCX_INVALID))
            SpbCheckDce(pdce);

        /*
         * We want to compute only the matchable visrgn at first,
         * so we don't set up hrgnClip, or set the EXCLUDERGN or INTERSECTRGN
         * bits yet -- we'll deal with those later.
         */
        pdce->DCX_flags = DCX_flagsMatch | DCX_INUSE;

#if DBG || defined(PRERELEASE)
        /*
         * We're about to select the visrgn into the DC, even though it's
         * not yet completely setup. Turn off the visrgn validation for now.
         * It will be turned on before this function returns.
         */
        GreValidateVisrgn(pdce->hdc, FALSE);
#endif

        /*
         * Now recompute the visrgn (minus any hrgnClip shenanigans)
         */
        if (TestWF(pwndOrg, WEFPREDIRECTED)) {
            DCX_flagsMatch |= DCX_REDIRECTEDBITMAP;
        }


        hrgn = NULL;
        if (CalcVisRgn(&hrgn, pwndOrg, pwndClip, DCX_flagsMatch) == FALSE) {
            pdce->DCX_flags |= DCX_PWNDORGINVISIBLE;
        }

        pdce->pwndOrg        = pwndOrg;
        pdce->pwndClip       = pwndClip;
        pdce->hrgnClip       = NULL;      // Just in case...
        pdce->hrgnClipPublic = NULL;

        ResetOrg(hrgn, pdce, TRUE);

        if (hrgn == NULL) {
            fVisRgnError = TRUE;
        }

        /*
         * When we arrive here, pdce (and *ppdce) point to
         * a cache entry whose visrgn and origin are set up.
         * All that remains to be done is to deal with EXCLUDE/INTERSECTRGN
         */
HaveComputedEntry:

        /*
         * If the window clipping flags have changed in the window
         * since the last time this dc was invalidated, then recompute
         * this dc entry.
         */
        if ((pdce->DCX_flags & DCX_MATCHMASK) != (DCX_flags & DCX_MATCHMASK))
            goto RecomputeEntry;

        /*
         * Let's check these assertions just in case...
         */
        UserAssert(pdce);
        UserAssert(*ppdce == pdce);
        UserAssert(pdce->DCX_flags & DCX_INUSE);
        UserAssert(!(pdce->DCX_flags & DCX_INVALID));
        UserAssert((pdce->DCX_flags & DCX_MATCHMASK) == (DCX_flags & DCX_MATCHMASK));

        /*
         * Move the dce to the head of the list so it's easy to find later.
         */
        if (pdce != gpDispInfo->pdceFirst) {
            *ppdce = pdce->pdceNext;
            pdce->pdceNext = gpDispInfo->pdceFirst;
            gpDispInfo->pdceFirst = pdce;
        }

#if DBG || defined(PRERELEASE)
        /*
         * We're about to mess with the visrgn in this DC, even though it's
         * not yet completely setup. Turn off the visrgn validation for now.
         * It will be turned on before this function returns.
         */
         GreValidateVisrgn(pdce->hdc, FALSE);
#endif

        /*
         * Time to deal with DCX_INTERSECTRGN or DCX_EXCLUDERGN.
         *
         * We handle these two bits specially, because cache entries
         * with these bits set cannot be reused with the bits set.  This
         * is because the area described in hrgnClip would have to be
         * compared along with the bit, which is a pain, especially since
         * they'd never match very often anyhow.
         *
         * What we do instead is to save the visrgn of the window before
         * applying either of these two flags, which is then restored
         * at ReleaseCacheDC() time, along with the clearing of these bits.
         * This effectively converts a cache entry with either of these
         * bits set into a "normal" cache entry that can be matched.
         */
        if (DCX_flags & DCX_INTERSECTRGN) {

            if (hrgnClip != HRGN_FULL) {

                SetEmptyRgn(ghrgnGDC);

                /*
                 * Save the visrgn for reuse on ReleaseDC().
                 * (do this BEFORE we set hrgnClip & pdce->flag bit,
                 * so that if a DCHook() callback occurs it recalculates
                 * without hrgnClip)
                 */
                UserAssertMsg0(!pdce->hrgnSavedVis,
                               "Nested SaveVisRgn attempt in _GetDCEx");

                /*
                 * get the current vis region into hrgnSavedVis.  Temporarily
                 * store a dummy one in the DC.
                 */

                pdce->hrgnSavedVis = CreateEmptyRgn();

                GreSelectVisRgn(pdce->hdc,pdce->hrgnSavedVis, SVR_SWAP);

                pdce->hrgnClip = hrgnClip;

                if (DCX_flags & DCX_NODELETERGN)
                    pdce->DCX_flags |= DCX_NODELETERGN;

                pdce->DCX_flags |= DCX_INTERSECTRGN;

                if (hrgnClip == NULL) {

                    pdce->hrgnClipPublic = NULL;

                } else {

                    IntersectRgn(ghrgnGDC, pdce->hrgnSavedVis, hrgnClip);

                    /*
                     * Make a copy of the hrgnClip and make it public
                     * so that we can use it in calculations in HungDraw.
                     */
                    pdce->hrgnClipPublic = CreateEmptyRgnPublic();
                    CopyRgn(pdce->hrgnClipPublic, hrgnClip);
                }

                /*
                 * Clear the SAVEDRGNINVALID bit, since we're just
                 * about to set it properly now.  If the dce later
                 * gets invalidated, it'll set this bit so we know
                 * to recompute it when we restore the visrgn.
                 */
                pdce->DCX_flags &= ~DCX_SAVEDRGNINVALID;

                /*
                 * Select in the new region.  we use the SWAP_REGION mode
                 * so that ghrgnGDC always has a valid rgn
                 */

                GreSelectVisRgn(pdce->hdc, ghrgnGDC, SVR_SWAP);
            }
        } else if (DCX_flags & DCX_EXCLUDERGN) {

            if (hrgnClip != NULL) {

                SetEmptyRgn(ghrgnGDC);

                /*
                 * Save the visrgn for reuse on ReleaseDC().
                 * (do this BEFORE we set hrgnClip & pdce->flag bit,
                 * so that if a DCHook() callback occurs it recalculates
                 * without hrgnClip)
                 */
                UserAssertMsg0(!pdce->hrgnSavedVis,
                               "Nested SaveVisRgn attempt in _GetDCEx");

                /*
                 * get the current vis region into hrgnSavedVis.  Temporarily
                 * store a dummy one in the DC.
                 */
                pdce->hrgnSavedVis = CreateEmptyRgn();

                GreSelectVisRgn(pdce->hdc,pdce->hrgnSavedVis, SVR_SWAP);

                pdce->hrgnClip = hrgnClip;

                if (DCX_flags & DCX_NODELETERGN)
                    pdce->DCX_flags |= DCX_NODELETERGN;

                pdce->DCX_flags |= DCX_EXCLUDERGN;

                if (hrgnClip == HRGN_FULL) {

                    pdce->hrgnClipPublic = HRGN_FULL;

                } else {

                    SubtractRgn(ghrgnGDC, pdce->hrgnSavedVis, hrgnClip);

                    /*
                     * Make a copy of the hrgnClip and make it public
                     * so that we can use it in calculations in HungDraw.
                     */
                    pdce->hrgnClipPublic = CreateEmptyRgnPublic();
                    CopyRgn(pdce->hrgnClipPublic, hrgnClip);
                }

                /*
                 * Clear the SAVEDRGNINVALID bit, since we're just
                 * about to set it properly now.  If the dce later
                 * gets invalidated, it'll set this bit so we know
                 * to recompute it when we restore the visrgn.
                 */
                pdce->DCX_flags &= ~DCX_SAVEDRGNINVALID;

                /*
                 * Select in the new region.  we use the SWAP_REGION mode
                 * so that ghrgnGDC always has a valid rgn
                 */

                GreSelectVisRgn(pdce->hdc, ghrgnGDC, SVR_SWAP);
            }
        }
    }

    if (pdce->DCX_flags & DCX_REDIRECTED) {
        UserAssert(pwndLayer != NULL);
        UserAssert(hbmLayer != NULL);

        UserVerify(GreSelectRedirectionBitmap(pdce->hdc, hbmLayer));

        /*
         * Enable bounds accumulation, so we know if there was any drawing
         * done into that DC and the actual rect we need to update when
         * this DC is released.
         */
        GreGetBounds(pdce->hdc, NULL, GGB_ENABLE_WINMGR);

        /*
         * In case the visrgn couldn't be allocated, clear it in the
         * dc again, since we just selected a new surface.
         */
        if (fVisRgnError) {
            GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);
        }
    }

    /*
     * Whew! Set ownership and return the bloody DC.
     * Only set ownership for cache dcs.  Own dcs have already been owned.
     * The reason why we don't want to set the ownership over again is
     * because the console sets its owndcs to PUBLIC so gdisrv can use
     * them without asserting.  We don't want to set the ownership back
     * again.
     */
    if (pdce->DCX_flags & DCX_CACHE) {

        if (!GreSetDCOwner(pdce->hdc, OBJECT_OWNER_CURRENT)) {
            RIPMSG1(RIP_WARNING, "GetDCEx: SetDCOwner Failed %lX", pdce->hdc);
        }

        /*
         * Decrement the Free DCE Count.  This should always be >= 0,
         * since we'll create a new dce if the cache is all in use.
         */
        DecrementFreeDCECount();

        pdce->ptiOwner = PtiCurrent();
    }

    if (TestWF(pwnd, WEFLAYOUTRTL) && !(DCX_flags & DCX_NOMIRROR)) {
        GreSetLayout(pdce->hdc, -1, LAYOUT_RTL);
    }

#if DBG || defined(PRERELEASE)
    GreValidateVisrgn(pdce->hdc, TRUE);
#endif

    GreUnlockDisplay(gpDispInfo->hDev);

    return pdce->hdc;
}

/***************************************************************************\
* ReleaseCacheDC
*
* Releases a DC from the cache.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

UINT ReleaseCacheDC(
    HDC  hdc,
    BOOL fEndPaint)
{
    PDCE pdce;
    PDCE *ppdce;

    for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

        if (pdce->hdc == hdc) {

            /*
             * Check for redundant releases or release of an invalid entry
             */
            if ((pdce->DCX_flags & (DCX_DESTROYTHIS | DCX_INVALID | DCX_INUSE)) != DCX_INUSE)
                return DCE_NORELEASE;

            /*
             * Lock the display since we may be playing with visrgns.
             */
            GreLockDisplay(gpDispInfo->hDev);

            if (pdce->DCX_flags & DCX_REDIRECTED) {
                UpdateRedirectedDC(pdce);
            }

            /*
             * If this is a permanent DC, then don't reset its state.
             */
            if (pdce->DCX_flags & DCX_CACHE) {
                /*
                 * Restore the DC state and mark the entry as not in use.
                 * Set owner back to server as well, since it's going back
                 * into the cache.
                 */
                if (!(pdce->DCX_flags & DCX_NORESETATTRS)) {
                    /*
                     * If bSetupDC() failed, the DC is busy (ie. in-use
                     * by another thread), so don't release it.
                     */
                    if ( (!(GreCleanDC(hdc))) ||
                         (!(GreSetDCOwner(hdc, OBJECT_OWNER_NONE))) ) {

                        GreUnlockDisplay(gpDispInfo->hDev);
                        return DCE_NORELEASE;
                    }

                } else if (!GreSetDCOwner(pdce->hdc, OBJECT_OWNER_NONE)) {

                    GreUnlockDisplay(gpDispInfo->hDev);
                    return DCE_NORELEASE;
                }

                pdce->ptiOwner  = NULL;
                pdce->DCX_flags    &= ~DCX_INUSE;

#if DBG || defined(PRERELEASE)
                /*
                 * Turn off checked only surface validation for now, since
                 * we may select a different surface (screen) in this DC that
                 * may not correspond to the visrgn currently in the DC. When
                 * the DC is given out again, it will be revalidated.
                 */
                GreValidateVisrgn(pdce->hdc, FALSE);
#endif

                /*
                 * The DC is no longer in use, so unselect the redirection
                 * bitmap from it.
                 */
                if (pdce->DCX_flags & DCX_REDIRECTED) {
                    UserVerify(GreSelectRedirectionBitmap(pdce->hdc, NULL));
                }

                /*
                 * Increment the Free DCE count.  This holds the count
                 * of available DCEs.  Check the threshold, and destroy
                 * the dce if it's above the mark.
                 */
                IncrementFreeDCECount();

                if (gnDCECount > DCE_SIZE_CACHETHRESHOLD) {
                    if (DestroyCacheDC(ppdce, pdce->hdc)) {
                        GreUnlockDisplay(gpDispInfo->hDev);
                        return DCE_FREED;
                    }
                }
            }

            /*
             * If we have an EXCLUDERGN or INTERSECTRGN cache entry,
             * convert it back to a "normal" cache entry by restoring
             * the visrgn and blowing away hrgnClip.
             *
             * Note that for non-DCX_CACHE DCs, we only do this if
             * we're being called from EndPaint().
             */
            if ((pdce->DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN)) &&
                    ((pdce->DCX_flags & DCX_CACHE) || fEndPaint)) {
                DeleteHrgnClip(pdce);
            }

            GreUnlockDisplay(gpDispInfo->hDev);
            return DCE_RELEASED;
        }
    }

    /*
     * Yell if DC couldn't be found...
     */
    RIPERR1(ERROR_DC_NOT_FOUND, RIP_WARNING,
            "Invalid device context (DC) handle passed to ReleaseCacheDC (0x%08lx)", hdc);

    return DCE_NORELEASE;
}

/***************************************************************************\
* CreateCacheDC
*
* Creates a DCE and adds it to the cache.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

HDC CreateCacheDC(
        PWND  pwndOrg,
        DWORD DCX_flags,
        PMONITOR pMonitor
        )
{
    PDCE pdce;
    HDC  hdc;
    HANDLE hDev;

    if ((pdce = (PDCE)UserAllocPool(sizeof(DCE), TAG_DCE)) == NULL)
        return NULL;

    if (pMonitor == NULL) {
        hDev = gpDispInfo->hDev;
    } else {
        hDev = pMonitor->hDev;
    }

    if ((hdc = GreCreateDisplayDC(hDev, DCTYPE_DIRECT, FALSE)) == NULL) {
        UserFreePool(pdce);
        return NULL;
    }

    /*
     * Link this entry into the cache entry list.
     */
    pdce->pdceNext      = gpDispInfo->pdceFirst;
    gpDispInfo->pdceFirst = pdce;

    pdce->hdc            = hdc;
    pdce->DCX_flags      = DCX_flags;
    pdce->pwndOrg        = pwndOrg;
    pdce->pwndClip       = pwndOrg;
    pdce->hrgnClip       = NULL;
    pdce->hrgnClipPublic = NULL;
    pdce->hrgnSavedVis   = NULL;
    pdce->pMonitor       = pMonitor;

    /*
     * Mark it as undeleteable so no application can delete it out of our
     * cache!
     */
    GreMarkUndeletableDC(hdc);

    if (DCX_flags & DCX_OWNDC) {

        /*
         * Set the ownership of owndcs immediately: that way console can set
         * the owernship to PUBLIC when it calls GetDC so that both the input
         * thread and the service threads can use the same owndc.
         */
        GreSetDCOwner(hdc, OBJECT_OWNER_CURRENT);
        pdce->ptiOwner = PtiCurrent();

    } else {

        /*
         * Otherwise it is a cache dc...  set its owner to none - nothing
         * is using it - equivalent of "being in the cache" but unaccessible
         * to other processes.
         */
        GreSetDCOwner(hdc, OBJECT_OWNER_NONE);
        pdce->ptiOwner = NULL;

        /*
         * Increment the available-cacheDC count.  Once this hits our
         * threshold, then we can free-up some of the entries.
         */
        IncrementFreeDCECount();
    }

    /*
     * If we're creating a permanent DC, then compute it now.
     */
    if (!(DCX_flags & DCX_CACHE)) {

        /*
         * Set up the class DC now...
         */
        if (TestCF(pwndOrg, CFCLASSDC))
            pwndOrg->pcls->pdce = pdce;

        /*
         * Finish setting up DCE and force eventual visrgn calculation.
         */
        UserAssert(!(DCX_flags & DCX_WINDOW));

        pdce->DCX_flags |= DCX_INUSE;

        InvalidateDce(pdce);
    }

    /*
     * If there are any spb's around then enable bounds accumulation.
     */
    if (AnySpbs())
        GreGetBounds(pdce->hdc, NULL, DCB_ENABLE | DCB_SET | DCB_WINDOWMGR);

    return pdce->hdc;
}

/***************************************************************************\
* WindowFromCacheDC
*
* Returns the window associated with a DC.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND WindowFromCacheDC(
    HDC hdc)
{
    PDCE pdce;
    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (pdce->hdc == hdc)
            return (pdce->DCX_flags & DCX_DESTROYTHIS) ? NULL : pdce->pwndOrg;
    }

    return NULL;
}

/***************************************************************************\
* DelayedDestroyCacheDC
*
* Destroys DCE's which have been partially destroyed.
*
* History:
* 16-Jun-1992 DavidPe   Created.
\***************************************************************************/

VOID DelayedDestroyCacheDC(VOID)
{
    PDCE *ppdce;
    PDCE pdce;


    /*
     * Zip through the cache looking for a DCX_DESTROYTHIS hdc.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        /*
         * If we found a DCE on this thread that we tried to destroy
         * earlier, try and destroy it again.
         */
        pdce = *ppdce;

        if (pdce->DCX_flags & DCX_DESTROYTHIS)
            DestroyCacheDC(ppdce, pdce->hdc);

        /*
         * Step to the next DC.  If the DC was deleted, there
         * is no need to calculate address of the next entry.
         */
        if (pdce == *ppdce)
            ppdce = &pdce->pdceNext;
    }

    PpiCurrent()->W32PF_Flags &= ~W32PF_OWNDCCLEANUP;
}

/***************************************************************************\
* DestroyCacheDC
*
* Removes a DC from the cache, freeing all resources associated
* with it.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

BOOL DestroyCacheDC(
    PDCE *ppdce,
    HDC  hdc)
{
    PDCE pdce;

    /*
     * Zip through the cache looking for hdc.
     */
    if (ppdce == NULL) {
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {
            if (pdce->hdc == hdc)
                break;
        }
    }

    if (ppdce == NULL)
        return FALSE;

    /*
     * Set this here so we know this DCE is supposed to be deleted.
     */
    pdce = *ppdce;
    pdce->DCX_flags |= DCX_DESTROYTHIS;

    /*
     * Free up the dce object and contents.
     */

    if (!(pdce->DCX_flags & DCX_NODELETERGN)) {
        DeleteMaybeSpecialRgn(pdce->hrgnClip);
        pdce->hrgnClip = NULL;
    }

    if (pdce->hrgnClipPublic != NULL) {
        GreDeleteObject(pdce->hrgnClipPublic);
        pdce->hrgnClipPublic = NULL;
    }

    if (pdce->hrgnSavedVis != NULL) {
        GreDeleteObject(pdce->hrgnSavedVis);
        pdce->hrgnSavedVis = NULL;
    }

    /*
     * If GreSetDCOwner() or GreDeleteDC() fail, the
     * DC is in-use by another thread.  Set
     * W32PF_OWNDCCLEANUP so we know to scan for and
     * delete this DCE later.
     */
    if (!GreSetDCOwner(hdc, OBJECT_OWNER_PUBLIC)) {
        PpiCurrent()->W32PF_Flags |= W32PF_OWNDCCLEANUP;
        return FALSE;
    }

#if DBG
    GreMarkDeletableDC(hdc);    // So GRE doesn't RIP.
#endif

    if (!GreDeleteDC(hdc)) {

#if DBG
        GreMarkUndeletableDC(hdc);
#endif
        PpiCurrent()->W32PF_Flags |= W32PF_OWNDCCLEANUP;
        return FALSE;
    }

    /*
     * Decrement this dc-entry from the free-list count.
     */
    if (pdce->DCX_flags & DCX_CACHE) {

        if (!(pdce->DCX_flags & DCX_INUSE)) {
            DecrementFreeDCECount();
        }
    }

#if DBG
    pdce->pwndOrg  = NULL;
    pdce->pwndClip = NULL;
#endif

    /*
     * Unlink the DCE from the list.
     */
    *ppdce = pdce->pdceNext;

    UserFreePool(pdce);

    return TRUE;
}


/***************************************************************************\
* InvalidateGDIWindows
*
* Recalculates the visrgn of all descendents of pwnd on behalf of GRE.
*
* History:
\***************************************************************************/

VOID InvalidateGDIWindows(
    PWND pwnd)
{
    PVOID pwo;

    if (pwnd != NULL) {

        if ((pwo = _GetProp(pwnd, PROP_WNDOBJ, TRUE)) != NULL) {

            HRGN hrgnClient = NULL;

            if (GreWindowInsteadOfClient(pwo)) {

                /*
                 * Never clip children for WO_RGN_WINDOW so that NetMeeting
                 * gets the unioned window area:
                 */

                CalcVisRgn(&hrgnClient,
                           pwnd,
                           pwnd,
                           DCX_WINDOW |
                           (TestWF(pwnd, WFCLIPSIBLINGS) ? DCX_CLIPSIBLINGS : 0));
            } else {
                CalcVisRgn(&hrgnClient,
                           pwnd,
                           pwnd,
                           DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);
            }

            GreSetClientRgn(pwo, hrgnClient, &(pwnd->rcClient));
        }

        pwnd = pwnd->spwndChild;
        while (pwnd != NULL) {
            InvalidateGDIWindows(pwnd);
            pwnd = pwnd->spwndNext;
        }
    }
}

/***************************************************************************\
* zzzInvalidateDCCache
*
* This function is called when the visrgn of a window is changing for
* some reason.  It is responsible for ensuring that all of the cached
* visrgns in the DC cache that are affected by the visrgn change are
* invalidated.
*
* Operations that affect the visrgn of a window (i.e., things that better
* call this routine one way or another:)
*
*   Hiding or showing self or parent
*   Moving, sizing, or Z-order change of self or parent
*   Minimizing or unminimizing self or parent
*   Screen or paint locking of self or parent
*   LockWindowUpdate of self or parent
*
* Invalidates any cache entries associated with pwnd and/or any children of
* pwnd by either recalcing them on the fly if they're in use, or causing
* them to be recalced later.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL zzzInvalidateDCCache(
    PWND  pwndInvalid,
    DWORD flags)
{
    PWND        pwnd;
    PDCE        pdce;
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL          tlpwndInvalid;
    FLONG       fl;

    /*
     * Invalidation implies screen real estate is changing so we must
     * jiggle the mouse, because a different window may be underneath
     * the mouse, which needs to get a mouse move in order to change the
     * mouse pointer.
     *
     * The check for the tracking is added for full-drag-windows.  In doing
     * full-drag, zzzBltValidBits() is called from setting the window-pos.
     * This resulted in an extra-mousemove being queued from this routine.
     * So, when we're tracking, don't queue a mousemove.  This pointer is
     * null when tracking is off, so it won't effect the normal case.
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pwndInvalid, &tlpwndInvalid);

    if (!(ptiCurrent->TIF_flags & TIF_MOVESIZETRACKING) &&
            !(flags & IDC_NOMOUSE)) {

#ifdef REDIRECTION
        if (!IsGlobalHooked(ptiCurrent, WHF_FROM_WH(WH_HITTEST)))
#endif // REDIRECTION

            zzzSetFMouseMoved();
    }

    /*
     * The visrgn of pwnd is changing.  First see if a change to this
     * visrgn will also affect other window's visrgns:
     *
     * 1) if parent is clipchildren, we need to invalidate parent
     * 2) if clipsiblings, we need to invalidate our sibling's visrgns.
     *
     * We don't optimize the case where we're NOT clipsiblings, and our
     * parent is clipchildren: very rare case.
     * We also don't optimize the fact that a clipsiblings window visrgn
     * change only affects the visrgns of windows BELOW it.
     */
    if (flags & IDC_DEFAULT) {

        flags = 0;

        if ((pwndInvalid->spwndParent != NULL) &&
            (pwndInvalid != PWNDDESKTOP(pwndInvalid))) {

            /*
             * If the parent is a clip-children window, then
             * a change to our visrgn will affect his visrgn, and
             * possibly those of our siblings.  So, invalidate starting
             * from our parent.  Note that we don't need to invalidate
             * any window DCs associated with our parent.
             */
            if (TestWF(pwndInvalid->spwndParent, WFCLIPCHILDREN)) {

                flags = IDC_CLIENTONLY;
                pwndInvalid = pwndInvalid->spwndParent;

            } else if (TestWF(pwndInvalid, WFCLIPSIBLINGS)) {

                /*
                 * If we are clip-siblings, chances are that our siblings are
                 * too.  A change to our visrgn might affect our siblings,
                 * so invalidate all of our siblings.
                 *
                 * NOTE! This code assumes that if pwndInvalid is NOT
                 * CLIPSIBLINGs, that either it does not overlap other
                 * CLIPSIBLINGs windows, or that none of the siblings are
                 * CLIPSIBLINGs.  This is a reasonable assumption, because
                 * mixing CLIPSIBLINGs and non CLIPSIBLINGs windows that
                 * overlap is generally unpredictable anyhow.
                 */
                flags = IDC_CHILDRENONLY;
                pwndInvalid = pwndInvalid->spwndParent;
            }
        }
    }

    /*
     * Go through the list of DCE's, looking for any that need to be
     * invalidated or recalculated.  Basically, any DCE that contains
     * a window handle that is equal to pwndInvalid or a child of pwndInvalid
     * needs to be invalidated.
     */
    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
            continue;

        /*
         * HACK ALERT
         *
         * A minimized client DC must never exclude its children, even if
         * its WS_CLIPCHILDREN bit is set.  For CS_OWNDC windows we must
         * update the flags of the DCE to reflect the change in window state
         * when the visrgn is eventually recomputed.
         */
        if (!(pdce->DCX_flags & (DCX_CACHE | DCX_WINDOW))) {

            if (TestWF(pdce->pwndOrg, WFCLIPCHILDREN))
                pdce->DCX_flags |= DCX_CLIPCHILDREN;

            if (TestWF(pdce->pwndOrg, WFMINIMIZED))
                pdce->DCX_flags &= ~DCX_CLIPCHILDREN;
        }

        /*
         * This code assumes that if pdce->pwndClip != pdce->pwndOrg,
         * that pdce->pwndClip == pdce->pwndOrg->spwndParent.  To ensure
         * that both windows are visited, we start the walk upwards from
         * the lower of the two, or pwndOrg.
         *
         * This can happen if someone gets a DCX_PARENTCLIP dc and then
         * changes the parent.
         */
#if DBG
        if ((pdce->pwndClip != pdce->pwndOrg) &&
                (pdce->pwndClip != pdce->pwndOrg->spwndParent)) {
            RIPMSG1(RIP_WARNING, "HDC %lX clipped to wrong parent", pdce->hdc);
        }
#endif
        /*
         * Walk upwards from pdce->pwndOrg, to see if we encounter
         * pwndInvalid.
         */
        for (pwnd = pdce->pwndOrg; pwnd; pwnd = pwnd->spwndParent) {

            if (pwnd == pwndInvalid) {

                if (pwndInvalid == pdce->pwndOrg) {

                    /*
                     * Ignore DCEs for pwndInvalid if IDC_CHILDRENONLY.
                     */
                    if (flags & IDC_CHILDRENONLY)
                        break;

                    /*
                     * Ignore window DCEs for pwndInvalid if IDC_CLIENTONLY
                     */
                    if ((flags & IDC_CLIENTONLY) && (pdce->DCX_flags & DCX_WINDOW))
                        break;
                }

                InvalidateDce(pdce);
                break;
            }
        }
    }

    /*
     * Update WNDOBJs in gdi if they exist.
     */
    GreLockDisplay(gpDispInfo->hDev);

    fl = (flags & IDC_MOVEBLT) ? GCR_DELAYFINALUPDATE : 0;

    if (gcountPWO != 0) {
        InvalidateGDIWindows(pwndInvalid);
        fl |= GCR_WNDOBJEXISTS;
    }

    GreClientRgnUpdated(fl);

    GreUpdateSpriteVisRgn(gpDispInfo->hDev);

    GreUnlockDisplay(gpDispInfo->hDev);

    ThreadUnlock(&tlpwndInvalid);

    return TRUE;
}

/***************************************************************************\
* _WindowFromDC (API)
*
* Takes a dc, returns the window associated with it.
*
* History:
* 23-Jun-1991 ScottLu   Created.
\***************************************************************************/

PWND _WindowFromDC(
    HDC hdc)
{
    PDCE pdce;

    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (!(pdce->DCX_flags & DCX_INUSE) || (pdce->DCX_flags & DCX_CREATEDC))
            continue;

        if (pdce->hdc == hdc)
            return pdce->pwndOrg;
    }

    return NULL;
}

/***************************************************************************\
* FastWindowFromDC
*
* Returns the window associated with a DC, and puts it at the
* front of the list.
*
* History:
* 23-Jun-1991 ScottLu   Created.
\***************************************************************************/

PWND FastWindowFromDC(
    HDC hdc)
{
    PDCE *ppdce;
    PDCE pdceT;

    if ((gpDispInfo->pdceFirst->hdc == hdc) &&
        (gpDispInfo->pdceFirst->DCX_flags & DCX_INUSE)) {

        return gpDispInfo->pdceFirst->pwndOrg;
    }

    for (ppdce = &gpDispInfo->pdceFirst; *ppdce; ppdce = &(*ppdce)->pdceNext) {

        if (((*ppdce)->hdc == hdc) && ((*ppdce)->DCX_flags & DCX_INUSE)) {

            /*
             * Unlink/link to make it first.
             */
            pdceT                 = *ppdce;
            *ppdce                = pdceT->pdceNext;
            pdceT->pdceNext       = gpDispInfo->pdceFirst;
            gpDispInfo->pdceFirst = pdceT;

            return pdceT->pwndOrg;
        }
    }

    return NULL;
}

/***************************************************************************\
* GetDCOrgOnScreen
*
* This function gets the DC origin of a window in screen coordinates. The
* DC origin is always in the surface coordinates. For screen DCs the
* surface is the screen, so their origin is already in the screen
* coordinates. For redirected DCs, GreGetDCOrg will return the origin
* of the DC in the redirected surface coordinates to which we will add
* the origin of the redirected window that the surface is backing.
*
* 11/25/1998        vadimg      created
\***************************************************************************/

BOOL GetDCOrgOnScreen(HDC hdc, LPPOINT ppt)
{
    if (GreGetDCOrg(hdc, ppt)) {
        POINT ptScreen;

        /*
         * Get the origin of the redirected window in screen coordinates.
         */
        if (UserGetRedirectedWindowOrigin(hdc, &ptScreen)) {
            ppt->x += ptScreen.x;
            ppt->y += ptScreen.y;
            return TRUE;
        }
    }
    return FALSE;
}

/***************************************************************************\
* UserGetRedirectedWindowOrigin
*
* The DC origin is in the surface coordinates. For screen DCs, the surface
* is the screen and so their origin is in the screen coordinates. But for
* redirected DCs, the backing surface origin is the same as the window
* being redirected. This function retrieves the screen origin of a redirected
* window corresponding to a redirection DC. It returns FALSE if this isn't
* a valid DC or it's not a redirected DC.
*
* 11/18/1998        vadimg      created
\***************************************************************************/

BOOL UserGetRedirectedWindowOrigin(HDC hdc, LPPOINT ppt)
{
    PWND pwnd;
    PDCE pdce;

    if ((pdce = LookupDC(hdc)) == NULL)
        return FALSE;

    if (!(pdce->DCX_flags & DCX_REDIRECTED))
        return FALSE;

    pwnd = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED);

    ppt->x = pwnd->rcWindow.left;
    ppt->y = pwnd->rcWindow.top;

    return TRUE;
}

/***************************************************************************\
* LookupDC
*
* Validate a DC by returning a correspnding pdce.
*
* 11/12/1997   vadimg          created
\***************************************************************************/

PDCE LookupDC(HDC hdc)
{
    PDCE pdce;

    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

        if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
            continue;

        if (pdce->hdc == hdc && pdce->pMonitor == NULL &&
                (pdce->DCX_flags & DCX_INUSE)) {
            return pdce;
        }
    }
    return NULL;
}

/***************************************************************************\
* GetMonitorDC
*
* 11/06/97      vadimg      ported from Memphis
\***************************************************************************/

#define DCX_LEAVEBITS (DCX_WINDOW | DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS | \
        DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE | DCX_NOCLIPCHILDREN | \
        DCX_USESTYLE | DCX_EXCLUDEUPDATE | DCX_INTERSECTUPDATE | \
        DCX_EXCLUDERGN | DCX_INTERSECTRGN)

HDC GetMonitorDC(PDCE pdceOrig, PMONITOR pMonitor)
{
    PDCE pdce;
    POINT pt;
    RECT rc;

TryAgain:
    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {
        /*
         * Find an available DC for this monitor.
         */
        if (pdce->DCX_flags & (DCX_INUSE | DCX_DESTROYTHIS))
            continue;

        if (pdce->pMonitor != pMonitor)
            continue;

        if (!(pdce->DCX_flags & DCX_INVALID))
            SpbCheckDce(pdce);

        /*
         * Copy DC properties and style bits.
         */
        GreSetDCOwner(pdce->hdc, OBJECT_OWNER_CURRENT);
        pdce->pwndOrg = pdceOrig->pwndOrg;
        pdce->pwndClip = pdceOrig->pwndClip;
        pdce->ptiOwner = pdceOrig->ptiOwner;
        pdce->DCX_flags = (DCX_INUSE | DCX_CACHE) |
                (pdceOrig->DCX_flags & DCX_LEAVEBITS);

        if (pdceOrig->hrgnClip > HRGN_FULL) {
            UserAssert(pdce->hrgnClip == NULL);
            UserAssert(pdceOrig->DCX_flags & (DCX_INTERSECTRGN | DCX_EXCLUDERGN));

            pdce->hrgnClip = CreateEmptyRgn();
            SetMonitorRegion(pMonitor, pdce->hrgnClip, pdceOrig->hrgnClip);
        } else {
            pdce->hrgnClip = pdceOrig->hrgnClip;
        }

        /*
         * Setup the visrgn clipped to this monitor.
         */
        GreCopyVisRgn(pdceOrig->hdc, ghrgnGDC);
        SetMonitorRegion(pMonitor, ghrgnGDC, ghrgnGDC);
        GreSelectVisRgn(pdce->hdc, ghrgnGDC, SVR_COPYNEW);

        GreGetDCOrgEx(pdceOrig->hdc, &pt, &rc);
        OffsetRect(&rc, -pMonitor->rcMonitor.left, -pMonitor->rcMonitor.top);
        GreSetDCOrg(pdce->hdc, rc.left, rc.top, (PRECTL)&rc);

        /*
         * Decrement the Free DCE Count.  This should always be >= 0,
         * since we'll create a new dce if the cache is all in use.
         */
        DecrementFreeDCECount();

        return pdce->hdc;
    }

    /*
     * If this call succeeds a new DC will be available in the cache,
     * so the loop will find it and properly set it up.
     */
    if (CreateCacheDC(NULL, DCX_INVALID | DCX_CACHE, pMonitor) == NULL)
        return NULL;

    goto TryAgain;
}

/***************************************************************************\
* OrderRects
*
* Order the rectangles, so that they flow from left to right. This is needed
* when combining a mirrored region (see MirrorRegion)
*
*
* History:
\***************************************************************************/
VOID OrderRects(
    LPRECT lpR,
    int nRects)
{
    RECT R;
    int i, j;

    //
    // Sort Left to right
    //
    for (i = 0; i < nRects; i++) {
        for (j = i + 1; j < nRects && (lpR + j)->top == (lpR + i)->top; j++) {
            if ((lpR + j)->left < (lpR + i)->left) {
                R = *(lpR + i);
                *(lpR + i) = *(lpR + j);
                *(lpR + j) = R;
            }
        }
    }
}

/***************************************************************************\
* MirrorRegion
*
* Mirror a region in a window. This is done by mirroring the rects that
* constitute the region. 'bUseClient' param controls whether the region is a
* client one or not.
*
* History:
\***************************************************************************/
BOOL MirrorRegion(
    PWND pwnd,
    HRGN hrgn,
    BOOL bUseClient)
{
    int nRects, i, nDataSize, Saveleft, cx;
    HRGN hrgn2 = NULL;
    RECT *lpR;
    RGNDATA *lpRgnData;
    BOOL bRet = FALSE;

    if (TestWF(pwnd, WEFLAYOUTRTL) && hrgn > HRGN_SPECIAL_LAST) {
        nDataSize = GreGetRegionData(hrgn, 0, NULL);
        if (nDataSize && (lpRgnData = (RGNDATA *)UserAllocPool(nDataSize, TAG_MIRROR))) {
            if (GreGetRegionData(hrgn, nDataSize, lpRgnData)) {
                nRects       = lpRgnData->rdh.nCount;
                lpR          = (RECT *)lpRgnData->Buffer;

                if (bUseClient) {
                    cx = pwnd->rcClient.right - pwnd->rcClient.left;
                } else {
                    cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
                }

                Saveleft                     = lpRgnData->rdh.rcBound.left;
                lpRgnData->rdh.rcBound.left  = cx - lpRgnData->rdh.rcBound.right;
                lpRgnData->rdh.rcBound.right = cx - Saveleft;


                for (i = 0; i<nRects; i++){
                    Saveleft   = lpR->left;
                    lpR->left  = cx - lpR->right;
                    lpR->right = cx - Saveleft;

                    lpR++;
                }

                OrderRects((RECT *)lpRgnData->Buffer, nRects);
                hrgn2 = GreExtCreateRegion(NULL, nDataSize, lpRgnData);
                if (hrgn2) {
                    GreCombineRgn(hrgn, hrgn2, NULL, RGN_COPY);
                    GreDeleteObject((HGDIOBJ)hrgn2);
                    bRet = TRUE;
                }
            }

            UserFreePool(lpRgnData);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\dragdrop.c ===
/****************************** Module Header ******************************\
* Module Name: dragdrop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Stuff for object-oriented direct manipulation, designed first for the shell.
*
* History:
* 08-06-91 darrinm    Ported from Win 3.1.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PCURSOR xxxQueryDropObject(PWND pwnd, LPDROPSTRUCT lpds);

/***************************************************************************\
* DragObject (API)
*
* Contains the main dragging loop.
*
* History:
* 08-06-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

DWORD xxxDragObject(
    PWND pwndParent,
    PWND pwndFrom,          // NULL is valid
    UINT wFmt,
    ULONG_PTR dwData,
    PCURSOR pcur)
{
    MSG msg, msgKey;
    DWORD result = 0;
    BOOL fDrag = TRUE;
    LPDROPSTRUCT lpds;
    PWND pwndDragging = NULL;
    PWND pwndTop;
    PCURSOR pcurOld, pcurT;
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndTop;
    TL tlpwndDragging;
    TL tlPool;
    PTHREADINFO pti = PtiCurrent();

    CheckLock(pwndParent);
    CheckLock(pwndFrom);
    CheckLock(pcur);
    UserAssert(IsWinEventNotifyDeferredOK());

    lpds = (LPDROPSTRUCT)UserAllocPoolWithQuota(2 * sizeof(DROPSTRUCT), TAG_DRAGDROP);
    if (lpds == NULL)
        return 0;

    ThreadLockPool(pti, lpds, &tlPool);
    lpds->hwndSource = HW(pwndFrom);
    lpds->wFmt = wFmt;
    lpds->dwData = dwData;

    if (pcur != NULL) {
        /*
         * No need to DeferWinEventNotify() - pwndFrom is locked
         */
        pcurOld = zzzSetCursor(pcur);
    } else {
        pcurOld = pti->pq->spcurCurrent;
    }

    if (pwndFrom) {
        for (pwndTop = pwndFrom; TestwndChild(pwndTop);
                pwndTop = pwndTop->spwndParent) ;

        ThreadLockWithPti(pti, pwndTop, &tlpwndTop);
        xxxUpdateWindow(pwndTop);
        ThreadUnlock(&tlpwndTop);
    }

    xxxWindowEvent(EVENT_SYSTEM_DRAGDROPSTART, pwndFrom, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    xxxSetCapture(pwndFrom);
    zzzShowCursor(TRUE);

    ThreadLockWithPti(pti, pwndDragging, &tlpwndDragging);

    while (fDrag && pti->pq->spwndCapture == pwndFrom) {
        while (!(xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE) ||
                 xxxPeekMessage(&msg, NULL, WM_QUEUESYNC, WM_QUEUESYNC, PM_REMOVE) ||
                 xxxPeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))) {
            if (!xxxSleepThread(QS_MOUSE | QS_KEY, 0, TRUE)) {
                ThreadUnlock(&tlpwndDragging);
                ThreadUnlockAndFreePool(pti, &tlPool);
                return 0;
            }
        }

        /*
         * Be sure to eliminate any extra keydown messages that are
         * being queued up by MOUSE message processing.
         */

        while (xxxPeekMessage(&msgKey, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
           ;

        if  ( (pti->pq->spwndCapture != pwndFrom) ||
              (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE) )
        {
            if (pcurT = SYSCUR(NO))
                zzzSetCursor(pcurT);
            break;
        }

        RtlCopyMemory(lpds + 1, lpds, sizeof(DROPSTRUCT));

        /*
         * in screen coordinates
         */
        lpds->ptDrop = msg.pt;

        pcurT = xxxQueryDropObject(pwndParent, lpds);

        /*
         * Returning FALSE to a WM_QUERYDROPOBJECT message means drops
         * aren't supported and the 'illegal drop target' cursor should be
         * displayed.  Returning TRUE means the target is valid and the
         * regular drag cursor should be displayed.  Also, through a bit
         * of polymorphic magic one can return a cursor handle to override
         * the normal drag cursor.
         */
        if (pcurT == (PCURSOR)FALSE) {
            pcurT = SYSCUR(NO);
            lpds->hwndSink = NULL;
        } else if (pcurT == (PCURSOR)TRUE) {
            pcurT = pcur;
        }

        if (pcurT != NULL)
            zzzSetCursor(pcurT);

        /*
         * send the WM_DRAGLOOP after the above zzzSetCursor() to allow the
         * receiver to change the cursor at WM_DRAGLOOP time with a zzzSetCursor()
         */
        if (pwndFrom) {
            xxxSendMessage(pwndFrom, WM_DRAGLOOP, (pcurT != SYSCUR(NO)),
                    (LPARAM)lpds);
        }

        /*
         * send these messages internally only
         */
        if (pwndDragging != RevalidateHwnd(lpds->hwndSink)) {
            if (pwndDragging != NULL) {
                xxxSendMessage(pwndDragging, WM_DRAGSELECT, FALSE,
                        (LPARAM)(lpds + 1));
            }
            pwndDragging = RevalidateHwnd(lpds->hwndSink);
            ThreadUnlock(&tlpwndDragging);
            ThreadLockWithPti(pti, pwndDragging, &tlpwndDragging);

            if (pwndDragging != NULL) {
                xxxSendMessage(pwndDragging, WM_DRAGSELECT, TRUE, (LPARAM)lpds);
            }
        } else {
            if (pwndDragging != NULL) {
                xxxSendMessage(pwndDragging, WM_DRAGMOVE, 0, (LPARAM)lpds);
            }
        }

        switch (msg.message) {
        case WM_LBUTTONUP:
        case WM_NCLBUTTONUP:
            fDrag = FALSE;
            break;
        }
    }

    ThreadUnlock(&tlpwndDragging);

    /*
     * If the capture has been lost (i.e. fDrag == TRUE), don't do the drop.
     */
    if (fDrag)
        pcurT = SYSCUR(NO);

    /*
     * before the actual drop, clean up the cursor, as the app may do
     * stuff here...
     */
    xxxReleaseCapture();
    zzzShowCursor(FALSE);

    zzzSetCursor(pcurOld);

    /*
     * we either got lbuttonup or enter
     */
    if (pcurT != SYSCUR(NO)) {

        /*
         * object allows drop...  send drop message
         */
        pwndT = ValidateHwnd(lpds->hwndSink);
        if (pwndT != NULL) {

            ThreadLockAlwaysWithPti(pti, pwndT, &tlpwndT);

            /*
             * Allow this guy to activate.
             */
            GETPTI(pwndT)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxDragObject set TIF %#p", GETPTI(pwndT));
            result = (DWORD)xxxSendMessage(pwndT, WM_DROPOBJECT,
                    (WPARAM)HW(pwndFrom), (LPARAM)lpds);

            ThreadUnlock(&tlpwndT);
        }
    }

    xxxWindowEvent(EVENT_SYSTEM_DRAGDROPEND, pwndFrom, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    ThreadUnlockAndFreePool(pti, &tlPool);
    return result;
}


/***************************************************************************\
* QueryDropObject
*
* Determines where in the window heirarchy the "drop" takes place, and
* sends a message to the deepest child window first.  If that window does
* not respond, we go up the heirarchy (recursively, for the moment) until
* we either get a window that does respond or the parent doesn't respond.
*
* History:
* 08-06-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

PCURSOR xxxQueryDropObject(
    PWND pwnd,
    LPDROPSTRUCT lpds)
{
    PWND pwndT;
    PCURSOR pcurT = NULL;
    POINT pt;
    BOOL fNC;
    TL tlpwndT;
    CheckLock(pwnd);

    /*
     *  pt is in screen coordinates
     */
    pt = lpds->ptDrop;

    /*
     * reject points outside this window or if the window is disabled
     */
    if (!PtInRect(&pwnd->rcWindow, pt) || TestWF(pwnd, WFDISABLED))
        return NULL;

    /*
     * Check to see if in window region (if it has one)
     */
    if (pwnd->hrgnClip != NULL) {
        if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
            return NULL;
    }

    /*
     * are we dropping in the nonclient area of the window or on an iconic
     * window?
     */
    if (fNC = (TestWF(pwnd, WFMINIMIZED) || !PtInRect(&pwnd->rcClient, pt))) {
        goto SendQueryDrop;
    }

    /*
     * dropping in client area
     */
    _ScreenToClient(pwnd, &pt);
    pwndT = _ChildWindowFromPointEx(pwnd, pt, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE);
    _ClientToScreen(pwnd, &pt);

    pcurT = NULL;
    if (pwndT && pwndT != pwnd) {
        ThreadLock(pwndT, &tlpwndT);
        pcurT = xxxQueryDropObject(pwndT, lpds);
        ThreadUnlock(&tlpwndT);
    }

    if (pcurT == NULL) {

        /*
         * there are no children who are in the right place or who want
         * drops...  convert the point into client coordinates of the
         * current window.  Because of the recursion, this is already
         * done if a child window grabbed the drop.
         */
SendQueryDrop:
        _ScreenToClient(pwnd, &lpds->ptDrop);
        lpds->hwndSink = HWq(pwnd);

        /*
         * To avoid hanging dropper (sender) app we do a SendMessageTimeout to
         * the droppee (receiver)
         */
        if ((PCURSOR)xxxSendMessageTimeout(pwnd, WM_QUERYDROPOBJECT, fNC,
                (LPARAM)lpds, SMTO_ABORTIFHUNG, 3*1000, (PLONG_PTR)&pcurT) == FALSE)
            pcurT = (PCURSOR)FALSE;

        if (pcurT != (PCURSOR)FALSE && pcurT != (PCURSOR)TRUE)
            pcurT = HMValidateHandle((HCURSOR)pcurT, TYPE_CURSOR);

        /*
         * restore drop point to screen coordinates if this window won't
         * take drops
         */
        if (pcurT == NULL)
            lpds->ptDrop = pt;
    }
    return pcurT;
}


/***************************************************************************\
* xxxDragDetect (API)
*
*
*
* History:
* 08-06-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDragDetect(
    PWND pwnd,
    POINT pt)
{
    return xxxIsDragging(pwnd, pt, WM_LBUTTONUP);
}

/***************************************************************************\
* xxxIsDragging
*
*
*
* History:
* 05-17-94 johnl        Ported from Chicago sources
\***************************************************************************/

BOOL xxxIsDragging(PWND pwnd, POINT ptScreen, UINT uMsg)
{
    RECT rc;
    MSG  msg;
    BOOL fDragging;
    BOOL fCheck;
    TL   tlpwndDragging;
    PTHREADINFO pti = PtiCurrent();

    /*
     * Check synchronous mouse state, and punt if the mouse isn't down
     * according to the queue.
     */
    if (!(_GetKeyState((uMsg == WM_LBUTTONUP ? VK_LBUTTON : VK_RBUTTON)) & 0x8000))
        return FALSE;

    xxxSetCapture(pwnd);

    *(LPPOINT)&rc.left = ptScreen;
    *(LPPOINT)&rc.right = ptScreen;
    InflateRect(&rc, SYSMET(CXDRAG), SYSMET(CYDRAG));

    fDragging = FALSE;
    fCheck    = TRUE;

    ThreadLockWithPti(pti, pwnd, &tlpwndDragging);
    while (fCheck) {
        while ( !(
                  xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,PM_REMOVE) ||
                  xxxPeekMessage(&msg, NULL, WM_QUEUESYNC, WM_QUEUESYNC,PM_REMOVE) ||
                  xxxPeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,PM_REMOVE)
                 )
               && (pti->pq->spwndCapture == pwnd)) {
            /*
             * If there is no input for half a second (500ms) consider that
             * we are dragging. If we don't specify a timeout value, the
             * thread may sleep here forever and wouldn't repaint, etc.
             */
            if (!xxxSleepThread(QS_MOUSE | QS_KEY, 500, TRUE)) {
                fDragging = TRUE;
                goto Cleanup;
            }
        }

        /*
         * Cancel if the button was released or we no longer have the capture.
         */
        if ( pti->pq->spwndCapture != pwnd || msg.message == uMsg) {
            fCheck = FALSE;
        } else {
            switch (msg.message) {

            case WM_MOUSEMOVE:
                if (!PtInRect(&rc, msg.pt)) {
                    fDragging = TRUE;
                    fCheck    = FALSE;
                }
                break;

            case WM_QUEUESYNC:
                /*
                 * CBT Hook needs to know
                 */
                xxxCallHook(HCBT_QS, 0, 0, WH_CBT);
                break;

            case WM_KEYDOWN:
                /*
                 * <Esc> cancels drag detection
                 */
                if (msg.wParam == VK_ESCAPE)
                    fCheck = FALSE;
                break;

            }
        }
    }

Cleanup:
    if (pti->pq->spwndCapture == pwnd)
        xxxReleaseCapture();

    ThreadUnlock(&tlpwndDragging);
    return fDragging ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\drawfrm.c ===
/****************************** Module Header ******************************\
* Module Name: drawfrm.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Window Frame Drawing Routines. (aka wmframe.c)
*
* History:
* 10-22-90 MikeHar    Ported functions from Win 3.0 sources.
* 13-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* BitBltSysBmp
*
\***************************************************************************/

BOOL FAR BitBltSysBmp(
    HDC          hdc,
    int          x,
    int          y,
    UINT         i
    )
{
    BOOL bRet;
    POEMBITMAPINFO pOem = gpsi->oembmi + i;

    bRet = GreBitBlt(hdc,
                     x,
                     y,
                     pOem->cx,
                     pOem->cy,
                     HDCBITS(),
                     pOem->x,
                     pOem->y,
                     SRCCOPY,
                     0);
    /*
     * If the UI language is Hebrew we do not want to mirror the ? mark only
     * Then redraw ? with out the button frame.
     */
    if (HEBREW_UI_LANGID() && MIRRORED_HDC(hdc)) {
        if ((i >= OBI_HELP) && (i <= OBI_HELP_H)) {
            if (i == OBI_HELP_D) {
                x = x + SYSMET(CXEDGE); 
            }
            bRet = GreBitBlt(hdc,
                             x,
                             y+SYSMET(CXEDGE),
                             pOem->cx-SYSMET(CXEDGE)*2,
                             pOem->cy-SYSMET(CXEDGE)*2,
                             HDCBITS(),
                             pOem->x+SYSMET(CXEDGE),
                             pOem->y+SYSMET(CXEDGE),
                             SRCCOPY|NOMIRRORBITMAP,
                             0);

        }
    }
    return bRet;
}

/***************************************************************************\
* xxxDrawWindowFrame
*
* History:
* 10-24-90 MikeHar      Ported from WaWaWaWindows.
\***************************************************************************/

void xxxDrawWindowFrame(
    PWND pwnd,
    HDC  hdc,
    UINT wFlags)
{
    RECT    rcClip;
    int cxFrame, cyFrame;
    UINT    wDCFlags = DC_NC;

    CheckLock(pwnd);

    /*
     * If we are minimized, or if a parent is minimized or invisible,
     * we've got nothing to draw.
     */
    if (!IsVisible(pwnd) ||
        (TestWF(pwnd, WFNONCPAINT) && !TestWF(pwnd, WFMENUDRAW)) ||
        EqualRect(&pwnd->rcWindow, &pwnd->rcClient)) {
        return;
    }

    /*
     * If the update rgn is not NULL, we may have to invalidate the bits saved.
     */
//    if (TRUE) {
    if (pwnd->hrgnUpdate > NULL || GreGetClipBox(hdc, &rcClip, TRUE) != NULLREGION) {
        RECT rcWindow;
        int  cBorders;

        if (TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFNONCPAINT)) {
            if (TestWF(pwnd, WFFRAMEON))
                wDCFlags |= DC_ACTIVE;
            if (wFlags & DF_HUNGREDRAW)
                wDCFlags |= DC_NOSENDMSG;
            xxxDrawCaptionBar(pwnd, hdc, wDCFlags);
            return;
        }

        cxFrame = cyFrame = cBorders =
            GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        cxFrame *= SYSMET(CXBORDER);
        cyFrame *= SYSMET(CYBORDER);

        GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_WINDOWCOORDS);
        InflateRect(&rcWindow, -cxFrame, -cyFrame);

        /*
         * If the menu style is present, draw it.
         */
        if (TestWF(pwnd, WFMPRESENT) && !(wFlags & DF_HUNGREDRAW)) {
            rcWindow.top += xxxMenuBarDraw(pwnd, hdc, cxFrame, cyFrame);
        }

        /*
         * Draw the title bar if the window has a caption or any window
         * borders.  Punt if the NONCPAINT bit is set, because that means
         * we're going to draw the frame a little bit later.
         */

        if ((TestWF(pwnd, WFBORDERMASK) != 0
                || TestWF(pwnd, WEFDLGMODALFRAME))
                || TestWF(pwnd, WFSIZEBOX)
                || TestWF(pwnd, WEFWINDOWEDGE)
                || TestWF(pwnd, WEFSTATICEDGE)
            && !TestWF(pwnd, WFNONCPAINT))
        {
            if (wFlags & DF_HUNGREDRAW)
                wDCFlags |= DC_NOSENDMSG;
            if (wFlags & DF_ACTIVE)
                wDCFlags |= DC_ACTIVE;
            xxxDrawCaptionBar(pwnd, hdc, wDCFlags | DC_NOVISIBLE);
        }

        //
        // Subtract out caption if present.
        //
        rcWindow.top += GetCaptionHeight(pwnd);

        //
        // Draw client edge
        //
        if (TestWF(pwnd, WFCEPRESENT)) {
            cxFrame += SYSMET(CXEDGE);
            cyFrame += SYSMET(CYEDGE);
            DrawEdge(hdc, &rcWindow, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        }

        //
        // Since scrolls don't have to use tricks to overlap the window
        // border anymore, we don't have to worry about borders.
        //
        if (TestWF(pwnd, WFVPRESENT) && !(wFlags & DF_HUNGREDRAW)) {
            if (TestWF(pwnd, WFHPRESENT)) {
                // This accounts for client borders.
                DrawSize(pwnd, hdc, cxFrame, cyFrame);
            }

            xxxDrawScrollBar(pwnd, hdc, TRUE);
        }

        if (TestWF(pwnd, WFHPRESENT) && !(wFlags & DF_HUNGREDRAW))
            xxxDrawScrollBar(pwnd, hdc, FALSE);
    }
}


/***************************************************************************\
* xxxRedrawFrame
*
* Called by scrollbars and menus to redraw a windows scroll bar or menu.
*
* History:
* 10-24-90 MikeHar Ported from WaWaWaWindows.
\***************************************************************************/

void xxxRedrawFrame(
    PWND pwnd)
{
    CheckLock(pwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
            SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
}

void xxxRedrawFrameAndHook(
    PWND pwnd)
{
    CheckLock(pwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
            SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
    if ( IsTrayWindow(pwnd) ) {
        HWND hw = HWq(pwnd);
        xxxCallHook(HSHELL_REDRAW, (WPARAM)hw, 0L, WH_SHELL);
        PostShellHookMessages(HSHELL_REDRAW, (LPARAM)hw);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ddemlsvr.h ===
/****************************** Module Header ******************************\
* Module Name: ddemlsvr.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the DDEML
* server-side.
*
* History:
* 12-6-91     sanfords   Created.
* 21-Jan-1992 IanJa      ANSI/Unicode neutralized (null op)
\***************************************************************************/

#define     MF_INTERNAL                  0x80000000L

// globals

extern PSVR_INSTANCE_INFO psiiList;
extern DWORD MonitorFlags;

// event.c

VOID xxxChangeMonitorFlags(PSVR_INSTANCE_INFO psii, DWORD afCmdNew);
DWORD xxxCsEvent(PEVENT_PACKET pep, WORD cbEventData);
LRESULT xxxEventWndProc(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
VOID xxxProcessDDEMLEvent(PSVR_INSTANCE_INFO psii, PEVENT_PACKET pep);
VOID xxxMessageEvent(PWND pwndTo, UINT message, WPARAM wParam, LPARAM lParam,
    DWORD flag, PDDEML_MSG_HOOK_DATA pdmhd);

// ddemlsvr.c

DWORD xxxCsDdeInitialize(PHANDLE phInst, HWND *phwndEvent, LPDWORD pMonitorFlags,
    DWORD afCmd, PVOID pcii);
DWORD _CsUpdateInstance(HANDLE hInst, LPDWORD pMonitorFlags, DWORD afCmd);
BOOL _CsDdeUninitialize(HANDLE hInst);
VOID xxxDestroyThreadDDEObject(PTHREADINFO pti, PSVR_INSTANCE_INFO psii);
PVOID _CsValidateInstance(HANDLE hInst);

// CSR callbacks

DWORD ClientEventCallback(PVOID pcii, PEVENT_PACKET pep);
DWORD ClientGetDDEHookData(UINT message, LPARAM lParam, PDDEML_MSG_HOOK_DATA pdmhd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\debug.c ===
/****************************** Module Header ******************************\
* Module Name: debug.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains random debugging related functions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Include stuff necessary to send a datagram to winsrv.
 */
#include "ntcsrmsg.h"
#include "csrmsg.h"

/**************************************************************************\
* ActivateDebugger
*
* Force an exception on the active application's context so it will break
* into the debugger.
*
* History:
* 05-10-91 DarrinM      Created.
\***************************************************************************/
BOOL xxxActivateDebugger(
    UINT fsModifiers)
{
    USER_API_MSG m;
    PACTIVATEDEBUGGERMSG a = &m.u.ActivateDebugger;
    PEPROCESS Process;
    HANDLE hDebugPort;
    NTSTATUS Status;

    if (fsModifiers & MOD_CONTROL) {
#if DBG
        if (RipOutput(0, RIP_WARNING, "User debugger", 0, "", "Debug prompt", NULL)) {
            DbgBreakPoint();
        }
#endif
        return FALSE;
    } else if (fsModifiers & MOD_SHIFT) {

        /*
         * Bail out if the process is not being debugged.
         */
        if (PsGetProcessDebugPort(gpepCSRSS) == NULL) {
            return FALSE;
        }

        a->ClientId.UniqueProcess = PsGetProcessId(gpepCSRSS);
    } else {
        if (gpqForeground == NULL || gpqForeground->ptiKeyboard == NULL) {
            return FALSE;
        }

        a->ClientId.UniqueProcess = PsGetThreadProcessId(gpqForeground->ptiKeyboard->pEThread);
        a->ClientId.UniqueThread = PsGetThreadId(gpqForeground->ptiKeyboard->pEThread);

        Status = LockProcessByClientId(a->ClientId.UniqueProcess, &Process);

        /*
         * Bail out if the process is not being debugged or the process id
         * is invalid.
         */
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        hDebugPort = PsGetProcessDebugPort(Process);
        UnlockProcess(Process);

        if (hDebugPort == NULL) {
            return FALSE;
        }
    }

    /*
     * Send the datagram to CSR.
     */
    if (CsrApiPort != NULL) {
        ULONG ArgLength = sizeof(*a);
        ArgLength |= (ArgLength << 16);
        ArgLength +=     ((sizeof( CSR_API_MSG ) - sizeof( m.u )) << 16) |
                        (FIELD_OFFSET( CSR_API_MSG, u ) - sizeof( m.h ));
        m.h.u1.Length = ArgLength;
        m.h.u2.ZeroInit = 0;
        m.CaptureBuffer = NULL;
        m.ApiNumber = CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                          UserpActivateDebugger);
        LeaveCrit();
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);
        EnterCrit();
        UserAssert(NT_SUCCESS(Status));
    }

    /*
     * Don't eat this event unless we are breaking into CSR! Since we have
     * choosen an arbitrary hot key like F12 for the debug key, we need to
     * pass on the key to the application, or apps that want this key would
     * never see it. If we had an api for installing a debug hot key
     * (export or MOD_DEBUG flag to RegisterHotKey()), then it would be ok
     * to eat because the user selected the hot key. But it is not ok to
     * eat it as long as we've picked an arbitrary hot key.
     */
    if (fsModifiers & MOD_SHIFT) {
        return TRUE;
    } else {
        return FALSE;
    }
}

DWORD GetRipComponent(
    VOID)
{
    return RIP_USERKRNL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\desktop.c ===
/***************************** Module Header ******************************\
* Module Name: desktop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains everything related to the desktop support.
*
* History:
* 23-Oct-1990 DarrinM   Created.
* 01-Feb-1991 JimA      Added new API stubs.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct _DESKTOP_CONTEXT {
    PUNICODE_STRING pstrDevice;
    LPDEVMODE       lpDevMode;
    DWORD           dwFlags;
    DWORD           dwCallerSessionId;
} DESKTOP_CONTEXT, *PDESKTOP_CONTEXT;

extern BOOL gfGdiEnabled;

/*
 * We use these to protect a handle we're currently using from being closed.
 */
PEPROCESS gProcessInUse;
HANDLE gHandleInUse;

/*
 * Debug Related Info.
 */
#if DBG
DWORD gDesktopsBusy;     // diagnostic
#endif

#ifdef DEBUG_DESK
VOID ValidateDesktop(PDESKTOP pdesk);
#endif
VOID DbgCheckForThreadsOnDesktop(PPROCESSINFO ppi, PDESKTOP pdesk);

VOID FreeView(
    PEPROCESS Process,
    PDESKTOP pdesk);


NTSTATUS
SetDisconnectDesktopSecurity(
    IN HDESK hdeskDisconnect);

#ifdef POOL_INSTR
    extern FAST_MUTEX* gpAllocFastMutex;   // mutex to syncronize pool allocations
#endif


PVOID DesktopAlloc(
    PDESKTOP pdesk,
    UINT     uSize,
    DWORD    tag)
{
    PVOID ptr;

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG2(RIP_ERROR,
                "DesktopAlloc: tag %d pdesk %#p is destroyed",
                tag,
                pdesk);
        return NULL;
    }

    ptr = Win32HeapAlloc(pdesk->pheapDesktop, uSize, tag, 0);
    if (ptr == NULL && TEST_SRVIF(SRVIF_LOGDESKTOPHEAPFAILURE)) {
        /*
         * This will be logged at most once per-session so as to avoid
         * flooding the event log.
         */
        CLEAR_SRVIF(SRVIF_LOGDESKTOPHEAPFAILURE);
        UserLogError(NULL, 0, WARNING_DESKTOP_HEAP_ALLOC_FAIL);
    }

    return ptr;
}

#if DBG

WCHAR s_strName[100];
CONST WCHAR s_strNameNull[] = L"null";

/***************************************************************************\
* GetDesktopName
*
* This is for debug purposes.
*
* Dec-10-1997 CLupu     Created.
\***************************************************************************/
LPCWSTR GetDesktopName(
    PDESKTOP pdesk)
{
    POBJECT_NAME_INFORMATION DesktopObjectName = (POBJECT_NAME_INFORMATION)s_strName;
    ULONG DesktopObjectNameLength = sizeof(s_strName) - sizeof(WCHAR);
    NTSTATUS Status;

    if (pdesk == NULL) {
        return s_strNameNull;
    }

    Status = ObQueryNameString(pdesk,
                               DesktopObjectName,
                               DesktopObjectNameLength,
                               &DesktopObjectNameLength);
    if (!NT_SUCCESS(Status)) {
        return s_strNameNull;
    }

    UserAssert(DesktopObjectNameLength + sizeof(WCHAR) < sizeof(s_strName));

    DesktopObjectName->Name.Buffer[DesktopObjectName->Name.Length / sizeof(WCHAR)] = 0;

    return (LPCWSTR)DesktopObjectName->Name.Buffer;
}

#endif

typedef struct _CST_THREADS {
    PVOID pParam;
    HANDLE UniqueProcessId;
    UINT  uID;
} CST_THREADS, *PCST_THREADS;

CST_THREADS gCSTParam[CST_MAX_THREADS];
CST_THREADS gCSTRemoteParam[CST_MAX_THREADS];

/***************************************************************************\
* CSTPop
*
* Pops the first available pointer and ID in gCSTParam or gCSTRemoteParam.
*
* History:
* 31-Mar-00 MHamid      Created.
\***************************************************************************/
BOOL CSTPop(
    PUINT pThreadID,
    PVOID *pParam,
    PHANDLE pUniqueProcessId,
    BOOL bRemoteThreadStack)
{
    UINT i = 0;
    PCST_THREADS pCSTParam = bRemoteThreadStack ? gCSTRemoteParam : gCSTParam;

    CheckCritIn();

    while (i < CST_MAX_THREADS) {
        if (pCSTParam[i].pParam) {
            *pParam = pCSTParam[i].pParam;
            if (NULL != pUniqueProcessId) {
                *pUniqueProcessId =  pCSTParam[i].UniqueProcessId;
            }
            *pThreadID = pCSTParam[i].uID;

            pCSTParam[i].pParam = NULL;
            pCSTParam[i].uID = 0;
            return TRUE;
        }

        i++;
    }

    return FALSE;
}

/***************************************************************************\
* CSTPush
*
* Push pointer (pParam) and ID  in the first empty spot in gCSTParam or
* gCSTRemoteParam.
*
* History:
* 31-Mar-00 MHamid      Created.
\***************************************************************************/
BOOL CSTPush(
    UINT uThreadID,
    PVOID pParam,
    HANDLE UniqueProcessId,
    BOOL bRemoteThreadStack)
{
    UINT i = 0;
    PCST_THREADS pCSTParam = bRemoteThreadStack ? gCSTRemoteParam : gCSTParam;

    CheckCritIn();

    while (i < CST_MAX_THREADS) {
        if (!pCSTParam[i].pParam) {
            pCSTParam[i].pParam = pParam;
            pCSTParam[i].UniqueProcessId = UniqueProcessId;
            pCSTParam[i].uID = uThreadID;
            return TRUE;
        }

        i++;
    }

    return FALSE;
}

/***************************************************************************\
* CSTCleanupStack
*
* Clean up any items left on gCSTParam or gCSTRemoteParam.
*
* History:
* 20-Aug-00 MSadek      Created.
\***************************************************************************/
VOID CSTCleanupStack(
    BOOL bRemoteThreadStack)
{
    UINT uThreadID;
    PVOID pObj;

    while(CSTPop(&uThreadID, &pObj, NULL, bRemoteThreadStack)) {
        switch(uThreadID) {
            case CST_RIT:
                    if (((PRIT_INIT)pObj)->pRitReadyEvent) {
                    FreeKernelEvent(&((PRIT_INIT)pObj)->pRitReadyEvent);
                }
                break;
            case CST_POWER:
                if (((PPOWER_INIT)pObj)->pPowerReadyEvent) {
                    FreeKernelEvent(&((PPOWER_INIT)pObj)->pPowerReadyEvent);
                }

                break;
        }
    }
}

/***************************************************************************\
* GetRemoteProcessId
*
* Return handle to a remote process where a system thread would be created
* (currently, only for ghost thread).
*
* History:
* 20-Aug-00 MSadek      Created.
\***************************************************************************/
HANDLE GetRemoteProcessId(
    VOID)
{
    UINT uThreadID;
    PVOID pInitData;
    HANDLE UniqueProcessId;

    if (!CSTPop(&uThreadID, &pInitData, &UniqueProcessId, TRUE)) {
        return NULL;
    }

    /*
     * We should be here only for ghost thread.
     */
    UserAssert(uThreadID == CST_GHOST);

    CSTPush(uThreadID, pInitData, UniqueProcessId, TRUE);

    return UniqueProcessId;
}

/***************************************************************************\
* HandleSystemThreadCreationFailure
*
* Handles the System thread creation failure
*
* History:
* 1-Oct-00 MSadek      Created.
\***************************************************************************/
VOID HandleSystemThreadCreationFailure(
    BOOL bRemoteThread)
{
    UINT uThreadID;
    PVOID pObj;

    /*
     * Should be called only in the context of CSRSS.
     */
    if (!ISCSRSS()) {
        return;
    }

    if (!CSTPop(&uThreadID, &pObj, NULL, bRemoteThread)) {
        return;
    }

    if (uThreadID == CST_POWER) {
        if (((PPOWER_INIT)pObj)->pPowerReadyEvent) {
            KeSetEvent(((PPOWER_INIT)pObj)->pPowerReadyEvent, EVENT_INCREMENT, FALSE);
        }
    }
}

/***************************************************************************\
* xxxCreateSystemThreads
*
* Call the right thread routine (depending on uThreadID),
* which will wait for its own desired messages.
*
* History:
* 15-Mar-00 MHamid      Created.
\***************************************************************************/
VOID xxxCreateSystemThreads(
    BOOL bRemoteThread)
{
    UINT uThreadID;
    PVOID pObj;

    /*
     * Do not allow any process other than CSRSS to call this function. The
     * only exception is the case of the ghost thread since we now allow it
     * to launch in the context of the shell process.
     */
    if (!bRemoteThread && !ISCSRSS()) {
        RIPMSG0(RIP_WARNING,
                "xxxCreateSystemThreads get called from a Process other than CSRSS");
        return;
    }

    if (!CSTPop(&uThreadID, &pObj, NULL, bRemoteThread)) {
        return;
    }

    LeaveCrit();

    switch (uThreadID) {
        case CST_DESKTOP:
            xxxDesktopThread(pObj);
            break;
        case CST_RIT:
            RawInputThread(pObj);
            break;
        case CST_GHOST:
            GhostThread(pObj);
            break;
       case CST_POWER:
            VideoPortCalloutThread(pObj);
            break;
    }

    EnterCrit();
}

/***************************************************************************\
* xxxDesktopThread
*
* This thread owns all desktops windows on a windowstation. While waiting
* for messages, it moves the mouse cursor without entering the USER critical
* section. The RIT does the rest of the mouse input processing.
*
* History:
* 03-Dec-1993 JimA      Created.
\***************************************************************************/
#define OBJECTS_COUNT 3

VOID xxxDesktopThread(
    PTERMINAL pTerm)
{
    KPRIORITY       Priority;
    NTSTATUS        Status;
    PTHREADINFO     ptiCurrent;
    PQ              pqOriginal;
    UNICODE_STRING  strThreadName;
    PKEVENT         *apRITEvents;
    HANDLE          hevtShutDown;
    PKEVENT         pEvents[2];
    USHORT          cEvents = 1;
    MSGWAITCALLBACK pfnHidChangeRoutine = NULL;
    DWORD           nEvents = 0;
    UINT            idMouseInput;
    UINT            idDesktopDestroy;
    UINT            idPumpMessages;

    UserAssert(pTerm != NULL);

    /*
     * Set the desktop thread's priority to low realtime.
     */
#ifdef W2K_COMPAT_PRIORITY
    Priority = LOW_REALTIME_PRIORITY;
#else
    Priority = LOW_REALTIME_PRIORITY - 4;
#endif
    ZwSetInformationThread(NtCurrentThread(),
                           ThreadPriority,
                           &Priority,
                           sizeof(KPRIORITY));

    /*
     * There are just two TERMINAL structures. One is for the
     * interactive windowstation and the other is for all the
     * non-interactive windowstations.
     */
    if (pTerm->dwTERMF_Flags & TERMF_NOIO) {
        RtlInitUnicodeString(&strThreadName, L"NOIO_DT");
    } else {
        RtlInitUnicodeString(&strThreadName, L"IO_DT");
    }

    if (!NT_SUCCESS(InitSystemThread(&strThreadName))) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        RIPMSG0(RIP_ERROR, "Fail to create the desktop thread");
        return;
    }

    ptiCurrent = PtiCurrentShared();

    pTerm->ptiDesktop = ptiCurrent;
    pTerm->pqDesktop  = pqOriginal = ptiCurrent->pq;

    (pqOriginal->cLockCount)++;
    ptiCurrent->pDeskInfo = &diStatic;

    /*
     * Set the winsta to NULL. It will be set to the right windowstation in
     * xxxCreateDesktop before pEventInputReady is set.
     */
    ptiCurrent->pwinsta = NULL;

    /*
     * Allocate non-paged array. Include an extra entry for the thread's
     * input event.
     */
    apRITEvents = UserAllocPoolNonPagedNS((OBJECTS_COUNT * sizeof(PKEVENT)),
                                          TAG_SYSTEM);

    if (apRITEvents == NULL) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        return;
    }

    idMouseInput     = 0xFFFF;
    idDesktopDestroy = 0xFFFF;

    /*
     * Reference the mouse input event.  The system terminal doesn't
     * wait for any mouse input.
     */
    if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {
        pfnHidChangeRoutine = (MSGWAITCALLBACK)ProcessDeviceChanges;
        idMouseInput  = nEvents++;
        UserAssert(aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange);
        apRITEvents[idMouseInput] = aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange;
    }

    /*
     * Create the desktop destruction event.
     */
    idDesktopDestroy = nEvents++;
    apRITEvents[idDesktopDestroy] = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (apRITEvents[idDesktopDestroy] == NULL) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        UserFreePool(apRITEvents);
        return;
    }
    pTerm->pEventDestroyDesktop = apRITEvents[idDesktopDestroy];

    EnterCrit();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Set the event that tells the initialization of desktop
     * thread is done.
     */
    pTerm->dwTERMF_Flags |= TERMF_DTINITSUCCESS;
    KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);

    if (gbRemoteSession) {
        WCHAR             szName[MAX_SESSION_PATH];
        UNICODE_STRING    ustrName;
        OBJECT_ATTRIBUTES obja;

        /*
         * Open the shutdown event. This event will be signaled
         * from W32WinStationTerminate.
         * This is a named event opend by CSR to signal that win32k should
         * go away. It's used in ntuser\server\api.c
         */
        swprintf(szName, 
                 L"\\Sessions\\%ld\\BaseNamedObjects\\EventShutDownCSRSS",
                 gSessionId);
        
        RtlInitUnicodeString(&ustrName, szName);

        InitializeObjectAttributes(&obja,
                                   &ustrName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = ZwOpenEvent(&hevtShutDown,
                               EVENT_ALL_ACCESS,
                               &obja);

        if (!NT_SUCCESS(Status)) {
            pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
            if(pTerm->pEventTermInit) {
                KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
            }
            FreeKernelEvent(&apRITEvents[idDesktopDestroy]);
            UserFreePool(apRITEvents);
            return;
        }

        ObReferenceObjectByHandle(hevtShutDown,
                                  EVENT_ALL_ACCESS,
                                  *ExEventObjectType,
                                  KernelMode,
                                  &pEvents[1],
                                  NULL);
        cEvents++;
    }
    
    /*
     * Prepare to wait on input ready event.
     */
    pEvents[0] = pTerm->pEventInputReady;
    ObReferenceObjectByPointer(pEvents[0],
                               EVENT_ALL_ACCESS,
                               *ExEventObjectType,
                               KernelMode);

    LeaveCrit();

    Status = KeWaitForMultipleObjects(cEvents,
                                      pEvents,
                                      WaitAny,
                                      WrUserRequest,
                                      KernelMode,
                                      FALSE,
                                      NULL,
                                      NULL);
    EnterCrit();

    ObDereferenceObject(pEvents[0]);
    if (cEvents > 1) {
        ObDereferenceObject(pEvents[1]);
    }
    if (Status == WAIT_OBJECT_0 + 1) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        if (pTerm->spwndDesktopOwner != NULL) {
            xxxCleanupMotherDesktopWindow(pTerm);

        }
        if (pTerm->pEventTermInit) {
            KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        }
        FreeKernelEvent(&apRITEvents[idDesktopDestroy]);
        UserFreePool(apRITEvents);
        if (hevtShutDown) {
            ZwClose(hevtShutDown);
        }
        pqOriginal->cLockCount--;
        pTerm->ptiDesktop = NULL;
        pTerm->pqDesktop  = NULL;
        LeaveCrit();
        return;
    }

    /*
     * Adjust the event ids
     */
    idMouseInput     += WAIT_OBJECT_0;
    idDesktopDestroy += WAIT_OBJECT_0;
    idPumpMessages    = WAIT_OBJECT_0 + nEvents;

    /*
     * message loop lasts until we get a WM_QUIT message
     * upon which we shall return from the function
     */
    while (TRUE) {
        DWORD result;

        /*
         * Wait for any message sent or posted to this queue, while calling
         * ProcessDeviceChanges whenever the mouse change event (pkeHidChange)
         * is set.
         */
        result = xxxMsgWaitForMultipleObjects(nEvents,
                                              apRITEvents,
                                              pfnHidChangeRoutine,
                                              NULL);

#if DBG
        gDesktopsBusy++;
        if (gDesktopsBusy >= 2) {
            RIPMSG0(RIP_WARNING, "2 or more desktop threads busy");
        }
#endif

        /*
         * result tells us the type of event we have:
         * a message or a signalled handle
         *
         * if there are one or more messages in the queue ...
         */
        if (result == (DWORD)idPumpMessages) {
            MSG msg;

            CheckCritIn();

            /*
             * read all of the messages in this next loop
             * removing each message as we read it
             */
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                /*
                 * Instrumentation to catch Windows Bug #210358.
                 */
                if (msg.message == WM_QUIT && ptiCurrent->cWindows > 1) {
                    FRE_RIPMSG2(RIP_ERROR, "xxxDesktopThread: WM_QUIT received when %d windows around for pti=%p",
                                ptiCurrent->cWindows, ptiCurrent);
                }

                /*
                 * If it's a quit message we're out of here.
                 */
                if (msg.message == WM_QUIT && ptiCurrent->cWindows <= 1) {
                    TRACE_DESKTOP(("WM_QUIT: Destroying the desktop thread. cWindows %d\n",
                                   ptiCurrent->cWindows));

                    HYDRA_HINT(HH_DTQUITRECEIVED);

                    /*
                     * The window station is gone, so
                     *
                     *      DON'T USE PWINSTA ANYMORE
                     */

                    /*
                     * We could have received a mouse message in between the
                     * desktop destroy event and the WM_QUIT message in which
                     * case we may need to clear spwndTrack again to make sure
                     * that a window (gotta be the desktop) isn't locked in.
                     */
                    Unlock(&ptiCurrent->rpdesk->spwndTrack);

                    /*
                     * If we're running on the last interactive desktop,
                     *  then we never unlocked pdesk->pDeskInfo->spwnd.
                     * However, it seems to me that the system stops
                     *  running before we make it here; otherwise, (or
                     *  for a Hydra-like thing) we need to unlock that
                     *  window here.....
                     */
                    UserAssert(ptiCurrent->rpdesk != NULL &&
                               ptiCurrent->rpdesk->pDeskInfo != NULL);
                    if (ptiCurrent->rpdesk->pDeskInfo->spwnd != NULL) {
                        Unlock(&ptiCurrent->rpdesk->pDeskInfo->spwnd);

                        ptiCurrent->rpdesk->dwDTFlags |= DF_QUITUNLOCK;

                    }

                    /*
                     * Because there is no desktop, we need to fake a
                     * desktop info structure so that the IsHooked()
                     * macro can test a "valid" fsHooks value.
                     */
                    ptiCurrent->pDeskInfo = &diStatic;

                    /*
                     * The desktop window is all that's left, so
                     * let's exit.  The thread cleanup code will
                     * handle destruction of the window.
                     */

                    /*
                     * If the thread is not using the original queue,
                     * destroy it.
                     */
                    UserAssert(pqOriginal->cLockCount);
                    (pqOriginal->cLockCount)--;
                    if (ptiCurrent->pq != pqOriginal) {
                        zzzDestroyQueue(pqOriginal, ptiCurrent);
                    }

#if DBG
                    gDesktopsBusy--;
#endif

                    LeaveCrit();

                    /*
                     * Deref the events now that we're done with them.
                     * Also free the wait array.
                     */
                    FreeKernelEvent(&apRITEvents[idDesktopDestroy]);
                    UserFreePool(apRITEvents);
                    pTerm->ptiDesktop = NULL;
                    pTerm->pqDesktop  = NULL;

                    pTerm->dwTERMF_Flags |= TERMF_DTDESTROYED;

                    /*
                     * Terminate the thread by just returning, since we are
                     * now a user thread.
                     */
                    return;
                } else if (msg.message == WM_DESKTOPNOTIFY) {
                    switch(msg.wParam) {
                    case DESKTOP_RELOADWALLPAPER:
                        {
                            TL tlName;
                            PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
                            xxxSetDeskWallpaper(pProfileUserName, SETWALLPAPER_METRICS);
                            FreeProfileUserName(pProfileUserName, &tlName);
                        }
                        break;

                    default:
                        RIPMSG1(RIP_WARNING, "WM_DESKTOPNOTIFY received with unrecognized wParam 0x%x", msg.wParam);
                        break;
                    }
                    continue;
                }

                UserAssert(msg.message != WM_QUIT);

                /*
                 * Otherwise dispatch it.
                 */
                xxxDispatchMessage(&msg);
            }
        } else if (result == idDesktopDestroy) {
            PDESKTOP        *ppdesk;
            PDESKTOP        pdesk;
            PWND            pwnd;
            PMENU           pmenu;
            TL              tlpwinsta;
            PWINDOWSTATION  pwinsta;
            TL              tlpdesk;
            TL              tlpwnd;
            PDESKTOP        pdeskTemp;
            HDESK           hdeskTemp;
            TL              tlpdeskTemp;

            /*
             * Destroy desktops on the destruction list.
             */
            for (ppdesk = &pTerm->rpdeskDestroy; *ppdesk != NULL;) {
                /*
                 * Unlink from the list.
                 */
                pdesk = *ppdesk;

                TRACE_DESKTOP(("Destroying desktop '%ws' %#p ...\n",
                       GetDesktopName(pdesk), pdesk));

                UserAssert(!(pdesk->dwDTFlags & DF_DYING));

                ThreadLockDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_DESKTOPTHREAD_DESK);
                pwinsta = pdesk->rpwinstaParent;
                ThreadLockWinSta(ptiCurrent, pdesk->rpwinstaParent, &tlpwinsta);

                LockDesktop(ppdesk, pdesk->rpdeskNext, LDL_TERM_DESKDESTROY1, (ULONG_PTR)pTerm);
                UnlockDesktop(&pdesk->rpdeskNext, LDU_DESK_DESKNEXT, 0);

                /*
                 * !!! If this is the current desktop, switch to another one.
                 */
                if (pdesk == grpdeskRitInput) {
                    PDESKTOP pdeskNew;

                    TRACE_DESKTOP(("Destroying the current active desktop\n"));

                        pdesk->dwDTFlags |= DF_ACTIVEONDESTROY;


                    if (pwinsta->dwWSF_Flags & WSF_SWITCHLOCK) {

                        TRACE_DESKTOP(("The windowstation is locked\n"));

                        /*
                         * this should be the interactive windowstation
                         */

                        if (pwinsta->dwWSF_Flags & WSF_NOIO) {
                            FRE_RIPMSG1(RIP_ERROR, "xxxDesktopThread: grpdeskRitInput on non-IO windowstation = %p", grpdeskRitInput);
                        }

                        /*
                         * Switch to the disconnected desktop if the logon desktop
                         * is being destroyed, or there is no logon desktop, or
                         * if the logon desktop has already been destroyed.
                         */
                        if (gspdeskDisconnect &&
                             (pdesk == grpdeskLogon ||
                              grpdeskLogon == NULL  ||
                              (grpdeskLogon->dwDTFlags & DF_DESKWNDDESTROYED))) {
                            TRACE_DESKTOP(("disable the screen and switch to the disconnect desktop\n"));
                            pdesk->dwDTFlags |= DF_SKIPSWITCHDESKTOP;
                            RemoteDisableScreen();
                            goto skip;

                        } else {
                            TRACE_DESKTOP(("Switch to the logon desktop '%ws' %#p ...\n",
                                   GetDesktopName(grpdeskLogon), grpdeskLogon));

                            pdeskNew = grpdeskLogon;
                        }
                    } else {
                        pdeskNew = pwinsta->rpdeskList;
                        if (pdeskNew == pdesk)
                            pdeskNew = pdesk->rpdeskNext;

                        /*
                         * You can hit this if you exit winlogon before
                         * logging in.  I.E. all desktop's close so there is
                         * no "next" one to switch to.  I'm assuming that there
                         * is a check for a NULL desktop in xxxSwitchDesktop().
                         *
                         * You can't switch to a NULL desktop.  But this means
                         * there isn't any input desktop so clear it manually.
                         */
                        if (pdeskNew == NULL) {

                            TRACE_DESKTOP(("NO INPUT FOR DT FROM THIS POINT ON ...\n"));

                            ClearWakeBit(ptiCurrent, QS_INPUT | QS_EVENT | QS_MOUSEMOVE, FALSE);
                            pdesk->dwDTFlags |= DF_DTNONEWDESKTOP;
                        }
                    }

                    TRACE_DESKTOP(("Switch to desktop '%ws' %#p\n",
                           GetDesktopName(pdeskNew), pdeskNew));

                    xxxSwitchDesktop(pwinsta, pdeskNew, 0);
                }
skip:

                /*
                 * Close the display if this desktop did not use the global
                 * display.
                 */
                if ((pdesk->pDispInfo->hDev != NULL) &&
                    (pdesk->pDispInfo->hDev != gpDispInfo->hDev)) {

                    TRACE_DESKTOP(("Destroy MDEV\n"));

                    DrvDestroyMDEV(pdesk->pDispInfo->pmdev);
                    GreFreePool(pdesk->pDispInfo->pmdev);
                    pdesk->pDispInfo->pmdev = NULL;
                }

                if (pdesk->pDispInfo != gpDispInfo) {
                    UserAssert(pdesk->pDispInfo->pMonitorFirst == NULL);
                    UserFreePool(pdesk->pDispInfo);
                    pdesk->pDispInfo = NULL;
                }

                /*
                 * Makes sure the IO desktop thread is running on the active destkop.
                 */
                if (!(pTerm->dwTERMF_Flags & TERMF_NOIO) && (ptiCurrent->rpdesk != grpdeskRitInput)) {
                    FRE_RIPMSG0(RIP_ERROR, "xxxDesktopThread: desktop thread not originally on grpdeskRitInput");
                }

                pdeskTemp = ptiCurrent->rpdesk;            // save current desktop
                hdeskTemp = ptiCurrent->hdesk;
                ThreadLockDesktop(ptiCurrent, pdeskTemp, &tlpdeskTemp, LDLT_FN_DESKTOPTHREAD_DESKTEMP);
                xxxSetThreadDesktop(NULL, pdesk);
                Unlock(&pdesk->spwndForeground);
                Unlock(&pdesk->spwndTray);

                /*
                 * Destroy desktop and menu windows.
                 */
                Unlock(&pdesk->spwndTrack);
                pdesk->dwDTFlags &= ~DF_MOUSEMOVETRK;

                if (pdesk->spmenuSys != NULL) {
                    pmenu = pdesk->spmenuSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuSys)) {
                        _DestroyMenu(pmenu);
                    }
                }

                if (pdesk->spmenuDialogSys != NULL) {
                    pmenu = pdesk->spmenuDialogSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuDialogSys)) {
                        _DestroyMenu(pmenu);
                    }
                }

                if (pdesk->spmenuHScroll != NULL) {
                    pmenu = pdesk->spmenuHScroll;
                    if (UnlockDesktopMenu(&pdesk->spmenuHScroll)) {
                        _DestroyMenu(pmenu);
                    }
                }

                if (pdesk->spmenuVScroll != NULL) {
                    pmenu = pdesk->spmenuVScroll;
                    if (UnlockDesktopMenu(&pdesk->spmenuVScroll)) {
                        _DestroyMenu(pmenu);
                    }
                }

                /*
                 * If this desktop doesn't have a pDeskInfo, then something
                 * is wrong. All desktops should have this until the object
                 * is freed.
                 */
                UserAssert(pdesk->pDeskInfo != NULL);

                if (pdesk->pDeskInfo) {
                    if (pdesk->pDeskInfo->spwnd == gspwndFullScreen) {
                        Unlock(&gspwndFullScreen);
                    }

                    if (pdesk->pDeskInfo->spwndShell) {
                        Unlock(&pdesk->pDeskInfo->spwndShell);
                    }

                    if (pdesk->pDeskInfo->spwndBkGnd) {
                        Unlock(&pdesk->pDeskInfo->spwndBkGnd);
                    }

                    if (pdesk->pDeskInfo->spwndTaskman) {
                        Unlock(&pdesk->pDeskInfo->spwndTaskman);
                    }

                    if (pdesk->pDeskInfo->spwndProgman) {
                        Unlock(&pdesk->pDeskInfo->spwndProgman);
                    }
                }

                UserAssert(!(pdesk->dwDTFlags & DF_DYING));

                if (pdesk->spwndMessage != NULL) {
                    pwnd = pdesk->spwndMessage;

                    if (Unlock(&pdesk->spwndMessage)) {
                        xxxDestroyWindow(pwnd);
                    }
                }

                if (pdesk->spwndTooltip != NULL) {
                    pwnd = pdesk->spwndTooltip;

                    if (Unlock(&pdesk->spwndTooltip)) {
                        xxxDestroyWindow(pwnd);
                    }
                    UserAssert(!(pdesk->dwDTFlags & DF_TOOLTIPSHOWING));
                }

                UserAssert(!(pdesk->dwDTFlags & DF_DYING));

                /*
                 * If the dying desktop is the owner of the desktop owner
                 * window, reassign it to the first available desktop. This
                 * is needed to ensure that xxxSetWindowPos will work on
                 * desktop windows.
                 */
                if (pTerm->spwndDesktopOwner != NULL &&
                    pTerm->spwndDesktopOwner->head.rpdesk == pdesk) {
                    PDESKTOP pdeskR;

                    /*
                     * Find out to what desktop the mother desktop window
                     * should go. Careful with the NOIO case where there
                     * might be several windowstations using the same
                     * mother desktop window
                     */
                    if (pTerm->dwTERMF_Flags & TERMF_NOIO) {
                        PWINDOWSTATION pwinstaW;

                        pdeskR = NULL;

                        CheckCritIn();

                        if (grpWinStaList) {
                            pwinstaW = grpWinStaList->rpwinstaNext;

                            while (pwinstaW != NULL) {
                                if (pwinstaW->rpdeskList != NULL) {
                                    pdeskR = pwinstaW->rpdeskList;
                                    break;
                                }
                                pwinstaW = pwinstaW->rpwinstaNext;
                            }
                        }

                    } else {
                        pdeskR = pwinsta->rpdeskList;
                    }

                    if (pdeskR == NULL) {
                        TRACE_DESKTOP(("DESTROYING THE MOTHER DESKTOP WINDOW %#p\n",
                                pTerm->spwndDesktopOwner));

                        xxxCleanupMotherDesktopWindow(pTerm);
                    } else {
                        TRACE_DESKTOP(("MOVING THE MOTHER DESKTOP WINDOW %#p to pdesk %#p '%ws'\n",
                                pTerm->spwndDesktopOwner, pdeskR, GetDesktopName(pdeskR)));

                        LockDesktop(&(pTerm->spwndDesktopOwner->head.rpdesk),
                                    pdeskR, LDL_MOTHERDESK_DESK1, (ULONG_PTR)(pTerm->spwndDesktopOwner));
                    }
                }

                if (pdesk->pDeskInfo && (pdesk->pDeskInfo->spwnd != NULL)) {
                    UserAssert(!(pdesk->dwDTFlags & DF_DESKWNDDESTROYED));

                    pwnd = pdesk->pDeskInfo->spwnd;

                    /*
                     * Hide this window without activating anyone else.
                     */
                    if (TestWF(pwnd, WFVISIBLE)) {
                        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                        xxxSetWindowPos(pwnd,
                                        NULL,
                                        0,
                                        0,
                                        0,
                                        0,
                                        SWP_HIDEWINDOW | SWP_NOACTIVATE |
                                            SWP_NOMOVE | SWP_NOSIZE |
                                            SWP_NOZORDER | SWP_NOREDRAW |
                                            SWP_NOSENDCHANGING);

                        ThreadUnlock(&tlpwnd);
                    }

                    /*
                     * A lot of pwnd related code assumes that we always
                     * have a valid desktop window. So we call
                     * xxxDestroyWindow first to clean up and then we unlock
                     * it to free it (now or eventually). However, if we're
                     * destroying the last destkop, then we don't unlock the
                     * window since we're are forced to continue running on
                     * that desktop.
                     */
                    TRACE_DESKTOP(("Destroying the desktop window\n"));

                    xxxDestroyWindow(pdesk->pDeskInfo->spwnd);
                    if (pdesk != grpdeskRitInput) {
                        Unlock(&pdesk->pDeskInfo->spwnd);
                        pdesk->dwDTFlags |= DF_NOTRITUNLOCK;
                    } else {
                        pdesk->dwDTFlags |= DF_ZOMBIE;

                        /*
                         * unlock the gspwndShouldBeForeground window
                         */
                        if (ISTS() && gspwndShouldBeForeground != NULL) {
                            Unlock(&gspwndShouldBeForeground);
                        }

                        /*
                         * This is hit in HYDRA when the last desktop does away
                         */
                        RIPMSG1(RIP_WARNING, "xxxDesktopThread: Running on zombie desk:%#p", pdesk);
                    }
                    pdesk->dwDTFlags |= DF_DESKWNDDESTROYED;
                }

                /*
                 * Restore the previous desktop.
                 *
                 * In NOIO sessions, if pdeskTemp is destroyed, don't bother switching
                 * back to it since it'll fail (and assert) latter in zzzSetDesktop
                 */
                if (!(pTerm->dwTERMF_Flags & TERMF_NOIO) ||
                    !(pdeskTemp->dwDTFlags & (DF_DESKWNDDESTROYED | DF_DYING))) {

                    xxxSetThreadDesktop(hdeskTemp, pdeskTemp);
                }

                /*
                 * Makes sure the IO desktop thread is running on the active destkop.
                 */
                if (!(pTerm->dwTERMF_Flags & TERMF_NOIO) && (ptiCurrent->rpdesk != grpdeskRitInput)) {
                    FRE_RIPMSG0(RIP_ERROR, "xxxDesktopThread: desktop thread not back on grpdeskRitInput");
                }

                ThreadUnlockDesktop(ptiCurrent, &tlpdeskTemp, LDUT_FN_DESKTOPTHREAD_DESKTEMP);
                ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
                ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_DESKTOPTHREAD_DESK);
            }

            /*
             * Wakeup ntinput thread for exit processing
             */
            TRACE_DESKTOP(("Wakeup ntinput thread for exit processing\n"));

            UserAssert(gpevtDesktopDestroyed != NULL);

            KeSetEvent(gpevtDesktopDestroyed, EVENT_INCREMENT, FALSE);

        } else if ((NTSTATUS)result == STATUS_USER_APC) {
            /*
             * Instrumentation to catch Windows Bug #210358.
             */
            FRE_RIPMSG1(RIP_ERROR, "xxxDesktopThread: received STATUS_USER_APC for pti=%p", ptiCurrent);
            /*
             * Perhaps we should repost WM_QUIT to myself?
             */
        } else {
            RIPMSG1(RIP_ERROR, "Desktop woke up for what? status=%08x", result);
        }

#if DBG
        gDesktopsBusy--;
#endif
    }
}

/***************************************************************************\
* xxxRealizeDesktop
*
* 4/28/97   vadimg      created
\***************************************************************************/

VOID xxxRealizeDesktop(PWND pwnd)
{
    CheckLock(pwnd);
    UserAssert(GETFNID(pwnd) == FNID_DESKTOP);

    if (ghpalWallpaper) {
        HDC hdc = _GetDC(pwnd);
        xxxInternalPaintDesktop(pwnd, hdc, FALSE);
        _ReleaseDC(hdc);
    }
}

/***************************************************************************\
* xxxDesktopWndProc
*
* History:
* 23-Oct-1990 DarrinM   Ported from Win 3.0 sources.
* 08-Aug-1996 jparsons  51725 - added fix to prevent crash on WM_SETICON
\***************************************************************************/
LRESULT xxxDesktopWndProc(
    PWND   pwnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    HDC         hdcT;
    PAINTSTRUCT ps;
    PWINDOWPOS  pwp;


    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, FNID_DESKTOP, WM_CREATE);


    if (pwnd->spwndParent == NULL) {
        switch (message) {

            case WM_SETICON:
                /*
                 * Cannot allow this as it will cause a callback to user mode
                 * from the desktop system thread.
                 */
                RIPMSG0(RIP_WARNING, "Discarding WM_SETICON sent to desktop.");
                return 0L;

            default:
                break;
        }

        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }

    switch (message) {
    case WM_WINDOWPOSCHANGING:
        /*
         * We receive this when switch desktop is called. Just to be
         * consistent, set the rit desktop as this thread's desktop.
         */
        pwp = (PWINDOWPOS)lParam;
        if (!(pwp->flags & SWP_NOZORDER) && pwp->hwndInsertAfter == HWND_TOP) {
            xxxSetThreadDesktop(NULL, grpdeskRitInput);

            /*
             * If some app has taken over the system-palette, we should make
             * sure the system is restored. Otherwise, if this is the logon
             * desktop, we might not be able to view the dialog correctly.
             */
            if (GreGetSystemPaletteUse(gpDispInfo->hdcScreen) != SYSPAL_STATIC) {
                GreRealizeDefaultPalette(gpDispInfo->hdcScreen, TRUE);
            }

            /*
             * Let everyone know if the palette has changed.
             */
            if (grpdeskRitInput->dwDTFlags & DTF_NEEDSPALETTECHANGED) {
                xxxSendNotifyMessage(PWND_BROADCAST,
                                     WM_PALETTECHANGED,
                                     (WPARAM)HWq(pwnd),
                                     0);
                grpdeskRitInput->dwDTFlags &= ~DTF_NEEDSPALETTECHANGED;
            }
        }
        break;

    case WM_FULLSCREEN: {
            TL tlpwndT;

            ThreadLockWithPti(ptiCurrent, grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
            xxxMakeWindowForegroundWithState(grpdeskRitInput->pDeskInfo->spwnd,
                                             GDIFULLSCREEN);
            ThreadUnlock(&tlpwndT);

            /*
             * We have to tell the switch window to repaint if we switched
             * modes
             */
            if (gspwndAltTab != NULL) {
                ThreadLockAlwaysWithPti(ptiCurrent, gspwndAltTab, &tlpwndT);
                xxxSendMessage(gspwndAltTab, WM_FULLSCREEN, 0, 0);
                ThreadUnlock(&tlpwndT);
            }

            break;
        }

    case WM_CLOSE:

        /*
         * Make sure nobody sends this window a WM_CLOSE and causes it to
         * destroy itself.
         */
        break;

    case WM_SETICON:
        /*
         * cannot allow this as it will cause a callback to user mode from the
         * desktop system thread.
         */
        RIPMSG0(RIP_WARNING, "WM_SETICON sent to desktop window was discarded.");
        break;

    case WM_CREATE: {
        TL tlName;
        PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
        /*
         * Is there a desktop pattern, or bitmap name in WIN.INI?
         */
        xxxSetDeskPattern(pProfileUserName, (LPWSTR)-1, TRUE);

        FreeProfileUserName(pProfileUserName, &tlName);
        /*
         * Initialize the system colors before we show the desktop window.
         */
        xxxSendNotifyMessage(pwnd, WM_SYSCOLORCHANGE, 0, 0L);

        hdcT = _GetDC(pwnd);
        xxxInternalPaintDesktop(pwnd, hdcT, FALSE); // use "normal" HDC so SelectPalette() will work
        _ReleaseDC(hdcT);

        /*
         * Save process and thread ids.
         */
        xxxSetWindowLong(pwnd,
                         0,
                         HandleToUlong(PsGetCurrentProcessId()),
                         FALSE);

        xxxSetWindowLong(pwnd,
                         4,
                         HandleToUlong(PsGetCurrentThreadId()),
                         FALSE);
        break;
    }
    case WM_PALETTECHANGED:
        if (HWq(pwnd) == (HWND)wParam) {
            break;
        }

        // FALL THROUGH

    case WM_QUERYNEWPALETTE:
        xxxRealizeDesktop(pwnd);
        break;

    case WM_SYSCOLORCHANGE:

        /*
         * We do the redrawing if someone has changed the sys-colors from
         * another desktop and we need to redraw.  This is appearent with
         * the MATROX card which requires OGL applications to take over
         * the entire sys-colors for drawing.  When switching desktops, we
         * never broadcast the WM_SYSCOLORCHANGE event to tell us to redraw
         * This is only a DAYTONA related fix, and should be removed once
         * we move the SYSMETS to a per-desktop state.
         *
         * 05-03-95 : ChrisWil.
         */
        xxxRedrawWindow(pwnd,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE);
        break;

    case WM_ERASEBKGND:
        hdcT = (HDC)wParam;
        xxxInternalPaintDesktop(pwnd, hdcT, TRUE);
        return TRUE;

    case WM_PAINT:
        xxxBeginPaint(pwnd, (LPPAINTSTRUCT)&ps);
        xxxEndPaint(pwnd, (LPPAINTSTRUCT)&ps);
        break;

#ifdef HUNGAPP_GHOSTING
    case WM_HUNGTHREAD:
        {
            PWND pwndT = RevalidateHwnd((HWND)lParam);

            if (pwndT != NULL && FHungApp(GETPTI(pwndT), CMSHUNGAPPTIMEOUT)) {
                TL tlpwnd;

                pwndT = GetTopLevelWindow(pwndT);

                ThreadLockAlways(pwndT, &tlpwnd);
                xxxCreateGhost(pwndT);
                ThreadUnlock(&tlpwnd);
            }
            break;
        }

    case WM_SCANGHOST:
        if (gpEventScanGhosts) {
            KeSetEvent(gpEventScanGhosts, EVENT_INCREMENT, FALSE);
        }
        break;

#endif
    case WM_CREATETRAILTIMER:
        if (GETMOUSETRAILS() && !gtmridMouseTrails) {
            gtmridMouseTrails = InternalSetTimer(NULL,
                                                 gtmridMouseTrails,
                                                 1000 / MOUSE_TRAILS_FREQ,
                                                 HideMouseTrails,
                                                 TMRF_RIT);
        }
        break;

    case WM_LBUTTONDBLCLK:
        message = WM_SYSCOMMAND;
        wParam = SC_TASKLIST;

        /*
         *** FALL THRU **
         */

    default:
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }

    return 0L;
}

/***************************************************************************\
* SetDeskPattern
*
* NOTE: the lpszPattern parameter is new for Win 3.1.
*
* History:
* 23-Oct-1990 DarrinM   Created stub.
* 22-Apr-1991 DarrinM   Ported code from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSetDeskPattern(PUNICODE_STRING pProfileUserName,
    LPWSTR   lpszPattern,
    BOOL     fCreation)
{
    LPWSTR p;
    int    i;
    UINT   val;
    WCHAR  wszNone[20];
    WCHAR  wchValue[MAX_PATH];
    WORD   rgBits[CXYDESKPATTERN];
    HBRUSH hBrushTemp;

    CheckCritIn();

    /*
     * Get rid of the old bitmap (if any).
     */
    if (ghbmDesktop != NULL) {
        GreDeleteObject(ghbmDesktop);
        ghbmDesktop = NULL;
    }

    /*
     * Check if a pattern is passed via lpszPattern.
     */
    if (lpszPattern != (LPWSTR)LongToPtr(-1)) {
        /*
         * Yes! Then use that pattern;
         */
        p = lpszPattern;
        goto GotThePattern;
    }

    /*
     * Else, pickup the pattern selected in WIN.INI.
     * Get the "DeskPattern" string from WIN.INI's [Desktop] section.
     */
    if (!FastGetProfileStringFromIDW(pProfileUserName,
                                     PMAP_DESKTOP,
                                     STR_DESKPATTERN,
                                     L"",
                                     wchValue,
                                     sizeof(wchValue)/sizeof(WCHAR),
                                     0)) {
        return FALSE;
    }

    ServerLoadString(hModuleWin,
                     STR_NONE,
                     wszNone,
                     sizeof(wszNone)/sizeof(WCHAR));

    p = wchValue;

GotThePattern:

    /*
     * Was a Desk Pattern selected?
     */
    if (*p == L'\0' || _wcsicmp(p, wszNone) == 0) {
        hBrushTemp = GreCreateSolidBrush(SYSRGB(DESKTOP));
        if (hBrushTemp != NULL) {
            if (SYSHBR(DESKTOP)) {
                GreMarkDeletableBrush(SYSHBR(DESKTOP));
                GreDeleteObject(SYSHBR(DESKTOP));
            }
            GreMarkUndeletableBrush(hBrushTemp);
            SYSHBR(DESKTOP) = hBrushTemp;
        }
        GreSetBrushOwnerPublic(hBrushTemp);
        goto SDPExit;
    }

    /*
     * Get eight groups of numbers seprated by non-numeric characters.
     */
    for (i = 0; i < CXYDESKPATTERN; i++) {
        val = 0;

        /*
         * Skip over any non-numeric characters, check for null EVERY time.
         */
        while (*p && !(*p >= L'0' && *p <= L'9')) {
            p++;
        }

        /*
         * Get the next series of digits.
         */
        while (*p >= L'0' && *p <= L'9') {
            val = val * (UINT)10 + (UINT)(*p++ - L'0');
        }

        rgBits[i] = (WORD)val;
    }

    ghbmDesktop = GreCreateBitmap(CXYDESKPATTERN,
                                  CXYDESKPATTERN,
                                  1,
                                  1,
                                  (LPBYTE)rgBits);
    if (ghbmDesktop == NULL) {
        return FALSE;
    }

    GreSetBitmapOwner(ghbmDesktop, OBJECT_OWNER_PUBLIC);

    RecolorDeskPattern();

SDPExit:
    if (!fCreation) {
        /*
         * Notify everyone that the colors have changed.
         */
        xxxSendNotifyMessage(PWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0L);

        /*
         * Update the entire screen.  If this is creation, don't update: the
         * screen hasn't drawn, and also there are some things that aren't
         * initialized yet.
         */
        xxxRedrawScreen();
    }

    return TRUE;
}

/***************************************************************************\
* RecolorDeskPattern
*
* Remakes the desktop pattern (if it exists) so that it uses the new system
* colors.
*
* History:
* 22-Apr-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID RecolorDeskPattern(
    VOID)
{
    HBITMAP hbmOldDesk;
    HBITMAP hbmOldMem;
    HBITMAP hbmMem;
    HBRUSH  hBrushTemp;

    if (ghbmDesktop == NULL) {
        return;
    }

    /*
     * Redo the desktop pattern in the new colors.
     */

    if (hbmOldDesk = GreSelectBitmap(ghdcMem, ghbmDesktop)) {
        if (!SYSMET(SAMEDISPLAYFORMAT)) {
            BYTE bmi[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 2];
            PBITMAPINFO pbmi = (PBITMAPINFO)bmi;

            pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            pbmi->bmiHeader.biWidth = CXYDESKPATTERN;
            pbmi->bmiHeader.biHeight = CXYDESKPATTERN;
            pbmi->bmiHeader.biPlanes = 1;
            pbmi->bmiHeader.biBitCount = 1;
            pbmi->bmiHeader.biCompression = BI_RGB;
            pbmi->bmiHeader.biSizeImage = 0;
            pbmi->bmiHeader.biXPelsPerMeter = 0;
            pbmi->bmiHeader.biYPelsPerMeter = 0;
            pbmi->bmiHeader.biClrUsed = 2;
            pbmi->bmiHeader.biClrImportant = 2;

            pbmi->bmiColors[0].rgbBlue  = (BYTE)((SYSRGB(DESKTOP) >> 16) & 0xff);
            pbmi->bmiColors[0].rgbGreen = (BYTE)((SYSRGB(DESKTOP) >>  8) & 0xff);
            pbmi->bmiColors[0].rgbRed   = (BYTE)((SYSRGB(DESKTOP)) & 0xff);

            pbmi->bmiColors[1].rgbBlue  = (BYTE)((SYSRGB(WINDOWTEXT) >> 16) & 0xff);
            pbmi->bmiColors[1].rgbGreen = (BYTE)((SYSRGB(WINDOWTEXT) >>  8) & 0xff);
            pbmi->bmiColors[1].rgbRed   = (BYTE)((SYSRGB(WINDOWTEXT)) & 0xff);

            hbmMem = GreCreateDIBitmapReal(HDCBITS(),
                                           0,
                                           NULL,
                                           pbmi,
                                           DIB_RGB_COLORS,
                                           sizeof(bmi),
                                           0,
                                           NULL,
                                           0,
                                           NULL,
                                           0,
                                           0,
                                           NULL);
        } else {
            hbmMem = GreCreateCompatibleBitmap(HDCBITS(),
                                               CXYDESKPATTERN,
                                               CXYDESKPATTERN);
        }

        if (hbmMem) {
            if (hbmOldMem = GreSelectBitmap(ghdcMem2, hbmMem)) {
                GreSetTextColor(ghdcMem2, SYSRGB(DESKTOP));
                GreSetBkColor(ghdcMem2, SYSRGB(WINDOWTEXT));

                GreBitBlt(ghdcMem2,
                          0,
                          0,
                          CXYDESKPATTERN,
                          CXYDESKPATTERN,
                          ghdcMem,
                          0,
                          0,
                          SRCCOPY,
                          0);

                if (hBrushTemp = GreCreatePatternBrush(hbmMem)) {
                    if (SYSHBR(DESKTOP) != NULL) {
                        GreMarkDeletableBrush(SYSHBR(DESKTOP));
                        GreDeleteObject(SYSHBR(DESKTOP));
                    }

                    GreMarkUndeletableBrush(hBrushTemp);
                    SYSHBR(DESKTOP) = hBrushTemp;
                }

                GreSetBrushOwnerPublic(hBrushTemp);
                GreSelectBitmap(ghdcMem2, hbmOldMem);
            }

            GreDeleteObject(hbmMem);
        }

        GreSelectBitmap(ghdcMem, hbmOldDesk);
    }
}

/***************************************************************************\
* GetDesktopHeapSize()
*
* Calculate the desktop heap size
*
* History:
* 27-Nov-2001 Msadek      Created it.
\***************************************************************************/

ULONG GetDesktopHeapSize(
    USHORT usFlags)
{
    ULONG ulHeapSize;

    switch (usFlags) {
    case DHS_LOGON:
        ulHeapSize = USR_LOGONSECT_SIZE;
#ifdef _WIN64
        /*
         * Increase heap size 50% for Win64 to allow for larger structures.
         */
        ulHeapSize = (ulHeapSize * 3) / 2;
#endif
        break;

    case DHS_DISCONNECT:
        ulHeapSize = USR_DISCONNECTSECT_SIZE;
#ifdef _WIN64
        /*
         * Increase heap size 50% for Win64 to allow for larger structures.
         */
        ulHeapSize = (ulHeapSize * 3) / 2;
#endif
        break;

    case DHS_NOIO:
        ulHeapSize = gdwNOIOSectionSize;
        break;

    default:
        ulHeapSize = gdwDesktopSectionSize;
    }

    return  ulHeapSize * 1024;
}

/***************************************************************************\
* xxxCreateDesktop (API)
*
* Create a new desktop object.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/
NTSTATUS xxxCreateDesktop2(
    PWINDOWSTATION   pwinsta,
    PACCESS_STATE    pAccessState,
    KPROCESSOR_MODE  AccessMode,
    PUNICODE_STRING  pstrName,
    PDESKTOP_CONTEXT Context,
    PVOID            *pObject)
{
    LUID              luidCaller;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PEPROCESS         Process;
    PDESKTOP          pdesk;
    PDESKTOPINFO      pdi;
    ULONG             ulHeapSize;
    USHORT            usSizeFlags = 0;
    NTSTATUS          Status;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;


    CheckCritIn();

    /*
     * If this is a desktop creation, make sure that the windowstation
     * grants create access.
     */
    if (!ObCheckCreateObjectAccess(
            pwinsta,
            WINSTA_CREATEDESKTOP,
            pAccessState,
            pstrName,
            TRUE,
            AccessMode,
            &Status)) {

        return Status;
    }

    /*
     * Fail if the windowstation is locked.
     */
    Process = PsGetCurrentProcess();
    if (pwinsta->dwWSF_Flags & WSF_OPENLOCK &&
            PsGetProcessId(Process) != gpidLogon) {

        /*
         * If logoff is occuring and the caller does not
         * belong to the session that is ending, allow the
         * open to proceed.
         */
        Status = GetProcessLuid(NULL, &luidCaller);

        if (!NT_SUCCESS(Status) ||
                !(pwinsta->dwWSF_Flags & WSF_SHUTDOWN) ||
                RtlEqualLuid(&luidCaller, &pwinsta->luidEndSession)) {
            return STATUS_DEVICE_BUSY;
        }
    }

    /*
     * If a devmode has been specified, we also must be able
     * to switch desktops.
     */
    if (Context->lpDevMode != NULL && (pwinsta->dwWSF_Flags & WSF_OPENLOCK) &&
            PsGetProcessId(Process) != gpidLogon) {
        return STATUS_DEVICE_BUSY;
    }

    /*
     * Allocate the new object
     */
    InitializeObjectAttributes(&ObjectAttributes, pstrName, 0, NULL, NULL);
    Status = ObCreateObject(
            KernelMode,
            *ExDesktopObjectType,
            &ObjectAttributes,
            UserMode,
            NULL,
            sizeof(DESKTOP),
            0,
            0,
            &pdesk);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "xxxCreateDesktop2: ObCreateObject failed with Status 0x%x",
                Status);
        return Status;
    }

    RtlZeroMemory(pdesk, sizeof(DESKTOP));

    /*
     * Store the session id of the session who created the desktop
     */
    pdesk->dwSessionId = gSessionId;

    /*
     * Fetch the parents security descriptor
     */
    Status = ObGetObjectSecurity(pwinsta,
                                 &SecurityDescriptor,
                                 &MemoryAllocated);
    if (!NT_SUCCESS(Status)) {
        goto Error;
    }

    /*
     * Create security descriptor.
     */
    Status = ObAssignSecurity(pAccessState,
                              SecurityDescriptor,
                              pdesk,
                              *ExDesktopObjectType);

    ObReleaseObjectSecurity(SecurityDescriptor, MemoryAllocated);
    if (!NT_SUCCESS(Status)) {
        goto Error;
    }

    /*
     * Set up desktop heap.  The first desktop (logon desktop) uses a
     * small heap (128).
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO) && (pwinsta->rpdeskList == NULL)) {
        usSizeFlags = DHS_LOGON;
    } else {
        if (pwinsta->dwWSF_Flags & WSF_NOIO) {
            usSizeFlags = DHS_NOIO;
        } else {
            /*
             * The disconnected desktop should be small also.
             */
            if (gspdeskDisconnect == NULL) {
                usSizeFlags = DHS_DISCONNECT;
            }
        }
    }
    ulHeapSize = GetDesktopHeapSize(usSizeFlags);

    /*
     * Create the desktop heap.
     */
    pdesk->hsectionDesktop = CreateDesktopHeap(&pdesk->pheapDesktop, ulHeapSize);
    if (pdesk->hsectionDesktop == NULL) {
        RIPMSGF1(RIP_WARNING,
                "CreateDesktopHeap failed for pdesk 0x%p",
                pdesk);

        /*
         * If we fail to create a desktop due to being out of desktop heap,
         * write an entry to the event log.
         */
        if (TEST_SRVIF(SRVIF_LOGDESKTOPHEAPFAILURE)) {
            CLEAR_SRVIF(SRVIF_LOGDESKTOPHEAPFAILURE);
            UserLogError(NULL, 0, WARNING_DESKTOP_CREATION_FAILED);
        }

        goto ErrorOutOfMemory;
    }

    if (pwinsta->rpdeskList == NULL || (pwinsta->dwWSF_Flags & WSF_NOIO)) {
        /*
         * The first desktop or invisible desktops must also use the default
         * settings. This is because specifying the devmode causes a desktop
         * switch, which must be avoided in this case.
         */
        Context->lpDevMode = NULL;
    }

    /*
     * Allocate desktopinfo
     */
    pdi = (PDESKTOPINFO)DesktopAlloc(pdesk, sizeof(DESKTOPINFO), DTAG_DESKTOPINFO);
    if (pdi == NULL) {
        RIPMSG0(RIP_WARNING, "xxxCreateDesktop: failed DeskInfo Alloc");
        goto ErrorOutOfMemory;
    }

    /*
     * Initialize everything.
     */
    pdesk->pDeskInfo = pdi;
    InitializeListHead(&pdesk->PtiList);

    /*
     * If a DEVMODE or another device name is passed in, then use that
     * information. Otherwise use the default information (gpDispInfo).
     */
    if (Context->lpDevMode) {
        BOOL  bDisabled = FALSE;
        PMDEV pmdev = NULL;
        LONG  ChangeStat = GRE_DISP_CHANGE_FAILED;

        /*
         * Allocate a display-info for this device.
         */
        pdesk->pDispInfo = (PDISPLAYINFO)UserAllocPoolZInit(
                sizeof(DISPLAYINFO), TAG_DISPLAYINFO);

        if (!pdesk->pDispInfo) {
            RIPMSGF1(RIP_WARNING,
                     "Failed to allocate pDispInfo for pdesk 0x%p",
                     pdesk);
            goto ErrorOutOfMemory;
        }

        if ((bDisabled = SafeDisableMDEV()) == TRUE) {
            ChangeStat = DrvChangeDisplaySettings(Context->pstrDevice,
                                                  NULL,
                                                  Context->lpDevMode,
                                                  LongToPtr(gdwDesktopId),
                                                  UserMode,
                                                  FALSE,
                                                  TRUE,
                                                  NULL,
                                                  &pmdev,
                                                  GRE_DEFAULT,
                                                  FALSE);
        }

        if (ChangeStat != GRE_DISP_CHANGE_SUCCESSFUL) {
            if (bDisabled) {
                SafeEnableMDEV();
            }

            //
            // If there is a failure, then repaint the whole screen.
            //

            RIPMSG1(RIP_WARNING, "xxxCreateDesktop2 callback for pdesk %#p !",
                    pdesk);

            xxxUserResetDisplayDevice();

            Status = STATUS_UNSUCCESSFUL;
            goto Error;
        }

        pdesk->pDispInfo->hDev  = pmdev->hdevParent;
        pdesk->pDispInfo->pmdev = pmdev;
        pdesk->dwDesktopId      = gdwDesktopId++;

        CopyRect(&pdesk->pDispInfo->rcScreen, &gpDispInfo->rcScreen);
        pdesk->pDispInfo->dmLogPixels = gpDispInfo->dmLogPixels;

        pdesk->pDispInfo->pMonitorFirst = NULL;
        pdesk->pDispInfo->pMonitorPrimary = NULL;

    } else {

        pdesk->pDispInfo   = gpDispInfo;
        pdesk->dwDesktopId = GW_DESKTOP_ID;

    }

    /*
     * Heap is HEAP_ZERO_MEMORY, so we should be zero-initialized already.
     */
    UserAssert(pdi->pvwplShellHook == NULL);

    pdi->pvDesktopBase  = Win32HeapGetHandle(pdesk->pheapDesktop);
    pdi->pvDesktopLimit = (PBYTE)pdi->pvDesktopBase + ulHeapSize;

    /*
     * Reference the parent windowstation
     */
    LockWinSta(&(pdesk->rpwinstaParent), pwinsta);

    /*
     * Link the desktop into the windowstation list
     */
    if (pwinsta->rpdeskList == NULL) {
        if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
            LockDesktop(&grpdeskLogon, pdesk, LDL_DESKLOGON, 0);
        }

        /*
         * Make the first desktop the "owner" of the top desktop window. This
         * is needed to ensure that xxxSetWindowPos will work on desktop
         * windows.
         */
        LockDesktop(&(pwinsta->pTerm->spwndDesktopOwner->head.rpdesk),
                    pdesk, LDL_MOTHERDESK_DESK2, (ULONG_PTR)(pwinsta->pTerm->spwndDesktopOwner));
    }


    LockDesktop(&pdesk->rpdeskNext, pwinsta->rpdeskList, LDL_DESK_DESKNEXT1, (ULONG_PTR)pwinsta);
    LockDesktop(&pwinsta->rpdeskList, pdesk, LDL_WINSTA_DESKLIST1, (ULONG_PTR)pwinsta);

    /*
     * Mask off invalid access bits
     */
    if (pAccessState->RemainingDesiredAccess & MAXIMUM_ALLOWED) {
        pAccessState->RemainingDesiredAccess &= ~MAXIMUM_ALLOWED;
        pAccessState->RemainingDesiredAccess |= GENERIC_ALL;
    }

    RtlMapGenericMask( &pAccessState->RemainingDesiredAccess, (PGENERIC_MAPPING)&DesktopMapping);
    pAccessState->RemainingDesiredAccess &=
            (DesktopMapping.GenericAll | ACCESS_SYSTEM_SECURITY);

    *pObject = pdesk;

    /*
     * Add the desktop to the global list of desktops in this win32k.
     */
    DbgTrackAddDesktop(pdesk);

    return STATUS_SUCCESS;

ErrorOutOfMemory:
    Status = STATUS_NO_MEMORY;
    // fall-through

Error:
    LogDesktop(pdesk, LD_DEREF_FN_2CREATEDESKTOP, FALSE, 0);
    ObDereferenceObject(pdesk);

    UserAssert(!NT_SUCCESS(Status));

    return Status;
}

BOOL xxxCreateDisconnectDesktop(
    HWINSTA        hwinsta,
    PWINDOWSTATION pwinsta)
{
    UNICODE_STRING      strDesktop;
    OBJECT_ATTRIBUTES   oa;
    HDESK               hdeskDisconnect;
    HRGN                hrgn;
    NTSTATUS            Status;

    /*
     * Create the empty clipping region for the disconnect desktop.
     */

    if ((hrgn = CreateEmptyRgnPublic()) == NULL) {
       RIPMSG0(RIP_WARNING, "Creation of empty region for Disconnect Desktop failed ");
       return FALSE;
    }

    /*
     * If not created yet, then create the Disconnected desktop
     * (used when WinStation is disconnected), and lock the desktop
     * and desktop window to ensure they never get deleted.
     */
    RtlInitUnicodeString(&strDesktop, L"Disconnect");
    InitializeObjectAttributes(&oa, &strDesktop,
            OBJ_OPENIF | OBJ_CASE_INSENSITIVE, hwinsta, NULL);

    hdeskDisconnect = xxxCreateDesktop(&oa,
                                       KernelMode,
                                       NULL,
                                       NULL,
                                       0,
                                       MAXIMUM_ALLOWED);

    if (hdeskDisconnect == NULL) {
        RIPMSG0(RIP_WARNING, "Could not create Disconnect desktop");
        GreDeleteObject(hrgn);
        return FALSE;
    }

    /*
     * Set the disconnect desktop security.
     * Keep around an extra reference to the disconnect desktop from
     * the CSR so it will stay around even if winlogon exits.
     */

    Status = SetDisconnectDesktopSecurity(hdeskDisconnect);

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(hdeskDisconnect,
                                           0,
                                           NULL,
                                           KernelMode,
                                           &gspdeskDisconnect,
                                           NULL);
    }
    if (!NT_SUCCESS(Status)) {

        RIPMSG1(RIP_WARNING, "Disconnect Desktop reference failed 0x%x", Status);

        GreDeleteObject(hrgn);
        xxxCloseDesktop(hdeskDisconnect, KernelMode);
        gspdeskDisconnect = NULL;
        return FALSE;
    }

    LogDesktop(gspdeskDisconnect, LDL_DESKDISCONNECT, TRUE, 0);

    /*
     * Set the region of the desktop window to be (0, 0, 0, 0) so
     * that there is no hittesting going on the 'disconnect' desktop
     * But prior to session the null region, we need to null the pointer
     * to the existing shared region so that it doesn't get deleted.
     */

    UserAssert(gspdeskDisconnect->pDeskInfo != NULL);

    gspdeskDisconnect->pDeskInfo->spwnd->hrgnClip = hrgn;


    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

    Status = ObOpenObjectByPointer(
                 gspdeskDisconnect,
                 0,
                 NULL,
                 EVENT_ALL_ACCESS,
                 NULL,
                 KernelMode,
                 &ghDisconnectDesk);

    if (NT_SUCCESS(Status)) {

        Status = ObOpenObjectByPointer(
                     pwinsta,
                     0,
                     NULL,
                     EVENT_ALL_ACCESS,
                     NULL,
                     KernelMode,
                     &ghDisconnectWinSta);
    }

    KeDetachProcess();

    if (!NT_SUCCESS(Status)) {

        RIPMSG0(RIP_WARNING, "Could not create Disconnect desktop");

        GreDeleteObject(hrgn);
        gspdeskDisconnect->pDeskInfo->spwnd->hrgnClip = NULL;

        if (ghDisconnectDesk != NULL) {
            CloseProtectedHandle(ghDisconnectDesk);
            ghDisconnectDesk = NULL;
        }

        xxxCloseDesktop(hdeskDisconnect, KernelMode);
        return FALSE;
    }

    /*
     * Don't want to do alot of paints if we disconnected before this.
     */
    if (!gbConnected) {
        RIPMSG0(RIP_WARNING,
            "RemoteDisconnect was issued during CreateDesktop(\"Winlogon\"...");
    }

    return TRUE;
}

VOID CleanupDirtyDesktops(
    VOID)
{
    PWINDOWSTATION pwinsta;
    PDESKTOP*      ppdesk;

    CheckCritIn();

    for (pwinsta = grpWinStaList; pwinsta != NULL; pwinsta = pwinsta->rpwinstaNext) {

        ppdesk = &pwinsta->rpdeskList;

        while (*ppdesk != NULL) {

            if (!((*ppdesk)->dwDTFlags & DF_DESKCREATED)) {
                RIPMSG1(RIP_WARNING, "Desktop %#p in a dirty state", *ppdesk);

                if (grpdeskLogon == *ppdesk) {
                    UnlockDesktop(&grpdeskLogon, LDU_DESKLOGON, 0);
                }

                if (pwinsta->pTerm->spwndDesktopOwner &&
                    pwinsta->pTerm->spwndDesktopOwner->head.rpdesk == *ppdesk) {

                    UnlockDesktop(&(pwinsta->pTerm->spwndDesktopOwner->head.rpdesk),
                                  LDU_MOTHERDESK_DESK, (ULONG_PTR)(pwinsta->pTerm->spwndDesktopOwner));
                }

                LockDesktop(ppdesk, (*ppdesk)->rpdeskNext, LDL_WINSTA_DESKLIST1, (ULONG_PTR)pwinsta);
            } else {
                ppdesk = &(*ppdesk)->rpdeskNext;
            }
        }
    }
}

VOID W32FreeDesktop(
    PVOID pObj)
{
    FRE_RIPMSG1(RIP_WARNING,
                "W32FreeDesktop: obj 0x%p is not freed in the regular code path.",
                pObj);

    ObDereferenceObject(pObj);
}

HDESK xxxCreateDesktop(
    POBJECT_ATTRIBUTES ccxObjectAttributes,
    KPROCESSOR_MODE    ProbeMode,
    PUNICODE_STRING    ccxpstrDevice,
    LPDEVMODE          ccxlpdevmode,
    DWORD              dwFlags,
    DWORD              dwDesiredAccess)
{
    HWINSTA         hwinsta;
    HDESK           hdesk;
    DESKTOP_CONTEXT Context;
    PDESKTOP        pdesk;
    PDESKTOPINFO    pdi;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdeskTemp;
    HDESK           hdeskTemp;
    PWND            pwndDesktop = NULL;
    PWND            pwndMessage = NULL;
    PWND            pwndTooltip = NULL;
    TL              tlpwnd;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    BOOL            fWasNull;
    BOOL            bSuccess;
    PPROCESSINFO    ppi;
    PPROCESSINFO    ppiSave;
    PTERMINAL       pTerm;
    NTSTATUS        Status;
    DWORD           dwDisableHooks;
    TL              tlW32Desktop;

#if DBG
    /*
     * Too many jumps in this function to use BEGIN/ENDATOMICHCECK
     */
    DWORD dwCritSecUseSave = gdwCritSecUseCount;
#endif

    CheckCritIn();

    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Capture directory handle and check for create access.
     */
    try {
        hwinsta = ccxObjectAttributes->RootDirectory;
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
    if (hwinsta != NULL) {
        Status = ObReferenceObjectByHandle(hwinsta,
                                           WINSTA_CREATEDESKTOP,
                                           *ExWindowStationObjectType,
                                           ProbeMode,
                                           &pwinsta,
                                           NULL);
        if (NT_SUCCESS(Status)) {
            DWORD dwSessionId = pwinsta->dwSessionId;

            ObDereferenceObject(pwinsta);
            if (dwSessionId != gSessionId) {
                /*
                 * Windows Bug: 418526
                 * Avoid creating a desktop that belongs to the other
                 * session.
                 */
                RIPMSGF1(RIP_WARNING,
                         "winsta 0x%p belongs to other session",
                         pwinsta);
                return NULL;
            }
        } else {
            RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
            return NULL;
        }
    }

    /*
     * Set up creation context
     */
    Context.lpDevMode  = ccxlpdevmode;
    Context.pstrDevice = ccxpstrDevice;
    Context.dwFlags    = dwFlags;
    Context.dwCallerSessionId = gSessionId;

    /*
     * Create the desktop -- the object manager uses try blocks.
     */
    Status = ObOpenObjectByName(ccxObjectAttributes,
                                *ExDesktopObjectType,
                                ProbeMode,
                                NULL,
                                dwDesiredAccess,
                                &Context,
                                &hdesk);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "xxxCreateDesktop: ObOpenObjectByName failed with Status 0x%x",
                  Status);

        /*
         * Cleanup desktop objects that were created in xxxCreateDesktop2
         * but later on the Ob manager failed the creation for other
         * reasons (ex: no quota).
         */
        CleanupDirtyDesktops();

        return NULL;
    }

    /*
     * If the desktop already exists, we're done.  This will only happen
     * if OBJ_OPENIF was specified.
     */
    if (Status == STATUS_OBJECT_NAME_EXISTS) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        RIPMSG0(RIP_WARNING, "xxxCreateDesktop: Object name exists");
        return hdesk;
    }

    /*
     * Reference the desktop to finish initialization
     */
    Status = ObReferenceObjectByHandle(
            hdesk,
            0,
            *ExDesktopObjectType,
            KernelMode,
            &pdesk,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        CloseProtectedHandle(hdesk);
        return NULL;
    }

    /*
     * Usermode marking such that any hdesk associated with this desktop will
     * always be referenced in this mode.
     */
    pdesk->dwDTFlags |= DF_DESKCREATED | ((ProbeMode == UserMode) ? DF_USERMODE : 0);

    LogDesktop(pdesk, LD_REF_FN_CREATEDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

    pwinsta = pdesk->rpwinstaParent;
    pTerm   = pwinsta->pTerm;
    pdi = pdesk->pDeskInfo;

    pdi->ppiShellProcess = NULL;

    ppi = PpiCurrent();

    if (gpepCSRSS != NULL) {
        WIN32_OPENMETHOD_PARAMETERS OpenParams;

        /*
         * Map the desktop into CSRSS to ensure that the hard error handler
         * can get access.
         */
        OpenParams.OpenReason = ObOpenHandle;
        OpenParams.Process = gpepCSRSS;
        OpenParams.Object = pdesk;
        OpenParams.GrantedAccess = 0;
        OpenParams.HandleCount = 1;

        if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
            /*
             * Desktop mapping failed.
             */
            CloseProtectedHandle(hdesk);

            LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP2, FALSE, (ULONG_PTR)PtiCurrent());

            ObDereferenceObject(pdesk);
            RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING, "Desktop mapping failed (2)");
            return NULL;
        }

        UserAssert(GetDesktopView(PpiFromProcess(gpepCSRSS), pdesk) != NULL);
    }

    /*
     * Set hook flags
     */
    SetHandleFlag(hdesk, HF_DESKTOPHOOK, dwFlags & DF_ALLOWOTHERACCOUNTHOOK);

    /*
     * Set up to create the desktop window.
     */
    fWasNull = (ptiCurrent->ppi->rpdeskStartup == NULL);
    pdeskTemp = ptiCurrent->rpdesk;            // save current desktop
    hdeskTemp = ptiCurrent->hdesk;

    /*
     * Switch ppi values so window will be created using the
     * system's desktop window class.
     */
    ppiSave  = ptiCurrent->ppi;
    ptiCurrent->ppi = pTerm->ptiDesktop->ppi;

    /*
     * Lock pdesk: with bogus TS protocol, the session
     * may be killed in the middle of the initialization.
     */
    PushW32ThreadLock(pdesk, &tlW32Desktop, W32FreeDesktop);

    DeferWinEventNotify();
    BeginAtomicCheck();

    if (zzzSetDesktop(ptiCurrent, pdesk, hdesk) == FALSE) {
        goto Error;
    }

    /*
     * Create the desktop window
     */
    /*
     * HACK HACK HACK!!! (adams) In order to create the desktop window
     * with the correct desktop, we set the desktop of the current thread
     * to the new desktop. But in so doing we allow hooks on the current
     * thread to also hook this new desktop. This is bad, because we don't
     * want the desktop window to be hooked while it is created. So we
     * temporarily disable hooks of the current thread and its desktop,
     * and reenable them after switching back to the original desktop.
     */

    dwDisableHooks = ptiCurrent->TIF_flags & TIF_DISABLEHOOKS;
    ptiCurrent->TIF_flags |= TIF_DISABLEHOOKS;

    pwndDesktop = xxxNVCreateWindowEx(
            (DWORD)0,
            (PLARGE_STRING)DESKTOPCLASS,
            NULL,
            (WS_POPUP | WS_CLIPCHILDREN),
            pdesk->pDispInfo->rcScreen.left,
            pdesk->pDispInfo->rcScreen.top,
            pdesk->pDispInfo->rcScreen.right - pdesk->pDispInfo->rcScreen.left,
            pdesk->pDispInfo->rcScreen.bottom - pdesk->pDispInfo->rcScreen.top,
            NULL,
            NULL,
            hModuleWin,
            NULL,
            VER31);

    if (pwndDesktop == NULL) {
        RIPMSGF1(RIP_WARNING,
                 "Failed to create the desktop window for pdesk 0x%p",
                 pdesk);
        goto Error;
    }

    /*
     * NOTE: In order for the message window to be created without
     * the desktop as it's owner, it needs to be created before
     * setting pdi->spwnd to the desktop window. This is a complete
     * hack and should be fixed.
     */
    pwndMessage = xxxNVCreateWindowEx(
            0,
            (PLARGE_STRING)gatomMessage,
            NULL,
            (WS_POPUP | WS_CLIPCHILDREN),
            0,
            0,
            100,
            100,
            NULL,
            NULL,
            hModuleWin,
            NULL,
            VER31);
    if (pwndMessage == NULL) {
        RIPMSGF0(RIP_WARNING, "Failed to create the message window");
        goto Error;
    }

    /*
     * NOTE: Remember what window class this window belongs to.
     * Since the message window does not have its own window proc
     * (they use xxxDefWindowProc) we have to do it here.
     */
    pwndMessage->fnid = FNID_MESSAGEWND;

    UserAssert(pdi->spwnd == NULL);

    Lock(&(pdi->spwnd), pwndDesktop);

    SetFullScreen(pwndDesktop, GDIFULLSCREEN);

    /*
     * Set this windows to the fullscreen window if we don't have one yet.
     *
     * Don't set gspwndFullScreen if gfGdiEnabled has been cleared (we may
     * be in the middle of a disconnect).
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        UserAssert(gfGdiEnabled == TRUE);
        if (gspwndFullScreen == NULL) {
            Lock(&(gspwndFullScreen), pwndDesktop);
        }
    }

    /*
     * NT Bug 388747: Link the message window to the mother desktop window
     * so that it properly has a parent.  We will do this before we link the
     * desktop window just so the initial message window appears after the
     * initial desktop window (a minor optimization, but not necessary).
     */
    Lock(&pwndMessage->spwndParent, pTerm->spwndDesktopOwner);
    LinkWindow(pwndMessage, NULL, pTerm->spwndDesktopOwner);
    Lock(&pdesk->spwndMessage, pwndMessage);
    Unlock(&pwndMessage->spwndOwner);

    /*
     * Link it as a child but don't use WS_CHILD style
     */
    LinkWindow(pwndDesktop, NULL, pTerm->spwndDesktopOwner);
    Lock(&pwndDesktop->spwndParent, pTerm->spwndDesktopOwner);
    Unlock(&pwndDesktop->spwndOwner);

    /*
     * Make it regional if it's display configuration is regional.
     */
    if (!pdesk->pDispInfo->fDesktopIsRect) {
        pwndDesktop->hrgnClip = pdesk->pDispInfo->hrgnScreen;
    }

    /*
     * Create shared menu window and tooltip window.
     */
    ThreadLock(pdesk->spwndMessage, &tlpwnd);

    /*
     * Create the tooltip window only for desktops in interactive
     * windowstations.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        pwndTooltip = xxxNVCreateWindowEx(
                WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
                (PLARGE_STRING)TOOLTIPCLASS,
                NULL,
                WS_POPUP | WS_BORDER,
                0,
                0,
                100,
                100,
                pdesk->spwndMessage,
                NULL,
                hModuleWin,
                NULL,
                VER31);


        if (pwndTooltip == NULL) {
            ThreadUnlock(&tlpwnd);
            RIPMSGF0(RIP_WARNING, "Failed to create the tooltip window");
            goto Error;
        }

        Lock(&pdesk->spwndTooltip, pwndTooltip);
    }

    ThreadUnlock(&tlpwnd);

    HMChangeOwnerThread(pdi->spwnd, pTerm->ptiDesktop);
    HMChangeOwnerThread(pwndMessage, pTerm->ptiDesktop);

    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        HMChangeOwnerThread(pwndTooltip, pTerm->ptiDesktop);
    }

    /*
     * Restore caller's ppi
     */
    PtiCurrent()->ppi = ppiSave;

    /*
     * HACK HACK HACK (adams): Renable hooks.
     */
    UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
    ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;

    /*
     * Restore the previous desktop
     */
    if (zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp) == FALSE) {
        goto Error;
    }

    EndAtomicCheck();
    UserAssert(dwCritSecUseSave == gdwCritSecUseCount);
    zzzEndDeferWinEventNotify();

    /*
     * If this is the first desktop, let the worker threads run now
     * that there is someplace to send input to.  Reassign the event
     * to handle desktop destruction.
     */
    if (pTerm->pEventInputReady != NULL) {

        /*
         * Set the windowstation for RIT and desktop thread
         * so when EventInputReady is signaled the RIT and the desktop
         * will have a windowstation.
         */
        if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {
            gptiRit->pwinsta = pwinsta;
        } else {
            /*
             * let the desktop thread of the system terminal have
             * a rpdesk.
             */
            if (zzzSetDesktop(pTerm->ptiDesktop, pdesk, NULL) == FALSE) {
                goto Error;
            }
        }

        pTerm->ptiDesktop->pwinsta = pwinsta;

        KeSetEvent(pTerm->pEventInputReady, EVENT_INCREMENT, FALSE);

        if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {

            LeaveCrit();
            while (grpdeskRitInput == NULL) {
                UserSleep(20);
                RIPMSG0(RIP_WARNING, "Waiting for grpdeskRitInput to be set ...");
            }
            EnterCrit();
        }

        ObDereferenceObject(pTerm->pEventInputReady);
        pTerm->pEventInputReady = NULL;
    }


    /*
     * HACK HACK:
     * LATER
     *
     * If we have a devmode passed in, then switch desktops ...
     */

    if (ccxlpdevmode) {
        TRACE_INIT(("xxxCreateDesktop: about to call switch desktop\n"));

        bSuccess = xxxSwitchDesktop(pwinsta, pdesk, SDF_CREATENEW);
        UserAssertMsg1(bSuccess,
                       "Failed to switch desktop 0x%p on create", pdesk);
    } else if (pTerm == &gTermIO) {
        UserAssert(grpdeskRitInput != NULL);

        /*
         * Force the window to the bottom of the z-order if there
         * is an active desktop so any drawing done on the desktop
         * window will not be seen.  This will also allow
         * IsWindowVisible to work for apps on invisible
         * desktops.
         */
        ThreadLockWithPti(ptiCurrent, pwndDesktop, &tlpwnd);
        xxxSetWindowPos(pwndDesktop, PWND_BOTTOM, 0, 0, 0, 0,
                    SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOMOVE |
                    SWP_NOREDRAW | SWP_NOSIZE | SWP_NOSENDCHANGING);
        ThreadUnlock(&tlpwnd);
    }

    /*
     * If it was null when we came in, make it null going out, or else
     * we'll have the wrong desktop selected into this.
     */
    if (fWasNull)
        UnlockDesktop(&ptiCurrent->ppi->rpdeskStartup,
                      LDU_PPI_DESKSTARTUP1, (ULONG_PTR)(ptiCurrent->ppi));

    /*
     * Create the disconnect desktop for the console session too.
     */

    if (gspdeskDisconnect == NULL && pdesk == grpdeskLogon) {
        UserAssert(hdesk != NULL);

        /*
         * Create the 'disconnect' desktop
         */
        if (!xxxCreateDisconnectDesktop(hwinsta, pwinsta)) {
            RIPMSG0(RIP_WARNING, "Failed to create the 'disconnect' desktop");

            LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP3, FALSE, (ULONG_PTR)PtiCurrent());
            PopW32ThreadLock(&tlW32Desktop);
            ObDereferenceObject(pdesk);

            xxxCloseDesktop(hdesk, KernelMode);

            return NULL;
        }

        /*
         * Signal that the disconnect desktop got created.
         */
        KeSetEvent(gpEventDiconnectDesktop, EVENT_INCREMENT, FALSE);

        HYDRA_HINT(HH_DISCONNECTDESKTOP);
    }

Cleanup:

    LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP3, FALSE, (ULONG_PTR)PtiCurrent());
    PopW32ThreadLock(&tlW32Desktop);
    ObDereferenceObject(pdesk);

    TRACE_INIT(("xxxCreateDesktop: Leaving\n"));

    if (hdesk != NULL) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
    }
    return hdesk;

Error:

    EndAtomicCheck();
    UserAssert(dwCritSecUseSave == gdwCritSecUseCount);

    if (pwndTooltip != NULL) {
        xxxDestroyWindow(pwndTooltip);
        Unlock(&pdesk->spwndTooltip);
    }
    if (pwndMessage != NULL) {
        xxxDestroyWindow(pwndMessage);
        Unlock(&pdesk->spwndMessage);
    }
    if (pwndDesktop != NULL) {
        xxxDestroyWindow(pwndDesktop);
        Unlock(&pdi->spwnd);
        Unlock(&gspwndFullScreen);
    }
    /*
     * Restore caller's ppi
     */
    PtiCurrent()->ppi = ppiSave;

    UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
    ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
    zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp);

    CloseProtectedHandle(hdesk);
    hdesk = NULL;

    zzzEndDeferWinEventNotify();

    /*
     * If it was null when we came in, make it null going out, or else
     * we'll have the wrong desktop selected into this.
     */
    if (fWasNull) {
        UnlockDesktop(&ptiCurrent->ppi->rpdeskStartup,
                      LDU_PPI_DESKSTARTUP1,
                      (ULONG_PTR)ptiCurrent->ppi);
    }

    goto Cleanup;

}

/***************************************************************************\
* ParseDesktop
*
* Parse a desktop path.
*
* History:
* 14-Jun-1995 JimA      Created.
\***************************************************************************/
NTSTATUS ParseDesktop(
    PVOID                        pContainerObject,
    POBJECT_TYPE                 pObjectType,
    PACCESS_STATE                pAccessState,
    KPROCESSOR_MODE              AccessMode,
    ULONG                        Attributes,
    PUNICODE_STRING              pstrCompleteName,
    PUNICODE_STRING              pstrRemainingName,
    PVOID                        Context,
    PSECURITY_QUALITY_OF_SERVICE pqos,
    PVOID                        *pObject)
{
    PWINDOWSTATION  pwinsta = pContainerObject;
    PDESKTOP        pdesk;
    PUNICODE_STRING pstrName;
    NTSTATUS        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    *pObject = NULL;

    if (Context && ((PDESKTOP_CONTEXT)Context)->dwCallerSessionId != gSessionId) {
        /*
         * Windows Bug: 418526:
         * If it's a creation request from the other session,
         * we have to bail out ASAP.
         */
        RIPMSGF1(RIP_WARNING,
                 "Rejecting desktop creation attempt from other session (%d)",
                 ((PDESKTOP_CONTEXT)Context)->dwCallerSessionId);
        return STATUS_INVALID_PARAMETER;
    }

    BEGIN_REENTERCRIT();

    UserAssert(OBJECT_TO_OBJECT_HEADER(pContainerObject)->Type == *ExWindowStationObjectType);
    UserAssert(pObjectType == *ExDesktopObjectType);

    /*
     * See if the desktop exists
     */
    for (pdesk = pwinsta->rpdeskList; pdesk != NULL; pdesk = pdesk->rpdeskNext) {
        pstrName = POBJECT_NAME(pdesk);
        if (pstrName && RtlEqualUnicodeString(pstrRemainingName, pstrName,
                (BOOLEAN)((Attributes & OBJ_CASE_INSENSITIVE) != 0))) {
            if (Context != NULL) {
                if (!(Attributes & OBJ_OPENIF)) {

                    /*
                     * We are attempting to create a desktop and one
                     * already exists.
                     */
                    Status = STATUS_OBJECT_NAME_COLLISION;
                    goto Exit;

                } else {
                    Status = STATUS_OBJECT_NAME_EXISTS;
                }
            } else {
                Status = STATUS_SUCCESS;
            }

            ObReferenceObject(pdesk);

            *pObject = pdesk;
            goto Exit;
        }
    }

    /*
     * Handle creation request
     */
    if (Context != NULL) {
        Status = xxxCreateDesktop2(pContainerObject,
                                   pAccessState,
                                   AccessMode,
                                   pstrRemainingName,
                                   Context,
                                   pObject);
    }

Exit:
    END_REENTERCRIT();

    return Status;

    UNREFERENCED_PARAMETER(pObjectType);
    UNREFERENCED_PARAMETER(pstrCompleteName);
    UNREFERENCED_PARAMETER(pqos);
}

/***************************************************************************\
* DestroyDesktop
*
* Called upon last close of a desktop to remove the desktop from the
* desktop list and free all desktop resources.
*
* History:
* 08-Dec-1993 JimA      Created.
\***************************************************************************/
BOOL DestroyDesktop(
    PDESKTOP pdesk)
{
    PWINDOWSTATION pwinsta = pdesk->rpwinstaParent;
    PTERMINAL      pTerm;
    PDESKTOP       *ppdesk;

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_WARNING, "DestroyDesktop: Already destroyed:%#p", pdesk);
        return FALSE;
    }

    /*
     * Unlink the desktop, if it has not yet been unlinked.
     */
    if (pwinsta != NULL) {

        ppdesk = &pwinsta->rpdeskList;
        while (*ppdesk != NULL && *ppdesk != pdesk) {
            ppdesk = &((*ppdesk)->rpdeskNext);
        }

        if (*ppdesk != NULL) {

            /*
             * remove desktop from the list
             */
            LockDesktop(ppdesk, pdesk->rpdeskNext, LDL_WINSTA_DESKLIST2, (ULONG_PTR)pwinsta);
            UnlockDesktop(&pdesk->rpdeskNext, LDU_DESK_DESKNEXT, (ULONG_PTR)pwinsta);
        }
    }

    /*
     * Link it into the destruction list and signal the desktop thread.
     */
    pTerm = pwinsta->pTerm;

    LockDesktop(&pdesk->rpdeskNext, pTerm->rpdeskDestroy, LDL_DESK_DESKNEXT2, 0);
    LockDesktop(&pTerm->rpdeskDestroy, pdesk, LDL_TERM_DESKDESTROY2, (ULONG_PTR)pTerm);
    KeSetEvent(pTerm->pEventDestroyDesktop, EVENT_INCREMENT, FALSE);

    pdesk->dwDTFlags |= DF_DESTROYED;

    TRACE_DESKTOP(("pdesk %#p '%ws' marked as destroyed\n", pdesk, GetDesktopName(pdesk)));

    return TRUE;
}


/***************************************************************************\
* FreeDesktop
*
* Called to free desktop object and section when last lock is released.
*
* History:
* 08-Dec-1993 JimA      Created.
\***************************************************************************/
NTSTATUS FreeDesktop(
    PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams)
{
    PDESKTOP pdesk = (PDESKTOP)pDeleteParams->Object;
    NTSTATUS Status = STATUS_SUCCESS;

    BEGIN_REENTERCRIT();

    UserAssert(OBJECT_TO_OBJECT_HEADER(pDeleteParams->Object)->Type == *ExDesktopObjectType);

#ifdef LOGDESKTOPLOCKS

    if (pdesk->pLog != NULL) {

        /*
         * By the time we get here the lock count for lock/unlock
         * tracking code should be 0
         */
        if (pdesk->nLockCount != 0) {
            RIPMSG3(RIP_WARNING,
                    "FreeDesktop pdesk %#p, pLog %#p, nLockCount %d should be 0",
                    pdesk, pdesk->pLog, pdesk->nLockCount);
        }
        UserFreePool(pdesk->pLog);
        pdesk->pLog = NULL;
    }
#endif

#if DBG
    if (pdesk->pDeskInfo && (pdesk->pDeskInfo->spwnd != NULL)) {

        /*
         * Assert if the desktop has a desktop window but the flag
         * that says the window is destroyed is not set.
         */
        UserAssert(pdesk->dwDTFlags & DF_DESKWNDDESTROYED);
    }
#endif

    /*
     * Mark the desktop as dying.  Make sure we aren't recursing.
     */
    UserAssert(!(pdesk->dwDTFlags & DF_DYING));
    pdesk->dwDTFlags |= DF_DYING;

#ifdef DEBUG_DESK
    ValidateDesktop(pdesk);
#endif

    /*
     * If the desktop is mapped into CSR, unmap it.  Note the
     * handle count values passed in will cause the desktop
     * to be unmapped and skip the desktop destruction tests.
     */
    FreeView(gpepCSRSS, pdesk);

    if (pdesk->pheapDesktop != NULL) {

        PVOID hheap = Win32HeapGetHandle(pdesk->pheapDesktop);

        Win32HeapDestroy(pdesk->pheapDesktop);

        Status = Win32UnmapViewInSessionSpace(hheap);

        UserAssert(NT_SUCCESS(Status));
        Win32DestroySection(pdesk->hsectionDesktop);
    }

    UnlockWinSta(&pdesk->rpwinstaParent);

    DbgTrackRemoveDesktop(pdesk);

    END_REENTERCRIT();

    return Status;
}

/***************************************************************************\
* CreateDesktopHeap
*
* Create a new desktop heap
*
* History:
* 27-Jul-1992 JimA      Created.
\***************************************************************************/

HANDLE CreateDesktopHeap(
    PWIN32HEAP* ppheapRet,
    ULONG       ulHeapSize)
{
    HANDLE        hsection;
    LARGE_INTEGER SectionSize;
    SIZE_T        ulViewSize;
    NTSTATUS      Status;
    PWIN32HEAP    pheap;
    PVOID         pHeapBase;

    /*
     * Create desktop heap section and map it into the kernel
     */
    SectionSize.QuadPart = ulHeapSize;

    Status = Win32CreateSection(&hsection,
                                SECTION_ALL_ACCESS,
                                NULL,
                                &SectionSize,
                                PAGE_EXECUTE_READWRITE,
                                SEC_RESERVE,
                                NULL,
                                NULL,
                                TAG_SECTION_DESKTOP);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_WARNING, "Can't create section for desktop heap.");
        return NULL;
    }

    ulViewSize = ulHeapSize;
    pHeapBase = NULL;

    Status = Win32MapViewInSessionSpace(hsection, &pHeapBase, &ulViewSize);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status,
                  RIP_WARNING,
                  "Can't map section for desktop heap into system space.");
        goto Error;
    }

    /*
     * Create desktop heap.
     */
    if ((pheap = UserCreateHeap(
            hsection,
            0,
            pHeapBase,
            ulHeapSize,
            UserCommitDesktopMemory)) == NULL) {

        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "Can't create Desktop heap.");

        Win32UnmapViewInSessionSpace(pHeapBase);
Error:
        Win32DestroySection(hsection);
        *ppheapRet = NULL;
        return NULL;
    }

    UserAssert(Win32HeapGetHandle(pheap) == pHeapBase);
    *ppheapRet = pheap;

    return hsection;
}

/***************************************************************************\
* GetDesktopView
*
* Determines if a desktop has already been mapped into a process.
*
* History:
* 10-Apr-1995 JimA      Created.
\***************************************************************************/
PDESKTOPVIEW GetDesktopView(
    PPROCESSINFO ppi,
    PDESKTOP     pdesk)
{
    PDESKTOPVIEW pdv;

    if (ppi->Process != gpepCSRSS && pdesk == NULL) {
        RIPMSG1(RIP_WARNING, "Process 0x%p isn't CSRSS but pdesk is NULL in GetDesktopView", ppi);
    }

    for (pdv = ppi->pdvList; pdv != NULL; pdv = pdv->pdvNext) {
        if (pdv->pdesk == pdesk) {
            break;
        }
    }

    return pdv;
}

/***************************************************************************\
* _MapDesktopObject
*
* Maps a desktop object into the client's address space
*
* History:
* 11-Apr-1995 JimA      Created.
\***************************************************************************/

PVOID _MapDesktopObject(
    HANDLE h)
{
    PDESKOBJHEAD pobj;
    PDESKTOPVIEW pdv;

    /*
     * Validate the handle
     */
    pobj = HMValidateHandle(h, TYPE_GENERIC);
    if (pobj == NULL) {
        return NULL;
    }

    UserAssert(HMObjectFlags(pobj) & OCF_DESKTOPHEAP);

    /*
     * Locate the client's view of the desktop. Realistically, this should
     * never fail for valid objects.
     */
    pdv = GetDesktopView(PpiCurrent(), pobj->rpdesk);
    if (pdv == NULL) {
        RIPMSG1(RIP_WARNING, "MapDesktopObject: cannot map handle 0x%p", h);
        return NULL;
    }

    UserAssert(pdv->ulClientDelta != 0);
    return (PVOID)((PBYTE)pobj - pdv->ulClientDelta);
}


NTSTATUS DesktopOpenProcedure(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams)
{
    PDESKTOP pdesk = (PDESKTOP)pOpenParams->Object;

    /*
     * Make sure we're not opening a handle for a destroy desktop. If this happens,
     * we probably want to fail it.
     */
    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_WARNING,
                "DesktopOpenProcedure: Opening a handle to destroyed desktop 0x%p",
                pdesk);
        return STATUS_ACCESS_DENIED;
    }

    /*
     * Allow desktop open cross session only if no special rights granted.
     */

    if (pOpenParams->GrantedAccess & SPECIFIC_RIGHTS_ALL) {
        if (PsGetProcessSessionId(pOpenParams->Process) != pdesk->dwSessionId) {
            return STATUS_ACCESS_DENIED;
        }
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* MapDesktop
*
* Attempts to map a desktop heap into a process.
*
* History:
* 20-Oct-1994 JimA      Created.
\***************************************************************************/
NTSTATUS MapDesktop(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams)
{
    PPROCESSINFO  ppi;
    PDESKTOP      pdesk = (PDESKTOP)pOpenParams->Object;
    SIZE_T        ulViewSize;
    LARGE_INTEGER liOffset;
    PDESKTOPVIEW  pdvNew;
    PBYTE         pheap;
    HANDLE        hsectionDesktop;
    PBYTE         pClientBase;
    NTSTATUS      Status = STATUS_SUCCESS;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pOpenParams->Object)->Type == *ExDesktopObjectType);

    TAGMSG2(DBGTAG_Callout,
            "Mapping desktop 0x%p into process 0x%p",
            pdesk,
            pOpenParams->Process);

    BEGIN_REENTERCRIT();

    /*
     * Ignore handle inheritance because MmMapViewOfSection cannot be called
     * during process creation.
     */
    if (pOpenParams->OpenReason == ObInheritHandle) {
        goto Exit;
    }

    /*
     * If there is no ppi, we can't map the desktop.
     */
    ppi = PpiFromProcess(pOpenParams->Process);
    if (ppi == NULL) {
        goto Exit;
    }

    /*
     * Do this here, before we (potentially) attach to the process, so
     * we know we're in the right context.
     */
    pheap = Win32HeapGetHandle(pdesk->pheapDesktop);
    hsectionDesktop = pdesk->hsectionDesktop;

    /*
     * We should not map a desktop cross session.
     */
    if (PsGetProcessSessionId(pOpenParams->Process) != pdesk->dwSessionId) {
        FRE_RIPMSG2(RIP_ERROR, "MapDesktop: Trying to map desktop %p into"
                    " process %p in a differnt session. How we ended up here?",
                    pdesk, pOpenParams->Process);

        Status = STATUS_ACCESS_DENIED;
        goto Exit;
    }

    /*
     * If the desktop has already been mapped we're done.
     */
    if (GetDesktopView(ppi, pdesk) != NULL) {
        goto Exit;
    }


    /*
     * Allocate a view of the desktop.
     */
    pdvNew = UserAllocPoolWithQuota(sizeof(*pdvNew), TAG_PROCESSINFO);
    if (pdvNew == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Read/write access has been granted. Map the desktop memory into
     * the client process.
     */
    ulViewSize = 0;
    liOffset.QuadPart = 0;
    pClientBase = NULL;

    Status = MmMapViewOfSection(hsectionDesktop,
                                pOpenParams->Process,
                                &pClientBase,
                                0,
                                0,
                                &liOffset,
                                &ulViewSize,
                                ViewUnmap,
                                SEC_NO_CHANGE,
                                PAGE_EXECUTE_READ);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "MapDesktop - failed to map to client process (Status == 0x%x).",
                Status);

        RIPNTERR0(Status, RIP_VERBOSE, "");
        UserFreePool(pdvNew);
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Link the view into the ppi.
     */
    pdvNew->pdesk         = pdesk;
    pdvNew->ulClientDelta = (ULONG_PTR)(pheap - pClientBase);
    pdvNew->pdvNext       = ppi->pdvList;
    ppi->pdvList          = pdvNew;

Exit:

    END_REENTERCRIT();

    return Status;
}


VOID FreeView(
    PEPROCESS Process,
    PDESKTOP pdesk)
{
    PPROCESSINFO ppi;
    NTSTATUS     Status;
    PDESKTOPVIEW pdv, *ppdv;

    /*
     * Bug 277291: gpepCSRSS can be NULL when FreeView is
     * called from FreeDesktop.
     */
    if (Process == NULL) {
        return;
    }

    /*
     * If there is no ppi, then the process is gone and nothing needs to be
     * unmapped.
     */
    ppi = PpiFromProcess(Process);
    if (ppi != NULL) {
        KAPC_STATE ApcState;
        BOOL       bAttached;
        PBYTE      pHeap;

        /*
         * Before potentially attaching to this process, we need to store
         * away this pointer. However, we don't know that this desktop is
         * even mapped into this process (previously, Win32HeapGetHandle()
         * would only have been called if GetDesktopView returned a non-NULL
         * value, meaning the desktop is mapped into the process). Thus,
         * we need to explicitly check the desktop's heap ptr before we
         * access it.
         */
        if (pdesk->pheapDesktop) {
            pHeap = (PBYTE)Win32HeapGetHandle(pdesk->pheapDesktop);
        } else {
            pHeap = NULL;
        }

        /*
         * We should not have any mapped views cross session.
         */
        if (PsGetProcessSessionId(Process) != pdesk->dwSessionId) {
            KeStackAttachProcess(PsGetProcessPcb(Process), &ApcState);
            bAttached = TRUE;
        } else {
            bAttached = FALSE;
        }

        pdv = GetDesktopView(ppi, pdesk);

        /*
         * Because mapping cannot be done when a handle is inherited, there
         * may not be a view of the desktop. Only unmap if there is a view.
         */
        if (pdv != NULL) {
            UserAssert(pHeap != NULL);
            if (PsGetProcessSessionId(Process) != pdesk->dwSessionId) {
                FRE_RIPMSG2(RIP_ERROR, "FreeView: Trying to free desktop "
                            "%p view into process %p in differnt session. "
                            "How we ended up here?",
                            pdesk, Process);
            }
            Status = MmUnmapViewOfSection(Process,
                                          pHeap - pdv->ulClientDelta);
            UserAssert(NT_SUCCESS(Status) || Status == STATUS_PROCESS_IS_TERMINATING);
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "FreeView unmap status = 0x%x", Status);
            }

            /*
             * Unlink and delete the view.
             */
            for (ppdv = &ppi->pdvList; *ppdv && *ppdv != pdv;
                    ppdv = &(*ppdv)->pdvNext) {
                /* do nothing */;
            }
            UserAssert(*ppdv);
            *ppdv = pdv->pdvNext;
            UserFreePool(pdv);
        }

        /*
         * No thread in this process should be on this desktop.
         */
        DbgCheckForThreadsOnDesktop(ppi, pdesk);

        if (bAttached) {
            KeUnstackDetachProcess(&ApcState);
        }
    }
}


NTSTATUS UnmapDesktop(
    PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams)
{
    PDESKTOP pdesk = (PDESKTOP)pCloseParams->Object;

    BEGIN_REENTERCRIT();

    UserAssert(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->Type == *ExDesktopObjectType);

    TAGMSG4(DBGTAG_Callout,
            "Unmapping desktop 0x%p from process 0x%p (0x%x <-> 0x%x)",
            pdesk,
            pCloseParams->Process,
            PsGetProcessSessionId(pCloseParams->Process),
            pdesk->dwSessionId);

    /*
     * Update cSystemHandles with the correct information.
     */
    pCloseParams->SystemHandleCount = (ULONG)(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->HandleCount) + 1;

    /*
     * Only unmap the desktop if this is the last process handle and
     * the process is not CSR.
     */
    if (pCloseParams->ProcessHandleCount == 1 && pCloseParams->Process != gpepCSRSS) {
        FreeView(pCloseParams->Process, pdesk);
    }

    if (pCloseParams->SystemHandleCount > 2) {
        goto Exit;
    }

    if (pCloseParams->SystemHandleCount == 2 && pdesk->dwConsoleThreadId != 0) {

        /*
         * If a console thread exists and we're down to two handles, it means
         * that the last application handle to the desktop is being closed.
         * Terminate the console thread so the desktop can be freed.
         */
        TerminateConsole(pdesk);
    } else if (pCloseParams->SystemHandleCount == 1) {
        /*
         * If this is the last handle to this desktop in the system,
         * destroy the desktop.
         */

        /*
         * No pti should be linked to this desktop.
         */
        if ((&pdesk->PtiList != pdesk->PtiList.Flink)
                || (&pdesk->PtiList != pdesk->PtiList.Blink)) {

            RIPMSG1(RIP_WARNING, "UnmapDesktop: PtiList not Empty. pdesk:%#p", pdesk);
        }

        DestroyDesktop(pdesk);
    }

Exit:
    END_REENTERCRIT();
    return STATUS_SUCCESS;
}


/***************************************************************************\
* OkayToCloseDesktop
*
* We can only close desktop handles if they're not in use.
*
* History:
* 08-Feb-1999 JerrySh   Created.
\***************************************************************************/
NTSTATUS OkayToCloseDesktop(
    PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams)
{
    PDESKTOP pdesk = (PDESKTOP)pOkCloseParams->Object;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pOkCloseParams->Object)->Type == *ExDesktopObjectType);

    /*
     * Kernel mode code can close anything.
     */
    if (pOkCloseParams->PreviousMode == KernelMode) {
        return STATUS_SUCCESS;
    /*
     * Do not allow a user mode process to close a kernel handle of ours.
     * It shouldn't. In addition, if this happens cross-session, we will try to
     * attach to the system processes and will bugcheck since the seesion
     * address space is not mapped into it. Same for the session manager 
     * process. See bug# 759533.
     */
    } else if (PsGetProcessSessionIdEx(pOkCloseParams->Process) == -1) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * We can't close the desktop if we're still initializing it.
     */
    if (!(pdesk->dwDTFlags & DF_DESKCREATED)) {
        RIPMSG1(RIP_WARNING, "Trying to close desktop %#p during initialization", pdesk);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * We can't close a desktop that's being used.
     */
    if (CheckHandleInUse(pOkCloseParams->Handle) || CheckHandleFlag(pOkCloseParams->Process, pdesk->dwSessionId, pOkCloseParams->Handle, HF_PROTECTED)) {
        RIPMSG1(RIP_WARNING, "Trying to close desktop %#p while still in use", pdesk);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* xxxUserResetDisplayDevice
*
* Called to reset the display device after a switch to another device.
* Used when opening a new device, or when switching back to an old desktop
*
* History:
* 31-May-1994 AndreVa   Created.
\***************************************************************************/
VOID xxxUserResetDisplayDevice(
    VOID)
{
    /*
     * Handle early system initialization gracefully.
     */
    if (grpdeskRitInput != NULL) {
        TL tlpwnd;

        gpqCursor = NULL;

        /*
         * Note that we want to clip the cursor here *before* redrawing the
         * desktop window. Otherwise, when we callback apps might encounter
         * a cursor position that doesn't make sense.
         */
        zzzInternalSetCursorPos(gpsi->ptCursor.x, gpsi->ptCursor.y);
        SetPointer(TRUE);

        UserAssert(grpdeskRitInput != NULL);
        ThreadLock(grpdeskRitInput->pDeskInfo->spwnd, &tlpwnd);
        xxxRedrawWindow(grpdeskRitInput->pDeskInfo->spwnd,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ERASE | RDW_ERASENOW |
                            RDW_ALLCHILDREN);
        ThreadUnlock(&tlpwnd);
    }
}

/***************************************************************************\
* OpenDesktopCompletion
*
* Verifies that a given desktop has successfully opened.
*
* History:
* 03-Oct-1995 JimA      Created.
\***************************************************************************/

BOOL OpenDesktopCompletion(
    PDESKTOP pdesk,
    HDESK    hdesk,
    DWORD    dwFlags,
    BOOL*    pbShutDown)
{
    PPROCESSINFO   ppi = PpiCurrent();
    PWINDOWSTATION pwinsta;

    /*
     * Fail if the windowstation is locked.
     */
    pwinsta = pdesk->rpwinstaParent;

    if (pwinsta->dwWSF_Flags & WSF_OPENLOCK &&
            PsGetProcessId(ppi->Process) != gpidLogon) {
        LUID luidCaller;
        NTSTATUS Status;

        /*
         * If logoff is occuring and the caller does not
         * belong to the session that is ending, allow the
         * open to proceed.
         */
        Status = GetProcessLuid(NULL, &luidCaller);

        if (!NT_SUCCESS(Status) ||
                (pwinsta->dwWSF_Flags & WSF_REALSHUTDOWN) ||
                RtlEqualLuid(&luidCaller, &pwinsta->luidEndSession)) {

            RIPERR0(ERROR_BUSY, RIP_WARNING, "OpenDesktopCompletion failed");

            /*
             * Set the shut down flag.
             */
            *pbShutDown = TRUE;
            return FALSE;
        }
    }

    SetHandleFlag(hdesk, HF_DESKTOPHOOK, dwFlags & DF_ALLOWOTHERACCOUNTHOOK);

    return TRUE;
}

/***************************************************************************\
* _OpenDesktop (API)
*
* Open a desktop object.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 20-Apr-2001 Mohamed   Removed xxx prefix since the function doesn't leave
*                       the Critical Section.
\***************************************************************************/

HDESK _OpenDesktop(
    POBJECT_ATTRIBUTES ccxObjA,
    KPROCESSOR_MODE    AccessMode,
    DWORD              dwFlags,
    DWORD              dwDesiredAccess,
    BOOL*              pbShutDown)
{
    HDESK    hdesk;
    PDESKTOP pdesk;
    NTSTATUS Status;

    /*
     * Require read/write access
     */
    dwDesiredAccess |= DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS;

    /*
     * Open the desktop -- Ob routines capture Obj attributes.
     */
    Status = ObOpenObjectByName(
            ccxObjA,
            *ExDesktopObjectType,
            AccessMode,
            NULL,
            dwDesiredAccess,
            NULL,
            &hdesk);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status, RIP_VERBOSE, "_OpenDesktop: ObOpenObjectByName failed with Status: 0x%x.", Status);
        return NULL;
    }

    /*
     * Reference the desktop
     */
    Status = ObReferenceObjectByHandle(
            hdesk,
            0,
            *ExDesktopObjectType,
            AccessMode,
            &pdesk,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status, RIP_VERBOSE, "_OpenDesktop: ObReferenceObjectByHandle failed with Status: 0x%x.", Status);

Error:
        CloseProtectedHandle(hdesk);
        return NULL;
    }

    if (pdesk->dwSessionId != gSessionId) {
        RIPNTERR1(STATUS_INVALID_HANDLE, RIP_WARNING,
                  "_OpenDesktop pdesk %#p belongs to a different session",
                  pdesk);
        ObDereferenceObject(pdesk);
        goto Error;
    }

    LogDesktop(pdesk, LD_REF_FN_OPENDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

    /*
     * Complete the desktop open
     */
    if (!OpenDesktopCompletion(pdesk, hdesk, dwFlags, pbShutDown)) {
        CloseProtectedHandle(hdesk);
        hdesk = NULL;
    }

    LogDesktop(pdesk, LD_DEREF_FN_OPENDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
    ObDereferenceObject(pdesk);

    if (hdesk != NULL) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
    }

    return hdesk;
}

/***************************************************************************\
* xxxSwitchDesktop (API)
*
* Switch input focus to another desktop and bring it to the top of the
* desktops
*
* dwFlags:
*   SDF_CREATENEW is set when a new desktop has been created on the device, and
*   when we do not want to send another enable\disable
*
*   SDF_SLOVERRIDE is set when we want to ignore WSF_SWITCHLOCK being set on
*   the desktop's winsta.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 11-Oct-2000 JasonSch  Added SDF_SLOVERRIDE flag.
\***************************************************************************/

BOOL xxxSwitchDesktop(
    PWINDOWSTATION pwinsta,
    PDESKTOP       pdesk,
    DWORD          dwFlags)
{
    PETHREAD    Thread;
    PWND        pwndSetForeground;
    TL          tlpwndChild;
    TL          tlpwnd;
    TL          tlhdesk;
    PQ          pq;
    BOOL        bUpdateCursor = FALSE;
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO pti;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTERMINAL   pTerm;
    NTSTATUS    Status;
    HDESK       hdesk;
    BOOL        bRet = TRUE;

    CheckCritIn();

    UserAssert(IsWinEventNotifyDeferredOK());

    if (pdesk == NULL) {
        return FALSE;
    }

    if (pdesk == grpdeskRitInput) {
        return TRUE;
    }

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_ERROR, "xxxSwitchDesktop: destroyed:%#p", pdesk);
        return FALSE;
    }

    UserAssert(!(pdesk->dwDTFlags & (DF_DESKWNDDESTROYED | DF_DYING)));

    if (pwinsta == NULL)
        pwinsta = pdesk->rpwinstaParent;

    /*
     * Get the windowstation, and assert if this process doesn't have one.
     */
    UserAssert(pwinsta);
    if (pwinsta == NULL) {
        RIPMSG1(RIP_WARNING,
                "xxxSwitchDesktop: failed for pwinsta NULL pdesk %#p", pdesk);
        return FALSE;
    }

    /*
     * Don't allow invisible desktops to become active
     */
    if (pwinsta->dwWSF_Flags & WSF_NOIO) {
        RIPMSG1(RIP_VERBOSE,
                "xxxSwitchDesktop: failed for NOIO pdesk %#p", pdesk);
        return FALSE;
    }

    pTerm = pwinsta->pTerm;

    UserAssert(grpdeskRitInput == pwinsta->pdeskCurrent);

    TRACE_INIT(("xxxSwitchDesktop: Entering, desktop = %ws, createdNew = %01lx\n", POBJECT_NAME(pdesk), (DWORD)((dwFlags & SDF_CREATENEW) != 0)));
    if (grpdeskRitInput) {
        TRACE_INIT(("               coming from desktop = %ws\n", POBJECT_NAME(grpdeskRitInput)));
    }

    /*
     * Wait if the logon has the windowstation locked
     */
    Thread = PsGetCurrentThread();

    /*
     * Allow switches to the disconnected desktop
     */
    if (pdesk != gspdeskDisconnect) {
        if (!PsIsSystemThread(Thread) && pdesk != grpdeskLogon  &&
           (((pwinsta->dwWSF_Flags & WSF_SWITCHLOCK) != 0) &&
              (dwFlags & SDF_SLOVERRIDE) == 0)                  &&
           PsGetThreadProcessId(Thread) != gpidLogon) {
            return FALSE;
        }
    }

    /*
     * We don't allow switching away from the disconnect desktop.
     */
    if (gbDesktopLocked && ((!gspdeskDisconnect) || (pdesk != gspdeskDisconnect))) {
        TRACE_DESKTOP(("Attempt to switch away from the disconnect desktop\n"));

        /*
         * we should not lock this global !!! clupu
         */
        LockDesktop(&gspdeskShouldBeForeground, pdesk, LDL_DESKSHOULDBEFOREGROUND1, 0);
        return TRUE;
    }

    /*
     * HACKHACK LATER !!!
     * Where should we really switch the desktop ...
     * And we need to send repaint messages to everyone...
     *
     */

    UserAssert(grpdeskRitInput == pwinsta->pdeskCurrent);

    if ((dwFlags & SDF_CREATENEW) == 0 && grpdeskRitInput &&
        (grpdeskRitInput->pDispInfo->hDev != pdesk->pDispInfo->hDev)) {

        if (grpdeskRitInput->pDispInfo == gpDispInfo) {
            if (!SafeDisableMDEV()) {
                RIPMSG1(RIP_WARNING, "xxxSwitchDesktop: DrvDisableMDEV failed for pdesk %#p",
                       grpdeskRitInput);
                return FALSE;
            }
        } else if (!DrvDisableMDEV(grpdeskRitInput->pDispInfo->pmdev, TRUE)) {
            RIPMSG1(RIP_WARNING, "xxxSwitchDesktop: DrvDisableMDEV failed for pdesk %#p",
                    grpdeskRitInput);
            return FALSE;
        }

        SafeEnableMDEV();
        bUpdateCursor = TRUE;
    }

    /*
     * Grab a handle to the pdesk.
     */
    Status = ObOpenObjectByPointer(pdesk,
                                   OBJ_KERNEL_HANDLE,
                                   NULL,
                                   EVENT_ALL_ACCESS,
                                   NULL,
                                   KernelMode,
                                   &hdesk);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING, "Could not get a handle for pdesk %#p Status 0x%x",
                pdesk, Status);
        return FALSE;
    }

    ThreadLockDesktopHandle(ptiCurrent, &tlhdesk, hdesk);

#if DBG
    /*
     * The current desktop is now the new desktop.
     */
    pwinsta->pdeskCurrent = pdesk;
#endif

    /*
     * Kill any journalling that is occuring. If an app is journaling to the
     * CoolSwitch window, zzzCancelJournalling() will kill the window.
     */
    if (ptiCurrent->rpdesk != NULL) {
        zzzCancelJournalling();
    }

    /*
     * Remove the cool switch window if it's on the RIT. Sending the message
     * is OK because the destination is the RIT, which should never block.
     */
    if (gspwndAltTab != NULL) {
        TL tlpwndT;

        ThreadLockWithPti(ptiCurrent, gspwndAltTab, &tlpwndT);
        xxxSendMessage(gspwndAltTab, WM_CLOSE, 0, 0);
        ThreadUnlock(&tlpwndT);
    }

    /*
     * Remove all trace of previous active window.
     */
    if (grpdeskRitInput != NULL) {
        UserAssert(grpdeskRitInput->spwndForeground == NULL);

        if (grpdeskRitInput->pDeskInfo->spwnd != NULL) {
            if (gpqForeground != NULL) {
                Lock(&grpdeskRitInput->spwndForeground,
                     gpqForeground->spwndActive);

                /*
                 * This is an API so ptiCurrent can pretty much be on any
                 * state. It might not be in grpdeskRitInput (current) or
                 * pdesk (the one we're switching to). It can be sharing its
                 * queue with other threads from another desktop. This is
                 * tricky because we're calling xxxSetForegroundWindow and
                 * xxxSetWindowPos but PtiCurrent might be on whatever
                 * desktop. We cannot cleanly switch ptiCurrent to the
                 * proper desktop because it might be sharing its queue with
                 * other threads, own windows, hooks, etc. So this is kind
                 * of broken.
                 *
                 * Old Comment:
                 * Fixup the current-thread (system) desktop. This could be
                 * needed in case the xxxSetForegroundWindow() calls
                 * xxxDeactivate(). There is logic in their which requires
                 * the desktop. This is only needed temporarily for this case.
                 *
                 * We would only go into xxxDeactivate if ptiCurrent->pq ==
                 * qpqForeground; but if this is the case, then ptiCurrent
                 * must be in grpdeskRitInput already. So I don't think we
                 * need this at all. Let's find out. Note that we might
                 * switch queues while processing the xxxSetForegroundWindow
                 * call. That should be fine as long as we don't switch
                 * desktops.
                 */
                 UserAssert(ptiCurrent->pq != gpqForeground ||
                            ptiCurrent->rpdesk == grpdeskRitInput);

                /*
                 * The SetForegroundWindow call must succed here, so we call
                 * xxxSetForegroundWindow2() directly.
                 */
                xxxSetForegroundWindow2(NULL, ptiCurrent, 0);
            }
        }
    }

    /*
     * Post update events to all queues sending input to the desktop
     * that is becoming inactive.  This keeps the queues in sync up
     * to the desktop switch.
     */
    if (grpdeskRitInput != NULL) {

        pHead = &grpdeskRitInput->PtiList;

        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
            pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
            pq  = pti->pq;

            if (pq->QF_flags & QF_UPDATEKEYSTATE) {
                PostUpdateKeyStateEvent(pq);
            }

            /*
             * Clear the reset bit to ensure that we can properly reset the
             * key state when this desktop again becomes active.
             */
            pq->QF_flags &= ~QF_KEYSTATERESET;
        }
    }

    /*
     * Are we switching away from a destroyed desktop? If so, we might never
     * unlock the pdesk->rpdeskinfo->spwnd.
     */
    if (grpdeskRitInput != NULL) {
        if (grpdeskRitInput->dwDTFlags & DF_ZOMBIE) {
            FRE_RIPMSG1(RIP_ERROR, "xxxSwitchDesktop: switching away from a destroyed desktop. pdesk = %p", grpdeskRitInput);
        }
    }

    /*
     * Send the RIT input to the desktop.  We do this before any window
     * management since DoPaint() uses grpdeskRitInput to go looking for
     * windows with update regions.
     */
    LockDesktop(&grpdeskRitInput, pdesk, LDL_DESKRITINPUT, 0);

    /*
     * Free any spbs that are only valid for the previous desktop.
     */
    FreeAllSpbs();

    /*
     * Lock it into the RIT thread (we could use this desktop rather than
     * the global grpdeskRitInput to direct input!)
     */
    if (zzzSetDesktop(gptiRit, pdesk, NULL) == FALSE) { // DeferWinEventNotify() ?? IANJA ??
        bRet = FALSE;
        goto Error;
    }

    /*
     * Lock the desktop into the desktop thread.  Be sure
     * that the thread is using an unattached queue before
     * setting the desktop.  This is needed to ensure that
     * the thread does not using a shared journal queue
     * for the old desktop.
     */
    if (pTerm->ptiDesktop->pq != pTerm->pqDesktop) {
        UserAssert(pTerm->pqDesktop->cThreads == 0);
        AllocQueue(NULL, pTerm->pqDesktop);
        pTerm->pqDesktop->cThreads++;
        zzzAttachToQueue(pTerm->ptiDesktop, pTerm->pqDesktop, NULL, FALSE);
    }
    if (zzzSetDesktop(pTerm->ptiDesktop, pdesk, NULL) == FALSE) { // DeferWinEventNotify() ?? IANJA ??
        bRet = FALSE;
        goto Error;
    }

    /*
     * Makes sure the desktop thread is running on the active destkop.
     */
    if (pTerm->ptiDesktop->rpdesk != grpdeskRitInput) {
        FRE_RIPMSG0(RIP_ERROR, "xxxSwitchDesktop: desktop thread not running on grpdeskRitInput");
    }


    /*
     * Bring the desktop window to the top and invalidate
     * everything.
     */
    ThreadLockWithPti(ptiCurrent, pdesk->pDeskInfo->spwnd, &tlpwnd);


    /*
     * Suspend DirectDraw before we bring up the desktop window, so we make
     * sure that everything is repainted properly once DirectDraw is disabled.
     */

    GreSuspendDirectDraw(pdesk->pDispInfo->hDev, TRUE);

    xxxSetWindowPos(pdesk->pDeskInfo->spwnd, // WHAT KEEPS pdesk LOCKED - IANJA ???
                    NULL,
                    0,
                    0,
                    0,
                    0,
                    SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_NOCOPYBITS);

    /*
     * At this point, my understanding is that the new desktop window has been
     * brought to the front, and therefore the vis-region of any app on any
     * other desktop is now NULL.
     *
     * So this is the appropriate time to resume DirectDraw, which will
     * ensure the DirectDraw app can not draw anything in the future.
     *
     * If this is not the case, then this code needs to be moved to a more
     * appropriate location.
     *
     * [andreva] 6-26-96
     */

    GreResumeDirectDraw(pdesk->pDispInfo->hDev, TRUE);

    /*
     * Find the first visible top-level window.
     */
    pwndSetForeground = pdesk->spwndForeground;
    if (pwndSetForeground == NULL || HMIsMarkDestroy(pwndSetForeground)) {

        pwndSetForeground = pdesk->pDeskInfo->spwnd->spwndChild;

        while ((pwndSetForeground != NULL) &&
                !TestWF(pwndSetForeground, WFVISIBLE)) {

            pwndSetForeground = pwndSetForeground->spwndNext;
        }
    }
    Unlock(&pdesk->spwndForeground);

    /*
     * Now set it to the foreground.
     */

    if (pwndSetForeground == NULL) {
        xxxSetForegroundWindow2(NULL, NULL, 0);
    } else {

        UserAssert(GETPTI(pwndSetForeground)->rpdesk == grpdeskRitInput);
        /*
         * If the new foreground window is a minimized fullscreen app,
         * make it fullscreen.
         */
        if (GetFullScreen(pwndSetForeground) == FULLSCREENMIN) {
            SetFullScreen(pwndSetForeground, FULLSCREEN);
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwndSetForeground, &tlpwndChild);
        /*
         * The SetForegroundWindow call must succed here, so we call
         * xxxSetForegroundWindow2() directly
         */
        xxxSetForegroundWindow2(pwndSetForeground, ptiCurrent, 0);
        ThreadUnlock(&tlpwndChild);
    }


    ThreadUnlock(&tlpwnd);

    /*
     * Overwrite key state of all queues sending input to the new
     * active desktop with the current async key state.  This
     * prevents apps on inactive desktops from spying on active
     * desktops.  This blows away anything set with SetKeyState,
     * but there is no way of preserving this without giving
     * away information about what keys were hit on other
     * desktops.
     */
    pHead = &grpdeskRitInput->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
        pq  = pti->pq;

        if (!(pq->QF_flags & QF_KEYSTATERESET)) {
            pq->QF_flags |= QF_UPDATEKEYSTATE | QF_KEYSTATERESET;
            RtlFillMemory(pq->afKeyRecentDown, CBKEYSTATERECENTDOWN, 0xff);
            PostUpdateKeyStateEvent(pq);
        }
    }

    /*
     * If there is a hard-error popup up, nuke it and notify the
     * hard error thread that it needs to pop it up again.
     */
    if (gHardErrorHandler.pti) {
        IPostQuitMessage(gHardErrorHandler.pti, 0);
    }

    /*
     * Notify anyone waiting for a desktop switch.
     */
    UserAssert(!(pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    KePulseEvent(gpEventSwitchDesktop, EVENT_INCREMENT, FALSE);

    /*
     * Reset the cursor when we come back from another pdev.
     */
    if (bUpdateCursor == TRUE) {
        gpqCursor = NULL;
        zzzInternalSetCursorPos(gpsi->ptCursor.x, gpsi->ptCursor.y);

        SetPointer(TRUE);
    }


    /*
     * If this desktop was not active during last display settings change
     * let's now bradcast the settings change to its windows. This code is
     * copied from xxxResetDisplayDevice().
     */
    if ((pdesk->dwDTFlags & DF_NEWDISPLAYSETTINGS) && pdesk->pDeskInfo && pdesk->pDeskInfo->spwnd) {
        pdesk->dwDTFlags &= ~DF_NEWDISPLAYSETTINGS;
        xxxBroadcastDisplaySettingsChange(pdesk, TRUE);
    }

Error:
    ThreadUnlockDesktopHandle(&tlhdesk);

    TRACE_INIT(("xxxSwitchDesktop: Leaving\n"));

    return bRet;
}

/***************************************************************************\
* zzzSetDesktop
*
* Set desktop and desktop info in the specified pti.
*
* History:
* 23-Dec-1993 JimA      Created.
\***************************************************************************/
BOOL zzzSetDesktop(
    PTHREADINFO pti,
    PDESKTOP    pdesk,
    HDESK       hdesk)
{
    PTEB                      pteb;
    OBJECT_HANDLE_INFORMATION ohi;
    PDESKTOP                  pdeskRef;
    PDESKTOP                  pdeskOld;
    PCLIENTTHREADINFO         pctiOld;
    TL                        tlpdesk;
    PTHREADINFO               ptiCurrent = PtiCurrent();
    BOOL                      bRet = TRUE;

    if (pti == NULL) {
        UserAssert(pti);
        return FALSE;
    }

    /*
     * A handle without an object pointer is bad news.
     */
    UserAssert(pdesk != NULL || hdesk == NULL);

    /*
     * This desktop must not be destroyed.
     */
    if (pdesk != NULL && (pdesk->dwDTFlags & (DF_DESKWNDDESTROYED | DF_DYING)) &&
        pdesk != pti->rpdesk) {
        /*
         * We need to make an exception for the desktop thread where it is
         * possible that all remaining desktops are marked for destruction so
         * the desktop thread will not be able to run on grpdeskRitInput.
         * Windows Bug #422389.
         */
        if (pti != gTermIO.ptiDesktop) {
            RIPMSG2(RIP_ERROR, "Assigning pti %#p to a dying desktop %#p",
                    pti, pdesk);
            return FALSE;
        } else {
            UserAssert(pdesk == grpdeskRitInput);
        }
    }

    /*
     * Catch reset of important desktops.
     */
    UserAssertMsg0(pti->rpdesk == NULL ||
                   pti->rpdesk->dwConsoleThreadId != TIDq(pti) ||
                   pti->cWindows == 0,
                   "Reset of console desktop");

    /*
     * Clear hook flag.
     */
    pti->TIF_flags &= ~TIF_ALLOWOTHERACCOUNTHOOK;

    /*
     * Get granted access
     */
    pti->hdesk = hdesk;
    if (hdesk != NULL) {
        if (NT_SUCCESS(ObReferenceObjectByHandle(hdesk,
                                                 0,
                                                 *ExDesktopObjectType,
                                                 (pdesk->dwDTFlags & DF_USERMODE)? UserMode : KernelMode,
                                                 &pdeskRef,
                                                 &ohi))) {

            UserAssert(pdesk->dwSessionId == gSessionId);

            LogDesktop(pdeskRef, LD_REF_FN_SETDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

            UserAssert(pdeskRef == pdesk);
            LogDesktop(pdesk, LD_DEREF_FN_SETDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdeskRef);
            pti->amdesk = ohi.GrantedAccess;
            if (CheckHandleFlag(NULL, pdesk->dwSessionId, hdesk, HF_DESKTOPHOOK)) {
                pti->TIF_flags |= TIF_ALLOWOTHERACCOUNTHOOK;
            }

            SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        } else {
            pti->amdesk = 0;
        }
    } else {
        pti->amdesk = 0;
    }

    /*
     * Do nothing else if the thread has initialized and the desktop is not
     * changing.
     */
    if (pdesk != NULL && pdesk == pti->rpdesk) {
        return TRUE;
    }

    /*
     * Save old pointers for later. Locking the old desktop ensures that we
     * will be able to free the CLIENTTHREADINFO structure.
     */
    pdeskOld = pti->rpdesk;
    ThreadLockDesktop(ptiCurrent, pdeskOld, &tlpdesk, LDLT_FN_SETDESKTOP);
    pctiOld = pti->pcti;

    /*
     * Remove the pti from the current desktop.
     */
     if (pti->rpdesk) {
        UserAssert(ISATOMICCHECK() || pti->pq == NULL || pti->pq->cThreads == 1);
        RemoveEntryList(&pti->PtiLink);
     }

    LockDesktop(&pti->rpdesk, pdesk, LDL_PTI_DESK, (ULONG_PTR)pti);


    /*
     * If there is no desktop, we need to fake a desktop info structure so
     * that the IsHooked() macro can test a "valid" fsHooks value. Also link
     * the pti to the desktop.
     */
    if (pdesk != NULL) {
        pti->pDeskInfo = pdesk->pDeskInfo;
        InsertHeadList(&pdesk->PtiList, &pti->PtiLink);
    } else {
        pti->pDeskInfo = &diStatic;
    }

    pteb = PsGetThreadTeb(pti->pEThread);
    if (pteb) {
        PDESKTOPVIEW pdv;
        if (pdesk && (pdv = GetDesktopView(pti->ppi, pdesk))) {
            try {
                pti->pClientInfo->pDeskInfo =
                        (PDESKTOPINFO)((PBYTE)pti->pDeskInfo - pdv->ulClientDelta);

                pti->pClientInfo->ulClientDelta = pdv->ulClientDelta;
                pti->ulClientDelta = pdv->ulClientDelta;

            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                  bRet = FALSE;
                  goto Error;
            }
        } else {
            try {
                pti->pClientInfo->pDeskInfo     = NULL;
                pti->pClientInfo->ulClientDelta = 0;
                pti->ulClientDelta = 0;

            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                  bRet = FALSE;
                  goto Error;
            }
            /*
             * Reset the cursor level to its orginal state.
             */
            pti->iCursorLevel = TEST_GTERMF(GTERMF_MOUSE) ? 0 : -1;
            if (pti->pq)
                pti->pq->iCursorLevel = pti->iCursorLevel;
        }
    }

    /*
     * Allocate thread information visible from client, then copy and free
     * any old info we have lying around.
     */
    if (pdesk != NULL) {

        /*
         * Do not use DesktopAlloc here because the desktop might
         * have DF_DESTROYED set.
         */
        pti->pcti = DesktopAllocAlways(pdesk,
                                       sizeof(CLIENTTHREADINFO),
                                       DTAG_CLIENTTHREADINFO);
    }

    try {

        if (pdesk == NULL || pti->pcti == NULL) {
            pti->pcti = &(pti->cti);
            pti->pClientInfo->pClientThreadInfo = NULL;
        } else {
            pti->pClientInfo->pClientThreadInfo =
                    (PCLIENTTHREADINFO)((PBYTE)pti->pcti - pti->pClientInfo->ulClientDelta);
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        if (pti->pcti != &(pti->cti)) {
            DesktopFree(pdesk, pti->pcti);
        }
        bRet = FALSE;
        goto Error;
    }
    if (pctiOld != NULL) {

        if (pctiOld != pti->pcti) {
            RtlCopyMemory(pti->pcti, pctiOld, sizeof(CLIENTTHREADINFO));
        }

        if (pctiOld != &(pti->cti)) {
            DesktopFree(pdeskOld, pctiOld);
        }

    } else {
        RtlZeroMemory(pti->pcti, sizeof(CLIENTTHREADINFO));
    }

    /*
     * If journalling is occuring on the new desktop, attach to
     * the journal queue.
     * Assert that the pti and the pdesk point to the same deskinfo
     *  if not, we will check the wrong hooks.
     */
    UserAssert(pdesk == NULL || pti->pDeskInfo == pdesk->pDeskInfo);
    UserAssert(pti->rpdesk == pdesk);
    if (pti->pq != NULL) {
        PQ pq = GetJournallingQueue(pti);
        if (pq != NULL) {
            pq->cThreads++;
            zzzAttachToQueue(pti, pq, NULL, FALSE);
        }
    }

Error:
    ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SETDESKTOP);
    return bRet;
}

/***************************************************************************\
* xxxSetThreadDesktop (API)
*
* Associate the current thread with a desktop.
*
* History:
* 16-Jan-1991 JimA      Created stub.
\***************************************************************************/
BOOL xxxSetThreadDesktop(
    HDESK    hdesk,
    PDESKTOP pdesk)
{
    PTHREADINFO  ptiCurrent;
    PPROCESSINFO ppiCurrent;
    PQ           pqAttach;

    ptiCurrent = PtiCurrent();
    ppiCurrent = ptiCurrent->ppi;

    /*
     * If the handle has not been mapped in, do it now.
     */
    if (pdesk != NULL) {
        WIN32_OPENMETHOD_PARAMETERS OpenParams;

        OpenParams.OpenReason = ObOpenHandle;
        OpenParams.Process = ppiCurrent->Process;
        OpenParams.Object = pdesk;
        OpenParams.GrantedAccess = 0;
        OpenParams.HandleCount = 1;


        if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
            return FALSE;
        }

        UserAssert(GetDesktopView(ppiCurrent, pdesk) != NULL);
    }

    /*
     * Check non-system thread status.
     */
    if (PsGetCurrentProcess() != gpepCSRSS) {
        /*
         * Fail if the non-system thread has any windows or thread hooks.
         */
        if (ptiCurrent->cWindows != 0 || ptiCurrent->fsHooks) {
            RIPERR0(ERROR_BUSY, RIP_WARNING, "Thread has windows or hooks");
            return FALSE;
        }

        /*
         * If this is the first desktop assigned to the process,
         * make it the startup desktop.
         */
        if (ppiCurrent->rpdeskStartup == NULL && hdesk != NULL) {
            LockDesktop(&ppiCurrent->rpdeskStartup, pdesk, LDL_PPI_DESKSTARTUP1, (ULONG_PTR)ppiCurrent);
            ppiCurrent->hdeskStartup = hdesk;
        }
    }


    /*
     * If the desktop is changing and the thread is sharing a queue, detach
     * the thread. This will ensure that threads sharing queues are all on
     * the same desktop. This will prevent zzzDestroyQueue from getting
     * confused and setting ptiKeyboard and ptiMouse to NULL when a thread
     * detachs.
     */
    if (ptiCurrent->rpdesk != pdesk) {
        if (ptiCurrent->pq->cThreads > 1) {
            pqAttach = AllocQueue(NULL, NULL);
            if (pqAttach != NULL) {
                pqAttach->cThreads++;
                zzzAttachToQueue(ptiCurrent, pqAttach, NULL, FALSE);
            } else {
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "Thread could not be detached");
                return FALSE;
            }
        } else if (ptiCurrent->pq == gpqForeground) {
            /*
             * This thread doesn't own any windows, still it's attached to
             * qpgForeground and it's the only thread attached to it. Since
             * any threads attached to qpgForeground must be in grpdeskRitInput,
             * we must set qpgForeground to NULL here because this thread is
             * going to another desktop.
             */
            UserAssert(ptiCurrent->pq->spwndActive == NULL);
            UserAssert(ptiCurrent->pq->spwndCapture == NULL);
            UserAssert(ptiCurrent->pq->spwndFocus == NULL);
            UserAssert(ptiCurrent->pq->spwndActivePrev == NULL);
            xxxSetForegroundWindow2(NULL, ptiCurrent, 0);
        } else if (ptiCurrent->rpdesk == NULL) {
            /*
             * We need to initialize iCursorLevel.
             */
            ptiCurrent->iCursorLevel = TEST_GTERMF(GTERMF_MOUSE) ? 0 : -1;
            ptiCurrent->pq->iCursorLevel = ptiCurrent->iCursorLevel;
        }

        UserAssert(ptiCurrent->pq != gpqForeground);
    }

    if (zzzSetDesktop(ptiCurrent, pdesk, hdesk) == FALSE) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* xxxGetThreadDesktop (API)
*
* Return a handle to the desktop assigned to the specified thread.
*
* History:
* 16-Jan-1991 JimA      Created stub.
\***************************************************************************/

HDESK xxxGetThreadDesktop(
    DWORD           dwThread,
    HDESK           hdeskConsole,
    KPROCESSOR_MODE AccessMode)
{
    PTHREADINFO  pti = PtiFromThreadId(dwThread);
    PPROCESSINFO ppiThread;
    HDESK        hdesk;
    NTSTATUS     Status;

    if (pti == NULL) {

        /*
         * If the thread has a console use that desktop.  If
         * not, then the thread is either invalid or not
         * a Win32 thread.
         */
        if (hdeskConsole == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_VERBOSE,
                    "xxxGetThreadDesktop: invalid threadId 0x%x",
                    dwThread);
            return NULL;
        }

        hdesk = hdeskConsole;
        ppiThread = PpiFromProcess(gpepCSRSS);
    } else {
        hdesk = pti->hdesk;
        ppiThread = pti->ppi;
    }

    /*
     * If there is no desktop, return NULL with no error
     */
    if (hdesk != NULL) {

        /*
         * If the thread belongs to this process, return the
         * handle.  Otherwise, enumerate the handle table of
         * this process to find a handle with the same
         * attributes.
         */
        if (ppiThread != PpiCurrent()) {
            PVOID pobj;
            OBJECT_HANDLE_INFORMATION ohi;

            RIPMSG4(RIP_VERBOSE, "[%x.%x] %s called xxxGetThreadDesktop for pti %#p",
                    PsGetCurrentProcessId(),
                    PsGetCurrentThreadId(),
                    PsGetCurrentProcessImageFileName(),
                    pti);

            KeAttachProcess(PsGetProcessPcb(ppiThread->Process));
            Status = ObReferenceObjectByHandle(hdesk,
                                               0,
                                               *ExDesktopObjectType,
                                               AccessMode,
                                               &pobj,
                                               &ohi);
            KeDetachProcess();
            if (!NT_SUCCESS(Status) ||
                !ObFindHandleForObject(PsGetCurrentProcess(), pobj, NULL, &ohi, &hdesk)) {

                RIPMSG0(RIP_VERBOSE, "Cannot find hdesk for current process");

                hdesk = NULL;

            } else {
                LogDesktop(pobj, LD_REF_FN_GETTHREADDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());
            }
            if (NT_SUCCESS(Status)) {
                LogDesktop(pobj, LD_DEREF_FN_GETTHREADDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
                ObDereferenceObject(pobj);
            }
        }

        if (hdesk == NULL) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "xxxGetThreadDesktop: hdesk is null");
        } else {
            SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        }
    }

    return hdesk;
}


/***************************************************************************\
* _GetInputDesktop (API)
*
* Obsolete - kept for compatibility only.  Return a handle to the
* desktop currently receiving input.  Returns the first handle to
* the input desktop found.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
\***************************************************************************/
HDESK _GetInputDesktop(
    VOID)
{
    HDESK hdesk;

    if (ObFindHandleForObject(PsGetCurrentProcess(), grpdeskRitInput, NULL, NULL, &hdesk)) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        return hdesk;
    } else {
        return NULL;
    }
}

/***************************************************************************\
* xxxCloseDesktop (API)
*
* Close a reference to a desktop and destroy the desktop if it is no
* longer referenced.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

BOOL xxxCloseDesktop(
    HDESK           hdesk,
    KPROCESSOR_MODE AccessMode)
{
    PDESKTOP     pdesk;
    PTHREADINFO  ptiT;
    PPROCESSINFO ppi;
    NTSTATUS     Status;

    ppi = PpiCurrent();

    /*
     * Get a pointer to the desktop.
     */
    Status = ObReferenceObjectByHandle(
            hdesk,
            0,
            *ExDesktopObjectType,
            AccessMode,
            &pdesk,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }

    UserAssert(pdesk->dwSessionId == gSessionId);

    LogDesktop(pdesk, LD_REF_FN_CLOSEDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

    if (ppi->Process != gpepCSRSS) {

        /*
         * Disallow closing of the desktop if the handle is in use by
         * any threads in the process.
         */
        for (ptiT = ppi->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {
            if (ptiT->hdesk == hdesk) {
                RIPERR2(ERROR_BUSY, RIP_WARNING,
                        "CloseDesktop: Desktop %#p still in use by thread %#p",
                        pdesk, ptiT);
                LogDesktop(pdesk, LD_DEREF_FN_CLOSEDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());
                ObDereferenceObject(pdesk);
                return FALSE;
            }
        }

        /*
         * If this is the startup desktop, unlock it
         */
         /*
          * Bug 41394. Make sure that hdesk == ppi->hdeskStartup. We might
          * be getting a handle to the desktop object that is different
          * from ppi->hdeskStartup but we still end up
          * setting ppi->hdeskStartup to NULL.
          */
        if ((pdesk == ppi->rpdeskStartup) && (hdesk == ppi->hdeskStartup)) {
            UnlockDesktop(&ppi->rpdeskStartup, LDU_PPI_DESKSTARTUP2, (ULONG_PTR)ppi);
            ppi->hdeskStartup = NULL;
        }
    }

    /*
     * Clear hook flag
     */
    SetHandleFlag(hdesk, HF_DESKTOPHOOK, FALSE);

    /*
     * Close the handle
     */
    Status = CloseProtectedHandle(hdesk);

    LogDesktop(pdesk, LD_DEREF_FN_CLOSEDESKTOP2, FALSE, (ULONG_PTR)PtiCurrent());
    ObDereferenceObject(pdesk);
    UserAssert(NT_SUCCESS(Status));

    return TRUE;
}

/***************************************************************************\
* TerminateConsole
*
* Post a quit message to a console thread and wait for it to terminate.
*
* History:
* 08-May-1995 JimA      Created.
\***************************************************************************/
VOID TerminateConsole(
    PDESKTOP pdesk)
{
    NTSTATUS Status;
    PETHREAD Thread;
    PTHREADINFO pti;

    if (pdesk->dwConsoleThreadId == 0) {
        return;
    }

    /*
     * Locate the console thread.
     */
    Status = LockThreadByClientId(LongToHandle(pdesk->dwConsoleThreadId), &Thread);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    /*
     * Post a quit message to the console.
     */
    pti = PtiFromThread(Thread);
    if (pti == NULL) {
        FRE_RIPMSG1(RIP_ERROR,
                    "PtiFromThread for CIT 0x%p returned NULL!",
                    Thread);
    }

    if (pti != NULL) {
        _PostThreadMessage(pti, WM_QUIT, 0, 0);
    }

    /*
     * Clear thread id so we don't post twice
     */
    pdesk->dwConsoleThreadId = 0;

    UnlockThread(Thread);
}

/***************************************************************************\
* CheckHandleFlag
*
* Returns TRUE if the desktop handle allows other accounts
* to hook this process.
*
* History:
* 07-13-95 JimA         Created.
\***************************************************************************/
BOOL CheckHandleFlag(
    PEPROCESS Process,
    DWORD     dwSessionId,
    HANDLE    hObject,
    DWORD     dwFlag)
{
    ULONG Index = ((PEXHANDLE)&hObject)->Index * HF_LIMIT + dwFlag;
    BOOL fRet = FALSE, bAttached = FALSE;
    PPROCESSINFO ppi;
    KAPC_STATE ApcState;

    EnterHandleFlagsCrit();

    if (Process == NULL) {
        ppi = PpiCurrent();
    } else {
        if (PsGetProcessSessionId(Process) != dwSessionId) {
            KeStackAttachProcess(PsGetProcessPcb(Process), &ApcState);
            bAttached = TRUE;
        }
        ppi = PpiFromProcess(Process);
    }

    if (ppi != NULL) {
        fRet = (Index < ppi->bmHandleFlags.SizeOfBitMap &&
                RtlCheckBit(&ppi->bmHandleFlags, Index));
    }

    if (bAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    LeaveHandleFlagsCrit();

    return fRet;
}

/***************************************************************************\
* SetHandleFlag
*
* Sets and clears the ability of a desktop handle to allow
* other accounts to hook this process.
*
* History:
* 07-13-95 JimA         Created.
\***************************************************************************/

BOOL SetHandleFlag(
    HANDLE       hObject,
    DWORD        dwFlag,
    BOOL         fSet)
{
    PPROCESSINFO ppi;
    ULONG Index = ((PEXHANDLE)&hObject)->Index * HF_LIMIT + dwFlag;
    PRTL_BITMAP pbm;
    ULONG       cBits;
    PULONG      Buffer;
    BOOL fRet = TRUE;

    UserAssert(dwFlag < HF_LIMIT);

    EnterHandleFlagsCrit();

    if ((ppi = PpiCurrent()) != NULL) {
        pbm = &ppi->bmHandleFlags;
        if (fSet) {

            /*
             * Expand the bitmap if needed
             */
            if (Index >= pbm->SizeOfBitMap) {
                /*
                 * Index is zero-based - cBits is an exact number of dwords
                 */
                cBits = ((Index + 1) + 0x1F) & ~0x1F;
                Buffer = UserAllocPoolWithQuotaZInit(cBits / 8, TAG_PROCESSINFO);
                if (Buffer == NULL) {
                    fRet = FALSE;
                    goto Exit;
                }
                if (pbm->Buffer) {
                    RtlCopyMemory(Buffer, pbm->Buffer, pbm->SizeOfBitMap / 8);
                    UserFreePool(pbm->Buffer);
                }

                RtlInitializeBitMap(pbm, Buffer, cBits);
            }

            RtlSetBits(pbm, Index, 1);
        } else if (Index < pbm->SizeOfBitMap) {
            RtlClearBits(pbm, Index, 1);
        }
    }

Exit:
    LeaveHandleFlagsCrit();

    return fRet;
}


/***************************************************************************\
* CheckHandleInUse
*
* Returns TRUE if the handle is currently in use.
*
* History:
* 02-Jun-1999 JerrySh   Created.
\***************************************************************************/
BOOL CheckHandleInUse(
    HANDLE hObject)
{
    BOOL fRet;

    EnterHandleFlagsCrit();
    fRet = ((gProcessInUse == PsGetCurrentProcess()) &&
            (gHandleInUse == hObject));
    LeaveHandleFlagsCrit();

    return fRet;
}

/***************************************************************************\
* SetHandleInUse
*
* Mark the handle as in use.
*
* History:
* 02-Jun-1999 JerrySh   Created.
\***************************************************************************/
VOID SetHandleInUse(
    HANDLE hObject)
{
    EnterHandleFlagsCrit();
    gProcessInUse = PsGetCurrentProcess();
    gHandleInUse = hObject;
    LeaveHandleFlagsCrit();
}

/***************************************************************************\
* xxxResolveDesktopForWOW
*
* Checks whether given process has access to the provided windowstation/desktop 
* or the defaults if none are specified. (WinSta0\Default).
*
* History:
* 03-Jan-2002 Mohamed   Modified to use dynamically allocated VM for 
*                       string buffers and CR for security on handle 
*                       manipulation.  Using UserMode handles intentionally 
*                       to undergo the needed security access checks.
\***************************************************************************/
NTSTATUS xxxResolveDesktopForWOW(
    IN OUT PUNICODE_STRING pstrDesktop)
{
    NTSTATUS           Status = STATUS_SUCCESS;
    UNICODE_STRING     strDesktop, strWinSta, strStatic;
    WCHAR              wchStaticBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    LPWSTR             pszDesktop;
    BOOL               fWinStaDefaulted;
    BOOL               fDesktopDefaulted;
    HWINSTA            hwinsta;
    HDESK              hdesk;
    PUNICODE_STRING    pstrStatic;
    POBJECT_ATTRIBUTES pObjA = NULL;
    SIZE_T             cbObjA;
    BOOL               bShutDown = FALSE;

    /*
     * Determine windowstation and desktop names.
     */
    if (pstrDesktop == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    strStatic.Length = 0;
    strStatic.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
    strStatic.Buffer = wchStaticBuffer;

    if (pstrDesktop->Length == 0) {
        RtlInitUnicodeString(&strDesktop, L"Default");
        fWinStaDefaulted = fDesktopDefaulted = TRUE;
    } else {
        USHORT cch;

        /*
         * The name be of the form windowstation\desktop. Parse the string
         * to separate out the names.
         */
        strWinSta = *pstrDesktop;
        cch = strWinSta.Length / sizeof(WCHAR);
        pszDesktop = strWinSta.Buffer;
        while (cch && *pszDesktop != L'\\') {
            cch--;
            pszDesktop++;
        }
        fDesktopDefaulted = FALSE;

        if (cch == 0) {

            /*
             * No windowstation name was specified, only the desktop.
             */
            strDesktop = strWinSta;
            fWinStaDefaulted = TRUE;
        } else {
            /*
             * Both names were in the string.
             */
            strDesktop.Buffer = pszDesktop + 1;
            strDesktop.Length = strDesktop.MaximumLength = (cch - 1) * sizeof(WCHAR);
            strWinSta.Length = (USHORT)(pszDesktop - strWinSta.Buffer) * sizeof(WCHAR);

            /*
             * zero terminate the strWinSta buffer so the rebuild of the desktop
             * name at the end of the function works.
             */
            *pszDesktop = (WCHAR)0;

            fWinStaDefaulted = FALSE;

            RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
            RtlAppendUnicodeToString(&strStatic, L"\\");
            RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
        }
    }

    if (fWinStaDefaulted) {

        /*
         * Default Window Station.
         */
        RtlInitUnicodeString(&strWinSta, L"WinSta0");

        RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
        RtlAppendUnicodeToString(&strStatic, L"\\");
        RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
    }

    /*
     * Open the computed windowstation. This will also do an access check.
     */

    /*
     * Allocate an object attributes structure, a UNICODE_STRING structure and a string 
     * buffer of suitable length in user address space.
     */
    cbObjA = sizeof(*pObjA) + sizeof(*pstrStatic) + STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
    Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
            &pObjA, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
    pstrStatic = (PUNICODE_STRING)((PBYTE)pObjA + sizeof(*pObjA));

    if (NT_SUCCESS(Status)) {
        /*
         * Note -- the string must be in client-space or the address
         * validation in _OpenWindowStation will fail. And we use UserMode
         * for KPROCESSOR_MODE to be able to utilize security checks;
         * KernelMode would bypass the checks. The side-effect of this is
         * that the returned hwinsta and hdesk handles are UserMode handles
         * and must be handled with care.
         */
        try {
            pstrStatic->Length = 0;
            pstrStatic->MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
            pstrStatic->Buffer = (PWSTR)((PBYTE)pstrStatic + sizeof(*pstrStatic));
            RtlCopyUnicodeString(pstrStatic, &strStatic);
            InitializeObjectAttributes(pObjA,
                                       pstrStatic,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }

        if (NT_SUCCESS(Status)) {
            hwinsta = _OpenWindowStation(pObjA, MAXIMUM_ALLOWED, UserMode);
        } else {
            hwinsta = NULL;
        }
        if (!hwinsta) {
            ZwFreeVirtualMemory(NtCurrentProcess(),
                                &pObjA,
                                &cbObjA,
                                MEM_RELEASE);
            return STATUS_ACCESS_DENIED;
        }
    } else {
        return STATUS_NO_MEMORY;
    }

    /*
     * Do an access check on the desktop by opening it
     */

    /*
     * Note -- the string must be in client-space or the
     * address validation in _OpenDesktop will fail.
     */
    try {
        RtlCopyUnicodeString(pstrStatic, &strDesktop);

        InitializeObjectAttributes( pObjA,
                                    pstrStatic,
                                    OBJ_CASE_INSENSITIVE,
                                    hwinsta,
                                    NULL);

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        Status = GetExceptionCode();
    }

    if (NT_SUCCESS(Status)) {
        hdesk = _OpenDesktop(pObjA,
                             UserMode,
                             0,
                             MAXIMUM_ALLOWED,
                             &bShutDown);
    } else {
        hdesk = NULL;
    }

    ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA, MEM_RELEASE);
    UserVerify(NT_SUCCESS(ObCloseHandle(hwinsta, UserMode)));

    if (!hdesk) {
        return STATUS_ACCESS_DENIED;
    }

    CloseProtectedHandle(hdesk);

    /*
     * Copy the final Computed String
     */
    RtlCopyUnicodeString(pstrDesktop, &strWinSta);
    RtlAppendUnicodeToString(pstrDesktop, L"\\");
    RtlAppendUnicodeStringToString(pstrDesktop, &strDesktop);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* xxxResolveDesktop
*
* Attempts to return handles to a windowstation and desktop associated
* with the logon session.
*
* History:
* 25-Apr-1994 JimA      Created.
* 03-Jan-2002 Mohamed   Modified it to use dynamically allocated VM for 
*                       string buffers and CR for security on handle 
*                       manipulation.  Using UserMode handles intentionally 
*                       to undergo the needed security access checks.
\***************************************************************************/
HDESK xxxResolveDesktop(
    HANDLE          hProcess,
    PUNICODE_STRING pstrDesktop,
    HWINSTA         *phwinsta,
    BOOL            fInherit,
    BOOL*           pbShutDown)
{
    PEPROCESS          Process;
    PPROCESSINFO       ppi;
    HWINSTA            hwinsta;
    HDESK              hdesk;
    PDESKTOP           pdesk;
    PWINDOWSTATION     pwinsta;
    BOOL               fInteractive;
    UNICODE_STRING     strDesktop,
                       strWinSta,
                       strStatic;
    PUNICODE_STRING    pstrStatic;
    WCHAR              wchStaticBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    LPWSTR             pszDesktop;
    POBJECT_ATTRIBUTES pObjA = NULL;
    SIZE_T             cbObjA;
    WCHAR              awchName[sizeof(L"Service-0x0000-0000$") / sizeof(WCHAR)];
    BOOL               fWinStaDefaulted;
    BOOL               fDesktopDefaulted;
    LUID               luidService;
    NTSTATUS           Status;
    HWINSTA            hwinstaDup;

    CheckCritIn();

    Status = ObReferenceObjectByHandle(hProcess,
                                       PROCESS_QUERY_INFORMATION,
                                       *PsProcessType,
                                       UserMode,
                                       &Process,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxResolveDesktop: Could not reference process handle (0x%X)", hProcess);
        return NULL;
    }

    hwinsta = hwinstaDup = NULL;
    hdesk = NULL;

    strStatic.Length = 0;
    strStatic.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
    strStatic.Buffer = wchStaticBuffer;

    /*
     * If the process already has a windowstation and a startup desktop,
     * return them.
     *
     * Make sure the process has not been destroyed first. Windows NT Bug
     * #214643.
     */
    ppi = PpiFromProcess(Process);
    if (ppi != NULL) {
        if (ppi->W32PF_Flags & W32PF_TERMINATED) {
            ObDereferenceObject(Process);
            RIPMSG1(RIP_WARNING,
                    "xxxResolveDesktop: ppi 0x%p has been destroyed",
                    ppi);
            return NULL;
        }

        if (ppi->hwinsta != NULL && ppi->hdeskStartup != NULL) {
            /*
             * If the target process is the current process, simply return
             * the handles. Otherwise, open the objects.
             */
            if (Process == PsGetCurrentProcess()) {
                hwinsta = ppi->hwinsta;
                hdesk = ppi->hdeskStartup;
            } else {
                Status = ObOpenObjectByPointer(ppi->rpwinsta,
                                               0,
                                               NULL,
                                               MAXIMUM_ALLOWED,
                                               *ExWindowStationObjectType,
                                               UserMode,
                                               &hwinsta);
                if (NT_SUCCESS(Status)) {
                    Status = ObOpenObjectByPointer(ppi->rpdeskStartup,
                                                   0,
                                                   NULL,
                                                   MAXIMUM_ALLOWED,
                                                   *ExDesktopObjectType,
                                                   UserMode,
                                                   &hdesk);
                    if (!NT_SUCCESS(Status)) {
                        UserVerify(NT_SUCCESS(ObCloseHandle(hwinsta, UserMode)));
                        hwinsta = NULL;
                    }
                }

                if (!NT_SUCCESS(Status)) {
                    RIPNTERR2(Status,
                              RIP_WARNING,
                              "xxxResolveDesktop: Failed to reference winsta=0x%p or desktop=0x%p",
                              ppi->rpwinsta,
                              ppi->rpdeskStartup);
                }
            }

            RIPMSG2(RIP_VERBOSE,
                    "xxxResolveDesktop: to hwinsta=%#p desktop=%#p",
                    hwinsta, hdesk);

            ObDereferenceObject(Process);
            *phwinsta = hwinsta;
            return hdesk;
        }
    }

    /*
     * Determine windowstation and desktop names.
     */
    if (pstrDesktop == NULL || pstrDesktop->Length == 0) {
        RtlInitUnicodeString(&strDesktop, L"Default");
        fWinStaDefaulted = fDesktopDefaulted = TRUE;
    } else {
        USHORT cch;

        /*
         * The name is of the form windowstation\desktop. Parse the string
         * to separate out the names.
         */
        strWinSta = *pstrDesktop;
        cch = strWinSta.Length / sizeof(WCHAR);
        pszDesktop = strWinSta.Buffer;
        while (cch && *pszDesktop != L'\\') {
            cch--;
            pszDesktop++;
        }
        fDesktopDefaulted = FALSE;

        if (cch == 0) {
            /*
             * No windowstation name was specified, only the desktop.
             */
            strDesktop = strWinSta;
            fWinStaDefaulted = TRUE;
        } else {
             /*
             * Both names were in the string.
             */
            strDesktop.Buffer = pszDesktop + 1;
            strDesktop.Length = strDesktop.MaximumLength = (cch - 1) * sizeof(WCHAR);
            strWinSta.Length = (USHORT)(pszDesktop - strWinSta.Buffer) * sizeof(WCHAR);
            fWinStaDefaulted = FALSE;
            RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
            RtlAppendUnicodeToString(&strStatic, L"\\");
            RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
            if (!NT_SUCCESS(Status = _UserTestForWinStaAccess(&strStatic,TRUE))) {
                RIPMSG3(RIP_WARNING,
                        "xxxResolveDesktop: Error (0x%x) resolving winsta='%.*ws'",
                        Status,
                        strStatic.Length,
                        strStatic.Buffer);
                goto ReturnNull;
            }
        }
    }

    /*
     * If the desktop name is defaulted, make the handles not inheritable.
     */
    if (fDesktopDefaulted) {
        fInherit = FALSE;
    }

    /*
     * If a windowstation has not been assigned to this process yet and
     * there are existing windowstations, attempt an open.
     */
    if (hwinsta == NULL && grpWinStaList) {
        /*
         * If the windowstation name was defaulted, create a name based on
         * the session.
         */
        if (fWinStaDefaulted) {
            /*
             * Default Window Station.
             */ 
            RtlInitUnicodeString(&strWinSta, L"WinSta0");
            RtlAppendUnicodeToString(&strStatic, szWindowStationDirectory);
            RtlAppendUnicodeToString(&strStatic, L"\\");
            RtlAppendUnicodeStringToString(&strStatic, &strWinSta);

            if (gbRemoteSession) {
                /*
                 * Fake this out if it's an non-interactive winstation startup.
                 * We don't want an extra winsta.
                 */
                fInteractive = NT_SUCCESS(_UserTestForWinStaAccess(&strStatic, TRUE));
            } else {
                fInteractive = NT_SUCCESS(_UserTestForWinStaAccess(&strStatic,fInherit));
            }

            if (!fInteractive) {
                GetProcessLuid(NULL, &luidService);
                swprintf(awchName,
                         L"Service-0x%x-%x$",
                         luidService.HighPart,
                         luidService.LowPart);
                RtlInitUnicodeString(&strWinSta, awchName);
            }
        }

        /*
         * If no windowstation name was passed in and a windowstation
         * handle was inherited, assign it.
         */
        if (fWinStaDefaulted) {
            if (ObFindHandleForObject(Process, NULL, *ExWindowStationObjectType,
                    NULL, &hwinsta)) {

                /*
                 * If the handle belongs to another process, dup it into
                 * this one.
                 */
                if (Process != PsGetCurrentProcess()) {
                    Status = ZwDuplicateObject(hProcess,
                                               hwinsta,
                                               NtCurrentProcess(),
                                               &hwinstaDup,
                                               0,
                                               0,
                                               DUPLICATE_SAME_ACCESS);
                    if (!NT_SUCCESS(Status)) {
                        hwinsta = NULL;
                    } else {
                        hwinsta = hwinstaDup;
                    }
                }
            }
        }

        /*
         * If we were assigned to a windowstation, make sure
         * it matches our fInteractive flag
         */
        if (hwinsta != NULL) {
            Status = ObReferenceObjectByHandle(hwinsta,
                                               0,
                                               *ExWindowStationObjectType,
                                               KernelMode,
                                               &pwinsta,
                                               NULL);
            if (NT_SUCCESS(Status)) {
                BOOL fIO = (pwinsta->dwWSF_Flags & WSF_NOIO) ? FALSE : TRUE;
                if (fIO != fInteractive) {
                    if (hwinstaDup) {
                        CloseProtectedHandle(hwinsta);
                    }
                    hwinsta = NULL;
                }
                ObDereferenceObject(pwinsta);
            }
        }

        /*
         * If not, open the computed windowstation.
         */
        if (NT_SUCCESS(Status) && hwinsta == NULL) {

            /*
             * Fill in the path to the windowstation
             */
            strStatic.Length = 0;
            RtlAppendUnicodeToString(&strStatic, szWindowStationDirectory);
            RtlAppendUnicodeToString(&strStatic, L"\\");
            RtlAppendUnicodeStringToString(&strStatic, &strWinSta);

            /*
             * Allocate an object attributes structure, a UNICODE_STRING structure and a string 
             * buffer of suitable length in user address space.
             */
            cbObjA = sizeof(*pObjA) + sizeof(*pstrStatic) + STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
            Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                    &pObjA, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
            pstrStatic = (PUNICODE_STRING)((PBYTE)pObjA + sizeof(*pObjA));

            if (NT_SUCCESS(Status)) {
                /*
                 * Note -- the string must be in client-space or the
                 * address validation in _OpenWindowStation will fail.
                 */
                try {
                    pstrStatic->Length = 0;
                    pstrStatic->MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
                    pstrStatic->Buffer = (PWSTR)((PBYTE)pstrStatic + sizeof(*pstrStatic));
                    RtlCopyUnicodeString(pstrStatic, &strStatic);
                    InitializeObjectAttributes(pObjA,
                                               pstrStatic,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               NULL);
                    if (fInherit) {
                        pObjA->Attributes |= OBJ_INHERIT;
                    }
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    Status = GetExceptionCode();
                }

                if (NT_SUCCESS(Status)) {
                    hwinsta = _OpenWindowStation(pObjA, MAXIMUM_ALLOWED, UserMode);
                }
            }
        }

        /*
         * Only allow service logons at the console. I don't think our
         * win32k exit routines cope with more than one windowstation.
         *
         * If the open failed and the process is in a non-interactive logon
         * session, attempt to create a windowstation and desktop for that
         * session. Note that the desktop handle will be closed after the
         * desktop has been assigned.
         */
        if (!gbRemoteSession && NT_SUCCESS(Status) &&
            hwinsta == NULL && !fInteractive && fWinStaDefaulted) {

            *phwinsta = xxxConnectService(&strStatic, &hdesk);

            /*
             * Clean up and leave.
             */
            if (pObjA != NULL) {
                ZwFreeVirtualMemory(NtCurrentProcess(),
                                    &pObjA,
                                    &cbObjA,
                                    MEM_RELEASE);
            }
            ObDereferenceObject(Process);

            RIPMSG2(RIP_VERBOSE,
                    "xxxResolveDesktop: xxxConnectService was called"
                    "to hwinsta=%#p desktop=%#p",
                    *phwinsta, hdesk);

            return hdesk;
        }
    }

    /*
     * Attempt to assign a desktop.
     */
    if (hwinsta != NULL) {
        /*
         * Every gui thread needs an associated desktop. We'll use the
         * default to start with and the application can override it if it
         * wants.
         */
        if (hdesk == NULL) {
            /*
             * If no desktop name was passed in and a desktop handle was
             * inherited, assign it.
             */
            if (fDesktopDefaulted) {
                if (ObFindHandleForObject(Process, NULL, *ExDesktopObjectType,
                         NULL, &hdesk)) {

                    /*
                     * If the handle belongs to another process, dup it into
                     * this one.
                     */
                    if (Process != PsGetCurrentProcess()) {
                        HDESK hdeskDup;

                        Status = ZwDuplicateObject(hProcess,
                                                   hdesk,
                                                   NtCurrentProcess(),
                                                   &hdeskDup,
                                                   0,
                                                   0,
                                                   DUPLICATE_SAME_ACCESS);
                        if (!NT_SUCCESS(Status)) {
                            CloseProtectedHandle(hdesk);
                            hdesk = NULL;
                        } else {
                            hdesk = hdeskDup;
                        }
                    }

                    /*
                     * Map the desktop into the process.
                     */
                    if (hdesk != NULL && ppi != NULL) {
                        Status = ObReferenceObjectByHandle(hdesk,
                                                  0,
                                                  *ExDesktopObjectType,
                                                  KernelMode,
                                                  &pdesk,
                                                  NULL);
                        if (NT_SUCCESS(Status)) {

                            LogDesktop(pdesk, LD_REF_FN_RESOLVEDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

                            {
                               WIN32_OPENMETHOD_PARAMETERS OpenParams;

                               OpenParams.OpenReason = ObOpenHandle;
                               OpenParams.Process = Process;
                               OpenParams.Object = pdesk;
                               OpenParams.GrantedAccess = 0;
                               OpenParams.HandleCount = 1;

                                if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
                                    Status = STATUS_NO_MEMORY;
                                    CloseProtectedHandle(hdesk);
                                    hdesk = NULL;
                                }
                            }

                            UserAssert(hdesk == NULL ||
                                       GetDesktopView(ppi, pdesk) != NULL);

                            LogDesktop(pdesk, LD_DEREF_FN_RESOLVEDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
                            ObDereferenceObject(pdesk);
                        } else {
                            CloseProtectedHandle(hdesk);
                            hdesk = NULL;
                        }
                    }
                }
            }

            /*
             * If not, open the desktop.
             */
            if (NT_SUCCESS(Status) && hdesk == NULL) {
                RtlCopyUnicodeString(&strStatic, &strDesktop);

                if (pObjA == NULL) {
                    /*
                     * Allocate an object attributes structure, a UNICODE_STRING structure and a string 
                     * buffer of suitable length in user address space.
                     */
                    cbObjA = sizeof(*pObjA) + sizeof(*pstrStatic) + STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
                    Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                            &pObjA, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
                    pstrStatic = (PUNICODE_STRING)((PBYTE)pObjA + sizeof(*pObjA));
                }

                if (NT_SUCCESS(Status)) {
                    /*
                     * Note -- the string must be in client-space or the
                     * address validation in _OpenDesktop will fail.
                     */
                    try {
                        pstrStatic->Length = 0;
                        pstrStatic->MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
                        pstrStatic->Buffer = (PWSTR)((PBYTE)pstrStatic + sizeof(*pstrStatic));
                        RtlCopyUnicodeString(pstrStatic, &strStatic);
                        InitializeObjectAttributes( pObjA,
                                                    pstrStatic,
                                                    OBJ_CASE_INSENSITIVE,
                                                    hwinsta,
                                                    NULL
                                                    );
                        if (fInherit) {
                            pObjA->Attributes |= OBJ_INHERIT;
                        }
                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                        Status = GetExceptionCode();
                    }

                    if (NT_SUCCESS(Status)) {
                        hdesk = _OpenDesktop(pObjA,
                                             UserMode,
                                             0,
                                             MAXIMUM_ALLOWED,
                                             pbShutDown);
                    }
                }
            }
        }

        if (hdesk == NULL) {
            UserVerify(NT_SUCCESS(ObCloseHandle(hwinsta, UserMode)));
            hwinsta = NULL;
        }
    }

    goto ExitNormally;

ReturnNull:

    UserAssert(hdesk == NULL);

    if (hwinsta != NULL) {
        UserVerify(NT_SUCCESS(ObCloseHandle(hwinsta, UserMode)));
        hwinsta = NULL;
    }

ExitNormally:

    if (pObjA != NULL) {
        ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA, MEM_RELEASE);
    }

    ObDereferenceObject(Process);

    *phwinsta = hwinsta;

    return hdesk;
}

#ifdef REDIRECTION
#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | DESKTOP_QUERY_INFORMATION | \
                     DESKTOP_REDIRECT        | STANDARD_RIGHTS_REQUIRED)
#else
#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#endif

NTSTATUS
SetDisconnectDesktopSecurity(
    IN HDESK hdeskDisconnect)
{
    ULONG ulLength;
    NTSTATUS Status = STATUS_SUCCESS;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;
    PACCESS_ALLOWED_ACE pace = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSID pSystemSid = NULL;


    /*
     * Get the well-known system SID.
     */
    pSystemSid = UserAllocPoolWithQuota(RtlLengthRequiredSid(1), TAG_SECURITY);

    if (pSystemSid != NULL) {
        *(RtlSubAuthoritySid(pSystemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        Status = RtlInitializeSid(pSystemSid, &NtSidAuthority, (UCHAR)1);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(Status)) {
        goto done;
    }

    /*
     * Allocate and ACE that give System all ACCESS (No access to any one else).
     */


    pace = AllocAce(NULL, ACCESS_ALLOWED_ACE_TYPE, 0,
            DESKTOP_ALL,
            pSystemSid, &ulLength);

    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "GetDisconnectDesktopSecurityDescriptor: AllocAce for Desktop Attributes failed");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    /*
     * Create the security descriptor.
     */
    pSecurityDescriptor = CreateSecurityDescriptor(pace, ulLength, FALSE);
    if (pSecurityDescriptor == NULL) {
        RIPMSG0(RIP_WARNING, "GetDisconnectDesktopSecurityDescriptor: CreateSecurityDescriptor failed");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    /*
     * Set security on Disconnected desktop.
     */
    Status = ZwSetSecurityObject(hdeskDisconnect,
                                 DACL_SECURITY_INFORMATION,
                                 pSecurityDescriptor);

done:

    /*
     * Cleanup allocations.
     */

    if (pSystemSid != NULL) {
        UserFreePool(pSystemSid);
    }

    if (pace != NULL) {
        UserFreePool(pace);
    }

    if (pSecurityDescriptor != NULL) {
        UserFreePool(pSecurityDescriptor);
    }

    return Status;
}

#ifdef DEBUG_DESK
VOID ValidateDesktop(
    PDESKTOP pdesk)
{
    /*
     * Verify that the desktop has been cleaned out.
     */
    PHE pheT, pheMax;
    BOOL fDirty = FALSE;

    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        switch (pheT->bType) {
            case TYPE_WINDOW:
                if (((PWND)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Window at 0x%p exists\n", pheT->phead);
                    break;
                }
                continue;
            case TYPE_MENU:
                if (((PMENU)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Menu at 0x%p exists\n", pheT->phead);
                    break;
                }
                continue;
            case TYPE_CALLPROC:
                if (((PCALLPROCDATA)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Callproc at 0x%p exists\n", pheT->phead);
                    break;
                }
                continue;
            case TYPE_HOOK:
                if (((PHOOK)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Hook at 0x%p exists\n", pheT->phead);
                    break;
                }
                continue;
            default:
                continue;
        }

        fDirty = TRUE;
    }

    UserAssert(!fDirty);
}
#endif

/***************************************************************************\
* DbgCheckForThreadsOnDesktop
*
* Validates that no threads in the process are still on this desktop.
*
* NB: This desktop can be in a different session than the process, so you
* CANNOT deref pdesk here.
*
* History:
* 27-Jun-2001  JasonSch    Created.
\***************************************************************************/
VOID DbgCheckForThreadsOnDesktop(
    PPROCESSINFO ppi,
    PDESKTOP pdesk)
{
#if DBG
    PTHREADINFO pti = ppi->ptiList;

    while (pti != NULL) {
        UserAssertMsg2(pti->rpdesk != pdesk,
                       "pti 0x%p still on pdesk 0x%p",
                       pti,
                       pdesk);

        pti = pti->ptiSibling;
    }
#else
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(pdesk);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ddemlsvr.c ===
/****************************** Module Header ******************************\
* Module Name: ddemlsvr.C
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager main module - Contains all server side ddeml functions.
*
* 27-Aug-1991 Sanford Staab   Created
* 21-Jan-1992 IanJa           ANSI/Unicode neutralized
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// globals

PSVR_INSTANCE_INFO psiiList;

DWORD xxxCsDdeInitialize(
PHANDLE phInst,
HWND *phwndEvent,
LPDWORD pMonitorFlags,
DWORD afCmd,
PVOID pcii)
{
    PSVR_INSTANCE_INFO psii;
    PTHREADINFO        ptiCurrent = PtiCurrent();

    CheckCritIn();

    psii = (PSVR_INSTANCE_INFO)HMAllocObject(PtiCurrent(), NULL,
            TYPE_DDEACCESS, sizeof(SVR_INSTANCE_INFO));
    if (psii == NULL) {
        return DMLERR_SYS_ERROR;
    }

    /*
     * We have to tell CreateWindow that window is not created for the same
     * module has the app, (CW_FLAGS_DIFFHMOD), so CreateWindow doesn't
     * assign a hotkey to this window.  Other window are done in the
     * client-server thunk
     */
    Lock(&(psii->spwndEvent), xxxNVCreateWindowEx(
            0,
            (PLARGE_STRING)gpsi->atomSysClass[ICLS_DDEMLEVENT],
            NULL,
            WS_POPUP | WS_CHILD,
            0, 0, 0, 0,
            (PWND)NULL,
            (PMENU)NULL,
            hModuleWin,
            NULL,
            CW_FLAGS_DIFFHMOD | VER31));

    if (psii->spwndEvent == NULL) {
        HMFreeObject((PVOID)psii);
        return DMLERR_SYS_ERROR;
    }
    /*
     * This GWL offset does NOT leave the critical section!
     */
    xxxSetWindowLongPtr(psii->spwndEvent, GWLP_PSII, (LONG_PTR)PtoH(psii), FALSE);
    psii->afCmd = 0;
    psii->pcii = pcii;
    //
    // Link into global list
    //
    psii->next = psiiList;
    psiiList = psii;

    //
    // Link into per-process list
    //
    psii->nextInThisThread = ptiCurrent->psiiList;
    ptiCurrent->psiiList = psii;

    *phInst = PtoH(psii);
    *phwndEvent = PtoH(psii->spwndEvent);
    xxxChangeMonitorFlags(psii, afCmd);        // sets psii->afCmd;
    *pMonitorFlags = MonitorFlags;
    return DMLERR_NO_ERROR;
}





DWORD _CsUpdateInstance(
HANDLE hInst,
LPDWORD pMonitorFlags,
DWORD afCmd)
{
    PSVR_INSTANCE_INFO psii;

    CheckCritIn();

    psii = (PSVR_INSTANCE_INFO)HMValidateHandleNoRip(hInst, TYPE_DDEACCESS);
    if (psii == NULL) {
        return DMLERR_INVALIDPARAMETER;
    }
    xxxChangeMonitorFlags(psii, afCmd);
    *pMonitorFlags = MonitorFlags;
    return DMLERR_NO_ERROR;
}





BOOL _CsDdeUninitialize(
HANDLE hInst)
{
    PSVR_INSTANCE_INFO psii;

    CheckCritIn();

    psii = HMValidateHandleNoRip(hInst, TYPE_DDEACCESS);
    if (psii == NULL) {
        return TRUE;
    }

    xxxDestroyThreadDDEObject(PtiCurrent(), psii);
    return TRUE;
}


VOID xxxDestroyThreadDDEObject(
PTHREADINFO pti,
PSVR_INSTANCE_INFO psii)
{
    PSVR_INSTANCE_INFO psiiT;

    CheckCritIn();

    if (HMIsMarkDestroy(psii)) {
        return;
    }

    //
    // Unlink psii from the global list.
    //
    if (psii == psiiList) {
        psiiList = psii->next;
    } else {
        for (psiiT = psiiList; psiiT->next != psii; psiiT = psiiT->next) {
            UserAssert(psiiT->next != NULL);
        }
        psiiT->next = psii->next;
    }
    // psii->next = NULL;

    //
    // Unlink psii from the per-process list.
    //
    if (psii == pti->psiiList) {
        pti->psiiList = psii->nextInThisThread;
    } else {
        for (psiiT = pti->psiiList; psiiT->nextInThisThread != psii; psiiT = psiiT->nextInThisThread) {
            UserAssert(psiiT->nextInThisThread != NULL);
        }
        psiiT->nextInThisThread = psii->nextInThisThread;
    }
    // psii->nextInThisThread = NULL;

    if (HMMarkObjectDestroy(psii)) {
        PWND pwnd = psii->spwndEvent;
        /*
         * We already removed psii from the linked list. This means that it 
         * will not get another chance to be cleaned up in 
         * xxxDestroyThreadInfo(), Since xxxDestroyWindow might leave 
         * the critical section the cleanup needs to be done in the below 
         * sequence else we will leak pssi and pwnd might be locked for good.
         * [msadek - 03/12/2002]
         */
        if (Unlock(&(psii->spwndEvent))) {
            HMFreeObject(psii);
            xxxDestroyWindow(pwnd);
        } else {
            HMFreeObject(psii);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ddetrack.c ===
/****************************** Module Header *******************************
* Module Name: ddetrack.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module handles tracking of DDE conversations for use in emulating
* DDE shared memory.
*
* History:
* 9-3-91      sanfords  Created
* 21-Jan-1992 IanJa     ANSI/Unicode netralized (null op)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PPUBOBJ gpPublicObjectList;

#define TRACE_DDE(str)          TAGMSG0(DBGTAG_DDE, str)
#define TRACE_DDE1(s, a)        TAGMSG1(DBGTAG_DDE, (s), (a))
#define TRACE_DDE2(s, a, b)     TAGMSG2(DBGTAG_DDE, (s), (a), (b))
#define TRACE_DDE3(s, a, b, c)  TAGMSG3(DBGTAG_DDE, (s), (a), (b), (c))

BOOL NewConversation(PDDECONV *ppdcNewClient, PDDECONV *ppdcNewServer,
        PWND pwndClient, PWND pwndServer);
PDDECONV FindDdeConv(PWND pwndProp, PWND pwndPartner);
BOOL AddConvProp(PWND pwndUs, PWND pwndThem, DWORD flags, PDDECONV pdcNew,
        PDDECONV pdcPartner);
FNDDERESPONSE xxxUnexpectedServerPost;
FNDDERESPONSE xxxUnexpectedClientPost;
FNDDERESPONSE xxxAdvise;
FNDDERESPONSE xxxAdviseAck;
FNDDERESPONSE xxxAdviseData;
FNDDERESPONSE xxxAdviseDataAck;
DWORD Unadvise(PDDECONV pDdeConv);
FNDDERESPONSE xxxUnadviseAck;
DWORD Request(PDDECONV pDdeConv);
FNDDERESPONSE xxxRequestAck;
FNDDERESPONSE xxxPoke;
FNDDERESPONSE xxxPokeAck;
FNDDERESPONSE xxxExecute;
FNDDERESPONSE xxxExecuteAck;
DWORD SpontaneousTerminate(PDWORD pmessage, PDDECONV pDdeConv);
FNDDERESPONSE DupConvTerminate;

HANDLE AnticipatePost(PDDECONV pDdeConv, FNDDERESPONSE fnResponse,
        HANDLE hClient, HANDLE hServer, PINTDDEINFO pIntDdeInfo, DWORD flags);
PXSTATE Createpxs(FNDDERESPONSE fnResponse, HANDLE hClient, HANDLE hServer,
        PINTDDEINFO pIntDdeInfo, DWORD flags);
DWORD AbnormalDDEPost(PDDECONV pDdeConv, DWORD message);
DWORD xxxCopyDdeIn(HANDLE hSrc, PDWORD pflags, PHANDLE phDirect, PINTDDEINFO *ppi);
DWORD xxxCopyAckIn(PDWORD pmessage, LPARAM *plParam, PDDECONV pDdeConv, PINTDDEINFO *ppIntDdeInfo);
HANDLE xxxCopyDDEOut(PINTDDEINFO pIntDdeInfo, PHANDLE phDirect);
BOOL FreeListAdd(PDDECONV pDdeConv, HANDLE hClient, DWORD flags);
VOID xxxFreeListFree(PFREELIST pfl);
VOID PopState(PDDECONV pDdeConv);
PDDECONV UnlinkConv(PDDECONV pDdeConv);

VOID FreeDDEHandle(PDDECONV pDdeConv, HANDLE hClient, DWORD flags);
DWORD ClientFreeDDEHandle(HANDLE hClient, DWORD flags);
DWORD ClientGetDDEFlags(HANDLE hClient, DWORD flags);
DWORD xxxClientCopyDDEIn1(HANDLE hClient, DWORD flags, PINTDDEINFO *ppi);
HANDLE xxxClientCopyDDEOut1(PINTDDEINFO pIntDdeInfo);
DWORD xxxClientCopyDDEOut2(PINTDDEINFO pIntDdeInfo);

PPUBOBJ IsObjectPublic(HANDLE hObj);
BOOL AddPublicObject(UINT format, HANDLE hObj, W32PID pid);
BOOL RemovePublicObject(UINT format, HANDLE hObj);
BOOL GiveObject(UINT format, HANDLE hObj, W32PID pid);

/*
 *  The Big Picture:
 *
 *  When a WM_DDE_ACK message is SENT, it implies the begining of a DDE
 *    Conversation.  The tracking layer creates DDECONV structure for each
 *    window in volved in the conversation and cross links the structures.
 *    Thus a unique window pair identifies a conversation.  Each window has
 *    its DDECONV structure attached to it via a private property.
 *
 *  As DDE messages are posted, the tracking layer copies data into the
 *    CSR server side of USER into a INTDDEINFO structure.  This structure
 *    contains flags which direct how the data is to be freed when the
 *    time comes.  This info is placed within an XSTATE structure along
 *    with context infomation.  A pointer to the XSTATE structure is
 *    placed in the lParam of the message and the MSB of message is set
 *    for special processing when the message is recieved on the other side.
 *
 *  If the message posted requires a responding message to follow the DDE
 *    protocol, a XSTATE structure is created and attached to DDECONV
 *    structure associated with the window that is expected to post the message.
 *    The XSTATE structure directs the tracking layer so that it knows the
 *    context of the message when it is posted and also includes any
 *    information needed for proper freeing of extra DDE data.
 *
 *  When the message is extracted from the queue either by a hook, peek,
 *    or by GetMessage, the id is checked to see if it lies in the special
 *    range.  If so, the XSTATE structure pointed to by the lParam is
 *    operated on.  This causes the data to be copied from the CSR server
 *    side of USER to the target process context.  Once this is done, the
 *    XSTATE structure may or may not be freed depending on flags and
 *    the message is restored to a proper DDE message form ready to be
 *    used by the target process.  Since the message id is changed back,
 *    subsequent peeks or hooks to the message will not result in duplicated
 *    processing of the message.
 *
 *  During the course of come transactions it becomes evident that an object
 *    on the opposite side process needs to be freed.  This is done
 *    asynchronously by inserting the object that needs freeing along with
 *    associated flags into a freeing list which is tied to the DDECONV
 *    structure associated with the window on the opposite side.  Whenever
 *    a DDE messages is posted, this freeing list is checked and processed.
 *
 *  When a WM_DDE_TERMINATE message is finally recieved, flags are set
 *    in the DDECONV structure indicating that the conversation is terminating.
 *    This alters the way the mapping layer handles DDE messages posted.
 *    When the responding side posts a WM_DDE_TERMINATE, the DDECONV structures
 *    and all associated information is freed and unlinked from the windows
 *    concerned.
 *
 *  Should a DDE window get destroyed before proper termination, the
 *    xxxDDETrackWindowDying function is called to make sure proper termination
 *    is done prior to the window being destroyed.
 */


/************************************************************************
* xxxDDETrackSendHook
*
* Called when a DDE message is passed to SendMessage().
*
* Returns fSendOk.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
BOOL xxxDDETrackSendHook(
PWND pwndTo,
DWORD message,
WPARAM wParam,
LPARAM lParam)
{
    PWND pwndServer;
    PDDECONV pdcNewClient, pdcNewServer;

    if (MonitorFlags & MF_SENDMSGS) {
        DDEML_MSG_HOOK_DATA dmhd;

        dmhd.cbData = 0;    // Initiate and Ack sent messages have no data.
        dmhd.uiLo = LOWORD(lParam);     // they arn't packed either.
        dmhd.uiHi = HIWORD(lParam);
        xxxMessageEvent(pwndTo, message, wParam, lParam, MF_SENDMSGS, &dmhd);
    }

    if (PtiCurrent()->ppi == GETPWNDPPI(pwndTo)) {
        /*
         * Skip monitoring of all intra-process conversations.
         */
        return TRUE;
    }

    if (message != WM_DDE_ACK) {
        if (message == WM_DDE_INITIATE) {
            return TRUE;     // this is cool
        }
        return FALSE;
    }

    pwndServer = ValidateHwnd((HWND)wParam);
    if (pwndServer == NULL) {
        return FALSE;
    }

    pdcNewServer = FindDdeConv(pwndServer, pwndTo);
    if (pdcNewServer != NULL) {
        RIPMSG2(RIP_WARNING,
                "DDE protocol violation - non-unique window pair (%#p:%#p)",
                PtoH(pwndTo), PtoH(pwndServer));
        /*
         * Duplicate Conversation case:
         *  Don't allow the ACK to pass, post a terminate to the server
         *  to shut down the duplicate on his end.
         */
        AnticipatePost(pdcNewServer, DupConvTerminate, NULL, NULL, NULL, 0);
        _PostMessage(pwndServer, WM_DDE_TERMINATE, (WPARAM)PtoH(pwndTo), 0);
        return FALSE;
    }

    if (!NewConversation(&pdcNewClient, &pdcNewServer, pwndTo, pwndServer)) {
        return FALSE;
    }

    TRACE_DDE2("%#p->%#p DDE Conversation started", PtoH(pwndTo), wParam);
    return TRUE;
}


/************************************************************************
* AddConvProp
*
* Helper for xxxDDETrackSendHook - associates a new DDECONV struct with
* a window and initializes it.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
BOOL AddConvProp(
PWND pwndUs,
PWND pwndThem,
DWORD flags,
PDDECONV pdcNew,
PDDECONV pdcPartner)
{
    PDDECONV pDdeConv;
    PDDEIMP pddei;

    pDdeConv = (PDDECONV)_GetProp(pwndUs, PROP_DDETRACK, PROPF_INTERNAL);
    Lock(&(pdcNew->snext), pDdeConv);
    Lock(&(pdcNew->spwnd), pwndUs);
    Lock(&(pdcNew->spwndPartner), pwndThem);

    /*
     * Assert to catch stress bug.
     */
    UserAssert(pdcPartner != (PDDECONV)(-1));

    Lock(&(pdcNew->spartnerConv), pdcPartner);
    pdcNew->spxsIn = NULL;
    pdcNew->spxsOut = NULL;
    pdcNew->flags = flags;
    pddei = (PDDEIMP)_GetProp((flags & CXF_IS_SERVER) ?
            pwndThem : pwndUs, PROP_DDEIMP, PROPF_INTERNAL);
    if (pddei != NULL) {    // This can be NULL if a bad WOW app has been
        pddei->cRefConv++;  // allowed through for compatability.
    }
    pdcNew->pddei = pddei;

    HMLockObject(pdcNew);         // lock for property
    InternalSetProp(pwndUs, PROP_DDETRACK, pdcNew, PROPF_INTERNAL);
    return TRUE;
}


/************************************************************************
* UnlinkConv
*
* Unlinks a DDECONV structure from the property list it is associated with.
*
* returns pDdeConv->snext
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
PDDECONV UnlinkConv(
PDDECONV pDdeConv)
{
    PDDECONV pdcPrev, pdcT, pDdeConvNext;

    /*
     * Already unlinked
     */
    if (pDdeConv->spwnd == NULL) {
        return NULL;
    }
    TRACE_DDE1("UnlinkConv(%#p)", pDdeConv);

    pdcT = (PDDECONV)_GetProp(pDdeConv->spwnd,
            PROP_DDETRACK, PROPF_INTERNAL);
    if (pdcT == NULL) {
        return NULL;             // already unlinked
    }

    pdcPrev = NULL;
    while (pdcT != pDdeConv) {
        pdcPrev = pdcT;
        pdcT = pdcT->snext;
        if (pdcT == NULL) {
            return NULL;        // already unlinked
        }
    }

    if (pdcPrev == NULL) {
        if (pDdeConv->snext == NULL) {
            // last one out removes the property
            InternalRemoveProp(pDdeConv->spwnd, PROP_DDETRACK, PROPF_INTERNAL);
        } else {
            // head conv unlinked - update prop
            InternalSetProp(pDdeConv->spwnd, PROP_DDETRACK, pDdeConv->snext,
                    PROPF_INTERNAL);
        }
    } else {
        Lock(&(pdcPrev->snext), pDdeConv->snext);
    }
    pDdeConvNext = Unlock(&(pDdeConv->snext));
    HMUnlockObject(pDdeConv);      // unlock for property detachment
    return pDdeConvNext;
}


/************************************************************************
* xxxDDETrackPostHook
*
* Hook function for handling posted DDE messages.
*
* returns post action code - DO_POST, FAKE_POST, FAIL_POST.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxDDETrackPostHook(
PUINT pmessage,
PWND pwndTo,
WPARAM wParam,
LPARAM *plParam,
BOOL fSent)
{
    PWND pwndFrom;
    PDDECONV pDdeConv = NULL;
    DWORD dwRet;
    TL tlpDdeConv;
    PFREELIST pfl, *ppfl;
    DWORD MFlag;

    CheckLock(pwndTo);

    MFlag = fSent ? MF_SENDMSGS : MF_POSTMSGS;
    if (MonitorFlags & MFlag) {
        DDEML_MSG_HOOK_DATA dmhd;

        switch (*pmessage ) {
        case WM_DDE_DATA:
        case WM_DDE_POKE:
        case WM_DDE_ADVISE:
        case WM_DDE_EXECUTE:
        case WM_DDE_ACK:
            ClientGetDDEHookData(*pmessage, *plParam, &dmhd);
            break;

        default:
            // WM_DDE_REQUEST
            // WM_DDE_TERMINATE
            // WM_DDE_UNADVISE
            dmhd.cbData = 0;
            dmhd.uiLo = LOWORD(*plParam);
            dmhd.uiHi = HIWORD(*plParam);
        }
        xxxMessageEvent(pwndTo, *pmessage, wParam, *plParam, MFlag,
                &dmhd);
    }

    if (PtiCurrent()->ppi == GETPWNDPPI(pwndTo)) {
        /*
         * skip all intra-process conversation tracking.
         */
        dwRet = DO_POST;
        goto Exit;
    }

    if (*pmessage == WM_DDE_INITIATE) {
        RIPMSG2(RIP_WARNING,
                "DDE Post failed (%#p:%#p) - WM_DDE_INITIATE posted",
                wParam, PtoH(pwndTo));
        dwRet = FAIL_POST;
        goto Exit;
    }

    pwndFrom = ValidateHwnd((HWND)wParam);
    if (pwndFrom == NULL) {
        /*
         * This is a post AFTER a window has been destroyed.  This is not
         * expected except in the case where xxxDdeTrackWindowDying()
         * is posting a cleanup terminate.
         */
        dwRet = *pmessage == WM_DDE_TERMINATE ? DO_POST : FAKE_POST;
        goto Exit;
    }

    /*
     * locate conversation info.
     */
    pDdeConv = FindDdeConv(pwndFrom, pwndTo);
    if (pDdeConv == NULL) {
        if (*pmessage != WM_DDE_TERMINATE &&
                (GETPTI(pwndFrom)->TIF_flags & TIF_16BIT) &&
                (pwndTo->head.rpdesk == pwndFrom->head.rpdesk)) {
            /*
             * If a WOW app bypasses initiates and posts directly to
             * a window on the same desktop, let it sneak by here.
             *
             * This allows some evil apps such as OpenEngine and CA-Cricket
             * to get away with murder.
             *
             * TERMINATES out of the blue however may be due to an app
             * posting its WM_DDE_TERMINATE after it has destroyed its
             * window.  Since window destruction would have generated the
             * TERMINATE already, don't let it through here.
             */
            NewConversation(&pDdeConv, NULL, pwndFrom, pwndTo);
        }
        if (pDdeConv == NULL) {
            RIPMSG2(RIP_VERBOSE, "Can't find DDE conversation for (%#p:%#p).",
                    wParam, PtoH(pwndTo));
            dwRet = *pmessage == WM_DDE_TERMINATE ? FAKE_POST : FAIL_POST;
            goto Exit;
        }
    }

    if (fSent && pDdeConv->spartnerConv->spxsOut != NULL &&
        !(GETPTI(pwndFrom)->dwCompatFlags2 & GACF2_DDENOSYNC) ) {
        /*
         * Sent DDE messages will not work if any posted DDE messages are
         * in the queue because this will violate the message ordering rule.
         */
        RIPMSG0(RIP_VERBOSE,
                "Sent DDE message failed - queue contains a previous post.");
        dwRet = FAIL_POST;
        goto Exit;
    }

    /*
     * The tracking layer never did allow multiple threads to handle
     * the same DDE conversation but win95 shipped and some apps
     * got out there that did just this.  We will let it slide for
     * 4.0 apps only so that when they rev their app, they will see
     * that they were wrong.
     */
    if (PtiCurrent() != GETPTI(pDdeConv) &&
            LOWORD(PtiCurrent()->dwExpWinVer) != VER40) {
        RIPERR0(ERROR_WINDOW_OF_OTHER_THREAD,
                RIP_ERROR,
                "Posting DDE message from wrong thread!");

        dwRet = FAIL_POST;
        goto Exit;
    }

    ThreadLockAlways(pDdeConv, &tlpDdeConv);

    /*
     * If the handle we're using is in the free list, remove it
     */
    ppfl = &pDdeConv->pfl;
    while (*ppfl != NULL) {
        if ((*ppfl)->h == (HANDLE)*plParam) {
            /* Let's stop to check this out */
            UserAssert((*ppfl)->h == (HANDLE)*plParam);
            *ppfl = (*ppfl)->next;
        } else {
            ppfl = &(*ppfl)->next;
        }
    }
    pfl = pDdeConv->pfl;
    pDdeConv->pfl = NULL;
    xxxFreeListFree(pfl);

    if (*pmessage != WM_DDE_TERMINATE &&
            (pDdeConv->flags & (CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED))) {
        dwRet = FAKE_POST;
        goto UnlockExit;
    }

    if (pDdeConv->spxsOut == NULL) {
        if (pDdeConv->flags & CXF_IS_SERVER) {
            dwRet = xxxUnexpectedServerPost((PDWORD)pmessage, plParam, pDdeConv);
        } else {
            dwRet = xxxUnexpectedClientPost((PDWORD)pmessage, plParam, pDdeConv);
        }
    } else {
        dwRet = (pDdeConv->spxsOut->fnResponse)(pmessage, plParam, pDdeConv);
    }

UnlockExit:

    ThreadUnlock(&tlpDdeConv);

Exit:

    if (dwRet == FAKE_POST && !((PtiCurrent())->TIF_flags & TIF_INCLEANUP)) {
        /*
         * We faked the post so do a client side cleanup here so that we
         * don't make it appear there is a leak in the client app.
         */
        DWORD flags = XS_DUMPMSG;
        /*
         * The XS_DUMPMSG tells FreeDDEHandle to also free the atoms
         * associated with the data - since a faked post would make the app
         * think that the receiver was going to cleanup the atoms.
         * It also tells FreeDDEHandle to pay attention to the
         * fRelease bit when freeing the data - this way, loaned data
         * won't be destroyed.
         */

        switch (*pmessage & 0xFFFF) {
        case WM_DDE_UNADVISE:
        case WM_DDE_REQUEST:
            goto DumpMsg;

        case WM_DDE_ACK:
            flags |= XS_PACKED;
            goto DumpMsg;

        case WM_DDE_ADVISE:
            flags |= XS_PACKED | XS_HIHANDLE;
            goto DumpMsg;

        case WM_DDE_DATA:
        case WM_DDE_POKE:
            flags |= XS_DATA | XS_LOHANDLE | XS_PACKED;
            goto DumpMsg;

        case WM_DDE_EXECUTE:
            flags |= XS_EXECUTE;
            // fall through
DumpMsg:
            if (pDdeConv != NULL) {
                TRACE_DDE("xxxDdeTrackPostHook: dumping message...");
                FreeDDEHandle(pDdeConv, (HANDLE)*plParam, flags);
                dwRet = FAILNOFREE_POST;
            }
        }
    }
#if DBG
    if (fSent) {
        TraceDdeMsg(*pmessage, (HWND)wParam, PtoH(pwndTo), MSG_SENT);
    } else {
        TraceDdeMsg(*pmessage, (HWND)wParam, PtoH(pwndTo), MSG_POST);
    }
    if (dwRet == FAKE_POST) {
        TRACE_DDE("...FAKED!");
    } else if (dwRet == FAIL_POST) {
        TRACE_DDE("...FAILED!");
    } else if (dwRet == FAILNOFREE_POST) {
        TRACE_DDE("...FAILED, DATA FREED!");
    }
#endif // DBG
    return dwRet;
}

VOID xxxCleanupDdeConv(
    PWND pwndProp)
{
    PDDECONV pDdeConv;

Restart:

    CheckCritIn();

    pDdeConv = (PDDECONV)_GetProp(pwndProp, PROP_DDETRACK, PROPF_INTERNAL);
    
    while (pDdeConv != NULL) {
        if ((pDdeConv->flags & (CXF_IS_SERVER | CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED))
                == (CXF_IS_SERVER | CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED) &&
            
            (pDdeConv->spartnerConv->flags & CXF_TERMINATE_POSTED)) {
            
            /*
             * clean up client side objects on this side
             */
            BOOL fUnlockDdeConv;
            TL tlpDdeConv;

            RIPMSG1(RIP_VERBOSE, "xxxCleanupDdeConv %p", pDdeConv);

            fUnlockDdeConv = (pDdeConv->pfl != NULL);
            if (fUnlockDdeConv) {
                PFREELIST pfl;

                ThreadLockAlways(pDdeConv, &tlpDdeConv);

                pfl = pDdeConv->pfl;
                pDdeConv->pfl = NULL;
                xxxFreeListFree(pfl);
            }

            FreeDdeConv(pDdeConv->spartnerConv);
            FreeDdeConv(pDdeConv);

            if (fUnlockDdeConv) {
                ThreadUnlock(&tlpDdeConv);
            }
            
            /*
             * Take it back from the top. The list might have changed
             * if we left the critical section
             */
            goto Restart;
        }
        
        pDdeConv = pDdeConv->snext;
    }
}


/************************************************************************
* xxxDDETrackGetMessageHook
*
* This routine is used to complete an inter-process copy from the
* CSRServer context to the target context.  pmsg->lParam is a
* pxs that is used to obtain the pIntDdeInfo needed to
* complete the copy.  The pxs is either filled with the target side
* direct handle or is freed depending on the message and its context.
*
* The XS_FREEPXS bit of the flags field of the pxs tells this function
* to free the pxs when done.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID xxxDDETrackGetMessageHook(
    PMSG pmsg)
{
    PXSTATE pxs;
    HANDLE hDirect;
    DWORD flags;
    BOOL fUnlockDdeConv;
    TL tlpDdeConv, tlpxs;

    TraceDdeMsg(pmsg->message, (HWND)pmsg->wParam, pmsg->hwnd, MSG_RECV);

    if (pmsg->message == WM_DDE_TERMINATE) {
        PWND pwndFrom, pwndTo;
        PDDECONV pDdeConv;

        pwndTo = ValidateHwnd(pmsg->hwnd);
        
        /*
         * We should get the pwnd even if the partner is destroyed in order
         * to clean up the DDE objects now.  Exiting now would work, but would
         * leave the conversation objects locked and present until the To window
         * gets destroyed, which seems excessive.
         */
        pwndFrom = RevalidateCatHwnd((HWND)pmsg->wParam);
        
        if (pwndTo == NULL) {
            TRACE_DDE("TERMINATE ignored, invalid window(s).");
            return;
        } else if (pwndFrom == NULL) {
            
CleanupAndExit:            
            /*
             * Do this only for appcompat
             */
            if (GetAppCompatFlags2(VERMAX) & GACF2_DDE) {
                xxxCleanupDdeConv(pwndTo);
            } else {
                TRACE_DDE("TERMINATE ignored, invalid window(s).");
            }
            return;
        }
        
        /*
         * locate conversation info.
         */
        pDdeConv = FindDdeConv(pwndTo, pwndFrom);
        if (pDdeConv == NULL) {
            /*
             * Must be a harmless extra terminate.
             */
            TRACE_DDE("TERMINATE ignored, conversation not found.");
            return;
        }

        if (pDdeConv->flags & CXF_TERMINATE_POSTED &&
                pDdeConv->spartnerConv->flags & CXF_TERMINATE_POSTED) {

            /*
             * clean up client side objects on this side
             */
            fUnlockDdeConv = FALSE;
            if (pDdeConv->pfl != NULL) {
                PFREELIST pfl;

                fUnlockDdeConv = TRUE;
                ThreadLockAlways(pDdeConv, &tlpDdeConv);
                pfl = pDdeConv->pfl;
                pDdeConv->pfl = NULL;
                xxxFreeListFree(pfl);
            }

            TRACE_DDE2("DDE conversation (%#p:%#p) closed",
                    (pDdeConv->flags & CXF_IS_SERVER) ? pmsg->wParam : (ULONG_PTR)pmsg->hwnd,
                    (pDdeConv->flags & CXF_IS_SERVER) ? (ULONG_PTR)pmsg->hwnd : pmsg->wParam);

            FreeDdeConv(pDdeConv->spartnerConv);
            FreeDdeConv(pDdeConv);

            if (fUnlockDdeConv) {
                ThreadUnlock(&tlpDdeConv);
            }
        }

        goto CleanupAndExit;
    }

    pxs = (PXSTATE)HMValidateHandleNoRip((HANDLE)pmsg->lParam, TYPE_DDEXACT);
    if (pxs == NULL) {
        /*
         * The posting window has died and the pxs was freed so this
         * message shouldn't be bothered with...map to WM_NULL.
         */
        pmsg->lParam = 0;
        pmsg->message = WM_NULL;
        return;
    }
    flags = pxs->flags;

    ThreadLockAlways(pxs, &tlpxs);
    pmsg->lParam = (LPARAM)xxxCopyDDEOut(pxs->pIntDdeInfo, &hDirect);
    if (pmsg->lParam == (LPARAM)NULL) {
        /*
         * Turn this message into a terminate - we failed to copy the
         * message data out which implies we are too low on memory
         * to continue the conversation.  Shut it down now before
         * other problems pop up that this failure will cause.
         */
        pmsg->message = WM_DDE_TERMINATE;
        RIPMSG0(RIP_WARNING, "DDETrack: couldn't copy data out, terminate faked.");
    }
    if (ThreadUnlock(&tlpxs) == NULL) {
        return;
    }

    if (flags & XS_FREEPXS) {
        FreeDdeXact(pxs);
        return;
    }

    /*
     * The only reason XS_FREEPXS isn't set is because we don't know which
     * side frees the data till an ACK comes back, thus one of the client
     * handles in pxs is already set via xxxDDETrackPostHook().  The one thats
     * not yet set gets set here.
     */

    if (pxs->hClient == NULL) {
        TRACE_DDE1("Saving %#p into hClient", hDirect);
        pxs->hClient = hDirect;
    } else {
        TRACE_DDE1("Saving %#p into hServer.", hDirect);
        pxs->hServer = hDirect;
    }
}



/************************************************************************
* xxxDDETrackWindowDying
*
* Called when a window with PROP_DDETRACK is destroyed.
*
* This posts a terminate to the partner window and sets up for proper
* terminate post fake from other end.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID xxxDDETrackWindowDying(
PWND pwnd,
PDDECONV pDdeConv)
{
    TL tlpDdeConv, tlpDdeConvNext;

    UNREFERENCED_PARAMETER(pwnd);

    CheckLock(pwnd);
    CheckLock(pDdeConv);

    TRACE_DDE2("xxxDDETrackWindowDying(%#p, %#p)", PtoH(pwnd), pDdeConv);

    while (pDdeConv != NULL) {

        PFREELIST pfl;

        /*
         * If there are any active conversations for this window
         * start termination if not already started.
         */
        if (!(pDdeConv->flags & CXF_TERMINATE_POSTED)) {
            /*
             * Win9x doesn't do any tracking. This breaks some apps that
             *  destroy the window first and then post the terminate. The
             *  other side gets two terminates.
             */
            if (!(GACF2_NODDETRKDYING & GetAppCompatFlags2(VER40))
                || (pDdeConv->spwndPartner == NULL)
                || !(GACF2_NODDETRKDYING
                        & GetAppCompatFlags2ForPti(GETPTI(pDdeConv->spwndPartner), VER40))) {

                /*
                 * CXF_TERMINATE_POSTED would have been set if the window had died.
                 */
                _PostMessage(pDdeConv->spwndPartner, WM_DDE_TERMINATE,
                        (WPARAM)PtoH(pDdeConv->spwnd), 0);
                // pDdeConv->flags |= CXF_TERMINATE_POSTED;  set by PostHookProc
            } else {
                RIPMSG2(RIP_WARNING, "xxxDDETrackWindowDying(GACF2_NODDETRKDYING) not posting terminate from %#p to %#p\r\n",
                        pwnd, pDdeConv->spwndPartner);
            }
        }

        /*
         * now fake that the other side already posted a terminate since
         * we will be gone.
         */
        pDdeConv->spartnerConv->flags |=
                CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED;

        ThreadLock(pDdeConv->snext, &tlpDdeConvNext);
        ThreadLockAlways(pDdeConv, &tlpDdeConv);

        pfl = pDdeConv->pfl;
        pDdeConv->pfl = NULL;

        if (pDdeConv->flags & CXF_PARTNER_WINDOW_DIED) {

            ThreadUnlock(&tlpDdeConv);
            /*
             * he's already gone, free up conversation tracking data
             */
            FreeDdeConv(pDdeConv->spartnerConv);
            FreeDdeConv(pDdeConv);
        } else {
            UnlinkConv(pDdeConv);
            ThreadUnlock(&tlpDdeConv);
        }
        xxxFreeListFree(pfl);

        pDdeConv = ThreadUnlock(&tlpDdeConvNext);
    }
}



/************************************************************************
* xxxUnexpectedServerPost
*
* Handles Server DDE messages not anticipated. (ie spontaneous or abnormal)
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxUnexpectedServerPost(
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    switch (*pmessage) {
    case WM_DDE_TERMINATE:
        return SpontaneousTerminate(pmessage, pDdeConv);

    case WM_DDE_DATA:
        return xxxAdviseData(pmessage, plParam, pDdeConv);

    case WM_DDE_ACK:

        /*
         * Could be an extra NACK due to timeout problems, just fake it.
         */
        TRACE_DDE("xxxUnexpectedServerPost: dumping ACK data...");
        FreeDDEHandle(pDdeConv, (HANDLE)*plParam, XS_PACKED);
        return FAILNOFREE_POST;

    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
    case WM_DDE_EXECUTE:
        return AbnormalDDEPost(pDdeConv, *pmessage);
    }
    return 0;
}



/************************************************************************
* xxxUnexpectedClientPost
*
*
* Handles Client DDE messages not anticipated. (ie spontaneous or abnormal)
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxUnexpectedClientPost(
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    switch (*pmessage) {
    case WM_DDE_TERMINATE:
        return SpontaneousTerminate(pmessage, pDdeConv);

    case WM_DDE_ACK:

        /*
         * Could be an extra NACK due to timeout problems, just fake it.
         */
        TRACE_DDE("xxxUnexpectedClientPost: dumping ACK data...");
        FreeDDEHandle(pDdeConv, (HANDLE)*plParam, XS_PACKED);
        return FAILNOFREE_POST;

    case WM_DDE_DATA:
        return AbnormalDDEPost(pDdeConv, *pmessage);

    case WM_DDE_ADVISE:
        return xxxAdvise(pmessage, plParam, pDdeConv);

    case WM_DDE_UNADVISE:
        return Unadvise(pDdeConv);

    case WM_DDE_REQUEST:
        return Request(pDdeConv);

    case WM_DDE_POKE:
        return xxxPoke(pmessage, plParam, pDdeConv);

    case WM_DDE_EXECUTE:
        return xxxExecute(pmessage, plParam, pDdeConv);
    }
    return 0;
}



/************************************************************************
*                   ADVISE TRANSACTION PROCESSING                       *
\***********************************************************************/



DWORD xxxAdvise(            // Spontaneous Client transaction = WM_DDE_ADVISE
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;
    DWORD flags, dwRet;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxAdvise");
    flags = XS_PACKED | XS_LOHANDLE;
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv, xxxAdviseAck,
             hDirect, NULL, pIntDdeInfo, flags);
        if (*plParam == 0) {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}

/*
 * If its inter-process:
 *
 * xxxDDETrackGetMessageHook() fills in hServer from pIntDdeInfo when WM_DDE_ADVISE
 * is received. pIntDdeInfo is then freed. The hServer handle is saved into the
 * pxs structure pointed to by lParam is a direct data structure since
 * packed DDE messages are always assumed to have the packing handle freed.
 */


DWORD xxxAdviseAck(         // Server response to advise - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pIntDdeInfo;
    DWORD dwRet;

    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxAdviseAck");

    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);

    pxsFree = pDdeConv->spxsOut;
    if (pIntDdeInfo->DdePack.uiLo & DDE_FACK) {

        /*
         * positive ack implies server accepted the hOptions data - free from
         * client at postmessage time.
         */
        TRACE_DDE("xxxAdviseAck: +ACK delayed freeing data from client");
        FreeListAdd(pDdeConv->spartnerConv, pxsFree->hClient, pxsFree->flags & ~XS_PACKED);
    } else {
        // Shouldn't this be freed directly?
        TRACE_DDE("xxxAdviseAck: -ACK delayed freeing data from server");
        FreeListAdd(pDdeConv, pxsFree->hServer, pxsFree->flags & ~XS_PACKED);
    }

    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                  ADVISE DATA TRANSACTION PROCESSING                   *
\***********************************************************************/



DWORD xxxAdviseData(        // spontaneous from server - WM_DDE_DATA
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD flags, dwRet;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;
    PXSTATE pxs;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxAdviseData");

    flags = XS_PACKED | XS_LOHANDLE | XS_DATA;

    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        TRACE_DDE1("xxxAdviseData: wStatus = %x",
                ((PDDE_DATA)(pIntDdeInfo + 1))->wStatus);
        if (!(((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & (DDE_FACK | DDE_FRELEASE))) {
            RIPMSG0(RIP_ERROR, "DDE protocol violation - no RELEASE or ACK bit set - setting RELEASE.");
            ((PDDE_DATA)(pIntDdeInfo + 1))->wStatus |= DDE_FRELEASE;
        }
        if (((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FRELEASE) {
            /*
             * giving it away
             */
            if (IsObjectPublic(pIntDdeInfo->hIndirect) != NULL) {
                RIPMSG0(RIP_ERROR, "DDE Protocol violation - giving away a public GDI object.");
                UserFreePool(pIntDdeInfo);
                return FAILNOFREE_POST;
            }
            if (GiveObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                    pIntDdeInfo->hIndirect,
                    (W32PID)(GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid))) {
                flags |= XS_GIVEBACKONNACK;
            }
            flags |= XS_FRELEASE;
        } else {
            /*
             * on loan
             */
            if (AddPublicObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                        pIntDdeInfo->hIndirect,
                        (W32PID)(GETPTI(pDdeConv->spwnd)->ppi->W32Pid))) {
                flags |= XS_PUBLICOBJ;
            }
        }

        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        if (((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FACK) {
            *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv,
                xxxAdviseDataAck, NULL, hDirect, pIntDdeInfo, flags);
        } else {
            TRACE_DDE("xxxAdviseData: dumping non Ackable data...");
            UserAssert(hDirect != (HANDLE)*plParam);
            FreeDDEHandle(pDdeConv, hDirect, flags & ~XS_PACKED);
            pxs = Createpxs(NULL, NULL, NULL, pIntDdeInfo, flags | XS_FREEPXS);
            if (pxs != NULL) {
                pxs->head.pti = GETPTI(pDdeConv->spwndPartner);
            }
            *plParam = (LPARAM)PtoH(pxs);
        }
        if (*plParam == 0) {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}


/*
 * If its inter-process:
 *
 * xxxDDETrackGetMessageHook() completes the copy from pIntDdeInfo when WM_DDE_DATA
 * is received. pIntDdeInfo is then freed. The hServer handle saved into the
 * pxs structure pointed to by lParam is a directdata structure since
 * packed DDE messages are always assumed to have the packing handle freed
 * by the receiving app.
 * For the !fAckReq case, the pxs is freed due to the XS_FREEPXS flag.
 */


DWORD xxxAdviseDataAck(     // Client response to advise data - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pIntDdeInfo;
    DWORD dwRet;

    CheckLock(pDdeConv);

    /*
     * This is also used for request data ack processing.
     */
    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedClientPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxAdviseDataAck");

    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);

    pxsFree = pDdeConv->spxsOut;
    TRACE_DDE3("xxxAdviseDataAck:pxs.hClient(%#p), hServer(%#p), wStatus(%x)",
            pxsFree->hClient, pxsFree->hServer, pIntDdeInfo->DdePack.uiLo);
    if (pIntDdeInfo->DdePack.uiLo & DDE_FACK) {

        /*
         * positive ack implies client accepted the data - free from
         * server at postmessage time iff FRELEASE was set in data msg.
         */
        if (pxsFree->flags & XS_FRELEASE) {
            TRACE_DDE("xxxAdviseDataAck: +ACK delayed server data free");
            FreeListAdd(pDdeConv->spartnerConv, pxsFree->hServer,
                    pxsFree->flags & ~XS_PACKED);
        } else {
            /*
             * Ack w/out fRelease bit means client is done with data.
             */
            TRACE_DDE1("xxxAdviseDataAck: Freeing %#p. (+ACK)",
                    pxsFree->hClient);
            UserAssert(pxsFree->hClient != (HANDLE)*plParam);
            FreeDDEHandle(pDdeConv, pxsFree->hClient, pxsFree->flags & ~XS_PACKED);
        }

    } else {
        TRACE_DDE1("xxxAdviseDataAck: Freeing %#p. (-ACK)",
                pxsFree->hClient);
        FreeDDEHandle(pDdeConv, pxsFree->hClient, pxsFree->flags & ~XS_PACKED);
        UserAssert(pxsFree->hClient != (HANDLE)*plParam);
    }
    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                   UNADVISE TRANSACTION PROCESSING                     *
\***********************************************************************/



DWORD Unadvise(          // Spontaneous client transaction = WM_DDE_UNADVISE
PDDECONV pDdeConv)
{
    TRACE_DDE("Unadvise");
    if (AnticipatePost(pDdeConv->spartnerConv, xxxUnadviseAck, NULL, NULL, NULL, 0)) {
        return DO_POST;
    } else {
        return FAIL_POST;
    }
}



DWORD xxxUnadviseAck(      // Server response to unadvise - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD dwRet;
    PINTDDEINFO pIntDdeInfo;
    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }
    TRACE_DDE("xxxUnadviseAck");
    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);
    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                   REQUEST TRANSACTION PROCESSING                      *
\***********************************************************************/

DWORD Request(       // Spontaneous Client transaction - WM_DDE_REQUEST
PDDECONV pDdeConv)
{
    TRACE_DDE("Request");
    if (AnticipatePost(pDdeConv->spartnerConv, xxxRequestAck, NULL, NULL, NULL, 0)) {
        return DO_POST;
    } else {
        return FAIL_POST;
    }
}



DWORD xxxRequestAck(    // Server response - WM_DDE_ACK or WM_DDE_DATA expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    DWORD flags;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;
    DWORD dwStatus, dwRet;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxRequestAck or xxxAdviseData");
    switch (*pmessage) {
    case WM_DDE_DATA:

        /*
         * This is very close to advise data handling - the only catch
         * is that if the fRequest bit is clear this IS advise data.
         */
        flags = XS_PACKED | XS_LOHANDLE | XS_DATA;

        dwStatus = ClientGetDDEFlags((HANDLE)*plParam, flags);

        if (!(dwStatus & DDE_FREQUESTED)) {

            /*
             * Its NOT a request Ack - it must be advise data
             */
            return xxxAdviseData(pmessage, plParam, pDdeConv);
        }

        pxsFree = pDdeConv->spxsOut;
        dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
        if (dwRet == DO_POST) {
            UserAssert(pIntDdeInfo != NULL);
            if (!(((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & (DDE_FACK | DDE_FRELEASE))) {
                RIPMSG0(RIP_ERROR, "DDE protocol violation - no RELEASE or ACK bit set - setting RELEASE.");
                ((PDDE_DATA)(pIntDdeInfo + 1))->wStatus |= DDE_FRELEASE;
            }
            if (dwStatus & DDE_FRELEASE) {
                /*
                 * giving it away
                 */
                if (IsObjectPublic(pIntDdeInfo->hIndirect) != NULL) {
                    RIPMSG0(RIP_ERROR, "DDE Protocol violation - giving away a public GDI object.");
                    UserFreePool(pIntDdeInfo);
                    return FAILNOFREE_POST;
                }
                if (GiveObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                        pIntDdeInfo->hIndirect,
                        (W32PID)GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid)) {
                    flags |= XS_GIVEBACKONNACK;
                }
                flags |= XS_FRELEASE;
            } else {
                /*
                 * on loan
                 */
                if (AddPublicObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                            pIntDdeInfo->hIndirect,
                            (W32PID)GETPTI(pDdeConv->spwnd)->ppi->W32Pid)) {
                    flags |= XS_PUBLICOBJ;
                }
            }
            *pmessage |= MSGFLAG_DDE_MID_THUNK;
            if (dwStatus & DDE_FACK) {
                *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv,
                    xxxAdviseDataAck, NULL, hDirect, pIntDdeInfo, flags);
            } else {
                TRACE_DDE("xxxRequestAck: Delayed freeing non-ackable request data");
                FreeListAdd(pDdeConv, hDirect, flags & ~XS_PACKED);
                pxsFree = Createpxs(NULL, NULL, NULL, pIntDdeInfo, flags | XS_FREEPXS);
                if (pxsFree != NULL) {
                    pxsFree->head.pti = GETPTI(pDdeConv->spwndPartner);
                }
                *plParam = (LPARAM)PtoH(pxsFree);
            }

            if (*plParam != 0) {
                PopState(pDdeConv);
            } else {
                dwRet = FAILNOFREE_POST;
            }
        }
        return dwRet;

    case WM_DDE_ACK:        // server NACKs request
        dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
        if (dwRet != DO_POST) {
            return dwRet;
        }
        UserAssert(pIntDdeInfo != NULL);
        PopState(pDdeConv);
        return DO_POST;

    default:
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }
}



/************************************************************************
*                     POKE TRANSACTION PROCESSING                       *
\***********************************************************************/



DWORD xxxPoke(          // spontaneous client transaction - WM_DDE_POKE
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD flags, dwRet;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxPoke");
    flags = XS_PACKED | XS_LOHANDLE | XS_DATA;
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        if (((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FRELEASE) {
            /*
             * giving it away
             */
            if (IsObjectPublic(pIntDdeInfo->hIndirect) != NULL) {
                RIPMSG0(RIP_ERROR, "DDE Protocol violation - giving away a public GDI object.");
                UserFreePool(pIntDdeInfo);
                return FAILNOFREE_POST;
            }
            if (GiveObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                    pIntDdeInfo->hIndirect,
                    (W32PID)GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid)) {
                flags |= XS_GIVEBACKONNACK;
            }
            flags |= XS_FRELEASE;
        } else {
            /*
             * on loan
             */
            /*
             * fAck bit is ignored and assumed on.
             */
            if (AddPublicObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                        pIntDdeInfo->hIndirect,
                        (W32PID)GETPTI(pDdeConv->spwnd)->ppi->W32Pid)) {
                flags |= XS_PUBLICOBJ;
            }
        }
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv, xxxPokeAck,
             hDirect, NULL, pIntDdeInfo, flags);
        if (*plParam == 0) {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}


/*
 * If its inter-process:
 *
 * xxxDDETrackGetMessageHook() fills in hServer from pIntDdeInfo when WM_DDE_ADVISE
 * is received.  pIntDdeInfo is then freed.  The hServer handle saved into the
 * pxs structure pointer to by lParam is a directdata structure since
 * packed DDE messages are always assumed to have the packing handle freed
 * by the receiving app.
 * For the !fAckReq case, the pxs is also freed due to the XS_FREEPXS flag.
 */


DWORD xxxPokeAck(       // Server response to poke data - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pIntDdeInfo;
    DWORD dwRet;

    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxPokeAck");

    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);

    pxsFree = pDdeConv->spxsOut;
    if (pIntDdeInfo->DdePack.uiLo & DDE_FACK) {
        // positive ack implies server accepted the data - free from
        // client at postmessage time iff fRelease was set in poke message.
        if (pxsFree->flags & XS_FRELEASE) {
            TRACE_DDE("xxxPokeAck: delayed freeing client data");
            FreeListAdd(pDdeConv->spartnerConv, pxsFree->hClient,
                    pxsFree->flags & ~XS_PACKED);
        }
    } else {
        // Nack means that sender is responsible for freeing it.
        // We must free it in the receiver's context for him.
        TRACE_DDE("xxxPokeAck: freeing Nacked data");
        UserAssert(pxsFree->hServer != (HANDLE)*plParam);
        FreeDDEHandle(pDdeConv, pxsFree->hServer, pxsFree->flags & ~XS_PACKED);
    }
    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                   EXECUTE TRANSACTION PROCESSING                      *
\***********************************************************************/

DWORD xxxExecute(       // spontaneous client transaction - WM_DDE_EXECUTE
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD flags, dwRet;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxExecute");

    flags = XS_EXECUTE;
    if (!TestWF(pDdeConv->spwnd, WFANSIPROC) &&
            !TestWF(pDdeConv->spwndPartner, WFANSIPROC)) {
        flags |= XS_UNICODE;
    }
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv, xxxExecuteAck,
                hDirect, NULL, pIntDdeInfo, flags);
        /*
         * Check for != 0 to make sure the AnticipatePost() succeeded.
         */
        if (*plParam != 0) {

            /*
             * In the execute case it is likely that the postee will want to activate
             * itself and come on top (OLE 1.0 is an example). In this case, allow
             * both the postee and the poster to foreground activate for the next
             * activate (poster because it will want to activate itself again
             * probably, once the postee is done.)
             */
            GETPTI(pDdeConv->spwnd)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxExecute set TIF %#p", GETPTI(pDdeConv->spwnd));
            GETPTI(pDdeConv->spwndPartner)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxExecute set TIF %#p", GETPTI(pDdeConv->spwndPartner));
        } else {
            dwRet = FAILNOFREE_POST;
        }

    }
    return dwRet;
}


/*
 * xxxDDETrackGetMessageHook() fills in hServer from pIntDdeInfo when WM_DDE_EXECUTE
 * is received.  pIntDdeInfo is then freed.
 */


DWORD xxxExecuteAck(       // Server response to execute data - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pi;
    DWORD flags = XS_PACKED | XS_FREESRC | XS_EXECUTE;
    DWORD dwRet;

    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxExecuteAck");
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, NULL, &pi);
    if (dwRet == DO_POST) {
        UserAssert(pi != NULL);
        /*
         * the server must respond to the execute with an ack containing the
         * same handle it was given.
         */
        pi->DdePack.uiHi = (ULONG_PTR)pDdeConv->spxsOut->hClient;
        pi->hDirect = NULL;
        pi->cbDirect = 0;
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        pxsFree = Createpxs(NULL, NULL, NULL, pi, XS_PACKED | XS_FREEPXS);
        if (pxsFree != NULL) {
            pxsFree->head.pti = GETPTI(pDdeConv->spwndPartner);
        }
        *plParam = (LPARAM)PtoH(pxsFree);
        if (*plParam != 0) {
            PopState(pDdeConv);
        } else {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}



/************************************************************************
*                  TERMINATE TRANSACTION PROCESSING                     *
\***********************************************************************/



DWORD SpontaneousTerminate(
PDWORD pmessage,
PDDECONV pDdeConv)
{
    TRACE_DDE("SpontaneousTerminate");
    if (pDdeConv->flags & CXF_TERMINATE_POSTED) {
        return FAKE_POST;
    } else {
        pDdeConv->flags |= CXF_TERMINATE_POSTED;
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        return DO_POST;
    }
}

/*
 * The xxxDDETrackGetMessageHook() function restores the *pmessage value.
 * Unless a spontaneous terminate from the other app has already
 * arrived, it will note that CXF_TERMINATE_POSTED is NOT set on
 * both sides so no action is taken.
 */


/************************************************************************
*               DUPLICATE CONVERSATION TERMINATION                      *
\***********************************************************************/

/*
 * This routine is called when a DDE server window sent a WM_DDE_ACK
 * message to a client window which is already engaged in a conversation
 * with that server window.  We swallow the ACK and post a terminate to
 * the server window to shut this conversation down.  When the server
 * posts the terminate, this function is called to basically fake
 * a sucessful post.  Thus the client is never bothered while the
 * errant server thinks the conversation was connected and then
 * imediately terminated.
 */
DWORD DupConvTerminate(       // WM_DDE_TERMINATE expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    CheckLock(pDdeConv);

    TRACE_DDE("DupConvTerminate");

    if (*pmessage != WM_DDE_TERMINATE) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    PopState(pDdeConv);
    return FAKE_POST;
}



/************************************************************************
*               HELPER ROUTINES FOR TRANSACTION TRACKING                *
\***********************************************************************/



/************************************************************************
* AnticipatePost
*
* Allocates, fills and links XSTATE structures.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
HANDLE AnticipatePost(
PDDECONV pDdeConv,
FNDDERESPONSE fnResponse,
HANDLE hClient,
HANDLE hServer,
PINTDDEINFO pIntDdeInfo,
DWORD flags)
{
    PXSTATE pxs;

    pxs = Createpxs(fnResponse, hClient, hServer, pIntDdeInfo, flags);
    if (pxs != NULL) {
        pxs->head.pti = pDdeConv->head.pti;
        if (pDdeConv->spxsOut == NULL) {
            UserAssert(pDdeConv->spxsIn == NULL);
            Lock(&(pDdeConv->spxsOut), pxs);
            Lock(&(pDdeConv->spxsIn), pxs);
        } else {
            UserAssert(pDdeConv->spxsIn != NULL);
            Lock(&(pDdeConv->spxsIn->snext), pxs);
            Lock(&(pDdeConv->spxsIn), pxs);
        }
#if 0
        {
            int i;
            HANDLEENTRY *phe;

            for (i = 0, phe = gSharedInfo.aheList;
                i <= (int)giheLast;
                    i++) {
                if (phe[i].bType == TYPE_DDEXACT) {
                    UserAssert(((PXSTATE)(phe[i].phead))->snext != pDdeConv->spxsOut);
                }
                if (phe[i].bType == TYPE_DDECONV &&
                        (PDDECONV)phe[i].phead != pDdeConv) {
                    UserAssert(((PDDECONV)(phe[i].phead))->spxsOut != pDdeConv->spxsOut);
                    UserAssert(((PDDECONV)(phe[i].phead))->spxsIn != pDdeConv->spxsOut);
                }
            }
        }
#endif
    }
    return PtoH(pxs);
}



/************************************************************************
* Createpxs
*
* Allocates and fills XSTATE structures.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
PXSTATE Createpxs(
FNDDERESPONSE fnResponse,
HANDLE hClient,
HANDLE hServer,
PINTDDEINFO pIntDdeInfo,
DWORD flags)
{
    PXSTATE pxs;

    pxs = HMAllocObject(PtiCurrent(), NULL, TYPE_DDEXACT, sizeof(XSTATE));
    if (pxs == NULL) {
#if DBG
        RIPMSG0(RIP_WARNING, "Unable to alloc DDEXACT");
#endif
        return NULL;
    }
    pxs->snext = NULL;
    pxs->fnResponse = fnResponse;
    pxs->hClient = hClient;
    pxs->hServer = hServer;
    pxs->pIntDdeInfo = pIntDdeInfo;
    pxs->flags = flags;
    ValidatePublicObjectList();
    UserAssert(pxs->head.cLockObj == 0);
    return pxs;
}




/************************************************************************
* AbnormalDDEPost
*
* This is the catch-all routine for wierd cases
*
* returns post action code - DO_POST, FAKE_POST, FAIL_POST.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD AbnormalDDEPost(
PDDECONV pDdeConv,
DWORD message)
{

#if DBG
    if (message != WM_DDE_TERMINATE) {
        RIPMSG2(RIP_WARNING,
                "DDE Post failed (%#p:%#p) - protocol violation.",
                PtoH(pDdeConv->spwnd), PtoH(pDdeConv->spwndPartner));
    }
#endif // DBG

    // shutdown this conversation by posting a terminate on
    // behalf of this guy, then fail all future posts but
    // fake a successful terminate.

    if (!(pDdeConv->flags & CXF_TERMINATE_POSTED)) {
        _PostMessage(pDdeConv->spwndPartner, WM_DDE_TERMINATE,
                (WPARAM)PtoH(pDdeConv->spwnd), 0);
        // pDdeConv->flags |= CXF_TERMINATE_POSTED; Set by post hook proc
    }
    return message == WM_DDE_TERMINATE ? FAKE_POST : FAIL_POST;
}



/************************************************************************
* NewConversation
*
* Worker function used to create a saimese pair of DDECONV structures.
*
* Returns fCreateOk
*
* History:
* 11-5-92    sanfords    Created
\***********************************************************************/
BOOL NewConversation(
PDDECONV *ppdcNewClient,
PDDECONV *ppdcNewServer,
PWND pwndClient,
PWND pwndServer)
{
    PDDECONV pdcNewClient;
    PDDECONV pdcNewServer;

    pdcNewClient = HMAllocObject(GETPTI(pwndClient), NULL,
            TYPE_DDECONV, sizeof(DDECONV));
    if (pdcNewClient == NULL) {
        return FALSE;
    }

    pdcNewServer = HMAllocObject(GETPTI(pwndServer), NULL,
            TYPE_DDECONV, sizeof(DDECONV));
    if (pdcNewServer == NULL) {
        HMFreeObject(pdcNewClient);     // we know it's not locked.
        return FALSE;
    }

    AddConvProp(pwndClient, pwndServer, 0, pdcNewClient, pdcNewServer);
    AddConvProp(pwndServer, pwndClient, CXF_IS_SERVER, pdcNewServer,
            pdcNewClient);

    if (ppdcNewClient != NULL) {
        *ppdcNewClient = pdcNewClient;
    }
    if (ppdcNewServer != NULL) {
        *ppdcNewServer = pdcNewServer;
    }
    return TRUE;
}


/************************************************************************
* FindDdeConv
*
* Locates the pDdeConv associated with pwndProp, and pwndPartner.
* Only searches pwndProp's property list.
*
* History:
* 3-31-91   sanfords    Created
\***********************************************************************/
PDDECONV FindDdeConv(
PWND pwndProp,
PWND pwndPartner)
{
    PDDECONV pDdeConv;

    pDdeConv = (PDDECONV)_GetProp(pwndProp, PROP_DDETRACK, PROPF_INTERNAL);
    while (pDdeConv != NULL && pDdeConv->spwndPartner != pwndPartner) {
        pDdeConv = pDdeConv->snext;
    }

    return pDdeConv;
}



/************************************************************************
* xxxCopyAckIn
*
* A common occurance helper function
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxCopyAckIn(
LPDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv,
PINTDDEINFO * ppIntDdeInfo)
{
    PINTDDEINFO pIntDdeInfo;
    DWORD flags, dwRet;
    PXSTATE pxs;

    CheckLock(pDdeConv);

    flags = XS_PACKED | XS_FREESRC;
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, NULL, ppIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(*ppIntDdeInfo != NULL);
        pIntDdeInfo = *ppIntDdeInfo;
        if (pDdeConv->spxsOut->flags & XS_GIVEBACKONNACK &&
                !(((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FACK)) {
            GiveObject(((PDDE_DATA)(pDdeConv->spxsOut->pIntDdeInfo + 1))->wFmt,
                    pDdeConv->spxsOut->pIntDdeInfo->hIndirect,
                    (W32PID)GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid);
        }
        if (pDdeConv->spxsOut->flags & XS_PUBLICOBJ) {
            RemovePublicObject(((PDDE_DATA)(pDdeConv->spxsOut->pIntDdeInfo + 1))->wFmt,
                    pDdeConv->spxsOut->pIntDdeInfo->hIndirect);
            pDdeConv->spxsOut->flags &= ~XS_PUBLICOBJ;
        }
        pxs = Createpxs(NULL, NULL, NULL, pIntDdeInfo, flags | XS_FREEPXS);
        if (pxs != NULL) {
            pxs->head.pti = GETPTI(pDdeConv->spwndPartner);
        }
        *plParam = (LPARAM)PtoH(pxs);
        if (*plParam == 0) {
            return FAILNOFREE_POST;
        }
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
    }
    return dwRet;
}



/************************************************************************
* FreeListAdd
*
* Adds a CSR Client handle to the free list associated with pDdeConv.
* This allows us to make sure stuff is freed that isn't in a context
* we have access at the time we know it must be freed.
*
* returns fSuccess
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
BOOL FreeListAdd(
PDDECONV pDdeConv,
HANDLE hClient,
DWORD flags)
{
    PFREELIST pfl;

    pfl = (PFREELIST)UserAllocPool(sizeof(FREELIST), TAG_DDE1);
    if (!pfl) {
        return FALSE;
    }
    TRACE_DDE2("FreeListAdd: %x for thread %x.", hClient,
            GETPTIID(pDdeConv->head.pti));
    pfl->h = hClient;
    pfl->flags = flags;
    pfl->next = pDdeConv->pfl;
    pDdeConv->pfl = pfl;
    return TRUE;
}


/************************************************************************
* FreeDDEHandle
*
* Frees contents DDE client side handle - delayed free if a WOW process.
*
* History:
* 7-28-94    sanfords    Created
\***********************************************************************/
VOID FreeDDEHandle(
PDDECONV pDdeConv,
HANDLE hClient,
DWORD flags)
{
    if (PtiCurrent()->TIF_flags & TIF_16BIT) {
        TRACE_DDE1("FreeDDEHandle: (WOW hack) delayed Freeing %#p.", hClient);
        FreeListAdd(pDdeConv, hClient, flags);
    } else {
        TRACE_DDE1("FreeDDEHandle: Freeing %#p.", hClient);
        ClientFreeDDEHandle(hClient, flags);
    }
}



/************************************************************************
* xxxFreeListFree
*
* Frees contents of the free list associated with pDdeConv.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID FreeListFree(
    PFREELIST pfl)
{
    PFREELIST pflPrev;

    CheckCritIn();

    UserAssert(pfl != NULL);

    while (pfl != NULL) {
        pflPrev = pfl;
        pfl = pfl->next;
        UserFreePool(pflPrev);
    }
}


VOID xxxFreeListFree(
PFREELIST pfl)
{
    PFREELIST pflPrev;
    BOOL      fInCleanup;
    TL        tlPool;

    CheckCritIn();

    if (pfl == NULL) {
        return;
    }

    fInCleanup = (PtiCurrent())->TIF_flags & TIF_INCLEANUP;

    while (pfl != NULL) {

        ThreadLockPoolCleanup(PtiCurrent(), pfl, &tlPool, FreeListFree);

        if (!fInCleanup) {
            TRACE_DDE1("Freeing %#p from free list.\n", pfl->h);
            ClientFreeDDEHandle(pfl->h, pfl->flags);
        }

        ThreadUnlockPoolCleanup(PtiCurrent(), &tlPool);

        pflPrev = pfl;
        pfl = pfl->next;
        UserFreePool(pflPrev);
    }
}


/************************************************************************
* PopState
*
* Frees spxsOut from pDdeConv and handles empty queue case.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID PopState(
PDDECONV pDdeConv)
{
    PXSTATE pxsNext, pxsFree;
    TL tlpxs;

    UserAssert(pDdeConv->spxsOut != NULL);
#if 0
    {
        int i;
        HANDLEENTRY *phe;

        for (i = 0, phe = gSharedInfo.aheList;
            i <= giheLast;
                i++) {
            if (phe[i].bType == TYPE_DDEXACT) {
                UserAssert(((PXSTATE)(phe[i].phead))->snext != pDdeConv->spxsOut);
            }
        }
    }
#endif
    UserAssert(!(pDdeConv->spxsOut->flags & XS_FREEPXS));
    UserAssert(pDdeConv->spxsIn != NULL);
    UserAssert(pDdeConv->spxsIn->snext == NULL);

    ThreadLockAlways(pDdeConv->spxsOut, &tlpxs);              // hold it fast
    pxsNext = pDdeConv->spxsOut->snext;
    pxsFree = Lock(&(pDdeConv->spxsOut), pxsNext);      // lock next into head
    if (pxsNext == NULL) {
        UserAssert(pDdeConv->spxsIn == pxsFree);
        Unlock(&(pDdeConv->spxsIn));                // queue is empty.
    } else {
        Unlock(&(pxsFree->snext));                  // clear next ptr
    }
    pxsFree = ThreadUnlock(&tlpxs);                     // undo our lock
    if (pxsFree != NULL) {
        FreeDdeXact(pxsFree);                           // cleanup.
    }
}


VOID FreeDdeConv(
PDDECONV pDdeConv)
{

    TRACE_DDE1("FreeDdeConv(%#p)", pDdeConv);

    if (!(pDdeConv->flags & CXF_TERMINATE_POSTED) &&
            !HMIsMarkDestroy(pDdeConv->spwndPartner)) {
        _PostMessage(pDdeConv->spwndPartner, WM_DDE_TERMINATE,
                (WPARAM)PtoH(pDdeConv->spwnd), 0);
        // pDdeConv->flags |= CXF_TERMINATE_POSTED; set by PostHookProc
    }

    if (pDdeConv->spartnerConv != NULL &&
            GETPTI(pDdeConv)->TIF_flags & TIF_INCLEANUP) {
        /*
         * Fake that the other side already posted a terminate.
         * This prevents vestigal dde structures from hanging
         * around after thread cleanup if the conversation structure
         * is destroyed before the associated window.
         */
        pDdeConv->spartnerConv->flags |= CXF_TERMINATE_POSTED;
    }

    UnlinkConv(pDdeConv);

    if (pDdeConv->pddei != NULL) {
        pDdeConv->pddei->cRefConv--;
        if (pDdeConv->pddei->cRefConv == 0 && pDdeConv->pddei->cRefInit == 0) {
            SeDeleteClientSecurity(&pDdeConv->pddei->ClientContext);
            UserFreePool(pDdeConv->pddei);
        }
        pDdeConv->pddei = NULL;
    }

    Unlock(&(pDdeConv->spartnerConv));
    Unlock(&(pDdeConv->spwndPartner));
    Unlock(&(pDdeConv->spwnd));

    if (!HMMarkObjectDestroy((PHEAD)pDdeConv))
        return;

    while (pDdeConv->spxsOut) {
        PopState(pDdeConv);
    }

    HMFreeObject(pDdeConv);
}



/***************************************************************************\
* xxxCopyDdeIn
*
* Description:
*   Copies DDE data from the CSR client to the CSR server side.
*   Crosses the CSR barrier as many times as is needed to get all the data
*   through the CSR window.
*
* History:
* 11-1-91   sanfords    Created.
\***************************************************************************/
DWORD xxxCopyDdeIn(
HANDLE hSrc,
PDWORD pflags,
PHANDLE phDirect,
PINTDDEINFO *ppi)
{
    DWORD dwRet;
    PINTDDEINFO pi;

    dwRet = xxxClientCopyDDEIn1(hSrc, *pflags, ppi);
    pi = *ppi;
    TRACE_DDE2(*pflags & XS_FREESRC ?
            "Copying in and freeing %#p(%#p)" :
            "Copying in %#p(%#p)",
            hSrc, pi ? pi->hDirect : 0);

    if (dwRet == DO_POST) {
        UserAssert(*ppi != NULL);
        *pflags = pi->flags;
        TRACE_DDE3("xxxCopyDdeIn: uiLo=%x, uiHi=%x, hDirect=%#p",
                pi->DdePack.uiLo, pi->DdePack.uiHi, pi->hDirect);
        if (phDirect != NULL) {
            *phDirect = pi->hDirect;
        }
    }
#if DBG
      else {
        RIPMSG0(RIP_WARNING, "Unable to alloc DDE INTDDEINFO");
    }
#endif

    return dwRet;
}



/***********************************************************************\
* xxxCopyDDEOut
*
* Returns: the apropriate client side handle for lParam or NULL on
* failure. (Since only TERMINATES should have 0 here)
*
* 11/7/1995 Created SanfordS
\***********************************************************************/

HANDLE xxxCopyDDEOut(
PINTDDEINFO pi,
PHANDLE phDirect)   // receives the target client side GMEM handle.
{
    HANDLE hDst;

    TRACE_DDE3("xxxCopyDDEOut: cbDirect=%x, cbIndirect=%x, flags=%x",
            pi->cbDirect, pi->cbIndirect, pi->flags);
    hDst = xxxClientCopyDDEOut1(pi);
    TRACE_DDE3("xxxCopyDDEOut: uiLo=%x, uiHi=%x, hResult=%#p",
            pi->DdePack.uiLo, pi->DdePack.uiHi, hDst);
    if (hDst != NULL) {
        if (phDirect != NULL) {
            TRACE_DDE1("xxxCopyDDEOut: *phDirect=%#p", pi->hDirect);
            *phDirect = pi->hDirect;
        }
    }
    return hDst;
}



/*
 * This API is used to set the QOS associated with a potential DDE client window.
 * It should be called prior to sending a WM_DDE_INITIATE message and the qos set
 * will hold until the WM_DDE_INITIATE send or broadcast returns.
 */
BOOL _DdeSetQualityOfService(
PWND pwndClient,
CONST PSECURITY_QUALITY_OF_SERVICE pqosNew,
PSECURITY_QUALITY_OF_SERVICE pqosOld)
{
    PSECURITY_QUALITY_OF_SERVICE pqosUser;
    PSECURITY_QUALITY_OF_SERVICE pqosAlloc = NULL;
    BOOL fRet;

    /*
     * ASSUME: calling process is owner of pwndClient - ensured in thunk.
     */
    pqosUser = (PSECURITY_QUALITY_OF_SERVICE)InternalRemoveProp(pwndClient,
            PROP_QOS, PROPF_INTERNAL);
    if (pqosUser == NULL) {
        if (RtlEqualMemory(pqosNew, &gqosDefault, sizeof(SECURITY_QUALITY_OF_SERVICE))) {
            return TRUE;           // no PROP_QOS property implies default QOS
        }
        pqosAlloc = (PSECURITY_QUALITY_OF_SERVICE)UserAllocPoolZInit(
                sizeof(SECURITY_QUALITY_OF_SERVICE), TAG_DDE2);
        if (pqosAlloc == NULL) {
            return FALSE;          // memory allocation failure - can't change from default
        }
        pqosUser = pqosAlloc;
    }
    *pqosOld = *pqosUser;
    *pqosUser = *pqosNew;

    fRet = InternalSetProp(pwndClient, PROP_QOS, pqosUser, PROPF_INTERNAL);
    if ((fRet == FALSE) && (pqosAlloc != NULL)) {
        UserFreePool(pqosAlloc);
    }

    return fRet;
}


/*
 * This is a private API for NetDDE's use.  It extracts the QOS associated with an
 * active DDE conversation.  Intra-process conversations always are set to the default
 * QOS.
 */
BOOL _DdeGetQualityOfService(
PWND pwndClient,
PWND pwndServer,
PSECURITY_QUALITY_OF_SERVICE pqos)
{
    PDDECONV pDdeConv;
    PSECURITY_QUALITY_OF_SERVICE pqosClient;

    if (pwndServer == NULL) {
        /*
         * Special case to support DDEML-RAW conversations that need to get
         * the QOS prior to initiation completion.
         */
        pqosClient = _GetProp(pwndClient, PROP_QOS, PROPF_INTERNAL);
        if (pqosClient == NULL) {
            *pqos = gqosDefault;
        } else {
            *pqos = *pqosClient;
        }
        return TRUE;
    }
    if (GETPWNDPPI(pwndClient) == GETPWNDPPI(pwndServer)) {
        *pqos = gqosDefault;
        return TRUE;
    }
    pDdeConv = FindDdeConv(pwndClient, pwndServer);
    if (pDdeConv == NULL) {
        return FALSE;
    }
    if (pDdeConv->pddei == NULL) {
        return FALSE;
    }
    *pqos = pDdeConv->pddei->qos;
    return TRUE;
}



BOOL _ImpersonateDdeClientWindow(
    PWND pwndClient,
    PWND pwndServer)
{
    PDDECONV pDdeConv;
    NTSTATUS Status;

    /*
     * Locate token used in the conversation
     */
    pDdeConv = FindDdeConv(pwndClient, pwndServer);
    if (pDdeConv == NULL || pDdeConv->pddei == NULL)
        return FALSE;

    /*
     * Stick the token into the dde server thread
     */
    Status = SeImpersonateClientEx(&pDdeConv->pddei->ClientContext,
            PsGetCurrentThread());
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}


VOID FreeDdeXact(
    PXSTATE pxs)
{
    if (!HMMarkObjectDestroy(pxs)) {
        return;
    }

#if 0
    {
        int i;
        HANDLEENTRY *phe;

        for (i = 0, phe = gSharedInfo.aheList; i <= giheLast; i++) {
            if (phe[i].bType == TYPE_DDEXACT) {
                UserAssert(((PXSTATE)(phe[i].phead))->snext != pxs);
            } else if (phe[i].bType == TYPE_DDECONV) {
                UserAssert(((PDDECONV)(phe[i].phead))->spxsOut != pxs);
                UserAssert(((PDDECONV)(phe[i].phead))->spxsIn != pxs);
            }
        }
    }
    UserAssert(pxs->head.cLockObj == 0);
    UserAssert(pxs->snext == NULL);
#endif

    if (pxs->pIntDdeInfo != NULL) {
        /*
         * free any server-side GDI objects
         */
        if (pxs->pIntDdeInfo->flags & (XS_METAFILEPICT | XS_ENHMETAFILE)) {
            GreDeleteServerMetaFile(pxs->pIntDdeInfo->hIndirect);
        }
        if (pxs->flags & XS_PUBLICOBJ) {
            RemovePublicObject(((PDDE_DATA)(pxs->pIntDdeInfo + 1))->wFmt,
                    pxs->pIntDdeInfo->hIndirect);
            pxs->flags &= ~XS_PUBLICOBJ;
        }
        UserFreePool(pxs->pIntDdeInfo);
    }

    HMFreeObject(pxs);
    ValidatePublicObjectList();
}



PPUBOBJ IsObjectPublic(
HANDLE hObj)
{
    PPUBOBJ ppo;

    for (ppo = gpPublicObjectList; ppo != NULL; ppo = ppo->next) {
        if (ppo->hObj == hObj) {
            break;
        }
    }
    return ppo;
}



BOOL AddPublicObject(
UINT format,
HANDLE hObj,
W32PID pid)
{
    PPUBOBJ ppo;

    switch (format) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        break;

    default:
        return FALSE;
    }

    ppo = IsObjectPublic(hObj);
    if (ppo == NULL) {
        ppo = UserAllocPool(sizeof(PUBOBJ), TAG_DDE4);
        if (ppo == NULL) {
            return FALSE;
        }
        ppo->count = 1;
        ppo->hObj = hObj;
        ppo->pid = pid;
        ppo->next = gpPublicObjectList;
        gpPublicObjectList = ppo;
        GiveObject(format, hObj, OBJECT_OWNER_PUBLIC);
    } else {
        ppo->count++;
    }
    return TRUE;
}



BOOL RemovePublicObject(
UINT format,
HANDLE hObj)
{
    PPUBOBJ ppo, ppoPrev;

    switch (format) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        break;

    default:
        return FALSE;
    }

    for (ppoPrev = NULL, ppo = gpPublicObjectList;
            ppo != NULL;
                ppoPrev = ppo, ppo = ppo->next) {
        if (ppo->hObj == hObj) {
            break;
        }
    }
    if (ppo == NULL) {
        UserAssert(FALSE);
        return FALSE;
    }
    ppo->count--;
    if (ppo->count == 0) {
        GiveObject(format, hObj, ppo->pid);
        if (ppoPrev != NULL) {
            ppoPrev->next = ppo->next;
        } else {
            gpPublicObjectList = ppo->next;
        }
        UserFreePool(ppo);
    }
    return TRUE;
}


BOOL
GiveObject(
    UINT format,
    HANDLE hObj,
    W32PID pid)
{
    switch (format) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
        GreSetBitmapOwner(hObj, pid);
        return TRUE;

    case CF_PALETTE:
        GreSetPaletteOwner(hObj, pid);
        return TRUE;

    default:
        return FALSE;
    }
}

#if DBG
VOID ValidatePublicObjectList()
{
    PPUBOBJ ppo;
    int i, count;
    HANDLEENTRY *phe;

    for (count = 0, ppo = gpPublicObjectList;
            ppo != NULL;
                ppo = ppo->next) {
        count += ppo->count;
    }
    for (i = 0, phe = gSharedInfo.aheList;
        i <= (int)giheLast;
            i++) {
        if (phe[i].bType == TYPE_DDEXACT) {
            if (((PXSTATE)(phe[i].phead))->flags & XS_PUBLICOBJ) {
                UserAssert(((PXSTATE)(phe[i].phead))->pIntDdeInfo != NULL);
                UserAssert(IsObjectPublic(((PXSTATE)
                        (phe[i].phead))->pIntDdeInfo->hIndirect) != NULL);
                count--;
            }
        }
    }
    UserAssert(count == 0);
}


VOID TraceDdeMsg(
UINT msg,
HWND hwndFrom,
HWND hwndTo,
UINT code)
{
    LPSTR szMsg, szType;

    msg = msg & 0xFFFF;

    switch (msg) {
    case WM_DDE_INITIATE:
        szMsg = "INITIATE";
        break;

    case WM_DDE_TERMINATE:
        szMsg = "TERMINATE";
        break;

    case WM_DDE_ADVISE:
        szMsg = "ADVISE";
        break;

    case WM_DDE_UNADVISE:
        szMsg = "UNADVISE";
        break;

    case WM_DDE_ACK:
        szMsg = "ACK";
        break;

    case WM_DDE_DATA:
        szMsg = "DATA";
        break;

    case WM_DDE_REQUEST:
        szMsg = "REQUEST";
        break;

    case WM_DDE_POKE:
        szMsg = "POKE";
        break;

    case WM_DDE_EXECUTE:
        szMsg = "EXECUTE";
        break;

    default:
        szMsg = "BOGUS";
        UserAssert(msg >= WM_DDE_FIRST && msg <= WM_DDE_LAST);
        break;
    }

    switch (code) {
    case MSG_SENT:
        szType = "[sent]";
        break;

    case MSG_POST:
        szType = "[posted]";
        break;

    case MSG_RECV:
        szType = "[received]";
        break;

    case MSG_PEEK:
        szType = "[peeked]";
        break;

    default:
        szType = "[bogus]";
        UserAssert(FALSE);
        break;
    }

    RIPMSG4(RIP_VERBOSE,
            "%#p->%#p WM_DDE_%s %s",
            hwndFrom, hwndTo, szMsg, szType);
}
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\dtbitmap.c ===
/****************************** Module Header ******************************\
* Module Name: dtbitmap.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Desktop Wallpaper Routines.
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Constants.
 */
#define MAXPAL         256
#define MAXSTATIC       20
#define TILE_XMINSIZE    2
#define TILE_YMINSIZE    4

/*
 * The version strings are stored in a contiguous-buffer.  Each string
 * is of size MAXVERSIONSTRING.
 */

// Size of each string buffer.
#define MAXVERSIONSTRING  128

// Offset into verbuffer of build-string.
#define OFFSET_BLDSTRING  0

// Offset into verbuffer of CSD string.
#define OFFSET_CSDSTRING  OFFSET_BLDSTRING + MAXVERSIONSTRING

// Max size of buffer (contains all 3 strings).
#define MAXVERSIONBUFFER  OFFSET_CSDSTRING + MAXVERSIONSTRING

WCHAR          wszSafeMode[MAX_PATH + 3 * MAXVERSIONSTRING];
WCHAR          SafeModeStr[64];
int            SafeModeStrLen;
WCHAR          wszProductName[MAXVERSIONSTRING];
WCHAR          wszProductBuild[2 * MAXVERSIONSTRING];


__inline PWND _GetShellWindow(
    PDESKTOP pdesk)
{
    if (pdesk == NULL) {
        return NULL;
    } else {
        return pdesk->pDeskInfo->spwndShell;
    }
}

/***************************************************************************\
* GetVersionInfo
*
* Outputs a string on the desktop indicating debug-version.
*
* History:
\***************************************************************************/
VOID
GetVersionInfo(
    BOOL Verbose)
{
    WCHAR          NameBuffer[MAXVERSIONBUFFER];
    WCHAR          Title1[MAXVERSIONSTRING];
    WCHAR          Title2[MAXVERSIONSTRING];
    WCHAR          wszPID[MAXVERSIONSTRING];
    WCHAR          wszProduct[MAXVERSIONSTRING];
    WCHAR          wszPBuild[MAXVERSIONSTRING];
    WCHAR          wszEvaluation[MAXVERSIONSTRING];
    UNICODE_STRING UserBuildString;
    UNICODE_STRING UserCSDString;
    NTSTATUS       Status;
    UINT           uProductStrId;

    /*
     * Temporary code name handling.  Used internally and turned off by ""
     * for release.  The matching string in strid.mc doesn't have a space
     * separator between code name and the rest of the title, so this
     * space must be included at end of this code name string.
     */
    WCHAR          wszCodeName[] = L"";

    RTL_QUERY_REGISTRY_TABLE BaseServerRegistryConfigurationTable[] = {

        {NULL,
         RTL_QUERY_REGISTRY_DIRECT,
#ifdef PRERELEASE
         L"BuildLab",
#else
         L"CurrentBuildNumber",
#endif // PRERELEASE
         &UserBuildString,
         REG_NONE,
         NULL,
         0},

        {NULL,
         RTL_QUERY_REGISTRY_DIRECT,
         L"CSDVersion",
         &UserCSDString,
         REG_NONE,
         NULL,
         0},

        {NULL,
         0,
         NULL,
         NULL,
         REG_NONE,
         NULL,
         0}
    };

    UserBuildString.Buffer          = &NameBuffer[OFFSET_BLDSTRING];
    UserBuildString.Length          = 0;
    UserBuildString.MaximumLength   = MAXVERSIONSTRING * sizeof(WCHAR);

    UserCSDString.Buffer            = &NameBuffer[OFFSET_CSDSTRING];
    UserCSDString.Length            = 0;
    UserCSDString.MaximumLength     = MAXVERSIONSTRING * sizeof(WCHAR);

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"",
                                    BaseServerRegistryConfigurationTable,
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "GetVersionInfo failed with status %x", Status);
        return;
    }

    ServerLoadString(hModuleWin, STR_DTBS_PRODUCTID, wszPID, ARRAY_SIZE(wszPID));
    ServerLoadString(hModuleWin, STR_DTBS_PRODUCTBUILD, wszPBuild, ARRAY_SIZE(wszPBuild));

    /*
     * Write out Debugging Version message.
     */

    /*
     * Bug 280256 - joejo
     * Create new desktop build information strings
     */
    if (USER_SHARED_DATA->SuiteMask & (1 << EmbeddedNT)) {
        uProductStrId = STR_DTBS_PRODUCTEMB;
    } else if (USER_SHARED_DATA->NtProductType == NtProductWinNt) {
#ifdef _WIN64
        uProductStrId = STR_DTBS_PRODUCTWKS64;
#else
        if (USER_SHARED_DATA->SuiteMask & (1 << Personal)) {
            uProductStrId = STR_DTBS_PRODUCTPER;
        } else {
            uProductStrId = STR_DTBS_PRODUCTPRO;
        }
#endif
    } else {
#ifdef _WIN64
        if (USER_SHARED_DATA->SuiteMask & (1 << DataCenter)) {
            uProductStrId = STR_DTBS_PRODUCTDTC64;
        } else if (USER_SHARED_DATA->SuiteMask & (1 << Enterprise)) {
            uProductStrId = STR_DTBS_PRODUCTADV64;
        } else {
            uProductStrId = STR_DTBS_PRODUCTSRV64;
        }
#else
        if (USER_SHARED_DATA->SuiteMask & (1 << DataCenter)) {
            uProductStrId = STR_DTBS_PRODUCTDTC;
        } else if (USER_SHARED_DATA->SuiteMask & (1 << Enterprise)) {
            uProductStrId = STR_DTBS_PRODUCTADV;
        } else if (USER_SHARED_DATA->SuiteMask & (1 << Blade)) {
            uProductStrId = STR_DTBS_PRODUCTBLA;
        } else if(USER_SHARED_DATA->SuiteMask & (1 << SmallBusinessRestricted)) {
            uProductStrId = STR_DTBS_PRODUCTSBS;
        } else {
            uProductStrId = STR_DTBS_PRODUCTSRV;
        }
#endif /* _WIN64 */
    }

    ServerLoadString(hModuleWin, uProductStrId, wszProduct, ARRAY_SIZE(wszProduct));

    swprintf(
        wszProductName,
        wszPID,
        wszCodeName,
        wszProduct);

    if (gfUnsignedDrivers) {
        /* This takes precedence */
        ServerLoadString(hModuleWin, STR_TESTINGONLY, wszEvaluation, ARRAY_SIZE(wszEvaluation));
    } else if (USER_SHARED_DATA->SystemExpirationDate.QuadPart) {
        ServerLoadString(hModuleWin, STR_DTBS_EVALUATION, wszEvaluation, ARRAY_SIZE(wszEvaluation));
    } else {
        wszEvaluation[0] = '\0';
    }

    swprintf(
        wszProductBuild,
        wszPBuild,
        wszEvaluation,
        UserBuildString.Buffer
        );

    if (Verbose) {
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE1, Title1, ARRAY_SIZE(Title1));
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE2, Title2, ARRAY_SIZE(Title2));

        swprintf(
            wszSafeMode,
            UserCSDString.Length == 0 ? Title1 : Title2,
            wszCodeName,
            UserBuildString.Buffer,
            UserCSDString.Buffer,
            USER_SHARED_DATA->NtSystemRoot
            );
    } else {
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE3, Title1, ARRAY_SIZE(Title1));
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE4, Title2, ARRAY_SIZE(Title2));

        swprintf(
            wszSafeMode,
            UserCSDString.Length == 0 ? Title1 : Title2,
            wszCodeName,
            UserBuildString.Buffer,
            UserCSDString.Buffer);
    }
}

/***************************************************************************\
* GetDefaultWallpaperName
*
* Get initial bitmap name
*
* History:
* 21-Feb-1995 JimA      Created.
* 06-Mar-1996 ChrisWil  Moved to kernel to facilite ChangeDisplaySettings.
\***************************************************************************/
VOID
GetDefaultWallpaperName(
    LPWSTR  lpszWallpaper)
{
    /*
     * Set the initial global wallpaper bitmap name for (Default)
     * The global name is an at most 8 character name with no
     * extension.  It is "winnt" for workstation or "lanmannt"
     * for server or server upgrade.  It is followed by 256 it
     * is for 256 color devices.
     */
    if (USER_SHARED_DATA->NtProductType == NtProductWinNt) {
        wcsncpycch(lpszWallpaper, L"winnt", 8);
    } else {
        wcsncpycch(lpszWallpaper, L"lanmannt", 8);
    }

    lpszWallpaper[8] = (WCHAR)0;

    if (gpsi->BitsPixel * gpsi->Planes > 4) {
        int iStart = wcslen(lpszWallpaper);
        iStart = min(iStart, 5);

        lpszWallpaper[iStart] = (WCHAR)0;
        wcscat(lpszWallpaper, L"256");
    }
}

/***************************************************************************\
* GetDeskWallpaperName
*
* History:
* 19-Dec-1994 JimA          Created.
* 29-Sep-1995 ChrisWil      ReWrote to return filename.
\***************************************************************************/
#define GDWPN_KEYSIZE   40
#define GDWPN_BITSIZE  256

LPWSTR GetDeskWallpaperName(PUNICODE_STRING pProfileUserName,
        LPWSTR       lpszFile
        )
{
    WCHAR  wszKey[GDWPN_KEYSIZE];
    WCHAR  wszNone[GDWPN_KEYSIZE];
    LPWSTR lpszBitmap = NULL;

    /*
     * Load the none-string.  This will be used for comparisons later.
     */
    ServerLoadString(hModuleWin, STR_NONE, wszNone, ARRAY_SIZE(wszNone));

    if ((lpszFile == NULL)                 ||
        (lpszFile == SETWALLPAPER_DEFAULT) ||
        (lpszFile == SETWALLPAPER_METRICS)) {

        /*
         * Allocate a buffer for the wallpaper.  We will assume
         * a default-size in this case.
         */
        lpszBitmap = UserAllocPool(GDWPN_BITSIZE * sizeof(WCHAR), TAG_SYSTEM);
        if (lpszBitmap == NULL)
            return NULL;

        /*
         * Get the "Wallpaper" string from WIN.INI's [Desktop] section.  The
         * section name is not localized, so hard code it.  If the string
         * returned is Empty, then set it up for a none-wallpaper.
         *
         * Unlike the rest of per user settings that got updated in
         * xxxUpdatePerUserSystemParameters, wallpaper is being updated via a
         * direct call to SystemParametersInfo from UpdatePerUserSystemParameters.
         * Force remote settings check in this case.
         */
        if (!FastGetProfileStringFromIDW(pProfileUserName,
                                         PMAP_DESKTOP,
                                         STR_DTBITMAP,
                                         wszNone,
                                         lpszBitmap,
                                         GDWPN_BITSIZE,
                                         POLICY_REMOTE
                                         )) {
            wcscpy(lpszBitmap, wszNone);
        }

    } else {

        UINT uLen;

        uLen = wcslen(lpszFile) + 1;
        uLen = max(uLen, GDWPN_BITSIZE);

        /*
         * Allocate enough space to store the name passed in.  Returning
         * NULL will allow the wallpaper to redraw.  As well, if we're
         * out of memory, then no need to load a wallpaper anyway.
         */
        lpszBitmap = UserAllocPool(uLen * sizeof(WCHAR), TAG_SYSTEM);
        if (lpszBitmap == NULL)
            return NULL;

        wcscpy(lpszBitmap, lpszFile);
    }

    /*
     * No bitmap if NULL passed in or if (NONE) in win.ini entry.  We
     * return NULL to force the redraw of the wallpaper in the kernel.
     */
    if ((*lpszBitmap == (WCHAR)0) || (_wcsicmp(lpszBitmap, wszNone) == 0)) {
        UserFreePool(lpszBitmap);
        return NULL;
    }

    /*
     * If bitmap name set to (DEFAULT) then set it to the system bitmap.
     */
    ServerLoadString(hModuleWin, STR_DEFAULT, wszKey, ARRAY_SIZE(wszKey));

    if (_wcsicmp(lpszBitmap, wszKey) == 0) {
        GetDefaultWallpaperName(lpszBitmap);
    }


    return lpszBitmap;
}

/***************************************************************************\
* TestVGAColors
*
* Tests whether the log-palette is just a standard 20 palette.
*
* History:
* 29-Sep-1995 ChrisWil  Created.
\***************************************************************************/

BOOL TestVGAColors(
    LPLOGPALETTE ppal)
{
    int      i;
    int      n;
    int      size;
    COLORREF clr;

    static CONST DWORD StupidColors[] = {
         0x00000000,        //   0 Sys Black
         0x00000080,        //   1 Sys Dk Red
         0x00008000,        //   2 Sys Dk Green
         0x00008080,        //   3 Sys Dk Yellow
         0x00800000,        //   4 Sys Dk Blue
         0x00800080,        //   5 Sys Dk Violet
         0x00808000,        //   6 Sys Dk Cyan
         0x00c0c0c0,        //   7 Sys Lt Grey
         0x00808080,        // 248 Sys Lt Gray
         0x000000ff,        // 249 Sys Red
         0x0000ff00,        // 250 Sys Green
         0x0000ffff,        // 251 Sys Yellow
         0x00ff0000,        // 252 Sys Blue
         0x00ff00ff,        // 253 Sys Violet
         0x00ffff00,        // 254 Sys Cyan
         0x00ffffff,        // 255 Sys White

         0x000000BF,        //   1 Sys Dk Red again
         0x0000BF00,        //   2 Sys Dk Green again
         0x0000BFBF,        //   3 Sys Dk Yellow again
         0x00BF0000,        //   4 Sys Dk Blue again
         0x00BF00BF,        //   5 Sys Dk Violet again
         0x00BFBF00,        //   6 Sys Dk Cyan  again

         0x000000C0,        //   1 Sys Dk Red again
         0x0000C000,        //   2 Sys Dk Green again
         0x0000C0C0,        //   3 Sys Dk Yellow again
         0x00C00000,        //   4 Sys Dk Blue again
         0x00C000C0,        //   5 Sys Dk Violet again
         0x00C0C000,        //   6 Sys Dk Cyan  again
    };

    size = (sizeof(StupidColors) / sizeof(StupidColors[0]));

    for (i = 0; i < (int)ppal->palNumEntries; i++) {

        clr = ((LPDWORD)ppal->palPalEntry)[i];

        for (n = 0; n < size; n++) {

            if (StupidColors[n] == clr)
                break;
        }

        if (n == size)
            return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* DoHTColorAdjustment
*
* The default HT-Gamma adjustment was 2.0 on 3.5 (internal to gdi).  For
* 3.51 this value was decreased to 1.0 to accomdate printing.  For our
* desktop-wallpaper we are going to darken it slightly to that the image
* doesn't appear to light.  For the Shell-Release we will provid a UI to
* allow users to change this for themselves.
*
*
* History:
* 11-May-1995 ChrisWil  Created.
\***************************************************************************/

#define FIXED_GAMMA (WORD)13000

VOID DoHTColorAdjust(
    HDC hdc)
{
    COLORADJUSTMENT ca;

    if (GreGetColorAdjustment(hdc, &ca)) {

        ca.caRedGamma   =
        ca.caGreenGamma =
        ca.caBlueGamma  = FIXED_GAMMA;

        GreSetColorAdjustment(hdc, &ca);
    }
}

/***************************************************************************\
* ConvertToDDB
*
* Converts a DIBSection to a DDB.  We do this to speed up drawings so that
* bitmap-colors don't have to go through a palette-translation match.  This
* will also stretch/expand the image if the syle is set.
*
* If the new image requires a halftone-palette, the we will create one and
* set it as the new wallpaper-palette.
*
* History:
* 26-Oct-1995 ChrisWil  Ported.
* 30-Oct-1995 ChrisWil  Added halftoning.  Rewote the stretch/expand stuff.
\***************************************************************************/

HBITMAP ConvertToDDB(
    HDC      hdc,
    HBITMAP  hbmOld,
    HPALETTE hpal)
{
    BITMAP  bm;
    HBITMAP hbmNew;

    /*
     * This object must be a REALDIB type bitmap.
     */
    GreExtGetObjectW(hbmOld, sizeof(bm), &bm);

    /*
     * Create the new wallpaper-surface.
     */
    if (hbmNew = GreCreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight)) {

        HPALETTE hpalDst;
        HPALETTE hpalSrc;
        HBITMAP  hbmDst;
        HBITMAP  hbmSrc;
        UINT     bpp;
        BOOL     fHalftone = FALSE;

        /*
         * Select in the surfaces.
         */
        hbmDst = GreSelectBitmap(ghdcMem2, hbmNew);
        hbmSrc = GreSelectBitmap(ghdcMem, hbmOld);

        /*
         * Determine image bits/pixel.
         */
        bpp = (bm.bmPlanes * bm.bmBitsPixel);

        /*
         * Use the palette if given.  If the image is of a greater
         * resolution than the device, then we're going to go through
         * a halftone-palette to get better colors.
         */
        if (hpal) {

            hpalDst = _SelectPalette(ghdcMem2, hpal, FALSE);
            hpalSrc = _SelectPalette(ghdcMem, hpal, FALSE);

            xxxRealizePalette(ghdcMem2);

            /*
             * Set the halftoning for the destination.  This is done
             * for images of greater resolution than the device.
             */
            if (bpp > gpsi->BitCount) {
                fHalftone = TRUE;
                DoHTColorAdjust(ghdcMem2);
            }
        }

        /*
         * Set the stretchbltmode.  This is more necessary when doing
         * halftoning.  Since otherwise, the colors won't translate
         * correctly.
         */
        SetBestStretchMode(ghdcMem2, bpp, fHalftone);

        /*
         * Set the new surface bits.  Use StretchBlt() so the SBMode
         * will be used in color-translation.
         */
        GreStretchBlt(ghdcMem2,
                      0,
                      0,
                      bm.bmWidth,
                      bm.bmHeight,
                      ghdcMem,
                      0,
                      0,
                      bm.bmWidth,
                      bm.bmHeight,
                      SRCCOPY,
                      0);

        /*
         * Restore palettes.
         */
        if (hpal) {
            _SelectPalette(ghdcMem2, hpalDst, FALSE);
            _SelectPalette(ghdcMem, hpalSrc, FALSE);
        }

        /*
         * Restore the surfaces.
         */
        GreSelectBitmap(ghdcMem2, hbmDst);
        GreSelectBitmap(ghdcMem, hbmSrc);
        GreDeleteObject(hbmOld);

        GreSetBitmapOwner(hbmNew, OBJECT_OWNER_PUBLIC);

    } else {
        hbmNew = hbmOld;
    }

    return hbmNew;
}

/***************************************************************************\
* CreatePaletteFromBitmap
*
* Take in a REAL dib handle and create a palette from it.  This will not
* work for bitmaps created by any other means than CreateDIBSection or
* CreateDIBitmap(CBM_CREATEDIB).  This is due to the fact that these are
* the only two formats who have palettes stored with their object.
*
* History:
* 29-Sep-1995 ChrisWil  Created.
\***************************************************************************/

HPALETTE CreatePaletteFromBitmap(
    HBITMAP hbm)
{
    HPALETTE     hpal;
    LPLOGPALETTE ppal;
    HBITMAP      hbmT;
    DWORD        size;
    int          i;

    /*
     * Make room for temp logical palette of max size.
     */
    size = sizeof(LOGPALETTE) + (MAXPAL * sizeof(PALETTEENTRY));

    ppal = (LPLOGPALETTE)UserAllocPool(size, TAG_SYSTEM);
    if (!ppal)
        return NULL;

    /*
     * Retrieve the palette from the DIB(Section).  The method of calling
     * GreGetDIBColorTable() can only be done on sections or REAL-Dibs.
     */
    hbmT = GreSelectBitmap(ghdcMem, hbm);
    ppal->palVersion    = 0x300;
    ppal->palNumEntries = (WORD)GreGetDIBColorTable(ghdcMem,
                                              0,
                                              MAXPAL,
                                              (LPRGBQUAD)ppal->palPalEntry);
    GreSelectBitmap(ghdcMem, hbmT);

    /*
     * Create a halftone-palette if their are no entries.  Otherwise,
     * swap the RGB values to be palentry-compatible and create us a
     * palette.
     */
    if (ppal->palNumEntries == 0) {
        hpal = GreCreateHalftonePalette(gpDispInfo->hdcScreen);
    } else {

        BYTE tmpR;

        /*
         * Swap red/blue because a RGBQUAD and PALETTEENTRY dont get along.
         */
        for (i=0; i < (int)ppal->palNumEntries; i++) {
            tmpR                         = ppal->palPalEntry[i].peRed;
            ppal->palPalEntry[i].peRed   = ppal->palPalEntry[i].peBlue;
            ppal->palPalEntry[i].peBlue  = tmpR;
            ppal->palPalEntry[i].peFlags = 0;
        }

        /*
         * If the Bitmap only has VGA colors in it we dont want to
         * use a palette.  It just causes unessesary palette flashes.
         */
        hpal = TestVGAColors(ppal) ? NULL : GreCreatePalette(ppal);
    }

    UserFreePool(ppal);

    /*
     * Make this palette public.
     */
    if (hpal)
        GreSetPaletteOwner(hpal, OBJECT_OWNER_PUBLIC);

    return hpal;
}

/***************************************************************************\
* TileWallpaper
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/

BOOL
TileWallpaper(HDC hdc, LPCRECT lprc, BOOL fOffset)
{
    int     xO;
    int     yO;
    int     x;
    int     y;
    BITMAP  bm;
    HBITMAP hbmT = NULL;
    POINT   ptOffset;

    if (fOffset) {
        ptOffset.x = gsrcWallpaper.x;
        ptOffset.y = gsrcWallpaper.y;
    } else {
        ptOffset.x = 0;
        ptOffset.y = 0;
    }

    /*
     * We need to get the dimensions of the bitmap here rather than rely on
     * the dimensions in srcWallpaper because this function may
     * be called as part of ExpandBitmap, before srcWallpaper is
     * set.
     */
    if (GreExtGetObjectW(ghbmWallpaper, sizeof(BITMAP), (PBITMAP)&bm)) {
        xO = lprc->left - (lprc->left % bm.bmWidth) + (ptOffset.x % bm.bmWidth);
        if (xO > lprc->left) {
            xO -= bm.bmWidth;
        }

        yO = lprc->top - (lprc->top % bm.bmHeight) + (ptOffset.y % bm.bmHeight);
        if (yO > lprc->top) {
            yO -= bm.bmHeight;
        }

        /*
         *  Tile the bitmap to the surface.
         */
        if (hbmT = GreSelectBitmap(ghdcMem, ghbmWallpaper)) {
            for (y = yO; y < lprc->bottom; y += bm.bmHeight) {
                for (x = xO; x < lprc->right; x += bm.bmWidth) {
                    GreBitBlt(hdc,
                              x,
                              y,
                              bm.bmWidth,
                              bm.bmHeight,
                              ghdcMem,
                              0,
                              0,
                              SRCCOPY,
                              0);
                }
            }

            GreSelectBitmap(ghdcMem, hbmT);
        }
    }

    return (hbmT != NULL);
}

/***************************************************************************\
* GetWallpaperCenterRect
*
* Returns the rect of centered wallpaper on a particular monitor.
*
* History:
* 26-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
GetWallpaperCenterRect(LPRECT lprc, LPPOINT lppt, LPCRECT lprcMonitor)
{
    RECT rc;


    if (gsrcWallpaper.x != 0 || gsrcWallpaper.y != 0) {
        rc.left = lprcMonitor->left + gsrcWallpaper.x;
        rc.top = lprcMonitor->top + gsrcWallpaper.y;
    } else {
        rc.left = (lprcMonitor->left + lprcMonitor->right - gsrcWallpaper.cx) / 2;
        rc.top = (lprcMonitor->top + lprcMonitor->bottom - gsrcWallpaper.cy) / 2;
    }

    rc.right  = rc.left + gsrcWallpaper.cx;
    rc.bottom = rc.top + gsrcWallpaper.cy;

    lppt->x = max(0, lprcMonitor->left - rc.left);
    lppt->y = max(0, lprcMonitor->top - rc.top);

    return IntersectRect(lprc, &rc, lprcMonitor);
}



/***************************************************************************\
* CenterOrStretchWallpaper
*
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/

BOOL
CenterOrStretchWallpaper(HDC hdc, LPCRECT lprcMonitor)
{
    BOOL    fStretchToEachMonitor = FALSE;
    RECT    rc;
    HBITMAP hbmT;
    BOOL    f = FALSE;
    HRGN    hrgn;
    POINT   pt;
    BITMAP  bm;
    int     oldStretchMode;

    /*
     * This used to call TileWallpaper, but this really slowed up the system
     * for small dimension bitmaps. We really only need to blt it once for
     * centered bitmaps.
     */
    if (hbmT = GreSelectBitmap(ghdcMem, ghbmWallpaper)) {
        if (fStretchToEachMonitor && (gwWPStyle & DTF_STRETCH)) {
            if (GreExtGetObjectW(ghbmWallpaper, sizeof(BITMAP), (PBITMAP)&bm)) {
                oldStretchMode = GreSetStretchBltMode(hdc, COLORONCOLOR);
                f = GreStretchBlt(hdc,
                                  lprcMonitor->left,
                                  lprcMonitor->top,
                                  lprcMonitor->right - lprcMonitor->left,
                                  lprcMonitor->bottom - lprcMonitor->top,
                                  ghdcMem,
                                  0,
                                  0,
                                  bm.bmWidth,
                                  bm.bmHeight,
                                  SRCCOPY,
                                  0);
                GreSetStretchBltMode(hdc, oldStretchMode);
            }
        } else {
            if (GetWallpaperCenterRect(&rc, &pt, lprcMonitor)) {
                f = GreBitBlt(hdc,
                              rc.left,
                              rc.top,
                              rc.right - rc.left,
                              rc.bottom - rc.top,
                              ghdcMem,
                              pt.x,
                              pt.y,
                              SRCCOPY,
                              0);

                /*
                 * Fill the bacground (excluding the bitmap) with the desktop
                 * brush.  Save the DC with the cliprect.
                 */
                if (f && NULL != (hrgn = CreateEmptyRgn())) {
                    if (GreGetRandomRgn(hdc, hrgn, 1) != -1) {
                        GreExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
                        FillRect(hdc, lprcMonitor, SYSHBR(DESKTOP));
                        GreExtSelectClipRgn(hdc, hrgn, RGN_COPY);
                    }

                    GreDeleteObject(hrgn);
                }
            }
        }

        GreSelectBitmap(ghdcMem, hbmT);
    }

    /*
     *  As a last-ditch effort, if something failed, just clear the desktop.
     */
    if (!f) {
        FillRect(hdc, lprcMonitor, SYSHBR(DESKTOP));
    }

    return f;
}

/***************************************************************************\
* xxxDrawWallpaper
*
* Performs the drawing of the wallpaper.  This can be either tiled or
* centered.  This routine provides the common things like palette-handling.
* If the (fPaint) is false, then we only to palette realization and no
* drawing.
*
* History:
* 01-Oct-1995 ChrisWil  Ported.
\***************************************************************************/

BOOL xxxDrawWallpaper(
    PWND        pwnd,
    HDC         hdc,
    PMONITOR    pMonitorPaint,
    LPCRECT     lprc)
{
    BOOL        f;
    HPALETTE    hpalT;
    int         i;

    CheckLock(pwnd);
    CheckLock(pMonitorPaint);
    UserAssert(ghbmWallpaper != NULL);
    UserAssert(lprc);

    /*
     * Select in the palette if one exists.  As a wallpaper, we should only
     * be able to do background-realizations.
     */
    if (ghpalWallpaper && pMonitorPaint->dwMONFlags & MONF_PALETTEDISPLAY) {
        hpalT = _SelectPalette(hdc, ghpalWallpaper, FALSE);
        i = xxxRealizePalette(hdc);
    } else {
        hpalT = NULL;
    }

    if (gwWPStyle & DTF_TILE) {
        f = TileWallpaper(hdc, lprc, pwnd != NULL);
    } else {
        f = CenterOrStretchWallpaper(hdc, &pMonitorPaint->rcMonitor);
    }

    if (hpalT) {
        _SelectPalette(hdc, hpalT, FALSE);
    }

    return f;
}

/***************************************************************************\
* xxxExpandBitmap
*
* Expand this bitmap to fit the screen.  This is used for tiled images
* only.
*
* History:
* 29-Sep-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

HBITMAP xxxExpandBitmap(
    HBITMAP hbm)
{
    int         nx;
    int         ny;
    BITMAP      bm;
    HBITMAP     hbmNew;
    HBITMAP     hbmD;
    LPRECT      lprc;
    RECT        rc;
    PMONITOR    pMonitor;
    TL          tlpMonitor;


    /*
     * Get the dimensions of the screen and bitmap we'll be dealing with.
     * We'll adjust the xScreen/yScreen to reflect the new surface size.
     * The default adjustment is to stretch the image to fit the screen.
     */
    GreExtGetObjectW(hbm, sizeof(bm), (PBITMAP)&bm);

    pMonitor = GetPrimaryMonitor();
    lprc = &pMonitor->rcMonitor;
    nx = (lprc->right / TILE_XMINSIZE) / bm.bmWidth;
    ny = (lprc->bottom / TILE_YMINSIZE) / bm.bmHeight;

    if (nx == 0)
        nx++;

    if (ny == 0)
        ny++;

    if ((nx + ny) <= 2)
        return hbm;


    /*
     * Create the surface for the new-bitmap.
     */
    rc.left = rc.top = 0;
    rc.right = nx * bm.bmWidth;
    rc.bottom = ny * bm.bmHeight;
    hbmD = GreSelectBitmap(ghdcMem, hbm);
    hbmNew = GreCreateCompatibleBitmap(ghdcMem, rc.right, rc.bottom);
    GreSelectBitmap(ghdcMem, hbmD);

    if (hbmNew == NULL)
        return hbm;

    if (hbmD = GreSelectBitmap(ghdcMem2, hbmNew)) {
        /*
         * Expand the bitmap to the new surface.
         */
        ThreadLockAlways(pMonitor, &tlpMonitor);
        xxxDrawWallpaper(NULL, ghdcMem2, pMonitor, &rc);
        ThreadUnlock(&tlpMonitor);
        GreSelectBitmap(ghdcMem2, hbmD);
    }

    GreDeleteObject(hbm);

    GreSetBitmapOwner(hbmNew, OBJECT_OWNER_PUBLIC);

    return hbmNew;
}

/***************************************************************************\
* xxxLoadDesktopWallpaper
*
* Load the dib (section) from the client-side.  We make this callback to
* utilize code in USER32 for loading/creating a dib or section.  Since,
* the wallpaper-code can be called from any-process, we can't use DIBSECTIONS
* for a wallpaper.  Luckily we can use Real-DIBs for this.  That way we
* can extract out a palette from the bitmap.  We couldn't do this if the
* bitmap was created "compatible".
*
* History:
* 29-Sep-1995 ChrisWil  Created.
\***************************************************************************/

BOOL xxxLoadDesktopWallpaper(
    LPWSTR lpszFile)
{
    UINT           LR_flags;
    int            dxDesired;
    int            dyDesired;
    UNICODE_STRING strName;


    /*
     * If the bitmap is somewhat large (big bpp), then we'll deal
     * with it as a real-dib.  We'll also do this for 8bpp since it
     * can utilize a palette.  Chicago uses DIBSECTIONS since it can
     * count on the one-process handling the drawing.  Since, NT can
     * have different processes doing the drawing, we can't use sections.
     */
    LR_flags = LR_LOADFROMFILE;

    if (gpDispInfo->fAnyPalette || gpsi->BitCount >= 8) {
        LR_flags |= LR_CREATEREALDIB;
    }

    /*
     * If we are going to be stretching the bitmap, go ahead and pre-stretch
     * the bitmap to the size of the primary monitor.  This makes blitting
     * to the primary monitor quicker (because it doesn't have to stretch),
     * while other monitors will be a little slower.
     */
    if (gwWPStyle & DTF_STRETCH) {
        PMONITOR pMonitor = GetPrimaryMonitor();
        dxDesired = pMonitor->rcMonitor.right - pMonitor->rcMonitor.left;
        dyDesired = pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top;
    } else {
        dxDesired = dyDesired = 0;
    }

    /*
     * Make a callback to the client to perform the loading.
     * Saves us some code.
     */
    RtlInitUnicodeString(&strName, lpszFile);

    ghbmWallpaper = xxxClientLoadImage(
            &strName,
            0,
            IMAGE_BITMAP,
            dxDesired,
            dyDesired,
            LR_flags,
            TRUE);

    if (ghbmWallpaper == NULL)
        return FALSE;

    /*
     * If it's a palette-display, then we will derive the global
     * wallpaper palette from the bitmap.
     */
    if (gpDispInfo->fAnyPalette) {
        ghpalWallpaper = CreatePaletteFromBitmap(ghbmWallpaper);
    }

    /*
     * Always try to convert the bitmap to a DDB.  On single monitor
     * systems this will improve performance.  On multiple-monitor
     * systems, GDI will refuse to create the DDB and just leave it
     * as a DIB at the color format of the primary monitor.
     */
    ghbmWallpaper = ConvertToDDB(gpDispInfo->hdcScreen, ghbmWallpaper, ghpalWallpaper);

    /*
     * Mark the bitmap as public, so any process can party with it.
     */
    GreSetBitmapOwner(ghbmWallpaper, OBJECT_OWNER_PUBLIC);

    /*
     * Expand bitmap if we are going to tile it. This creates a larger
     * bitmap that contains an even multiple of the source bitmap.  This
     * larger bitmap can then be tiled more quickly than the smaller bitmap.
     */
    if (gwWPStyle & DTF_TILE) {
        ghbmWallpaper = xxxExpandBitmap(ghbmWallpaper);
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetDeskWallpaper
*
* Sets the desktop-wallpaper.  This deletes the old handles in the process.
*
* History:
* 29-Jul-1991 MikeKe    From win31.
* 01-Oct-1995 ChrisWil  Rewrote for LoadImage().
\***************************************************************************/

BOOL xxxSetDeskWallpaper(PUNICODE_STRING pProfileUserName,
    LPWSTR lpszFile)
{
    BITMAP       bm;
    UINT         WallpaperStyle2;
    PWND         pwndShell;
    TL           tl;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOP     pdesk;
    BOOL         fRet = FALSE;
    HBITMAP      hbmOld;

    PROFINTINFO  apsi[] = {
        {PMAP_DESKTOP, (LPWSTR)STR_TILEWALL , 0, &gwWPStyle    },
        {PMAP_DESKTOP, (LPWSTR)STR_DTSTYLE  , 0, &WallpaperStyle2   },
        {PMAP_DESKTOP, (LPWSTR)STR_DTORIGINX, 0, &gsrcWallpaper.x },
        {PMAP_DESKTOP, (LPWSTR)STR_DTORIGINY, 0, &gsrcWallpaper.y },
        {0,            NULL,                  0, NULL               }
    };

    pdesk = ptiCurrent->rpdesk;
    hbmOld = ghbmWallpaper;

    if ((lpszFile == SETWALLPAPER_METRICS) && !(gwWPStyle & DTF_STRETCH)) {

        gsrcWallpaper.x = 0;
        gsrcWallpaper.y = 0;

        if (ghbmWallpaper)
            goto CreateNewWallpaper;

        goto Metric_Change;
    }

CreateNewWallpaper:

    /*
     * Delete the old wallpaper and palette if the exist.
     */
    if (ghpalWallpaper) {
        GreDeleteObject(ghpalWallpaper);
        ghpalWallpaper = NULL;
    }

    if (ghbmWallpaper) {
        GreDeleteObject(ghbmWallpaper);
        ghbmWallpaper = NULL;
    }

    /*
     * Kill any SPBs no matter what. This works if we're switching from/to
     * palettized wallpaper. Fixes a lot of problems because palette doesn't
     * change, shell paints funny on desktop, etc.
     */
    BEGINATOMICCHECK();
    FreeAllSpbs();
    ENDATOMICCHECK();

    /*
     * If this is a metric-change (and stretched), then we need to
     * reload it.  However, since we are called from the winlogon process
     * during a desktop-switch, we would be mapped to the wrong Luid
     * when we attempt to grab the name from GetDeskWallpaperName.  This
     * would use the Luid from the DEFAULT user rather than the current
     * logged on user.  In order to avoid this, we cache the wallpaer
     * name so that on METRIC-CHANGES we use the current-user's wallpaper.
     *
     * NOTE: we assume that prior to any METRIC change, we have already
     * setup the ghbmWallpaper and lpszCached.  This is usually done
     * either on logon or during user desktop-changes through conrol-Panel.
     */
    if (lpszFile == SETWALLPAPER_METRICS) {

        UserAssert(gpszWall != NULL);

        goto LoadWallpaper;
    }

    /*
     * Free the cached handle.
     */
    if (gpszWall) {
        UserFreePool(gpszWall);
        gpszWall = NULL;
    }

    /*
     * Load the wallpaper-name.  If this returns FALSE, then
     * the user specified (None).  We will return true to force
     * the repainting of the desktop.
     */
    gpszWall = GetDeskWallpaperName(pProfileUserName,lpszFile);
    if (!gpszWall) {
        fRet = TRUE;
        goto SDW_Exit;
    }

    /*
     * Retrieve the default settings from the registry.
     *
     * If tile is indicated, then normalize style to not include
     * FIT/STRETCH which are center-only styles.  Likewise, if
     * we are centered, then normalize out the TILE bit.
     */
    FastGetProfileIntsW(pProfileUserName, apsi, 0);

    gwWPStyle &= DTF_TILE;
    if (!(gwWPStyle & DTF_TILE)) {
        gwWPStyle = WallpaperStyle2 & DTF_STRETCH;
    }

    /*
     * Load the wallpaper.  This makes a callback to the client to
     * perform the bitmap-creation.
     */

LoadWallpaper:

    if (xxxLoadDesktopWallpaper(gpszWall) == FALSE) {
        gwWPStyle = 0;
        goto SDW_Exit;
    }

    /*
     * If we have a palette, then we need to do the correct realization and
     * notification.
     */
    if (ghpalWallpaper != NULL) {
        PWND pwndSend;

        /*
         * Get the shell window. This could be NULL on system
         * initialization. We will use this to do palette realization.
         */
        pwndShell = _GetShellWindow(pdesk);
        if (pwndShell) {
            pwndSend = pwndShell;
        } else {
            pwndSend = (pdesk ? pdesk->pDeskInfo->spwnd : NULL);
        }

        /*
         * Update the desktop with the new bitmap.  This cleans
         * out the system-palette so colors can be realized.
         */
        GreRealizeDefaultPalette(gpDispInfo->hdcScreen, TRUE);

        /*
         * Don't broadcast if system initialization is occuring. Otherwise
         * this gives the shell first crack at realizing its colors
         * correctly.
         */
        if (pwndSend) {
            HWND hwnd = HW(pwndSend);

            ThreadLockAlways(pwndSend, &tl);
            xxxSendNotifyMessage(pwndSend, WM_PALETTECHANGED, (WPARAM)hwnd, 0);
            ThreadUnlock(&tl);
        }
    }

Metric_Change:
    if (fRet = GreExtGetObjectW(ghbmWallpaper, sizeof(bm), (PBITMAP)&bm)) {
        gsrcWallpaper.cx = bm.bmWidth;
        gsrcWallpaper.cy = bm.bmHeight;
    }

SDW_Exit:

    /*
     * Notify the shell-window that the wallpaper changed. We need to refresh
     * our local pwndShell here because we might have called-back above.
     */
    pwndShell = _GetShellWindow(pdesk);
    if ((pwndShell != NULL) &&
        ((hbmOld && !ghbmWallpaper) || (!hbmOld && ghbmWallpaper))) {

        ThreadLockAlways(pwndShell, &tl);
        xxxSendNotifyMessage(pwndShell,
                             WM_SHELLNOTIFY,
                             SHELLNOTIFY_WALLPAPERCHANGED,
                             (LPARAM)ghbmWallpaper);
        ThreadUnlock(&tl);
    }

    return fRet;
}


/***************************************************************************\
* DesktopBuildPaint
*
* Draw the build information onto the desktop
*
* History:
* 2/4/99    joejo - Bug 280256
\***************************************************************************/
void DesktopBuildPaint(
    HDC         hdc,
    PMONITOR    pMonitor)
{
    int         imode;
    COLORREF    oldColor;
    RECT        rcText = {0,0,0,0};
    RECT        rcBuildInfo = {0,0,0,0};
    HFONT       oldFont = GreGetHFONT(hdc);
    SIZE sizeText;
    SIZE sizeProductName;
    SIZE sizeProductBuild;
    SIZE sizeSystemRoot;
    BOOL fDrawSolidBackground = FALSE;
    int cBorder = 5;
    int cMargin = fDrawSolidBackground ? 5 : 0;

    /*
     * Set up DC
     */
    imode = GreSetBkMode(hdc, TRANSPARENT);

    if (fDrawSolidBackground) {
        /*
         * Since we are going to draw our own background, we can always set
         * the pen color to black.
         */
        oldColor = GreSetTextColor( hdc, RGB(0,0,0) );
    } else {
        /*
         * Since we are not going to draw our own background, we have to work
         * with whatever is already there.  This is an ugly hack to try and
         * cover the case where our white text won't show up on a white
         * background.  Of course, this doesn't catch the bitmap case.  Or
         * the almost white case.
         */
        if (GreGetBrushColor(SYSHBR(BACKGROUND)) != 0x00ffffff) {
            oldColor = GreSetTextColor( hdc, RGB(255,255,255) );
        } else {
            oldColor = GreSetTextColor( hdc, RGB(0,0,0) );
        }
    }

    /*
     * Get the width in pixels of the longest string we are going to print out.
     */
    if (gpsi && gpsi->hCaptionFont) {
        GreSelectFont(hdc, gpsi->hCaptionFont);
    }

    GreGetTextExtentW(
        hdc,
        wszProductName,
        wcslen(wszProductName),
        &sizeProductName,
        GGTE_WIN3_EXTENT);

    if (ghMenuFont != NULL ) {
        GreSelectFont(hdc, ghMenuFont);
    }

    GreGetTextExtentW(
        hdc,
        wszProductBuild,
        wcslen(wszProductBuild),
        &sizeProductBuild,
        GGTE_WIN3_EXTENT);

    if (gDrawVersionAlways) {
        GreGetTextExtentW(
            hdc,
            USER_SHARED_DATA->NtSystemRoot,
            wcslen(USER_SHARED_DATA->NtSystemRoot),
            &sizeSystemRoot,
            GGTE_WIN3_EXTENT);
    } else {
        sizeSystemRoot.cx = 0;
        sizeSystemRoot.cy = 0;
    }

    sizeText.cx = sizeProductName.cx >= sizeProductBuild.cx ? sizeProductName.cx : sizeProductBuild.cx;
    sizeText.cy = sizeProductName.cy + sizeProductBuild.cy;
    if (gDrawVersionAlways) {
        sizeText.cx = (sizeText.cx >= sizeSystemRoot.cx) ? sizeText.cx : sizeSystemRoot.cx;
        sizeText.cy += sizeSystemRoot.cy;
    }

    /*
     * Calculate the position for all of the build info on the desktop.
     * We will draw either 2 or 3 lines of text.
     */
    rcBuildInfo.left = pMonitor->rcWork.right - cBorder - cMargin - sizeText.cx - cMargin;
    rcBuildInfo.top = pMonitor->rcWork.bottom - cBorder - cMargin - sizeText.cy - cMargin;
    rcBuildInfo.right = pMonitor->rcWork.right - cBorder;
    rcBuildInfo.bottom = pMonitor->rcWork.bottom - cBorder;

    /*
     * Draw the background if we want it.
     *
     */
    if (fDrawSolidBackground) {
        NtGdiRoundRect(hdc,  rcBuildInfo.left, rcBuildInfo.top, rcBuildInfo.right, rcBuildInfo.bottom, 10, 10);
    }

    /*
     * Print Windows 2000 name
     */
    if (gpsi && gpsi->hCaptionFont) {
        GreSelectFont(hdc, gpsi->hCaptionFont);
    }

    rcText.left = rcBuildInfo.left + cMargin;
    rcText.top = rcBuildInfo.top + cMargin;
    rcText.right = rcText.left + sizeText.cx;
    rcText.bottom = rcText.top + sizeProductName.cy;

    GreSetTextAlign(hdc, TA_RIGHT | TA_BOTTOM);

    GreExtTextOutW(
        hdc,
        rcText.right,
        rcText.bottom,
        0,
        &rcText,
        wszProductName,
        wcslen(wszProductName),
        (LPINT)NULL
        );

    /*
     * Print Build Number
     */
    if (ghMenuFont != NULL ) {
        GreSelectFont(hdc, ghMenuFont);
    }

    rcText.top = rcText.bottom + 1;
    rcText.bottom = rcText.top + sizeProductBuild.cy;

    GreExtTextOutW(
        hdc,
        rcText.right,
        rcText.bottom,
        0,
        &rcText,
        wszProductBuild,
        wcslen(wszProductBuild),
        (LPINT)NULL
        );

    /*
     * If we are in CHK mode, draw the System Dir Path
     */
    if (gDrawVersionAlways) {
        rcText.top = rcText.bottom + 1;
        rcText.bottom = rcText.top + sizeSystemRoot.cy;

        GreExtTextOutW(
            hdc,
            rcText.right,
            rcText.bottom,
            0,
            &rcText,
            USER_SHARED_DATA->NtSystemRoot,
            wcslen(USER_SHARED_DATA->NtSystemRoot),
            (LPINT)NULL
            );
    }

    if (oldFont) {
        GreSelectFont(hdc, oldFont);
    }

    GreSetBkMode(hdc, imode);
    GreSetTextColor(hdc, oldColor);
}

/***************************************************************************\
* xxxDesktopPaintCallback
*
* Draw the wallpaper or fill with the background brush. In debug,
* also draw the build number on the top of each monitor.
*
* History:
* 20-Sep-1996 adams     Created.
\***************************************************************************/
BOOL
xxxDesktopPaintCallback(
    PMONITOR        pMonitor,
    HDC             hdc,
    LPRECT          lprcMonitorClip,
    LPARAM          dwData)
{
    BOOL            f;
    PWND            pwnd;

    CheckLock(pMonitor);

    pwnd = (PWND)dwData;


    if (SYSMET(CLEANBOOT)) {
        FillRect(hdc, lprcMonitorClip, ghbrBlack );
        f = TRUE;
    } else {
        /*
         * if this is the disconnected desktop, skip the bitmap paint
         */
        if (gbDesktopLocked) {
            f = FALSE;
        } else {

            /*
             * Paint the desktop with a color or the wallpaper.
             */
            if (ghbmWallpaper) {
                f = xxxDrawWallpaper(
                        pwnd,
                        hdc,
                        pMonitor,
                        lprcMonitorClip);
            } else {
                FillRect(hdc, lprcMonitorClip, SYSHBR(DESKTOP));
                f = TRUE;
            }
        }
    }

    if (SYSMET(CLEANBOOT)
            || gDrawVersionAlways
            || gdwCanPaintDesktop) {
        static BOOL fInit = TRUE;
        SIZE        size;
        int         imode;
        COLORREF    oldColor;
        HFONT       oldFont = NULL;


        /*
         * Grab the stuff from the registry
         */
        if (fInit) {
            if (SYSMET(CLEANBOOT)) {
                ServerLoadString( hModuleWin, STR_SAFEMODE, SafeModeStr, ARRAY_SIZE(SafeModeStr) );
                SafeModeStrLen = wcslen(SafeModeStr);
            }
            GetVersionInfo(SYSMET(CLEANBOOT) == 0);
            fInit = FALSE;
        }

        if (SYSMET(CLEANBOOT)) {
            if (gpsi != NULL && gpsi->hCaptionFont != NULL) {
                oldFont = GreSelectFont(hdc, gpsi->hCaptionFont);
            }

            GreGetTextExtentW(hdc, wszSafeMode, wcslen(wszSafeMode), &size, GGTE_WIN3_EXTENT);
            imode = GreSetBkMode(hdc, TRANSPARENT);

            oldColor = GreSetTextColor( hdc, RGB(255,255,255) );

            GreExtTextOutW(
                hdc,
                (pMonitor->rcWork.left + pMonitor->rcWork.right - size.cx) / 2,
                pMonitor->rcWork.top,
                0,
                (LPRECT)NULL,
                wszSafeMode,
                wcslen(wszSafeMode),
                (LPINT)NULL
                );

            GreGetTextExtentW(hdc, SafeModeStr, SafeModeStrLen, &size, GGTE_WIN3_EXTENT);

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.left,
                pMonitor->rcWork.top,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.right - size.cx,
                pMonitor->rcWork.top,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.right - size.cx,
                pMonitor->rcWork.bottom - gpsi->tmSysFont.tmHeight,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.left,
                pMonitor->rcWork.bottom - gpsi->tmSysFont.tmHeight,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreSetBkMode(hdc, imode);
            GreSetTextColor(hdc, oldColor);

            if (oldFont) {
                GreSelectFont(hdc, oldFont);
            }
        } else {
            if (!gbRemoteSession || !gdwTSExcludeDesktopVersion) {
                DesktopBuildPaint(hdc, pMonitor);
            }
        }
    }

    return f;
}



/***************************************************************************\
* xxxInvalidateDesktopOnPaletteChange
*
* Invalidates the shell window and uncovered areas of the desktop
* when the palette changes.
*
* History:
* 28-Apr-1997 adams     Created.
\***************************************************************************/
VOID
xxxInvalidateDesktopOnPaletteChange(
    PWND pwnd)
{
    PDESKTOP    pdesk;
    PWND        pwndShell;
    TL          tlpwndShell;
    RECT        rc;
    BOOL        fRedrawDesktop;

    CheckLock(pwnd);

    /*
     * Invalidate the shell window.
     */
    pdesk = PtiCurrent()->rpdesk;
    pwndShell = _GetShellWindow(pdesk);
    if (!pwndShell) {
        fRedrawDesktop = TRUE;
        rc = gpsi->rcScreen;
    } else {
        ThreadLockAlways(pwndShell, &tlpwndShell);
        xxxRedrawWindow(
                pwndShell,
                NULL,
                NULL,
                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);

        /*
         * The shell window may not cover all of the desktop.
         * Invalidate the part of the desktop wallpaper it
         * doesn't sit over.
         */
        fRedrawDesktop = SubtractRect(&rc, &pwnd->rcWindow, &pwndShell->rcWindow);
        ThreadUnlock(&tlpwndShell);
    }

    /*
     * Invalidate the desktop window.
     */
    if (fRedrawDesktop) {
        xxxRedrawWindow(
                pwnd,
                &rc,
                NULL,
                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
    }
}

/***************************************************************************\
* xxxInternalPaintDesktop
*
* If fPaint is TRUE, enumerate the monitors to paint the desktop.
* Otherwise, it selects the bitmap palette into the DC to select
* its colors into the hardware palette.
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/
BOOL xxxInternalPaintDesktop(
    PWND    pwnd,
    HDC     hdc,
    BOOL    fPaint)
{
    BOOL fRet = FALSE;

    CheckLock(pwnd);

    if (fPaint) {
        RECT rcOrg, rcT;
        POINT pt;

        /*
         * For compatiblity purposes the DC origin of desktop windows
         * is set to the primary monitor, i.e. (0,0). Since we may get
         * either desktop or non-desktop DCs here, temporarily reset
         * the hdc origin to (0,0).
         */
        GreGetDCOrgEx(hdc, &pt, &rcOrg);
        CopyRect(&rcT, &rcOrg);
        OffsetRect(&rcT, -rcT.left, -rcT.top);
        GreSetDCOrg(hdc, rcT.left, rcT.top, (PRECTL)&rcT);

        fRet = xxxEnumDisplayMonitors(
                hdc,
                NULL,
                (MONITORENUMPROC) xxxDesktopPaintCallback,
                (LPARAM)pwnd,
                TRUE);

        /*
         * Reset the DC origin back.
         */
        GreSetDCOrg(hdc, rcOrg.left, rcOrg.top, (PRECTL)&rcOrg);

    } else if (ghpalWallpaper &&
               GetPrimaryMonitor()->dwMONFlags & MONF_PALETTEDISPLAY) {
        /*
         * Select in the palette if one exists.
         */
        HPALETTE    hpalT;
        int         i;

        hpalT = _SelectPalette(hdc, ghpalWallpaper, FALSE);
        i = xxxRealizePalette(hdc);
        _SelectPalette(hdc, hpalT, FALSE);

        if (i > 0) {
            xxxInvalidateDesktopOnPaletteChange(pwnd);
        }
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\dwp.c ===
/****************************** Module Header ******************************\
* Module Name: dwp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains xxxDefWindowProc and related functions.
*
* History:
* 10-22-90 DarrinM      Created stubs.
* 13-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
*  DWP_DrawItem()
*
*  Does default WM_DRAWITEM handling.
*
\***************************************************************************/

void DWP_DrawItem(
    LPDRAWITEMSTRUCT lpdis)
{
    if (lpdis->CtlType == ODT_LISTBOX) {
        /*
         * Default OwnerDraw Listbox Item Drawing
         */
        if (   (lpdis->itemAction == ODA_FOCUS)
            || (   lpdis->itemAction == ODA_DRAWENTIRE
                && lpdis->itemState & ODS_FOCUS)
           ) {
            ClientFrame(lpdis->hDC, &lpdis->rcItem, gpsi->hbrGray, PATINVERT, 1, 1);
        }
    }
}


/***************************************************************************\
* xxxDWP_SetRedraw
*
*   This routine sets/resets the VISIBLE flag for windows who don't want any
*   redrawing.  Although a fast way of preventing paints, it is the apps
*   responsibility to reset this flag once they need painting.  Otherwise,
*   the window will be rendered transparent (could leave turds on the
*   screen).
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

void xxxDWP_SetRedraw(
    PWND pwnd,
    BOOL fRedraw)
{
    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (fRedraw) {
        if (!TestWF(pwnd, WFVISIBLE)) {
            SetVisible(pwnd, SV_SET);

            /*
             * We made this window visible - if it is behind any SPBs,
             * then we need to go invalidate them.
             *
             * We do this AFTER we make the window visible, so that
             * SpbCheckHwnd won't ignore it.
             */
            if (AnySpbs())
                SpbCheckPwnd(pwnd);

            /*
             * Now we need to invalidate/recalculate any affected cache entries
             * This call must be AFTER the window state change
             * No need to DeferWinEventNotify() since pwnd is threadlocked.
             */
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);

            /*
             * Because 3.1 sometimes doesn't draw window frames when 3.0 did,
             * we need to ensure that the frame gets drawn if the window is
             * later invalidated after a WM_SETREDRAW(TRUE)
             */
            SetWF(pwnd, WFSENDNCPAINT);
        }
    } else {
        if (TestWF(pwnd, WFVISIBLE)) {

            /*
             * Invalidate any SPBs.
             *
             * We do this BEFORE we make the window invisible, so
             * SpbCheckHwnd() won't ignore it.
             */
            if (AnySpbs())
                SpbCheckPwnd(pwnd);

            /*
             * Clear WFVISIBLE and delete any update regions lying around.
             */
            SetVisible(pwnd, SV_UNSET | (TestWF(pwnd, WFWIN31COMPAT) ? SV_CLRFTRUEVIS : 0));

            /*
             * Now we need to invalidate/recalc affected cache entries
             * This call must be AFTER the window state change
             * No need to DeferWinEventNotify() since we're about to return.
             */
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
        }
    }
}


/***************************************************************************\
* DWP_GetEnabledPopup
*
* History:
* 10-28-90 MikeHar Ported from Windows.
\***************************************************************************/

PWND DWP_GetEnabledPopup(
    PWND pwndStart)
{
    PWND pwndT, pwnd;
    PTHREADINFO ptiStart;
    BOOL        fVisitedFirstChild = FALSE;

    ptiStart = GETPTI(pwndStart);
    pwnd = pwndStart->spwndNext;

#ifdef SYSMODALWINDOWS
    if (gspwndSysModal)
        return NULL;
#endif

    /*
     * The user clicked on a window that is disabled. That window is pwndStart.
     * This loop is designed to evaluate what application this window is
     * associated with, and activate that "application", by finding what window
     * associated with that application can be activated. This is done by
     * enumerating top level windows, searching for a top level enabled
     * and visible ownee associated with this application.
     */
    while (pwnd != pwndStart) {
        if (pwnd == NULL) {

        /*
         * Warning! Win 3.1 had PWNDDESKTOP(pwndStart)->spwndChild
         * which could loop forever if pwndStart was a child window
         */
            if (fVisitedFirstChild) {
                /*
                 * If we visited the first child before then do not loop
                 * for ever, it is time to return.
                 */
                return NULL;
            }
            pwnd = pwndStart->spwndParent->spwndChild;
            fVisitedFirstChild = TRUE;
            continue;
        }

        /*
         * We have two cases we need to watch out for here.  The first is when
         * applications call AssociateThreadInput() to tie two threads
         * together to share input state.  If the threads own the same queue,
         * then associate them together: this way, when two threads call
         * AttachThreadInput(), one created the main window, one created the
         * dialog window, when you click on the main window, they'll both
         * come to the top (rather than beeping).  In this case we want to
         * compare queues.  When Control Panel starts Setup in the Network
         * applet is one type of example of attached input.
         *
         * The second case is WOW apps.  All wow apps have the same queue
         * so to retain Win 3.1 compatibility, we want to treat each app
         * as an individual task (Win 3.1 tests hqs), so we will compare
         * PTI's for WOW apps.
         *
         * To see this case start 16 bit notepad and 16 bit write.  Do file
         * open on write and then give notepad the focus now click on write's
         * main window and the write file open dialog should activate.
         *
         * Another related case is powerpnt.  This case is interesting because
         * it tests that we do not find another window to activate when nested
         * windows are up and you click on a owner's owner.  Run Powerpnt, do
         * Edit-Insert-Picture and Object-Recolor Picture will bring up a
         * dialog with combos, drop down one of the color combo and then click
         * on powerpnt's main window - focus should stay with the dialogs
         * combo and it should stay dropped down.
         */
        if (((ptiStart->TIF_flags & TIF_16BIT) && (GETPTI(pwnd) == ptiStart)) ||
                (!(ptiStart->TIF_flags & TIF_16BIT) && (GETPTI(pwnd)->pq == ptiStart->pq))) {

            if (!TestWF(pwnd, WFDISABLED) && TestWF(pwnd, WFVISIBLE)) {
                pwndT = pwnd->spwndOwner;

                /*
                 * If this window is the parent of a popup window,
                 * bring up only one.
                 */
                while (pwndT) {
                    if (pwndT == pwndStart)
                        return pwnd;

                    pwndT = pwndT->spwndOwner;
                }

                /*
                 * Win9x continues looping only if pwnd is WEFTOPMOST. NT4 just returns, like Win3.1
                 * As soon as we find a window on the queue, we stop. So if the queue owns
                 * multiple top level unowned windows, then this code will probably not find
                 * the enabled popup. Note that owned windows are supposed to be on top of the
                 * owner, usally right on top of it (ie, pwnd->spwndNext == pwnd->spwndOwner)
                 * so this code used to find any other top level unowned windows before the enabled
                 * popup and bail. Odd.
                 * So let's continue looping. Hopefully this won't cause any compatibility problems
                 */
                // return NULL;
            }
        }
        pwnd = pwnd->spwndNext;
    }

    return NULL;
}
/***************************************************************************\
* xxxDWP_ProcessVirtKey
*
* History:
* 10-28-90 MikeHar      Ported from Windows.
\***************************************************************************/

void xxxDWP_ProcessVirtKey(
    UINT wKey)
{
    PTHREADINFO pti;
    TL tlpwndActive;

    pti = PtiCurrent();
    if (pti->pq->spwndActive == NULL)
        return;

    switch (wKey) {

    case VK_F4:
        if (TestCF(pti->pq->spwndActive, CFNOCLOSE))
            break;

        /*
         * Don't change the focus if the child window has it.
         */
        if (pti->pq->spwndFocus == NULL ||
                GetTopLevelWindow(pti->pq->spwndFocus) !=
                pti->pq->spwndActive) {
            ThreadLockAlwaysWithPti(pti, pti->pq->spwndActive, &tlpwndActive);
            xxxSetFocus(pti->pq->spwndActive);
            ThreadUnlock(&tlpwndActive);
        }
        _PostMessage(pti->pq->spwndActive, WM_SYSCOMMAND, SC_CLOSE, 0L);
        break;

    case VK_TAB:
        /*
         * If alt-tab is reserved by console, don't bring up the alt-tab
         * window.
         */
        if (GETPTI(pti->pq->spwndActive)->fsReserveKeys & CONSOLE_ALTTAB)
            break;

    case VK_ESCAPE:
    case VK_F6:
        ThreadLockAlwaysWithPti(pti, pti->pq->spwndActive, &tlpwndActive);
        xxxSendMessage(pti->pq->spwndActive, WM_SYSCOMMAND,
                (UINT)(_GetKeyState(VK_SHIFT) < 0 ? SC_NEXTWINDOW : SC_PREVWINDOW),
                        (LONG)(DWORD)(WORD)wKey);
        ThreadUnlock(&tlpwndActive);
       break;
    }
}


/***************************************************************************\
* xxxDWP_Paint
*
* Handle WM_PAINT and WM_PAINTICON messages.
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

void xxxDWP_Paint(
    PWND pwnd)
{
    PAINTSTRUCT ps;

    CheckLock(pwnd);

    /*
     * Bad handling of a WM_PAINT message, the application called
     * BeginPaint/EndPaint and is now calling DefWindowProc for the same
     * WM_PAINT message. Just return so we don't get full drag problems.
     * (Word and Excel do this).
     *
     * Added the check for empty-client-rects.  ObjectVision has a problem
     * with empty-windows being invalidated during a full-drag.  They used
     * to get blocked at the STARTPAINT and couldn't get through to
     * xxxBeginPaint to validate their update-rgn.
     *
     * i.e.
     *      a) Parent has a child-window with an empty rect.  On a full
     *         drag of the parent, we process SetWindowPos() to paint
     *         the new position.
     *
     *      b) During the parents processing of WM_PAINT, it calls
     *         GetUpdateRect() on the empty-child, which sets the STARTPAINT
     *         on its window.
     *
     *      c) On return to the parent WM_PAINT handler, it calls
     *         UpdateWindow() on the child, and used to get blocked here
     *         because the STARTPAINT bit was set.  The Child never gets
     *         updated, causing an infinite loop.
     *
     *      *) By checking for an empty-rectangle, we will let it through
     *         to validate.
     *
     */
    if (TestWF(pwnd, WFSTARTPAINT) && !IsRectEmpty(&(pwnd->rcClient))) {
        return;
    }

    if (xxxBeginPaint(pwnd, &ps)) {
        xxxEndPaint(pwnd, &ps);
    }
}


/***************************************************************************\
* xxxDWP_EraseBkgnd
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDWP_EraseBkgnd(
    PWND pwnd,
    UINT msg,
    HDC  hdc)
{
    HBRUSH hbr;

    CheckLock(pwnd);

    switch (msg) {
    case WM_ICONERASEBKGND:
        //
        // Old compatibility:  Many hack apps use this to paint the
        // desktop wallpaper.  We never send WM_ICONERASEBKGND anymore
        // because we don't have client areas in our minimized windows.
        //
        if (!TestWF(pwnd, WFCHILD)) {
            xxxInternalPaintDesktop(pwnd, hdc, TRUE);
        } else {
            return FALSE;
        }
        break;

    case WM_ERASEBKGND:
        if (hbr = pwnd->pcls->hbrBackground) {
            // Convert sys colors to proper brush
            if (hbr <= (HBRUSH)COLOR_MAX)
                hbr = SYSHBRUSH((ULONG_PTR)hbr - 1);

            /*
             * Remove call to UnrealizeObject.  GDI handles this
             * for brushes on NT.
             *
             * if (hbr != SYSHBR(DESKTOP))
             *     GreUnrealizeObject(hbr);
             */

            xxxFillWindow(pwnd, pwnd, hdc, hbr);
        } else {
            return FALSE;
        }
    }
    return TRUE;
}


/***************************************************************************\
* xxxDWP_SetCursorInfo
*
*
* History:
* 26-Apr-1994 mikeke    Created
\***************************************************************************/

/***************************************************************************\
* xxxDWP_SetCursor
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDWP_SetCursor(
    PWND pwnd,
    HWND hwndHit,
    int codeHT,
    UINT msg)
{
    PWND pwndParent, pwndPopup, pwndHit;
    PCURSOR pcur;
    LRESULT lt;
    TL tlpwndParent;
    TL tlpwndPopup;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * wParam  == pwndHit == pwnd that cursor is over
     * lParamL == ht  == Hit test area code (result of WM_NCHITTEST)
     * lParamH == msg     == Mouse message number
     */
    if (msg)
    {
        switch (codeHT)
        {
        case HTLEFT:
        case HTRIGHT:
            pcur = SYSCUR(SIZEWE);
            break;
        case HTTOP:
        case HTBOTTOM:
            pcur = SYSCUR(SIZENS);
            break;
        case HTTOPLEFT:
        case HTBOTTOMRIGHT:
            pcur = SYSCUR(SIZENWSE);
            break;
        case HTTOPRIGHT:
        case HTBOTTOMLEFT:
            pcur = SYSCUR(SIZENESW);
            break;

        default:
            goto NotSize;
        }

        pwndHit = RevalidateHwnd(hwndHit);
        if (pwndHit == NULL)
            return FALSE;

        if (TestWF(pwndHit, WFSYSMENU)) {
            TL tlpwndHit;
            DWORD dwState;

            ThreadLockAlways(pwndHit, &tlpwndHit);
            dwState = _GetMenuState(
                    xxxGetSysMenu(pwndHit, TRUE), SC_SIZE, MF_BYCOMMAND);
            ThreadUnlock(&tlpwndHit);

            if ((dwState != (DWORD) -1) && (dwState & MFS_GRAYED))
                goto UseNormalCursor;
        }
        /*
         * No need to DeferWinEventNotify() - we're about to return
         */
        zzzSetCursor(pcur);
        return TRUE;
    }

NotSize:

    pwndParent = GetChildParent(pwnd);

    /*
     * Some windows (like the list boxes of comboboxes), are marked with
     * the child bit but are actually child of the desktop (can happen
     * if you call SetParent()). Make this special case check for
     * the desktop here.
     */
    if (pwndParent == PWNDDESKTOP(pwnd))
        pwndParent = NULL;

    if (pwndParent != NULL) {
        ThreadLockAlways(pwndParent, &tlpwndParent);
        lt = xxxSendMessage(pwndParent, WM_SETCURSOR, (WPARAM)hwndHit,
            MAKELONG(codeHT, msg));
        ThreadUnlock(&tlpwndParent);
        if (lt != 0)
            return TRUE;
    }

    if (msg == 0) {
        /*
         * No need to DeferWinEventNotify() - we're about to return
         */
        zzzSetCursor(SYSCUR(ARROW));

    } else {
        pwndHit = RevalidateHwnd(hwndHit);
        if (pwndHit == NULL)
            return FALSE;

        switch (codeHT) {
        case HTCLIENT:
            if (pwndHit->pcls->spcur != NULL) {
                /*
                 * No need to DeferWinEventNotify() - we're about to return
                 */
                zzzSetCursor(pwndHit->pcls->spcur);
            }
            break;

#ifdef LAME_BUTTON
        case HTLAMEBUTTON:

            /*
             * Show the hand cursor if we are over the Lame! text
             * in the caption.
             */
            zzzSetCursor(SYSCUR(HAND));

            break;
#endif // LAME_BUTTON

        case HTERROR:
            switch (msg) {
            case WM_MOUSEMOVE:
                if (TestUP(ACTIVEWINDOWTRACKING)) {
                    xxxActiveWindowTracking(pwnd, WM_SETCURSOR, codeHT);
                }
                break;

            case WM_LBUTTONDOWN:
                if ((pwndPopup = DWP_GetEnabledPopup(pwnd)) != NULL) {
                    if (pwndPopup != PWNDDESKTOP(pwnd)->spwndChild) {
                        PWND pwndActiveOld;

                        pwndActiveOld = PtiCurrent()->pq->spwndActive;

                        ThreadLockAlways(pwndPopup, &tlpwndPopup);

                        xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0,
                                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                        xxxSetActiveWindow(pwndPopup);

                        ThreadUnlock(&tlpwndPopup);

                        if (pwndActiveOld != PtiCurrent()->pq->spwndActive)
                            break;

                        /*
                         *** ELSE FALL THRU **
                         */
                    }
                }

                /*
                 *** FALL THRU **
                 */

            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_XBUTTONDOWN:
                {
                    PWND pwndDlg;

                    pwndDlg = DWP_GetEnabledPopup(pwnd);

                    if (pwndDlg != NULL) {

                        ThreadLockAlways(pwndDlg, &tlpwndPopup);

                        xxxFlashWindow(pwndDlg,
                                       MAKELONG(FLASHW_ALL, UP(FOREGROUNDFLASHCOUNT)),
                                       (gpsi->dtCaretBlink >> 3));

                        ThreadUnlock(&tlpwndPopup);
                    }

                    xxxMessageBeep(0);

                    break;
                }
            }

            /*
             *** FALL THRU **
             */

        default:
UseNormalCursor:
            /*
             * No need to DeferWinEventNotify() - we're about to return
             */
            zzzSetCursor(SYSCUR(ARROW));
            break;
        }
    }

    return FALSE;
}


/***************************************************************************\
* xxxDWP_NCMouse
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

void xxxDWP_NCMouse(
    PWND pwnd,
    UINT msg,
    UINT ht,
    LPARAM lParam)
{
    UINT cmd;

    CheckLock(pwnd);

    cmd = 0;
    switch (msg) {
    case WM_NCLBUTTONDOWN:

        switch (ht) {
        case HTZOOM:
        case HTREDUCE:
        case HTCLOSE:
        case HTHELP:
            cmd = xxxTrackCaptionButton(pwnd, ht);
            break;

        default:
            // Change into a MV/SZ command
            if (ht >= HTSIZEFIRST && ht <= HTSIZELAST)
                cmd = SC_SIZE + (ht - HTSIZEFIRST + WMSZ_SIZEFIRST);
            break;
        }

        if (cmd != 0) {
            //
            // For SysCommands on system menu, don't do if menu item is
            // disabled.
            //
            if (   cmd != SC_CONTEXTHELP
                && TestWF(pwnd, WFSYSMENU)
                && !TestwndChild(pwnd)
               ) {
                if (_GetMenuState(xxxGetSysMenu(pwnd, TRUE), cmd & 0xFFF0,
                    MF_BYCOMMAND) & MFS_GRAYED)
                    break;
            }

            xxxSendMessage(pwnd, WM_SYSCOMMAND, cmd, lParam);
            break;
        }
        // FALL THRU

    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
        xxxHandleNCMouseGuys(pwnd, msg, ht, lParam);
        break;
    }
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
\***************************************************************************/

UINT AreNonClientAreasToBePainted(
    PWND pwnd)
{
    WORD wRetValue = 0;

    /*
     * Check if Active and Inactive captions have same color
     */
    if (SYSRGB(ACTIVECAPTION) != SYSRGB(INACTIVECAPTION) ||
            SYSRGB(CAPTIONTEXT) != SYSRGB(INACTIVECAPTIONTEXT)) {
        wRetValue = DC_CAPTION;
    }

    /*
     * We want to repaint the borders if we're not minimized and
     * we have a sizing border and the active/inactive colors are
     * different.
     */
    if (!TestWF(pwnd, WFMINIMIZED) && TestWF(pwnd, WFSIZEBOX) &&
        (SYSRGB(ACTIVEBORDER) != SYSRGB(INACTIVEBORDER))) {
        // We need to redraw the sizing border.
        wRetValue |= DC_FRAME;
    }

    return wRetValue;
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
* 07-Aug-1996 vadimg   Added menu grayout and underline code
\***************************************************************************/

VOID xxxDWP_DoNCActivate(
    PWND pwnd,
    DWORD dwFlags,
    HRGN hrgnClip)
{
    UINT wFlags = DC_CAPTION;

    CheckLock(pwnd);

   /*
    * Later5.0 Gerardob. Since activation must follow focus, modeless
    *  menu windows are activated so they can receive keyboard input;
    *  however, we want the notification frame on, even when inactive.
    * (so it looks just like regular menus).
    * There are other scenarios when we want focus and activation on
    *  different parent-child chains so we should consider allowing this.
    */
    if ((dwFlags & NCA_ACTIVE)
            || (!(dwFlags & NCA_FORCEFRAMEOFF)
                && IsModelessMenuNotificationWindow(pwnd))) {

        SetWF(pwnd, WFFRAMEON);
        wFlags |= DC_ACTIVE;
    } else {

        ClrWF(pwnd, WFFRAMEON);
    }

    if ((hrgnClip != HRGN_NONE) && TestWF(pwnd, WFVISIBLE) && !TestWF(pwnd, WFNONCPAINT)) {

        HDC  hdc;
        WORD wBorderOrCap = (WORD)AreNonClientAreasToBePainted(pwnd);

        if (wBorderOrCap) {

            /*
             * Validate and Copy the region for our use.  Since we
             * hand this off to GetWindowDC() we won't have to delete
             * the region (done in ReleaseDC()).  Regardless, the region
             * passed in from the user is its responsibility to delete.
             */
            hrgnClip = UserValidateCopyRgn(hrgnClip);

            if (hdc = _GetDCEx(pwnd, hrgnClip, DCX_WINDOW | DCX_USESTYLE)) {
                 /*
                  * Draw the menu for grayout and underlines
                  */
                if (TestWF(pwnd, WFMPRESENT)) {
                    int cxFrame, cyFrame;
                    cxFrame = cyFrame = GetWindowBorders(pwnd->style,
                         pwnd->ExStyle, TRUE, FALSE);
                    cxFrame *= SYSMET(CXBORDER);
                    cyFrame *= SYSMET(CYBORDER);
                    xxxMenuBarDraw(pwnd, hdc, cxFrame, cyFrame);
                }
                xxxDrawCaptionBar(pwnd, hdc, wBorderOrCap | wFlags);
                _ReleaseDC(hdc);
            } else {
                GreDeleteObject(hrgnClip);
            }
        }
    }
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
\***************************************************************************/

BOOL xxxRedrawTitle(
    PWND pwnd, UINT wFlags)
{
    BOOL fDrawn = TRUE;

    CheckLock(pwnd);

    if (TestWF(pwnd, WFVISIBLE)) {

        if (TestWF(pwnd, WFBORDERMASK) == (BYTE)LOBYTE(WFCAPTION)) {
            if (TestwndFrameOn(pwnd)) {
                wFlags |= DC_ACTIVE;
            }

            if (IsInsideUserApiHook()) {
                xxxSendMessage(pwnd, WM_NCUAHDRAWCAPTION, wFlags, 0);
            } else {
                HDC hdc = _GetWindowDC(pwnd);
                xxxDrawCaptionBar(pwnd, hdc, wFlags);
                _ReleaseDC(hdc);
            }
        } else {
            fDrawn = FALSE;
        }
    }

    if ( IsTrayWindow(pwnd) && (wFlags & (DC_ICON | DC_TEXT)) ) {
        HWND hw = HWq(pwnd);
        xxxCallHook(HSHELL_REDRAW, (WPARAM)hw, 0L, WH_SHELL);
        PostShellHookMessages(HSHELL_REDRAW, (LPARAM)hw);

    }
    return(fDrawn);
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
\***************************************************************************/

void xxxDWP_DoCancelMode(
    PWND pwnd)
{
    PTHREADINFO pti = PtiCurrent();
    PWND pwndCapture = pti->pq->spwndCapture;
    PMENUSTATE pMenuState;

    /*
     * If the below menu lines are changed in any way, then SQLWin
     * won't work if in design mode you drop some text, double click on
     * it, then try to use the heirarchical menus.
     */
    pMenuState = GetpMenuState(pwnd);
    if ((pMenuState != NULL)
            && (pwnd == pMenuState->pGlobalPopupMenu->spwndNotify)
            && !pMenuState->fModelessMenu) {

        xxxEndMenu(pMenuState);
    }

    if (pwndCapture == pwnd) {
        PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
        if (pSBTrack && (pSBTrack->xxxpfnSB != NULL))
            xxxEndScroll(pwnd, TRUE);

        if (pti->pmsd != NULL) {
            pti->pmsd->fTrackCancelled = TRUE;
            pti->TIF_flags &= ~TIF_MOVESIZETRACKING;

            /*
             * Also clip the cursor back to the whole screen
             * so we don't get confused in xxxMoveSize.
             * This fix bug 64166.
             */
            zzzClipCursor((LPRECT)NULL);
        }

        /*
         * If the capture is still set, just release at this point.
         */
        xxxReleaseCapture();
    }
}

BOOL xxxDWPPrint(
    PWND   pwnd,
    HDC    hdc,
    LPARAM lParam)
{
    POINT  pt;
    int    iDC;
    LPRECT lprc;
    PWND   pwndSave = pwnd;
    LPARAM lParamSave = lParam;
    BOOL   fNotVisible;
    PBWL   pbwl;
    HWND   *phwnd;
    TL     tlpwnd;
    DWORD  dwOldLayout;
    BOOL   bMirrorDC;

    CheckLock(pwnd);

    if ((lParam & PRF_CHECKVISIBLE) && !_IsWindowVisible(pwnd))
        return(FALSE);

    bMirrorDC = (TestWF(pwnd, WEFLAYOUTRTL) && !MIRRORED_HDC(hdc));

    if (lParam & PRF_NONCLIENT) {

        /*
         * draw non-client area first
         */
        if (fNotVisible = !TestWF(pwnd, WFVISIBLE))
            SetVisible(pwnd, SV_SET);

        SetWF(pwnd, WFMENUDRAW);

        if (bMirrorDC) {
            LONG wox = pwnd->rcWindow.right - pwnd->rcWindow.left - 1;
            dwOldLayout = GreSetLayout(hdc, wox, LAYOUT_RTL);
            if(IsInsideUserApiHook()) {
                xxxSendMessage(pwnd, WM_NCUAHDRAWFRAME, (WPARAM)hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            } else {
                xxxDrawWindowFrame(pwnd, hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            }
            GreSetLayout(hdc, wox, dwOldLayout);
        } else {
            if(IsInsideUserApiHook()) {
                xxxSendMessage(pwnd, WM_NCUAHDRAWFRAME, (WPARAM)hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            } else {
                xxxDrawWindowFrame(pwnd, hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            }
        }

        ClrWF(pwnd, WFMENUDRAW);

        if (fNotVisible)
            SetVisible(pwnd, SV_UNSET);
    }

    if (lParam & PRF_CLIENT) {

        /*
         * draw client area second
         */
        iDC = GreSaveDC(hdc);
        GreGetWindowOrg(hdc, &pt);

        if (lParam & PRF_NONCLIENT) {
            int xBorders, yBorders;

            /*
             * adjust for non-client area
             */
            xBorders = pwnd->rcClient.left - pwnd->rcWindow.left;
            yBorders = pwnd->rcClient.top - pwnd->rcWindow.top;
            GreSetWindowOrg(hdc, pt.x - xBorders, pt.y - yBorders, NULL);
        }

        lprc = &pwnd->rcClient;
        GreIntersectClipRect(hdc, 0, 0, lprc->right - lprc->left, lprc->bottom - lprc->top);

        if (bMirrorDC) {
            LONG wox = pwnd->rcClient.right - pwnd->rcClient.left - 1;
            dwOldLayout = GreSetLayout(hdc, wox, LAYOUT_RTL);
            if (lParam & PRF_ERASEBKGND)
                xxxSendMessage(pwnd, WM_ERASEBKGND, (WPARAM) hdc, 0L);
            xxxSendMessage(pwnd, WM_PRINTCLIENT, (WPARAM) hdc, lParam);
            GreSetLayout(hdc, wox, dwOldLayout);
        } else {
            if (lParam & PRF_ERASEBKGND)
                xxxSendMessage(pwnd, WM_ERASEBKGND, (WPARAM) hdc, 0L);
            xxxSendMessage(pwnd, WM_PRINTCLIENT, (WPARAM) hdc, lParam);
        }

        GreRestoreDC(hdc, iDC);

        pt.x += pwnd->rcWindow.left;
        pt.y += pwnd->rcWindow.top;

        if (lParam & PRF_CHILDREN) {

            /*
             * when drawing children, always include nonclient area
             */
            lParam |= PRF_NONCLIENT | PRF_ERASEBKGND;

            lParam &= ~PRF_CHECKVISIBLE;

            /*
             * draw children last
             */
            pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
            if (pbwl != NULL) {
                for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
                    if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                        continue;

                    if (TestWF(pwnd, WFVISIBLE)) {
                        lprc = &pwnd->rcWindow;
                        iDC = GreSaveDC(hdc);
                        GreSetWindowOrg(hdc, pt.x - lprc->left, pt.y - lprc->top, NULL);
                        if (!TestCF(pwnd, CFPARENTDC)) {
                            GreIntersectClipRect(hdc, 0, 0, lprc->right - lprc->left, lprc->bottom - lprc->top);
                        }
                        ThreadLockAlways(pwnd, &tlpwnd);
                        xxxSendMessage(pwnd, WM_PRINT, (WPARAM) hdc, lParam);
                        ThreadUnlock(&tlpwnd);
                        GreRestoreDC(hdc, iDC);
                    }
                }
                FreeHwndList(pbwl);
            }
        }

        if (lParam & PRF_OWNED) {
            pbwl = BuildHwndList((PWNDDESKTOP(pwnd))->spwndChild, BWL_ENUMLIST, NULL);
            if (pbwl != NULL) {
                for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

                    if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                        continue;

                    if ((pwnd->spwndOwner == pwndSave) && TestWF(pwnd, WFVISIBLE)) {
                        iDC = GreSaveDC(hdc);
                        GreSetWindowOrg(hdc, pt.x - pwnd->rcWindow.left, pt.y - pwnd->rcWindow.top, NULL);
                        ThreadLockAlways(pwnd, &tlpwnd);
                        xxxSendMessage(pwnd, WM_PRINT, (WPARAM) hdc, lParamSave);
                        ThreadUnlock(&tlpwnd);
                        GreRestoreDC(hdc, iDC);
                    }
                }
                FreeHwndList(pbwl);
            }
        }
    }

    return TRUE;
}



/***************************************************************************\
*
*  DWP_GetIcon()
*
*  Gets the small or big icon for a window.  For small icons, if we created
*  the thing, we don't let the app see it.
*
\***************************************************************************/

HICON DWP_GetIcon(
    PWND pwnd,
    UINT uType)
{
    HICON   hicoTemp;
    ATOM atom;

    if (uType > ICON_SMALL2) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "WM_GETICON: Invalid wParam value (0x%X)", uType);
        return (HICON)NULL;
    }

    if (uType == ICON_BIG) {
        atom = gpsi->atomIconProp;
    } else {
        UserAssert(uType == ICON_SMALL || uType == ICON_SMALL2);
        atom = gpsi->atomIconSmProp;
    }

    /*
     *  Get the icon from the window
     */
    hicoTemp = (HICON)_GetProp(pwnd, MAKEINTATOM(atom), PROPF_INTERNAL);

    /*
     *  If it's a USER created small icon don't return it.
     */
    if (uType == ICON_SMALL && hicoTemp) {
        PCURSOR pcurTemp;

        pcurTemp = (PCURSOR)HMValidateHandleNoRip((HCURSOR)hicoTemp, TYPE_CURSOR);
        if (pcurTemp != NULL && (pcurTemp->CURSORF_flags & CURSORF_SECRET)) {
            hicoTemp = (HICON)NULL;
        }
    }

    return hicoTemp;
}


/***************************************************************************\
*
*  DestroyWindowSmIcon()
*
*  Destroys the small icon of a window if we've created a cached one.
*  This is  because it's called in winrare.c when the caption height
*  changes.
*
\***************************************************************************/

BOOL DestroyWindowSmIcon(
    PWND pwnd)
{
    HCURSOR hcursor;
    PCURSOR pcursor;

    //
    // Get the small icon property first...
    //
    hcursor = (HCURSOR)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
    if (hcursor == NULL)
        return FALSE;

    pcursor = (PCURSOR)HMValidateHandleNoRip(hcursor, TYPE_CURSOR);
    if (pcursor == NULL)
        return FALSE;

    //
    // Remove it if it's a secretly created one
    //

    if (pcursor->CURSORF_flags & CURSORF_SECRET)
    {
        ClrWF(pwnd, WFSMQUERYDRAGICON);
        InternalRemoveProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
        _DestroyCursor(pcursor, CURSOR_ALWAYSDESTROY);
        return(TRUE);
    }
    else
        return(FALSE);
}


/***************************************************************************\
*
*  xxxDWP_SetIcon()
*
*  Sets the small or big icon for a window, and returns back the previous
*  one.
*
\***************************************************************************/

HICON xxxDWP_SetIcon(
    PWND   pwnd,
    WPARAM wType,
    HICON  hicoNew)
{
    HICON   hIcon;
    HICON   hIconSm;
    HICON   hOld;
    BOOL    fRedraw;

    CheckLock(pwnd);

#if DBG
    if (hicoNew && !IS_PTR(hicoNew)) {
        RIPMSG1(RIP_WARNING, "WM_SETICON: Icon handle missing HIWORD (0x%08X)", hicoNew);
    }
#endif

    if (wType > ICON_RECREATE)
    {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "WM_SETICON: Invalid wParam value (0x%0X)", wType);
        return (HICON)NULL;
    }

    /*
     *  Regenerate small icons if requested.
     */
    if (wType == ICON_RECREATE) {
        xxxRecreateSmallIcons(pwnd);
        return 0L;
    }

    /*
     *  Save old icon
     */
    hIcon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);
    hIconSm = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
    hOld = ((wType == ICON_SMALL) ? hIconSm : hIcon);

    /*
     * Only update the icons if they have changed
     */
    if (hOld != hicoNew)
    {
        PCURSOR pcursor;
        BOOL fWasCache = FALSE;

        fRedraw = TRUE;

        /*
         *  Always remove the small icon because it is either being replaced or
         *  will be recreated if the big icon is being set.
         */
        pcursor = (PCURSOR)HMValidateHandleNoRip(hIconSm, TYPE_CURSOR);
        if (pcursor && (pcursor->CURSORF_flags & CURSORF_SECRET)) {
            fWasCache = TRUE;
            _DestroyCursor(pcursor, CURSOR_ALWAYSDESTROY);
        }

        if (wType == ICON_SMALL) {
            /*
             *  Apps never see the icons that USER creates behind their backs
             *  from big icons.
             */
            if (fWasCache)
                hOld = NULL;

            hIconSm = hicoNew;
        } else {
            if (fWasCache) {
                /*
                 * Force us to recalc the small icon to match the new big icon
                 */
                hIconSm = NULL;
            } else if (hIconSm) {
                /*
                 * Redraw of the caption isn't needed because the small icon
                 * didn't change.
                 */
                fRedraw = FALSE;
            }

            hIcon = hicoNew;
        }


        /*
         *  Store the icons off the window as properties
         */
        InternalSetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), (HANDLE)hIcon, PROPF_INTERNAL | PROPF_NOPOOL);
        InternalSetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), (HANDLE)hIconSm, PROPF_INTERNAL | PROPF_NOPOOL);

        /*
         *  Create the small icon if it doesn't exist.
         */
        if (hIcon && !hIconSm)
            xxxCreateWindowSmIcon(pwnd, hIcon, TRUE);

        /*
         * Redraw caption if the small icon has changed
         */
        if (fRedraw)
            xxxRedrawTitle(pwnd, DC_ICON);
    }
    return hOld;
}

// --------------------------------------------------------------------------
//
//  CreateWindowSmIcon()
//
//  Makes a per-window small icon copy of a big icon.
//
// --------------------------------------------------------------------------
HICON xxxCreateWindowSmIcon(
    PWND pwnd,
    HICON hIconBig,
    BOOL fNotQueryDrag)
{
    HICON   hIconSm = NULL;
    PCURSOR pcurs = NULL,pcursBig;

    CheckLock(pwnd);
    UserAssert(hIconBig);

    pcursBig = (PCURSOR)HMValidateHandleNoRip(hIconBig, TYPE_CURSOR);

    if (pcursBig) {
        pcurs = xxxClientCopyImage(PtoHq(pcursBig),
                        pcursBig->rt == PTR_TO_ID(RT_ICON) ? IMAGE_ICON : IMAGE_CURSOR,
                        SYSMET(CXSMICON),
                        SYSMET(CYSMICON),
                        LR_DEFAULTCOLOR | (fNotQueryDrag ? LR_COPYFROMRESOURCE : 0));
        if (pcurs != NULL)
            hIconSm = PtoHq(pcurs);
    }
    if (hIconSm) {
        pcurs->CURSORF_flags |= CURSORF_SECRET;
        InternalSetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), (HANDLE)hIconSm, PROPF_INTERNAL | PROPF_NOPOOL);
        if (!fNotQueryDrag)
            SetWF(pwnd, WFSMQUERYDRAGICON);
    }

    return(hIconSm);
}


/***************************************************************************\
* xxxDefWindowProc (API)
*
* History:
* 10-23-90 MikeHar Ported from WaWaWaWindows.
* 12-07-90 IanJa   CTLCOLOR handling round right way
\***************************************************************************/

LRESULT xxxDefWindowProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    /*
     * If we've got a registered UserApiHook handler loaded in this process,
     * pass the message off to it. For server side wndproc, we need to make an exception
     * passing WM_NCDESTROY so that themes can get a chance to do cleanup since they will not
     * see if in the post hook for those type of windows
     */
    if (IsInsideUserApiHook() &&
        (!TestWF(pwnd, WFDESTROYED) || ((message == WM_NCDESTROY) && TestWF(pwnd, WFSERVERSIDEPROC) && !(pwnd->fnid & FNID_DELETED_BIT))) &&
        (!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)) &&
        xxxLoadUserApiHook()) {

        /*
         * Call back to the appropriate DefWindowProc handler.
         */
        if (TestWF(pwnd, WFANSIPROC)) {
            return ScSendMessage(pwnd,
                                 message,
                                 wParam,
                                 lParam,
                                 0,
                                 gpsi->apfnClientA.pfnDispatchDefWindowProc,
                                 SCMS_FLAGS_ANSI);
        } else {
            return ScSendMessage(pwnd,
                                 message,
                                 wParam,
                                 lParam,
                                 0,
                                 gpsi->apfnClientW.pfnDispatchDefWindowProc,
                                 0);
        }
    }

    return xxxRealDefWindowProc(pwnd, message, wParam, lParam);
}

LRESULT xxxRealDefWindowProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT     lt;
    PWND        pwndT;
    TL          tlpwndParent;
    TL          tlpwndT;
    int         icolBack;
    int         icolFore;
    int         i;

    CheckLock(pwnd);

    if (pwnd == (PWND)-1) {
        return 0;
    }

    if (message > WM_USER) {
        return 0;
    }

    /*
     * Important:  If you add cases to the switch statement below,
     *             and those messages can originate on the client
     *             side, add the messages to server.c's gawDefWindowMsgs
     *             array or else the client will short-circuit the call
     *             and return 0.
     */

    switch (message) {
    case WM_CLIENTSHUTDOWN:
        return xxxClientShutdown(pwnd, wParam);

    case WM_NCACTIVATE:
        xxxDWP_DoNCActivate(pwnd, (LOWORD(wParam) ? NCA_ACTIVE : 0), (HRGN)lParam);
        return (LONG)TRUE;

    case WM_NCHITTEST:
        return FindNCHit(pwnd, (LONG)lParam);

    case WM_NCCALCSIZE:

        /*
         * wParam = fCalcValidRects
         * lParam = LPRECT rgrc[3]:
         *        lprc[0] = rcWindowNew = New window rectangle
         *    if fCalcValidRects:
         *        lprc[1] = rcWindowOld = Old window rectangle
         *        lprc[2] = rcClientOld = Old client rectangle
         *
         * On return:
         *        rgrc[0] = rcClientNew = New client rect
         *    if fCalcValidRects:
         *        rgrc[1] = rcValidDst  = Destination valid rectangle
         *        rgrc[2] = rcValidSrc  = Source valid rectangle
         */
        xxxCalcClientRect(pwnd, (LPRECT)lParam, FALSE);
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
        xxxDWP_NCMouse(pwnd, message, (UINT)wParam, lParam);
        break;

    case WM_CANCELMODE:
        {
            /*
             * Terminate any modes the system might
             * be in, such as scrollbar tracking, menu mode,
             * button capture, etc.
             */
            xxxDWP_DoCancelMode(pwnd);
        }
        break;

    case WM_NCCREATE:
        if (TestWF(pwnd, (WFHSCROLL | WFVSCROLL))) {
            if (_InitPwSB(pwnd) == NULL)
                return (LONG)FALSE;
        }

#ifdef FE_SB // xxxDefWindowProc()
        /*
         * If CREATESTRUCTEX.strName contains resource id, we don't
         * need to call DefSetText(). because it is a numeric number,
         * it does not need Ansi <-> Unicode translation.
         */
        if (lParam) {
            PLARGE_STRING pstr = &((PCREATESTRUCTEX)lParam)->strName;

            if (pwnd->head.rpdesk == NULL || pstr == NULL || pstr->Buffer == NULL) {
                pwnd->strName.Length = 0;
                return TRUE;
            }

            if ((pstr->bAnsi && (pstr->Length >= sizeof(BYTE)) &&
                                (*(PBYTE)(pstr->Buffer) == 0xff)) ||
                (!pstr->bAnsi && (pstr->Length >= sizeof(WCHAR)) &&
                                (*(PWCHAR)(pstr->Buffer) == 0xffff))) {
               /*
                * This is Resource ID, we just return here with TRUE.
                */
               return (LONG)TRUE;
            }
        }
#endif // FE_SB

        SetWF(pwnd, WFTITLESET);

        return (LONG)DefSetText(pwnd, &((PCREATESTRUCTEX)lParam)->strName);

    case WM_PRINT:
            return((LRESULT)xxxDWPPrint(pwnd, (HDC) wParam, lParam));

    case WM_NCPAINT:
        {
            HDC hdc;
            /*
             * Force the drawing of the menu.
             */
            SetWF(pwnd, WFMENUDRAW);

            /*
             * Get a window DC intersected with hrgnClip,
             * but make sure that hrgnClip doesn't get deleted.
             */
            hdc = _GetDCEx(pwnd,
                           (HRGN)wParam,
                           DCX_USESTYLE         |
                               DCX_WINDOW       |
                               DCX_INTERSECTRGN |
                               DCX_NODELETERGN  |
                               DCX_LOCKWINDOWUPDATE);

            xxxDrawWindowFrame(pwnd,
                               hdc,
                               (TestWF(pwnd, WFFRAMEON) &&
                                   (GETPTI(pwnd)->pq == gpqForeground)) ? DF_ACTIVE : 0L);

            _ReleaseDC(hdc);
            ClrWF(pwnd, WFMENUDRAW);
        }
        break;

    case WM_UAHINIT:
        /*
         * If the theme is becoming active, we need to "prime" the UAH's to
         * ensure that they get loaded.  This can happen if an existing app
         * becomes themed but doesn't call xxxCreateWindow() or
         * xxxDefWindowProc()
         */
        if (IsInsideUserApiHook()) {
            if (!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)) {
                return xxxLoadUserApiHook();
            }
        }
        break;

    case WM_NCUAHDRAWCAPTION:
        {
            HDC hdc = _GetWindowDC(pwnd);
            xxxDrawCaptionBar(pwnd, hdc, (UINT) wParam);
            _ReleaseDC(hdc);
        }
        break;

    case WM_NCUAHDRAWFRAME:
        {
            xxxDrawWindowFrame(pwnd,(HDC)wParam, (UINT)lParam);
        }
        break;

    case WM_ISACTIVEICON:
        return TestWF(pwnd, WFFRAMEON) != 0;

    case WM_SETTEXT:
        /*
         * At one time we added an optimization to do nothing if the new
         * text was the same as the old text but found that QCcase does not work
         * because it calls SetWindowText not to change the text but
         * cause the title bar to redraw after it had added the sysmenu
         * through SetWindowLong
         */
        if (lt = DefSetText(pwnd, (PLARGE_STRING)lParam)) {
            /*
             * Text was set, so redraw title bar
             */
            xxxRedrawTitle(pwnd, DC_TEXT);
            xxxWindowEvent(EVENT_OBJECT_NAMECHANGE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);
        }
        return lt;

    case WM_GETTEXT:
        if (wParam != 0) {
            PLARGE_STRING pstr = (PLARGE_STRING)lParam;

            if (pwnd->strName.Length) {
                if (pstr->bAnsi) {
                    i = WCSToMB(pwnd->strName.Buffer,
                            pwnd->strName.Length / sizeof(WCHAR),
                            (LPSTR *)&pstr->Buffer, pstr->MaximumLength - 1, FALSE);
                    ((LPSTR)pstr->Buffer)[i] = 0;
                    pstr->Length = i;
                } else {
                    i = TextCopy(&pwnd->strName, pstr->Buffer, (UINT)wParam);
                    pstr->Length = i * sizeof(WCHAR);
                }
                return i;
            }

            /*
             * else Null terminate the text buffer since there is no text.
             */
            if (pstr->bAnsi) {
                *(LPSTR)pstr->Buffer = 0;
            } else {
                *(LPWSTR)pstr->Buffer = 0;
            }
        }
        return 0L;

    case WM_GETTEXTLENGTH:
        if (pwnd->strName.Length) {
            UINT cch;
            if (lParam) {
                RtlUnicodeToMultiByteSize(&cch,
                                          pwnd->strName.Buffer,
                                          pwnd->strName.Length);
            } else {
                cch = pwnd->strName.Length / sizeof(WCHAR);
            }
            return cch;
        }
        return 0L;

    case WM_CLOSE:
        xxxDestroyWindow(pwnd);
        break;

    case WM_PAINT:
    case WM_PAINTICON:
        xxxDWP_Paint(pwnd);
        break;

    case WM_ERASEBKGND:
    case WM_ICONERASEBKGND:
        return (LONG)xxxDWP_EraseBkgnd(pwnd, message, (HDC)wParam);

    case WM_SYNCPAINT:

        /*
         * Clear our sync-paint pending flag.
         */
        ClrWF(pwnd, WFSYNCPAINTPENDING);

        /*
         * This message is sent when SetWindowPos() is trying
         * to get the screen looking nice after window rearrangement,
         * and one of the windows involved is of another task.
         * This message avoids lots of inter-app message traffic
         * by switching to the other task and continuing the
         * recursion there.
         *
         * wParam         = flags
         * LOWORD(lParam) = hrgnClip
         * HIWORD(lParam) = pwndSkip  (not used; always NULL)
         *
         * pwndSkip is now always NULL.
         *
         * NOTE: THIS MESSAGE IS FOR INTERNAL USE ONLY! ITS BEHAVIOR
         * IS DIFFERENT IN 3.1 THAN IN 3.0!!
         */
        xxxInternalDoSyncPaint(pwnd, (DWORD)wParam);
        break;

    case WM_QUERYOPEN:
    case WM_QUERYENDSESSION:
    case WM_DEVICECHANGE:
    case WM_POWERBROADCAST:
        return (LONG)TRUE;

    // Default handling for WM_CONTEXTMENU support
    case WM_RBUTTONUP:
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            lParam = MAKELPARAM(pwnd->rcClient.right - GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        } else {
            lParam = MAKELONG(GET_X_LPARAM(lParam) + pwnd->rcClient.left, GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        }
        xxxSendMessage(pwnd, WM_CONTEXTMENU, (WPARAM) HWq(pwnd), lParam);
        break;

    case WM_NCRBUTTONDOWN:
        {
            int         nHit;
            MSG         msg;
            LONG        spt;
            PTHREADINFO pti = PtiCurrent();

            nHit = FindNCHit(pwnd, (LONG)lParam);
            if (nHit == HTVSCROLL || nHit == HTHSCROLL) {
                if (!_IsDescendant(pti->pq->spwndActive, pwnd)) {
                    break;
                }
            } else if (nHit == HTCAPTION || nHit == HTSYSMENU) {
                if (pwnd != pti->pq->spwndActive) {
                    break;
                }
            } else {
                break;
            }

            xxxSetCapture(pwnd);

            while (TRUE)
            {
                if (xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
                {
                    if (msg.message == WM_RBUTTONUP)
                    {
                        xxxReleaseCapture();
                        spt = POINTTOPOINTS(msg.pt);
                        nHit = FindNCHit(pwnd, spt);
                        if ((nHit == HTCAPTION) || (nHit == HTSYSMENU) ||
                            (nHit == HTVSCROLL) || (nHit == HTHSCROLL)) {
                            xxxSendMessage(pwnd, WM_CONTEXTMENU, (WPARAM) HWq(pwnd), spt);
                        }
                        break;
                    }
                }
                if (pwnd != pti->pq->spwndCapture)
                // Someone else grabbed the capture.  Bail out.
                    break;
//                xxxWaitMessage();
                if (!xxxSleepThread(QS_MOUSE, 0, TRUE))
                    break;
            }
        }
        break;

    /*
     * Default handling for WM_APPCOMMAND support
     */
    case WM_NCXBUTTONUP:
    case WM_XBUTTONUP:
        {
            WORD cmd;
            WORD keystate;
            LPARAM lParamAppCommand;

            cmd = 0;
            switch (GET_XBUTTON_WPARAM(wParam)) {
            case XBUTTON1:
                cmd = APPCOMMAND_BROWSER_BACKWARD;
                break;

            case XBUTTON2:
                cmd = APPCOMMAND_BROWSER_FORWARD;
                break;

            default:
                break;
            }

            if (cmd == 0) {
                break;
            }

            cmd |= FAPPCOMMAND_MOUSE;
            if (message == WM_XBUTTONUP) {
                keystate = GET_KEYSTATE_WPARAM(wParam);
            } else {
                keystate = (WORD)GetMouseKeyFlags(PtiCurrent()->pq);
            }

            lParamAppCommand = MAKELPARAM(keystate, cmd);
            xxxSendMessage(pwnd, WM_APPCOMMAND, (WPARAM) HWq(pwnd), lParamAppCommand);
            break;
        }

    case WM_MOUSEWHEEL:
        if (TestwndChild(pwnd)) {
            ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
            xxxSendMessage(pwnd->spwndParent, WM_MOUSEWHEEL, wParam, lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_CONTEXTMENU:
        {
            int nHit;

            nHit = FindNCHit(pwnd, (LONG)lParam);

            /*
             * Put up a context menu if we clicked on a scroll bar
             */
            if ((nHit == HTVSCROLL) || (nHit == HTHSCROLL)) {
                if (_IsDescendant(PtiCurrent()->pq->spwndActive, pwnd)) {
                    xxxDoScrollMenu(pwnd, NULL, nHit - HTHSCROLL, lParam);
                }
                break;
            }

            if (TestwndChild(pwnd)) {
                ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
                xxxSendMessage(pwnd->spwndParent, WM_CONTEXTMENU, (WPARAM) HWq(pwnd), lParam);
                ThreadUnlock(&tlpwndParent);
            } else {
                /*
                 *  Do default context menu if right clicked on caption
                 */
                if (pwnd == PtiCurrent()->pq->spwndActive)
                {
                    if (nHit == HTCAPTION)
                        goto DoTheDefaultThang;
                    else if (nHit == HTSYSMENU)
                    {
                        i = SC_CLOSE;
                        goto DoTheSysMenuThang;
                    }

                    /*
                     *  If this was generated by the keyboard (apps key), then simulate a shift-f10
                     *  for old apps so they get a crack at putting up their context menu.
                     */
                    if (lParam == KEYBOARD_MENU && !TestWF(pwnd, WFWIN40COMPAT))
                        xxxSimulateShiftF10();
                }
            }
        }
        break;

    case WM_APPCOMMAND:
        /*
         * Bubble the message to the parent
         */
        if (TestwndChild(pwnd)) {
            ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
            lt = xxxSendMessage(pwnd->spwndParent, WM_APPCOMMAND, wParam, lParam);
            ThreadUnlock(&tlpwndParent);
            return lt;
        } else if (pwnd != PWNDDESKTOP(pwnd) ) {
            BOOL bEatMe = FALSE;
            /*
             * Notify listeners on the SHELLHOOK that a WM_APPCOMMAND message was not handled
             * We also post this message to the shell queue so they don't need to load themselves
             * into every process with a hook.
             * We don't bother about the desktop since csrss services it and it doesn't accept
             * shell hooks so there is no point.
             */
            if (IsHooked(PtiCurrent(), WHF_SHELL))
                bEatMe = (xxxCallHook(HSHELL_APPCOMMAND, wParam, lParam, WH_SHELL) != 0);

            /*
             * The shell only wants to get this notification if no one in
             * the hook chain handled this WM_APPCOMMAND, so we check the
             * return value of the hook (if there was one). See RAID #54863.
             */
            if(!bEatMe)
                PostShellHookMessages(HSHELL_APPCOMMAND, lParam);
        }
        break;

    case WM_KEYF1:
        xxxSendHelpMessage(pwnd, HELPINFO_WINDOW,
                (int) (TestwndChild(pwnd) ? PTR_TO_ID(pwnd->spmenu) : 0),
                HWq(pwnd), GetContextHelpId(pwnd));
        break;

    case WM_SYSCOMMAND:
        xxxSysCommand(pwnd, (UINT)wParam, lParam);
        break;

    case WM_KEYDOWN:
        if (wParam == VK_F10) {
            PtiCurrent()->pq->QF_flags |= QF_FF10STATUS;
HandleF10:
         /*
          *  Generate a WM_CONTEXTMENU for new apps for shift-f10.
          */
             if (_GetKeyState(VK_SHIFT) < 0 && TestWF(pwnd, WFWIN40COMPAT)) {
                 xxxSendMessage(pwnd, WM_CONTEXTMENU, (WPARAM)HWq(pwnd), KEYBOARD_MENU);
             }
        }
        break;

    case WM_HELP:
        // If this window is a child window, Help message must be passed on
        // to it's parent; Else, this must be passed on to the owner window.
        pwndT = (TestwndChild(pwnd)? pwnd->spwndParent : pwnd->spwndOwner);
        if (pwndT && (pwndT != _GetDesktopWindow())) {
            ThreadLockAlways(pwndT, &tlpwndT);
            lt = xxxSendMessage(pwndT, WM_HELP, wParam, lParam);
            ThreadUnlock(&tlpwndT);
            return lt;
        }
        return 0L;

    case WM_SYSKEYDOWN:
        {
            PTHREADINFO pti = PtiCurrent();

            /*
             * Is the ALT key down?
             */
            if (HIWORD(lParam) & SYS_ALTERNATE) {
                /*
                 * Toggle QF_FMENUSTATUS iff this is NOT a repeat KEYDOWN
                 * message; Only if the prev key state was 0, then this is the
                 * first KEYDOWN message and then we consider toggling menu
                 * status; Fix for Bugs #4531 & #4566 --SANKAR-- 10-02-89.
                 */
                if ((HIWORD(lParam) & SYS_PREVKEYSTATE) == 0) {

                    /*
                     * Don't have to lock pwndActive because it's
                     * processing this key.
                     */
                    if ((wParam == VK_MENU) &&
                            !(pti->pq->QF_flags & QF_FMENUSTATUS)) {
                        pti->pq->QF_flags |= QF_FMENUSTATUS;
                        xxxDrawMenuBarUnderlines(pwnd, TRUE);
                    } else {
                        pti->pq->QF_flags &= ~(QF_FMENUSTATUS|QF_FMENUSTATUSBREAK);
                    }
                }

                pti->pq->QF_flags &= ~QF_FF10STATUS;

                xxxDWP_ProcessVirtKey((UINT)wParam);

            } else {
                if (wParam == VK_F10) {
                    pti->pq->QF_flags |= QF_FF10STATUS;
                    goto HandleF10;
                }
            }
        }
        break;

    case WM_SYSKEYUP:
    case WM_KEYUP:
        {
            PTHREADINFO pti = PtiCurrent();

            /*
             * press and release F10 or ALT.  Send this only to top-level windows,
             * otherwise MDI gets confused.  The fix in which DefMDIChildProc()
             * passed up the message was insufficient in the case a child window
             * of the MDI child had the focus.
             * Also make sure the sys-menu activation wasn't broken by a mouse
             * up or down when the Alt was down (QF_MENUSTATUSBREAK).
             */
            if ((wParam == VK_MENU && !(pti->pq->QF_flags & QF_TABSWITCHING) && ((pti->pq->QF_flags &
                    (QF_FMENUSTATUS | QF_FMENUSTATUSBREAK)) == QF_FMENUSTATUS)) ||
                    (wParam == VK_F10 && (pti->pq->QF_flags & QF_FF10STATUS ))) {
                pwndT = GetTopLevelWindow(pwnd);
                if (gspwndFullScreen != pwndT) {

                    ThreadLockWithPti(pti, pwndT, &tlpwndT);
                    /*
                     * Draw the underlines for F10. This was already down for ALT
                     *  when the key went down.
                     */
                    if (wParam == VK_F10) {
                        xxxDrawMenuBarUnderlines(pwnd, TRUE);
                    }
                    xxxSendMessage(pwndT, WM_SYSCOMMAND, SC_KEYMENU, 0);
                    ThreadUnlock(&tlpwndT);
                }
            }

            /*
             * Turn off bit for tab-switching.  This is set in the _KeyEvent()
             * routine when it's been determined we're doing switching.  This
             * is necessary for cases where the ALT-KEY is release before the
             * TAB-KEY.  In which case, the FMENUSTATUS bit would be cleared
             * by the ALT-KEY-UP and would have forced us into a syscommand
             * loop.  This guarentees that we don't enter that condition.
             */
            if (wParam == VK_MENU) {
                pti->pq->QF_flags &= ~QF_TABSWITCHING;
                xxxDrawMenuBarUnderlines(pwnd, FALSE);
            }

            pti->pq->QF_flags &= ~(QF_FMENUSTATUS | QF_FMENUSTATUSBREAK | QF_FF10STATUS);
        }
        break;

    case WM_SYSCHAR:
        {
            PTHREADINFO pti = PtiCurrent();

            /*
             * If syskey is down and we have a char...
             */
            pti->pq->QF_flags &= ~(QF_FMENUSTATUS | QF_FMENUSTATUSBREAK);

            if (wParam == VK_RETURN && TestWF(pwnd, WFMINIMIZED)) {

                /*
                 * If the window is iconic and user hits RETURN, we want to
                 * restore this window.
                 */
                _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
                break;
            }

            if ((HIWORD(lParam) & SYS_ALTERNATE) && wParam) {
                if (wParam == VK_TAB || wParam == VK_ESCAPE)
                    break;

                /*
                 * Send ALT-SPACE only to top-level windows.
                 */
                if ((wParam == MENUSYSMENU) && (TestwndChild(pwnd))) {
                    ThreadLockAlwaysWithPti(pti, pwnd->spwndParent, &tlpwndParent);
                    xxxSendMessage(pwnd->spwndParent, message, wParam, lParam);
                    ThreadUnlock(&tlpwndParent);
                } else {
                    xxxSendMessage(pwnd, WM_SYSCOMMAND, SC_KEYMENU, (DWORD)wParam);
                }
            } else {

                /*
                 * Ctrl-Esc produces a WM_SYSCHAR, But should not beep;
                 */
                if (wParam != VK_ESCAPE)
                    xxxMessageBeep(0);
            }
        }
        break;
    case WM_UNICHAR:
        if (wParam == UNICODE_NOCHAR) {
            return FALSE;
        } else {
            _PostMessage(pwnd, WM_CHAR, wParam, lParam);
        }
        break;

    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:

        /*
         * Do default processing for keystrokes into owner draw listboxes.
         */
        return -1L;

    case WM_ACTIVATE:
        if (wParam)
            xxxSetFocus(pwnd);
        break;

    case WM_INPUTLANGCHANGEREQUEST:
    {
        PWND pwndFocus = PtiCurrent()->pq->spwndFocus;

        /*
         * #115190
         * Dialog does not forward I.L.Reqest to the focused window.
         * (Memphis compatible issue)
         */
        if (pwndFocus && (pwndFocus != pwnd) &&
                pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_DIALOG]) {
            /*
             * pass message to focus'ed window. Old app, pass on to
             * focus'ed window which may be ML aware.  (edit class
             * for example).
             */
            ThreadLockAlways(pwndFocus, &tlpwndT);
            xxxSendMessage(pwndFocus, message, wParam, lParam);
            ThreadUnlock(&tlpwndT);
        } else if (!xxxActivateKeyboardLayout(_GetProcessWindowStation(NULL),
                (HKL)lParam, KLF_SETFORPROCESS, pwnd)) {
            RIPERR1(ERROR_INVALID_KEYBOARD_HANDLE, RIP_WARNING, "WM_INPUTLANGCHANGEREQUEST: Invalid keyboard handle (0x%08lx)", lParam);
        }
        break;
    }

    case WM_INPUTLANGCHANGE:
    {
        PBWL pbwl;
        HWND *phwnd;
        TL tlpwnd;

        pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
        if (pbwl == NULL)
            return 0;

        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
            /*
             * Make sure this hwnd is still around.
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                continue;

            ThreadLockAlways(pwnd, &tlpwnd);
            RIPMSG1(RIP_VERBOSE, "WM_INPUTLANGCHANGE: Sending message to pwnd %#p", pwnd);
            xxxSendMessage(pwnd, message, wParam, lParam);
            ThreadUnlock(&tlpwnd);
        }
        FreeHwndList(pbwl);

        break;
    }

    case WM_SETREDRAW:
        xxxDWP_SetRedraw(pwnd, wParam != 0);
        break;

    case WM_WINDOWPOSCHANGING:
        {
            /*
             * If the window's size is changing, adjust the passed-in size
             */
            WINDOWPOS *ppos = ((WINDOWPOS *)lParam);
            if (!(ppos->flags & SWP_NOSIZE)) {
                xxxAdjustSize(pwnd, &ppos->cx, &ppos->cy);
            }
        }
        break;

    case WM_WINDOWPOSCHANGED:
        xxxHandleWindowPosChanged(pwnd, (PWINDOWPOS)lParam);
        break;

    case WM_CTLCOLORSCROLLBAR:
        if (gpsi->BitCount < 8 ||
                SYSRGB(3DHILIGHT) != SYSRGB(SCROLLBAR) ||
                SYSRGB(3DHILIGHT) == SYSRGB(WINDOW))
        {
            /*
             * Remove call to UnrealizeObject.  GDI handles this
             * for brushes on NT.
             *
             * GreUnrealizeObject(ghbrGray);
             */

            GreSetBkColor((HDC)wParam, SYSRGB(3DHILIGHT));
            GreSetTextColor((HDC)wParam, SYSRGB(3DFACE));
            return((LRESULT)gpsi->hbrGray);
        }

        icolBack = COLOR_3DHILIGHT;
        icolFore = COLOR_BTNTEXT;
        goto SetColor;

    case WM_CTLCOLORBTN:
        if (TestWF(pwnd, WFWIN40COMPAT)) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_BTNTEXT;
        } else {
            goto ColorDefault;
        }
        goto SetColor;

    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
        // We want static controls in dialogs to have the 3D
        // background color, but statics in windows to inherit
        // their parents' background.
        if (TestWF(pwnd, WFWIN40COMPAT)
           ) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_WINDOWTEXT;
            goto SetColor;
        }
        // ELSE FALL THRU...

    case WM_CTLCOLOR:              // here for WOW only
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLOREDIT:
ColorDefault:
        icolBack = COLOR_WINDOW;
        icolFore = COLOR_WINDOWTEXT;

SetColor:
        GreSetBkColor((HDC)wParam, gpsi->argbSystem[icolBack]);
        GreSetTextColor((HDC)wParam, gpsi->argbSystem[icolFore]);
        return (LRESULT)(SYSHBRUSH(icolBack));

    case WM_SETCURSOR:

        /*
         * wParam  == pwndHit == pwnd that cursor is over
         * lParamL == ht  == Hit test area code (result of WM_NCHITTEST)
         * lParamH == msg     == Mouse message number
         */
        return (LONG)xxxDWP_SetCursor(pwnd, (HWND)wParam, (int)(SHORT)lParam,
                HIWORD(lParam));

    case WM_MOUSEACTIVATE:
        pwndT = GetChildParent(pwnd);
        if (pwndT != NULL) {
            ThreadLockAlways(pwndT, &tlpwndT);
            lt = xxxSendMessage(pwndT, WM_MOUSEACTIVATE, wParam, lParam);
            ThreadUnlock(&tlpwndT);
            if (lt != 0)
                return lt;
        }

        /*
         * Moving, sizing or minimizing? Activate AFTER we take action.
         * If the user LEFT clicked in the title bar, don't activate now:
         */
        return  (   (LOWORD(lParam) == HTCAPTION)
                 && (HIWORD(lParam) == WM_LBUTTONDOWN)
                )
              ? (LONG)MA_NOACTIVATE
              : (LONG)MA_ACTIVATE;

    case WM_SHOWWINDOW:

        /*
         * If we are being called because our owner window is being shown,
         * hidden, minimized, or un-minimized, then we must hide or show
         * show ourself as appropriate.
         *
         * This behavior occurs for popup windows or owned windows only.
         * It's not designed for use with child windows.
         */
        if (LOWORD(lParam) != 0 && (TestwndPopup(pwnd) || pwnd->spwndOwner)) {

            /*
             * The WFHIDDENPOPUP flag is an internal flag that indicates
             * that the window was hidden because its owner was hidden.
             * This way we only show windows that were hidden by this code,
             * not intentionally by the application.
             *
             * Go ahead and hide or show this window, but only if:
             *
             * a) we need to be hidden, or
             * b) we need to be shown, and we were hidden by
             *    an earlier WM_SHOWWINDOW message
             */
            if ((!wParam && TestWF(pwnd, WFVISIBLE)) ||
                    (wParam && !TestWF(pwnd, WFVISIBLE) &&
                    TestWF(pwnd, WFHIDDENPOPUP))) {

                /*
                 * Remember that we were hidden by WM_SHOWWINDOW processing
                 */
                ClrWF(pwnd, WFHIDDENPOPUP);
                if (!wParam)
                    SetWF(pwnd, WFHIDDENPOPUP);

                xxxShowWindow(
                        pwnd,
                        (wParam ? SW_SHOWNOACTIVATE : SW_HIDE) | TEST_PUDF(PUDF_ANIMATE));
            }
        }
        break;

    case WM_SYSMENU:
        if (   !TestWF(pwnd, WFDISABLED)
            && (   (GETPTI(pwnd)->pq == gpqForeground)
                || xxxSetForegroundWindow(pwnd, FALSE))
           )
        {
            PMENU pMenu;
            TL tpmenu;
DoTheDefaultThang:
            if (TestWF(pwnd, WFMAXIMIZED) || TestWF(pwnd, WFMINIMIZED))
                i = SC_RESTORE;
            else
                i = SC_MAXIMIZE;

DoTheSysMenuThang:
            if ((pMenu = xxxGetSysMenu(pwnd, TRUE)) != NULL)
            {
                _SetMenuDefaultItem(pMenu, i, MF_BYCOMMAND);

                // Tell the shell we are bringing it up the system menu
                PostShellHookMessages(HSHELL_SYSMENU, (LPARAM)HWq(pwnd));

                ThreadLockAlways(pMenu, &tpmenu);
                if (lParam == 0xFFFFFFFF)
                {
                    // this is a keyboard generated WM_SYSMENU
                    if (FDoTray())
                    {
                        TPMPARAMS tpm;

                        tpm.cbSize = sizeof(TPMPARAMS);

                        if (xxxSendMinRectMessages(pwnd, &tpm.rcExclude)) {
                            xxxTrackPopupMenuEx(pMenu, TPM_SYSMENU | TPM_VERTICAL,
                                tpm.rcExclude.left, tpm.rcExclude.top, pwnd, &tpm);
                        }
                    }
                }
                else
                {
                    xxxTrackPopupMenuEx(pMenu, TPM_RIGHTBUTTON | TPM_SYSMENU,
                        GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), pwnd, NULL);
                }
                ThreadUnlock(&tpmenu);
            }
        }
        break;

    case WM_DRAWITEM:
        DWP_DrawItem((LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_GETHOTKEY:
        return (LONG)DWP_GetHotKey(pwnd);
        break;

    case WM_SETHOTKEY:
        return (LONG)DWP_SetHotKey(pwnd, (DWORD)wParam);
        break;

    case WM_GETICON:
        return (LRESULT)DWP_GetIcon(pwnd, (BOOL)wParam);

    case WM_SETICON:
        return (LRESULT)xxxDWP_SetIcon(pwnd, wParam, (HICON)lParam);

    case WM_COPYGLOBALDATA:
        /*
         * This message is used to thunk WM_DROPFILES messages along
         * with other things.  If we end up here with it, directly
         * call the client back to finish processing of this message.
         * This assumes that the ultimate destination of the
         * WM_DROPFILES message is in the client side's process context.
         */
        return(SfnCOPYGLOBALDATA(NULL, 0, wParam, lParam, 0, 0, 0, NULL));

    case WM_QUERYDROPOBJECT:
        /*
         * if the app has registered interest in drops, return TRUE
         */
        return (LRESULT)(TestWF(pwnd, WEFACCEPTFILES) ? TRUE : FALSE);

    case WM_DROPOBJECT:
        return DO_DROPFILE;

    case WM_ACCESS_WINDOW:
        if (ValidateHwnd((HWND)wParam)) {
            // SECURITY: set ACL for this window to no-access
            return TRUE;
        }
        return FALSE;

    case WM_NOTIFYFORMAT:
        if(lParam == NF_QUERY)
            return(TestWF(pwnd, WFANSICREATOR) ? NFR_ANSI : NFR_UNICODE);
        break;

    case WM_CHANGEUISTATE:
        {
            WORD wAction = LOWORD(wParam);
            WORD wFlags = HIWORD(wParam);
            BOOL bRealChange = FALSE;

            /*
             * Validate parameters and determine the flags that should actually be changed.
             */
            if ((wFlags & ~UISF_VALID) || (wAction > UIS_LASTVALID) || lParam) {
                return 0;
            }

            if (wAction == UIS_INITIALIZE) {
                wFlags = 0;
                if (TEST_KbdCuesPUSIF) {
                    if (TEST_SRVIF(SRVIF_LASTRITWASKEYBOARD)) {
                        wAction = UIS_CLEAR;
                    } else {
                        wAction = UIS_SET;
                    }
                    wFlags = UISF_HIDEFOCUS | UISF_HIDEACCEL;
                    wParam = MAKEWPARAM(wAction, wFlags);
                }
            } else if (!TEST_KbdCuesPUSIF) {
                wFlags &= ~(UISF_HIDEFOCUS | UISF_HIDEACCEL);
            }

            if (wFlags == 0) {
                return 0;
            }


            UserAssert(wAction == UIS_SET || wAction == UIS_CLEAR);
            /*
             * If the state is not going to change, there's nothing to do here
             */
            if (wFlags & UISF_HIDEFOCUS) {
                bRealChange = (!!TestWF(pwnd, WEFPUIFOCUSHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_HIDEACCEL) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACCELHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_ACTIVE) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACTIVE)) ^ (wAction == UIS_SET);
            }

            if (!bRealChange) {
                break;
            }

            /*
             * Children pass this message up
             * Top level windows update their children's state and
             * send down to their imediate children WM_UPDATEUISTATE.
             */
            if (TestwndChild(pwnd)) {
                ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
                lt = xxxSendMessage(pwnd->spwndParent, WM_CHANGEUISTATE, wParam, lParam);
                ThreadUnlock(&tlpwndParent);
                return lt;
            } else {
                return xxxSendMessage(pwnd, WM_UPDATEUISTATE, wParam, lParam);
            }

        }
        break;

    case WM_QUERYUISTATE:
        return (TestWF(pwnd, WEFPUIFOCUSHIDDEN) ? UISF_HIDEFOCUS : 0) |
               (TestWF(pwnd, WEFPUIACCELHIDDEN) ? UISF_HIDEACCEL : 0) |
               (TestWF(pwnd, WEFPUIACTIVE) ? UISF_ACTIVE : 0);
        break;

    case WM_UPDATEUISTATE:
        {
            WORD wAction = LOWORD(wParam);
            WORD wFlags = HIWORD(wParam);

            /*
             * Validate parameters and determine the flags that should actually be changed.
             */
            if ((wFlags & ~UISF_VALID) || (wAction > UIS_LASTVALID) || lParam) {
                return 0;
            }

            if (wAction == UIS_INITIALIZE) {
                wFlags = 0;
                if (TEST_KbdCuesPUSIF) {
                    if (TEST_SRVIF(SRVIF_LASTRITWASKEYBOARD)) {
                        wAction = UIS_CLEAR;
                    } else {
                        wAction = UIS_SET;
                    }
                    wFlags = UISF_HIDEFOCUS | UISF_HIDEACCEL;
                    wParam = MAKEWPARAM(wAction, wFlags);
                }
            } else if (!TEST_KbdCuesPUSIF) {
                wFlags &= ~(UISF_HIDEFOCUS | UISF_HIDEACCEL);
            }

            if (wFlags == 0) {
                return 0;
            }

            switch (wAction) {
                case UIS_INITIALIZE:
                    /*
                     * UISTATE: UIS_INITIALIZE sets the UIState bits for
                     * HIDEACCEL AND HIDEFOCUS based on the last input type.
                     *
                     * ACTIVE will not be changed.
                     */
                    if (!TEST_SRVIF(SRVIF_LASTRITWASKEYBOARD)) {
                        SetWF(pwnd, WEFPUIFOCUSHIDDEN);
                        SetWF(pwnd, WEFPUIACCELHIDDEN);
                        wParam = MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS);
                    } else {
                        ClrWF(pwnd, WEFPUIFOCUSHIDDEN);
                        ClrWF(pwnd, WEFPUIACCELHIDDEN);
                        wParam = MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS);
                    }
                    break;

                case UIS_SET:
                    if (wFlags & UISF_HIDEACCEL) {
                        SetWF(pwnd, WEFPUIACCELHIDDEN);
                    }
                    if (wFlags & UISF_HIDEFOCUS) {
                        SetWF(pwnd, WEFPUIFOCUSHIDDEN);
                    }
                    if (wFlags & UISF_ACTIVE) {
                        SetWF(pwnd, WEFPUIACTIVE);
                    }
                    break;

                case UIS_CLEAR:
                    if (wFlags & UISF_HIDEACCEL) {
                        ClrWF(pwnd, WEFPUIACCELHIDDEN);
                    }
                    if (wFlags & UISF_HIDEFOCUS) {
                        ClrWF(pwnd, WEFPUIFOCUSHIDDEN);
                    }
                    if (wFlags & UISF_ACTIVE) {
                        ClrWF(pwnd, WEFPUIACTIVE);
                    }
                    break;

                default:
                    break;
             }

            /*
             * Send it down to its immediate children if any
             */
             if (pwnd->spwndChild) {

                PBWL pbwl;
                HWND *phwnd;
                TL tlpwnd;

                pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
                if (pbwl == NULL)
                    return 0;

                for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
                    /*
                     * Make sure this hwnd is still around.
                     */
                    if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                        continue;

                    ThreadLockAlways(pwnd, &tlpwnd);
                    xxxSendMessage(pwnd, message, wParam, lParam);
                    ThreadUnlock(&tlpwnd);
                }
                FreeHwndList(pbwl);
            }
        }
        break;

#ifdef PENWIN20
    // LATER mikeke
    default:
        // BOGUS
        // 32-bit ize DefPenWindowProc
        //
        // call DefPenWindowProc if penwin is loaded
        if (   (message >= WM_HANDHELDFIRST)
            && (message <= WM_HANDHELDLAST)
           ) {
            if (lpfnHandHeld != NULL)
                return (*lpfnHandHeld)(HW16(pwnd), message, wParamLo, lParam);
        } else if (   (message >= WM_PENWINFIRST)
                   && (message <= WM_PENWINLAST)
                  ) {
            if (SYSMET(PENWINDOWS))
                return DefPenWindowProc(pwnd, message, wParamLo, lParam);
        }

#endif // PENWIN20
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ex.c ===
/**************************** Module Header ********************************\
* Module Name: ex.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Executive support routines
*
* History:
* 03-04-95 JimA       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
OpenEffectiveToken(
    PHANDLE phToken)
{
    NTSTATUS Status;

    /*
     * Open the client's token.
     */
    Status = ZwOpenThreadTokenEx(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 (BOOLEAN)TRUE,     // OpenAsSelf
                 OBJ_KERNEL_HANDLE,
                 phToken);
    if (Status == STATUS_NO_TOKEN) {

        /*
         * Client wasn't impersonating anyone.  Open its process token.
         */
        Status = ZwOpenProcessTokenEx(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     OBJ_KERNEL_HANDLE,
                     phToken);
    }

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Can't open client's token! - Status = %lx", Status);
    }
    return Status;
}

NTSTATUS
GetProcessLuid(
    PETHREAD Thread,
    PLUID LuidProcess
    )
{
    PACCESS_TOKEN UserToken = NULL;
    BOOLEAN fCopyOnOpen;
    BOOLEAN fEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    NTSTATUS Status;

    if (Thread == NULL)
        Thread = PsGetCurrentThread();

    //
    // Check for a thread token first
    //

    UserToken = PsReferenceImpersonationToken(Thread,
            &fCopyOnOpen, &fEffectiveOnly, &ImpersonationLevel);

    if (UserToken == NULL) {

        //
        // No thread token, go to the process
        //

        UserToken = PsReferencePrimaryToken(PsGetThreadProcess(Thread));
        if (UserToken == NULL)
            return STATUS_NO_TOKEN;
    }

    Status = SeQueryAuthenticationIdToken(UserToken, LuidProcess);

    //
    // We're finished with the token
    //

    ObDereferenceObject(UserToken);

    return Status;
}


BOOLEAN IsRestricted(
    PETHREAD Thread)
{
    PACCESS_TOKEN UserToken;
    BOOLEAN fCopyOnOpen;
    BOOLEAN fEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    BOOLEAN fRestricted = FALSE;

    /*
     * Check for a thread token first.
     */
    UserToken = PsReferenceImpersonationToken(Thread,
            &fCopyOnOpen, &fEffectiveOnly, &ImpersonationLevel);

    /*
     * If no thread token, go to the process.
     */
    if (UserToken == NULL) {
        UserToken = PsReferencePrimaryToken(PsGetThreadProcess(Thread));
    }

    /*
     * If we got a token, is it restricted?
     */
    if (UserToken != NULL) {
        fRestricted = SeTokenIsRestricted(UserToken);
        ObDereferenceObject(UserToken);
    }

    return fRestricted;
}

NTSTATUS InitSystemThread(
    PUNICODE_STRING pstrThreadName)
{
    PETHREAD pEThread;
    PEPROCESS Process;
    PTHREADINFO pti;
    NTSTATUS Status = STATUS_SUCCESS;

    CheckCritOut();

    pEThread = PsGetCurrentThread();
    Process = PsGetThreadProcess(pEThread);

    ValidateThreadSessionId(pEThread);

    /*
     * check to see if process is already set, if not, we
     * need to set it up as well
     */
    UserAssert(PsGetProcessWin32Process(Process));

    EnterCrit();

    /*
     * Flag this as a system thread
     */

    pti = PtiCurrentShared();

    /*
     * This is a CSRSS thread and we want to just convert it to a system thread,
     * Then changes the TIF flags and allocate a kernel side pClientInfo.
     */
    UserAssert((pti->TIF_flags & TIF_CSRSSTHREAD) && !(pti->TIF_flags & TIF_SYSTEMTHREAD));

#if DBG
    try {
        UserAssert(pti->pClientInfo == ((PCLIENTINFO)((NtCurrentTeb())->Win32ClientInfo)));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }
#endif

    pti->pClientInfo = UserAllocPoolWithQuota(sizeof(CLIENTINFO),
                                              TAG_CLIENTTHREADINFO);
    if (pti->pClientInfo == NULL) {
        LeaveCrit();
        return STATUS_NO_MEMORY;
    }
    pti->TIF_flags &= ~TIF_CSRSSTHREAD;
    pti->TIF_flags |= TIF_SYSTEMTHREAD;
    INITCLIENTINFO(pti);

    if (pstrThreadName) {
        if (pti->pstrAppName != NULL)
            UserFreePool(pti->pstrAppName);
        pti->pstrAppName = UserAllocPoolWithQuota(sizeof(UNICODE_STRING) +
                pstrThreadName->Length + sizeof(WCHAR), TAG_TEXT);
        if (pti->pstrAppName != NULL) {
            pti->pstrAppName->Buffer = (PWCHAR)(pti->pstrAppName + 1);
            RtlCopyMemory(pti->pstrAppName->Buffer, pstrThreadName->Buffer,
                    pstrThreadName->Length);
            pti->pstrAppName->Buffer[pstrThreadName->Length / sizeof(WCHAR)] = 0;
            pti->pstrAppName->MaximumLength = pstrThreadName->Length + sizeof(WCHAR);
            pti->pstrAppName->Length = pstrThreadName->Length;
        }
    }

    /*
     * Need to clear the W32PF_APPSTARTING bit so that windows created by
     * the RIT don't cause the cursor to change to the app starting cursor.
     */
    if (pti->ppi != NULL && (pti->ppi->W32PF_Flags & W32PF_APPSTARTING)) {
        ClearAppStarting(pti->ppi);
    }

Error:
    LeaveCrit();

    return Status;
}

NTSTATUS CommitReadOnlyMemory(
    HANDLE hSection,
    PSIZE_T pCommitSize,
    DWORD dwCommitOffset,
    int*  pdCommit)
{
    SIZE_T ulViewSize;
    LARGE_INTEGER liOffset;
    PEPROCESS Process;
    PVOID pUserBase, pvt;
    NTSTATUS Status;

    ulViewSize = 0;
    pUserBase = NULL;
    liOffset.QuadPart = 0;
    Process = PsGetCurrentProcess();

    Status = MmMapViewOfSection(
            hSection,
            Process,
            &pUserBase,
            0,
            PAGE_SIZE,
            &liOffset,
            &ulViewSize,
            ViewUnmap,
            SEC_NO_CHANGE,
            PAGE_EXECUTE_READ);

    if (NT_SUCCESS(Status)) {

        /*
         * Commit the memory
         */
        pUserBase = pvt = (PVOID)((PBYTE)pUserBase + dwCommitOffset);

        Status = ZwAllocateVirtualMemory(
                NtCurrentProcess(),
                &pUserBase,
                0,
                pCommitSize,
                MEM_COMMIT,
                PAGE_EXECUTE_READ);

        if (pdCommit) {
            *pdCommit = (int)((PBYTE)pUserBase - (PBYTE)pvt);
        } else {
            UserAssert(pvt == pUserBase);
        }

        MmUnmapViewOfSection(Process, pUserBase);
    }

    return Status;
}

/***************************************************************************\
* CreateKernelEvent
*
* Creates a kernel event.  This is used when reference counted events
* created by ZwCreateEvent are not needed.
*
* History:
* 06-26-95 JimA             Created.
\***************************************************************************/
PKEVENT CreateKernelEvent(
    IN EVENT_TYPE Type,
    IN BOOLEAN State)
{
    PKEVENT pEvent;

    pEvent = UserAllocPoolNonPagedNS(sizeof(KEVENT), TAG_SYSTEM);
    if (pEvent != NULL) {
        KeInitializeEvent(pEvent, Type, State);
    }

    return pEvent;
}

/***************************************************************************\
* LockObjectAssignment
*
* References an object into a data structure
*
* History:
* 06-26-95 JimA             Created.
\***************************************************************************/
VOID LockObjectAssignment(
    PVOID *pplock,
    PVOID pobject
#ifdef LOGDESKTOPLOCKS
    ,DWORD tag,
    ULONG_PTR extra
#endif
    )
{
    PVOID pobjectOld;

    /*
     * Save old object to dereference AFTER the new object is referenced.
     * This will avoid problems with relocking the same object.
     */
    pobjectOld = *pplock;

    /*
     * Reference the new object.
     */
    if (pobject != NULL) {
        ObReferenceObject(pobject);
#ifdef LOGDESKTOPLOCKS
        if (OBJECT_TO_OBJECT_HEADER(pobject)->Type == *ExDesktopObjectType) {
            LogDesktop(pobject, tag, TRUE, extra);
        }
#endif
    }
    *pplock = pobject;

    /*
     * Dereference the old object.
     */
    if (pobjectOld != NULL) {
#ifdef LOGDESKTOPLOCKS
        if (OBJECT_TO_OBJECT_HEADER(pobjectOld)->Type == *ExDesktopObjectType) {
            LogDesktop(pobjectOld, tag, FALSE, extra);
        }
#endif
        ObDereferenceObject(pobjectOld);
    }
}

/***************************************************************************\
* UnlockObjectAssignment
*
* Dereferences an object locked into a data structure
*
* History:
* 06-26-95 JimA             Created.
\***************************************************************************/
VOID UnlockObjectAssignment(
    PVOID *pplock
#ifdef LOGDESKTOPLOCKS
    ,DWORD tag,
    ULONG_PTR extra
#endif
    )
{
    if (*pplock != NULL) {
        PVOID plock = *pplock;
#ifdef LOGDESKTOPLOCKS
        if (OBJECT_TO_OBJECT_HEADER(*pplock)->Type == *ExDesktopObjectType) {
            LogDesktop(*pplock, tag, FALSE, extra);
        }
#endif
        *pplock = NULL;
        ObDereferenceObject(plock);
    }
}

/***************************************************************************\
* UserDereferenceObject
*
* We need this for thread locking stuff since ObDereferenceObject is a macro.
*
* 09-21-98 JerrySh          Created.
\***************************************************************************/
VOID UserDereferenceObject(
    PVOID pobj)
{
    ObDereferenceObject(pobj);
}


/***************************************************************************\
* ProtectHandle
*
* This api is used set and clear close protection on handles used
* by the kernel.
*
* 08-18-95 JimA             Created.
\***************************************************************************/
NTSTATUS ProtectHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE pObjectType,
    IN BOOLEAN Protect)
{
    OBJECT_HANDLE_INFORMATION HandleInfo;
    OBJECT_HANDLE_FLAG_INFORMATION HandleFlagInfo;
    NTSTATUS Status;
    PVOID pObject = NULL;

    Status = ObReferenceObjectByHandle(
        Handle,
        EVENT_ALL_ACCESS,
        pObjectType,
        UserMode,
        &pObject,
        &HandleInfo);
    if (NT_SUCCESS(Status)) {
        HandleFlagInfo.Inherit = (HandleInfo.HandleAttributes & OBJ_INHERIT) ? TRUE : FALSE;
        HandleFlagInfo.ProtectFromClose = Protect;

        Status = ObSetHandleAttributes(
            Handle,
            &HandleFlagInfo,
            UserMode);
    }

    if (pObject) {
        ObDereferenceObject(pObject);
    }

    return Status;
}

#ifdef LOGDESKTOPLOCKS

#define LOG_DELTA   8

PLogD GrowLogIfNecessary(
    PDESKTOP pdesk)
{
    if (pdesk->nLogCrt < pdesk->nLogMax) {
        UserAssert(pdesk->pLog != NULL);
        return pdesk->pLog;
    }

    /*
     * Grow the buffer
     */
    if (pdesk->pLog == NULL) {

        UserAssert(pdesk->nLogMax == 0 && pdesk->nLogCrt == 0);

        pdesk->pLog = (PLogD)UserAllocPool(LOG_DELTA * sizeof(LogD), TAG_LOGDESKTOP);

    } else {
        pdesk->pLog = (PLogD)UserReAllocPool(pdesk->pLog,
                                             pdesk->nLogCrt * sizeof(LogD),
                                             (pdesk->nLogCrt + LOG_DELTA) * sizeof(LogD),
                                             TAG_LOGDESKTOP);
    }

    UserAssert(pdesk->pLog != NULL);

    pdesk->nLogMax += LOG_DELTA;

    return pdesk->pLog;
}

/***************************************************************************\
* LogDesktop
*
* Log the lock/unlock calls for desktop objects
*
* Dec-2-97 clupu            Created.
\***************************************************************************/
VOID LogDesktop(
    PDESKTOP pdesk,
    DWORD    tag,
    BOOL     bLock,
    ULONG_PTR extra)
{
    DWORD tag1 = 0, tag2 = 0;
    PLogD pLog;

    if (pdesk == NULL) {
        return;
    }

    /*
     * The tag stored in LogD structure is actually a WORD.
     */
    UserAssert(HIWORD(tag) == 0);

    if (bLock) {
        (pdesk->nLockCount)++;

growAndAdd:
        /*
         * grow the table if necessary and add the new
         * lock/unlock information to it
         */
        pLog = GrowLogIfNecessary(pdesk);

        pLog += pdesk->nLogCrt;

        pLog->tag   = (WORD)tag;
        pLog->type  = (WORD)bLock;
        pLog->extra = extra;

        RtlZeroMemory(pLog->trace, 6 * sizeof(PVOID));

        RtlWalkFrameChain(pLog->trace, 6, 0);

        (pdesk->nLogCrt)++;
        return;
    }

    /*
     * It's an unlock.
     * First search for a matching lock
     */
    UserAssert(pdesk->nLockCount > 0);

    switch (tag) {
    case LDU_CLS_DESKPARENT1:
        tag1 = LDL_CLS_DESKPARENT1;
        break;
    case LDU_CLS_DESKPARENT2:
        tag1 = LDL_CLS_DESKPARENT1;
        tag2 = LDL_CLS_DESKPARENT2;
        break;
    case LDU_FN_DESTROYCLASS:
        tag1 = LDL_FN_DESTROYCLASS;
        break;
    case LDU_FN_DESTROYMENU:
        tag1 = LDL_FN_DESTROYMENU;
        break;
    case LDU_FN_DESTROYTHREADINFO:
        tag1 = LDL_FN_DESTROYTHREADINFO;
        break;
    case LDU_FN_DESTROYWINDOWSTATION:
        tag1 = LDL_FN_DESTROYWINDOWSTATION;
        break;
    case LDU_DESKDISCONNECT:
        tag1 = LDL_DESKDISCONNECT;
        break;
    case LDU_DESK_DESKNEXT:
        tag1 = LDL_DESK_DESKNEXT1;
        break;
    case LDU_OBJ_DESK:
        tag1 = LDL_OBJ_DESK;
        tag2 = LDL_MOTHERDESK_DESK1;
        break;
    case LDL_PTI_DESK:
        tag1 = LDL_PTI_DESK;
        tag2 = LDL_DT_DESK;
        break;
    case LDU_PTI_DESK:
        tag1 = LDL_PTI_DESK;
        break;
    case LDU_PPI_DESKSTARTUP1:
    case LDU_PPI_DESKSTARTUP2:
    case LDU_PPI_DESKSTARTUP3:
        tag1 = LDL_PPI_DESKSTARTUP1;
        tag2 = LDL_PPI_DESKSTARTUP2;
        break;
    case LDU_DESKLOGON:
        tag1 = LDL_DESKLOGON;
        break;

    case LDUT_FN_FREEWINDOW:
        tag1 = LDLT_FN_FREEWINDOW;
        break;
    case LDUT_FN_DESKTOPTHREAD_DESK:
        tag1 = LDLT_FN_DESKTOPTHREAD_DESK;
        break;
    case LDUT_FN_DESKTOPTHREAD_DESKTEMP:
        tag1 = LDLT_FN_DESKTOPTHREAD_DESKTEMP;
        break;
    case LDUT_FN_SETDESKTOP:
        tag1 = LDLT_FN_SETDESKTOP;
        break;
    case LDUT_FN_NTUSERSWITCHDESKTOP:
        tag1 = LDLT_FN_NTUSERSWITCHDESKTOP;
        break;
    case LDUT_FN_SENDMESSAGEBSM1:
    case LDUT_FN_SENDMESSAGEBSM2:
        tag1 = LDLT_FN_SENDMESSAGEBSM;
        break;
    case LDUT_FN_SYSTEMBROADCASTMESSAGE:
        tag1 = LDLT_FN_SYSTEMBROADCASTMESSAGE;
        break;
    case LDUT_FN_CTXREDRAWSCREEN:
        tag1 = LDLT_FN_CTXREDRAWSCREEN;
        break;
    case LDUT_FN_CTXDISABLESCREEN:
        tag1 = LDLT_FN_CTXDISABLESCREEN;
        break;

    case LD_DEREF_FN_CREATEDESKTOP1:
    case LD_DEREF_FN_CREATEDESKTOP2:
    case LD_DEREF_FN_CREATEDESKTOP3:
        tag1 = LD_REF_FN_CREATEDESKTOP;
        break;
    case LD_DEREF_FN_OPENDESKTOP:
        tag1 = LD_REF_FN_OPENDESKTOP;
        break;
    case LD_DEREF_FN_SETDESKTOP:
        tag1 = LD_REF_FN_SETDESKTOP;
        break;
    case LD_DEREF_FN_GETTHREADDESKTOP:
        tag1 = LD_REF_FN_GETTHREADDESKTOP;
        break;
    case LD_DEREF_FN_CLOSEDESKTOP1:
    case LD_DEREF_FN_CLOSEDESKTOP2:
        tag1 = LD_REF_FN_CLOSEDESKTOP;
        break;
    case LD_DEREF_FN_RESOLVEDESKTOP:
        tag1 = LD_REF_FN_RESOLVEDESKTOP;
        break;
    case LD_DEREF_VALIDATE_HDESK1:
    case LD_DEREF_VALIDATE_HDESK2:
    case LD_DEREF_VALIDATE_HDESK3:
    case LD_DEREF_VALIDATE_HDESK4:
        tag1 = LDL_VALIDATE_HDESK;
        break;
    case LDUT_FN_CREATETHREADINFO1:
    case LDUT_FN_CREATETHREADINFO2:
        tag1 = LDLT_FN_CREATETHREADINFO;
        break;
    case LD_DEREF_FN_SETCSRSSTHREADDESKTOP1:
    case LD_DEREF_FN_SETCSRSSTHREADDESKTOP2:
        tag1 = LD_REF_FN_SETCSRSSTHREADDESKTOP;
        break;
    case LD_DEREF_FN_CONSOLECONTROL1:
        tag1 = LD_REF_FN_CONSOLECONTROL1;
        break;
    case LD_DEREF_FN_CONSOLECONTROL2:
        tag1 = LD_REF_FN_CONSOLECONTROL2;
        break;
    case LD_DEREF_FN_GETUSEROBJECTINFORMATION:
        tag1 = LD_REF_FN_GETUSEROBJECTINFORMATION;
        break;
    case LD_DEREF_FN_SETUSEROBJECTINFORMATION:
        tag1 = LD_REF_FN_SETUSEROBJECTINFORMATION;
        break;
    case LD_DEREF_FN_CREATEWINDOWSTATION:
        tag1 = LD_REF_FN_CREATEWINDOWSTATION;
        break;

    case LDL_TERM_DESKDESTROY1:
        tag1 = LDL_TERM_DESKDESTROY2;
        break;
    case LDL_MOTHERDESK_DESK1:
        tag1 = LDL_MOTHERDESK_DESK1;
        tag2 = LDL_MOTHERDESK_DESK2;
        break;
    case LDL_WINSTA_DESKLIST2:
        tag1 = LDL_WINSTA_DESKLIST1;
        break;
    case LDL_DESKRITINPUT:
    case LDU_DESKRITINPUT:
        tag1 = LDL_DESKRITINPUT;
        break;
    }

    if (tag1 != 0) {

        int ind;

        /*
         * this is an unlock we know about. Let's find the
         * matching lock in the table. We start searching
         * the table backwords.
         */
        for (ind = pdesk->nLogCrt - 1; ind >= 0; ind--) {
            pLog = pdesk->pLog + ind;

            if (pLog->type == 1 &&
                (pLog->tag == tag1 || pLog->tag == tag2) &&
                pLog->extra == extra) {

                /*
                 * match found. remove the lock
                 */
                RtlMoveMemory(pdesk->pLog + ind,
                              pdesk->pLog + ind + 1,
                              (pdesk->nLogCrt - ind - 1) * sizeof(LogD));

                (pdesk->nLogCrt)--;

                (pdesk->nLockCount)--;

                if (pdesk->nLockCount == 0) {
                    RIPMSG1(RIP_VERBOSE, "Lock count 0 for pdesk %#p\n", pdesk);
                }

                return;
            }
        }

        /*
         * We didn't find the matching lock and we were supposed to.
         * Just add it to the table and we'll look at it.
         */
        RIPMSG3(RIP_WARNING, "Didn't find matching lock for pdesk %#p tag %d extra %lx\n",
                pdesk, tag, extra);
    }
    (pdesk->nLockCount)--;

    goto growAndAdd;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\enumwin.c ===
/****************************** Module Header ******************************\
* Module Name: enumwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the EnumWindows API, BuildHwndList and related functions.
*
* History:
* 10-20-90 darrinm      Created.
* ??-??-?? ianja        Added Revalidation code
* 02-19-91 JimA         Added enum access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PBWL pbwlCache;

#if DBG
PBWL pbwlCachePrev;
#endif

PBWL InternalBuildHwndList(PBWL pbwl, PWND pwnd, UINT flags);
PBWL InternalBuildHwndOwnerList(PBWL pbwl, PWND pwndStart, PWND pwndOwner);
#ifdef FE_IME
PBWL InternalRebuildHwndListForIMEClass(PBWL pbwl, BOOL fRemoveChild);
PWND InternalGetIMEOwner(HWND hwnd, BOOL fRetIMEWnd);
#endif


/***************************************************************************\
* xxxInternalEnumWindow
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 02-06-91 IanJa        rename: the call to lpfn can leave the critsect.
* 02-19-91 JimA         Added enum access check
\***************************************************************************/

BOOL xxxInternalEnumWindow(
    PWND pwndNext,
    WNDENUMPROC_PWND lpfn,
    LPARAM lParam,
    UINT flags)
{
    HWND *phwnd;
    PWND pwnd;
    PBWL pbwl;
    BOOL fSuccess;
    TL tlpwnd;

    CheckLock(pwndNext);

    if ((pbwl = BuildHwndList(pwndNext, flags, NULL)) == NULL)
        return FALSE;

    fSuccess = TRUE;
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Lock the window before we pass it off to the app.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) != NULL) {

            /*
             * Call the application.
             */
            ThreadLockAlways(pwnd, &tlpwnd);
            fSuccess = (*lpfn)(pwnd, lParam);
            ThreadUnlock(&tlpwnd);
            if (!fSuccess)
                break;
        }
    }

    FreeHwndList(pbwl);

    return fSuccess;
}


/***************************************************************************\
* BuildHwndList
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

#define CHWND_BWLCREATE 32

PBWL BuildHwndList(
    PWND pwnd,
    UINT flags,
    PTHREADINFO pti)
{
    PBWL pbwl;

    CheckCritIn();

    if ((pbwl = pbwlCache) != NULL) {

        /*
         * We're using the cache now; zero it out.
         */
#if DBG
        pbwlCachePrev = pbwlCache;
#endif
        pbwlCache = NULL;

#if DBG
        {
            PBWL pbwlT;
            /*
             * pbwlCache shouldn't be in the global linked list.
             */
            for (pbwlT = gpbwlList; pbwlT != NULL; pbwlT = pbwlT->pbwlNext) {
                UserAssert(pbwlT != pbwl);
            }
        }
#endif
    } else {

        /*
         * sizeof(BWL) includes the first element of array.
         */
        pbwl = (PBWL)UserAllocPool(sizeof(BWL) + sizeof(PWND) * CHWND_BWLCREATE,
                TAG_WINDOWLIST);
        if (pbwl == NULL)
            return NULL;

        pbwl->phwndMax = &pbwl->rghwnd[CHWND_BWLCREATE - 1];
    }
    pbwl->phwndNext = pbwl->rghwnd;

    /*
     * We'll use ptiOwner as temporary storage for the thread we're
     * scanning for. It will get reset to the proper thing at the bottom
     * of this routine.
     */
    pbwl->ptiOwner = pti;

#ifdef OWNERLIST
    if (flags & BWL_ENUMOWNERLIST) {
        pbwl = InternalBuildHwndOwnerList(pbwl, pwnd, NULL);
    } else {
        pbwl = InternalBuildHwndList(pbwl, pwnd, flags);
    }
#else
    pbwl = InternalBuildHwndList(pbwl, pwnd, flags);
#endif

    /*
     * If phwndNext == phwndMax, it indicates that the pbwl has failed to expand.
     * The list is no longer valid, so we should just bail.
     */
    if (pbwl->phwndNext >= pbwl->phwndMax) {
        UserAssert(pbwl->phwndNext == pbwl->phwndMax);
        /*
         * Even if we had picked pbwl from the global single cache (pbwlCache),
         * it should have already been unlinked from the global link list when it was put in the cache.
         * So we should just free it without manupilating the link pointers.
         * If we have allocated the pwbl for ourselves, we can simply free it.
         * In both cases, we should just call UserFreePool().
         * As the side effect, it may make some room by providing a free pool block.
         */
        UserFreePool(pbwl);
        return NULL;
    }

    /*
     * Stick in the terminator.
     */
    *pbwl->phwndNext = (HWND)1;

#ifdef FE_IME
    if (flags & BWL_ENUMIMELAST) {
        UserAssert(IS_IME_ENABLED());
        /*
         * For IME windows.
         * Rebuild window list for EnumWindows API. Because ACCESS 2.0 assumes
         * the first window that is called CallBack Functions in the task is
         * Q-Card Wnd. We should change the order of IME windows
         */
        pbwl = InternalRebuildHwndListForIMEClass(pbwl,
                    (flags & BWL_REMOVEIMECHILD) == BWL_REMOVEIMECHILD);
    }
#endif

    /*
     * Finally link this guy into the list.
     */
    pbwl->ptiOwner = PtiCurrent();
    pbwl->pbwlNext = gpbwlList;
    gpbwlList = pbwl;


    /*
     * We should have given out the cache if it was available
     */
    UserAssert(pbwlCache == NULL);

    return pbwl;
}

/***************************************************************************\
* ExpandWindowList
*
* This routine expands a window list.
*
* 01-16-92 ScottLu      Created.
\***************************************************************************/

BOOL ExpandWindowList(
    PBWL *ppbwl)
{
    PBWL pbwl;
    PBWL pbwlT;
    HWND *phwnd;

    pbwl = *ppbwl;
    phwnd = pbwl->phwndNext;

    /*
     * Map phwnd to an offset.
     */
    phwnd = (HWND *)((BYTE *)phwnd - (BYTE *)pbwl);

    /*
     * Increase size of BWL by 8 slots.  (8 + 1) is
     * added since phwnd is "sizeof(HWND)" less
     * than actual size of handle.
     */
    pbwlT = (PBWL)UserReAllocPool((HANDLE)pbwl,
            PtrToUlong(phwnd) + sizeof(PWND),
            PtrToUlong(phwnd) + (BWL_CHWNDMORE + 1) * sizeof(PWND),
            TAG_WINDOWLIST);

    /*
     * Did alloc succeed?
     */
    if (pbwlT != NULL)
        pbwl = pbwlT;                 /* Yes, use new block. */

    /*
     * Map phwnd back into a pointer.
     */
    phwnd = (HWND *)((ULONG_PTR)pbwl + (ULONG_PTR)phwnd);

    /*
     * Did ReAlloc() fail?
     */
    if (pbwlT == NULL) {
        RIPMSG0(RIP_WARNING, "ExpandWindowList: out of memory.");
        return FALSE;
    }

    /*
     * Reset phwndMax.
     */
    pbwl->phwndNext = phwnd;
    pbwl->phwndMax = phwnd + BWL_CHWNDMORE;

    *ppbwl = pbwl;

    return TRUE;
}

#ifdef OWNERLIST

/***************************************************************************\
* InternalBuildHwndOwnerList
*
* Builds an hwnd list sorted by owner. Ownees go first. Shutdown uses this for
* WM_CLOSE messages.
*
* 01-16-93 ScottLu      Created.
\***************************************************************************/

PBWL InternalBuildHwndOwnerList(
    PBWL pbwl,
    PWND pwndStart,
    PWND pwndOwner)
{
    PWND pwndT;

    /*
     * Put ownees first in the list.
     */
    for (pwndT = pwndStart; pwndT != NULL; pwndT = pwndT->spwndNext) {

        /*
         * Not the ownee we're looking for? Continue.
         */
        if (pwndT->spwndOwner != pwndOwner)
            continue;

        /*
         * Only top level windows that have system menus (the ones that can
         * receive a WM_CLOSE message).
         */
        if (!TestWF(pwndT, WFSYSMENU))
            continue;

        /*
         * Add it and its ownees to our list.
         */
        pbwl = InternalBuildHwndOwnerList(pbwl, pwndStart, pwndT);

        /*
         * If ExpandWindowList() failed in recursive calls,
         * just bail here.
         */
        if (pbwl->phwndNext >= pbwl->phwndMax) {
            UserAssert(pbwl->phwndNext == pbwl->phwndMax);
            return pbwl;
        }
        UserAssert(pbwl->phwndNext < pbwl->phwndMax);
    }

    /*
     * Finally add this owner to our list.
     */
    if (pwndOwner != NULL) {
        UserAssert(pbwl->phwndNext < pbwl->phwndMax);
        *pbwl->phwndNext = HWq(pwndOwner);
        pbwl->phwndNext++;
        if (pbwl->phwndNext == pbwl->phwndMax) {
            if (!ExpandWindowList(&pbwl))
                return pbwl;
        }
    }

    return pbwl;
}

#endif

/***************************************************************************\
* InternalBuildHwndList
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

#define BWLGROW 8

PBWL InternalBuildHwndList(
    PBWL pbwl,
    PWND pwnd,
    UINT flags)
{
    /*
     * NOTE: pbwl->phwndNext is used as a place to keep
     *       the phwnd across calls to InternalBuildHwndList().
     *       This is OK since we don't link pbwl into the list
     *       of pbwl's until after we've finished enumerating windows.
     */

    while (pwnd != NULL) {
        /*
         * Make sure it matches the thread id, if there is one.
         */
        if (pbwl->ptiOwner == NULL || pbwl->ptiOwner == GETPTI(pwnd)) {
            UserAssert(pbwl->phwndNext < pbwl->phwndMax);
            *pbwl->phwndNext = HWq(pwnd);
            pbwl->phwndNext++;
            if (pbwl->phwndNext == pbwl->phwndMax) {
#if EMULATE_EXPAND_FAILURE
                static int n = 0;
                if (++n % 32 == 0) {
                    RIPMSG0(RIP_WARNING, "InternalBuildHwndList: emulating ExpandWindowList failure.");
                    break;
                }
#endif
                if (!ExpandWindowList(&pbwl))
                    break;
            }
        }

        /*
         * Should we step through the Child windows?
         */
        if ((flags & BWL_ENUMCHILDREN) && pwnd->spwndChild != NULL) {
            pbwl = InternalBuildHwndList(pbwl, pwnd->spwndChild, BWL_ENUMLIST | BWL_ENUMCHILDREN);
            /*
             * If ExpandWindowList() failed in the recursive call,
             * we should just bail.
             */
            if (pbwl->phwndNext >= pbwl->phwndMax) {
                UserAssert(pbwl->phwndNext == pbwl->phwndMax);
                RIPMSG1(RIP_WARNING, "InternalBuildHwndList: failed to expand BWL in enumerating children. pbwl=%#p", pbwl);
                break;
            }
            UserAssert(pbwl->phwndNext < pbwl->phwndMax);
        }

        /*
         * Are we enumerating only one window?
         */
        if (!(flags & BWL_ENUMLIST))
            break;

        pwnd = pwnd->spwndNext;
    }

    return pbwl;
}


/***************************************************************************\
* FreeHwndList
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void FreeHwndList(
    PBWL pbwl)
{
    PBWL *ppbwl;
    PBWL pbwlT;

    CheckCritIn();

    /*
     * We should never have an active bwl that is the free cached bwl
     */
    UserAssert(pbwl != pbwlCache);

    /*
     * Unlink this bwl from the list.
     */
    for (ppbwl = &gpbwlList; *ppbwl != NULL; ppbwl = &(*ppbwl)->pbwlNext) {
        if (*ppbwl == pbwl) {
            *ppbwl = pbwl->pbwlNext;

            /*
             * If the cache is empty or this pbwl is larger than the
             * cached one, save the pbwl there.
             */
            if (pbwlCache == NULL) {
                pbwlCache = pbwl;
            } else if ((pbwl->phwndMax - pbwl->rghwnd) >
                       (pbwlCache->phwndMax - pbwlCache->rghwnd)) {
                pbwlT = pbwlCache;
                pbwlCache = pbwl;
                UserFreePool((HANDLE)pbwlT);
            } else {
                UserFreePool((HANDLE)pbwl);
            }
            return;
        }
    }

    /*
     * Assert if we couldn't find the pbwl in the list...
     */
    UserAssert(FALSE);
}

#ifdef FE_IME

PBWL InternalRebuildHwndListForIMEClass(
    PBWL pbwl,
    BOOL fRemoveChild)
{
    PHWND phwndIME, phwndIMECur, phwnd, phwndCur;
    DWORD dwSize = (DWORD)((BYTE *)pbwl->phwndMax - (BYTE *)pbwl) + sizeof(HWND);

    phwndIMECur = phwndIME = (PHWND)UserAllocPool(dwSize, TAG_WINDOWLIST);
    if (phwndIME == NULL) {
        RIPMSG0(RIP_WARNING, "RebuildHwndListForIMEClass: invalid phwndIME");
        return pbwl;
    }

    phwndCur = pbwl->rghwnd;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        PWND pwndIMEOwner;

        // Find the IME class or CS_IME window in the owners of hwnd.
        // When fRemoveChild is TRUE, we want IME class window as the return
        // of InternalGetIMEOwner.
        if (pwndIMEOwner = InternalGetIMEOwner(*phwnd, fRemoveChild)) {
            try {
                if (!fRemoveChild ||
                    (pwndIMEOwner->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME] &&
                      ((PIMEWND)pwndIMEOwner)->pimeui != NULL &&
                     !ProbeAndReadStructure(((PIMEWND)pwndIMEOwner)->pimeui, IMEUI).fChildThreadDef))
                {
                    *phwndIMECur++ = *phwnd;
                }
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
        } else {
            *phwndCur++ = *phwnd;
        }
    }

    // Here NULL s used as terminator.
    *phwndIMECur = NULL;

    phwndIMECur = phwndIME;
    while(*phwndIMECur != NULL)
        *phwndCur++ = *phwndIMECur++;

    if (*phwndCur != (HWND)1) {
        RIPMSG0(RIP_WARNING, "RebuildHwndListForIMEClass: Where is terminator?");
        *phwndCur = (HWND)1;
    }

    UserFreePool((HANDLE)phwndIME);
    return pbwl;
}

PWND InternalGetIMEOwner(
    HWND hwnd,
    BOOL fRetIMEWnd)
{
    PWND pwnd, pwndT, pwndIME;

    pwnd = RevalidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;

    for (pwndT = pwnd; pwndT != NULL; pwndT = pwndT->spwndOwner) {
        if (TestCF(pwndT,CFIME) ||
                pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {

            if (!fRetIMEWnd)
                return pwndT;

            pwndIME = pwndT;

            while (pwndT && (pwndT->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]))
                pwndT = pwndT->spwndOwner;

            if (pwndT)
                pwndIME = pwndT;
            else
                RIPMSG0(RIP_WARNING, "Can't find IME Class window");

            return pwndIME;
        }
    }

    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\event.c ===
/****************************** Module Header ******************************\
* Module Name: event.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager event module - this is a fancy way of allowing interprocess
*   communication across security contexts.  This is needed because the
*   DDE Access Object security may be different than hwnd security so
*   straight messages arn't good enough.
*
* Created: 8/27/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


DWORD MonitorFlags = 0;     // current filter flags being monitored by someone.

typedef struct tagMONITOR_COUNT {
    int iCount;
    DWORD flag;
} MONITOR_COUNT, *PMONITOR_COUNT;

#define C_MONITOR_COUNT 10

MONITOR_COUNT aMonitorCount[C_MONITOR_COUNT] = {
    { 0, MF_HSZ_INFO },
    { 0, MF_SENDMSGS },
    { 0, MF_POSTMSGS },
    { 0, MF_CALLBACKS },
    { 0, MF_ERRORS },
    { 0, MF_LINKS },
    { 0, MF_CONV },
    { 0, CBF_SKIP_REGISTRATIONS },
    { 0, CBF_SKIP_UNREGISTRATIONS },
    { 0, MF_INTERNAL },
};

#define MONITORED_FLAGS \
    MF_HSZ_INFO |   \
    MF_SENDMSGS |   \
    MF_POSTMSGS |   \
    MF_CALLBACKS |   \
    MF_ERRORS |   \
    MF_LINKS |   \
    MF_CONV |   \
    CBF_SKIP_REGISTRATIONS |   \
    CBF_SKIP_UNREGISTRATIONS |   \
    MF_INTERNAL


/***************************************************************************\
* ChangeMonitorFlags
*
* Description:
*   Updates the global MonitorFlags variable to reflect the union of all
*   event types being monitored by DDEML applications.
*
* History:
* 11-26-91   sanfords    Created.
\***************************************************************************/
VOID xxxChangeMonitorFlags(
PSVR_INSTANCE_INFO psii,
DWORD afCmdNew)
{
    int i;
    DWORD dwChangedFlags;
    DWORD OldMonitorFlags;

    CheckCritIn();

    dwChangedFlags = psii->afCmd ^ afCmdNew;
    /*
     * Due to the way MONITORED_FLAGS was defined, this if stmt is always
     * false. Since it's been this way since day 1, it's now a feature.
     * Bug #105937.
     *
     * if (!(dwChangedFlags & MONITORED_FLAGS)) {
     *   return;
     * }
     */
    psii->afCmd = afCmdNew;

    OldMonitorFlags = MonitorFlags;
    MonitorFlags = 0;
    for (i = 0; i < C_MONITOR_COUNT; i++) {
        if (dwChangedFlags & aMonitorCount[i].flag) {
            if (aMonitorCount[i].flag & afCmdNew) {
                aMonitorCount[i].iCount++;
            } else {
                aMonitorCount[i].iCount--;
            }
        }
        if (aMonitorCount[i].iCount) {
            MonitorFlags |= aMonitorCount[i].flag;
        }
    }
    if (OldMonitorFlags != MonitorFlags) {
        EVENT_PACKET ep;

        ep.EventType = 0;
        ep.fSense = FALSE;
        ep.cbEventData = sizeof(DWORD);
        ep.Data = MonitorFlags;
        xxxCsEvent(&ep, sizeof(DWORD));
    }
}



/***************************************************************************\
* xxxCsEvent
*
* Description:
*   Handles broadcasting of all types of DDEML events.
*
* History:
* 11-1-91   sanfords    Created.
* 10-28-97  FritzS    added cbEventData as a passed-in parameter.  This was
                      done because the EVENT_PACKET may be client-side and
                      we capture the count to keep a hostile app from changing
                      the size after data probing.
\***************************************************************************/
DWORD xxxCsEvent(
PEVENT_PACKET pep, WORD cbEventData)
{
    PSVR_INSTANCE_INFO psiiT;
    PEVENT_PACKET pep2;
    HWND *ahwndEvent = NULL;
    PWND pwnd;
    int cHwndAllocated, i, cTargets;
    TL tlpwnd;
    TL tlpep2;
    TL tlahwndEvent;
    ULONG cbEventPacket;
    PTHREADINFO pti = PtiCurrent();

    CheckCritIn();

    /*
     * Copy pep info to a server side stable area
     */
    cbEventPacket = cbEventData + sizeof(EVENT_PACKET) - sizeof(DWORD);
    pep2 = (PEVENT_PACKET)UserAllocPoolWithQuota(cbEventPacket, TAG_DDE5);
    if (pep2 == NULL) {
        return DMLERR_MEMORY_ERROR;
    }
    try {
        RtlCopyMemory((LPSTR)pep2, (LPSTR)pep, cbEventPacket);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        UserFreePool(pep2);
        return DMLERR_INVALIDPARAMETER;
    }

    pep2->cbEventData = cbEventData;
    cTargets = 0;
    cHwndAllocated = 0;

    for (psiiT = psiiList; psiiT != NULL; psiiT =  psiiT->next) {
        //
        // Don't bother with event windows for instances who's flags
        // indicate they're not interrested in the event.
        //
        if (((psiiT->afCmd & pep2->EventType) && !pep2->fSense) ||
                (!(psiiT->afCmd & pep2->EventType) && pep2->fSense)) {
            continue;
        }

        if (cTargets >= cHwndAllocated) {
            if (ahwndEvent == NULL) {
                cHwndAllocated = 8;
                ahwndEvent = (HWND *)UserAllocPoolWithQuota(
                        sizeof(HWND) * cHwndAllocated,
                        TAG_DDE6);
            } else {
                DWORD dwSize = cHwndAllocated * sizeof(HWND);
                HWND *ahwndEventT = ahwndEvent;

                cHwndAllocated += 8;
                ahwndEvent = (HWND *)UserReAllocPoolWithQuota(ahwndEvent, dwSize,
                        sizeof(HWND) * cHwndAllocated, TAG_DDE7);
                if (ahwndEvent == NULL) {
                    UserFreePool(ahwndEventT);
                }
            }
            if (ahwndEvent == NULL) {
                UserFreePool(pep2);
                return DMLERR_MEMORY_ERROR;
            }
        }
        ahwndEvent[cTargets++] = PtoH(psiiT->spwndEvent);
    }

    ThreadLockPool(pti, pep2, &tlpep2);
    if (ahwndEvent != NULL) {
        ThreadLockPool(pti, ahwndEvent, &tlahwndEvent);
        for (i = 0; i < cTargets; i++) {
            /*
             * We need to change contexts for the callback
             */
            pwnd = ValidateHwnd(ahwndEvent[i]);
            if (pwnd != NULL) {
                ThreadLockAlwaysWithPti(pti, pwnd, &tlpwnd);
                xxxSendMessage(pwnd, WM_DDEMLEVENT, 0, (LPARAM)pep2);
                ThreadUnlock(&tlpwnd);
            }
        }
        ThreadUnlockAndFreePool(pti, &tlahwndEvent);
    }
    ThreadUnlockAndFreePool(pti, &tlpep2);

    return DMLERR_NO_ERROR;
}




/***************************************************************************\
* xxxEventWndProc
*
* Description:
*   Window proc for DDEML event windows.  These windows serve to get user
*   into the proper context for callbacks to DDEML applications.
*
* History:
* 11-1-91   sanfords    Created.
\***************************************************************************/
LRESULT xxxEventWndProc(
PWND pwnd,
UINT message,
WPARAM wParam,
LPARAM lParam)
{
    PSVR_INSTANCE_INFO psii;

    CheckCritIn();
    CheckLock(pwnd);

    psii = HMValidateHandleNoRip((HANDLE)_GetWindowLongPtr(pwnd, GWLP_PSII),
                                 TYPE_DDEACCESS);
    if (psii == NULL) {
        goto CallDWP;
    }

    switch (message) {
    case WM_DDEMLEVENT:
#define pep ((PEVENT_PACKET)lParam)
        if (((psii->afCmd & pep->EventType) && pep->fSense) ||
                (!(psii->afCmd & pep->EventType) && !pep->fSense)) {
            ClientEventCallback(psii->pcii, pep);
        }
#undef pep
        break;

    case WM_DESTROY:
        xxxChangeMonitorFlags(psii, 0);
        break;

    default:
CallDWP:
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }
    return 0;
}



/***************************************************************************\
* xxxMessageEvent
*
* Description:  Called when a hooked DDE message is sent or posted.  flags
*   specifies the applicable MF_ flag.  This is called in the server side
*   context of the sender or poster which may or may not be a DDEML process.
*   pdmhd contains DDE data extracted and copied from the client side.
*
* History:
* 12-1-91   sanfords    Created.
\***************************************************************************/
VOID xxxMessageEvent(
PWND pwndTo,
UINT message,
WPARAM wParam,
LPARAM lParam,
DWORD flag,
PDDEML_MSG_HOOK_DATA pdmhd)
{
    PEVENT_PACKET pep;
    PWND pwndFrom;
    TL tlpep;
    PTHREADINFO pti;

    CheckCritIn();

    pep = (PEVENT_PACKET)UserAllocPoolWithQuota(sizeof(EVENT_PACKET) -
            sizeof(DWORD) + sizeof(MONMSGSTRUCT), TAG_DDE8);
    if (pep == NULL) {
        return;
    }
    pep->EventType = flag;
    pep->fSense = TRUE;
    pep->cbEventData = sizeof(MONMSGSTRUCT);
#define pmsgs ((MONMSGSTRUCT *)&pep->Data)
    pmsgs->cb = sizeof(MONMSGSTRUCT);
    pmsgs->hwndTo = PtoH(pwndTo);
    pmsgs->dwTime = NtGetTickCount();

    pwndFrom = RevalidateHwnd((HWND)wParam);
    if (pwndFrom != NULL) {
        pmsgs->hTask = GETPTIID(GETPTI(pwndFrom));
    } else {
        pmsgs->hTask = 0;
    }

    pmsgs->wMsg = message;
    pmsgs->wParam = wParam;
    pmsgs->lParam = lParam;
    if (pdmhd != NULL) {
        pmsgs->dmhd = *pdmhd;
    }
#undef pmsgs
    pti = PtiCurrent();
    ThreadLockPool(pti, pep, &tlpep);
    xxxCsEvent(pep, sizeof(MONMSGSTRUCT));
    ThreadUnlockAndFreePool(pti, &tlpep);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\focusact.c ===
/****************************** Module Header ******************************\
* Module Name: focusact.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-08-90 DavidPe      Created.
* 02-11-91 JimA         Multi-desktop support.
* 02-13-91 mikeke       Added Revalidation code.
* 06-10-91 DavidPe      Changed to desynchronized model.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL RemoveEventMessage(PQ pq, DWORD dwQEvent, DWORD dwQEventStop);

/***************************************************************************\
* xxxDeactivate
*
* This routine does the processing for the event posted when the foreground
* thread changes.  Note the difference in order of assignment vs. message
* sending in the focus and active windows.  This is consistent with how
* things are done in Win 3.1.
*
*
* PTHREADINFO pti May not be ptiCurrent if SetForegroundWindow called from
* minmax
*
* History:
* 06-07-91 DavidPe      Created.
\***************************************************************************/

void xxxDeactivate(
    PTHREADINFO pti,            // May not be ptiCurrent
    DWORD tidSetForeground)
{
    PWND pwndLose;
    AAS aas;
    TL tlpwndCapture;
    TL tlpwndChild;
    TL tlpwndLose;
    TL tlpti;
    TL tlptiLose;
    WPARAM wParam;
    PTHREADINFO ptiLose;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fSetActivateAppBit = FALSE;

    /*
     * If we're not active, we have nothing to deactivate, so just return.
     * If we don't return, we'll send redundant WM_ACTIVATEAPP messages.
     * Micrografx Draw, for example, calls FreeProcInstance() twice when
     * this occurs, thereby crashing.
     */
    if (pti->pq->spwndActive == NULL)
        return;

    /*
     * If pti != ptiCurrent, thread lock pti because we may leave
     * the critical section.
     */
    if (pti != ptiCurrent)
        ThreadLockPti(ptiCurrent, pti, &tlpti);

    /*
     * Prevent an activating WM_ACTIVATEAPP from being sent
     * while we're processing this event.
     */
    if (!(pti->TIF_flags & TIF_INACTIVATEAPPMSG)) {
        pti->TIF_flags |= TIF_INACTIVATEAPPMSG;
        fSetActivateAppBit = TRUE;
    }

    /*
     * Cancel any modes like move/size and menu tracking.
     */
    if (pti->pq->spwndCapture != NULL) {
        ThreadLockAlwaysWithPti(ptiCurrent, pti->pq->spwndCapture, &tlpwndCapture);
        xxxSendMessage(pti->pq->spwndCapture, WM_CANCELMODE, 0, 0);
        ThreadUnlock(&tlpwndCapture);

        /*
         * Set QS_MOUSEMOVE so any sleeping modal loops,
         * like the move/size code, will wake up and figure
         * out that it should abort.
         */
        SetWakeBit(pti, QS_MOUSEMOVE);
    }

    /*
     * See the comments in xxxActivateThisWindow about Harvard Graphics.
     * WinWord's Equation editor does some games when it gets the WM_ACTIVATE
     * so we have to remember to send the WM_ACTIVATEAPP to ptiLose. 22510
     */
    if (pti->pq->spwndActive != NULL) {
        pwndLose = pti->pq->spwndActive;
        ptiLose = GETPTI(pwndLose);

        ThreadLockPti(ptiCurrent, ptiLose, &tlptiLose);
        ThreadLockAlwaysWithPti(ptiCurrent, pwndLose, &tlpwndLose);
        wParam = MAKELONG(WA_INACTIVE, TestWF(pwndLose, WFMINIMIZED));
        if (!xxxSendMessage(pwndLose, WM_NCACTIVATE, WA_INACTIVE, 0)) {
            ThreadUnlock(&tlpwndLose);
            ThreadUnlockPti(ptiCurrent, &tlptiLose);
            goto Exit;
        }
        xxxSendMessage(pwndLose, WM_ACTIVATE, wParam, 0);

        /*
         * Only update the queue's active windows if they weren't
         * changed while we were off calling SendMessage.
         */
        if (pti->pq->spwndActive == pwndLose) {
            Lock(&pti->pq->spwndActivePrev, pti->pq->spwndActive);
            Unlock(&pti->pq->spwndActive);
        }

        /*
         * The flag WFFRAMEON is cleared in the default processing of
         * WM_NCACTIVATE message.
         * We want to clear this flag again here since it might of been
         * set in xxxSendNCPaint.
         * Pbrush calls DrawMenuBar when it gets the WM_ACTIVATE message
         * sent above and this causes xxxSendNCPaint to get called and the
         * WFFRAMEON flag gets reset.
         */
        ClrWF(pwndLose, WFFRAMEON);
        ThreadUnlock(&tlpwndLose);

        /*
         * Revalidate ptiLose because the thread may have gone away
         * when the activation messages were sent above.
         */
        aas.ptiNotify = (ptiLose->TIF_flags & TIF_INCLEANUP) ? NULL : ptiLose;
        ThreadUnlockPti(ptiCurrent, &tlptiLose);
    } else {

        /*
         * Use a non-NULL special value for the test after
         * the xxxActivateApp calls.
         */
        pwndLose = (PWND)-1;
        aas.ptiNotify = pti;
    }

    if (aas.ptiNotify) {
        aas.tidActDeact = tidSetForeground;
        aas.fActivating = FALSE;
        aas.fQueueNotify = FALSE;

        ThreadLockWithPti(ptiCurrent,
                pti->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
        xxxInternalEnumWindow(pti->rpdesk->pDeskInfo->spwnd->spwndChild,
                (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
        ThreadUnlock(&tlpwndChild);
    }

    /*
     * If an app (i.e. Harvard Graphics/Windows Install) tries to
     * reactivate itself during a deactivating WM_ACTIVATEAPP
     * message, force deactivation.
     */
    if (pti->pq->spwndActive == pwndLose) {

        ThreadLockWithPti(ptiCurrent, pwndLose, &tlpwndLose);
        if (!xxxSendMessage(pwndLose, WM_NCACTIVATE, WA_INACTIVE, 0)) {
            ThreadUnlock(&tlpwndLose);
            goto Exit;
        }
        xxxSendMessage(pwndLose, WM_ACTIVATE, WA_INACTIVE, 0);
        ThreadUnlock(&tlpwndLose);

        /*
         * Only update the queue's active windows if they weren't
         * changed while we were off calling SendMessage.
         */
        if (pti->pq->spwndActive == pwndLose) {
            Lock(&pti->pq->spwndActivePrev, pti->pq->spwndActive);
            Unlock(&pti->pq->spwndActive);
        }
    }

    if (pti->pq->spwndFocus != NULL) {
        pwndLose = Unlock(&pti->pq->spwndFocus);
        if (pwndLose != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwndLose, &tlpwndLose);
            xxxSendMessage(pwndLose, WM_KILLFOCUS, 0, 0);
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndLose, FALSE, FALSE);
            }
#endif
            ThreadUnlock(&tlpwndLose);
        }
    }

Exit:
    if (fSetActivateAppBit) {
        pti->TIF_flags &= ~TIF_INACTIVATEAPPMSG;
    }
    if (pti != ptiCurrent)
        ThreadUnlockPti(ptiCurrent, &tlpti);
}


/***************************************************************************\
* xxxSendFocusMessages
*
* Common routine for xxxSetFocus() and xxxActivateWindow() that sends the
* WM_KILLFOCUS and WM_SETFOCUS messages to the windows losing and
* receiving the focus.  This function also sets the local pwndFocus
* to the pwnd receiving the focus.
*
* History:
* 11-08-90 DavidPe      Ported.
* 06-06-91 DavidPe      Rewrote for local pwndFocus/pwndActive in THREADINFO.
\***************************************************************************/

void xxxSendFocusMessages(
    PTHREADINFO pti,
    PWND pwndReceive)
{
    PWND pwndLose;
    TL tlpwndLose;

    CheckLock(pwndReceive);

    /*
     * Remember if this app set the focus to NULL on purpose after it was
     * activated (needed in ActivateThisWindow()).
     */
    pti->pq->QF_flags &= ~QF_FOCUSNULLSINCEACTIVE;
    if (pwndReceive == NULL && pti->pq->spwndActive != NULL)
        pti->pq->QF_flags |= QF_FOCUSNULLSINCEACTIVE;

    pwndLose = pti->pq->spwndFocus;
    ThreadLockWithPti(pti, pwndLose, &tlpwndLose);

    /*
     * We shouldn't be locking a valid pwnd from another queue.
     */
    UserAssert((pwndReceive == NULL)
                    || TestWF(pwndReceive, WFDESTROYED)
                    || (pti->pq == GETPTI(pwndReceive)->pq));
    Lock(&pti->pq->spwndFocus, pwndReceive);

    if (pwndReceive == NULL) {
        if (pwndLose != NULL) {
            /*
             * Tell the client that nobody is gaining focus.
             */
            xxxWindowEvent(EVENT_OBJECT_FOCUS, NULL, OBJID_CLIENT, INDEXID_OBJECT, 0);
            xxxSendMessage(pwndLose, WM_KILLFOCUS, 0, 0);
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndLose, FALSE, FALSE);
            }
#endif
        }
    } else {

        /*
         * Make this thread foreground so its base
         * priority get set higher.
         */
        if (pti->pq == gpqForeground)
            SetForegroundThread(GETPTI(pwndReceive));

        if (pwndLose != NULL) {
            xxxSendMessage(pwndLose, WM_KILLFOCUS, (WPARAM)HWq(pwndReceive), 0);
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndLose, FALSE, FALSE);
            }
#endif
        }

        /*
         * Send the WM_SETFOCUS message, but only if the window we're
         * setting the focus to still has the focus!  This allows apps
         * to prevent themselves from losing the focus by catching
         * the WM_NCACTIVATE message and returning FALSE or by calling
         * SetFocus() inside their WM_KILLFOCUS handler.
         */
        if (pwndReceive == pti->pq->spwndFocus) {
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndReceive, TRUE, FALSE);
            }
#endif
            /*
             * We have to do this BEFORE sending the WM_SETFOCUS message.
             * The app, upon receiving it, very well may turn around and
             * SetFocus() to a child window.
             */
            xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndReceive, OBJID_CLIENT, INDEXID_OBJECT, 0);
            xxxSendMessage(pwndReceive, WM_SETFOCUS, (WPARAM)HW(pwndLose), 0);
        }
    }

    ThreadUnlock(&tlpwndLose);
}


/***************************************************************************\
* xxxActivateApp
*
* xxxEnumWindows call-back function to send the WM_ACTIVATEAPP
* message to the appropriate windows.
*
* We search for windows whose pq == HIWORD(lParam).  Once we find
* one, we send a WM_ACTIVATEAPP message to that window.  The wParam
* of the message is FALSE if the app is losing the activation and
* TRUE if the app is gaining the activation.  The lParam is the
* task handle of the app gaining the activation if wParam is FALSE
* and the task handle of the app losing the activation if wParam
* is TRUE.
*
* lParam = (HIWORD) : pq of app that we are searching for
*          (LOWORD) : pq of app that we notify about
*
* fDoActivate = TRUE  : Send activate
*               FALSE : Send deactivate
*
* History:
* 11-08-90 DavidPe      Ported.
* 06-26-91 DavidPe      Changed for desync focus/activation.
\***************************************************************************/

BOOL xxxActivateApp(
    PWND pwnd,
    AAS *paas)
{
    CheckLock(pwnd);

    if (GETPTI(pwnd) == paas->ptiNotify) {

        if (paas->fQueueNotify) {
            QueueNotifyMessage(pwnd, WM_ACTIVATEAPP, paas->fActivating,
                    paas->tidActDeact);
        } else {
            xxxSendMessage(pwnd, WM_ACTIVATEAPP, paas->fActivating,
                    paas->tidActDeact);
        }
    }

    return TRUE;
}


/***************************************************************************\
* FBadWindow
*
*
* History:
* 11-08-90 DavidPe      Ported.
\***************************************************************************/

BOOL FBadWindow(
    PWND pwnd)
{
    return (pwnd == NULL
            || !TestWF(pwnd, WFVISIBLE)
            || TestWF(pwnd, WFDISABLED));
}


void xxxUpdateTray(PWND pwnd)
{
    PWND pwndT;

    CheckLock(pwnd);
    if (!TestWF(pwnd, WFVISIBLE)) {
        return;
    }

    for (pwndT = pwnd; pwndT->spwndOwner; pwndT = pwndT->spwndOwner) {
    }

    // Notify the shell hook about this activation change
    if (    GETPTI(pwndT)->pq == gpqForeground &&
            FDoTray() &&
            (FCallHookTray() || FPostTray(pwndT->head.rpdesk)) &&
            FTopLevel(pwndT) &&
            TestWF(pwndT, WFVISIBLE))
    {
        BOOL        fFirstTry;
        BOOL        fTryAgain;
        PWND        pwndArg;
        TL          tlpwndArg;

        fFirstTry = TRUE;
        do {
            fTryAgain = FALSE;
            if (TestWF(pwndT, WFWIN40COMPAT)) {
                if (TestWF(pwnd, WFWIN40COMPAT) && IsTrayWindow(pwnd)) {
                    pwndArg = pwnd;
                } else {
                    pwndArg = IsTrayWindow(pwndT) ? pwndT : NULL;
                }
            } else {
                if (TestWF(pwndT, WEFTOOLWINDOW)) {
                    pwndArg = NULL;
                } else if (FHas31TrayStyles(pwndT)) {
                    pwndArg = Is31TrayWindow(pwndT) ? pwndT : NULL;
                } else if (fFirstTry && (pwndT = pwndT->spwndLastActive)) {
                    fFirstTry = FALSE;
                    fTryAgain = TRUE;
                } else {
                    return;
                }
            }
        } while (fTryAgain);

        ThreadLock(pwndArg, &tlpwndArg);
        xxxSetTrayWindow(
                (pwndArg) ? pwndArg->head.rpdesk : pwndT->head.rpdesk,
                pwndArg,
                NULL);

        ThreadUnlock(&tlpwndArg);
    }
}

/***************************************************************************\
* xxxActivateThisWindow
*
* This function is the workhorse for window activation.  It will attempt to
* activate the pwnd specified.  The other parameters are defined as:
*
*  fFlags      This is a flag-mask which defines how the routine is called.
*              These flags are defined as follows:
*
*              ATW_MOUSE     This is set if activation is changing due to a
*                            mouse click and not set if some other action
*                            caused this window to be activated.  This bit
*                            determines the value of wParam on the
*                            WM_ACTIVATE message.
*
*              ATW_SETFOCUS  This parameter is set if this routine should
*                            set the focus to NULL.  If we are called from
*                            the xsxSetFocus() function this will not be
*                            set indicating that we shouldn't mess with the
*                            focus.  Normally (if we are not called from
*                            xxxSetFocus), we set the focus to NULL here
*                            and either the app or xxxDefWindowProc() sets
*                            the focus to the appropriate window.  If the
*                            bit is not set, we don't want to do anything
*                            with focus.  The app may still do a call to
*                            xxxSetFocus() when the WM_ACTIVATE comes
*                            through, but it will just be redundant on its
*                            part.
*
*              ATW_ASYNC     This bit is set if we are processing this
*                            routine from an asynchronous activate (i.e.
*                            xxxProcessEventMessage()).  In this case, we
*                            make sure that we are the foreground queue
*                            before determining if we bring the window to
*                            top.
*
* History:
* 11-08-90 DavidPe      Ported.
* 05-01-95 ChrisWil     changed bool-flags to 1 ATW_ type.
\***************************************************************************/

BOOL xxxActivateThisWindow(
    PWND pwnd,
    DWORD tidLoseForeground,
    DWORD fFlags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndT, pwndActivePrev, pwndActiveSave;
    TL tlpwndActive;
    TL tlpwndChild;
    TL tlpwndActivePrev;
    WPARAM wParam;
    BOOL fSetActivateAppBit;

    BOOL fMouse = (BOOL)(fFlags & ATW_MOUSE);
    BOOL fSetFocus = (BOOL)(fFlags & ATW_SETFOCUS);
    BOOL fAsync = (BOOL)(fFlags & ATW_ASYNC);

#if DBG
    PQ pqSave = ptiCurrent->pq;
#endif


    CheckLock(pwnd);

    /*
     * If pwnd is NULL, then we can't do anything.
     */
    if ((pwnd == NULL) || (pwnd == PWNDDESKTOP(pwnd))) {
        return FALSE;
    }

    /*
     * Don't activate a window that has been destroyed.
     */
    if (HMIsMarkDestroy(pwnd))
        return FALSE;

    /*
     * We don't activate top-level windows of a different queue.
     */
    if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
        return FALSE;
    }

    pwndActiveSave = ptiCurrent->pq->spwndActive;

    /*
     * Do the change-in-activation if the two-windows are different,
     * and if we're not recursing
     */
    if ((pwnd != pwndActiveSave) && !TestWF(pwnd, WFBEINGACTIVATED)) {

        /*
         * Ask the CBT hook whether it is OK to activate this window.
         */
        {
            CBTACTIVATESTRUCT CbtActivateParams;

            if (IsHooked(ptiCurrent, WHF_CBT)) {

                CbtActivateParams.fMouse     = fMouse;
                CbtActivateParams.hWndActive = HW(pwndActiveSave);

                if (xxxCallHook(HCBT_ACTIVATE,
                        (WPARAM)HWq(pwnd), (LPARAM)&CbtActivateParams, WH_CBT)) {
                    return FALSE;
                }
            }
        }

        ptiCurrent->pq->QF_flags &= ~QF_EVENTDEACTIVATEREMOVED;

        /*
         * If the active window went away but somehow was left referenced
         * in the queue, then we do not want to do any deactivation of
         * that window.
         *
         * Don't thread lock this because the next thing we do with it
         * is just an equality check.
         *
         * A DBG check is placed in xxxDestroyWindow to attempt to
         * catch the situation where we return from the function with
         * the destroyed window set in the active (pq).  If that situation
         * can be detected and solved, then this conditional might be
         * removed: ChrisWil - 08/22/95.
         */
        if (ptiCurrent->pq->spwndActive && TestWF(ptiCurrent->pq->spwndActive, WFDESTROYED)) {
            Lock(&ptiCurrent->pq->spwndActive, NULL);
        } else {
            Lock(&ptiCurrent->pq->spwndActivePrev, ptiCurrent->pq->spwndActive);
        }
        pwndActivePrev = ptiCurrent->pq->spwndActive;

        /*
         * If there was a previously active window,
         * and we're in the foreground then assign
         * gpqForegroundPrev to ourself.
         */
        if ((pwndActivePrev != NULL) && (ptiCurrent->pq == gpqForeground)) {
            gpqForegroundPrev = ptiCurrent->pq;
        }

        /*
         * Deactivate currently active window if possible.
         */
        if (pwndActivePrev != NULL) {
            ThreadLockWithPti(ptiCurrent, pwndActivePrev, &tlpwndActive);

            /*
             * The active window can prevent itself from losing the
             * activation by returning FALSE to this WM_NCACTIVATE message
             */
            wParam = MAKELONG(WA_INACTIVE, TestWF(pwndActivePrev, WFMINIMIZED));
            if (!xxxSendMessage(pwndActivePrev, WM_NCACTIVATE,
                    wParam, (LPARAM)HWq(pwnd))) {
                ThreadUnlock(&tlpwndActive);
                return FALSE;
            }

            xxxSendMessage(pwndActivePrev, WM_ACTIVATE, wParam, (LPARAM)HWq(pwnd));

            ThreadUnlock(&tlpwndActive);
        }

        /*
         * If the activation changed while we were gone, we'd better
         * not send any more messages, since they'd go to the wrong window.
         * (and, they've already been sent anyhow)
         */
        if (ptiCurrent->pq->spwndActivePrev != ptiCurrent->pq->spwndActive ||
                pwndActiveSave != ptiCurrent->pq->spwndActive) {
#if DBG
            if (ptiCurrent->pq->spwndActivePrev == ptiCurrent->pq->spwndActive) {
                RIPMSG0(RIP_WARNING, "xxxActivateThisWindow: ptiCurrent->pq->spwndActive changed in callbacks");
            }
#endif
            return FALSE;
        }

        /*
         * If the window being activated has been destroyed, don't
         * do anything else.  Making it the active window in this
         * case can cause console to hang during shutdown.
         */
        if (HMIsMarkDestroy(pwnd))
            return FALSE;

        /*
         * Before we lock the new pwndActivate, make sure we're still
         *  on the same queue.
         */
        if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
            RIPMSG1(RIP_WARNING, "xxxActivateThisWindow: Queue unattached:%#p", pqSave);
            return FALSE;
        }

        /*
         * This bit, which means the app set the focus to NULL after becoming
         * active, doesn't make sense if the app is just becoming active, so
         * clear it in this case. It is used below in this routine to
         * determine whether to send focus messages (read comment in this
         * routine).
         */
        if (ptiCurrent->pq->spwndActive == NULL)
            ptiCurrent->pq->QF_flags &= ~QF_FOCUSNULLSINCEACTIVE;

        Lock(&ptiCurrent->pq->spwndActive, pwnd);

        /*
         * Tp prevent recursion, set pwnd's WFBEINGACTIVATED bit.
         * Recursion can happen if we have an activation battle with other
         * threads which keep changing ptiCurrent->pq->spwndActive behind our
         * callbacks.
         * WARNING: Do NOT return from this routine without clearing this bit!
         */
        SetWF(pwnd, WFBEINGACTIVATED);

        xxxWindowEvent(EVENT_SYSTEM_FOREGROUND, pwnd, OBJID_WINDOW, INDEXID_OBJECT, WEF_USEPWNDTHREAD);

        /*
         * Remove all async activates up to the next async deactivate. We
         * do this so that any queued activates don't reset this synchronous
         * activation state we're now setting. Only remove up till the next
         * deactivate because active state is synchronized with reading
         * input from the input queue.
         *
         * For example, an activate event gets put in an apps queue. Before
         * processing it the app calls ActivateWindow(), which is synchronous.
         * You want the ActivateWindow() to win because it is newer
         * information.
         *
         * msmail32 demonstrates this. Minimize msmail. Alt-tab to it. It
         * brings up the password dialog, but it isn't active. It correctly
         * activates the password dialog but then processes an old activate
         * event activating the icon, so the password dialog is not active.
         */
        RemoveEventMessage(ptiCurrent->pq, QEVENT_ACTIVATE, QEVENT_DEACTIVATE);

        xxxMakeWindowForegroundWithState(NULL, 0);

        pwndActivePrev = ptiCurrent->pq->spwndActivePrev;
        ThreadLockWithPti(ptiCurrent, pwndActivePrev, &tlpwndActivePrev);

        if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) && xxxSendMessage(pwnd, WM_QUERYNEWPALETTE, 0, 0)) {
            xxxSendNotifyMessage(PWND_BROADCAST, WM_PALETTEISCHANGING,
                    (WPARAM)HWq(pwnd), 0);
        }

        /*
         * If the window becoming active is not already the top window in the
         * Z-order, then call xxxBringWindowToTop() to do so.
         */

        /*
         * If this isn't a child window, first check to see if the
         * window isn't already 'on top'.  If not, then call
         * xxxBringWindowToTop().
         */
        if (!(fFlags & ATW_NOZORDER) && !TestWF(pwnd, WFCHILD)) {

            /*
             * Look for the first visible child of the desktop.
             * ScottLu changed this to start looking at the desktop
             * window. Since the desktop window was always visible,
             * BringWindowToTop was always called regardless of whether
             * it was needed or not. No one can remember why this
             * change was made, so I'll change it back to the way it
             * was in Windows 3.1. - JerrySh
             */
            pwndT = PWNDDESKTOP(pwnd)->spwndChild;

            while (pwndT && (!TestWF(pwndT, WFVISIBLE))) {
                pwndT = pwndT->spwndNext;
            }

            /*
             * If this activation came from an async call (i.e.
             * xxxProcessEventMessage), we need to check to see
             * if the thread is the foreground-queue.  If not, then
             * we do not want to bring the window to the top.  This
             * is because another window could have already been
             * place on top w/foreground.  Bringing the window to
             * the top in this case would result in a top-level window
             * without activation. - ChrisWil
             *
             * Added a check to see if the previous-active window went
             * invisible during the deactivation time.  This will ensure
             * that we bring the new window to the top.  Otherwise, we
             * could end up skipping over the previous-window from the
             * above tests.  Office95 apps demonstrate this behaviour by
             * turning their windows invisible during the painting of their
             * captionbars.  By the time we use to get here, we failed to
             * bring the new window to top.
             */
            if ((pwnd != pwndT) || (pwndActivePrev && !IsVisible(pwndActivePrev))) {

                if (!(fAsync && (gpqForeground != ptiCurrent->pq))) {
                    DWORD dwFlags;

                    /*
                     * Bring the window to the top.  If we're already
                     * activating the window, don't reactivate it.
                     */
                    dwFlags = SWP_NOSIZE | SWP_NOMOVE;
                    if (pwnd == pwndT)
                        dwFlags |= SWP_NOACTIVATE;

                    xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0, dwFlags);
                }
            }
        }

        /*
         * If there was no previous active window, or if the
         * previously active window belonged to another thread
         * send the WM_ACTIVATEAPP messages.  The fActivate == FALSE
         * case is handled in xxxDeactivate when 'hwndActivePrev == NULL'.
         *
         * Harvard Graphics/Windows setup calls SetActiveWindow when it
         * receives a deactivationg WM_ACTIVATEAPP.  The TIF_INACTIVATEAPPMSG
         * prevents an activating WM_ACTIVATEAPP(TRUE) from being sent while
         * deactivation is occuring.
         */
        fSetActivateAppBit = FALSE;
        if (!(ptiCurrent->TIF_flags & TIF_INACTIVATEAPPMSG) &&
                ((pwndActivePrev == NULL) ||
                (GETPTI(pwndActivePrev) != GETPTI(pwnd)))) {
            AAS aas;

            /*
             * First send the deactivating WM_ACTIVATEAPP if there
             * was a previously active window of another thread in
             * the current queue.
             */
            if (pwndActivePrev != NULL) {
                PTHREADINFO ptiPrev = GETPTI(pwndActivePrev);
                TL tlptiPrev;

                /*
                 * Ensure that the other thread can't recurse
                 * and send more WM_ACTIVATEAPP msgs.
                 */
                ptiPrev->TIF_flags |= TIF_INACTIVATEAPPMSG;

                aas.ptiNotify = ptiPrev;
                aas.tidActDeact = TIDq(ptiCurrent);
                aas.fActivating = FALSE;
                aas.fQueueNotify = FALSE;

                ThreadLockPti(ptiCurrent, ptiPrev, &tlptiPrev);
                ThreadLockWithPti(ptiCurrent, pwndActivePrev->head.rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
                xxxInternalEnumWindow(pwndActivePrev->head.rpdesk->pDeskInfo->spwnd->spwndChild,
                        (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
                ThreadUnlock(&tlpwndChild);
                ptiPrev->TIF_flags &= ~TIF_INACTIVATEAPPMSG;
                ThreadUnlockPti(ptiCurrent, &tlptiPrev);
            }

            /*
             * This will ensure that the current thread will not
             * send any more WM_ACTIVATEAPP messages until it
             * is done performing its activation.
             */
            ptiCurrent->TIF_flags |= TIF_INACTIVATEAPPMSG;
            fSetActivateAppBit = TRUE;

            aas.ptiNotify = GETPTI(pwnd);
            aas.tidActDeact = tidLoseForeground;
            aas.fActivating = TRUE;
            aas.fQueueNotify = FALSE;

            ThreadLockWithPti(ptiCurrent, ptiCurrent->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
            xxxInternalEnumWindow(ptiCurrent->rpdesk->pDeskInfo->spwnd->spwndChild,
                    (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
            ThreadUnlock(&tlpwndChild);
        }

        /*
         * If this window has already been drawn as active, set the
         * flag so that we don't draw it again.
         */
        if (TestWF(pwnd, WFFRAMEON)) {
            SetWF(pwnd, WFNONCPAINT);
        }

        /*
         * If the window is marked for destruction, don't do
         * the lock because xxxFreeWindow has already been called
         * and a lock here will result in the window locking itself
         * and never being freed.
         */
        if (!HMIsMarkDestroy(pwnd)) {

            /*
             * Set most recently active window in owner/ownee list.
             */
            pwndT = pwnd;
            while (pwndT->spwndOwner != NULL) {
                pwndT = pwndT->spwndOwner;
            }
            Lock(&pwndT->spwndLastActive, pwnd);
        }


        xxxSendMessage(pwnd, WM_NCACTIVATE,
                MAKELONG(GETPTI(pwnd)->pq == gpqForeground,
                ptiCurrent->pq->spwndActive != NULL ?
                TestWF(ptiCurrent->pq->spwndActive, WFMINIMIZED) : 0),
                (LPARAM)HW(pwndActivePrev));

        if (ptiCurrent->pq->spwndActive != NULL) {
            xxxSendMessage(pwnd, WM_ACTIVATE,
                    MAKELONG((fMouse ? WA_CLICKACTIVE : WA_ACTIVE),
                    TestWF(ptiCurrent->pq->spwndActive, WFMINIMIZED)),
                    (LPARAM)HW(pwndActivePrev));
        } else {
            xxxSendMessage(pwnd, WM_ACTIVATE,
                    MAKELONG((fMouse ? WA_CLICKACTIVE : WA_ACTIVE), 0),
                    (LPARAM)HW(pwndActivePrev));
        }

        xxxUpdateTray(pwnd);

        ThreadUnlock(&tlpwndActivePrev);

        ClrWF(pwnd, WFNONCPAINT);

        /*
         * If xxxActivateThisWindow() is called from xxxSetFocus() then
         * fSetFocus is FALSE.  In this case, we don't set the focus since
         * xxxSetFocus() will do that for us.  Otherwise, we set the focus
         * to the newly activated window if the window with the focus is
         * not the new active window or one of its children.  Normally,
         * xxxDefWindowProc() will set the focus.
         */
        ThreadLockWithPti(ptiCurrent, ptiCurrent->pq->spwndActive, &tlpwndActive);

        /*
         * Win3.1 checks spwndFocus != NULL - we check QF_FOCUSNULLSINCEACTIVE,
         * which is the win32 equivalent. On win32, 32 bit apps each have their
         * own focus. If the app is not foreground, most of the time spwndFocus
         * is NULL when the window is being activated and brought to the
         * foreground. It wouldn't go through this code in this case. Win3.1 in
         * effect is checking if the previous active application had an
         * hwndFocus != NULL. Win32 effectively assumes the last window has a
         * non-NULL hwndFocus, so win32 instead checks to see if the focus has
         * been set to NULL since this application became active (meaning, did
         * it purposefully set the focus to NULL). If it did, don't go through
         * this codepath (like win3.1). If it didn't, go through this code path
         * because the previous application had an hwndFocus != NULL
         * (like win3.1). Effectively it is the same check as win3.1, but
         * updated to deal with async input.
         *
         * Case in point: bring up progman, hit f1 (to get win32 help). Click
         * history to get a popup (has the focus in a listbox in the client
         * area). Activate another app, now click on title bar only of history
         * popup. The focus should get set by going through this code path.
         *
         * Alternate case: Ventura Publisher brings up "Special Effects"
         * dialog. If "Bullet" from this dialog was clicked last time the
         * dialog was brought up, sending focus messages here when
         * hwndFocus == NULL, would reset the focus to "None" incorrectly
         * because Ventura does its state setting when it gets the focus
         * messages. The real focus messages it is depending on are the
         * ones that come from the SetFocus() call in DlgSetFocus() in
         * the dialog management code. (In this case, before the dialog
         * comes up, focus == active window. When the dialog comes up
         * and EnableWindow(hwndOwner, FALSE) is called, EnableWindow() calls
         * SetFocus(NULL) (because it is disabling the window that is also
         * the focus window). When the dialog comes up it gets activated via
         * SwpActivate(), but since the focus is NULL vpwin does not expect
         * to go through this code path.)
         *
         * - scottlu
         */
#if 0
// this is what win3.1 does - which won't work for win32

        if (fSetFocus && ptiCurrent->pq->spwndFocus != NULL && ptiCurrent->pq->spwndActive !=
                GetTopLevelWindow(ptiCurrent->pq->spwndFocus))
#else
        if (fSetFocus && !(ptiCurrent->pq->QF_flags & QF_FOCUSNULLSINCEACTIVE) &&
                ptiCurrent->pq->spwndActive != GetTopLevelWindow(ptiCurrent->pq->spwndFocus)) {
#endif

            xxxSendFocusMessages(ptiCurrent,
                    (ptiCurrent->pq->spwndActive != NULL &&
                    TestWF(ptiCurrent->pq->spwndActive, WFMINIMIZED)) ?
                    NULL : ptiCurrent->pq->spwndActive);
        }

        ThreadUnlock(&tlpwndActive);

        /*
         * This flag is examined in the menu loop code so that we exit from
         * menu mode if another window was activated while we were tracking
         * menus.
         */
        ptiCurrent->pq->QF_flags |= QF_ACTIVATIONCHANGE;

        if (gppiScreenSaver == NULL) {

            /*
             * Activation has occurred, update our last idle time counter if
             * we're on the input desktop.
             */
            if ((ptiCurrent->rpdesk == grpdeskRitInput) && (!gbBlockSendInputResets)) {
                glinp.timeLastInputMessage = NtGetTickCount();
            }

        } else {

            if (GETPTI(pwnd)->ppi != gppiScreenSaver) {
                /*
                 * Activation ocurred by an app other than the screen saver.
                 * Update the idle time counter and mark our screen saver as
                 * active (so it can quit).
                 */

#if 0
// LATER
                if (ptiCurrent->rpdesk != gppiScreenSaver->rpdeskStartup) {
                    /*
                     * Activation is occurring on different desktops, let WinLogon decide
                     * if it wants to switch.
                     */
                }
#endif

                glinp.timeLastInputMessage = NtGetTickCount();
                gppiScreenSaver->W32PF_Flags &= ~W32PF_IDLESCREENSAVER;
                SetForegroundPriorityProcess(gppiScreenSaver, gppiScreenSaver->ptiMainThread, TRUE);
            }
        }

        /*
         * If WM_ACTIVATEAPP messages were sent, it is now
         * safe to allow them to be sent again.
         */
        if (fSetActivateAppBit)
            ptiCurrent->TIF_flags &= ~TIF_INACTIVATEAPPMSG;


    } else {
#if DBG
        if (TestWF(pwnd, WFBEINGACTIVATED)) {
            RIPMSG1(RIP_WARNING, "xxxActivateThisWindow recursing on pwnd %#p\n", pwnd);
        }
#endif
        ptiCurrent->pq->QF_flags &= ~QF_EVENTDEACTIVATEREMOVED;
        if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) && xxxSendMessage(pwnd, WM_QUERYNEWPALETTE, 0, 0)) {
            xxxSendNotifyMessage(PWND_BROADCAST, WM_PALETTEISCHANGING,
                    (WPARAM)HWq(pwnd), 0);
        }
    }

    ClrWF(pwnd, WFBEINGACTIVATED);
    return ptiCurrent->pq->spwndActive == pwnd;
}


/***************************************************************************\
* RemoveEventMessage
*
* Removes events dwQEvent until finding dwQEventStop. Used for removing
* activate and deactivate events.
*
* 04-01-93 ScottLu      Created.
\***************************************************************************/

BOOL RemoveEventMessage(
    PQ pq,
    DWORD dwQEvent,
    DWORD dwQEventStop)
{
    PQMSG pqmsgT;
    PQMSG pqmsgPrev;
    BOOL bRemovedEvent = FALSE;

    /*
     * Remove all events dwQEvent until finding dwQEventStop.
     */
    for (pqmsgT = pq->mlInput.pqmsgWriteLast; pqmsgT != NULL; ) {

        if (pqmsgT->dwQEvent == dwQEventStop)
            return(bRemovedEvent);

        pqmsgPrev = pqmsgT->pqmsgPrev;

        /*
         * If the event is found and is not the one being peeked,
         * delete it.
         */
        if (pqmsgT->dwQEvent == dwQEvent &&
                pqmsgT != (PQMSG)pq->idSysPeek) {
            DelQEntry(&(pq->mlInput), pqmsgT);
            bRemovedEvent = TRUE;
        }
        pqmsgT = pqmsgPrev;
    }
    return(bRemovedEvent);
}


/***************************************************************************\
* CanForceForeground
*
* A process can NOT force a new foreground when:
* -There is a last input owner glinp.ptiLastWoken), and
* -The process didn't get the last hot key, key or mouse click, and
* -There is a thread with foreground priority gptiForeground), and
* -The process doesn't own the foreground thread, and
* -The process doesn't have foreground activation right, and
* -The process was not the last one to do SendInput/JournalPlayBack
* -There is a foreground queue, and
* -The last input owner is not being debugged, and
* -The foreground process is not being debugged, and
* -The last input was not long ago
*
* History:
* 05/12/97  GerardoB    Extracted from xxxSetForegroundWindow
\***************************************************************************/
BOOL CanForceForeground(PPROCESSINFO ppi)
{

    if ((glinp.ptiLastWoken != NULL)
            && (glinp.ptiLastWoken->ppi != ppi)
            && (gptiForeground != NULL)
            && (gptiForeground->ppi != ppi)
            && !(ppi->W32PF_Flags & (W32PF_ALLOWFOREGROUNDACTIVATE | W32PF_ALLOWSETFOREGROUND))
            && (ppi != gppiInputProvider)
            && (gpqForeground != NULL)
            &&
        #if DBG
            /*
             * When attaching the debugger to the foreground app, this function always
             *  returns TRUE. In order to be able to debug anything related to this
             *  function in such case, set this global to TRUE.
             */
               (gfDebugForegroundIgnoreDebugPort
                || (
        #endif
                       (PsGetProcessDebugPort(glinp.ptiLastWoken->ppi->Process) == NULL)
                    && (PsGetProcessDebugPort(gptiForeground->ppi->Process) == NULL)
        #if DBG
                ))
        #endif
            && !IsTimeFromLastRITEvent(UP(FOREGROUNDLOCKTIMEOUT))) {

        return FALSE;
    } else {
        return TRUE;
    }

}
/***************************************************************************\
* AllowSetForegroundWindow (5.0 API)
*
* This API is meant to be called by the foreground process to allow another
*  process to take the foreground.
* This is implemented by making a thread in dwProcessId the owner of the last
*  input event. This means that dwProcessId keeps the right to take the foreground
*  until the user generates new input (unless the input is direct to dwProcessId itself).
*
* History:
* 01-28-98 GerardoB      Created.
\***************************************************************************/
BOOL xxxAllowSetForegroundWindow(
    DWORD dwProcessId)
{
    DWORD dwError;
    PEPROCESS pep;
    NTSTATUS Status;
    PPROCESSINFO ppi;
    /*
     * Get the ppi for dwProcessId
     * ASFW_ANY NULLs out the input owner so any process can take the foreground
     */
    if (dwProcessId != ASFW_ANY) {
        Status = LockProcessByClientId((HANDLE)LongToHandle( dwProcessId ), &pep);
        if (!NT_SUCCESS(Status)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            return FALSE;
        }
        ppi = PpiFromProcess(pep);
        if (ppi == NULL) {
            dwError = ERROR_INVALID_PARAMETER;
            goto UnlockAndFail;
        }
    }
    /*
     * Do nothing if the current process cannot force a foreground change.
     * We could have checked this upfront but we didn't since we had to
     *  leave the crit section and the state could have changed.
     */
    if (!CanForceForeground(PpiCurrent())) {
        dwError = ERROR_ACCESS_DENIED;
        goto UnlockAndFail;
    }
    /*
     * Let's make a thread (if any) of this process be the last input owner
     */
    if (dwProcessId != ASFW_ANY) {
        TAGMSG2(DBGTAG_FOREGROUND, "xxxAllowSetForegroundWindow by %#p to %#p", PpiCurrent(), ppi);
        glinp.ptiLastWoken = ppi->ptiList;
        UnlockProcess(pep);
    } else {
        TAGMSG1(DBGTAG_FOREGROUND, "xxxAllowSetForegroundWindow by %#p to ANY", PpiCurrent());
        glinp.ptiLastWoken = NULL;
    }
    return TRUE;

UnlockAndFail:
    if (dwProcessId != ASFW_ANY) {
        UnlockProcess(pep);
    }
    RIPERR0(dwError, RIP_VERBOSE, "");
    return FALSE;
}
/***************************************************************************\
* LockSetForegroundWindow (5.0 API)
*
* This API allows application to prevent any call to SetForegroundWindow.
* This is mainly intended for application implementing their own menus
*  so they can block SFW just like we do for our own menus.
* Certain actions like hitting the ALT key or any foreground change (ie, by a click)
*  will automatically unlock SFW (so apps cannot hose SFW)
*
* History:
* 07-04-98 GerardoB      Created.
\***************************************************************************/
BOOL _LockSetForegroundWindow(
    UINT uLockCode)
{
    DWORD dwError;
    PPROCESSINFO ppiCurrent = PpiCurrent();

    switch (uLockCode) {
        case LSFW_LOCK:
            /*
             * If the caller cannot lock it or already locked, fail the call
             */
            if (CanForceForeground(ppiCurrent) && (gppiLockSFW == NULL)) {
                gppiLockSFW = ppiCurrent;
                TAGMSG1(DBGTAG_FOREGROUND, "_LockSetForegroundWindow locked by %#p", ppiCurrent);
            } else {
                dwError = ERROR_ACCESS_DENIED;
                goto FailIt;
            }
            break;

        case LSFW_UNLOCK:
            /*
             * If the caller didn't lock it, fail the call
             */
            if (ppiCurrent == gppiLockSFW) {
                gppiLockSFW = NULL;
                TAGMSG0(DBGTAG_FOREGROUND, "_LockSetForegroundWindow UNLOCKED");
            } else {
                dwError = ERROR_ACCESS_DENIED;
                goto FailIt;
            }
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            goto FailIt;
    }

    return TRUE;

FailIt:
    RIPERR0(dwError, RIP_VERBOSE, "");
    return FALSE;
}
/***************************************************************************\
* CleanupDecSFWLockCount
*
* Wrapper to be passed to PushW32ThreadLock, which wants an actual function.
* History:
* 10/19/98 GerardoB      Created.
\***************************************************************************/
void CleanupDecSFWLockCount(PVOID pIgnore)
{
    DecSFWLockCount();
    UNREFERENCED_PARAMETER(pIgnore);
}

/***************************************************************************\
* xxxSetForegroundWindow (API)
*
* History:
* 06-07-91 DavidPe      Created.
\***************************************************************************/
BOOL xxxStubSetForegroundWindow(
    PWND pwnd)
{
    return xxxSetForegroundWindow(pwnd, TRUE);
}
BOOL xxxSetForegroundWindow(
    PWND pwnd,
    BOOL fFlash)
{
    BOOL fNiceCall = TRUE;
    BOOL fSyncActivate, fActive;
    DWORD dwFlashFlags;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndFlash;
    TL tlpwndFlash;

    CheckLock(pwnd);

    /*
     * If we're trying to set a window on our own thread to the foreground,
     * and we're already in the foreground, treat it just like a call to
     * SetActiveWindow().
     */
    if ((pwnd != NULL) && (GETPTI(pwnd)->pq == gpqForeground)) {
        fSyncActivate = (gpqForeground == ptiCurrent->pq);
        if (fSyncActivate) {
            gppiWantForegroundPriority = ptiCurrent->ppi;
        } else {
            gppiWantForegroundPriority = GETPTI(pwnd)->ppi;
        }

        goto JustActivateIt;
    }

    /*
     * If the foregrond is not locked
     *     and this thread has the right to changethe foreground,
     * then remove the activation right (it's a one-shot deal)
     *      and do it.
     *
     *
     * Bug 247768 - joejo
     * Add compatibility hack for foreground activation problems.
     *
     * To Fix Winstone99, ignore the foreground lock if the input
     *  provider is making this call. GerardoB.
     *
     * Windows Bug 88327 - jasonsch
     * Screen savers can always come to the foreground.
     */
    if ((!IsForegroundLocked() || (ptiCurrent->ppi == gppiInputProvider))
            && (ptiCurrent->TIF_flags & (TIF_ALLOWFOREGROUNDACTIVATE | TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD)
                || CanForceForeground(ptiCurrent->ppi)
                || GiveUpForeground()) || ptiCurrent->ppi == gppiScreenSaver) {

        TAGMSG1(DBGTAG_FOREGROUND, "xxxSetForegroundWindow FRemoveForegroundActivate %#p", ptiCurrent);

        FRemoveForegroundActivate(ptiCurrent);
        return xxxSetForegroundWindow2(pwnd, ptiCurrent, 0);
    }
    fNiceCall = FALSE;
    TAGMSG3(DBGTAG_FOREGROUND, "xxxSetForegroundWindow: rude call by %#p to %#p-%#p",
            ptiCurrent, pwnd, (pwnd != NULL ? GETPTI(pwnd) : NULL));
    if (pwnd == NULL) {
        return FALSE;
    }
    /*
     * Notify the user that this pwnd wants to come to the foreground.
     * Try to flash a tray button only; otherwise, flash pwnd
     */
    if (fFlash) {
        pwndFlash = DSW_GetTopLevelCreatorWindow(GetTopLevelWindow(pwnd));
        if (IsTrayWindow(pwndFlash)) {
            dwFlashFlags = FLASHW_TRAY;
        } else {
            pwndFlash = pwnd;
            dwFlashFlags = FLASHW_ALL;
        }
        ThreadLockAlways(pwndFlash, &tlpwndFlash);
        xxxFlashWindow(pwndFlash,
                       MAKELONG(dwFlashFlags | FLASHW_TIMERNOFG, UP(FOREGROUNDFLASHCOUNT)),
                       0);
        ThreadUnlock(&tlpwndFlash);
    }
    /*
     * Activate the window.
     */
    fSyncActivate = (ptiCurrent->pq == GETPTI(pwnd)->pq);

JustActivateIt:

    if (fSyncActivate) {
        fActive = xxxActivateWindow(pwnd, AW_USE);
    } else if (pwnd == GETPTI(pwnd)->pq->spwndActive) {
        fActive = TRUE;
    } else {
        fActive = PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq,
                                QEVENT_ACTIVATE, NULL, 0,
                                0, (LPARAM)HWq(pwnd)) ;
    }

    /*
     * Return FALSE if we failed the set foreground request.
     */
    return fNiceCall && fActive;
}
/***************************************************************************\
* xxxSetForegroundWindow2
*
* History:
* 07-19-91 DavidPe      Created.
\***************************************************************************/

BOOL xxxSetForegroundWindow2(
    PWND pwnd,
    PTHREADINFO pti,
    DWORD fFlags)
{
    PTHREADINFO ptiForegroundOld;
    PTHREADINFO ptiForegroundNew;
    PQ pqForegroundOld, pqForegroundNew, pqCurrent;
    HWND hwnd;
    PQMSG pqmsgDeactivate, pqmsgActivate;
    BOOL bRemovedEvent;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL retval = TRUE;
    UINT uMsg;
    CheckLock(pwnd);

    /*
     * Queue pointers and threadinfo pointers can go away when calling xxx
     * calls. Also, queues can get recalced via AttachThreadInput() during
     * xxx calls - so we want to reference the application becoming foreground.
     * PQs cannot be refcount locked (either thread locked or structure locked)
     * so must (re)calculate them after returning from xxx calls.
     *
     * NOTE: gpqForeground and gpqForegroundPrev are always current and don't
     *       need special handling.
     */

    /*
     * Don't allow the foreground to be set to a window that is not
     * on the current desktop.
     */
    if (pwnd != NULL && (pwnd->head.rpdesk != grpdeskRitInput ||
            HMIsMarkDestroy(pwnd))) {
        return FALSE;
    }

    /*
     * Unlock SetForegroundWindow (if someone had it locked)
     */
    gppiLockSFW = NULL;
    TAGMSG3(DBGTAG_FOREGROUND, "xxxSetForegroundWindow2 by %#p to %#p-%#p",
            ptiCurrent, pwnd, (pwnd != NULL ? GETPTI(pwnd) : NULL));

    /*
     * Calculate who is becoming foreground. Also, remember who we want
     * foreground (for priority setting reasons).
     */
    if ((gptiForeground != NULL) && !(gptiForeground->TIF_flags & TIF_INCLEANUP)) {
        ptiForegroundOld = gptiForeground;
    } else {
        ptiForegroundOld = NULL;
    }
    pqForegroundOld = NULL;
    pqForegroundNew = NULL;
    pqCurrent = NULL;

    gpqForegroundPrev = gpqForeground;

    if (pwnd != NULL) {
        ptiForegroundNew = GETPTI(pwnd);
        UserAssert(ptiForegroundNew->rpdesk == grpdeskRitInput);
        gppiWantForegroundPriority = GETPTI(pwnd)->ppi;
        gpqForeground = GETPTI(pwnd)->pq;
        UserAssert(gpqForeground->cThreads != 0);
        UserAssert(gpqForeground->ptiMouse->rpdesk == grpdeskRitInput);
        // Assert to catch AV in xxxNextWindow doing Alt-Esc: If we have a non-NULL
        // gpqForeground, its kbd input thread better have an rpdesk!  -IanJa
        UserAssert(!gpqForeground || (gpqForeground->ptiKeyboard && gpqForeground->ptiKeyboard->rpdesk));
        SetForegroundThread(GETPTI(pwnd));
    } else {
        ptiForegroundNew = NULL;
        gppiWantForegroundPriority = NULL;
        gpqForeground = NULL;
        SetForegroundThread(NULL);
    }

    /*
     * Are we switching the foreground queue?
     */
    if (gpqForeground != gpqForegroundPrev) {
        TL tlptiForegroundOld;
        TL tlptiForegroundNew;
        TL tlpti;

        ThreadLockPti(ptiCurrent, ptiForegroundOld, &tlptiForegroundOld);
        ThreadLockPti(ptiCurrent, ptiForegroundNew, &tlptiForegroundNew);
        ThreadLockPti(ptiCurrent, pti, &tlpti);

        /*
         * If this call didn't come from the RIT, cancel tracking
         * and other global states.
         */
        if (pti != NULL) {

            /*
             * Clear any visible tracking going on in system.
             */
            xxxCancelTracking();

            /*
             * Remove the clip cursor rectangle - it is a global mode that
             * gets removed when switching.  Also remove any LockWindowUpdate()
             * that's still around.
             */
            zzzClipCursor(NULL);
            LockWindowUpdate2(NULL, TRUE);

            /*
             * Make sure the desktop of the newly activated window is the
             * foreground fullscreen window
             */
            xxxMakeWindowForegroundWithState(NULL, 0);
        }

        /*
         * We've potentially done callbacks. Calculate pqForegroundOld
         * based on our locked local variable ptiForegroundOld.
         */
        pqForegroundOld = NULL;
        if (ptiForegroundOld && !(ptiForegroundOld->TIF_flags & TIF_INCLEANUP)) {
            pqForegroundOld = ptiForegroundOld->pq;
        }

        pqCurrent = NULL;
        if (pti != NULL)
            pqCurrent = pti->pq;

        /*
         * Now allocate message for the deactivation
         */
        pqmsgDeactivate = pqmsgActivate = NULL;

        if ((pqForegroundOld != NULL) && (pqForegroundOld != pqCurrent)) {
            if ((pqmsgDeactivate = AllocQEntry(&pqForegroundOld->mlInput)) ==
                    NULL) {
                retval = FALSE;
                goto Exit;
            }
        }

        /*
         * Do any appropriate deactivation.
         */
        if (pqForegroundOld != NULL) {

            /*
             * If we're already on the foreground queue we'll call
             * xxxDeactivate() directly later in this routine since
             * it'll cause us to leave the critical section.
             */
            if (pqForegroundOld != pqCurrent) {
                StoreQMessage(pqmsgDeactivate, NULL, 0,
                        gptiForeground != NULL ? (WPARAM)GETPTIID(gptiForeground) : 0,
                        0, 0, QEVENT_DEACTIVATE, 0);

                /*
                 * If there was an old foreground thread, make it perform
                 * the deactivation.  Otherwise, any thread on the queue
                 * can perform the deactivation.
                 */
                if (ptiForegroundOld != NULL) {
                    SetWakeBit(ptiForegroundOld, QS_EVENTSET);

                    StoreQMessagePti(pqmsgDeactivate, ptiForegroundOld);

                }

                if (pqForegroundOld->spwndActive != NULL) {
                    if (ptiForegroundOld != NULL && FHungApp(ptiForegroundOld, CMSHUNGAPPTIMEOUT)) {
                        TL tlpwnd;
                        ThreadLockAlwaysWithPti(ptiCurrent, pqForegroundOld->spwndActive, &tlpwnd);
                        xxxRedrawHungWindowFrame(pqForegroundOld->spwndActive, FALSE);
                        ThreadUnlock(&tlpwnd);
                    } else {
                        SetHungFlag(pqForegroundOld->spwndActive, WFREDRAWFRAMEIFHUNG);
                    }
                }
            }
        }

        /*
         * We've potentially done callbacks. Calculate pqForegroundNew
         * based on our locked local variable ptiForegroundNew.
         */
        pqForegroundNew = NULL;
        if (ptiForegroundNew && !(ptiForegroundNew->TIF_flags & TIF_INCLEANUP)) {
            pqForegroundNew = ptiForegroundNew->pq;
        }

        /*
         * Update pqCurrent since we may have made an xxx call,
         * and this variable may be invalid.
         */
        pqCurrent = NULL;
        if (pti != NULL) {
            pqCurrent = pti->pq;
        }

        if ((pqForegroundNew != NULL) && (pqForegroundNew != pqCurrent)) {
            pqmsgActivate = AllocQEntry(&pqForegroundNew->mlInput);
            if (pqmsgActivate == NULL) {
                retval = FALSE;
                goto Exit;
            }
        }

        /*
         * Do any appropriate activation.
         */
        if (pqForegroundNew != NULL) {
            /*
             * We're going to activate (synchronously or async with an activate
             * event). We want to remove the last deactivate event if there is
             * one because this is new state. If we don't, then 1> we could
             * synchronously activate and then asynchronously deactivate,
             * thereby processing these events out of order, or 2> we could
             * pile up a chain of deactivate / activate events which would
             * make the titlebar flash alot if the app wasn't responding to
             * input for awhile (in this case, it doesn't matter if we
             * put a redundant activate in the queue, since the app is already
             * active. Remove all deactivate events because this app is
             * setting a state that is not meant to be synchronized with
             * existing queued input.
             *
             * Case: run setup, switch away (it gets deactivate event). setup
             * is not reading messages so it hasn't go it yet. It finally
             * comes up, calls SetForegroundWindow(). It's synchronous,
             * it activates ok and sets foreground. Then the app calls
             * GetMessage() and gets the deactivate. Now it isn't active.
             */
            bRemovedEvent = RemoveEventMessage(pqForegroundNew, QEVENT_DEACTIVATE, (DWORD)-1);

            /*
             * Now do any appropriate activation.  See comment below
             * for special cases.  If we're already on the foreground
             * queue we'll call xxxActivateThisWindow() directly.
             */
            if (pqForegroundNew != pqCurrent) {

                /*
                 * We do the 'pqCurrent == NULL' test to see if we're being
                 * called from the RIT.  In this case we pass NULL for the
                 * HWND which will check to see if there is already an active
                 * window for the thread and redraw its frame as truly active
                 * since it's in the foreground now.  It will also cancel any
                 * global state like LockWindowUpdate() and ClipRect().
                 */
                if ((pqCurrent == NULL) && (!(fFlags & SFW_SWITCH))) {
                    hwnd = NULL;
                } else {
                    hwnd = HW(pwnd);
                }

                if (bRemovedEvent) {
                    pqForegroundNew->QF_flags |= QF_EVENTDEACTIVATEREMOVED;
                }
                /*
                 * MSMail relies on a specific order to how win3.1 does
                 * fast switch alt-tab activation. On win3.1, it essentially
                 * activates the window, then restores it. MsMail gets confused
                 * if it isn't active when it gets restored, so this logic
                 * will make sure msmail gets restore after it gets activated.
                 *
                 * Click on a message line in the in-box, minimize msmail,
                 * alt-tab to it. The same line should have the focus if msmail
                 * got restored after it got activated.
                 *
                 * This is the history behind SFW_ACTIVATERESTORE.
                 */
                if (fFlags & SFW_ACTIVATERESTORE) {
                    uMsg = PEM_ACTIVATE_RESTORE;
                } else {
                    uMsg = 0;
                }

                if (fFlags & SFW_NOZORDER) {
                    uMsg |= PEM_ACTIVATE_NOZORDER;
                }

                StoreQMessage(pqmsgActivate, NULL, uMsg,
                        (fFlags & SFW_STARTUP) ? 0 : (WPARAM)TID(ptiForegroundOld),
                        (LPARAM)hwnd, 0, QEVENT_ACTIVATE, 0);


                /*
                 * Signal the window's thread to perform activation.  We
                 * know that ptiForegroundNew is valid because pqForegroundNew
                 * is not NULL.
                 */

                StoreQMessagePti(pqmsgActivate, ptiForegroundNew);

                SetWakeBit(ptiForegroundNew, QS_EVENTSET);

                if (pqForegroundNew->spwndActive != NULL) {
                    if (FHungApp(ptiForegroundNew, CMSHUNGAPPTIMEOUT)) {
                        TL tlpwnd;
                        ThreadLockAlwaysWithPti(ptiCurrent, pqForegroundNew->spwndActive, &tlpwnd);
                        xxxRedrawHungWindowFrame(pqForegroundNew->spwndActive, TRUE);
                        ThreadUnlock(&tlpwnd);
                    } else {
                        SetHungFlag(pqForegroundNew->spwndActive, WFREDRAWFRAMEIFHUNG);
                    }
                }

            } else {
                if (pwnd != pqCurrent->spwndActive) {
                    if (!(fFlags & SFW_STARTUP)) {
                        retval = xxxActivateThisWindow(pwnd, TID(ptiForegroundOld),
                                ((fFlags & SFW_SETFOCUS) ? 0 : ATW_SETFOCUS));

                        /*
                         * Make sure the mouse is on this window.
                         */
                        if (retval && TestUP(ACTIVEWINDOWTRACKING)) {
                            zzzActiveCursorTracking(pwnd);
                        }
                        goto Exit;
                    }

                } else {

                    /*
                     * If pwnd is already the active window, just make sure
                     * it's drawn active and on top (if requested).
                     */
                    xxxSendMessage(pwnd, WM_NCACTIVATE,
                            TRUE,
                            (LPARAM)HW(pwnd));
                    xxxUpdateTray(pwnd);
                    if (!(fFlags & SFW_NOZORDER)) {
                        xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                    }
                }
            }


        } /* if (pqForegroundNew != NULL) */

        /*
         * First update pqForegroundOld and pqCurrent since we may have
         * made an xxx call, and these variables may be invalid.
         */
        pqForegroundOld = NULL;
        if (ptiForegroundOld && !(ptiForegroundOld->TIF_flags & TIF_INCLEANUP)) {
            pqForegroundOld = ptiForegroundOld->pq;
        }

        pqCurrent = NULL;
        if (pti != NULL)
            pqCurrent = pti->pq;

        /*
         * Now check to see if we needed to do any 'local' deactivation.
         * (ie.  were we on the queue that is being deactivated by this
         * SetForegroundWindow() call?)
         */
        if ((pqForegroundOld != NULL) && (pqForegroundOld == pqCurrent)) {
            xxxDeactivate(pti, (pwnd != NULL) ? TIDq(GETPTI(pwnd)) : 0);
        }
Exit:
        ThreadUnlockPti(ptiCurrent, &tlpti);
        ThreadUnlockPti(ptiCurrent, &tlptiForegroundNew);
        ThreadUnlockPti(ptiCurrent, &tlptiForegroundOld);
    }

    return retval;
}
/***************************************************************************\
* FRemoveForegroundActivate
*
* Returns TRUE if the foreground activate right was removed.
*
* 05-12-97 GerardoB     Extracted from FAllowForegroundActivate.
\***************************************************************************/
BOOL FRemoveForegroundActivate(PTHREADINFO pti)
{
    BOOL fRemoved;
    PPROCESSINFO ppi;
    /*
     * W32PF_APPSTARTING gets turned off the first activate this process does.
     * We assume it's ready now for action.
     */
    ppi = pti->ppi;
    if (ppi->W32PF_Flags & W32PF_APPSTARTING) {
        ClearAppStarting(ppi);
    }

    /*
     * Remove the right if present.
     */
    fRemoved =  (pti->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE);
    if (fRemoved) {
        pti->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE ;
        TAGMSG1(DBGTAG_FOREGROUND, "FRemoveForegroundActivate clear TIF %#p", pti);
    } else {
        fRemoved = (ppi->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE);
    }
    if (fRemoved) {
        ppi->W32PF_Flags &= ~W32PF_ALLOWFOREGROUNDACTIVATE;
        TAGMSG1(DBGTAG_FOREGROUND, "FRemoveForegroundActivate clear W32PF %#p", ppi);
    }

    return fRemoved;

}
/***************************************************************************\
* FAllowForegroundActivate
*
* Checks to see if we previously have allowed this process or thread to
* do a foreground activate - meaning, next time it becomes active, whether
* we'll allow it to come to the foreground.  Sometimes processes are granted
* the right to foreground activate themselves, if they aren't foreground,
* like when starting up (there are other cases). Grant this if this process
* is allowed.
*
* 09-08-92 ScottLu      Created.
\***************************************************************************/

BOOL FAllowForegroundActivate(
    PQ pq,
    PWND pwnd)
{
    PTHREADINFO  ptiCurrent = PtiCurrent();
    UserAssert(pwnd != NULL);
    /*
     * Bail if this guy doesn't have the foreground activate right.
     */
    TAGMSG1(DBGTAG_FOREGROUND, "FAllowForegroundActivate FRemoveForegroundActivate %#p", ptiCurrent);
    if (!FRemoveForegroundActivate(ptiCurrent)) {
        return FALSE;
    }
    /*
     * Don't try to foreground activate if:
     *  we're not on the right desktop.
     *  we're already in the foreground
     *  the foreground is locked
     * It'll fail in SetForegroundWindow2() anyway. This way
     * ActivateWindow() will still locally activate the window.
     */
    if ((ptiCurrent->rpdesk != grpdeskRitInput)
            || (gpqForeground == pq)
            || IsForegroundLocked()) {
        TAGMSG0(DBGTAG_FOREGROUND, "FAllowForegroundActivate FALSE due to addtional checks");
        return FALSE;
    }
    /*
     * noactivate windows cannot take the foreground unless explicitly requested.
     * Note that windows passed to this function are expected to be toplevel, which is
     *  where this style has meaning. This might not be the case if AW_SKIP picked an
     *  owner window which is not top level. Since noactivate doesn't apply to the owner
     *  chain, it's OK to ignore this.
     */
    #if DBG
    if (TestwndChild(pwnd)) {
        RIPMSG1(RIP_WARNING, "FAllowForegroundActivate pwnd %#p is not top level", pwnd);
    }
    #endif
    if (TestWF(pwnd, WEFNOACTIVATE)) {
        TAGMSG1(DBGTAG_FOREGROUND, "FAllowForegroundActivate noactivate window:%#p", pwnd);
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetFocus (API)
*
* History:
* 11-08-90 DavidPe      Ported.
\***************************************************************************/

PWND xxxSetFocus(
    PWND pwnd)
{
    HWND hwndTemp;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTHREADINFO ptiActiveKL;
    PWND pwndTemp = NULL;
    TL tlpwndTemp;

    CheckLock(pwnd);
    /*
     * Special case if we are setting the focus to a null window.
     */
    if (pwnd == NULL) {
        if (IsHooked(ptiCurrent, WHF_CBT) && xxxCallHook(HCBT_SETFOCUS, 0,
                (LPARAM)HW(ptiCurrent->pq->spwndFocus), WH_CBT)) {
            return NULL;
        }

        /*
         * Save old focus so that we can return it.
         */
        hwndTemp = HW(ptiCurrent->pq->spwndFocus);
        xxxSendFocusMessages(ptiCurrent, pwnd);
        return RevalidateHwnd(hwndTemp);
    }

    /*
     * We no longer allow inter-thread set focuses.
     */
    if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
        return NULL;
    }

    /*
     * If the window recieving the focus or any of its ancestors is either
     * minimized or disabled, don't set the focus.
     */
    for (pwndTemp = pwnd; pwndTemp != NULL; pwndTemp = pwndTemp->spwndParent) {
        if (TestWF(pwndTemp, WFMINIMIZED) || TestWF(pwndTemp, WFDISABLED)) {

            /*
             * Don't change the focus if going to a minimized or disabled
             * window.
             */
            return NULL;
        }

        if (!TestwndChild(pwndTemp)) {
            break;
        }
    }
    UserAssert(pwndTemp != NULL);

    /*
     * pwndTemp should now be the top level ancestor of pwnd.
     */
    ThreadLockWithPti(ptiCurrent, pwndTemp, &tlpwndTemp);
    if (pwnd != ptiCurrent->pq->spwndFocus) {
        if (IsHooked(ptiCurrent, WHF_CBT) && xxxCallHook(HCBT_SETFOCUS, (WPARAM)HWq(pwnd),
                (LPARAM)HW(ptiCurrent->pq->spwndFocus), WH_CBT)) {
            ThreadUnlock(&tlpwndTemp);
            return NULL;
        }

        /*
         * Activation must follow the focus.  That is, setting the focus to
         * a particualr window means that the top-level parent of this window
         * must be the active window (top-level parent is determined by
         * following the parent chain until you hit a top-level guy).  So,
         * we must activate this top-level parent if it is different than
         * the current active window.
         *
         * Only change activation if top-level parent is not the currently
         * active window.
         */
        if (pwndTemp != ptiCurrent->pq->spwndActive) {

            /*
             * If this app is not in the foreground, see if foreground
             * activation is allowed.
             */
            if (ptiCurrent->pq != gpqForeground && FAllowForegroundActivate(ptiCurrent->pq, pwndTemp)) {
                /*
                 * If the process lost the foreground activation right by giving
                 * focus to a hidden window, then give it the right back. See
                 * bug #401932 for how this might affect an app
                 */
                if (!TestWF(pwndTemp, WFVISIBLE)){
                    ptiCurrent->ppi->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
                }
                if (!xxxSetForegroundWindow2(pwndTemp, ptiCurrent, SFW_SETFOCUS)) {
                    ThreadUnlock(&tlpwndTemp);
                    return NULL;
                }
            }

            /*
             * This will return FALSE if something goes wrong.
             */
            if (pwndTemp != ptiCurrent->pq->spwndActive) {
                if (!xxxActivateThisWindow(pwndTemp, 0, 0)) {
                    ThreadUnlock(&tlpwndTemp);
                    return NULL;
                }
            }
        }

        /*
         * Save current pwndFocus since we must return this.
         */
        pwndTemp = ptiCurrent->pq->spwndFocus;
        ThreadUnlock(&tlpwndTemp);
        ThreadLockWithPti(ptiCurrent, pwndTemp, &tlpwndTemp);

        /*
         * Change the global pwndFocus and send the WM_{SET/KILL}FOCUS
         * messages.
         */
        xxxSendFocusMessages(ptiCurrent, pwnd);

    } else {
        pwndTemp = ptiCurrent->pq->spwndFocus;
    }

    if (ptiCurrent->pq->spwndFocus) {
        /*
         * For the shell notification hook, we should use the pti->spkl
         * of the window with the focus. This could be a different thread,
         * (or even different process) when the queue is attached. The typical
         * case would be OLE out-of-process server.
         * #352877
         */
        ptiActiveKL = GETPTI(ptiCurrent->pq->spwndFocus);
    } else {
        /*
         * Preserving the NT4 behavior, otherwise.
         */
        ptiActiveKL = ptiCurrent;
    }
    UserAssert(ptiActiveKL);

    /*
     * Update the keyboard icon on the tray if the layout changed during focus change.
     * Before winlogon loads kbd layouts, pti->spkActive is NULL. #99321
     */
    if (ptiActiveKL->spklActive) {
        HKL hklActive = ptiActiveKL->spklActive->hkl;

        if ((gLCIDSentToShell != hklActive) && IsHooked(ptiCurrent, WHF_SHELL)) {
            gLCIDSentToShell = hklActive;
            xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)hklActive, WH_SHELL);
        }
    }

    hwndTemp = HW(pwndTemp);
    ThreadUnlock(&tlpwndTemp);

    /*
     * Return the pwnd of the window that lost the focus.
     * Return the validated hwndTemp: since we locked/unlocked pwndTemp,
     * it may be gone.
     */
    return RevalidateHwnd(hwndTemp);
}


/***************************************************************************\
* xxxSetActiveWindow (API)
*
*
* History:
* 11-08-90 DavidPe      Created.
\***************************************************************************/

PWND xxxSetActiveWindow(
    PWND pwnd)
{
    HWND hwndActiveOld;
    PTHREADINFO pti;

    CheckLock(pwnd);

    pti = PtiCurrent();

    /*
     * 32 bit apps must call SetForegroundWindow (to be NT 3.1 compatible)
     * but 16 bit apps that are foreground can make other apps foreground.
     * xxxActivateWindow makes sure an app is foreground.
     */
    if (!(pti->TIF_flags & TIF_16BIT) && (pwnd != NULL) && (GETPTI(pwnd)->pq != pti->pq)) {
        return NULL;
    }

    hwndActiveOld = HW(pti->pq->spwndActive);

    xxxActivateWindow(pwnd, AW_USE);

    return RevalidateHwnd(hwndActiveOld);
}


/***************************************************************************\
* xxxActivateWindow
*
* Changes the active window.  Given the pwnd and cmd parameters, changes the
* activation according to the following rules:
*
*  If cmd ==
*      AW_USE  Use the pwnd passed as the new active window.  If this
*              window cannot be activated, return FALSE.
*
*      AW_TRY  Try to use the pwnd passed as the new active window.  If
*              this window cannot be activated activate another window
*              using the rules for AW_SKIP.
*
*      AW_SKIP Activate any other window than pwnd passed.  The order of
*              searching for a candidate is as follows:
*              -   If pwnd is a popup, try its owner
*              -   else scan the top-level window list for the first
*                  window that is not pwnd that can be activated.
*
*      AW_USE2 Same as AW_USE except that the wParam on the WM_ACTIVATE
*              message will be set to 2 rather than the default of 1. This
*              indicates the activation is being changed due to a mouse
*              click.
*
*      AW_TRY2 Same as AW_TRY except that the wParam on the WM_ACTIVATE
*              message will be set to 2 rather than the default of 1. This
*              indicates the activation is being changed due to a mouse
*              click.
*
*      AW_SKIP2 Same as AW_SKIP, but we skip the first check that AW_SKIP
*              performes (the pwndOwner test).  This is used when
*              the pwnd parameter is NULL when this function is called.
*
*  This function returns TRUE if the activation changed and FALSE if
*  it did not change.
*
*  This function calls xxxActivateThisWindow() to actually do the activation.
*
* History:
* 11-08-90 DavidPe      Ported.
\***************************************************************************/

BOOL xxxActivateWindow(
    PWND pwnd,
    UINT cmd)
{
    DWORD fFlags = ATW_SETFOCUS;
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL tlpwnd;
    BOOL fSuccess;
    BOOL fAllowForeground, fSetForegroundRight;

    CheckLock(pwnd);


    if (pwnd != NULL) {

        /*
         * See if this window is OK to activate
         * (Cannot activate child windows).
         */
        if (TestwndChild(pwnd))
            return FALSE;

    } else {
        cmd = AW_SKIP2;
    }

    switch (cmd) {

    case AW_TRY2:
        fFlags |= ATW_MOUSE;

    /*
     *** FALL THRU **
     */
    case AW_TRY:

        /*
         * See if this window is OK to activate.
         */
        if (!FBadWindow(pwnd)) {
            break;
        }

    /*
     * If pwnd can not be activated, drop into the AW_SKIP case.
     */
    case AW_SKIP:

        /*
         * Try the owner of this popup.
         */
        if (TestwndPopup(pwnd) && !FBadWindow(pwnd->spwndOwner)) {
            pwnd = pwnd->spwndOwner;
            break;
        }

        /*
         * fall through
         */

    case AW_SKIP2:

        /*
         * Try the previously active window but don't activate a shell window
         */
        if ((gpqForegroundPrev != NULL)
                && !FBadWindow(gpqForegroundPrev->spwndActivePrev)
                /*
                 * Bug 290129 - joejo
                 *
                 * Test for WFBOTTOMMOST as opposed to WEFTOOLWINDOW to fix
                 * issue with Office2000 assistant and balloon help.
                 */
                && !TestWF(gpqForegroundPrev->spwndActivePrev, WFBOTTOMMOST)) {

            pwnd = gpqForegroundPrev->spwndActivePrev;
            break;
        }

        {
            PWND pwndSave = pwnd;
            DWORD flags = NTW_IGNORETOOLWINDOW;

TryAgain:
            /*
             * Find a new active window from the top-level window list,
             * skip tool windows the first time through.
             */
            pwnd = NextTopWindow(ptiCurrent, pwndSave, (cmd == AW_SKIP ? pwndSave : NULL),
                                 flags);

            if (pwnd) {
                if (!FBadWindow(pwnd->spwndLastActive))
                    pwnd = pwnd->spwndLastActive;
            } else {
                if (flags == NTW_IGNORETOOLWINDOW) {
                    flags = 0;
                    goto TryAgain;
                }
            }
        }


    case AW_USE:
        break;

    case AW_USE2:
        fFlags |= ATW_MOUSE;
        break;

    default:
        return FALSE;
    }

    if (pwnd == NULL)
        return FALSE;

    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

    if (GETPTI(pwnd)->pq == ptiCurrent->pq) {
        /*
         * Activation is within this queue. Usually this means just do
         * all the normal message sending. But if this queue isn't the
         * foreground queue, check to see if it is allowed to become
         * foreground.
         */

        /*
         * Sometimes processes are granted the right to foreground
         * activate themselves, if they aren't foreground, like
         * when starting up (there are other cases). Grant this if
         * this process is allowed.
         */

         /*
          * Removed the first clause from the following if statement
          * if (pti->pq == gpqForeground || !FAllowForegroundActivate(pti->pq)) {
          * This fixes the problem where foreground app A activates app B
          * the user switches to app C, then B does something to activate A
          * (like destroy an owned window).  A now comes to the foreground
          * unexpectedly. This clause is not in Win95 code and was added in
          * 3.51 code to fix some test script hang (Bug 7461)
          */

        if (!FAllowForegroundActivate(ptiCurrent->pq, pwnd)) {
            fSuccess = xxxActivateThisWindow(pwnd, 0, fFlags);
            ThreadUnlock(&tlpwnd);
            return fSuccess;
        }

        fAllowForeground = TRUE;
        /*
         * If this thread doesn't have any top-level non-minimized visible windows,
         *  let it keep the right since it's probably not done with activation yet.
         * Bug 274383 - joejo
         */
        fSetForegroundRight = (ptiCurrent->cVisWindows == 0);

    } else {
        /*
         * If the caller is in the foreground, it has the right to change
         * the foreground itself.
         */
        fAllowForeground = (gpqForeground == ptiCurrent->pq)
                                || (gpqForeground == NULL);
        /*
         * Give the right to change the foreground to this thread only if it already
         *  has it, it has more visible windows or this is an explicit request to
         *  activate the given window.
         * When an app destroys/hides the active (foreground) window, we choose a new
         *  active window and will probably hit this code. We don't want to give them the
         *  right to change the foreground in this case since it's us making the activation
         *  (See comments below). We let them keep the right so apps destroying their last
         *  visible window (ie a splash initialization window) can take the foreground again
         *  when they create another window (the main window).
         */
        if (fAllowForeground) {
            fSetForegroundRight = ((ptiCurrent->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE)
                                        || (ptiCurrent->cVisWindows != 0)
                                        || (cmd == AW_USE));
        } else {
            fSetForegroundRight = FALSE;
        }
    }

    fSuccess = FALSE;
    if (fAllowForeground) {
        /*
         * Hack! Temporarily give this thread a foreground right to make sure
         *  this call succeds.
         */
        ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
        TAGMSG1(DBGTAG_FOREGROUND, "xxxActivateWindow temporarly set TIF %#p", ptiCurrent);
        fSuccess = xxxSetForegroundWindow(pwnd, (cmd == AW_USE));

        if (fSetForegroundRight) {
            /*
             * We activated some other app on purpose. If so that means this
             * thread is probably controlling this window and will probably want
             * to set itself active and foreground really soon again (for example,
             * a setup program doing dde to progman). A real live case: wingz -
             * bring up page setup..., options..., ok, ok. Under Win3.1 the
             * activation goes somewhere strange and then wingz calls
             * SetActiveWindow() to bring it back. This'll make sure that works.
             *
             * We used to set this before calling xxxSetForegeroundWindow above.
             * This would cause callers doing an intra-queue activation to
             *  retain their foreground right eventhough it is supposed to be
             *  a one shot deal (that's why FAllowForeground clears the bits).
             * In addtion, xxxSetForegroundWindow might clear the bits (it didnt'
             *  used to); so we do it here, and only if we did an inter-queue
             *  activation
             */
            ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxActivateWindow set TIF %#p", ptiCurrent);
        } else {
            /*
             * Make sure to remove the temporary right.
             */
            ptiCurrent->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxActivateWindow clear TIF %#p", ptiCurrent);
        }
    }

    ThreadUnlock(&tlpwnd);
    return fSuccess;
}


/***************************************************************************\
* GNT_NextTopScan
*
* Starting at hwnd (or hwndDesktop->hwndChild if hwnd == NULL), find
* the next window owned by hwndOwner.
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND GNT_NextTopScan(
    PTHREADINFO pti,
    PWND pwnd,
    PWND pwndOwner)
{
    if (pwnd == NULL) {
        UserAssert(pti->rpdesk != NULL &&
                   (pti->rpdesk->dwDTFlags & DF_DESKWNDDESTROYED) == 0);
        pwnd = pti->rpdesk->pDeskInfo->spwnd->spwndChild;
    } else {
        pwnd = pwnd->spwndNext;
    }

    for (; pwnd != NULL; pwnd = pwnd->spwndNext) {
        if (pwnd->spwndOwner == pwndOwner)
            break;
    }

    return pwnd;
}


/***************************************************************************\
* NTW_GetNextTop
*
* <brief description>
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND NTW_GetNextTop(
    PTHREADINFO pti,
    PWND pwnd)
{
    PWND pwndOwner;

    if (pwnd == NULL) {
        goto ReturnFirst;
    }

    /*
     * First look for any windows owned by this window
     * If that fails, then go up one level to our owner,
     * and look for next window owned by his owner.
     * This results in a depth-first ordering of the windows.
     */

    pwndOwner = pwnd;
    pwnd = NULL;

    do {
        if ((pwnd = GNT_NextTopScan(pti, pwnd, pwndOwner)) != NULL) {
            return pwnd;
        }

        pwnd = pwndOwner;
        if (pwnd != NULL)
            pwndOwner = pwnd->spwndOwner;

    } while (pwnd != NULL);

ReturnFirst:

    /*
     * If no more windows to enumerate, return the first unowned window.
     */
    return GNT_NextTopScan(pti, NULL, NULL);
}


/***************************************************************************\
* NTW_GetPrevTop
*
* <brief description>
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND NTW_GetPrevTop(
    PTHREADINFO pti,
    PWND pwndCurrent)
{
    PWND pwnd;
    PWND pwndPrev;

    /*
     * Starting from beginning, loop thru the windows, saving the previous
     * one, until we find the window we're currently at.
     */
    pwndPrev = NULL;

    do {
        pwnd = NTW_GetNextTop(pti, pwndPrev);
        if (pwnd == pwndCurrent && pwndPrev != NULL) {
            break;
        }
    } while ((pwndPrev = pwnd) != NULL);

    return pwndPrev;
}


/***************************************************************************\
* NextTopWindow
*
* <brief description>
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND CheckTopLevelOnly(
    PWND pwnd)
{
    /*
     * fnid == -1 means this is a desktop window - find the first child
     * of this desktop, if it is one.
     */
    while (pwnd != NULL && GETFNID(pwnd) == FNID_DESKTOP) {
        pwnd = pwnd->spwndChild;
    }

    return pwnd;
}


PWND NextTopWindow(
    PTHREADINFO pti,
    PWND        pwnd,
    PWND        pwndSkip,
    DWORD       flags )
{
    BOOL fFoundFirstUnowned;
    PWND pwndPrev;
    PWND pwndStart = pwnd;
    PWND pwndFirstUnowned;

    /*
     * If the search gets to the first unowned window TWICE (See NTW_GetNextTop),
     * we couldn't find a window
     */
    pwndFirstUnowned = GNT_NextTopScan(pti, NULL, NULL);
    fFoundFirstUnowned = FALSE;

    if (pwnd == NULL) {
        pwnd = NTW_GetNextTop(pti, NULL);

        /*
         * Don't allow desktop windows.
         */
        pwnd = pwndStart = CheckTopLevelOnly(pwnd);

        if (pwnd == NULL)
            return NULL;    // No more windows owned by the thread

        goto Loop;
    }

    /*
     * Don't allow desktop windows.
     */
    pwnd = pwndStart = CheckTopLevelOnly(pwnd);
    if (pwnd == NULL)
        return NULL;        // No more windows owned by this thread

    /*
     * Don't allow desktop windows.
     */
    pwndSkip = CheckTopLevelOnly(pwndSkip);



    while (TRUE) {
        pwndPrev = pwnd;
        pwnd = ((flags & NTW_PREVIOUS) ? NTW_GetPrevTop(pti, pwnd) : NTW_GetNextTop(pti, pwnd));

        /*
         * If we've cycled to where we started, couldn't find one: return NULL
         */
        if (pwnd == pwndStart)
            break;

        if (pwnd == pwndFirstUnowned) {
            if (fFoundFirstUnowned) {
                break;
            } else {
                fFoundFirstUnowned = TRUE;
            }
        }

        if (pwnd == NULL)
            break;

        /*
         * If we've cycled over desktops, then return NULL because we'll
         * never hit pwndStart.
         */
        if (PWNDDESKTOP(pwndStart) != PWNDDESKTOP(pwnd))
            break;

        /*
         * going nowhere is a bad sign.
         */
        if (pwndPrev == pwnd) {
            /*
             * This is a temporary fix chosen because its safe.  This case
             * was hit when a window failed the NCCREATE message and fell
             * into xxxFreeWindow and left the critical section after being
             * unlinked.  The app then died and entered cleanup code and
             * tried to destroy this window again.
             */
            break;
        }

Loop:
        if (pwnd == pwndSkip)
            continue;

        /*
         *  If it's visible, not disabled, not a noactivate window
         *   and either we're not ignoringtool windows or it's not a
         *  tool window, then we've got it.
         */
        if (TestWF(pwnd, WFVISIBLE) &&
            !TestWF(pwnd, WFDISABLED) &&
            !TestWF(pwnd, WEFNOACTIVATE) &&
            (!(flags & NTW_IGNORETOOLWINDOW) || !TestWF(pwnd, WEFTOOLWINDOW))) {

            return pwnd;
        }
    }

    return NULL;
}


/***************************************************************************\
* xxxCheckFocus
*
*
* History:
* 11-08-90 DarrinM      Ported.
\***************************************************************************/

void xxxCheckFocus(
    PWND pwnd)
{
    TL tlpwndParent;
    PTHREADINFO pti;

    CheckLock(pwnd);

    pti = PtiCurrent();

    if (pwnd == pti->pq->spwndFocus) {

        /*
         * Set focus to parent of child window.
         */
        if (TestwndChild(pwnd)) {
            ThreadLockWithPti(pti, pwnd->spwndParent, &tlpwndParent);
            xxxSetFocus(pwnd->spwndParent);
            ThreadUnlock(&tlpwndParent);
        } else {
            xxxSetFocus(NULL);
        }
    }

    if (pwnd == pti->pq->caret.spwnd) {
        zzzDestroyCaret();
    }
}


/***************************************************************************\
* SetForegroundThread
*
*
* History:
* 12-xx-91 MarkL    Created.
* 02-12-92 DavidPe  Rewrote as SetForegroundThread().
\***************************************************************************/

VOID SetForegroundThread(
    PTHREADINFO pti)
{
    PKL pklPrev;

    if (pti == gptiForeground)
        return;

    /*
     * The foregorund thread must be on the foreground queue.
     * xxxSendFocusMessages obtains this pti from a window
     *  received as a parameter. If the owner of the window
     *  exited during a callback (in the caller), then the pti
     *  will be gptiRit,which might not be in the foreground queue
     */
    UserAssert((pti == NULL)
                || (pti->pq == gpqForeground)
                || (pti == gptiRit));

    /*
     * If we're changing gptiForeground to another process,
     * change the base priorities of the two processes.  We
     * know that if either 'pti' or 'gptiForeground' is NULL
     * that both aren't NULL due to the first test in this
     * function.
     */
    if ((pti == NULL) || (gptiForeground == NULL) ||
            (pti->ppi != gptiForeground->ppi)) {
        if (gptiForeground != NULL) {
            gptiForeground->ppi->W32PF_Flags &= ~W32PF_FORCEBACKGROUNDPRIORITY;
            SetForegroundPriority(gptiForeground, FALSE);
        }

        if (pti != NULL) {
            SetForegroundPriority(pti, TRUE);
        }
    }

    if (gptiForeground) {
        pklPrev = gptiForeground->spklActive;
    } else {
        pklPrev = NULL;
    }
    gptiForeground = pti;
    if (gptiForeground && gptiForeground->spklActive) {
        ChangeForegroundKeyboardTable(pklPrev, gptiForeground->spklActive);
    }

    /*
     * Clear recent down information in the async key state to prevent
     * spying by apps.
     */
    RtlZeroMemory(gafAsyncKeyStateRecentDown, CBKEYSTATERECENTDOWN);

    /*
     * Update the async key cache index.
     */
    gpsi->dwAsyncKeyCache++;
}

VOID SetForegroundPriorityProcess(
    PPROCESSINFO    ppi,
    PTHREADINFO     pti,
    BOOL            fSetForeground)
{
    PEPROCESS Process;
    UCHAR PriorityClassSave;

    UserAssert(ppi != NULL);

    Process = ppi->Process;
    UserAssert(ppi->Process != NULL);

    if (ppi->W32PF_Flags & W32PF_IDLESCREENSAVER) {
        fSetForeground = FALSE;
        PriorityClassSave = PsGetProcessPriorityClass(Process);
        PsSetProcessPriorityClass(Process, PROCESS_PRIORITY_CLASS_IDLE);
    }

    /*
     * If we previously delayed setting some process to the background
     * because a screen saver was starting up, do it now.
     */
    if (gppiForegroundOld != NULL) {
        if (gppiForegroundOld == ppi) {
            gppiForegroundOld = NULL;
        } else if (ppi != gppiScreenSaver) {
            PsSetProcessPriorityByClass(gppiForegroundOld->Process, PsProcessPriorityBackground);
            gppiForegroundOld = NULL;
        }
    }

    /*
     * If this app should be background, don't let it go foreground.
     * Foreground apps run at a higher base priority.
     */
    if (ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY) {
        if (pti != NULL && !(pti->TIF_flags & TIF_GLOBALHOOKER)) {
            PsSetProcessPriorityByClass(Process, PsProcessPrioritySpinning);
        }
    } else if (fSetForeground) {
        PsSetProcessPriorityByClass(Process, PsProcessPriorityForeground);
    } else if (pti != NULL && !(pti->TIF_flags & TIF_GLOBALHOOKER)) {
        /*
         * Don't adjust the priority of the current foreground process if
         * the new foreground process is a screen saver.
         */
        if (gppiScreenSaver && gppiScreenSaver != ppi) {
            gppiForegroundOld = ppi;
        } else {
            PsSetProcessPriorityByClass(Process, PsProcessPriorityBackground);
        }
    }

    if (ppi->W32PF_Flags & W32PF_IDLESCREENSAVER) {
        PsSetProcessPriorityClass(Process, PriorityClassSave);
    }
}


VOID SetForegroundPriority(
    PTHREADINFO pti,
    BOOL fSetForeground)
{
    UserAssert(pti != NULL);

    /*
     * We don't want to change the priority of system or console threads
     */
    if (pti->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))
        return;

    SetForegroundPriorityProcess(pti->ppi, pti, fSetForeground);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\exitwin.c ===
/**************************** Module Header ********************************\
* Module Name: exitwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 07-23-92 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define OPTIONMASK (EWX_SHUTDOWN | EWX_REBOOT | EWX_FORCE)

/*
 * Globals local to this file only
 */
PWINDOWSTATION  gpwinstaLogoff;
DWORD           gdwLocks;
DWORD           gdwShutdownFlags;
HANDLE          gpidEndSession;

#ifdef PRERELEASE
DWORD gdwllParamCopy, gdwStatusCopy, gdwFlagsCopy;
BOOL  gfNotifiedCopy;
#endif // PRERELEASE

/*
 * Called by ExitWindowsEx() to check whether the thread is permitted to logoff.
 * If it is, and this is WinLogon calling, then also save any of the user's
 * setting that have not yet been stored in the profile.
 */
BOOL PrepareForLogoff(
    UINT uFlags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckCritIn();

    if (ptiCurrent->TIF_flags & TIF_RESTRICTED) {
        PW32JOB pW32Job;

        pW32Job = ptiCurrent->ppi->pW32Job;

        UserAssert(pW32Job != NULL);

        if (pW32Job->restrictions & JOB_OBJECT_UILIMIT_EXITWINDOWS) {
            // Not permitted to ExitWindows.
            return FALSE;
        }
    }

    /*
     * There are no restrictions, or the restriction do not deny shutdown:
     * The caller is about to ExitWindowsEx via CSR, so save the volatile
     * elements of the User preferences in their profile
     */
    if (PsGetThreadProcessId(ptiCurrent->pEThread) == gpidLogon) {
        /*
         * Save the current user's NumLock state
         */
        TL tlName;
        PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
        RegisterPerUserKeyboardIndicators(pProfileUserName);
        FreeProfileUserName(pProfileUserName, &tlName);
    }

    return TRUE;
    UNREFERENCED_PARAMETER(uFlags);
}


BOOL NotifyLogon(
    PWINDOWSTATION pwinsta,
    PLUID pluidCaller,
    DWORD dwFlags,
    NTSTATUS StatusCode)
{
    BOOL fNotified = FALSE;
    DWORD dwllParam;
    DWORD dwStatus;

    if (!(dwFlags & EWX_NONOTIFY)) {

        if (dwFlags & EWX_CANCELED) {
            dwllParam = LOGON_LOGOFFCANCELED;
            dwStatus = StatusCode;
        } else {
            dwllParam = LOGON_LOGOFF;
            dwStatus = dwFlags;
        }

        if (dwFlags & EWX_SHUTDOWN) {
            /*
             * Post the message to the global logon notify window
             */
            if (gspwndLogonNotify != NULL) {
                _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                             dwllParam, (LONG)dwStatus);
                fNotified = TRUE;
            }
        } else {
            if (gspwndLogonNotify != NULL &&
                    (RtlEqualLuid(&pwinsta->luidUser, pluidCaller) ||
                     RtlEqualLuid(&luidSystem, pluidCaller))) {
                _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, dwllParam,
                        (LONG)dwStatus);
                fNotified = TRUE;
            }
        }
    }

#ifdef PRERELEASE
    /*
     * Remember what these were for debugging purposes.
     */
    gdwllParamCopy = dwllParam;
    gdwFlagsCopy   = dwFlags;
    gdwStatusCopy  = dwStatus;
    gfNotifiedCopy = fNotified;
#endif // PRERELEASE

    return fNotified;
}

NTSTATUS InitiateShutdown(
    PETHREAD Thread,
    PULONG lpdwFlags)
{
    static PRIVILEGE_SET psShutdown = {
        1, PRIVILEGE_SET_ALL_NECESSARY, { SE_SHUTDOWN_PRIVILEGE, 0 }
    };
    PEPROCESS Process;
    LUID luidCaller;
    PPROCESSINFO ppi;
    PWINDOWSTATION pwinsta;
    HWINSTA hwinsta;
    PTHREADINFO ptiClient;
    NTSTATUS Status;
    DWORD dwFlags;

    /*
     * Find out the callers sid. Only want to shutdown processes in the
     * callers sid.
     */
    Process = PsGetThreadProcess(Thread);
    ptiClient = PtiFromThread(Thread);
    Status = GetProcessLuid(Thread, &luidCaller);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * Set the system flag if the caller is a system process.
     * Winlogon uses this to determine in which context to perform
     * a shutdown operation.
     */
    dwFlags = *lpdwFlags;
    if (RtlEqualLuid(&luidCaller, &luidSystem)) {
        dwFlags |= EWX_SYSTEM_CALLER;
    } else {
        dwFlags &= ~EWX_SYSTEM_CALLER;
    }

    /*
     * Find a windowstation.  If the process does not have one
     * assigned, use the standard one.
     */
    ppi = PpiFromProcess(Process);
    if (ppi == NULL) {
        /*
         * We ran into a case where the thread was terminated and had already
         * been cleaned up by USER.  Thus, the ppi and ptiClient was NULL.
         */
        return STATUS_INVALID_HANDLE;
    }
    pwinsta = ppi->rpwinsta;
    hwinsta = ppi->hwinsta;
    /*
     * If we're not being called by Winlogon, validate the call and
     * notify the logon process to do the actual shutdown.
     */
    if (PsGetThreadProcessId(Thread) != gpidLogon) {
        dwFlags &= ~EWX_WINLOGON_CALLER;
        *lpdwFlags = dwFlags;

        if (pwinsta == NULL) {
#ifndef LATER
            return STATUS_INVALID_HANDLE;
#else
            hwinsta = ppi->pOpenObjectTable[HI_WINDOWSTATION].h;
            if (hwinsta == NULL) {
                return STATUS_INVALID_HANDLE;
            }
            pwinsta = (PWINDOWSTATION)ppi->pOpenObjectTable[HI_WINDOWSTATION].phead;
#endif
        }

        /*
         * Check security first - does this thread have access?
         */
        if (!RtlAreAllAccessesGranted(ppi->amwinsta, WINSTA_EXITWINDOWS)) {
            return STATUS_ACCESS_DENIED;
        }

        /*
         * If the client requested shutdown, reboot, or poweroff they must have
         * the shutdown privilege.
         */
        if (dwFlags & EWX_SHUTDOWN) {
            if (!IsPrivileged(&psShutdown) ) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {

            /*
             * If this is a non-IO windowstation and we are not shutting down,
             * fail the call.
             */
            if (pwinsta->dwWSF_Flags & WSF_NOIO) {
                return STATUS_INVALID_DEVICE_REQUEST;
            }
        }
    }

    /*
     * Is there a shutdown already in progress?
     */
    if (gdwThreadEndSession != 0) {
        DWORD dwNew;

        /*
         * If the current shutdown in another sid and is not being done by
         * winlogon, override it.
         */
        if (!RtlEqualLuid(&luidCaller, &gpwinstaLogoff->luidEndSession) &&
                (gpidEndSession != gpidLogon)) {
            return STATUS_RETRY;
        }

        /*
         * Calculate new flags
         */
        dwNew = dwFlags & OPTIONMASK & (~gdwShutdownFlags);

        /*
         * Should we override the other shutdown?  Make sure
         * winlogon does not recurse.
         */
        if (dwNew && HandleToUlong(PsGetCurrentThreadId()) !=
                gdwThreadEndSession) {
            /*
             * Only one windowstation can be logged off at a time.
             */
            if (!(dwFlags & EWX_SHUTDOWN) &&
                    pwinsta != gpwinstaLogoff) {
                return STATUS_DEVICE_BUSY;
            }
            /* Bug# 453872
             * Since we are about to fail this call. Do not change gdwShutdownFlags
             * Later when we notify winlogon in EndShtdown, if we changed gdwShutdownFlags
             * and the call does not have EWX_WINLOGON_CALLER, winlogon will abort the call
             * to take care of the case when an application keeps calling ExitWindows.
             * [msadek- 08/08/2001]
             */ 
#if 0 

            /*
             * Set the new flags
             */
            gdwShutdownFlags = dwFlags;
#endif

            if (dwNew & EWX_FORCE) {
                return STATUS_RETRY;
            } else {
                return STATUS_PENDING;
            }
        } else {
            /*
             * Don't override
             */
            return STATUS_PENDING;
        }
    }

    /*
     * If the caller is not winlogon, signal winlogon to start
     * the real shutdown.
     */
    if (PsGetThreadProcessId(Thread) != gpidLogon) {
        if (dwFlags & EWX_NOTIFY) {
            if (ptiClient && ptiClient->TIF_flags & TIF_16BIT)
                gptiShutdownNotify = ptiClient;
            dwFlags &= ~EWX_NOTIFY;
            *lpdwFlags = dwFlags;
        }

        if (NotifyLogon(pwinsta, &luidCaller, dwFlags, STATUS_SUCCESS))
            return STATUS_PENDING;
        else if (ptiClient && ptiClient->cWindows)
            return STATUS_CANT_WAIT;
    }

    /*
     * Mark this thread as the one that is currently processing
     * exit windows, and set the global saying someone is exiting
     */
    dwFlags |= EWX_WINLOGON_CALLER;
    *lpdwFlags = dwFlags;
    gdwShutdownFlags = dwFlags;

    gdwThreadEndSession = HandleToUlong(PsGetCurrentThreadId());
    SETSYSMETBOOL(SHUTTINGDOWN, TRUE);
    gpidEndSession = PsGetCurrentThreadProcessId();
    gpwinstaLogoff = pwinsta;
    pwinsta->luidEndSession = luidCaller;

    /*
     * Lock the windowstation to prevent apps from starting
     * while we're doing shutdown processing.
     */
    gdwLocks = pwinsta->dwWSF_Flags & (WSF_SWITCHLOCK | WSF_OPENLOCK);
    pwinsta->dwWSF_Flags |= (WSF_OPENLOCK | WSF_SHUTDOWN);

    /*
     * Set the flag WSF_REALSHUTDOWN if we are not doing just a
     * logoff
     */
    if (dwFlags &
        (EWX_WINLOGON_OLD_SHUTDOWN | EWX_WINLOGON_OLD_REBOOT |
         EWX_SHUTDOWN | EWX_REBOOT)) {

        pwinsta->dwWSF_Flags |= WSF_REALSHUTDOWN;
    }

    return STATUS_SUCCESS;
}

NTSTATUS EndShutdown(
    PETHREAD Thread,
    NTSTATUS StatusShutdown)
{
    PWINDOWSTATION pwinsta = gpwinstaLogoff;
    PDESKTOP pdesk;
    LUID luidCaller;
    UserAssert(gpwinstaLogoff);

    gpwinstaLogoff = NULL;
    gpidEndSession = NULL;
    gdwThreadEndSession = 0;
    SETSYSMETBOOL(SHUTTINGDOWN, FALSE);
    pwinsta->dwWSF_Flags &= ~WSF_SHUTDOWN;

    if (!NT_SUCCESS(GetProcessLuid(Thread, &luidCaller))) {
        luidCaller = RtlConvertUlongToLuid(0);     // null luid
    }

    if (!NT_SUCCESS(StatusShutdown)) {

        /*
         * We need to notify the process that called ExitWindows that
         * the logoff was aborted.
         */
        if (gptiShutdownNotify) {
            _PostThreadMessage(gptiShutdownNotify, WM_ENDSESSION, FALSE, 0);
            gptiShutdownNotify = NULL;
        }

        /*
         * Reset the windowstation lock flags so apps can start
         * again.
         */
        pwinsta->dwWSF_Flags =
                (pwinsta->dwWSF_Flags & ~WSF_OPENLOCK) |
                gdwLocks;

        /*
         * Bug 294204 - joejo
         * Tell winlogon that we we cancelled shutdown/logoff.
         */
        NotifyLogon(pwinsta, &luidCaller, gdwShutdownFlags | EWX_CANCELED, StatusShutdown);

        return STATUS_SUCCESS;
    }

    gptiShutdownNotify = NULL;

    /*
     * If logoff is occuring for the user set by winlogon, perform
     * the normal logoff cleanup.  Otherwise, clear the open lock
     * and continue.
     */
    if (((pwinsta->luidUser.LowPart != 0) || (pwinsta->luidUser.HighPart != 0)) &&
            RtlEqualLuid(&pwinsta->luidUser, &luidCaller)) {

        /*
         * Zero out the free blocks in all desktop heaps.
         */
        for (pdesk = pwinsta->rpdeskList; pdesk != NULL; pdesk = pdesk->rpdeskNext) {
            RtlZeroHeap(Win32HeapGetHandle(pdesk->pheapDesktop), 0);
        }

        /*
         * Logoff/shutdown was successful. In case this is a logoff, remove
         * everything from the clipboard so the next logged on user can't get
         * at this stuff.
         */
        ForceEmptyClipboard(pwinsta);

        /*
         * Destroy all non-pinned atoms in the global atom table.  User can't
         * create pinned atoms.  Currently only the OLE atoms are pinned.
         */
        RtlEmptyAtomTable(pwinsta->pGlobalAtomTable, FALSE);

        // this code path is hit only on logoff and also on shutdown
        // We do not want to unload fonts twice when we attempt shutdown
        // so we mark that the fonts have been unloaded at a logoff time

        if (TEST_PUDF(PUDF_FONTSARELOADED)) {
            LeaveCrit();
            GreRemoveAllButPermanentFonts();
            EnterCrit();
            CLEAR_PUDF(PUDF_FONTSARELOADED);
        }
    } else {
        pwinsta->dwWSF_Flags &= ~WSF_OPENLOCK;
    }

    /*
     * Tell winlogon that we successfully shutdown/logged off.
     */
    NotifyLogon(pwinsta, &luidCaller, gdwShutdownFlags, STATUS_SUCCESS);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* xxxClientShutdown2
*
* Called by xxxClientShutdown
\***************************************************************************/

LONG xxxClientShutdown2(
    PBWL pbwl,
    UINT msg,
    WPARAM wParam)
{
    HWND *phwnd;
    PWND pwnd;
    TL tlpwnd;
    BOOL fEnd;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fDestroyTimers;
    LPARAM lParam;

    /*
     * Make sure we don't send this window any more WM_TIMER
     * messages if the session is ending. This was causing
     * AfterDark to fault when it freed some memory on the
     * WM_ENDSESSION and then tried to reference it on the
     * WM_TIMER.
     * LATER GerardoB: Do we still need to do this??
     * Do this horrible thing only if the process is in the
     * context being logged off.
     * Perhaps someday we should post a WM_CLOSE so the app
     * gets a better chance to clean up (if this process is in
     * the context being logged off, winsrv is going to call
     * TerminateProcess soon after this).
     */
     fDestroyTimers = (wParam & WMCS_EXIT) && (wParam & WMCS_CONTEXTLOGOFF);

     /*
      * fLogOff and fEndSession parameters (WM_ENDSESSION only)
      */
     lParam = wParam & ENDSESSION_LOGOFF;
     wParam &= WMCS_EXIT;

    /*
     * Now enumerate these windows and send the WM_QUERYENDSESSION or
     * WM_ENDSESSION messages.
     */
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        ThreadLockAlways(pwnd, &tlpwnd);

        /*
         * Send the message.
         */
        switch (msg) {
        case WM_QUERYENDSESSION:

            /*
             * Windows does not send the WM_QUERYENDSESSION to the app
             * that called ExitWindows
             */
            if (ptiCurrent == gptiShutdownNotify) {
                fEnd = TRUE;
            } else {
                fEnd = (xxxSendMessage(pwnd, WM_QUERYENDSESSION, FALSE, lParam) != 0);
                if (!fEnd) {
                    RIPMSG2(RIP_WARNING, "xxxClientShutdown2: pwnd:%p canceled shutdown. lParam:%p",
                            pwnd, lParam);
                }
            }
            break;

        case WM_ENDSESSION:
            xxxSendMessage(pwnd, WM_ENDSESSION, wParam, lParam);
            fEnd = TRUE;

            if (fDestroyTimers) {
                DestroyWindowsTimers(pwnd);
            }

            break;
        }

        ThreadUnlock(&tlpwnd);

        if (!fEnd)
            return WMCSR_CANCEL;
    }

    return WMCSR_ALLOWSHUTDOWN;
}
/***************************************************************************\
* xxxClientShutdown
*
* This is the processing that occurs when an application receives a
* WM_CLIENTSHUTDOWN message.
*
* 10-01-92 ScottLu      Created.
\***************************************************************************/
LONG xxxClientShutdown(
    PWND pwnd,
    WPARAM wParam)
{
    PBWL pbwl;
    PTHREADINFO ptiT;
    LONG lRet;

    /*
     * Build a list of windows first.
     */
    ptiT = GETPTI(pwnd);

    if ((pbwl = BuildHwndList(ptiT->rpdesk->pDeskInfo->spwnd->spwndChild,
            BWL_ENUMLIST, ptiT)) == NULL) {
        /*
         * Can't allocate memory to notify this thread's windows of shutdown.
         * Can't do more than kill the app
         */
        return WMCSR_ALLOWSHUTDOWN;
    }

    if (wParam & WMCS_QUERYEND) {
        lRet = xxxClientShutdown2(pbwl, WM_QUERYENDSESSION, wParam);
    } else {
        xxxClientShutdown2(pbwl, WM_ENDSESSION, wParam);
        lRet = WMCSR_DONE;
    }

    FreeHwndList(pbwl);
    return lRet;
}

/***************************************************************************\
* xxxRegisterUserHungAppHandlers
*
* This routine simply records the WOW callback address for notification of
* "hung" wow apps.
*
* History:
* 01-Apr-1992 jonpa      Created.
* Added saving and duping of wowexc event handle
\***************************************************************************/

BOOL xxxRegisterUserHungAppHandlers(
    PFNW32ET pfnW32EndTask,
    HANDLE   hEventWowExec)
{
    BOOL   bRetVal;
    PPROCESSINFO    ppi;
    PWOWPROCESSINFO pwpi;
    ULONG ProcessInfo;
    NTSTATUS Status;

    //
    // Check the Target Process to see if this is a 16-bit process
    //

    Status = ZwQueryInformationProcess( NtCurrentProcess(),
                                        ProcessWx86Information,
                                        &ProcessInfo,
                                        sizeof(ProcessInfo),
                                        NULL
                                      );

    if (!NT_SUCCESS(Status) || ProcessInfo == 0) {
        return FALSE;
    }


    //
    //  Allocate the per wow process info stuff
    //  ensuring the memory is Zero init.
    //
    pwpi = (PWOWPROCESSINFO) UserAllocPoolWithQuotaZInit(
            sizeof(WOWPROCESSINFO), TAG_WOWPROCESSINFO);

    if (!pwpi)
        return FALSE;

    //
    // Reference the WowExec event for kernel access
    //
    bRetVal = NT_SUCCESS(ObReferenceObjectByHandle(
                 hEventWowExec,
                 EVENT_ALL_ACCESS,
                 *ExEventObjectType,
                 UserMode,
                 &pwpi->pEventWowExec,
                 NULL
                 ));

    //
    //  if sucess then intialize the pwpi, ppi structs
    //  else free allocated memory
    //
    if (bRetVal) {
        pwpi->hEventWowExecClient = hEventWowExec;
        pwpi->lpfnWowExitTask = pfnW32EndTask;
        ppi = PpiCurrent();
        ppi->pwpi = pwpi;

        // add to the list, order doesn't matter
        pwpi->pwpiNext = gpwpiFirstWow;
        gpwpiFirstWow  = pwpi;

        }
    else {
        UserFreePool(pwpi);
        }

   return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\fullscr.c ===
/****************************** Module Header ******************************\
* Module Name: fullscr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the fullscreen code for Win32k.
*
* History:
* 12-Dec-1991 mikeke   Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop



/***************************************************************************\
* We can only have one fullscreen window at a time so this information can
* be stored globally.
*
* We partially use busy waiting to set the state of the hardware. The
* problem is that while we are in the middle of a fullscreen switch, we
* leave the critical section, so someone else could come in and change the
* state of the fullscreen stuff. In order to keep the system from getting
* confused about the state of the device, we actually "post" the request.
*
* What we do with external requests for switching, is that we will do busy
* waiting on these state variables. So an app won't be able to request a
* fullscreen switch while one is under way.  This is a way to make the
* system completely reentrant for state switches.
*
* The state variables themselves can only be touched while owning the
* critical section. We are guaranteed that we will not busy wait forever
* since the switch operations (although long) will eventually finish.
*
* 20-Mar-1996 andreva  Created
\***************************************************************************/

#if DBG
LONG TraceFullscreenSwitch;
#endif

HANDLE ghSwitcher;
BOOL gfRedoFullScreenSwitch, gfGdiEnabled = TRUE;
POINT gptCursorFullScreen;

VOID SetVDMCursorBounds(LPRECT lprc);


VOID UserSetDelayedChangeBroadcastForAllDesktops(
    PDESKTOP pCurrentDesktop)
{
    PWINDOWSTATION pwinsta;
    PDESKTOP pdesk;

    /*
     * Get a pointer to the windowstation so we can change display setting
     * for all of its destops.
     */
    if ((pwinsta = grpWinStaList) == NULL) {
        RIPMSGF0(RIP_ERROR, "No interactive WindowStation");
        return;
    }

    /*
     * Walk all the desktops of the winstation and, for each of them, just
     * set its delayed Broadcast indicator to TRUE so that next switch to
     * that destop will force Display Settings change messages to be
     * broadcasted to windows of that desktop.
     */
    pdesk = pwinsta->rpdeskList;
    while (pdesk != NULL) {
        if (pdesk != pCurrentDesktop) {
            pdesk->dwDTFlags |= DF_NEWDISPLAYSETTINGS;
        }

        pdesk = pdesk->rpdeskNext;
    }
}


/***************************************************************************\
* FullScreenCleanup
*
* This is called during thread cleanup, we test to see if we died during a
* full screen switch and switch back to the GDI desktop if we did.
*
* NOTE:
* All the variables touched here are guaranteed to be touched under
* the CritSect.
*
* 12-Dec-1991 mikeke   Created
\***************************************************************************/
VOID FullScreenCleanup(
    VOID)
{
    if (PsGetCurrentThreadId() == ghSwitcher) {
        /*
         * Correct the full screen state.
         */
        if (gfGdiEnabled) {
            TRACE_SWITCH(("Switching: FullScreenCleanup: Gdi Enabled\n"));

            /*
             * Gdi is enabled; since we are switching away from gdi the only
             * thing we could have done so far is locking the screen so
             * unlock it.
             */
            CLEAR_PUDF(PUDF_LOCKFULLSCREEN);
            LockWindowUpdate2(NULL, TRUE);
        } else {
            /*
             * GDI is not enabled. This means we were switching from a full
             * screen to another fullscreen or back to GDI. Or we could have
             * disabled gdi and sent a message to the new full screen which
             * never got completed.
             *
             * In any case this probably means the fullscreen guy is gone so
             * we will switch back to gdi.
             *
             * Delete any left over saved screen state stuff set the fullscreen
             * to nothing and then send a message that will cause us to switch
             * back to the gdi desktop.
             */
            TL tlpwndT;

            TRACE_SWITCH(("Switching: FullScreenCleanup: Gdi Disabled\n"));

            Unlock(&gspwndFullScreen);
            gbFullScreen = FULLSCREEN;

            ThreadLock(grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
            xxxSendNotifyMessage(grpdeskRitInput->pDeskInfo->spwnd, WM_FULLSCREEN,
                                 GDIFULLSCREEN,
                                 (LPARAM)HW(grpdeskRitInput->pDeskInfo->spwnd));
            ThreadUnlock(&tlpwndT);
        }

        ghSwitcher = NULL;
        gfRedoFullScreenSwitch = FALSE;
    }
}

/***************************************************************************\
* xxxMakeWindowForegroundWithState
*
* Syncs the screen graphics mode with the mode of the specified (foreground)
* window.
*
* We make sure only one thread is going through this code by checking
* ghSwitcher. If ghSwitcher is non-NULL someone is already in this code.
*
* 12-Dec-1991 mikeke   Created
\***************************************************************************/
BOOL xxxMakeWindowForegroundWithState(
    PWND pwnd,
    BYTE NewState)
{
    PWND pwndNewFG;
    TL tlpwndNewFG;

    TRACE_SWITCH(("Switching: xxxMakeWindowForegroundWithState: Enter\n"));
    TRACE_SWITCH(("\t \t pwnd     = %08lx\n", pwnd));
    TRACE_SWITCH(("\t \t NewState = %d\n", NewState));

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If we should switch to a specific window save that window.
     */
    if (pwnd != NULL) {
        if (NewState == GDIFULLSCREEN) {
            Lock(&gspwndShouldBeForeground, pwnd);
        }

        /*
         * Change to the new state.
         */

        SetFullScreen(pwnd, NewState);

        if (NewState == FULLSCREEN &&
            (gpqForeground == NULL || gpqForeground->spwndActive != pwnd)) {
            SetFullScreen(pwnd, FULLSCREENMIN);
        }
    }

    /*
     * Since we leave the critical section during the switch, some other
     * thread could come into this routine and request a switch. The global
     * will be reset, and we will use the loop to perform the next switch.
     */
    if (ghSwitcher != NULL) {
        gfRedoFullScreenSwitch = TRUE;
        TRACE_SWITCH(("Switching: xxxMakeWindowForegroundWithState was posted: Exit\n"));

        return TRUE;
    }

    UserAssert(!gfRedoFullScreenSwitch);
    ghSwitcher = PsGetCurrentThreadId();

    /*
     * We loop, switching full screens until all states have stabilized
     */

    while (TRUE) {
        /*
         * Figure out who should be foreground.
         */
        gfRedoFullScreenSwitch = FALSE;

        if (gspwndShouldBeForeground != NULL) {
            pwndNewFG = gspwndShouldBeForeground;
            Unlock(&gspwndShouldBeForeground);
        } else {
            if (gpqForeground != NULL && gpqForeground->spwndActive != NULL) {

                pwndNewFG = gpqForeground->spwndActive;

                if (GetFullScreen(pwndNewFG) == WINDOWED ||
                    GetFullScreen(pwndNewFG) == FULLSCREENMIN) {
                    pwndNewFG = PWNDDESKTOP(pwndNewFG);
                }
            } else {
                /*
                 * No active window, switch to current desktop.
                 */
                pwndNewFG = grpdeskRitInput->pDeskInfo->spwnd;
            }
        }

        /*
         * We don't need to switch if the right window is already foreground.
         */
        if (pwndNewFG == gspwndFullScreen) {
            break;
        }

        ThreadLock(pwndNewFG, &tlpwndNewFG);

        {
            BYTE bStateNew = GetFullScreen(pwndNewFG);
            TL tlpwndOldFG;
            PWND pwndOldFG = gspwndFullScreen;
            BYTE bStateOld = gbFullScreen;

            ThreadLock(pwndOldFG, &tlpwndOldFG);

            Lock(&gspwndFullScreen, pwndNewFG);
            gbFullScreen = bStateNew;

            UserAssert(!HMIsMarkDestroy(gspwndFullScreen));

            /*
             * If the old screen was GDIFULLSCREEN and we are switching to
             * GDIFULLSCREEN then just repaint.
             *
             * BUG 231647: For remote sessions it can happen that pwndOldFG is
             * NULL but the display is enabled therefore a call to
             * DrvEnableMDEV would confuse the Drv* code. The way this happens
             * is when gspwndFullScreen was the desktop window of a desktop
             * that got destroyed after we switched away from it.
             */
            if ((pwndOldFG != NULL || gbRemoteSession) &&
                bStateOld == GDIFULLSCREEN &&
                bStateNew == GDIFULLSCREEN) {

                xxxRedrawWindow(pwndNewFG,
                                NULL,
                                NULL,
                                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE |
                                    RDW_ERASENOW);

                ThreadUnlock(&tlpwndOldFG);
            } else {
                /*
                 * Tell old 'foreground' window it is losing control of the
                 * screen.
                 */
                if (pwndOldFG != NULL) {
                    switch (bStateOld) {
                    case FULLSCREEN:
                        if (GetFullScreen(pwndOldFG) == FULLSCREEN) {
                            SetFullScreen(pwndOldFG, FULLSCREENMIN);
                        }
                        xxxSendMessage(pwndOldFG, WM_FULLSCREEN, FALSE, 0);
                        xxxCapture(GETPTI(pwndOldFG), NULL, FULLSCREEN_CAPTURE);
                        SetVDMCursorBounds(NULL);
                        break;

                    case GDIFULLSCREEN:
                        /*
                         * Lock out other windows from drawing while we are
                         * fullscreen.
                         */
                        LockWindowUpdate2(pwndOldFG, TRUE);
                        SET_PUDF(PUDF_LOCKFULLSCREEN);

                        UserAssert(gfGdiEnabled == TRUE);

                        /*
                         * We are about to switch to FULLSCREEN mode.
                         *
                         * IsRemoteConnection() == TRUE indicates that we
                         * are on a remote session. Switching to FULLSCREEN
                         * mode is not supported on remote sessions.
                         *
                         * gfSwitchInProgress flag means that we are
                         * currently in process of disconnecting the
                         * session, so even if it is not remote right now it
                         * is about to go remote. In these cases we must not
                         * switch to FULLSCREEN mode.
                         */
                        if (IsRemoteConnection() || gfSwitchInProgress ||
                            !SafeDisableMDEV()) {

                            /*
                             * Restore the previous state before bailing.
                             */
                            CLEAR_PUDF(PUDF_LOCKFULLSCREEN);
                            LockWindowUpdate2(NULL, TRUE);

                            Lock(&gspwndFullScreen, pwndOldFG);
                            gbFullScreen = bStateOld;

                            ThreadUnlock(&tlpwndOldFG);
                            ThreadUnlock(&tlpwndNewFG);

                            ghSwitcher = NULL;

                            return FALSE;
                        }

                        gptCursorFullScreen = gpsi->ptCursor;
                        gfGdiEnabled = FALSE;
                        break;

                    default:
                        RIPMSG0(RIP_ERROR, "xxxMakeWindowForegroundWithState: bad screen state");
                        break;

                    }
                }

                ThreadUnlock(&tlpwndOldFG);

                switch (bStateNew) {
                case FULLSCREEN:
                    xxxCapture(GETPTI(pwndNewFG), pwndNewFG, FULLSCREEN_CAPTURE);
                    xxxSendMessage(pwndNewFG, WM_FULLSCREEN, TRUE, 0);
                    break;

                case GDIFULLSCREEN:
                    if (ISTS() && pwndOldFG != NULL) {
                        UserAssert(gfGdiEnabled == FALSE);
                    }
                    SafeEnableMDEV();

                    gfGdiEnabled = TRUE;

                    /*
                     * Return the cursor to it's old state. Reset the screen
                     * saver mouse position or it'll go away by accident.
                     */
                    gpqCursor = NULL;
                    gpcurPhysCurrent = NULL;
                    gpcurLogCurrent = NULL;
                    SetPointer(FALSE);
                    gptSSCursor = gptCursorFullScreen;

                    /*
                     * No need to DeferWinEventNotify() - we use only globals,
                     * then make an xxx call below.
                     */
                    zzzInternalSetCursorPos(gptCursorFullScreen.x,
                                            gptCursorFullScreen.y);

                    CLEAR_PUDF(PUDF_LOCKFULLSCREEN);
                    LockWindowUpdate2(NULL, TRUE);

                    xxxRedrawWindow(pwndNewFG,
                                    NULL,
                                    NULL,
                                    RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE |
                                        RDW_ERASENOW);
                    break;

                default:
                    RIPMSG0(RIP_ERROR, "xxxMakeWindowForegroundWithState: bad screen state");
                    break;
                }
            }
        }

        ThreadUnlock(&tlpwndNewFG);

        if (!gfRedoFullScreenSwitch) {
            break;
        }
    }

    TRACE_SWITCH(("Switching: xxxMakeWindowForegroundWithState: Exit\n"));

    ghSwitcher = NULL;
    return TRUE;
}

/***************************************************************************\
* MonitorFromHdev
\***************************************************************************/
PMONITOR MonitorFromHdev(
    HANDLE hdev)
{
    PMONITOR pMonitor;

    for (pMonitor = gpDispInfo->pMonitorFirst; pMonitor != NULL;
            pMonitor = pMonitor->pMonitorNext) {
        if (pMonitor->hDev == hdev) {
            return pMonitor;
        }
    }
    return NULL;
}

/***************************************************************************\
* HdevFromMonitor
\***************************************************************************/
ULONG HdevFromMonitor(
    PMONITOR pMonitor)
{
    PMDEV pmdev = gpDispInfo->pmdev;
    ULONG i;

    for (i = 0; i < pmdev->chdev; i++) {
        if (pmdev->Dev[i].hdev == pMonitor->hDev) {
            return i;
        }
    }

    return -1;
}

/***************************************************************************\
* CreateMonitor
\***************************************************************************/
PMONITOR CreateMonitor(
    VOID)
{
    PMONITOR pMonitor;

    pMonitor = (PMONITOR)HMAllocObject(NULL, NULL, TYPE_MONITOR, sizeof(MONITOR));

    if (pMonitor != NULL) {
        pMonitor->rcMonitor.left = 0;
        pMonitor->rcMonitor.top = 0;
        pMonitor->rcMonitor.right = 0;
        pMonitor->rcMonitor.bottom = 0;

        pMonitor->rcWork.left = 0;
        pMonitor->rcWork.top = 0;
        pMonitor->rcWork.right = 0;
        pMonitor->rcWork.bottom = 0;
    } else {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "CreateMonitor failed");
    }

    return pMonitor;
}

/***************************************************************************\
* CreateCachedMonitor
\***************************************************************************/
PMONITOR CreateCachedMonitor(
    VOID)
{
    if (gpMonitorCached == NULL) {
        gpMonitorCached = CreateMonitor();
    }

    return gpMonitorCached;
}

/***************************************************************************\
* SetMonitorData
\***************************************************************************/
PMONITOR SetMonitorData(
    PMONITOR pMonitor,
    ULONG iDev)
{
    PMDEV pmdev = gpDispInfo->pmdev;
    HDEV hdev = pmdev->Dev[iDev].hdev;
    BOOL fVisible = TRUE;
    BOOL fPrimary = FALSE;
    HDC hdcTmp;

    UserAssert(iDev < pmdev->chdev);

    if (hdcTmp = GreCreateDisplayDC(hdev, DCTYPE_DIRECT, FALSE)) {
        if (GreGetDeviceCaps(hdcTmp, CAPS1) & C1_MIRROR_DEVICE) {
            fVisible = FALSE;
        }
        GreDeleteDC(hdcTmp);
    }

    if (fVisible && (pmdev->Dev[iDev].rect.top == 0) &&
            (pmdev->Dev[iDev].rect.left == 0)) {
        fPrimary = TRUE;
    }

    if (pMonitor == NULL) {
        if (fPrimary) {
            UserAssert(gpMonitorCached != NULL);
            pMonitor = gpMonitorCached;
            gpMonitorCached = NULL;
        } else {
            pMonitor = CreateMonitor();
        }
    }

    if (pMonitor == NULL) {
        return NULL;
    }

    SET_OR_CLEAR_FLAG(pMonitor->dwMONFlags, MONF_VISIBLE, fVisible);

    /*
     * When the monitor rect is changing, size the work area so the same
     * amount as before is clipped off each edge.
     */
    if (!EqualRect(&pMonitor->rcMonitor, &pmdev->Dev[iDev].rect)) {
        pMonitor->rcWork.left = pmdev->Dev[iDev].rect.left -
                (pMonitor->rcMonitor.left - pMonitor->rcWork.left);
        pMonitor->rcWork.top = pmdev->Dev[iDev].rect.top -
                (pMonitor->rcMonitor.top - pMonitor->rcWork.top);
        pMonitor->rcWork.right = pmdev->Dev[iDev].rect.right -
                (pMonitor->rcMonitor.right - pMonitor->rcWork.right);
        pMonitor->rcWork.bottom = pmdev->Dev[iDev].rect.bottom -
                (pMonitor->rcMonitor.bottom - pMonitor->rcWork.bottom);
    }
    pMonitor->rcMonitor = pmdev->Dev[iDev].rect;
    pMonitor->hDev = hdev;

    /*
     * Make sure that the work area is inside the monitor's bounds.
     */
    if (pMonitor->rcWork.right < pMonitor->rcWork.left) {
        pMonitor->rcWork.right = pMonitor->rcWork.left;
    }

    if (pMonitor->rcWork.bottom < pMonitor->rcWork.top) {
        pMonitor->rcWork.bottom = pMonitor->rcWork.top;
    }

    if (!IntersectRect(&pMonitor->rcWork, &pMonitor->rcWork, &pMonitor->rcMonitor)) {
        pMonitor->rcWork = pMonitor->rcMonitor;
    }

    if (fPrimary) {
        gpDispInfo->pMonitorPrimary = pMonitor;
    }

    return pMonitor;
}

/***************************************************************************\
*
* Is this still TRUE ?
*
* When a window becomes FULLSCREEN, it is minimized and
* treated like any other minimized window.  Whenever the
* minimized window is restored, by double clicking, menu
* or keyboard, it remains minimized and the application
* is given control of the screen device.
*
* 12-Dec-1991 mikeke   Created
\***************************************************************************/

DWORD gdwMonitorBusy;

/***************************************************************************\
* xxxUpdateUserScreen
*
* Updates USER information associated with the screen
*
* History:
* 28-Sep-1996 adams     Created.
\***************************************************************************/
BOOL xxxUpdateUserScreen(
    BOOL fInitializeTime)
{
    PMDEV           pmdev = gpDispInfo->pmdev;
    ULONG           i;
    PMONITOR        pMonitor;
    TEXTMETRIC      tm;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    HRGN            hrgn;
    BOOL            fPaletteDisplay;
    RECT            rc;
    PMONITOR pMonitorNext = gpDispInfo->pMonitorFirst;
    PMONITOR *ppMonitorLast = &gpDispInfo->pMonitorFirst;


    TRACE_INIT(("xxxUpdateUserScreen\n"));

    UserAssert(gpDispInfo->hdcScreen);
    UserAssert(gpMonitorCached != NULL);

    CheckCritIn();
    if (!fInitializeTime) {
        /*
         * Wait until the unprotected code goes through the monitor reference.
         * We skip this if it's initializing the session to avoid leaving the
         * critical section.
         */
        while (InterlockedCompareExchange(&gdwMonitorBusy, TRUE, FALSE) != FALSE) {
            UserAssert(gdwMonitorBusy == TRUE);
            RIPMSGF0(RIP_VERBOSE, "Monitor is busy referenced by the mouse input.");
            LeaveCrit();
            UserSleep(1);
            EnterCrit();
        }
    }

    /*
     * Keep HMONITOR for the hdev that is the same. Delete the monitors that
     * weren't found in the new hdev list.
     */
    while (pMonitorNext != NULL) {
        pMonitor = pMonitorNext;
        pMonitorNext = pMonitor->pMonitorNext;

        if ((i = HdevFromMonitor(pMonitor)) == -1) {
            DestroyMonitor(pMonitor);
        } else {
            SetMonitorData(pMonitor, i);
            ppMonitorLast = &pMonitor->pMonitorNext;
        }
    }

    /*
     * Create monitors for the hdevs that aren't yet on the monitor list.
     */
    for (i = 0; i < pmdev->chdev; i++) {
        if ((pMonitor = MonitorFromHdev(pmdev->Dev[i].hdev)) == NULL) {
            /*
             * Try to create a new monitor.
             */
            pMonitor = SetMonitorData(NULL, i);

            if (pMonitor != NULL) {
                *ppMonitorLast = pMonitor;
                ppMonitorLast = &pMonitor->pMonitorNext;
            }
        }
    }

    UserAssert(gpDispInfo->pMonitorFirst != NULL);
    UserAssert(gpDispInfo->pMonitorPrimary != NULL);

    /*
     * For now, all monitors have the same display format.
     */
    SYSMET(SAMEDISPLAYFORMAT) = (pmdev->ulFlags & MDEV_MISMATCH_COLORDEPTH) ? FALSE : TRUE;
    fPaletteDisplay = GreGetDeviceCaps(gpDispInfo->hdcScreen, RASTERCAPS) & RC_PALETTE;
    gpDispInfo->fAnyPalette = !!fPaletteDisplay;

    /*
     * Determine the coordinates of the virtual desktop. Compute cMonitors as
     * the number of visible monitors.
     */
    SetRectEmpty(&rc);

    gpDispInfo->cMonitors = 0;
    for (pMonitor = gpDispInfo->pMonitorFirst; pMonitor; pMonitor = pMonitor->pMonitorNext) {
        /*
         * Only visible monitors contribute to the desktop area.
         */
        if (pMonitor->dwMONFlags & MONF_VISIBLE) {
            rc.left = min(rc.left, pMonitor->rcMonitor.left);
            rc.top = min(rc.top, pMonitor->rcMonitor.top);
            rc.right = max(rc.right, pMonitor->rcMonitor.right);
            rc.bottom = max(rc.bottom, pMonitor->rcMonitor.bottom);

            gpDispInfo->cMonitors++;
        }

        if (SYSMET(SAMEDISPLAYFORMAT)) {
            SET_OR_CLEAR_FLAG(pMonitor->dwMONFlags, MONF_PALETTEDISPLAY, fPaletteDisplay);
        } else {
            if (GreIsPaletteDisplay(pMonitor->hDev)) {
                pMonitor->dwMONFlags |= MONF_PALETTEDISPLAY;
                gpDispInfo->fAnyPalette = TRUE;
            }
        }

#ifdef SUBPIXEL_MOUSE
        /*
         * The new mouse's acceleration curves depend on the screen resolution,
         * so we rebuild the curves here.
         */
        BuildMouseAccelerationCurve(pMonitor);
#endif // SUBPIXEL_MOUSE
    }
    UserAssert(gpDispInfo->pMonitorPrimary != NULL);
    gpDispInfo->rcScreen = rc;

    if (!fInitializeTime) {
        /*
         * Release the monitor busy lock, so that the
         * mouse cursor update can resume.
         */
        UserAssert(gdwMonitorBusy == TRUE);
        InterlockedExchange(&gdwMonitorBusy, FALSE);
    }

    /*
     * Notify the TS service if one coordinate of the virtual screen changed
     * and we're doing console shadow.
     */
    if (gfRemotingConsole &&
        gpConsoleShadowDisplayChangeEvent &&
        !((SYSMET(XVIRTUALSCREEN) == gpDispInfo->rcScreen.left) &&
          (SYSMET(YVIRTUALSCREEN) == gpDispInfo->rcScreen.top) &&
          (SYSMET(CXVIRTUALSCREEN) == gpDispInfo->rcScreen.right - gpDispInfo->rcScreen.left) &&
          (SYSMET(CYVIRTUALSCREEN) == gpDispInfo->rcScreen.bottom - gpDispInfo->rcScreen.top))) {

        KeSetEvent(gpConsoleShadowDisplayChangeEvent, EVENT_INCREMENT, FALSE);
    }


    /*
     * Update system metrics
     */
    SYSMET(CXSCREEN)        = gpDispInfo->pMonitorPrimary->rcMonitor.right;
    SYSMET(CYSCREEN)        = gpDispInfo->pMonitorPrimary->rcMonitor.bottom;
    SYSMET(XVIRTUALSCREEN)  = gpDispInfo->rcScreen.left;
    SYSMET(YVIRTUALSCREEN)  = gpDispInfo->rcScreen.top;
    SYSMET(CXVIRTUALSCREEN) = gpDispInfo->rcScreen.right - gpDispInfo->rcScreen.left;
    SYSMET(CYVIRTUALSCREEN) = gpDispInfo->rcScreen.bottom - gpDispInfo->rcScreen.top;
    SYSMET(CXMAXTRACK)      = SYSMET(CXVIRTUALSCREEN) + (2 * (SYSMET(CXSIZEFRAME) + SYSMET(CXEDGE)));
    SYSMET(CYMAXTRACK)      = SYSMET(CYVIRTUALSCREEN) + (2 * (SYSMET(CYSIZEFRAME) + SYSMET(CYEDGE)));
    SYSMET(CMONITORS)       = gpDispInfo->cMonitors;

    /*
     * Bug 281219: Flush out the mouse move points if a mode change occured.
     */
    RtlZeroMemory(gaptMouse, MAX_MOUSEPOINTS * sizeof(MOUSEMOVEPOINT));

    SetDesktopMetrics();

    gpDispInfo->dmLogPixels = (WORD)GreGetDeviceCaps(gpDispInfo->hdcScreen, LOGPIXELSY);

    UserAssert(gpDispInfo->dmLogPixels != 0);

    /*
     * Get per-monitor or sum of monitor information, including:
     *     The desktop region.
     *     The region of each monitor.
     *     Min bit counts - Not for NT SP2.
     *     Same color format - Not for NT SP2.
     */

    SetOrCreateRectRgnIndirectPublic(&gpDispInfo->hrgnScreen, PZERO(RECT));

    if (gpDispInfo->hrgnScreen) {
        int iRgn = RGN_ERROR;

        for (pMonitor = gpDispInfo->pMonitorFirst;
             pMonitor;
             pMonitor = pMonitor->pMonitorNext) {
            /*
             * We want to set up hrgnMonitor for all monitors, visible or
             * not.
             */
            if (SetOrCreateRectRgnIndirectPublic(&pMonitor->hrgnMonitor,
                                                 &pMonitor->rcMonitor)) {
                /*
                 * But we want only visible monitors to contribute to
                 * hrgnScreen.
                 */
                if (pMonitor->dwMONFlags & MONF_VISIBLE) {
                    iRgn = UnionRgn(gpDispInfo->hrgnScreen,
                                    gpDispInfo->hrgnScreen,
                                    pMonitor->hrgnMonitor);
                }

            }
        }

        gpDispInfo->fDesktopIsRect = (iRgn == SIMPLEREGION);
    }


    /*
     * Reset the window region of desktop windows.
     */
    hrgn = (gpDispInfo->fDesktopIsRect) ? NULL : gpDispInfo->hrgnScreen;
    for (pwinsta = grpWinStaList; pwinsta; pwinsta = pwinsta->rpwinstaNext) {
        for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
            if (pdesk->pDispInfo == gpDispInfo) {
                pdesk->pDeskInfo->spwnd->hrgnClip = hrgn;
            }
        }
    }

    /*
     * Updated information stored in gpsi.
     */
    gpsi->Planes        = (BYTE)GreGetDeviceCaps(gpDispInfo->hdcScreen, PLANES);
    gpsi->BitsPixel     = (BYTE)GreGetDeviceCaps(gpDispInfo->hdcScreen, BITSPIXEL);
    gpsi->BitCount      = gpsi->Planes * gpsi->BitsPixel;
    gpDispInfo->BitCountMax = gpsi->BitCount;
    SET_OR_CLEAR_PUSIF(PUSIF_PALETTEDISPLAY, fPaletteDisplay);
    gpsi->dmLogPixels   = gpDispInfo->dmLogPixels;
    gpsi->rcScreen      = gpDispInfo->rcScreen;
    gpsi->cxSysFontChar = GetCharDimensions(HDCBITS(), &tm, &gpsi->cySysFontChar);
    gpsi->tmSysFont     = tm;

    EnforceColorDependentSettings();

    VerifyVisibleMonitorCount();

    return TRUE;
}


/**************************************************************************\
* InitUserScreen
*
* Initializes user variables at startup.
*
* The caller of this function needs to handle failures. If this is called as
* part of the interactive console and it fails, USER will currently bugcheck.
* If this is called as part of RemoteConnect() for Terminal Server, the
* resources will be cleaned up in CleanupGDI() as part of normal thread
* cleanup.
*
* 12-Jan-1994 andreva       Created
* 23-Jan-1995 ChrisWil      ChangeDisplaySettings work.
\**************************************************************************/
BOOL InitUserScreen(
    VOID)
{
    int i;
    TL tlName;
    PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
    BOOL fSuccess = TRUE;

    TRACE_INIT(("UserInit: Initialize Screen\n"));

    /*
     * Create screen and memory dcs.
     */
    gpDispInfo->hdcScreen = GreCreateDisplayDC(gpDispInfo->hDev, DCTYPE_DIRECT, FALSE);

    if (gpDispInfo->hdcScreen == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create gpDispInfo->hdcScreen");
        fSuccess = FALSE;
        goto Exit;
    }

    GreSelectFont(gpDispInfo->hdcScreen, GreGetStockObject(SYSTEM_FONT));
    GreSetDCOwner(gpDispInfo->hdcScreen, OBJECT_OWNER_PUBLIC);

    HDCBITS() = GreCreateCompatibleDC(gpDispInfo->hdcScreen);

    if (HDCBITS() == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create HDCBITS()");
        fSuccess = FALSE;
        goto Exit;
    }

    GreSelectFont(HDCBITS(), GreGetStockObject(SYSTEM_FONT));
    GreSetDCOwner(HDCBITS(), OBJECT_OWNER_PUBLIC);

    ghdcMem = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
    fSuccess &= !!ghdcMem;

    ghdcMem2 = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
    fSuccess &= !!ghdcMem2;

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "Fail to create ghdcMem or ghdcMem2");
        goto Exit;
    }

    GreSetDCOwner(ghdcMem, OBJECT_OWNER_PUBLIC);
    GreSetDCOwner(ghdcMem2, OBJECT_OWNER_PUBLIC);

    if (CreateCachedMonitor() == NULL) {
        fSuccess = FALSE;
        goto Exit;
    }

    /*
     * N.b. although it's xxx, this function does not
     * leave the critical section if fInitializeTime is TRUE.
     */
    BEGINATOMICCHECK();
    if (!xxxUpdateUserScreen(TRUE)) {
        RIPMSG0(RIP_WARNING, "xxxUpdateUserScreen failed");
        fSuccess = FALSE;
        goto Exit;
    }
    ENDATOMICCHECK();

    /*
     * Do some initialization so we create the system colors.
     */

    /*
     * Set the window sizing border width to something reasonable.
     */
    gpsi->gclBorder = 1;

    /*
     * Init InternalInvalidate globals
     */
    ghrgnInv0 = CreateEmptyRgnPublic();    // For InternalInvalidate()
    fSuccess &= !!ghrgnInv0;

    ghrgnInv1 = CreateEmptyRgnPublic();    // For InternalInvalidate()
    fSuccess &= !!ghrgnInv1;

    ghrgnInv2 = CreateEmptyRgnPublic();    // For InternalInvalidate()
    fSuccess &= !!ghrgnInv2;

    /*
     * Initialize SPB globals
     */
    ghrgnSPB1 = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSPB1;

    ghrgnSPB2 = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSPB2;

    ghrgnSCR  = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSCR;

    /*
     * Initialize ScrollWindow/ScrollDC globals
     */
    ghrgnSW        = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSW;

    ghrgnScrl1     = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrl1;

    ghrgnScrl2     = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrl2;

    ghrgnScrlVis   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlVis;

    ghrgnScrlSrc   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlSrc;

    ghrgnScrlDst   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlDst;

    ghrgnScrlValid = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlValid;

    /*
     * Initialize SetWindowPos()
     */
    ghrgnInvalidSum = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnInvalidSum;

    ghrgnVisNew     = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnVisNew;

    ghrgnSWP1       = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSWP1;

    ghrgnValid      = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnValid;

    ghrgnValidSum   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnValidSum;

    ghrgnInvalid    = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnInvalid;

    /*
     * Initialize DC cache
     */
    ghrgnGDC = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnGDC;

    for (i = 0; i < DCE_SIZE_CACHEINIT; i++) {
        fSuccess &= !!CreateCacheDC(NULL, DCX_INVALID | DCX_CACHE, NULL);
    }

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "CreateCacheDC failed");
        goto Exit;
    }

    /*
     * Let engine know that the display must be secure.
     */

    GreMarkDCUnreadable(gpDispInfo->hdcScreen);

    /*
     * LATER mikeke - if ghfontsys is changed anywhere but here
     * we need to fix SetNCFont()
     */
    ghFontSys = (HFONT)GreGetStockObject(SYSTEM_FONT);

#if DBG
    SYSMET(DEBUG) = TRUE;
#else
    SYSMET(DEBUG) = FALSE;
#endif

    SYSMET(CLEANBOOT) = **((PULONG *)&InitSafeBootMode);

    SYSMET(SLOWMACHINE) = 0;

    /*
     * Initialize system colors from registry.
     */
    xxxODI_ColorInit(pProfileUserName);

    /*
     * Paint the screen background.
     */
    FillRect(gpDispInfo->hdcScreen, &gpDispInfo->rcScreen, SYSHBR(DESKTOP));

    UserAssert(fSuccess);

Exit:
    FreeProfileUserName(pProfileUserName, &tlName);

    return fSuccess;
}


/***************************************************************************\
* xxxResetSharedDesktops
*
* Resets the attributes for other desktops which share the DISPINFO that
* was just changed.  We need to resize all visrgns of the other desktops
* so that clipping is allright.
*
* NOTE:  For now, we have to change all the desktop even though we keep
* track of the devmode on a per desktop basis, because we can switch
* back to a desktop that has a different resolution and paint it before
* we can change the resolution again.
*
* There is also an issue with CDS_FULLSCREEN where we currently lose track
* of whether or not the desktop settings need to be reset or not. [andreva]
*
* 19-Feb-1996 ChrisWil Created.
\***************************************************************************/
VOID ResetSharedDesktops(
    PDISPLAYINFO pDIChanged,
    PDESKTOP     pdeskChanged)
{
    PWINDOWSTATION pwinsta = _GetProcessWindowStation(NULL);
    PDESKTOP       pdesk;
    HRGN           hrgn;
    POINT          pt;
    PRECT          prc;
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If this is CSRSS doing the dynamic resolution change then use
     * WinSta0 since the process windowstation is NULL for CSRSS.
     */


    if ((IsRemoteConnection()) && pwinsta == NULL && PsGetCurrentProcess() == gpepCSRSS) {
        pwinsta = grpWinStaList;
    }

    if (pwinsta == NULL) {
        if (PtiCurrent()->TIF_flags & (TIF_CSRSSTHREAD|TIF_SYSTEMTHREAD)) {
            pwinsta =  grpdeskRitInput->rpwinstaParent;
        } else {
            TRACE_SWITCH(("ResetSharedDesktops - NULL window station !\n"));
            return;
        }
    }

    for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
        /*
         * Make sure this is a shared DISPINFO.
         */
        if (pdesk->pDispInfo == pDIChanged) {
#if 0
            /*
             * This is the preferable method to set the desktop-window.
             * However, this causes synchronization problems where we
             * leave the critical-section allowing other apps to call
             * ChangeDisplaySettings() and thus mucking up the works.
             *
             * By calculating the vis-rgn ourselves, we can assure that
             * the clipping is current for the desktop even when we leave
             * the section.
             */
            {
                TL tlpwnd;

                ThreadLockAlways(pdesk->pDeskInfo->spwnd, &tlpwnd);
                xxxSetWindowPos(pdesk->pDeskInfo->spwnd,
                                PWND_TOP,
                                pDIChanged->rcScreen.left,
                                pDIChanged->rcScreen.top,
                                pDIChanged->rcScreen.right - pDIChanged->rcScreen.left,
                                pDIChanged->rcScreen.bottom - pDIChanged->rcScreen.top,
                                SWP_NOZORDER | SWP_NOACTIVATE);
                ThreadUnlock(&tlpwnd);
            }
#else
            CopyRect(&pdesk->pDeskInfo->spwnd->rcWindow, &pDIChanged->rcScreen);
            CopyRect(&pdesk->pDeskInfo->spwnd->rcClient, &pDIChanged->rcScreen);
#endif
        }
    }

    /*
     * Recalc the desktop visrgn.
     */
    hrgn = CreateEmptyRgn();
    CalcVisRgn(&hrgn,
               pdeskChanged->pDeskInfo->spwnd,
               pdeskChanged->pDeskInfo->spwnd,
               DCX_WINDOW);

    GreSelectVisRgn(pDIChanged->hdcScreen, hrgn, SVR_DELETEOLD);

    /*
     * Invalidate all DCE's visrgns.
     */
    zzzInvalidateDCCache(pdeskChanged->pDeskInfo->spwnd, 0);

    /*
     * Position mouse so that it is within the new visrgn, once we
     * recalc it.
     */
    if (grpdeskRitInput->pDispInfo == pDIChanged) {
        prc = &pDIChanged->pMonitorPrimary->rcMonitor;
        pt.x = (prc->right - prc->left) / 2;
        pt.y = (prc->bottom - prc->top) / 2;

        /*
         * Remember new mouse pos. Makes sure we don't wake the screensaver.
         */
        gptSSCursor = pt;
        zzzInternalSetCursorPos(pt.x, pt.y);
    }
}

/***************************************************************************\
* DestroyMonitorDCs
*
* 03/03/1998      vadimg      created
\***************************************************************************/
VOID DestroyMonitorDCs(
    VOID)
{
    PDCE pdce;
    PDCE *ppdce;

    /*
     * Scan the DC cache to find any monitor DC's that need to be destroyed.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL;) {
        pdce = *ppdce;

        if (pdce->pMonitor != NULL) {
            DestroyCacheDC(ppdce, pdce->hdc);
        }

        /*
         * Step to the next DC. If the DC was deleted, there is no need to
         * calculate address of the next entry.
         */
        if (pdce == *ppdce) {
            ppdce = &pdce->pdceNext;
        }
    }
}

/***************************************************************************\
* ResetSystemColors
*
* Reset all system colors to make sure magic colors are reset and
* solid system colors are indeed solid after a mode change.
\***************************************************************************/
VOID ResetSystemColors(
    VOID)
{
    INT i, colorIndex[COLOR_MAX];
    COLORREF colorValue[COLOR_MAX];

    for (i = 0; i < COLOR_MAX; i++) {
        colorIndex[i] = i;
        colorValue[i] = gpsi->argbSystemUnmatched[i];
    }

    BEGINATOMICCHECK();
    xxxSetSysColors(NULL,
                    i,
                    colorIndex,
                    colorValue,
                    SSCF_FORCESOLIDCOLOR | SSCF_SETMAGICCOLORS);
    ENDATOMICCHECK();
}

/***************************************************************************\
* xxxResetDisplayDevice
*
* Resets the user-globals with the new hdev settings.
*
* 19-Feb-1996 ChrisWil Created.
\***************************************************************************/
VOID xxxResetDisplayDevice(
    PDESKTOP     pdesk,
    PDISPLAYINFO pDI,
    DWORD        CDS_Flags)
{
    WORD            wOldBpp;
    PMONITORRECTS   pmr = NULL;
    TL              tlPool;
    PTHREADINFO     ptiCurrent = PtiCurrent();

    wOldBpp = gpsi->BitCount;

    if (!(CDS_Flags & CDS_FULLSCREEN)) {
        pmr = SnapshotMonitorRects();
        if (pmr) {
            ThreadLockPool(ptiCurrent, pmr, &tlPool);
        }
    }

    /*
     * Cleanup any monitor specific DCs we gave out.
     */
    DestroyMonitorDCs();

    xxxUpdateUserScreen(FALSE);
    ResetSharedDesktops(pDI, pdesk);

    ResetSystemColors();

    if (ghbmCaption) {
        GreDeleteObject(ghbmCaption);
        ghbmCaption = CreateCaptionStrip();
    }

    zzzClipCursor(&pDI->rcScreen);

    /*
     * Adjust window positions to fit new resolutions and positions of
     * monitors.
     *
     * Don't adjust the windows if we are in a temporary mode change.
     */
    if (pmr) {
        xxxDesktopRecalc(pmr);
        ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
    }

    /*
     * Relead the desktop wallpaper on a video mode change.
     */
    if (ghbmWallpaper) {
        UserAssert(gpszWall);

        if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
            /*
             * The thread is being terminated. We cannot transition back to
             * the client side. So we ask the desktop to do it for us.
             */
            _PostThreadMessage(gTermIO.ptiDesktop,
                               WM_DESKTOPNOTIFY,
                               DESKTOP_RELOADWALLPAPER,
                               0);
        } else {
            TL tlName;
            PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
            xxxSetDeskWallpaper(pProfileUserName, SETWALLPAPER_METRICS);
            FreeProfileUserName(pProfileUserName, &tlName);
        }
    }

    /*
     * Recreate cached bitmaps.
     */
    CreateBitmapStrip();

    /*
     * Broadcast that the display has changed resolution. Also broadcast a
     * color-change if we were not in fullscreen, and a color-change took
     * effect.
     */
    if (!(CDS_Flags & CDS_FULLSCREEN) && gpsi->BitCount != wOldBpp) {
        xxxBroadcastDisplaySettingsChange(pdesk, TRUE);
    } else {
        xxxBroadcastDisplaySettingsChange(pdesk, FALSE);
    }

    /*
     * If the user performed a CTL-ESC, it is possible that the tray-window
     * is then in the menu-loop. We want to clear this out so that we don't
     * leave improper menu positioning.
     */
    if (gpqForeground && gpqForeground->spwndCapture) {
        QueueNotifyMessage(gpqForeground->spwndCapture, WM_CANCELMODE, 0, 0);
    }
}

/***************************************************************************\
* TrackFullscreenMode
*
* Remember the process going into the fullscreen mode, so that the mode can
* be restored if the process doesn't clean up upon exit. If some other mode
* change, clear the global since that means we're definitely out of the
* fullscreen mode.
*
* 1/12/1999        vadimg      created
\***************************************************************************/
VOID TrackFullscreenMode(
    DWORD dwFlags)
{
    if (dwFlags & CDS_FULLSCREEN) {
        gppiFullscreen = PtiCurrent()->ppi;
    } else {
        gppiFullscreen = NULL;
    }
}

/***************************************************************************\
* NtUserChangeDisplaySettings
*
* ChangeDisplaySettings API
*
* 01-Sep-1995 andreva  Created
* 19-Feb-1996 ChrisWil Implemented Dynamic-Resolution changes.
\***************************************************************************/
LONG xxxUserChangeDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN LPDEVMODEW pDevMode,
    IN PDESKTOP pdesk,
    IN DWORD dwFlags,
    IN PVOID lParam,
    IN MODE PreviousMode)
{
    BOOL     bSwitchMode;
    PDESKTOP pdesktop;
    LONG     status;
    PMDEV    pmdev;

    /*
     * NOTE: The lParam has NOT been properly captured. It is not used in
     * this function, but is passed onto other called functions. Once the
     * correct type is determined and it is to be used, it must be properly
     * captured.
     */

    TRACE_INIT(("ChangeDisplaySettings - Entering\n"));
    TRACE_SWITCH(("ChangeDisplaySettings - Entering\n"));

    TRACE_INIT(("    Flags -"));

    if (dwFlags & CDS_UPDATEREGISTRY) TRACE_INIT((" CDS_UPDATEREGISTRY - "));
    if (dwFlags & CDS_TEST) TRACE_INIT((" CDS_TEST - "));
    if (dwFlags & CDS_FULLSCREEN) TRACE_INIT((" CDS_FULLSCREEN - "));
    if (dwFlags & CDS_GLOBAL) TRACE_INIT((" CDS_GLOBAL - "));
    if (dwFlags & CDS_SET_PRIMARY) TRACE_INIT((" CDS_SET_PRIMARY - "));
    if (dwFlags & CDS_RESET) TRACE_INIT((" CDS_RESET - "));
    if (dwFlags & CDS_NORESET) TRACE_INIT((" CDS_NORESET - "));
    if (dwFlags & CDS_VIDEOPARAMETERS) TRACE_INIT((" CDS_VIDEOPARAMETERS - "));
    TRACE_INIT(("\n"));

    /*
     * Perform Error Checking to verify flag combinations are valid.
     */
    if (dwFlags & ~CDS_VALID) {
        return GRE_DISP_CHANGE_BADFLAGS;
    }

    if (DrvQueryMDEVPowerState(gpDispInfo->pmdev) == FALSE) {
        RIPMSG0(RIP_WARNING, "ChangeDisplaySettings failed because the device is powered off");
        return GRE_DISP_CHANGE_BADPARAM;
    }

    if (gbMDEVDisabled) {
        RIPMSG0(RIP_WARNING, "ChangeDisplaySettings failed because the MDEV is already disabled");
        return GRE_DISP_CHANGE_FAILED;
    }

    /*
     * CDS_GLOBAL and CDS_NORESET can only be specified if UPDATEREGISTRY
     * is specified.
     */
    if ((dwFlags & (CDS_GLOBAL | CDS_NORESET)) && (!(dwFlags & CDS_UPDATEREGISTRY))) {
        return GRE_DISP_CHANGE_BADFLAGS;
    }

    if ((dwFlags & CDS_NORESET) && (dwFlags & CDS_RESET)) {
        return GRE_DISP_CHANGE_BADFLAGS;
    }

    if ((dwFlags & CDS_EXCLUSIVE) && (dwFlags & CDS_FULLSCREEN) && (dwFlags & CDS_RESET)) {
        return GRE_DISP_CHANGE_BADFLAGS;
    }

    /*
     * Allow mode change if this is a CSRSS of a remote session. This means we
     * are changing display settings when reconnecting a session with a
     * diferent resolution.
     */
    if (TEST_PUDF(PUDF_LOCKFULLSCREEN)) {
        if (!(ISCSRSS() && (IsRemoteConnection())))  {
            return GRE_DISP_CHANGE_FAILED;
        }
    }


    /*
     * If the modeset is being done on a non-active desktop, we don't want
     * it to happen.
     *
     * PtiCurrent()->rpdesk can be NULL in the case of thread shutdown.
     */
    if (pdesk) {
        pdesktop = pdesk;
    } else {
        pdesktop = PtiCurrent()->rpdesk;
    }

    if (pdesktop != grpdeskRitInput) {
        RIPMSG0(RIP_WARNING, "ChangeDisplaySettings on wrong desktop pdesk\n");
        return GRE_DISP_CHANGE_FAILED;
    }

    bSwitchMode = !(dwFlags & (CDS_NORESET | CDS_TEST));

    /*
     * Turn off cursor and free the spb's prior to calling the mode-change.
     * This will make sure off-screen memory is cleaned up for gdi while
     * mucking with the resolution changes.
     */
    if (bSwitchMode) {
        if (CreateCachedMonitor() == NULL) {
            return GRE_DISP_CHANGE_FAILED;
        }

        SetPointer(FALSE);
        FreeAllSpbs();
    }

    /*
     * Before calling gdi to change the mode, we should kill the fade sprite.
     * This is so that we won't keep pointers to gdi sprites during the mode
     * change because the sprites could be reallocated.
     */
    if (gfade.hbm != NULL) {
        StopFade();
    }

    /*
     * Similarly, we should kill the sprites associated with the drag rect
     * (if any exist) before the mode change.
     */
    bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);

    /*
     * Let's capture our parameters. They are both required.
     *
     * If the input string is not NULL, then we are trying to affect another
     * device. The device name is the same as for EnumDisplaySettings.
     */
    status = DrvChangeDisplaySettings(pstrDeviceName,
                                      gpDispInfo->pMonitorPrimary->hDev,
                                      pDevMode,
                                      LongToPtr(pdesktop->dwDesktopId),
                                      PreviousMode,
                                      (dwFlags & CDS_UPDATEREGISTRY),
                                      bSwitchMode,
                                      gpDispInfo->pmdev,
                                      &pmdev,
                                      (dwFlags & CDS_RAWMODE) ? GRE_RAWMODE : GRE_DEFAULT,
                                      (dwFlags & CDS_TRYCLOSEST));


    if (bSwitchMode) {
        /*
         * If the caller wanted a reset, but the mode is identical, just reset
         * the current mode.
         */
        if (status == GRE_DISP_CHANGE_NO_CHANGE) {
            TrackFullscreenMode(dwFlags);

            if (pmdev != NULL) {
                GreFreePool(pmdev);
            }

            if (dwFlags & CDS_RESET) {
                if (SafeDisableMDEV()) {
                    SafeEnableMDEV();
                }

                xxxUserResetDisplayDevice();
            }

            status = GRE_DISP_CHANGE_SUCCESSFUL;
        } else if (status == GRE_DISP_CHANGE_SUCCESSFUL) {
            ResetRedirectedWindows();
            TrackFullscreenMode(dwFlags);

            /*
             * ChangeDisplaySettings automatically destroys the old MDEV, we
             * only have to delete it here.
             */
            GreFreePool(gpDispInfo->pmdev);
            gpDispInfo->pmdev = pmdev;
            xxxResetDisplayDevice(pdesktop, gpDispInfo, dwFlags);

            /*
             * Set delayed change indicator for currently background desktops.
             */
            UserSetDelayedChangeBroadcastForAllDesktops(pdesktop);
        } else if (status < GRE_DISP_CHANGE_SUCCESSFUL) {
            UserAssert(pmdev == NULL);
            xxxUserResetDisplayDevice();
        }

        xxxInternalInvalidate(pdesktop->pDeskInfo->spwnd,
                              HRGN_FULL,
                              RDW_INVALIDATE | RDW_ERASE | RDW_FRAME |
                                  RDW_ALLCHILDREN);

        /*
         * Bring back the cursor-shape.
         */
        SetPointer(TRUE);
        zzzUpdateCursorImage();
    }

    /*
     * TV-Out Support.
     */
    if (NT_SUCCESS(status) && (dwFlags & CDS_VIDEOPARAMETERS)) {
        if (lParam == NULL) {
            status = GRE_DISP_CHANGE_BADPARAM;
        } else {
            status = DrvSetVideoParameters(pstrDeviceName,
                                           gpDispInfo->pMonitorPrimary->hDev,
                                           PreviousMode,
                                           lParam);
        }
    }

    TRACE_INIT(("ChangeDisplaySettings - Leaving, Status = %d\n", status));

    return status;
}


/***************************************************************************\
* xxxbFullscreenSwitch
*
* Switch in and out of fullscreen console mode
*
* 15-Apr-1997 andreva  Created
\***************************************************************************/
BOOL xxxbFullscreenSwitch(
    BOOL bFullscreenSwitch,
    HWND hwnd)
{
    PWND pwnd;
    TL   tlpwnd;
    BOOL bStat = TRUE;

    pwnd = ValidateHwnd(hwnd);
    if (!pwnd) {
        return GRE_DISP_CHANGE_BADPARAM;
    }

    /*
     * We don't want our mode switch to be posted on the looping thread.
     * So let's loop until the system has settled down and no mode switch
     * is currently occuring.
     */
    ThreadLock(pwnd, &tlpwnd);
    UserAssert(ghSwitcher != PsGetCurrentThreadId());
    while (ghSwitcher != NULL) {
        /*
         * Make sure we aren't blocking anyone who's sending us a message.
         * They can have ghSwitcher and never release it because they are
         * waiting on us to process the sent message. And we're waiting on
         * ghSwitcher, hence a deadlock.
         */
        xxxSleepThread(0, 1, FALSE);
    }

    /*
     * Syncronize with session switching.
     */
    if (gfSwitchInProgress || IsRemoteConnection() || gfSessionSwitchBlock) {
        ThreadUnlock(&tlpwnd);
        return FALSE;
    } else {
        gfSessionSwitchBlock = TRUE;
    }

    /*
     * If there is a window, we want to check the state of the window. For
     * most calls, we want to ensure we are in windowed mode. However, for
     * Console, we want to make sure we are in fullscreen mode. So
     * differentiate between the two. We will check if the TEXTMODE flag
     * is passed in the DEVMODE.
     */
    if (bFullscreenSwitch) {
        if (GetFullScreen(pwnd) != FULLSCREEN) {
            xxxShowWindow(pwnd, SW_SHOWMINIMIZED | TEST_PUDF(PUDF_ANIMATE));
            xxxUpdateWindow(pwnd);
        }

        if (!xxxMakeWindowForegroundWithState(pwnd, FULLSCREEN)) {
            goto FullscreenSwitchFailed;
        }

        if (ghSwitcher != NULL || gbFullScreen != FULLSCREEN) {
            goto FullscreenSwitchFailed;
        }
    } else {
        /*
         * For the console windows, we want to call with WINDOWED.
         */
        if (!xxxMakeWindowForegroundWithState(pwnd, WINDOWED)) {
            goto FullscreenSwitchFailed;
        }

        if (ghSwitcher != NULL || gbFullScreen != GDIFULLSCREEN) {
FullscreenSwitchFailed:
            TRACE_INIT(("ChangeDisplaySettings: Can not switch out of fullscreen\n"));
            bStat = FALSE;
        }
    }

    ThreadUnlock(&tlpwnd);
    gfSessionSwitchBlock = FALSE;

    return bStat;
}


NTSTATUS RemoteRedrawRectangle(
    WORD Left,
    WORD Top,
    WORD Right,
    WORD Bottom)
{
    CheckCritIn();

    TRACE_HYDAPI(("RemoteRedrawRectangle\n"));

    UserAssert(ISCSRSS());

    /*
     * If xxxRemoteStopScreenUpdates has not been called, then just repaint
     * the current foreground window.
     */
    if (gspdeskShouldBeForeground == NULL) {
        if (gspwndFullScreen) {
            TL   tlpwnd;
            RECT rcl;

            ThreadLock(gspwndFullScreen, &tlpwnd);

            rcl.left   = Left;
            rcl.top    = Top;
            rcl.right  = Right;
            rcl.bottom = Bottom;

            vDrvInvalidateRect(gpDispInfo->hDev, &rcl);

            xxxRedrawWindow(gspwndFullScreen, &rcl, NULL,
                            RDW_INVALIDATE | RDW_ALLCHILDREN |
                            RDW_ERASE | RDW_ERASENOW);
            ThreadUnlock(&tlpwnd);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS RemoteRedrawScreen(
    VOID)
{
    TL             tlpdesk;
    PWINDOWSTATION pwinsta;
    PTHREADINFO    ptiCurrent;

    TRACE_HYDAPI(("RemoteRedrawScreen\n"));

    CheckCritIn();

    if (!gbFreezeScreenUpdates) {
        return STATUS_SUCCESS;
    }

    ptiCurrent = PtiCurrentShared();

    gbFreezeScreenUpdates = FALSE;

    /*
     * Switch back to the previous desktop
     */
    if (gspdeskShouldBeForeground == NULL) {
        RIPMSG0(RIP_WARNING,
                "RemoteRedrawScreen called with no gspdeskShouldBeForeground");
        return STATUS_SUCCESS;
    }

    gbDesktopLocked = FALSE;
    pwinsta = gspdeskShouldBeForeground->rpwinstaParent;

    /*
     * Switch back to the previous desktop.
     */
    if (!(gspdeskShouldBeForeground->dwDTFlags & DF_DESTROYED)) {
        ThreadLockDesktop(ptiCurrent, gspdeskShouldBeForeground, &tlpdesk, LDLT_FN_CTXREDRAWSCREEN);
        xxxSwitchDesktop(pwinsta, gspdeskShouldBeForeground, SDF_SLOVERRIDE);
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CTXREDRAWSCREEN);

    }
    LockDesktop(&gspdeskShouldBeForeground, NULL, LDL_DESKSHOULDBEFOREGROUND2, 0);

    return STATUS_SUCCESS;
}

NTSTATUS RemoteDisableScreen(
    VOID)
{
    TL             tlpdesk;
    PTHREADINFO    ptiCurrent;
    PWINDOWSTATION pwinsta;
    NTSTATUS       Status = STATUS_SUCCESS;

    CheckCritIn();

    TRACE_HYDAPI(("RemoteDisableScreen\n"));

    ptiCurrent = PtiCurrentShared();

    if (grpdeskRitInput != gspdeskDisconnect &&
        gspdeskDisconnect != NULL) {

        pwinsta = gspdeskDisconnect->rpwinstaParent;

        /*
         * Save current desktop
         */
        UserAssert(grpdeskRitInput == pwinsta->pdeskCurrent);

        LockDesktop(&gspdeskShouldBeForeground,
                    grpdeskRitInput,
                    LDL_DESKSHOULDBEFOREGROUND3,
                    0);

        gbDesktopLocked = TRUE;

        /*
         * Switch to disconnected desktop.
         */
        ThreadLockDesktop(ptiCurrent, gspdeskDisconnect, &tlpdesk, LDLT_FN_CTXDISABLESCREEN);
        xxxSwitchDesktop(pwinsta, gspdeskDisconnect, SDF_SLOVERRIDE);
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CTXDISABLESCREEN);
    } else if (gspdeskDisconnect != NULL) {
        /*
         * For some reason the disconnected desktop was the current desktop.
         * Now prevent switching from it.
         */
        gbDesktopLocked = TRUE;
    }

    return Status;
}

VOID xxxBroadcastDisplaySettingsChange(
    PDESKTOP pdesk,
    BOOL bBroadcastColorChange)
{
    /*
     * Broadcast that the display has changed resolution. We are going
     * to specify the desktop for the changing-desktop. That way we
     * don't get confused as to what desktop to broadcast to.
     */
    xxxBroadcastMessage(pdesk->pDeskInfo->spwnd,
                        WM_DISPLAYCHANGE,
                        gpsi->BitCount,
                        MAKELONG(SYSMET(CXSCREEN), SYSMET(CYSCREEN)),
                        BMSG_SENDNOTIFYMSG,
                        NULL);

    /*
     * Broadcast a color-change if requested to do so.
     */
    if (bBroadcastColorChange) {
        xxxBroadcastMessage(pdesk->pDeskInfo->spwnd,
                            WM_SETTINGCHANGE,
                            0,
                            0,
                            BMSG_SENDNOTIFYMSG,
                            NULL);

        xxxBroadcastMessage(pdesk->pDeskInfo->spwnd,
                            WM_SYSCOLORCHANGE,
                            0,
                            0,
                            BMSG_SENDNOTIFYMSG,
                            NULL);
    }
}


NTSTATUS xxxRequestOutOfFullScreenMode(
    VOID)
{
    TL tlpwndT;
    NTSTATUS Status = STATUS_SUCCESS;

    if (gspwndFullScreen) {
        /*
         * Give the console window a chance to orderly exit full screen mode.
         */

        ThreadLock(gspwndFullScreen, &tlpwndT);
        xxxSendMessage(gspwndFullScreen, CM_MODE_TRANSITION, (WPARAM)WINDOWED, (LPARAM)0);
        ThreadUnlock(&tlpwndT);

        /*
         * Let's loop until the system has settled down and no mode switch
         * is currently occuring.
         */
        while (ghSwitcher != NULL) {
            /*
             * Make sure we aren't blocking anyone who's sending us a
             * message. They can have ghSwitcher and never release it
             * because they are waiting on us to process the sent message.
             * And we're waiting on ghSwitcher, hence a deadlock.
             */
            xxxSleepThread(0, 1, FALSE);
        }

        /*
         * See if the fullscreen window didn't exit fullscreen mode
         * gracefully.
         */
        if (gspwndFullScreen && (gbFullScreen == FULLSCREEN)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\fekbd.c ===
/****************************** Module Header ******************************\
* Module Name: fekbd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* OEM-specific tables and routines for FarEast keyboards.
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * This macro will clear Virtual key code.
 */
#define NLS_CLEAR_VK(Vk)  \
    ((Vk) &= (KBDEXT|KBDMULTIVK|KBDSPECIAL|KBDNUMPAD|KBDBREAK))

/*
 * This macro will clear Virtual key code and 'make'/'break' bit.
 */
#define NLS_CLEAR_VK_AND_ATTR(Vk) \
    ((Vk) &= (KBDEXT|KBDMULTIVK|KBDSPECIAL|KBDNUMPAD))

/*
 * VK_DBE_xxx tables.
 */
BYTE NlsAlphaNumMode[] = {VK_DBE_ALPHANUMERIC,VK_DBE_HIRAGANA,VK_DBE_KATAKANA,0};
BYTE NlsSbcsDbcsMode[] = {VK_DBE_SBCSCHAR,VK_DBE_DBCSCHAR,0};
BYTE NlsRomanMode[] = {VK_DBE_NOROMAN,VK_DBE_ROMAN,0};
BYTE NlsCodeInputMode[] = {VK_DBE_NOCODEINPUT,VK_DBE_CODEINPUT,0};

/*
 * Modifiers for generate NLS Virtual Key.
 */
VK_TO_BIT aVkToBits_NLSKBD[] = {
    { VK_SHIFT,   KBDSHIFT},
    { VK_CONTROL, KBDCTRL},
    { VK_MENU,    KBDALT},
    { 0,          0}
};

MODIFIERS Modifiers_NLSKBD = {
    &aVkToBits_NLSKBD[0],
    7,
    {
        0,  // modifier keys (VK modification number 0)
        1,  // modifier keys (VK modification number 1)
        2,  // modifier keys (VK modification number 2)
        3,  // modifier keys (VK modification number 3)
        4,  // modifier keys (VK modification number 4)
        5,  // modifier keys (VK modification number 5)
        6,  // modifier keys (VK modification number 6)
        7,  // modifier keys (VK modification number 7)
    }
};

/*
 * For PC-9800 Series configuration.
 */
#define GEN_KANA_AWARE 0x1 // Switch generation for VK_END/VK_HELP based on Kana On/Off.
#define GEN_VK_END     0x2 // Generate VK_END, otherwise VK_HELP.
#define GEN_VK_HOME    0x4 // Generate VK_HOME, otherwise VK_CLEAR.

#define IS_KANA_AWARE()   (fNlsKbdConfiguration & GEN_KANA_AWARE)
#define IS_SEND_VK_END()  (fNlsKbdConfiguration & GEN_VK_END)
#define IS_SEND_VK_HOME() (fNlsKbdConfiguration & GEN_VK_HOME)

BYTE fNlsKbdConfiguration = GEN_KANA_AWARE | GEN_VK_END | GEN_VK_HOME;

/***************************************************************************\
* NlsTestKeyStateToggle()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsTestKeyStateToggle(BYTE Vk)
{
    if (gpqForeground) {
        return (TestKeyStateToggle(gpqForeground,Vk));
    } else {
        return (TestAsyncKeyStateToggle(Vk));
    }
}

/***************************************************************************\
* NlsSetKeyStateToggle(BYTE Vk)
*
* History:
* 27-09-96 hideyukn       Created.
\***************************************************************************/

VOID NlsSetKeyStateToggle(BYTE Vk)
{
    if (gpqForeground)
        SetKeyStateToggle(gpqForeground,Vk);
    SetAsyncKeyStateToggle(Vk);
}

/***************************************************************************\
* NlsClearKeyStateToggle()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

VOID NlsClearKeyStateToggle(BYTE Vk)
{
    if (gpqForeground)
        ClearKeyStateToggle(gpqForeground,Vk);
    ClearAsyncKeyStateToggle(Vk);
}

/***************************************************************************\
* NlsGetCurrentInputMode()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BYTE NlsGetCurrentInputMode(BYTE *QueryMode)
{
    BYTE *VkTable = QueryMode;
    BYTE VkDefault;
    /*
     * Get VkDefault, we will return this, if no bit is toggled.
     */
    VkDefault = *VkTable;

    while (*VkTable) {
        if (NlsTestKeyStateToggle(*VkTable)) {
            return *VkTable;
        }
        VkTable++;
    }

    /* Something error */
    return VkDefault;
}

/***************************************************************************\
* NlsNullProc() - nothing to do
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsNullProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    /*
     * Actually we should not get here...
     */
    return TRUE;
}

/***************************************************************************\
* NlsSendBaseVk() - nothing to do
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsSendBaseVk(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    /*
     * We don't need to modify Original data.
     */
    return TRUE;
}

/***************************************************************************\
* NlsSendParamVk() - Replace original message with parameter
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsSendParamVk(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);

    /*
     * Clear Virtual code.
     */
    NLS_CLEAR_VK(pKe->usFlaggedVk);
    /*
     * Set parameter as new VK key.
     */
    pKe->usFlaggedVk |= (BYTE)dwParam;
    return TRUE;
}

/***************************************************************************\
* NlsLapseProc() - Lapse handle (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsLapseProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    /*
     * Just throw away this event.
     */
    return FALSE;
}

/***************************************************************************\
* AlphanumericModeProc() - handle special case Alphanumeric key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsAlphanumericModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!NlsTestKeyStateToggle(VK_DBE_ALPHANUMERIC)) {
            /*
             * Query current mode.
             */
            BYTE CurrentMode = NlsGetCurrentInputMode(NlsAlphaNumMode);
            /*
             * Off toggle for previous key mode.
             */
            NlsClearKeyStateToggle(CurrentMode);
            /*
             * We are not in 'AlphaNumeric' mode, before enter 'AlphaNumeric'
             * mode, we should send 'break' for previous key mode.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk | CurrentMode | KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                        pKe->hDevice,
                        &pKe->data,
#endif
                        FALSE);
        }
        /*
         * Switch to 'AlphaNumeric' mode.
         */
        pKe->usFlaggedVk |= VK_DBE_ALPHANUMERIC;

        /*
         * Call i/o control.
         */
        if ((!gdwIMEOpenStatus) && NlsTestKeyStateToggle(VK_KANA)) {
            NlsKbdSendIMEProc(TRUE, IME_CMODE_KATAKANA);
        }
    } else {
        return NlsLapseProc(pKe,dwExtraInfo,dwParam);
    }
    return TRUE;
}

/***************************************************************************\
* KatakanaModeProc() - handle special case Katakana key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsKatakanaModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!NlsTestKeyStateToggle(VK_DBE_KATAKANA)) {
            /*
             * Query current mode.
             */
            BYTE CurrentMode = NlsGetCurrentInputMode(NlsAlphaNumMode);
            /*
             * Off toggle for previous key mode.
             */
            NlsClearKeyStateToggle(CurrentMode);
            /*
             * We are not in 'Katakana' mode, yet. Before enter 'Katakana'
             * mode, we should make 'break key' for previous mode.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk | CurrentMode | KBDBREAK),
                       pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                        pKe->hDevice,
                        &pKe->data,
#endif
                        FALSE);
        }
        /*
         * Switch to 'Katakana' mode.
         */
        pKe->usFlaggedVk |= VK_DBE_KATAKANA;

        /*
         * Call i/o control.
         */
        if ((!gdwIMEOpenStatus) && (!(NlsTestKeyStateToggle(VK_KANA)))) {
            NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* HiraganaModeProc() - handle special case Hiragana key (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsHiraganaModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!NlsTestKeyStateToggle(VK_DBE_HIRAGANA)) {
            /*
             * Query current mode.
             */
            BYTE CurrentMode = NlsGetCurrentInputMode(NlsAlphaNumMode);
            /*
             * Off toggle for previous key mode.
             */
            NlsClearKeyStateToggle(CurrentMode);
            /*
             * We are not in 'Hiragana' mode, yet. Before enter 'Hiragana'
             * mode, we should make 'break key' for previous key.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk | CurrentMode | KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                      pKe->hDevice,
                      &pKe->data,
#endif
                      FALSE);
        }
        /*
         * Switch to 'Hiragana' mode.
         */
        pKe->usFlaggedVk |= VK_DBE_HIRAGANA;

        /*
         * Call i/o control.
         */
        if ((!gdwIMEOpenStatus) && (!(NlsTestKeyStateToggle(VK_KANA)))) {
            NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
        }
    } else {
        return (NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* SbcsDbcsToggleProc() - handle special case SBCS/DBCS key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsSbcsDbcsToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Query current 'Sbcs'/'Dbcs' mode.
         */
        BYTE CurrentMode = NlsGetCurrentInputMode(NlsSbcsDbcsMode);
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);
        /*
         * Off toggle for previous key mode.
         */
        NlsClearKeyStateToggle(CurrentMode);

        switch (CurrentMode) {
        case VK_DBE_SBCSCHAR:
            /*
             * We are in 'SbcsChar' mode, let us send 'break key' for that.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_SBCSCHAR|KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                      pKe->hDevice,
                      &pKe->data,
#endif
                      FALSE);
            /*
             * Then, switch to 'DbcsChar' mode.
             */
            pKe->usFlaggedVk |= VK_DBE_DBCSCHAR;
            break;
        case VK_DBE_DBCSCHAR:
            /*
             * We are in 'DbcsChar' mode, let us send 'break key' for that.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_DBCSCHAR|KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                      pKe->hDevice,
                      &pKe->data,
#endif
                      FALSE);
            /*
             * Then, switch to 'SbcsChar' mode.
             */
            pKe->usFlaggedVk |= VK_DBE_SBCSCHAR;
            break;
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* RomanToggleProc() - handle special case Roman key (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsRomanToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Query current 'Roman'/'NoRoman' mode.
         */
        BYTE CurrentMode = NlsGetCurrentInputMode(NlsRomanMode);
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);
        /*
         * Off toggle for previous key mode.
         */
        NlsClearKeyStateToggle(CurrentMode);

        switch (CurrentMode) {
            case VK_DBE_NOROMAN:
                /*
                 * We are in 'NoRoman' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_NOROMAN|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'Roman' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_ROMAN;
                break;
            case VK_DBE_ROMAN:
                /*
                 * We are in 'Roman' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_ROMAN|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'NoRoman' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_NOROMAN;
                break;
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* CodeInputToggleProc() - handle special case Code Input key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsCodeInputToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Query current 'CodeInput'/'NoCodeInput' mode.
         */
        BYTE CurrentMode = NlsGetCurrentInputMode(NlsCodeInputMode);
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);
        /*
         * Off toggle for previous key mode.
         */
        NlsClearKeyStateToggle(CurrentMode);

        switch (CurrentMode) {
            case VK_DBE_NOCODEINPUT:
                /*
                 * We are in 'NoCodeInput' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_NOCODEINPUT|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'CodeInput' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_CODEINPUT;
                break;
            case VK_DBE_CODEINPUT:
                /*
                 * We are in 'CodeInput' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_CODEINPUT|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'NoCodeInput' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_NOCODEINPUT;
                break;
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* KanaToggleProc() - handle special case Kana key (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsKanaModeToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    /*
     * Check this is 'make' or 'break'.
     */
    BOOL bMake = !(pKe->usFlaggedVk & KBDBREAK);
    /*
     * Check we are in 'kana' mode or not.
     */
    BOOL bKana = NlsTestKeyStateToggle(VK_KANA);
    /*
     * Clear virtual code and key attributes.
     */
    NLS_CLEAR_VK_AND_ATTR(pKe->usFlaggedVk);

    if (bMake) {
        /*
         * We are in 'make' sequence.
         */
        if (bKana) {
            /*
             * Make 'break' for VK_KANA.
             */
            pKe->usFlaggedVk |= (VK_KANA|KBDBREAK);
        } else {
            /*
             * Not yet in 'kana' mode, Let generate 'make' for VK_KANA...
             */
            pKe->usFlaggedVk |= VK_KANA;
        }
        return TRUE;
    } else {
        /*
         * We will keep 'down' & 'toggled' in 'kana' mode,
         * then don't need to generate 'break' for VK_KANA.
         * when next time generate 'make' for this, we will generate
         * 'break' for this.
         */
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
}

/**********************************************************************\
* NlsHelpOrEndProc()
*
* History:
* 26-09-96 hideyukn       Ported from NEC code.
\**********************************************************************/

BOOL NlsHelpOrEndProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    if (!(pKe->usFlaggedVk & KBDNUMPAD)) {
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!IS_KANA_AWARE()) {
            /*
             * We don't care 'kana' status. just check VK_END or VK_HELP.
             */
            if (IS_SEND_VK_END()) {
                pKe->usFlaggedVk |= VK_END;
            } else {
                pKe->usFlaggedVk |= VK_HELP;
            }
        } else {
            /*
             * We care 'kana' status.
             */
            if (IS_SEND_VK_END()) {
                if (NlsTestKeyStateToggle(VK_KANA)) {
                    pKe->usFlaggedVk |= VK_HELP;
                } else {
                    pKe->usFlaggedVk |= VK_END;
                }
            } else {
                if (NlsTestKeyStateToggle(VK_KANA)) {
                    pKe->usFlaggedVk |= VK_END;
                } else {
                    pKe->usFlaggedVk |= VK_HELP;
                }
            }
        }
    }
    return TRUE;
}

/**********************************************************************\
* NlsHelpOrEndProc()
*
* History:
* 26-09-96 hideyukn       Ported from NEC code.
\**********************************************************************/

BOOL NlsHomeOrClearProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    if (!(pKe->usFlaggedVk & KBDNUMPAD)) {
        /*
         * Clear virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (IS_SEND_VK_HOME()) {
            pKe->usFlaggedVk |= VK_HOME;
        } else {
            pKe->usFlaggedVk |= VK_CLEAR;
        }
    }
    return TRUE;
}

/**********************************************************************\
* NlsNumpadModeProc()
*
* History:
* 26-09-96 hideyukn       Ported from NEC code.
\**********************************************************************/

BOOL NlsNumpadModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    /*
     * Get current Virtual key.
     */
    BYTE Vk = LOBYTE(pKe->usFlaggedVk);

    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    if (!NlsTestKeyStateToggle(VK_NUMLOCK)) {
        /*
         * Clear virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        switch (Vk) {
        case VK_NUMPAD0:
             pKe->usFlaggedVk |= VK_INSERT;
             break;
        case VK_NUMPAD1:
             pKe->usFlaggedVk |= VK_END;
             break;
        case VK_NUMPAD2:
             pKe->usFlaggedVk |= VK_DOWN;
             break;
        case VK_NUMPAD3:
             pKe->usFlaggedVk |= VK_NEXT;
             break;
        case VK_NUMPAD4:
             pKe->usFlaggedVk |= VK_LEFT;
             break;
        case VK_NUMPAD5:
             pKe->usFlaggedVk |= VK_CLEAR;
             break;
        case VK_NUMPAD6:
             pKe->usFlaggedVk |= VK_RIGHT;
             break;
        case VK_NUMPAD7:
             pKe->usFlaggedVk |= VK_HOME;
             break;
        case VK_NUMPAD8:
             pKe->usFlaggedVk |= VK_UP;
             break;
        case VK_NUMPAD9:
             pKe->usFlaggedVk |= VK_PRIOR;
             break;
        case VK_DECIMAL:
             pKe->usFlaggedVk |= VK_DELETE;
             break;
        }

    } else if (TestRawKeyDown(VK_SHIFT)) {
        /*
         * Clear virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        switch (Vk) {
        case VK_NUMPAD0:
             pKe->usFlaggedVk |= VK_INSERT;
             break;
        case VK_NUMPAD1:
             pKe->usFlaggedVk |= VK_END;
             break;
        case VK_NUMPAD2:
             pKe->usFlaggedVk |= VK_DOWN;
             break;
        case VK_NUMPAD3:
             pKe->usFlaggedVk |= VK_NEXT;
             break;
        case VK_NUMPAD4:
             pKe->usFlaggedVk |= VK_LEFT;
             break;
        case VK_NUMPAD5:
             pKe->usFlaggedVk |= VK_CLEAR;
             break;
        case VK_NUMPAD6:
             pKe->usFlaggedVk |= VK_RIGHT;
             break;
        case VK_NUMPAD7:
             pKe->usFlaggedVk |= VK_HOME;
             break;
        case VK_NUMPAD8:
             pKe->usFlaggedVk |= VK_UP;
             break;
        case VK_NUMPAD9:
             pKe->usFlaggedVk |= VK_PRIOR;
             break;
        case VK_DECIMAL:
             pKe->usFlaggedVk |= VK_DELETE;
             break;
        }
    } else {
        /*
         * Otherwise, just pass through...
         */
    }
    return TRUE;
}

/**********************************************************************\
* NlsKanaEventProc() - Fujitsu FMV oyayubi shift keyboard use only.
*
* History:
* 10-10-96 v-kazuta       Created.
\**********************************************************************/
BOOL NlsKanaEventProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);
    /*
     * Clear Virtual code.
     */
    NLS_CLEAR_VK(pKe->usFlaggedVk);

    /*
     * Set parameter as new VK key.
     */
    pKe->usFlaggedVk |= (BYTE)dwParam;

    /*
     * Send notification to kernel mode keyboard driver.
     */
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        if (NlsTestKeyStateToggle(VK_KANA)) {
            /*
             * Call i/o control.
             */
            NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
        } else {
            /*
             * Call i/o control.
             */
            NlsKbdSendIMEProc(TRUE, IME_CMODE_KATAKANA);
        }
    }
    return TRUE;
}

/**********************************************************************\
* NlsConvOrNonConvProc() - Fujitsu FMV oyayubi shift keyboard only.
*
* History:
* 10-10-96 v-kazuta       Created.
\**********************************************************************/
BOOL NlsConvOrNonConvProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);
    /*
     *
     */
    if ((!gdwIMEOpenStatus) && (!(NlsTestKeyStateToggle(VK_KANA)))) {
        NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
    }
    /*
     * We don't need to modify Original data.
     */
    return TRUE;
}

/**********************************************************************\
* Index to function body dispatcher table
*
* History:
* 16-07-96 hideyukn       Created.
\**********************************************************************/

NLSKEPROC aNLSKEProc[] = {
    NlsNullProc,             // KBDNLS_NULL (Invalid function)
    NlsLapseProc,            // KBDNLS_NOEVENT (Drop keyevent)
    NlsSendBaseVk,           // KBDNLS_SEND_BASE_VK (Send Base VK_xxx)
    NlsSendParamVk,          // KBDNLS_SEND_PARAM_VK (Send Parameter VK_xxx)
    NlsKanaModeToggleProc,   // KBDNLS_KANAMODE (VK_KANA (Special case))
    NlsAlphanumericModeProc, // KBDNLS_ALPHANUM (VK_DBE_ALPHANUMERIC)
    NlsHiraganaModeProc,     // KBDNLS_HIRAGANA (VK_DBE_HIRAGANA)
    NlsKatakanaModeProc,     // KBDNLS_KATAKANA (VK_DBE_KATAKANA)
    NlsSbcsDbcsToggleProc,   // KBDNLS_SBCSDBCS (VK_DBE_SBCSCHAR/VK_DBE_DBCSCHAR)
    NlsRomanToggleProc,      // KBDNLS_ROMAN (VK_DBE_ROMAN/VK_DBE_NOROMAN)
    NlsCodeInputToggleProc,  // KBDNLS_CODEINPUT (VK_DBE_CODEINPUT/VK_DBE_NOCODEINPUT)
    NlsHelpOrEndProc,        // KBDNLS_HELP_OR_END (VK_HELP or VK_END)     [NEC PC-9800 Only]
    NlsHomeOrClearProc,      // KBDNLS_HOME_OR_CLEAR (VK_HOME or VK_CLEAR) [NEC PC-9800 Only]
    NlsNumpadModeProc,       // KBDNLS_NUMPAD (VK_xxx for Numpad)          [NEC PC-9800 Only]
    NlsKanaEventProc,        // KBDNLS_KANAEVENT (VK_KANA) [Fujitsu FMV oyayubi Only]
    NlsConvOrNonConvProc,    // KBDNLS_CONV_OR_NONCONV (VK_CONVERT and VK_NONCONVERT) [Fujitsu FMV oyayubi Only]
};

BOOL GenerateNlsVkKey(PVK_F pVkToF, WORD nMod, PKE pKe, ULONG_PTR dwExtraInfo)
{
    BYTE  iFuncIndex;
    DWORD dwParam;

    iFuncIndex = pVkToF->NLSFEProc[nMod].NLSFEProcIndex;
    dwParam = pVkToF->NLSFEProc[nMod].NLSFEProcParam;

    return((aNLSKEProc[iFuncIndex])(pKe, dwExtraInfo, dwParam));
}

BOOL GenerateNlsVkAltKey(PVK_F pVkToF, WORD nMod, PKE pKe, ULONG_PTR dwExtraInfo)
{
    BYTE  iFuncIndex;
    DWORD dwParam;

    iFuncIndex = pVkToF->NLSFEProcAlt[nMod].NLSFEProcIndex;
    dwParam = pVkToF->NLSFEProcAlt[nMod].NLSFEProcParam;

    return((aNLSKEProc[iFuncIndex])(pKe,dwExtraInfo,dwParam));
}

/***************************************************************************\
* KbdNlsFuncTypeDummy() - KBDNLS_FUNC_TYPE_NULL
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL KbdNlsFuncTypeDummy(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo)
{
    UNREFERENCED_PARAMETER(pVkToF);
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);

    /*
     * We don't need to modify Original data.
     */
    return TRUE;
}

/***************************************************************************\
* KbdNlsFuncTypeNormal - KBDNLS_FUNC_TYPE_NORMAL
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL KbdNlsFuncTypeNormal(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo)
{
    WORD nMod;

    if (pKe == NULL) {
        /*
         * Clear state and deactivate this key processor
         */
        return FALSE;
    }

    nMod = GetModificationNumber(&Modifiers_NLSKBD,
                                 GetModifierBits(&Modifiers_NLSKBD,
                                                 gafRawKeyState));

    if (nMod != SHFT_INVALID) {
        return(GenerateNlsVkKey(pVkToF, nMod, pKe, dwExtraInfo));
    }
    return FALSE;
}

/***************************************************************************\
* KbdNlsFuncTypeAlt - KBDNLS_FUNC_TYPE_ALT
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL KbdNlsFuncTypeAlt(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo)
{
    WORD nMod;
    BOOL fRet = FALSE;

    if (pKe == NULL) {
        /*
         * Clear state and deactivate this key processor
         */
        return FALSE;
    }

    nMod = GetModificationNumber(&Modifiers_NLSKBD,
                                 GetModifierBits(&Modifiers_NLSKBD,
                                                 gafRawKeyState));

    if (nMod != SHFT_INVALID) {
        if (!(pKe->usFlaggedVk & KBDBREAK)) {
            if (pVkToF->NLSFEProcCurrent == KBDNLS_INDEX_ALT) {
                fRet = GenerateNlsVkAltKey(pVkToF, nMod, pKe, dwExtraInfo);
            } else {
                fRet = GenerateNlsVkKey(pVkToF, nMod, pKe, dwExtraInfo);
            }
            if (pVkToF->NLSFEProcSwitch & (1 << nMod)) {
                TAGMSG0(DBGTAG_IMM, "USERKM:FEKBD Switching Alt table");
                /*
                 * Switch to "alt".
                 */
                pVkToF->NLSFEProcCurrent = KBDNLS_INDEX_ALT;
            }
        } else {
            if (pVkToF->NLSFEProcCurrent == KBDNLS_INDEX_ALT) {
                fRet = GenerateNlsVkAltKey(pVkToF, nMod, pKe, dwExtraInfo);
                /*
                 * Back to "normal"
                 */
                pVkToF->NLSFEProcCurrent = KBDNLS_INDEX_NORMAL;
            } else {
                fRet = GenerateNlsVkKey(pVkToF, nMod, pKe, dwExtraInfo);
            }
        }
    }
    return fRet;
}

/***************************************************************************\
* KENLSProcs()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

NLSVKFPROC aNLSVKFProc[] = {
    KbdNlsFuncTypeDummy,  // KBDNLS_TYPE_NULL       0
    KbdNlsFuncTypeNormal, // KBDNLS_TYPE_NORMAL     1
    KbdNlsFuncTypeAlt     // KBDNLS_TYPE_TOGGLE     2
};

/*
 * Returning FALSE means the Key Event has been deleted by a special-case
 * KeyEvent processor.
 * Returning TRUE means the Key Event should be passed on (although it may
 * have been altered.
 */
BOOL xxxKENLSProcs(PKE pKe, ULONG_PTR dwExtraInfo)
{

    CheckCritIn();

    if (gpKbdNlsTbl != NULL) {
        PVK_F pVkToF = gpKbdNlsTbl->pVkToF;
        UINT  iNumVk = gpKbdNlsTbl->NumOfVkToF;

        while(iNumVk) {
            if (pVkToF[iNumVk-1].Vk == LOBYTE(pKe->usFlaggedVk)) {
                return aNLSVKFProc[pVkToF[iNumVk-1].NLSFEProcType](&pVkToF[iNumVk-1], pKe, dwExtraInfo);
            }
            iNumVk--;
        }
    }
    /*
     * Other special Key Event processors
     */
    return TRUE;
}

/***************************************************************************\
* NlsKbdSendIMENotification()
*
* History:
* 10-09-96 hideyukn       Created.
\***************************************************************************/

VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion)
{
    PKBDNLSTABLES       pKbdNlsTable = gpKbdNlsTbl;

    if (pKbdNlsTable == NULL) {
        /*
         * 'Active' layout driver does not have NLSKBD table.
         */
        return;
    }

    /*
     * Let us send notification to kernel mode keyboard driver, if nessesary.
     */
    if ((pKbdNlsTable->LayoutInformation) & NLSKBD_INFO_SEND_IME_NOTIFICATION) {
        PDEVICEINFO pDeviceInfo;

        /*
         * Fill up the KEYBOARD_IME_STATUS structure.
         */
        gKbdImeStatus.UnitId      = 0;
        gKbdImeStatus.ImeOpen     = dwImeOpen;
        gKbdImeStatus.ImeConvMode = dwImeConversion;

        EnterDeviceInfoListCrit();
        BEGINATOMICDEVICEINFOLISTCHECK();
        for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
            if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                RequestDeviceChange(pDeviceInfo, GDIAF_IME_STATUS, TRUE);
            }
        }
        ENDATOMICDEVICEINFOLISTCHECK();
        LeaveDeviceInfoListCrit();
    }
}

VOID NlsKbdSendIMEProc(DWORD dwImeOpen, DWORD dwImeConversion)
{
    if (gpqForeground != NULL && gpqForeground->ptiKeyboard != NULL &&
        (!(GetAppImeCompatFlags(gpqForeground->ptiKeyboard) & IMECOMPAT_HYDRACLIENT))) {
        NlsKbdSendIMENotification(dwImeOpen, dwImeConversion);
    }
}

/*
 * Compatibility for Windows NT 3.xx and Windows 3.x for NEC PC-9800 Series
 */
#define NLSKBD_CONFIG_PATH L"WOW\\keyboard"

/***************************************************************************\
* NlsKbdInitializePerSystem()
*
* History:
* 26-09-96 hideyukn       Created.
\***************************************************************************/

VOID NlsKbdInitializePerSystem(VOID)
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[4];

    UNICODE_STRING EndString, HelpString;
    UNICODE_STRING YesString, NoString;
    UNICODE_STRING HomeString, ClearString;

    UNICODE_STRING HelpKeyString;
    UNICODE_STRING KanaHelpString;
    UNICODE_STRING ClearKeyString;

    NTSTATUS Status;

    //
    // Set default VK_DBE_xxx status.
    //
    //
    // AlphaNumeric input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_ALPHANUMERIC);

    //
    // Single byte character input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_SBCSCHAR);

    //
    // No roman input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_NOROMAN);

    //
    // No code input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_NOCODEINPUT);

    //
    // From Here, below code is for compatibility for Windows NT 3.xx
    // for NEC PC-9800 verion.
    //

    //
    // Initialize default strings.
    //
    RtlInitUnicodeString(&EndString, L"end");
    RtlInitUnicodeString(&HelpString,L"help");

    RtlInitUnicodeString(&YesString,L"yes");
    RtlInitUnicodeString(&NoString, L"no");

    RtlInitUnicodeString(&HomeString, L"home");
    RtlInitUnicodeString(&ClearString,L"clear");

    //
    // Initialize recieve buffer.
    //
    RtlInitUnicodeString(&HelpKeyString,NULL);
    RtlInitUnicodeString(&KanaHelpString,NULL);
    RtlInitUnicodeString(&ClearKeyString,NULL);

    //
    // Initalize query tables.
    //
    // ValueName : "helpkey"
    // ValueData : if "end" VK_END, otherwise VK_HELP
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[0].Name = (PWSTR) L"helpkey",
    QueryTable[0].EntryContext = (PVOID) &HelpKeyString;
    QueryTable[0].DefaultType = REG_SZ;
    QueryTable[0].DefaultData = &EndString;
    QueryTable[0].DefaultLength = 0;

    //
    // ValueName : "KanaHelpKey"
    // ValueData : if "yes" if kana on switch VK_HELP and VK_END
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[1].Name = (PWSTR) L"KanaHelpKey",
    QueryTable[1].EntryContext = (PVOID) &KanaHelpString;
    QueryTable[1].DefaultType = REG_SZ;
    QueryTable[1].DefaultData = &YesString;
    QueryTable[1].DefaultLength = 0;

    //
    // ValueName : "clrkey"
    // ValueData : if "home" VK_HOME, otherwise VK_CLEAR
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[2].Name = (PWSTR) L"clrkey",
    QueryTable[2].EntryContext = (PVOID) &ClearKeyString;
    QueryTable[2].DefaultType = REG_SZ;
    QueryTable[2].DefaultData = &HomeString;
    QueryTable[2].DefaultLength = 0;

    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = NULL;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    NLSKBD_CONFIG_PATH,
                                    QueryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "FEKBD:RtlQueryRegistryValues fails (%x)", Status);
        return;
    }

    if (RtlEqualUnicodeString(&HelpKeyString,&HelpString,TRUE)) {
        /*
         * Generate VK_HELP, when NLSKBD_HELP_OR_END is called.
         */
        fNlsKbdConfiguration &= ~GEN_VK_END;
    }

    if (RtlEqualUnicodeString(&KanaHelpString,&NoString,TRUE)) {
        /*
         * In case of "yes":
         * If 'kana' is on, when NLSKBD_HELP_OR_END is called, switch VK_END and VK_HELP.
         * Else, in case of "no":
         * Doesn't generate by 'kana' toggle state.
         */
        fNlsKbdConfiguration &= ~GEN_KANA_AWARE;
    }

    if (RtlEqualUnicodeString(&ClearKeyString,&ClearString,TRUE)) {
        /*
         * Generate VK_CLEAR, when KBDNLS_HOME_OR_CLEAR is called.
         */
        fNlsKbdConfiguration &= ~GEN_VK_HOME;
    }

    ExFreePool(HelpKeyString.Buffer);
    ExFreePool(KanaHelpString.Buffer);
    ExFreePool(ClearKeyString.Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\globals.h ===
/****************************** Module Header ******************************\
* Module Name: globals.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables
* One must be executing on the server's context to manipulate
* any of these variables or call any of these functions.  Serializing access
* to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#ifndef _GLOBALS_
#define _GLOBALS_

#ifdef AUTORUN_CURSOR
UINT_PTR  gtmridAutorunCursor;
#endif // AUTORUN_CURSOR

extern ULONG InitSafeBootMode;  // imported from NTOS (init.c), must use a pointer to reference the data

extern DWORD   gdwPUDFlags;

/*
 * Wallpaper Data.
 */
extern HBITMAP  ghbmWallpaper;
extern HPALETTE ghpalWallpaper;
extern SIZERECT gsrcWallpaper;
extern UINT     gwWPStyle;
extern HBITMAP  ghbmDesktop;
extern LPWSTR   gpszWall;

/*
 * Policy Settings.
 */
extern DWORD gdwPolicyFlags;

/*
 * SafeBoot
 */
extern DWORD gDrawVersionAlways;

/*
 * TS override flag for painting desktop version.
 */
extern DWORD gdwTSExcludeDesktopVersion;

/*
 * External drivers
 */
extern BOOL gfUnsignedDrivers;

/*
 * External drivers
 */
extern BOOL gfUnsignedDrivers;

/*
 * Full-Drag.
 */
extern HRGN ghrgnUpdateSave;
extern int  gnUpdateSave;

extern PWND gspwndAltTab;

extern PWND gspwndShouldBeForeground;

/*
 * full screen variables
 */
extern PWND  gspwndScreenCapture;
extern PWND  gspwndInternalCapture;
extern PWND  gspwndFullScreen;

/*
 * pre-cached monitor for mode changes
 */
extern PMONITOR gpMonitorCached;

/*
 * logon notify window
 */
extern PWND  gspwndLogonNotify;

extern PKEVENT gpEventDiconnectDesktop;

/*
 * handle for WinSta0_DesktopSwitch event
 */
extern HANDLE  ghEventSwitchDesktop;
extern PKEVENT gpEventSwitchDesktop;

/*
 * Thread Info Variables
 */
extern PTHREADINFO     gptiTasklist;
extern PTHREADINFO     gptiShutdownNotify;
extern PTHREADINFO     gptiLockUpdate;
extern PTHREADINFO     gptiForeground;
extern PTHREADINFO     gptiBlockInput;
extern PWOWTHREADINFO  gpwtiFirst;
extern PWOWPROCESSINFO gpwpiFirstWow;

/*
 * Queue Variables
 */
extern PQ gpqForeground;
extern PQ gpqForegroundPrev;
extern PQ gpqCursor;

/*
 * Accessibility globals
 */
extern FILTERKEYS    gFilterKeys;
extern STICKYKEYS    gStickyKeys;
extern MOUSEKEYS     gMouseKeys;
extern ACCESSTIMEOUT gAccessTimeOut;
extern TOGGLEKEYS    gToggleKeys;
extern SOUNDSENTRY   gSoundSentry;

extern HIGHCONTRAST  gHighContrast;
extern WCHAR         gHighContrastDefaultScheme[];

/*
 * Fade animation globals
 */
extern FADE gfade;

/*
 * FilterKeys Support
 */
extern UINT_PTR  gtmridFKActivation;
extern UINT_PTR  gtmridFKResponse;
extern UINT_PTR  gtmridFKAcceptanceDelay;
extern int   gFilterKeysState;

extern KE gFKKeyEvent;
extern CONST PKE gpFKKeyEvent;
extern ULONG gFKExtraInformation;
extern int gFKNextProcIndex;

/*
 * ToggleKeys Support
 */
extern UINT_PTR  gtmridToggleKeys;
extern ULONG gTKExtraInformation;
extern int   gTKNextProcIndex;

/*
 * TimeOut Support
 */
extern UINT_PTR  gtmridAccessTimeOut;


/*
 * MouseKeys Support
 */
extern WORD  gwMKButtonState;
extern WORD  gwMKCurrentButton;
extern UINT_PTR  gtmridMKMoveCursor;
extern LONG  gMKDeltaX;
extern LONG  gMKDeltaY;
extern UINT  giMouseMoveTable;

extern HWND ghwndSoundSentry;
extern UINT_PTR  gtmridSoundSentry;

extern MOUSECURSOR gMouseCursor;

/*
 * Multilingual keyboard layout support.
 */
extern PKL      gspklBaseLayout;
extern HKL      gLCIDSentToShell;
extern DWORD    gSystemFS;   // System font's fontsignature (single bit)

extern KBDLANGTOGGLE gLangToggle[];
extern int           gLangToggleKeyState;

extern BYTE          gfInNumpadHexInput;
extern BOOL          gfEnableHexNumpad;

/*
 * Grave accent keyboard switch for thai locales
 */
extern BOOL gbGraveKeyToggle;



/*
 * Points to currently active Keyboard Layer tables
 */
extern PKBDTABLES    gpKbdTbl;
extern PKL           gpKL;
extern BYTE          gSystemCPCharSet;   // System's input locale charset
extern PKBDNLSTABLES gpKbdNlsTbl;
extern DWORD         gdwKeyboardAttributes;

/*
 * from kbd.c
 */
extern USHORT ausNumPadCvt[]; // VK values for Numeric keypad.

extern DWORD     gtimeStartCursorHide;
extern RECT      grcCursorClip;
extern ULONG_PTR gdwMouseMoveExtraInfo;
extern DWORD     gdwMouseMoveTimeStamp;
extern LASTINPUT glinp;
extern POINT     gptCursorAsync;
extern PPROCESSINFO gppiInputProvider;
extern PPROCESSINFO gppiLockSFW;
extern UINT guSFWLockCount;
#if DBG
extern BOOL gfDebugForegroundIgnoreDebugPort;
#endif

// FE Modifiers_VK
extern PMODIFIERS gpModifiers_VK;
extern MODIFIERS Modifiers_VK_STANDARD;
extern MODIFIERS Modifiers_VK_IBM02;

/***************************************************************************\
* apulCvt_VK[] - obtain VK translation table from shift state
*     A VK translation table is used to change the value of the Virtual Key
*     according to the shift state.   OEM only (not locale-specific)
\***************************************************************************/
extern PULONG *gapulCvt_VK;
extern ULONG *gapulCvt_VK_101[];
extern ULONG *gapulCvt_VK_84[];
// gapulCvt_VK_IBM02[] is for FE
extern ULONG *gapulCvt_VK_IBM02[];

/***************************************************************************\
* awNumPadCvt[]   - Translate cursor movement keys to numpad keys
\***************************************************************************/
extern BYTE aVkNumpad[];

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];


/*
 * Cursor related Variables
 */
extern PCURSOR gpcurLogCurrent;
extern PCURSOR gpcurPhysCurrent;
extern RECT    grcVDMCursorBounds;
extern DWORD   gdwLastAniTick;
extern UINT_PTR gidCursorTimer;

extern PWND gspwndActivate;
extern PWND gspwndLockUpdate;
extern PWND gspwndMouseOwner;
extern HWND ghwndSwitch;

extern UINT gwMouseOwnerButton;
extern BOOL gbMouseButtonsRecentlySwapped;

extern UINT gdtMNDropDown;

extern int  gcountPWO;          /* count of pwo WNDOBJs in gdi */
extern int  gnKeyboardSpeed;
extern int  giScreenSaveTimeOutMs;
extern BOOL gbBlockSendInputResets;

extern PBWL gpbwlList;

extern UINT gdtDblClk;

extern UINT gcxMouseHover;
extern UINT gcyMouseHover;
extern UINT gdtMouseHover;

extern CAPTIONCACHE gcachedCaptions[];

extern PATTACHINFO  gpai;

extern PDESKTOP     gpdeskRecalcQueueAttach;

extern PWND         gspwndCursor;
extern PPROCESSINFO gppiStarting;
extern PPROCESSINFO gppiList;
extern PPROCESSINFO gppiWantForegroundPriority;
extern PPROCESSINFO gppiForegroundOld;

extern PW32JOB      gpJobsList;


extern UINT_PTR  gtmridAniCursor;

extern int           gcHotKey;
extern PHOTKEYSTRUCT gpHotKeyList;
extern int           gcHotKeyAlloc;
extern PIMEHOTKEYOBJ gpImeHotKeyListHeader;


extern int gMouseSpeed;
extern int gMouseThresh1;
extern int gMouseThresh2;
extern int gMouseSensitivityFactor;
extern int gMouseSensitivity;
extern int gMouseTrails;
extern int gMouseTrailsToHide;
extern UINT_PTR  gtmridMouseTrails;

extern UINT   guDdeSendTimeout;


extern INT   gnFastAltTabRows;    /* Rows of icons in quick switch window     */
extern INT   gnFastAltTabColumns; /* Columns of icons in quick switch window  */

extern DWORD   gdwThreadEndSession; /* Shutting down system?                    */

extern HBRUSH  ghbrHungApp;       /* Brush used to redraw hung app windows.   */

extern HBITMAP ghbmBits;
extern HBITMAP ghbmCaption;

extern int     gcxCaptionFontChar;
extern int     gcyCaptionFontChar;
extern HFONT   ghSmCaptionFont;
extern int     gcxSmCaptionFontChar;
extern int     gcySmCaptionFontChar;

extern HFONT   ghMenuFont;
extern HFONT   ghMenuFontDef;
extern int     gcxMenuFontChar;
extern int     gcyMenuFontChar;
extern int     gcxMenuFontOverhang;
extern int     gcyMenuFontExternLeading;
extern int     gcyMenuFontAscent;
extern int     gcyMenuScrollArrow;

#ifdef LAME_BUTTON
extern HFONT ghLameFont;
extern DWORD gdwLameFlags;
#endif

#if DBG
extern UINT guModalMenuStateCount;
#endif

/*
 * From mnstate.c
 */
extern POPUPMENU gpopupMenu;
extern MENUSTATE gMenuState;

extern HFONT ghStatusFont;
extern HFONT ghIconFont;

/*
 * Cached SMWP structure
 */
extern SMWP gSMWP;

extern DWORD gpdwCPUserPreferencesMask [SPI_BOOLMASKDWORDSIZE];

extern PROFILEVALUEINFO gpviCPUserPreferences [1 + SPI_DWORDRANGECOUNT];

/*
 * Sys expunge control data.
 */
extern DWORD gdwSysExpungeMask;    // hmods to be expunged
extern DWORD gcSysExpunge;         // current count of expunges performed

/*
 * System classes
 */
extern PCLS gpclsList;

extern PCURSOR gpcurFirst;

extern SYSCFGICO gasyscur[];
extern SYSCFGICO gasysico[];

/*
 * Screen Saver Info
 */
extern PPROCESSINFO gppiScreenSaver;
extern POINT        gptSSCursor;

/*
 * Orphaned fullscreen mode changes that DDraw used to cleanup.
 */
extern PPROCESSINFO gppiFullscreen;

/*
 * accessibility byte-size data
 */
extern BYTE  gLastVkDown;
extern BYTE  gBounceVk;
extern BYTE gPhysModifierState;
extern BYTE gCurrentModifierBit;
extern BYTE gPrevModifierState;
extern BYTE gLatchBits;
extern BYTE gLockBits;
extern BYTE  gTKScanCode;
extern BYTE  gMKPreviousVk;
extern BYTE  gbMKMouseMode;

extern PSCANCODEMAP gpScancodeMap;

extern BYTE gStickyKeysLeftShiftCount;  // # of consecutive left shift key presses.
extern BYTE gStickyKeysRightShiftCount; // # of consecutive right shift key presses.


/*
 * Some terminal data is global in non-Hydra.
 */
extern DWORD               gdwGTERMFlags;   // GTERMF_ flags
extern PTHREADINFO         gptiRit;
extern PDESKTOP            grpdeskRitInput;
extern PKEVENT             gpkeHidChange;
extern PKEVENT             gpkeMouseData;

/*
 * Video Information
 */
extern BYTE                gbFullScreen;
extern PDISPLAYINFO        gpDispInfo;
extern BOOL                gbMDEVDisabled;

/*
 * Count of available cacheDC's. This is used in determining a threshold
 * count of DCX_CACHE types available.
 */
extern int gnDCECount;

extern int gnVisibleRedirectedCount;

/*
 * Hung redraw list
 */
extern  PVWPL  gpvwplHungRedraw;

/*
 * SetWindowPos() related globals
 */
extern HRGN    ghrgnInvalidSum;
extern HRGN    ghrgnVisNew;
extern HRGN    ghrgnSWP1;
extern HRGN    ghrgnValid;
extern HRGN    ghrgnValidSum;
extern HRGN    ghrgnInvalid;

extern HRGN    ghrgnInv0;               // Temp used by InternalInvalidate()
extern HRGN    ghrgnInv1;               // Temp used by InternalInvalidate()
extern HRGN    ghrgnInv2;               // Temp used by InternalInvalidate()

extern HDC     ghdcMem;
extern HDC     ghdcMem2;

/*
 * DC Cache related globals
 */
extern HRGN    ghrgnGDC;                // Temp used by GetCacheDC et al

/*
 * SPB related globals
 */
extern HRGN    ghrgnSCR;                // Temp used by SpbCheckRect()
extern HRGN    ghrgnSPB1;
extern HRGN    ghrgnSPB2;

/*
 * ScrollWindow/ScrollDC related globals
 */
extern HRGN    ghrgnSW;              // Temps used by ScrollDC/ScrollWindow
extern HRGN    ghrgnScrl1;
extern HRGN    ghrgnScrl2;
extern HRGN    ghrgnScrlVis;
extern HRGN    ghrgnScrlSrc;
extern HRGN    ghrgnScrlDst;
extern HRGN    ghrgnScrlValid;

/*
 * General Device and Driver information
 */
extern PDEVICEINFO gpDeviceInfoList;
extern PERESOURCE  gpresDeviceInfoList;
#if DBG
extern DWORD gdwDeviceInfoListCritSecUseCount;
extern DWORD gdwInAtomicDeviceInfoListOperation;
#endif
extern PDRIVER_OBJECT gpWin32kDriverObject;
extern DWORD gnRetryReadInput;

/*
 * Mouse Information
 */
extern MOUSEEVENT  gMouseEventQueue[];
extern DWORD       gdwMouseQueueHead;
extern DWORD       gdwMouseEvents;
extern PERESOURCE  gpresMouseEventQueue;
extern int         gnMice;

/*
 * Keyboard Information
 */
extern KEYBOARD_ATTRIBUTES             gKeyboardInfo;
extern CONST KEYBOARD_ATTRIBUTES gKeyboardDefaultInfo;
extern KEYBOARD_INPUT_DATA             gkei[];
extern KEYBOARD_INDICATOR_PARAMETERS   gklp;
extern KEYBOARD_INDICATOR_PARAMETERS   gklpBootTime;
extern KEYBOARD_TYPEMATIC_PARAMETERS   gktp;
extern int                             gnKeyboards;
extern IO_STATUS_BLOCK                 giosbKbdControl;
/*
 * IME status for keyboard device
 */
extern KEYBOARD_IME_STATUS             gKbdImeStatus;


extern BYTE gafAsyncKeyState[];
extern BYTE gafAsyncKeyStateRecentDown[];

extern BYTE gafRawKeyState[];

extern BOOLEAN gfKanaToggle;

extern DWORD               gdwUpdateKeyboard;
extern HARDERRORHANDLER    gHardErrorHandler;

extern UINT      gfsSASModifiers;     // SAS modifiers
extern UINT      gfsSASModifiersDown; // SAS modifiers really physically down
extern UINT      gvkSAS;              // The Secure Attention Sequence (SAS) key.

// FE_IME
extern DWORD     gdwIMEOpenStatus;
extern DWORD     gdwIMEConversionStatus;
extern HIMC      gHimcFocus;
extern BOOL      gfIMEShowStatus;
// end FE_IME

#ifdef GENERIC_INPUT
extern int gnHid;
#endif

#ifdef MOUSE_IP
/*
 * Sonar
 */
extern int giSonarRadius;
extern BYTE gbLastVkForSonar;
extern BYTE gbVkForSonarKick;
extern POINT gptSonarCenter;

#endif

/*
 * Clicklock
 */
extern BOOL  gfStartClickLock;
extern DWORD gdwStartClickLockTick;

/*
 * Mouse move points
 */
extern MOUSEMOVEPOINT gaptMouse[];
extern UINT gptInd;


extern CONST ALWAYSZERO gZero;
extern KBDTABLES KbdTablesFallback;
extern CONST HANDLETYPEINFO gahti[];

/*
 * Security data
 */

extern CONST GENERIC_MAPPING KeyMapping;

extern CONST GENERIC_MAPPING WinStaMapping;
extern PSECURITY_DESCRIPTOR gpsdInitWinSta;

extern PPUBOBJ gpPublicObjectList;

extern CONST PROC apfnSimpleCall[];
extern CONST ULONG ulMaxSimpleCall;

extern PRIVILEGE_SET psTcb;

extern PVOID Win32KBaseAddress;

extern CONST GENERIC_MAPPING DesktopMapping;

extern CONST SFNSCSENDMESSAGE gapfnScSendMessage[];

extern PSMS gpsmsList;

extern TERMINAL gTermIO;
extern TERMINAL gTermNOIO;

extern PTERMINAL gpMainTerminal;
extern PWINDOWSTATION grpWinStaList;
/*
 * the logon desktop
 */
extern PDESKTOP grpdeskLogon;


extern CONST LUID luidSystem;

extern PKBDFILE gpkfList;        // Currently loaded keyboard layout files.

extern PTHREADINFO gptiCurrent;
extern PTIMER gptmrFirst;
extern PKTIMER gptmrMaster;
extern DWORD gcmsLastTimer;
extern BOOL gbMasterTimerSet;

extern ULONGLONG gSessionCreationTime;

extern BOOL gbDisableAlpha;

extern LONG gUserProcessHandleQuota;
extern DWORD gUserPostMessageLimit;

/*
 * Active Accessibility - Window Events
 */
extern PEVENTHOOK gpWinEventHooks;    // list of installed hooks
extern PNOTIFY gpPendingNotifies;     // FILO of outstanding notifications
extern PNOTIFY gpLastPendingNotify;   // end of above list.
extern DWORD gdwDeferWinEvent;        // Defer notification is > 0

/*
 * This is the timeout value used for callbacks to low level hook procedures
 */
extern int gnllHooksTimeout;

/*
 * UserApiHook
 */
extern int gihmodUserApiHook;
extern ULONG_PTR goffPfnInitUserApiHook;
extern PPROCESSINFO gppiUserApiHook;

// FE_SB
extern PUSHORT gpusMouseVKey;

extern USHORT  gNumLockVk;
extern USHORT  gOemScrollVk;
// FE_SB

extern CONST WCHAR szOneChar[];
extern CONST WCHAR szY[];
extern CONST WCHAR szy[];
extern CONST WCHAR szN[];

extern CONST WCHAR szNull[];

extern WCHAR szWindowStationDirectory[MAX_SESSION_PATH];

extern HBRUSH  ghbrWhite;
extern HBRUSH  ghbrBlack;
extern HFONT ghFontSys;

extern HANDLE hModuleWin;
extern HANDLE hModClient;

#if DBG
extern LONG TraceInitialization;
#endif

extern DESKTOPINFO diStatic;

extern ULONG gdwDesktopId;

extern PERESOURCE gpresUser;
extern PFAST_MUTEX gpHandleFlagsMutex;

extern PROC gpfnwp[];

#ifdef HUNGAPP_GHOSTING
extern PKEVENT gpEventScanGhosts;
extern ATOM gatomGhost;
#endif // HUNGAPP_GHOSTING

extern ATOM gatomShadow;

extern ATOM gatomConsoleClass;
extern ATOM gatomFirstPinned;
extern ATOM gatomLastPinned;

extern ATOM gatomMessage;
extern ATOM gaOleMainThreadWndClass;
extern ATOM gaFlashWState;
extern ATOM atomCheckpointProp;
extern ATOM atomDDETrack;
extern ATOM atomQOS;
extern ATOM atomDDEImp;
extern ATOM atomWndObj;
extern ATOM atomImeLevel;

#ifdef POOL_INSTR
extern DWORD gdwAllocCrt;          // the index for the current allocation
#endif // POOL_INSTR

extern UINT guiOtherWindowCreated;
extern UINT guiOtherWindowDestroyed;
extern UINT guiActivateShellWindow;

extern ATOM atomUSER32;
extern ATOM atomLayer;

extern HANDLE gpidLogon;
extern PEPROCESS gpepInit;

extern PEPROCESS gpepCSRSS;

extern int giLowPowerTimeOutMs;
extern int giPowerOffTimeOutMs;

extern PSERVERINFO gpsi;
extern SHAREDINFO gSharedInfo;

extern DWORD giheLast;           /* index to last allocated entry */

extern DWORD gdwDesktopSectionSize;
extern DWORD gdwNOIOSectionSize;

#if defined (USER_PERFORMANCE)
extern CSSTATISTICS gCSStatistics;
#endif // USER_PERFORMANCE

extern SECURITY_QUALITY_OF_SERVICE gqosDefault;  // system default DDE qos.

extern CONST COLORREF gargbInitial[];

extern POWERSTATE gPowerState;

extern WCHAR gszMIN[15];
extern WCHAR gszMAX[15];
extern WCHAR gszRESUP[20];
extern WCHAR gszRESDOWN[20];
extern WCHAR gszHELP[20];
/* Commented out due to TandyT ...
 * extern WCHAR gszSMENU[30];
 */
extern WCHAR gszSCLOSE[15];
extern WCHAR gszCAPTIONTOOLTIP[CAPTIONTOOLTIPLEN];

/*
 * Pointer to shared SERVERINFO data.
 */
extern HANDLE ghSectionShared;
extern PVOID  gpvSharedBase;
extern PWIN32HEAP gpvSharedAlloc;

extern BOOL gbVideoInitialized;

extern BOOL gbNoMorePowerCallouts;

extern BOOL gbCleanedUpResources;

extern WSINFO gWinStationInfo;

extern ULONG    gSessionId;
extern BOOL     gbRemoteSession;
extern BOOL    gfEnableWindowsKey;

extern PDESKTOP gspdeskDisconnect;

extern HANDLE  ghRemoteVideoChannel;

extern HANDLE  ghRemoteMouseChannel;
extern HANDLE  ghRemoteKeyboardChannel;
extern HANDLE  ghRemoteBeepChannel;
extern PVOID   gpRemoteBeepDevice;
extern HANDLE  ghRemoteThinwireChannel;



extern BOOL   gfSwitchInProgress;
extern USHORT gProtocolType;
extern USHORT gConsoleShadowProtocolType;

extern BOOL   gfRemotingConsole;

extern HANDLE ghConsoleShadowVideoChannel;
extern HANDLE ghConsoleShadowMouseChannel;
extern HANDLE ghConsoleShadowBeepChannel;
extern PVOID  gpConsoleShadowBeepDevice;
extern HANDLE ghConsoleShadowKeyboardChannel;
extern HANDLE ghConsoleShadowThinwireChannel;
extern KHANDLE gConsoleShadowhDev;
extern PKEVENT gpConsoleShadowDisplayChangeEvent;

extern CLIENTKEYBOARDTYPE gRemoteClientKeyboardType;

extern BOOL gfSessionSwitchBlock;

extern BOOL gbExitInProgress;
extern BOOL gbCleanupInitiated;

extern BOOL gbStopReadInput;

extern PDESKTOP gspdeskShouldBeForeground;
extern BOOL     gbDesktopLocked;


extern BOOL  gbFreezeScreenUpdates;
extern ULONG gSetLedReceived;
extern BOOL  gbClientDoubleClickSupport;

extern BOOL gbDisconnectHardErrorAttach;

extern PKEVENT gpevtDesktopDestroyed;

extern PKEVENT gpevtVideoportCallout;

extern HDESK   ghDisconnectDesk;
extern HWINSTA ghDisconnectWinSta;

extern ULONG gnShadowers;
extern BOOL  gbConnected;

extern WCHAR gstrBaseWinStationName[];

extern PFILE_OBJECT gVideoFileObject;
extern PFILE_OBJECT gThinwireFileObject;


extern PFILE_OBJECT gConsoleShadowVideoFileObject;
extern PFILE_OBJECT gConsoleShadowThinwireFileObject;

extern PVOID gpThinWireCache;
extern PVOID gpConsoleShadowThinWireCache;


extern WMSNAPSHOT gwms;
extern BOOL gbSnapShotWindowsAndMonitors;

extern BOOL gbPnPWaiting;
extern PKEVENT gpEventPnPWainting;

extern PVOID ghKbdTblBase;
extern ULONG guKbdTblSize;

extern DWORD gdwHydraHint;

extern DWORD gdwCanPaintDesktop;

extern WCHAR gszUserName[40];
extern WCHAR gszDomainName[40];
extern WCHAR gszComputerName[40];

extern HANDLE ghCanActivateForegroundPIDs[];

extern DWORD gdwGuiThreads;

extern DWORD gSessionPoolMask; // Allocate out of session pool
/*
 * Debug only globals
 */
#if DBG
extern DWORD gdwCritSecUseCount;
extern DWORD gdwInAtomicOperation;
extern LPCSTR gapszFNID[];
extern LPCSTR gapszMessage[];
extern int gnDeferredWinEvents;

extern BOOL gbTraceHydraApi;
extern BOOL gbTraceDesktop;

/*
 * The total number of thread locks for all threads in the system at a certain time
 * should be less than MAX_THREAD_LOCKS*MAX_THREAD_LOCKS_ARRAYS
 */
#define MAX_THREAD_LOCKS        1000
#define MAX_THREAD_LOCKS_ARRAYS 100

extern PTL gpaThreadLocksArrays[MAX_THREAD_LOCKS_ARRAYS];
extern PTL gFreeTLList;
extern int gcThreadLocksArraysAllocated;

#endif  // DBG
extern EX_RUNDOWN_REF gWinstaRunRef;

/*
 * Reserved bit in the Drive Letter bit mask of a
 * WM_DEVICECHANGE message for the following wParam
 * (DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEARRIVAL)
 * If this bit is set, then this message describes a change with
 * global drive letters and we should check if the drive letters
 * already exist in the receiver's LUID DosDevices.
 * If drive letter exists in the user's LUID DosDevices, then
 * un-set this drive letter in the msg's bitmask.
 */
#define DBV_FILTER_MSG 0x40000000

extern ULONG gLUIDDeviceMapsEnabled;

#ifdef SUBPIXEL_MOUSE
extern FIXPOINT gDefxTxf[], gDefyTxf[];
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\globals.c ===
/****************************** Module Header ******************************\
* Module Name: globals.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables.  One must be
* executing on the server's context to manipulate any of these variables.
* Serializing access to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef AUTORUN_CURSOR
/*
 * Timer for autorun cursor.
 */
UINT_PTR gtmridAutorunCursor;
#endif

/*
 * Per user data is global in non-Hydra.
 */
DWORD gdwPUDFlags = ACCF_FIRSTTICK | PUDF_BEEP | PUDF_ANIMATE;

/*
 * Wallpaper Data.
 */
HBITMAP  ghbmWallpaper;
HPALETTE ghpalWallpaper;
SIZERECT gsrcWallpaper;
UINT     gwWPStyle;
HBITMAP  ghbmDesktop;
LPWSTR   gpszWall;

/*
 * Policy Settings.
 */
DWORD gdwPolicyFlags = POLICY_ALL;

/*
 * SafeBoot
 */
#if DBG
DWORD gDrawVersionAlways = TRUE;
#else
DWORD gDrawVersionAlways;
#endif

/*
 * TS override flag for painting desktop version.
 */
DWORD gdwTSExcludeDesktopVersion;

/*
 * External drivers
 */
BOOL gfUnsignedDrivers;

/*
 * Full-Drag.
 */
HRGN ghrgnUpdateSave;
int  gnUpdateSave;

PWND gspwndAltTab;

PWND gspwndShouldBeForeground;

/*
 * full screen variables
 */
PWND  gspwndScreenCapture;
PWND  gspwndInternalCapture;
PWND  gspwndFullScreen;

/*
 * pre-cached monitor for mode changes
 */
PMONITOR gpMonitorCached;

/*
 * logon notify window
 */
PWND  gspwndLogonNotify;

PKEVENT gpEventDiconnectDesktop;

/*
 * handle for WinSta0_DesktopSwitch event
 *
 * Note: originally intended for Hydra support,
 * now some other modules rely on this event.
 * Consider this as exposed.
 */
HANDLE  ghEventSwitchDesktop;
PKEVENT gpEventSwitchDesktop;

/*
 * Thread Info Variables
 */
PTHREADINFO     gptiTasklist;
PTHREADINFO     gptiShutdownNotify;
PTHREADINFO     gptiLockUpdate;
PTHREADINFO     gptiForeground;
PTHREADINFO     gptiBlockInput;
PWOWTHREADINFO  gpwtiFirst;
PWOWPROCESSINFO gpwpiFirstWow;

/*
 * Queue Variables
 */
PQ gpqForeground;
PQ gpqForegroundPrev;
PQ gpqCursor;

/*
 * Accessibility globals
 */
FILTERKEYS    gFilterKeys;
STICKYKEYS    gStickyKeys;
MOUSEKEYS     gMouseKeys;
ACCESSTIMEOUT gAccessTimeOut;
TOGGLEKEYS    gToggleKeys;
SOUNDSENTRY   gSoundSentry;

HIGHCONTRAST  gHighContrast;
WCHAR         gHighContrastDefaultScheme[MAX_SCHEME_NAME_SIZE];

/*
 * Fade animation globals
 */
FADE gfade;

/*
 * FilterKeys Support
 */
UINT_PTR  gtmridFKActivation;
UINT_PTR  gtmridFKResponse;
UINT_PTR  gtmridFKAcceptanceDelay;
int   gFilterKeysState;

KE    gFKKeyEvent;
CONST PKE gpFKKeyEvent = &gFKKeyEvent;
ULONG gFKExtraInformation;
int   gFKNextProcIndex;

/*
 * ToggleKeys Support
 */
UINT_PTR  gtmridToggleKeys;
ULONG gTKExtraInformation;
int   gTKNextProcIndex;

/*
 * TimeOut Support
 */
UINT_PTR  gtmridAccessTimeOut;

/*
 * MouseKeys Support
 */
WORD  gwMKButtonState;
WORD  gwMKCurrentButton = MOUSE_BUTTON_LEFT;
UINT_PTR  gtmridMKMoveCursor;
LONG  gMKDeltaX;
LONG  gMKDeltaY;
UINT  giMouseMoveTable;

HWND ghwndSoundSentry;
UINT_PTR  gtmridSoundSentry;

MOUSECURSOR gMouseCursor;

/*
 * Multilingual keyboard layout support.
 */
PKL      gspklBaseLayout;
HKL      gLCIDSentToShell;
DWORD    gSystemFS;    // System font's font signature (single bit)

KBDLANGTOGGLE gLangToggle[] = {
    VK_MENU,   0,               KLT_ALT,
    0,         SCANCODE_LSHIFT, KLT_LEFTSHIFT,
    0,         SCANCODE_RSHIFT, KLT_RIGHTSHIFT
};
int           gLangToggleKeyState;

/*
 * Multiple flag for hex Alt+NumPad mode.
 */
BYTE gfInNumpadHexInput;
BOOL gfEnableHexNumpad;

/*
 * Grave accent keyboard switch for thai locales
 */
BOOL gbGraveKeyToggle;

/*
 * Points to currently active Keyboard Layer tables
 */
PKBDTABLES    gpKbdTbl = &KbdTablesFallback;
PKL           gpKL;
BYTE          gSystemCPCharSet = ANSI_CHARSET;  // System's input locale charset
PKBDNLSTABLES gpKbdNlsTbl;
DWORD         gdwKeyboardAttributes;        // see KLLF_SHIFTLOCK etc.

DWORD     gtimeStartCursorHide;
RECT      grcCursorClip;
ULONG_PTR gdwMouseMoveExtraInfo;
DWORD     gdwMouseMoveTimeStamp;
LASTINPUT glinp;
POINT     gptCursorAsync;
PPROCESSINFO gppiInputProvider;
PPROCESSINFO gppiLockSFW;
UINT guSFWLockCount;
#if DBG
BOOL gfDebugForegroundIgnoreDebugPort;
#endif

/*
 * Cursor related Variables
 */
PCURSOR gpcurLogCurrent;
PCURSOR gpcurPhysCurrent;
RECT    grcVDMCursorBounds;
DWORD   gdwLastAniTick;
UINT_PTR gidCursorTimer;

PWND gspwndActivate;
PWND gspwndLockUpdate;
PWND gspwndMouseOwner;
HWND ghwndSwitch;

UINT gwMouseOwnerButton;
BOOL gbMouseButtonsRecentlySwapped;

UINT gdtMNDropDown;

int  gcountPWO;          /* count of pwo WNDOBJs in gdi */
int  gnKeyboardSpeed = 15;
int  giScreenSaveTimeOutMs;
BOOL gbBlockSendInputResets;

PBWL gpbwlList;

UINT gdtDblClk = 500;

/*
 * TrackMouseEvent related globals
 */
UINT gcxMouseHover;
UINT gcyMouseHover;
UINT gdtMouseHover;

CAPTIONCACHE gcachedCaptions[CCACHEDCAPTIONS];

/*
 * list of thread attachments
 */
PATTACHINFO  gpai;

PDESKTOP     gpdeskRecalcQueueAttach;

PWND         gspwndCursor;
PPROCESSINFO gppiStarting;
PPROCESSINFO gppiList;
PPROCESSINFO gppiWantForegroundPriority;
PPROCESSINFO gppiForegroundOld;


PW32JOB      gpJobsList;

UINT_PTR  gtmridAniCursor;

int           gcHotKey;
PHOTKEYSTRUCT gpHotKeyList;
int           gcHotKeyAlloc;

/*
 * IME HotKeys
 */
PIMEHOTKEYOBJ gpImeHotKeyListHeader;

int gMouseSpeed;
int gMouseThresh1;
int gMouseThresh2;
int gMouseSensitivityFactor = 256;
int gMouseSensitivity;
int gMouseTrails;
int gMouseTrailsToHide;
UINT_PTR  gtmridMouseTrails;

UINT   guDdeSendTimeout;


INT gnFastAltTabRows;      /* Rows of icons in quick switch window     */
INT gnFastAltTabColumns;   /* Columns of icons in quick switch window  */

DWORD gdwThreadEndSession; /* Shutting down system?                    */

HBRUSH ghbrHungApp;        /* Brush used to redraw hung app windows.   */

HBITMAP ghbmBits;
HBITMAP ghbmCaption;

int     gcxCaptionFontChar;
int     gcyCaptionFontChar;
HFONT   ghSmCaptionFont;
int     gcxSmCaptionFontChar;
int     gcySmCaptionFontChar;

HFONT   ghMenuFont;
HFONT   ghMenuFontDef;
int     gcxMenuFontChar;
int     gcyMenuFontChar;
int     gcxMenuFontOverhang;
int     gcyMenuFontExternLeading;
int     gcyMenuFontAscent;
int     gcyMenuScrollArrow;

#ifdef LAME_BUTTON
HFONT ghLameFont;
DWORD gdwLameFlags;
#endif

#if DBG
UINT guModalMenuStateCount;
#endif

/*
 * From mnstate.c
 */
POPUPMENU gpopupMenu;
MENUSTATE gMenuState;

HFONT ghStatusFont;
HFONT ghIconFont;

/*
 * Cached SMWP structure
 */
SMWP gSMWP;

/*
 * SystemParametersInfo bit mask and DWORD array.
 *
 * Bit mask. Manipulate these values using the TestUP, SetUP and ClearUP macros.
 * Set the default value here by ORing the corresponding UPBOOLMask value.
 * Write the actual value here to make it easier to read the value stored
 *  in the registry. OR the value even if defaulting to 0; just make sure to
 *  preceed with a not (!) operator.
 * Note that this is an array of DWORDs, so if your value happens to start a new
 *  DWORD, make sure to add a comma at the end of previous UPMask line.
 *
 * This initialization is made just for documentation and it doesn't cost anything.
 * The default values are actually read from the registry.
 */
DWORD gpdwCPUserPreferencesMask [SPI_BOOLMASKDWORDSIZE] = {
    !0x00000001     /* !ACTIVEWINDOWTRACKING */
  |  0x00000002     /*  MENUANIMATION */
  |  0x00000004     /*  COMBOBOXANIMATION */
  |  0x00000008     /*  LISTBOXSMOOTHSCROLLING */
  |  0x00000010     /*  GRADIENTCAPTIONS */
  | !0x00000020     /*  KEYBOARDCUES = MENUUNDERLINES */
  | !0x00000040     /* !ACTIVEWNDTRKZORDER */
  |  0x00000080     /*  HOTTRACKING */
  |  0x00000200     /*  MENUFADE */
  |  0x00000400     /*  SELECTIONFADE */
  |  0x00000800     /*  TOOLTIPANIMATION */
  |  0x00001000     /*  TOOLTIPFADE */
  |  0x00002000     /*  CURSORSHADOW */
  | !0x00008000     /*  CLICKLOCK */
  |  0x00010000     /*  MOUSEVANISH */
  |  0x00020000     /*  FLATMENU */
  | !0x00040000     /*  DROPSHADOW */
  |  0x80000000     /*  UIEFFECTS */
};


/*
 * SPI_GET/SETUSERPREFENCES.
 * Each SPI_UP_* define in winuser.w must have a corresponding entry here.
 */
PROFILEVALUEINFO gpviCPUserPreferences[1 + SPI_DWORDRANGECOUNT] = {
    /*Default       Registry key name       Registry value name */
    {0,             PMAP_DESKTOP,           (LPCWSTR)STR_USERPREFERENCESMASK},
    {200000,        PMAP_DESKTOP,           (LPCWSTR)STR_FOREGROUNDLOCKTIMEOUT},
    {0,             PMAP_DESKTOP,           (LPCWSTR)STR_ACTIVEWNDTRKTIMEOUT},
    {3,             PMAP_DESKTOP,           (LPCWSTR)STR_FOREGROUNDFLASHCOUNT},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_CARETWIDTH},
    {1200,          PMAP_DESKTOP,           (LPCWSTR)STR_CLICKLOCKTIME},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FONTSMOOTHINGTYPE},
    {0,             PMAP_DESKTOP,           (LPCWSTR)STR_FONTSMOOTHINGGAMMA}, /* 0 mean use the default from the display driver */
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FOCUSBORDERWIDTH},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FOCUSBORDERHEIGHT},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FONTSMOOTHINGORIENTATION},
};


/*
 * Sys expunge control data.
 */
DWORD gdwSysExpungeMask;    // hmods to be expunged
DWORD gcSysExpunge;         // current count of expunges performed

/*
 * System classes
 */
PCLS gpclsList;

PCURSOR gpcurFirst;

SYSCFGICO gasyscur[COCR_CONFIGURABLE] = {
    {OCR_NORMAL,      STR_CURSOR_ARROW      , NULL }, // OCR_ARROW_DEFAULT
    {OCR_IBEAM,       STR_CURSOR_IBEAM      , NULL }, // OCR_IBEAM_DEFAULT
    {OCR_WAIT,        STR_CURSOR_WAIT       , NULL }, // OCR_WAIT_DEFAULT
    {OCR_CROSS,       STR_CURSOR_CROSSHAIR  , NULL }, // OCR_CROSS_DEFAULT
    {OCR_UP,          STR_CURSOR_UPARROW    , NULL }, // OCR_UPARROW_DEFAULT
    {OCR_SIZENWSE,    STR_CURSOR_SIZENWSE   , NULL }, // OCR_SIZENWSE_DEFAULT
    {OCR_SIZENESW,    STR_CURSOR_SIZENESW   , NULL }, // OCR_SIZENESW_DEFAULT
    {OCR_SIZEWE,      STR_CURSOR_SIZEWE     , NULL }, // OCR_SIZEWE_DEFAULT
    {OCR_SIZENS,      STR_CURSOR_SIZENS     , NULL }, // OCR_SIZENS_DEFAULT
    {OCR_SIZEALL,     STR_CURSOR_SIZEALL    , NULL }, // OCR_SIZEALL_DEFAULT
    {OCR_NO,          STR_CURSOR_NO         , NULL }, // OCR_NO_DEFAULT
    {OCR_APPSTARTING, STR_CURSOR_APPSTARTING, NULL }, // OCR_APPSTARTING_DEFAULT
    {OCR_HELP,        STR_CURSOR_HELP       , NULL }, // OCR_HELP_DEFAULT
    {OCR_NWPEN,       STR_CURSOR_NWPEN      , NULL }, // OCR_NWPEN_DEFAULT
    {OCR_HAND,        STR_CURSOR_HAND       , NULL }, // OCR_HAND_DEFAULT
    {OCR_ICON,        STR_CURSOR_ICON       , NULL }, // OCR_ICON_DEFAULT
    {OCR_AUTORUN,     STR_CURSOR_AUTORUN    , NULL }, // OCR_AUTORUN_DEFAULT
};

SYSCFGICO gasysico[COIC_CONFIGURABLE] = {
    {OIC_SAMPLE,      STR_ICON_APPLICATION , NULL }, // OIC_APPLICATION_DEFAULT
    {OIC_WARNING,     STR_ICON_HAND        , NULL }, // OIC_WARNING_DEFAULT
    {OIC_QUES,        STR_ICON_QUESTION    , NULL }, // OIC_QUESTION_DEFAULT
    {OIC_ERROR,       STR_ICON_EXCLAMATION , NULL }, // OIC_ERROR_DEFAULT
    {OIC_INFORMATION, STR_ICON_ASTERISK    , NULL }, // OIC_INFORMATION_DEFAULT
    {OIC_WINLOGO,     STR_ICON_WINLOGO     , NULL }, // OIC_WINLOGO_DEFAULT
};

/*
 * Screen Saver Info
 */
PPROCESSINFO gppiScreenSaver;
POINT        gptSSCursor;

/*
 * Orphaned fullscreen mode changes that DDraw used to cleanup.
 */
PPROCESSINFO gppiFullscreen;

/*
 * accessibility byte-size data
 */
BYTE gLastVkDown;
BYTE gBounceVk;
BYTE gPhysModifierState;
BYTE gCurrentModifierBit;
BYTE gPrevModifierState;
BYTE gLatchBits;
BYTE gLockBits;
BYTE gTKScanCode;
BYTE gMKPreviousVk;
BYTE gbMKMouseMode;

PSCANCODEMAP gpScancodeMap;

BYTE gStickyKeysLeftShiftCount;  // # of consecutive left shift key presses.
BYTE gStickyKeysRightShiftCount; // # of consecutive right shift key presses.


/*
 * Some terminal data is global in non-Hydra.
 */
DWORD               gdwGTERMFlags;   // GTERMF_ flags
PTHREADINFO         gptiRit;
PDESKTOP            grpdeskRitInput;
PKEVENT             gpkeMouseData;

/*
 * Video Information
 */
BYTE                gbFullScreen = GDIFULLSCREEN;
PDISPLAYINFO        gpDispInfo;
BOOL                gbMDEVDisabled;

/*
 * Count of available cacheDC's. This is used in determining a threshold
 * count of DCX_CACHE types available.
 */
int gnDCECount;

int gnVisibleRedirectedCount;

/*
 * Hung redraw list
 */
PVWPL   gpvwplHungRedraw;

/*
 * SetWindowPos() related globals
 */
HRGN    ghrgnInvalidSum;
HRGN    ghrgnVisNew;
HRGN    ghrgnSWP1;
HRGN    ghrgnValid;
HRGN    ghrgnValidSum;
HRGN    ghrgnInvalid;

HRGN    ghrgnInv0;               // Temp used by InternalInvalidate()
HRGN    ghrgnInv1;               // Temp used by InternalInvalidate()
HRGN    ghrgnInv2;               // Temp used by InternalInvalidate()

HDC     ghdcMem;
HDC     ghdcMem2;

/*
 * DC Cache related globals
 */
HRGN    ghrgnGDC;                // Temp used by GetCacheDC et al

/*
 * SPB related globals
 */
HRGN    ghrgnSCR;                // Temp used by SpbCheckRect()
HRGN    ghrgnSPB1;
HRGN    ghrgnSPB2;

/*
 * ScrollWindow/ScrollDC related globals
 */
HRGN    ghrgnSW;              // Temps used by ScrollDC/ScrollWindow
HRGN    ghrgnScrl1;
HRGN    ghrgnScrl2;
HRGN    ghrgnScrlVis;
HRGN    ghrgnScrlSrc;
HRGN    ghrgnScrlDst;
HRGN    ghrgnScrlValid;

/*
 * General Device and Driver information
 */
PDEVICEINFO gpDeviceInfoList;
PERESOURCE  gpresDeviceInfoList;
#if DBG
DWORD gdwDeviceInfoListCritSecUseCount;   // bumped for every enter and leave
DWORD gdwInAtomicDeviceInfoListOperation; // inc/dec for BEGIN/ENDATOMICDEVICEINFOLISTCHECK
#endif
PDRIVER_OBJECT gpWin32kDriverObject;
DWORD gnRetryReadInput;

/*
 * Mouse Information
 */
MOUSEEVENT  gMouseEventQueue[NELEM_BUTTONQUEUE];
DWORD       gdwMouseQueueHead;
DWORD       gdwMouseEvents;
PERESOURCE  gpresMouseEventQueue;
int         gnMice;

#ifdef GENERIC_INPUT
/*
 * USB based Human Input Device (HID) Information
 */
PKEVENT gpkeHidChange;
HID_REQUEST_TABLE gHidRequestTable;

/*
 * Number of the HID device currently attached to the system
 */
int gnHid;

/*
 * Number of the processes that are HID aware
 * N.b. this may not include the process only interested in
 * raw input of the legacy devices (kbd/mouse)
 */
int gnHidProcess;

#endif

/*
 * Keyboard Information
 */
KEYBOARD_ATTRIBUTES             gKeyboardInfo = {
               // Initial default settings:
    {4, 0},    // Keyboard Identifier (Type, Subtype)
    1,         // KeyboardMode (Scancode Set 1)
    12,        // NumberOfFunction keys
    3,         // NumberOfIndicators (CapsLock, NumLock ScrollLock)
    104,       // NumberOfKeysTotal
    0,         // InputDataQueueLength
    {0, 0, 0}, // KeyRepeatMinimum (UnitId, Rate, Delay)
    {0, 0, 0}, // KeyRepeatMaximum (UnitId, Rate, Delay)
};
CONST KEYBOARD_ATTRIBUTES             gKeyboardDefaultInfo = {
               // Initial default settings:
    {4, 0},    // Keyboard Identifier (Type, Subtype)
    1,         // KeyboardMode (Scancode Set 1)
    12,        // NumberOfFunction keys
    3,         // NumberOfIndicators (CapsLock, NumLock ScrollLock)
    104,       // NumberOfKeysTotal
    0,         // InputDataQueueLength
    {0, 2, 250},    // KeyRepeatMinimum (UnitId, Rate, Delay)
    {0, 30, 1000},  // KeyRepeatMaximum (UnitId, Rate, Delay)
};

KEYBOARD_INDICATOR_PARAMETERS   gklp;
KEYBOARD_INDICATOR_PARAMETERS   gklpBootTime;
KEYBOARD_TYPEMATIC_PARAMETERS   gktp;
int                             gnKeyboards;

/*
 * This is the IO Status block used for IOCTL_KEYBOARD_ICA_SCANMAP,
 * IOCTL_KEYBOARD_QUERY_ATTRIBUTES and IOCTL_KEYBOARD_SET_INDICATORS
 */
IO_STATUS_BLOCK giosbKbdControl;

/*
 * IME status for keyboard device
 */
KEYBOARD_IME_STATUS gKbdImeStatus;

/*
 * Async key state tables. gafAsyncKeyState holds the down bit and toggle
 * bit, gafAsyncKeyStateRecentDown hold the bits indicates a key has gone
 * down since the last read.
 */
BYTE gafAsyncKeyState[CBKEYSTATE];
BYTE gafAsyncKeyStateRecentDown[CBKEYSTATERECENTDOWN];

/*
 * Raw Key state: this is the low-level async keyboard state.
 * (assuming Scancodes are correctly translated to Virtual Keys). It is used
 * for modifying and processing key events as they are received in ntinput.c
 * The Virtual Keys recorded here are obtained directly from the Virtual
 * Scancode via the awVSCtoVK[] table: no shift-state, numlock or other
 * conversions are applied.
 * This IS affected by injected keystrokes (SendInput, keybd_event) so that
 * on-screen-keyboards and other accessibility components work just like the
 * real keyboard: with the exception of the SAS (Ctrl-Alt-Del), which checks
 * real physically pressed modifier keys (gfsSASModifiersDown).
 * Left & right SHIFT, CTRL and ALT keys are distinct. (VK_RSHIFT etc.)
 * See also: SetRawKeyDown() etc.
 */
BYTE gafRawKeyState[CBKEYSTATE];
BOOLEAN gfKanaToggle;

DWORD               gdwUpdateKeyboard;
HARDERRORHANDLER    gHardErrorHandler;

/*
 * WinLogon specific information:
 * Note: SAS modifiers are a combination of MOD_SHIFT, MOD_CONTROL, MOD_ALT
 * not a combination of KBDSHIFT, KBDCTRL, KBDALT (different values!)
 */
UINT  gfsSASModifiers;     // SAS modifiers
UINT  gfsSASModifiersDown; // SAS modifiers really physically down
UINT  gvkSAS;              // The Secure Attention Sequence (SAS) key.

/*
 * IME status for shell and keyboard driver notification
 */
DWORD gdwIMEOpenStatus = 0xffffffff;
DWORD gdwIMEConversionStatus = 0xffffffff;
HIMC  gHimcFocus = (HIMC)(INT_PTR)(INT)0xffffffff;
BOOL  gfIMEShowStatus;

#ifdef MOUSE_IP

/*
 * Sonar
 */
int giSonarRadius = -1;
BYTE gbLastVkForSonar;
BYTE gbVkForSonarKick = VK_CONTROL;
POINT gptSonarCenter;

#endif

/*
 * Clicklock
 */
BOOL  gfStartClickLock;
DWORD gdwStartClickLockTick;


/*
 * The global array used by GetMouseMovePointsEx
 */
MOUSEMOVEPOINT gaptMouse[MAX_MOUSEPOINTS];

/*
 * Index in the gaptMouse array where the next mouse point will
 * be written. gptInd goes circular in the gaptMouse array.
 * It is initialized to 1 so the first point is (0, 0)
 */
UINT gptInd = 1;

/*
 * We get this warning if we don't explicitly initalize gZero:
 *
 * C4132: 'gZero' : const object should be initialized
 *
 * But we can't explicitly initialize it since it is a union. So
 * we turn the warning off.
 */
#pragma warning(disable:4132)
CONST ALWAYSZERO gZero;
#pragma warning(default:4132)

PSMS gpsmsList;

TERMINAL gTermIO;
TERMINAL gTermNOIO;

PWINDOWSTATION grpWinStaList;

/*
 * the logon desktop
 */
PDESKTOP grpdeskLogon;

HANDLE CsrApiPort;
CONST LUID luidSystem = SYSTEM_LUID;

PKBDFILE gpkfList;

PTHREADINFO gptiCurrent;
PTIMER gptmrFirst;
PKTIMER gptmrMaster;
DWORD gcmsLastTimer;
BOOL gbMasterTimerSet;

/*
 * Time this session was created.
 */
ULONGLONG gSessionCreationTime;

BOOL gbDisableAlpha;

/*
 * This constant is the max USER handles allowed in a process. It is
 * meant to prevent runaway apps from eating the system. It is changed
 * via a registry setting -- PMAP_WINDOWSM/USERProcessHandleQuota.
 */
LONG gUserProcessHandleQuota;

/*
 * This global variable limits the maximum number of posted message
 * per thread. If the number of message posted to a thread exceeds
 * this value, PostMessage will fail.
 */
DWORD gUserPostMessageLimit;

/*
 * Active Accessibility - Window Events
 */
PEVENTHOOK gpWinEventHooks;    // list of installed hooks
PNOTIFY gpPendingNotifies;     // FILO of outstanding notifications
PNOTIFY gpLastPendingNotify;   // end of above list.
DWORD gdwDeferWinEvent;        // Defer notification is > 0

/*
 * This is the timeout value used for callbacks to low level hook procs.
 */
int gnllHooksTimeout;

/*
 * UserApiHook
 */
int gihmodUserApiHook = -1;
ULONG_PTR goffPfnInitUserApiHook;
PPROCESSINFO gppiUserApiHook;

/*
 * gpusMouseVKey
 */
extern CONST USHORT ausMouseVKey[];
PUSHORT gpusMouseVKey = (PUSHORT)ausMouseVKey;

USHORT  gNumLockVk   = VK_NUMLOCK;
USHORT  gOemScrollVk = VK_SCROLL;


CONST WCHAR szNull[2] = { TEXT('\0'), TEXT('\015') };

WCHAR szWindowStationDirectory[MAX_SESSION_PATH];

CONST WCHAR szOneChar[] = TEXT("0");
CONST WCHAR szY[]     = TEXT("Y");
CONST WCHAR szy[]     = TEXT("y");
CONST WCHAR szN[]     = TEXT("N");

HBRUSH ghbrWhite;
HBRUSH ghbrBlack;
HFONT ghFontSys;

HANDLE hModuleWin;        // win32k.sys hmodule
HANDLE hModClient;        // user32.dll hModule

#if DBG
LONG TraceInitialization;
#endif

DESKTOPINFO diStatic;

/*
 * DWORD incremented with each new desktop, so GDI can match display devices
 * with desktops appropriately. Since at boot time there is no desktop
 * structure, we cannot use the desktop itself for this purpose.
 */
ULONG gdwDesktopId = GW_DESKTOP_ID + 1;

PERESOURCE gpresUser;
PFAST_MUTEX gpHandleFlagsMutex;

PROC gpfnwp[ICLS_MAX];

#ifdef HUNGAPP_GHOSTING
PKEVENT gpEventScanGhosts;
ATOM gatomGhost;
#endif

ATOM gatomShadow;

ATOM gatomConsoleClass;
ATOM gatomFirstPinned;
ATOM gatomLastPinned;

ATOM gatomMessage;
ATOM gaOleMainThreadWndClass;
ATOM gaFlashWState;
ATOM atomCheckpointProp;
ATOM atomDDETrack;
ATOM atomQOS;
ATOM atomDDEImp;
ATOM atomWndObj;
ATOM atomImeLevel;

ATOM atomLayer;

#ifdef POOL_INSTR
DWORD gdwAllocCrt;          // the index for the current allocation
#endif // POOL_INSTR

UINT guiOtherWindowCreated;
UINT guiOtherWindowDestroyed;
UINT guiActivateShellWindow;

ATOM atomUSER32;

HANDLE gpidLogon;
PEPROCESS gpepCSRSS;
PEPROCESS gpepInit;

int giLowPowerTimeOutMs;
int giPowerOffTimeOutMs;

/*
 * Security info
 */

CONST GENERIC_MAPPING KeyMapping = {KEY_READ, KEY_WRITE, KEY_EXECUTE, KEY_ALL_ACCESS};
CONST GENERIC_MAPPING WinStaMapping = {
    WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ENUMERATE |
        WINSTA_READSCREEN | STANDARD_RIGHTS_READ,

    WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES |
        STANDARD_RIGHTS_WRITE,

    WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | STANDARD_RIGHTS_EXECUTE,

    WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ENUMERATE |
        WINSTA_READSCREEN | WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP |
        WINSTA_WRITEATTRIBUTES | WINSTA_ACCESSGLOBALATOMS |
        WINSTA_EXITWINDOWS | STANDARD_RIGHTS_REQUIRED
};

/*
 * Desktop generic mapping.
 */
CONST GENERIC_MAPPING DesktopMapping = {
    DESKTOP_READOBJECTS | DESKTOP_ENUMERATE |
#ifdef REDIRECTION
    DESKTOP_QUERY_INFORMATION |
#endif // REDIRECTION
    STANDARD_RIGHTS_READ,

    DESKTOP_WRITEOBJECTS | DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU |
        DESKTOP_HOOKCONTROL | DESKTOP_JOURNALRECORD |
        DESKTOP_JOURNALPLAYBACK |
#ifdef REDIRECTION
        DESKTOP_REDIRECT |
#endif // REDIRECTION
        STANDARD_RIGHTS_WRITE,

    DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_EXECUTE,

    DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_ENUMERATE |
        DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU | DESKTOP_HOOKCONTROL |
        DESKTOP_JOURNALRECORD | DESKTOP_JOURNALPLAYBACK |
#ifdef REDIRECTION
        DESKTOP_QUERY_INFORMATION | DESKTOP_REDIRECT |
#endif // REDIRECTION
        DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_REQUIRED
};



/*
 * Pointer to shared SERVERINFO data.
 */
PSERVERINFO gpsi;
SHAREDINFO gSharedInfo;

/*
 * Handle table globals.
 */
DWORD giheLast;             /* index to last allocated handle entry */

DWORD  gdwDesktopSectionSize;
DWORD  gdwNOIOSectionSize;

#if defined (USER_PERFORMANCE)
/*
 *  To turn on performance counters, you have to set the environment variable
 *  USER_PERFORMANCE when compiling win32k.sys
 */
CSSTATISTICS gCSStatistics;
#endif // USER_PERFORMANCE

SECURITY_QUALITY_OF_SERVICE gqosDefault = {
        sizeof(SECURITY_QUALITY_OF_SERVICE),
        SecurityImpersonation,
        SECURITY_STATIC_TRACKING,
        TRUE
    };

CONST COLORREF gargbInitial[COLOR_MAX] = {
    RGB(192, 192, 192),   // COLOR_SCROLLBAR
    RGB( 58, 110, 165),   // COLOR_BACKGROUND
    RGB(000, 000, 128),   // COLOR_ACTIVECAPTION
    RGB(128, 128, 128),   // COLOR_INACTIVECAPTION
    RGB(192, 192, 192),   // COLOR_MENU
    RGB(255, 255, 255),   // COLOR_WINDOW
    RGB(000, 000, 000),   // COLOR_WINDOWFRAME
    RGB(000, 000, 000),   // COLOR_MENUTEXT
    RGB(000, 000, 000),   // COLOR_WINDOWTEXT
    RGB(255, 255, 255),   // COLOR_CAPTIONTEXT
    RGB(192, 192, 192),   // COLOR_ACTIVEBORDER
    RGB(192, 192, 192),   // COLOR_INACTIVEBORDER
    RGB(128, 128, 128),   // COLOR_APPWORKSPACE
    RGB(000, 000, 128),   // COLOR_HIGHLIGHT
    RGB(255, 255, 255),   // COLOR_HIGHLIGHTTEXT
    RGB(192, 192, 192),   // COLOR_BTNFACE
    RGB(128, 128, 128),   // COLOR_BTNSHADOW
    RGB(128, 128, 128),   // COLOR_GRAYTEXT
    RGB(000, 000, 000),   // COLOR_BTNTEXT
    RGB(192, 192, 192),   // COLOR_INACTIVECAPTIONTEXT
    RGB(255, 255, 255),   // COLOR_BTNHIGHLIGHT
    RGB(000, 000, 000),   // COLOR_3DDKSHADOW
    RGB(223, 223, 223),   // COLOR_3DLIGHT
    RGB(000, 000, 000),   // COLOR_INFOTEXT
    RGB(255, 255, 225),   // COLOR_INFOBK
    RGB(180, 180, 180),   // COLOR_3DALTFACE /* unused */
    RGB(  0,   0, 255),   // COLOR_HOTLIGHT
    RGB( 16, 132, 208),   // COLOR_GRADIENTACTIVECAPTION
    RGB(181, 181, 181),   // COLOR_GRADIENTINACTIVECAPTION
    RGB(210, 210, 255),   // COLOR_MENUHILIGHT
    RGB(212, 208, 200)    // COLOR_MENUBAR
};

POWERSTATE gPowerState;


WCHAR gszMIN[15];
WCHAR gszMAX[15];
WCHAR gszRESUP[20];
WCHAR gszRESDOWN[20];
WCHAR gszHELP[20];
/* Commented out due to TandyT ...
 * WCHAR gszSMENU[30];
 */
WCHAR gszSCLOSE[15];
WCHAR gszCAPTIONTOOLTIP[CAPTIONTOOLTIPLEN];

/*
 * Pointer to shared SERVERINFO data.
 */

HANDLE ghSectionShared;
PVOID  gpvSharedBase;

PWIN32HEAP gpvSharedAlloc;

BOOL   gbVideoInitialized;

BOOL   gbNoMorePowerCallouts;

BOOL gbCleanedUpResources;

WSINFO gWinStationInfo;

ULONG  gSessionId;              // the session id. The fisrt session has the id 0
BOOL   gbRemoteSession;         // TRUE if win32k is for a remote session

PDESKTOP gspdeskDisconnect;

PDESKTOP gspdeskShouldBeForeground;
BOOL     gbDesktopLocked;

HANDLE ghRemoteVideoChannel;
HANDLE ghRemoteMouseChannel;
HANDLE ghRemoteBeepChannel;
PVOID  gpRemoteBeepDevice;
HANDLE ghRemoteKeyboardChannel;
HANDLE ghRemoteThinwireChannel;


USHORT gProtocolType; /* Starts as PROTOCOL_CONSOLE */
USHORT gConsoleShadowProtocolType;

BOOL   gfSwitchInProgress;
BOOL   gfRemotingConsole;

HANDLE ghConsoleShadowVideoChannel;
HANDLE ghConsoleShadowMouseChannel;
HANDLE ghConsoleShadowBeepChannel;
PVOID  gpConsoleShadowBeepDevice;
HANDLE ghConsoleShadowKeyboardChannel;
HANDLE ghConsoleShadowThinwireChannel;
KHANDLE gConsoleShadowhDev;
PKEVENT gpConsoleShadowDisplayChangeEvent;

CLIENTKEYBOARDTYPE gRemoteClientKeyboardType;


BOOL gfSessionSwitchBlock;

BOOL   gbExitInProgress;
BOOL   gbCleanupInitiated;

BOOL   gbStopReadInput;

BOOL   gbFreezeScreenUpdates;

ULONG  gSetLedReceived;
BOOL   gbClientDoubleClickSupport;
BOOL   gfEnableWindowsKey = TRUE;

BOOL   gbDisconnectHardErrorAttach;

PKEVENT gpevtDesktopDestroyed;
PKEVENT gpevtVideoportCallout;

HDESK ghDisconnectDesk;

HWINSTA ghDisconnectWinSta;

ULONG  gnShadowers;
BOOL   gbConnected;

WCHAR  gstrBaseWinStationName[WINSTATIONNAME_LENGTH];

PFILE_OBJECT gVideoFileObject;
PFILE_OBJECT gThinwireFileObject;


PFILE_OBJECT gConsoleShadowVideoFileObject;
PFILE_OBJECT gConsoleShadowThinwireFileObject;

PVOID gpThinWireCache;
PVOID gpConsoleShadowThinWireCache;

WMSNAPSHOT gwms;
BOOL gbSnapShotWindowsAndMonitors;

BOOL gbPnPWaiting;
PKEVENT gpEventPnPWainting;

PVOID ghKbdTblBase;
ULONG guKbdTblSize;

DWORD gdwHydraHint;

DWORD gdwCanPaintDesktop;

WCHAR gszUserName[40];
WCHAR gszDomainName[40];
WCHAR gszComputerName[40];

/*
 * Used for keeping track of stub parent processes that exit too early.
 */
HANDLE ghCanActivateForegroundPIDs[ACTIVATE_ARRAY_SIZE];


DWORD gdwGuiThreads;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
 * The section below has debug only globals
 *
 */
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
 * Debug only globals
 */
#if DBG

BOOL gbTraceHydraApi;
BOOL gbTraceDesktop;

DWORD gdwCritSecUseCount;                // bumped for every enter and leave
DWORD gdwInAtomicOperation;

/*
 * Debug Active Accessibility - ensure deferred win events are not lost.
 */
int gnDeferredWinEvents;

LPCSTR gapszFNID[] = {
    "FNID_SCROLLBAR",
    "FNID_ICONTITLE",
    "FNID_MENU",
    "FNID_DESKTOP",
    "FNID_DEFWINDOWPROC",
    "FNID_MESSAGEWND",
    "FNID_SWITCH",
    "FNID_MESSAGE",
    "FNID_BUTTON",
    "FNID_COMBOBOX",
    "FNID_COMBOLISTBOX",
    "FNID_DIALOG",
    "FNID_EDIT",
    "FNID_LISTBOX",
    "FNID_MDICLIENT",
    "FNID_STATIC",
    "FNID_IME",
    "FNID_HKINLPCWPEXSTRUCT",
    "FNID_HKINLPCWPRETEXSTRUCT",
    "FNID_DEFFRAMEPROC",
    "FNID_DEFMDICHILDPROC",
    "FNID_MB_DLGPROC",
    "FNID_MDIACTIVATEDLGPROC",
    "FNID_SENDMESSAGE",
    "FNID_SENDMESSAGEFF",
    "FNID_SENDMESSAGEEX",
    "FNID_CALLWINDOWPROC",
    "FNID_SENDMESSAGEBSM",
    "FNID_TOOLTIP",
    "FNID_GHOST",
    "FNID_SENDNOTIFYMESSAGE",
    "FNID_SENDMESSAGECALLBACK"
};

LPCSTR gapszMessage[] = {
    "WM_NULL",
    "WM_CREATE",
    "WM_DESTROY",
    "WM_MOVE",
    "WM_SIZEWAIT",
    "WM_SIZE",
    "WM_ACTIVATE",
    "WM_SETFOCUS",
    "WM_KILLFOCUS",
    "WM_SETVISIBLE",
    "WM_ENABLE",
    "WM_SETREDRAW",
    "WM_SETTEXT",
    "WM_GETTEXT",
    "WM_GETTEXTLENGTH",
    "WM_PAINT",

    "WM_CLOSE",
    "WM_QUERYENDSESSION",
    "WM_QUIT",
    "WM_QUERYOPEN",
    "WM_ERASEBKGND",
    "WM_SYSCOLORCHANGE",
    "WM_ENDSESSION",
    "WM_SYSTEMERROR",
    "WM_SHOWWINDOW",
    "WM_CTLCOLOR",
    "WM_WININICHANGE",
    "WM_DEVMODECHANGE",
    "WM_ACTIVATEAPP",
    "WM_FONTCHANGE",
    "WM_TIMECHANGE",
    "WM_CANCELMODE",

    "WM_SETCURSOR",
    "WM_MOUSEACTIVATE",
    "WM_CHILDACTIVATE",
    "WM_QUEUESYNC",
    "WM_GETMINMAXINFO",
    "WM_LOGOFF",
    "WM_PAINTICON",
    "WM_ICONERASEBKGND",
    "WM_NEXTDLGCTL",
    "WM_ALTTABACTIVE",
    "WM_SPOOLERSTATUS",
    "WM_DRAWITEM",
    "WM_MEASUREITEM",
    "WM_DELETEITEM",
    "WM_VKEYTOITEM",
    "WM_CHARTOITEM",

    "WM_SETFONT",
    "WM_GETFONT",
    "WM_SETHOTKEY",
    "WM_GETHOTKEY",
    "WM_FILESYSCHANGE",
    "WM_ISACTIVEICON",
    "WM_QUERYPARKICON",
    "WM_QUERYDRAGICON",
    "WM_WINHELP",
    "WM_COMPAREITEM",
    "WM_FULLSCREEN",
    "WM_CLIENTSHUTDOWN",
    "WM_DDEMLEVENT",
    "WM_GETOBJECT",
    "fnEmpty",
    "MM_CALCSCROLL",

    "WM_TESTING",
    "WM_COMPACTING",

    "WM_OTHERWINDOWCREATED",
    "WM_OTHERWINDOWDESTROYED",
    "WM_COMMNOTIFY",
    "WM_MEDIASTATUSCHANGE",
    "WM_WINDOWPOSCHANGING",
    "WM_WINDOWPOSCHANGED",

    "WM_POWER",
    "WM_COPYGLOBALDATA",
    "WM_COPYDATA",
    "WM_CANCELJOURNAL",
    "WM_LOGONNOTIFY",
    "WM_KEYF1",
    "WM_NOTIFY",
    "WM_ACCESS_WINDOW",

    "WM_INPUTLANGCHANGEREQUE",
    "WM_INPUTLANGCHANGE",
    "WM_TCARD",
    "WM_HELP",
    "WM_USERCHANGED",
    "WM_NOTIFYFORMAT",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_FINALDESTROY",
    "WM_MEASUREITEM_CLIENTDATA",
    "WM_TASKACTIVATED",
    "WM_TASKDEACTIVATED",
    "WM_TASKCREATED",
    "WM_TASKDESTROYED",
    "WM_TASKUICHANGED",
    "WM_TASKVISIBLE",
    "WM_TASKNOTVISIBLE",
    "WM_SETCURSORINFO",
    "fnEmpty",
    "WM_CONTEXTMENU",
    "WM_STYLECHANGING",
    "WM_STYLECHANGED",
    "WM_DISPLAYCHANGE",
    "WM_GETICON",

    "WM_SETICON",
    "WM_NCCREATE",
    "WM_NCDESTROY",
    "WM_NCCALCSIZE",

    "WM_NCHITTEST",
    "WM_NCPAINT",
    "WM_NCACTIVATE",
    "WM_GETDLGCODE",

    "WM_SYNCPAINT",
    "WM_SYNCTASK",

    "fnEmpty",
    "WM_KLUDGEMINRECT",
    "WM_LPKDRAWSWITCHWND",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_NCMOUSEMOVE",
    "WM_NCLBUTTONDOWN",
    "WM_NCLBUTTONUP",
    "WM_NCLBUTTONDBLCLK",
    "WM_NCRBUTTONDOWN",
    "WM_NCRBUTTONUP",
    "WM_NCRBUTTONDBLCLK",
    "WM_NCMBUTTONDOWN",
    "WM_NCMBUTTONUP",
    "WM_NCMBUTTONDBLCLK",

    "fnEmpty",
    "WM_NCXBUTTONDOWN",
    "WM_NCXBUTTONUP",
    "WM_NCXBUTTONDBLCLK",
    "WM_NCUAHDRAWCAPTION",
    "WM_NCUAHDRAWFRAME",

    "EM_GETSEL",
    "EM_SETSEL",
    "EM_GETRECT",
    "EM_SETRECT",
    "EM_SETRECTNP",
    "EM_SCROLL",
    "EM_LINESCROLL",
    "EM_SCROLLCARET",
    "EM_GETMODIFY",
    "EM_SETMODIFY",
    "EM_GETLINECOUNT",
    "EM_LINEINDEX",
    "EM_SETHANDLE",
    "EM_GETHANDLE",
    "EM_GETTHUMB",
    "fnEmpty",

    "fnEmpty",
    "EM_LINELENGTH",
    "EM_REPLACESEL",
    "EM_SETFONT",
    "EM_GETLINE",
    "EM_LIMITTEXT",
    "EM_CANUNDO",
    "EM_UNDO",
    "EM_FMTLINES",
    "EM_LINEFROMCHAR",
    "EM_SETWORDBREAK",
    "EM_SETTABSTOPS",
    "EM_SETPASSWORDCHAR",
    "EM_EMPTYUNDOBUFFER",
    "EM_GETFIRSTVISIBLELINE",
    "EM_SETREADONLY",

    "EM_SETWORDBREAKPROC",
    "EM_GETWORDBREAKPROC",
    "EM_GETPASSWORDCHAR",
    "EM_SETMARGINS",
    "EM_GETMARGINS",
    "EM_GETLIMITTEXT",
    "EM_POSFROMCHAR",
    "EM_CHARFROMPOS",
    "EM_SETIMESTATUS",

    "EM_GETIMESTATUS",
    "EM_MSGMAX",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "SBM_SETPOS",
    "SBM_GETPOS",
    "SBM_SETRANGE",
    "SBM_GETRANGE",
    "fnEmpty",
    "fnEmpty",
    "SBM_SETRANGEREDRAW",
    "fnEmpty",

    "fnEmpty",
    "SBM_SETSCROLLINFO",
    "SBM_GETSCROLLINFO",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "BM_GETCHECK",
    "BM_SETCHECK",
    "BM_GETSTATE",
    "BM_SETSTATE",
    "BM_SETSTYLE",
    "BM_CLICK",
    "BM_GETIMAGE",
    "BM_SETIMAGE",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_INPUT",

    "WM_KEYDOWN",
    "WM_KEYUP",
    "WM_CHAR",
    "WM_DEADCHAR",
    "WM_SYSKEYDOWN",
    "WM_SYSKEYUP",
    "WM_SYSCHAR",
    "WM_SYSDEADCHAR",
    "WM_YOMICHAR",
    "WM_UNICHAR",
    "WM_CONVERTREQUEST",
    "WM_CONVERTRESULT",
    "WM_INTERIM",
    "WM_IME_STARTCOMPOSITION",
    "WM_IME_ENDCOMPOSITION",
    "WM_IME_COMPOSITION",

    "WM_INITDIALOG",
    "WM_COMMAND",
    "WM_SYSCOMMAND",
    "WM_TIMER",
    "WM_HSCROLL",
    "WM_VSCROLL",
    "WM_INITMENU",
    "WM_INITMENUPOPUP",
    "WM_SYSTIMER",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_MENUSELECT",

    "WM_MENUCHAR",
    "WM_ENTERIDLE",

    "WM_MENURBUTTONUP",
    "WM_MENUDRAG",
    "WM_MENUGETOBJECT",
    "WM_UNINITMENUPOPUP",
    "WM_MENUCOMMAND",
    "WM_CHANGEUISTATE",

    "WM_UPDATEUISTATE",
    "WM_QUERYUISTATE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "WM_LBTRACKPOINT",
    "WM_CTLCOLORMSGBOX",
    "WM_CTLCOLOREDIT",
    "WM_CTLCOLORLISTBOX",
    "WM_CTLCOLORBTN",
    "WM_CTLCOLORDLG",
    "WM_CTLCOLORSCROLLBAR",
    "WM_CTLCOLORSTATIC",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "CB_GETEDITSEL",
    "CB_LIMITTEXT",
    "CB_SETEDITSEL",
    "CB_ADDSTRING",
    "CB_DELETESTRING",
    "CB_DIR",
    "CB_GETCOUNT",
    "CB_GETCURSEL",
    "CB_GETLBTEXT",
    "CB_GETLBTEXTLEN",
    "CB_INSERTSTRING",
    "CB_RESETCONTENT",
    "CB_FINDSTRING",
    "CB_SELECTSTRING",
    "CB_SETCURSEL",
    "CB_SHOWDROPDOWN",

    "CB_GETITEMDATA",
    "CB_SETITEMDATA",
    "CB_GETDROPPEDCONTROLRECT",
    "CB_SETITEMHEIGHT",
    "CB_GETITEMHEIGHT",
    "CB_SETEXTENDEDUI",
    "CB_GETEXTENDEDUI",
    "CB_GETDROPPEDSTATE",
    "CB_FINDSTRINGEXACT",
    "CB_SETLOCALE",
    "CB_GETLOCALE",
    "CB_GETTOPINDEX",

    "CB_SETTOPINDEX",
    "CB_GETHORIZONTALEXTENT",
    "CB_SETHORIZONTALEXTENT",
    "CB_GETDROPPEDWIDTH",

    "CB_SETDROPPEDWIDTH",
    "CB_INITSTORAGE",
    "fnEmpty",
    "CB_MULTIPLEADDSTRING",
    "CB_GETCOMBOBOXINFO",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "STM_SETICON",
    "STM_GETICON",
    "STM_SETIMAGE",
    "STM_GETIMAGE",
    "STM_MSGMAX",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "LB_ADDSTRING",
    "LB_INSERTSTRING",
    "LB_DELETESTRING",
    "LB_SELITEMRANGEEX",
    "LB_RESETCONTENT",
    "LB_SETSEL",
    "LB_SETCURSEL",
    "LB_GETSEL",
    "LB_GETCURSEL",
    "LB_GETTEXT",
    "LB_GETTEXTLEN",
    "LB_GETCOUNT",
    "LB_SELECTSTRING",
    "LB_DIR",
    "LB_GETTOPINDEX",
    "LB_FINDSTRING",

    "LB_GETSELCOUNT",
    "LB_GETSELITEMS",
    "LB_SETTABSTOPS",
    "LB_GETHORIZONTALEXTENT",
    "LB_SETHORIZONTALEXTENT",
    "LB_SETCOLUMNWIDTH",
    "LB_ADDFILE",
    "LB_SETTOPINDEX",
    "LB_SETITEMRECT",
    "LB_GETITEMDATA",
    "LB_SETITEMDATA",
    "LB_SELITEMRANGE",
    "LB_SETANCHORINDEX",
    "LB_GETANCHORINDEX",
    "LB_SETCARETINDEX",
    "LB_GETCARETINDEX",

    "LB_SETITEMHEIGHT",
    "LB_GETITEMHEIGHT",
    "LB_FINDSTRINGEXACT",
    "LBCB_CARETON",
    "LBCB_CARETOFF",
    "LB_SETLOCALE",
    "LB_GETLOCALE",
    "LB_SETCOUNT",

    "LB_INITSTORAGE",

    "LB_ITEMFROMPOINT",
    "LB_INSERTSTRINGUPPER",
    "LB_INSERTSTRINGLOWER",
    "LB_ADDSTRINGUPPER",
    "LB_ADDSTRINGLOWER",
    "LBCB_STARTTRACK",
    "LBCB_ENDTRACK",

    "fnEmpty",
    "LB_MULTIPLEADDSTRING",
    "LB_GETLISTBOXINFO",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "MN_SETHMENU",
    "MN_GETHMENU",
    "MN_SIZEWINDOW",
    "MN_OPENHIERARCHY",
    "MN_CLOSEHIERARCHY",
    "MN_SELECTITEM",
    "MN_CANCELMENUS",
    "MN_SELECTFIRSTVALIDITEM",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "MN_FINDMENUWINDOWFROMPOINT",
    "MN_SHOWPOPUPWINDOW",
    "MN_BUTTONDOWN",
    "MN_MOUSEMOVE",
    "MN_BUTTONUP",
    "MN_SETTIMERTOOPENHIERARCHY",

    "MN_DBLCLK",
    "MN_ACTIVEPOPUP",
    "MN_ENDMENU",
    "MN_DODRAGDROP",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_MOUSEMOVE",
    "WM_LBUTTONDOWN",
    "WM_LBUTTONUP",
    "WM_LBUTTONDBLCLK",
    "WM_RBUTTONDOWN",
    "WM_RBUTTONUP",
    "WM_RBUTTONDBLCLK",
    "WM_MBUTTONDOWN",
    "WM_MBUTTONUP",
    "WM_MBUTTONDBLCLK",
    "WM_MOUSEWHEEL",
    "WM_XBUTTONDOWN",
    "WM_XBUTTONUP",
    "WM_XBUTTONDBLCLK",
    "fnEmpty",
    "fnEmpty",

    "WM_PARENTNOTIFY",
    "WM_ENTERMENULOOP",
    "WM_EXITMENULOOP",
    "WM_NEXTMENU",
    "WM_SIZING",
    "WM_CAPTURECHANGED",
    "WM_MOVING",
    "fnEmpty",

    "WM_POWERBROADCAST",
    "WM_DEVICECHANGE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_MDICREATE",
    "WM_MDIDESTROY",
    "WM_MDIACTIVATE",
    "WM_MDIRESTORE",
    "WM_MDINEXT",
    "WM_MDIMAXIMIZE",
    "WM_MDITILE",
    "WM_MDICASCADE",
    "WM_MDIICONARRANGE",
    "WM_MDIGETACTIVE",
    "WM_DROPOBJECT",
    "WM_QUERYDROPOBJECT",
    "WM_BEGINDRAG",
    "WM_DRAGLOOP",
    "WM_DRAGSELECT",
    "WM_DRAGMOVE",

    //
    // 0x0230
    //
    "WM_MDISETMENU",
    "WM_ENTERSIZEMOVE",
    "WM_EXITSIZEMOVE",

    "WM_DROPFILES",
    "WM_MDIREFRESHMENU",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0240
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0250
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0260
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0270
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0280
    //
    "WM_KANJIFIRST",
    "WM_IME_SETCONTEXT",
    "WM_IME_NOTIFY",
    "WM_IME_CONTROL",
    "WM_IME_COMPOSITIONFULL",
    "WM_IME_SELECT",
    "WM_IME_CHAR",
    "WM_IME_SYSTEM",

    "WM_IME_REQUEST",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    //
    // 0x0290
    //
    "WM_IME_KEYDOWN",
    "WM_IME_KEYUP",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "WM_KANJILAST",

    //
    // 0x02a0
    //
    "WM_NCMOUSEHOVER",
    "WM_MOUSEHOVER",
    "WM_NCMOUSELEAVE",
    "WM_MOUSELEAVE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02b0
    //
    "fnEmpty",
    "WM_WTSSESSION_CHANGE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02c0
    //
    "WM_TABLET_FIRST",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02d0
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_TABLET_LAST",

    //
    // 0x02e0
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02f0
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0300
    //
    "WM_CUT",
    "WM_COPY",
    "WM_PASTE",
    "WM_CLEAR",
    "WM_UNDO",
    "WM_RENDERFORMAT",
    "WM_RENDERALLFORMATS",
    "WM_DESTROYCLIPBOARD",
    "WM_DRAWCLIPBOARD",
    "WM_PAINTCLIPBOARD",
    "WM_VSCROLLCLIPBOARD",
    "WM_SIZECLIPBOARD",
    "WM_ASKCBFORMATNAME",
    "WM_CHANGECBCHAIN",
    "WM_HSCROLLCLIPBOARD",
    "WM_QUERYNEWPALETTE",

    "WM_PALETTEISCHANGING",
    "WM_PALETTECHANGED",
    "WM_HOTKEY",

    "WM_SYSMENU",
    "WM_HOOKMSG",
    "WM_EXITPROCESS",
    "WM_WAKETHREAD",
    "WM_PRINT",

    "WM_PRINTCLIENT",
    "WM_APPCOMMAND",
    "WM_THEMECHANGED",
    "WM_UAHINIT",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_NOTIFYWOW",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_MM_RESERVED_FIRST",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "WM_MM_RESERVED_LAST",

    "WM_DDE_INITIATE",
    "WM_DDE_TERMINATE",
    "WM_DDE_ADVISE",
    "WM_DDE_UNADVISE",
    "WM_DDE_ACK",
    "WM_DDE_DATA",
    "WM_DDE_REQUEST",
    "WM_DDE_POKE",
    "WM_DDE_EXECUTE",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_CBT_RESERVED_FIRST",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "WM_CBT_RESERVED_LAST",
};


/*
 * This array will keep the TL stuctures alive. Free builds allocate these on the
 * stack and they get overwritten on function return. The link from the stack TL
 * to the static TL and vice-versa is maintained using TL.ptl. ptlStack->ptl ==
 * ptlStatic and ptlStatic->ptl == ptlStack. So ptl1->ptl->ptl == ptl1. When a
 * ptlStatic is freed, it is linked at the head of the gFreeTLlist and the
 * uTLCount has TL_FREED_PATTERN added in the HIWORD. When inspecting the static
 * TLs this pattern will help identify an unused element.
 */
PTL gpaThreadLocksArrays[MAX_THREAD_LOCKS_ARRAYS];
PTL gFreeTLList;
int gcThreadLocksArraysAllocated;

#endif
EX_RUNDOWN_REF gWinstaRunRef;

#ifdef SUBPIXEL_MOUSE
FIXPOINT gDefxTxf[SM_POINT_CNT], gDefyTxf[SM_POINT_CNT];
#endif

PVOID gpvWin32kImageBase;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\heap.c ===
/****************************** Module Header ******************************\
* Module Name: heap.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains kernel-mode heap management code.
*
* History:
* 03-16-95 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

NTSTATUS UserCommitDesktopMemory(
    PVOID pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize)
{
    PDESKTOPVIEW    pdv;
    DWORD           dwCommitOffset;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    int             dCommit;
    NTSTATUS        Status;
    PETHREAD        Thread = PsGetCurrentThread();

    /*
     * If this is a system thread, we have no view of the desktop
     * and must map it in.  Fortunately, this does not happen often.
     *
     * We use the Thread variable because PsIsSystemThread is a macro
     * that multiply resolves the parameter.
     */
    if (PsIsSystemThread(Thread)) {

        /*
         * Find the desktop that owns the section.
         */
        for (pwinsta = grpWinStaList; pwinsta; pwinsta = pwinsta->rpwinstaNext) {
            for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
                if (pdesk->pDeskInfo->pvDesktopBase == pBase)
                    goto FoundIt;
            }
        }
FoundIt:
        if (pwinsta == NULL) {
            RIPMSG3(RIP_ERROR, "UserCommitDesktopMemory failed: pBase %#p, ppCommit %#p, pCommitSize %d",
                    pBase, ppCommit, *pCommitSize);
            return STATUS_NO_MEMORY;
        }

        /*
         * Map the section into the current process and commit the
         * first page of the section.
         */
        dwCommitOffset = (ULONG)((PBYTE)*ppCommit - (PBYTE)pBase);
        Status = CommitReadOnlyMemory(pdesk->hsectionDesktop, pCommitSize,
                    dwCommitOffset, &dCommit);
        if (NT_SUCCESS(Status)) {
            *ppCommit = (PBYTE)*ppCommit + dCommit;
        }
    } else {

        /*
         * Find the current process' view of the desktop
         */
        for (pdv = PpiCurrent()->pdvList; pdv != NULL; pdv = pdv->pdvNext) {
            if (pdv->pdesk->pDeskInfo->pvDesktopBase == pBase)
                break;
        }
        
        /*
         * 254954: If we didn't find a desktop view then map the desktop view
         * to the current process.
         */
        if (pdv == NULL) {
            /*
             * Find the desktop that owns the section.
             */
            for (pwinsta = grpWinStaList; pwinsta; pwinsta = pwinsta->rpwinstaNext) {
                for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
                    if (pdesk->pDeskInfo->pvDesktopBase == pBase)
                        goto FoundTheDesktop;
                }
            }

FoundTheDesktop:
            if (pwinsta == NULL) {
                RIPMSG3(RIP_ERROR, "UserCommitDesktopMemory failed: pBase %#p, ppCommit %#p, pCommitSize %d",
                        pBase, ppCommit, *pCommitSize);
                return STATUS_NO_MEMORY;
            }

            UserAssert(pdesk != NULL);

            /*
             * Map the desktop into the current process
             */
            {

                WIN32_OPENMETHOD_PARAMETERS OpenParams;

                OpenParams.OpenReason = ObOpenHandle;
                OpenParams.Process = PsGetCurrentProcess();
                OpenParams.Object = pdesk;
                OpenParams.GrantedAccess = 0;
                OpenParams.HandleCount = 1;

                if (!NT_SUCCESS (MapDesktop(&OpenParams))) {
                    RIPMSG2(RIP_WARNING, "UserCommitDesktopMemory: Could't map pdesk %#p in ppi %#p",
                            pdesk, PpiCurrent());
                    return STATUS_NO_MEMORY;
                }
            }
            
            pdv = GetDesktopView(PpiCurrent(), pdesk);

            if (pdv == NULL) {
                RIPMSG2(RIP_ERROR, "UserCommitDesktopMemory: GetDesktopView returns NULL for pdesk %#p in ppi %#p",
                      pdesk, PpiCurrent());
                return STATUS_NO_MEMORY;
            }
        }

        /*
         * Commit the memory using the session view base so it doesn't matter
         * if the user destroys (and replaces) his usermode view.
         */

        Status = MmCommitSessionMappedView (*ppCommit, *pCommitSize);
    }

    return Status;
}

NTSTATUS UserCommitSharedMemory(
    PVOID  pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize)
{
    ULONG_PTR   ulClientDelta;
    DWORD       dwCommitOffset;
    PBYTE       pUserBase;
    NTSTATUS    Status;
    PEPROCESS   Process;
    int         dCommit;
    PW32PROCESS pw32p;

#if DBG
    if (pBase != Win32HeapGetHandle(gpvSharedAlloc)) {
        RIPMSG0(RIP_WARNING, "pBase != gpvSharedAlloc");
    }
#else
    UNREFERENCED_PARAMETER(pBase);
#endif

    Process = PsGetCurrentProcess();

    ValidateProcessSessionId(Process);

    pw32p = PsGetProcessWin32Process(Process);
    if (pw32p == NULL ||
        (((PPROCESSINFO)pw32p)->pClientBase == NULL)) {

        dwCommitOffset = (ULONG)((PBYTE)*ppCommit - (PBYTE)gpvSharedBase);
        Status = CommitReadOnlyMemory(
                ghSectionShared, pCommitSize, dwCommitOffset, &dCommit);

        if (NT_SUCCESS(Status)) {
            *ppCommit = (PBYTE) *ppCommit + dCommit;
        }
    } else {

        /*
         * Commit the memory
         */
        ulClientDelta = (ULONG_PTR)((PBYTE)gpvSharedBase - (PBYTE)(PpiCurrent()->pClientBase));
        pUserBase = (PVOID)((PBYTE)*ppCommit - ulClientDelta);
        Status = ZwAllocateVirtualMemory(
                         NtCurrentProcess(),
                         &pUserBase,
                         0,
                         pCommitSize,
                         MEM_COMMIT,
                         PAGE_EXECUTE_READ);
        if (NT_SUCCESS(Status)) {
            *ppCommit = (PVOID)((PBYTE)pUserBase + ulClientDelta);
        }
    }

    return Status;
}

PWIN32HEAP UserCreateHeap(
    HANDLE                      hSection,
    ULONG                       ulViewOffset,
    PVOID                       pvBaseAddress,
    DWORD                       dwSize,
    PRTL_HEAP_COMMIT_ROUTINE    pfnCommit)
{
    PVOID pUserBase;
    SIZE_T ulViewSize;
    LARGE_INTEGER liOffset;
    PEPROCESS Process = PsGetCurrentProcess();
    RTL_HEAP_PARAMETERS HeapParams;
    NTSTATUS Status;
    ULONG HeapFlags;
    ULONG CommitSize;

#if defined(_WIN64)

    CommitSize = 8192;

#else

    CommitSize = 4096;

#endif

    /*
     * Map the section into the current process and commit the
     * first page of the section.
     */
    ulViewSize        = 0;
    liOffset.LowPart  = ulViewOffset;
    liOffset.HighPart = 0;
    pUserBase         = NULL;

    Status = MmMapViewOfSection(
                    hSection,
                    Process,
                    &pUserBase,
                    0,
                    CommitSize,
                    &liOffset,
                    &ulViewSize,
                    ViewUnmap,
                    SEC_NO_CHANGE,
                    PAGE_EXECUTE_READ);

    if (!NT_SUCCESS(Status))
        return NULL;

    MmUnmapViewOfSection(Process, pUserBase);

    /*
     * We now have a committed page to create the heap in.
     */
    RtlZeroMemory(&HeapParams, sizeof(HeapParams));

    HeapParams.Length         = sizeof(HeapParams);
    HeapParams.InitialCommit  = CommitSize;
    HeapParams.InitialReserve = dwSize;
    HeapParams.CommitRoutine  = pfnCommit;

    UserAssert(HeapParams.InitialCommit < dwSize);
    
    
    HeapFlags = HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;

#if DBG
    HeapFlags |= HEAP_TAIL_CHECKING_ENABLED;
#endif // DBG

    return Win32HeapCreate("UH_HEAD",
                           "UH_TAIL",
                           HeapFlags,
                           pvBaseAddress,
                           dwSize,
                           CommitSize,
                           NULL,
                           &HeapParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\help.c ===
/**************************** Module Header ********************************\
* Module Name: help.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Help function
*
* History:
* 04-15-91 JimA             Ported.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

DWORD _GetWindowContextHelpId(PWND pWnd)
{
    return (DWORD)(ULONG_PTR)_GetProp(pWnd, MAKEINTATOM(gpsi->atomContextHelpIdProp),
            PROPF_INTERNAL);
}


BOOL _SetWindowContextHelpId(PWND pWnd, DWORD dwContextId)
{
    //If dwContextId is NULL, then this implies that the caller wants to
    // remove the dwContextId associated with this Window.
    if(dwContextId == 0) {
        InternalRemoveProp(pWnd, MAKEINTATOM(gpsi->atomContextHelpIdProp),
                PROPF_INTERNAL);
        return(TRUE);
      }

    return (InternalSetProp(pWnd, MAKEINTATOM(gpsi->atomContextHelpIdProp),
            (HANDLE)LongToHandle( dwContextId ), PROPF_INTERNAL | PROPF_NOPOOL));
}


/***************************************************************************\
* SendHelpMessage
*
*
\***************************************************************************/

void xxxSendHelpMessage(
    PWND   pwnd,
    int    iType,
    int    iCtrlId,
    HANDLE hItemHandle,
    DWORD  dwContextId)
{
    HELPINFO    HelpInfo;
    long        lValue;

    CheckLock(pwnd);

    HelpInfo.cbSize = sizeof(HELPINFO);
    HelpInfo.iContextType = iType;
    HelpInfo.iCtrlId = iCtrlId;
    HelpInfo.hItemHandle = hItemHandle;
    HelpInfo.dwContextId = dwContextId;

    lValue = _GetMessagePos();
    HelpInfo.MousePos.x = GET_X_LPARAM(lValue);
    HelpInfo.MousePos.y = GET_Y_LPARAM(lValue);

    xxxSendMessage(pwnd, WM_HELP, 0, (LPARAM)(LPHELPINFO)&HelpInfo);
}


/*
 * Modal loop for when the user has selected the help icon from the titlebar
 *
 */
VOID xxxHelpLoop(PWND pwnd)
{
    HWND        hwndChild;
    PWND        pwndChild;
    PWND        pwndControl;
    MSG         msg;
    RECT        rc;
    int         cBorders;
    PTHREADINFO ptiCurrent = PtiCurrent();
    DLGENUMDATA DlgEnumData;
    TL          tlpwndChild;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    xxxWindowEvent(EVENT_SYSTEM_CONTEXTHELPSTART, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    zzzSetCursor(SYSCUR(HELP));
    xxxCapture(ptiCurrent, pwnd, SCREEN_CAPTURE);

    cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

    CopyInflateRect(&rc, &pwnd->rcWindow, -cBorders * SYSMET(CXBORDER), -cBorders * SYSMET(CYBORDER));

    while (ptiCurrent->pq->spwndCapture == pwnd) {
        if (!xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_NOREMOVE)) {
            xxxWaitMessage();
            continue;
        }

        if (msg.message == WM_NCLBUTTONDOWN) {
            break;
        } else if (msg.message == WM_LBUTTONDOWN) {
            /*
             *  If user clicked outside of window client, bail out now.
             */
            if (!PtInRect(&rc, msg.pt))
                break;

            /*
             *  WindowHitTest() won't return a static control's handle
             */
            hwndChild = xxxWindowHitTest(pwnd, msg.pt, NULL, 0);
            pwndChild = ValidateHwnd( hwndChild );
            ThreadLock(pwndChild, &tlpwndChild);

            if (pwndChild && FIsParentDude(pwndChild))
            {
                /*
                 * If this is a dialog class, then one of three things has
                 * happened:
                 *
                 *  o   This is a static text control
                 *  o   This is the background of the dialog box.
                 *
                 * What we do is enumerate the child windows and see if
                 * any of them contain the current cursor point. If they do,
                 * change our window handle and continue on. Otherwise,
                 * return doing nothing -- we don't want context-sensitive
                 * help for a dialog background.
                 *
                 * If this is a group box, then we might have clicked on a
                 * disabled control, so we enumerate child windows to see
                 * if we get another control.
                 */

                /*
                 *  We're enumerating a dialog's children.  So, if we don't
                 *  find any matches, hwndChild will be NULL and the check
                 *  below will drop out.
                 */
                DlgEnumData.pwndDialog = pwndChild;
                DlgEnumData.pwndControl = NULL;
                DlgEnumData.ptCurHelp = msg.pt;
                xxxInternalEnumWindow(pwndChild, EnumPwndDlgChildProc, (LPARAM)&DlgEnumData, BWL_ENUMCHILDREN);
                pwndControl = DlgEnumData.pwndControl;
            } else {
                pwndControl = pwndChild;
            }

            /*
             * If we click on nothing, just exit.
             */
            if (pwndControl == pwnd) {
                pwndControl = NULL;
            }

            /*
             *  HACK ALERT (Visual Basic 4.0) - they have their own non-window
             *    based controls that draw directly on the main dialog.  In order
             *    to provide help for these controls, we pass along the WM_HELP
             *    message iff the main dialog has a context id assigned.
             *
             *  If the top level window has its own context help ID,
             *  then pass it in the context help message.
             */
            if (!pwndControl) {
                if (_GetProp(pwnd, MAKEINTATOM(gpsi->atomContextHelpIdProp), TRUE))
                    pwndControl = pwnd;
            }

            if (pwndControl) {
                PWND    pwndSend;
                int     id;
                TL      tlpwndSend;
                TL      tlpwndControl;

                ThreadLockAlways(pwndControl, &tlpwndControl);

                zzzSetCursor(SYSCUR(ARROW));
                xxxReleaseCapture();
                xxxRedrawTitle(pwnd, DC_BUTTONS);
                ClrWF(pwnd, WFHELPBUTTONDOWN);
                xxxGetMessage(&msg, NULL, 0, 0);

                xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR,
                    INDEX_TITLEBAR_HELPBUTTON, FALSE);

                xxxWindowEvent(EVENT_SYSTEM_CONTEXTHELPEND, pwnd, OBJID_WINDOW,
                    INDEXID_CONTAINER, FALSE);

                /*
                 * Determine the ID of the control
                 * We used to always sign extend, but Win98 doesn't do that
                 * so we only sign extend 0xffff.  MCostea #218711
                 */
                if (TestwndChild(pwndControl)) {
                    id = PTR_TO_ID(pwndControl->spmenu);
                    if (id == 0xffff) {
                        id = -1;
                    }
                } else {
                    id = -1;
                }

                /*
                 * Disabled controls and static controls won't pass this
                 * on to their parent, so instead, we send the message to
                 * their parent.
                 */

                if (TestWF(pwndControl, WFDISABLED)) {
                    PWND pwndParent = _GetParent(pwndControl);
                    if (!pwndParent)
                    {
                        ThreadUnlock( &tlpwndControl );
                        ThreadUnlock( &tlpwndChild );
                        return;
                    }
                    pwndSend = pwndParent;
                } else {
                    pwndSend = pwndControl;
                }

                ThreadLockAlways(pwndSend, &tlpwndSend);
                xxxSendHelpMessage( pwndSend, HELPINFO_WINDOW, id,
                    (HANDLE)HWq(pwndControl), GetContextHelpId(pwndControl));
                ThreadUnlock(&tlpwndSend);
                ThreadUnlock(&tlpwndControl);
                ThreadUnlock(&tlpwndChild);
                return;
            }
            ThreadUnlock(&tlpwndChild);
            break;

        }
        else if ((msg.message == WM_RBUTTONDOWN) || 
                 (msg.message == WM_MBUTTONDOWN) || 
                 (msg.message == WM_XBUTTONDOWN)) {
            /*
             *  fix bug 29852; break the loop for right and middle buttons
             *  and pass along the messages to the control
             */
            break;
        }
        else if (msg.message == WM_MOUSEMOVE) {
            if (PtInRect(&rc, msg.pt))
                zzzSetCursor(SYSCUR(HELP));
            else
                zzzSetCursor(SYSCUR(ARROW));
        }
        else if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
        {
            xxxGetMessage( &msg, NULL, 0, 0 );
            break;
        }

        xxxGetMessage(&msg, NULL, 0, 0);
        xxxTranslateMessage(&msg, 0);
        xxxDispatchMessage(&msg);
    }

    xxxReleaseCapture();
    zzzSetCursor(SYSCUR(ARROW));
    xxxRedrawTitle(pwnd, DC_BUTTONS);

    ClrWF(pwnd, WFHELPBUTTONDOWN);
    xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR,
            INDEX_TITLEBAR_HELPBUTTON, 0);

    xxxWindowEvent(EVENT_SYSTEM_CONTEXTHELPEND, pwnd, OBJID_WINDOW,
            INDEXID_CONTAINER, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ghost.c ===
/***************************** Module Header ******************************\
* Module Name: ghost.c
*
* Copyright (c) 1985-1999, Microsoft Corporation
*
* Ghost support for unresponsive windows.
*
* History:
* 23-Apr-1999   vadimg      created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef HUNGAPP_GHOSTING

typedef struct tagGHOST *PGHOST;
typedef struct tagGHOST {
    PGHOST pghostNext;          // next structure in the linked list
    PWND pwnd;                  // hung window we're trying to ghost
    PWND pwndGhost;             // ghost window created for this pwnd
    HBITMAP hbm;                // saved visual bits for the ghosted window
    HRGN hrgn;                  // what visual bits are available to us
    RECT rcClient;              // client rect in window's coordinates
    UINT fWarningText : 1;     // whether the warning text has been added
    UINT fSizedOrMoved : 1;
} GHOST, *PGHOST;

PGHOST gpghostFirst;            // pointer to the start of the ghost list
PTHREADINFO gptiGhost;          // pointer to ghost threadinfo

ULONG guGhostLinked;
ULONG guGhostUnlinked;
ULONG guGhostBmpCreated;
ULONG guGhostBmpFreed;

#define XY_MARGIN 10
#define MAXSTRING 256

#define GHOST_MAX 50

/***************************************************************************\
* _DisableProcessWindowsGhosting
*
* Diables ghosting windows for the calling process.
* History:
* 31-May-01 MSadek      Created.
\***************************************************************************/
VOID _DisableProcessWindowsGhosting(
    VOID)
{
    PpiCurrent()->W32PF_Flags |= W32PF_DISABLEWINDOWSGHOSTING;
}

/***************************************************************************\
* GhostFromGhostPwnd
*
* Find the ghost structure for this ghost window.
\***************************************************************************/
PGHOST GhostFromGhostPwnd(
    PWND pwndGhost)
{
    PGHOST pghost;

    for (pghost = gpghostFirst; pghost != NULL; pghost = pghost->pghostNext) {
        if (pghost->pwndGhost == pwndGhost) {
            return pghost;
        }
    }
    return NULL;
}

/***************************************************************************\
* GhostFromPwnd
*
\***************************************************************************/
PGHOST GhostFromPwnd(
    PWND pwnd)
{
    PGHOST pghost;

    for (pghost = gpghostFirst; pghost != NULL; pghost = pghost->pghostNext) {
        if (pghost->pwnd == pwnd) {
            return pghost;
        }
    }
    return NULL;
}

/***************************************************************************\
* FindGhost
*
* Find a ghost that corresponds to this hung window.
\***************************************************************************/
PWND FindGhost(
    PWND pwnd)
{
    PGHOST pghost = GhostFromPwnd(pwnd);

    if (pghost != NULL) {
        return pghost->pwndGhost;
    } else {
        return NULL;
    }
}

/***************************************************************************\
* GhostSizedOrMoved
*
* Returns true if the ghost window corresponding to a window was sized or moved
* through its life time.
\***************************************************************************/
BOOL GhostSizedOrMoved(
    PWND pwnd)
{
    PGHOST pghost = GhostFromPwnd(pwnd);

    if (pghost != NULL) {
        return pghost->fSizedOrMoved;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* UnlinkAndFreeGhost
*
* This function unlinks a ghost element from the list and free its allocated
* memory.
\***************************************************************************/
_inline VOID UnlinkAndFreeGhost(
    PGHOST* ppghost,
    PGHOST pghost)
{
    UserAssert(pghost->hbm == NULL);

    *ppghost = pghost->pghostNext;
     UserFreePool(pghost);
     guGhostUnlinked++;
}

/***************************************************************************\
* GetWindowIcon
*
* Get a window icon. If asked try the large icon first, then the small icon,
* then the windows logo icon.
\***************************************************************************/
PICON GetWindowIcon(
    PWND pwnd,
    BOOL fBigIcon)
{
    HICON hicon;
    PICON picon = NULL;

    if (fBigIcon) {
        hicon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), TRUE);
        if (hicon) {
            picon = (PICON)HMValidateHandleNoRip(hicon, TYPE_CURSOR);
        }

        if (picon == NULL) {
            picon = pwnd->pcls->spicn;
        }
    }

    if (picon == NULL) {
        hicon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), TRUE);

        if (hicon != NULL) {
            picon = (PICON)HMValidateHandleNoRip(hicon, TYPE_CURSOR);
        }

        if (picon == NULL) {
            picon = pwnd->pcls->spicnSm;
        }
    }

    return picon;
}

/***************************************************************************\
* AddGhost
*
* Add a new ghost structure for a hung window.
\***************************************************************************/
BOOL AddGhost(
    PWND pwnd)
{
    PGHOST pghost;
    CheckCritIn();

    /*
     * Need to limit the maximum number of ghost windows created as not to
     * result into thread starvation.
     */
    if (guGhostLinked - guGhostUnlinked == GHOST_MAX) {
        return FALSE;
    }

    if ((pghost = (PGHOST)UserAllocPoolZInit(sizeof(GHOST), TAG_GHOST)) == NULL) {
        return FALSE;
    }

    pghost->pghostNext = gpghostFirst;
    gpghostFirst = pghost;

    pghost->pwnd = pwnd;

    /*
     * When pwndGhost is NULL, the ghost thread will try to create a ghost
     * window for this hung window.
     */
    KeSetEvent(gpEventScanGhosts, EVENT_INCREMENT, FALSE);
    guGhostLinked++;

    return TRUE;
}

BOOL AddOwnedWindowToGhostList(
    PWND pwndRoot,
    PWND pwndOrg)
{
    PWND pwnd = NULL;

    while (pwnd = NextOwnedWindow(pwnd, pwndRoot, pwndRoot->spwndParent)) {
        if (!AddOwnedWindowToGhostList(pwnd, pwndOrg)) {
           return FALSE;
        }

        /*
         * We need to add the bottom window on the chain first to the ghost
         * list because we scan the list from the head thus, ensure that the
         * owned window is already created at the time we create the ownee
         * ghost.
         */
        if (GhostFromPwnd(pwnd) == NULL) {
            if (!AddGhost(pwnd)) {
                return FALSE;
            }

            if (GETPTI(pwndOrg) != GETPTI(pwndRoot)) {
                RIPMSGF4(RIP_WARNING,
                         "Cross thread ghosting pwnd: 0x%p pti 0x%p, pwndRoot: 0x%p pti 0x%p",
                         pwndOrg,
                         GETPTI(pwndOrg),
                         pwndRoot,
                         GETPTI(pwndRoot));
            }
        }
    }

    return TRUE;
}

BOOL AddGhostOwnersAndOwnees(
    PWND pwnd)
{
    PWND pwndRoot = pwnd;

    /*
     * Get the topmost owner window in the chain.
     */
    while(pwndRoot->spwndOwner != NULL) {
        pwndRoot = pwndRoot->spwndOwner;
    }

    /*
     * Now starting form that window, walk the whole ownee tree.
     */
    if (!AddOwnedWindowToGhostList(pwndRoot, pwnd)) {
        return FALSE;
    }

    /*
     * For the topmost window (or the only single window if there is no Owner / Ownee
     * relationship at all, add the window to the ghost list
     */
    if (GhostFromPwnd(pwndRoot) == NULL) {
        if (!AddGhost(pwndRoot)) {
            return FALSE;
        }

        if (GETPTI(pwnd) != GETPTI(pwndRoot)) {
            RIPMSGF4(RIP_WARNING,
                     "Cross thread ghosting pwnd: 0x%p pti 0x%p, pwndRoot: 0x%p pti 0x%p",
                     pwnd,
                     GETPTI(pwnd),
                     pwndRoot,
                     GETPTI(pwndRoot));
        }
    }

    return TRUE;
}

#if GHOST_AGGRESSIVE

/***************************************************************************\
* DimSavedBits
*
\***************************************************************************/
VOID DimSavedBits(
    PGHOST pghost)
{
    HBITMAP hbm, hbmOld, hbmOld2;
    LONG cx, cy;
    RECT rc;
    BLENDFUNCTION blend;

    if (pghost->hbm == NULL) {
        return;
    }

    if (gpDispInfo->fAnyPalette) {
        return;
    }

    cx = pghost->rcClient.right - pghost->rcClient.left;
    cy = pghost->rcClient.bottom - pghost->rcClient.top;

    hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy);
    if (hbm == NULL) {
        return;
    }

    hbmOld = GreSelectBitmap(ghdcMem, hbm);
    hbmOld2 = GreSelectBitmap(ghdcMem2, pghost->hbm);

    rc.left = rc.top = 0;
    rc.right = cx;
    rc.bottom = cy;
    FillRect(ghdcMem, &rc, SYSHBR(MENU));

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = AC_MIRRORBITMAP;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = 150;
    GreAlphaBlend(ghdcMem, 0, 0, cx, cy, ghdcMem2, 0, 0, cx, cy, blend, NULL);

    GreSelectBitmap(ghdcMem, hbmOld);
    GreSelectBitmap(ghdcMem2, hbmOld2);

    GreDeleteObject(pghost->hbm);
    pghost->hbm = hbm;
}

#endif

/***************************************************************************\
* SaveVisualBits
*
\***************************************************************************/
VOID SaveVisualBits(
    PGHOST pghost)
{
    BOOL fSaveBits;
    PWND pwnd;
    HBITMAP hbmOld;
    int cx, cy;
    RECT rcT;
    HDC hdc;

    fSaveBits = FALSE;
    pwnd = pghost->pwnd;

    /*
     * Nothing to save if the window is completely invalid.
     */
    if (pwnd->hrgnUpdate != HRGN_FULL) {

        CalcVisRgn(&pghost->hrgn, pwnd, pwnd, DCX_CLIPSIBLINGS);

        /*
         * Only can save bits if the window is not completely obscured and
         * either there is no invalid bits or if there are bits left over
         * after we subtract the invalid bits from the visible area.
         */
        if (pghost->hrgn != NULL &&
                GreGetRgnBox(pghost->hrgn, &rcT) != NULLREGION) {

            if (pwnd->hrgnUpdate == NULL) {
                fSaveBits = TRUE;
            } else {

                /*
                 * We'll use the bounding box of the invalid region of the
                 * ghost window as an approximation of the total invalid
                 * region, this way we won't have to go through all of the
                 * children.
                 */
                GreGetRgnBox(pwnd->hrgnUpdate, &rcT);
                SetRectRgnIndirect(ghrgnGDC, &rcT);

                if (SubtractRgn(pghost->hrgn, pghost->hrgn, ghrgnGDC) != NULLREGION) {
                    fSaveBits = TRUE;
                }
            }
        }
    }

    /*
     * Now try to save the bits.
     */
    if (fSaveBits) {
        UserAssert(pghost->hrgn != NULL);

        cx = pwnd->rcClient.right - pwnd->rcClient.left;
        cy = pwnd->rcClient.bottom - pwnd->rcClient.top;

        if (pghost->hbm != NULL) {
            FRE_RIPMSG0(RIP_ERROR, "SaveVisaulBits: overriding pghost->hbm");
        }

        /*
         * Use NOVIDEOMEMORY here, because for the blend we'll have to be
         * reading from this bitmap and reading from video memory is slow
         * when the alpha isn't done by the graphics card but by GDI.
         */
        pghost->hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy | CCB_NOVIDEOMEMORY);
        guGhostBmpCreated++;

        if (pghost->hbm != NULL) {
            int dx, dy;

            dx = pghost->pwnd->rcClient.left - pghost->pwndGhost->rcClient.left;
            dy = pghost->pwnd->rcClient.top - pghost->pwndGhost->rcClient.top;

            /*
             * Get the visual bits rectangle in ghost client rect origin.
             */
            pghost->rcClient.left = dx;
            pghost->rcClient.top = dy;
            pghost->rcClient.right = dx + cx;
            pghost->rcClient.bottom = dy + cy;

            /*
             * Make the region originate in the ghost client rect origin.
             */
            GreOffsetRgn(pghost->hrgn,
                    -pwnd->rcClient.left + dx,
                    -pwnd->rcClient.top + dy);

            hbmOld = GreSelectBitmap(ghdcMem, pghost->hbm);
            hdc = _GetDC(pghost->pwnd);

            GreBitBlt(ghdcMem, 0, 0, cx, cy, hdc, 0, 0, SRCCOPY, 0);

            _ReleaseDC(hdc);
            GreSelectBitmap(ghdcMem, hbmOld);
        }
    }

    /*
     * Clean up the region if couldn't save the visual bits successfully.
     */
    if (pghost->hbm == NULL && pghost->hrgn != NULL) {
        GreDeleteObject(pghost->hrgn);
        pghost->hrgn = NULL;
    }
}

/***************************************************************************\
* xxxAddWarningText
*
\***************************************************************************/
VOID xxxAddWarningText(
    PWND pwnd)
{
    WCHAR szText[CCHTITLEMAX];
    UINT cch, cchNR;
    LARGE_STRING strName;
    WCHAR szNR[MAXSTRING];

    ServerLoadString(hModuleWin, STR_NOT_RESPONDING, szNR, ARRAY_SIZE(szNR));

    /*
     * Add "Not responding" to the end of the title text.
     */
    cch = TextCopy(&pwnd->strName, szText, CCHTITLEMAX);
    cchNR = wcslen(szNR);
    cch = min(CCHTITLEMAX - cchNR - 1, cch);
    wcscpy(szText + cch, szNR);
    strName.bAnsi = FALSE;
    strName.Buffer = szText;
    strName.Length = (USHORT)((cch + cchNR) * sizeof(WCHAR));
    strName.MaximumLength = strName.Length + sizeof(UNICODE_NULL);

    xxxDefWindowProc(pwnd, WM_SETTEXT, 0, (LPARAM)&strName);
}

/***************************************************************************\
* xxxCreateGhostWindow
*
\***************************************************************************/
BOOL xxxCreateGhostWindow(
    PGHOST pghost)
{
    PWND pwnd;
    PWND pwndGhost;
    PWND pwndOwner = NULL;
    PGHOST pghostOwner = NULL;
    PTHREADINFO pti;
    HWND hwnd, hwndGhost;
    TL tlpwndT1, tlpwndT2, tlpwndT3, tlpwndT4, tlpwndT5;
    PWND pwndPrev;
    DWORD dwFlags, style, ExStyle;
    PICON picon;
    LARGE_UNICODE_STRING str;
    UINT cbAlloc;
    BOOL fHasOwner = FALSE;

    if (gbCleanupInitiated) {
        FRE_RIPMSG0(RIP_ERROR, "Trying to create a ghost window while shutdown is in progress");
        return FALSE;
    }
    pwnd = pghost->pwnd;

    cbAlloc = pwnd->strName.Length + sizeof(WCHAR);
    str.Buffer = UserAllocPoolWithQuota(cbAlloc, TAG_GHOST);

    if (str.Buffer == NULL) {
        return FALSE;
    }

    str.MaximumLength = cbAlloc;
    str.Length =  pwnd->strName.Length;
    str.bAnsi = FALSE;

    RtlCopyMemory(str.Buffer, pwnd->strName.Buffer, str.Length);

    str.Buffer[str.Length / sizeof(WCHAR)] = 0;

    ThreadLock(pwnd, &tlpwndT1);
    ThreadLockPool(ptiCurrent, str.Buffer, &tlpwndT2);

    if (pwnd->spwndOwner && ((pghostOwner = GhostFromPwnd(pwnd->spwndOwner)) != NULL) &&
        ((pwndOwner = pghostOwner->pwndGhost)) != NULL) {
        fHasOwner = TRUE;
        ThreadLock(pwndOwner, &tlpwndT3);
    }

    /*
     * Create the ghost window invisible and disallow it to be
     * maximized since it would be kind of pointless...
     * We don't remove the WS_MAXIMIZEBOX box here as
     * GetMonitorMaxArea() checks on WFMAXBOX to judge
     * if the window should be maximized to the full screen
     * area or to the working area (and it is being called during window creation).
     * See bug# 320325
     */
    ExStyle = (pwnd->ExStyle & ~(WS_EX_LAYERED | WS_EX_COMPOSITED)) & WS_EX_ALLVALID;
    style = pwnd->style & ~(WS_VISIBLE | WS_DISABLED);

    pwndGhost = xxxNVCreateWindowEx(ExStyle, (PLARGE_STRING)gatomGhost,
            (PLARGE_STRING)&str, style,
            pwnd->rcWindow.left, pwnd->rcWindow.top,
            pwnd->rcWindow.right - pwnd->rcWindow.left,
            pwnd->rcWindow.bottom - pwnd->rcWindow.top,
            pwndOwner, NULL, hModuleWin, NULL, WINVER);

    if (pwndGhost == NULL || (pghost = GhostFromPwnd(pwnd)) == NULL) {
        if (fHasOwner) {
            ThreadUnlock(&tlpwndT3);
        }
        ThreadUnlockAndFreePool(ptiCurrent, &tlpwndT2);
        ThreadUnlock(&tlpwndT1);
        return FALSE;
    }

    pghost->pwndGhost = pwndGhost;

    /*
     * Try to get large and small icons for the hung window. Since
     * we store the handles, it should be OK if these icons
     * somehow go away while the ghost window still exists.
     */
    if ((picon = GetWindowIcon(pwnd, TRUE)) != NULL) {
        InternalSetProp(pwndGhost, MAKEINTATOM(gpsi->atomIconProp),
                (HANDLE)PtoHq(picon), PROPF_INTERNAL | PROPF_NOPOOL);
    }
    if ((picon = GetWindowIcon(pwnd, FALSE)) != NULL) {
        InternalSetProp(pwndGhost, MAKEINTATOM(gpsi->atomIconSmProp),
                (HANDLE)PtoHq(picon), PROPF_INTERNAL | PROPF_NOPOOL);
    }

    /*
     * Now remove WFMAXBOX before painting the window.
     */
    ClrWF(pwndGhost, WFMAXBOX);
    SaveVisualBits(pghost);

#if GHOST_AGGRESSIVE
    DimSavedBits(pghost);
#endif

    /*
     * If the hung window is the active foreground window, allow
     * the activation to bring the ghost window to the foreground.
     */
    dwFlags = SWP_NOSIZE | SWP_NOMOVE;

    if (TestWF(pwnd, WFVISIBLE)) {
        dwFlags |= SWP_SHOWWINDOW;
        SetWF(pwnd, WEFGHOSTMAKEVISIBLE);
    }

    pti = GETPTI(pwnd);

    if (pti->pq == gpqForeground && pti->pq->spwndActive == pwnd) {
        PtiCurrent()->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
    } else {
        dwFlags |= SWP_NOACTIVATE;
    }

    /*
     * We will zorder the ghost window right above the hung window.
     */
    pwndPrev = _GetWindow(pwnd, GW_HWNDPREV);
    if (pwndPrev == pwndGhost) {
        dwFlags |= SWP_NOZORDER;
        pwndPrev = NULL;
    }

    ThreadLock(pwndGhost, &tlpwndT4);
    ThreadLock(pwndPrev, &tlpwndT5);

    /*
     * Make the shell remove the hung window from the taskbar. From
     * now on users will be dealing with the system menu on the
     * ghost window.
     */
    hwnd = HWq(pwnd);
    hwndGhost = HWq(pwndGhost);
    PostShellHookMessages(HSHELL_WINDOWREPLACING, (LPARAM)hwndGhost);
    PostShellHookMessages(HSHELL_WINDOWREPLACED, (LPARAM)hwnd);
    xxxCallHook(HSHELL_WINDOWREPLACED, (WPARAM)hwnd, (LPARAM)hwndGhost, WH_SHELL);

    xxxSetWindowPos(pwndGhost, pwndPrev, 0, 0, 0, 0, dwFlags);

    /*
     * Clear the visible bit on the hung window now and post our
     * queue message which will figure out when it wakes up.
     */
    if (TestWF(pwnd, WEFGHOSTMAKEVISIBLE)) {
        SetVisible(pwnd, SV_UNSET);
    }
    pti = GETPTI(pwnd);
    PostEventMessage(pti, pti->pq, QEVENT_HUNGTHREAD, pwnd, 0, 0, 0);

    zzzWindowEvent(EVENT_OBJECT_HIDE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);

    /*
     * If the end user clicked and held on the hung window, fake
     * this mouse click to the ghost window. This also ensures that
     * the attempted dragging operation will not be interrupted.
     */
    if (gspwndMouseOwner == pwnd) {
        Lock(&gspwndMouseOwner, pwndGhost);

        PostInputMessage(GETPTI(pwndGhost)->pq, pwndGhost, WM_LBUTTONDOWN,
                0, MAKELONG((SHORT)gptCursorAsync.x, (SHORT)gptCursorAsync.y),
                0, 0);
    }

    ThreadUnlock(&tlpwndT5);
    ThreadUnlock(&tlpwndT4);
    if (fHasOwner) {
        ThreadUnlock(&tlpwndT3);
    }
    ThreadUnlockAndFreePool(ptiCurrent, &tlpwndT2);
    ThreadUnlock(&tlpwndT1);

    return TRUE;
}

/***************************************************************************\
* CleanupGhost
*
* Cleans up an ghost structure entry
* Handles  the case when the ghost thread got destroyed during callback
* History:
* 29-Nov-00 MSadek      Created.
\***************************************************************************/
PWND CleanupGhost(
    PGHOST *ppghost,
    PGHOST pghost)
{
    PWND pwndGhost;

    if (pghost->hrgn != NULL) {
        GreDeleteObject(pghost->hrgn);
    }

    if (pghost->hbm != NULL) {
        GreDeleteObject(pghost->hbm);
        guGhostBmpFreed++;
        pghost->hbm = NULL;
    }

    /*
     * We used the icon handles owned by the ghosted window, so
     * we will only remove the properties without actually
     * destroying the icons, as it would happen in DestroyWindow.
     */
    pwndGhost = pghost->pwndGhost;
    if (pwndGhost != NULL) {
        InternalRemoveProp(pwndGhost,
                MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);
        InternalRemoveProp(pwndGhost,
                MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
    }
    UnlinkAndFreeGhost(ppghost, pghost);

    return pwndGhost;
}

/***************************************************************************\
* ResetGhostThreadInfo
*
* Does a celanup for the ghost windows global linked list.
* Add a comment reading that we need to clean up the list, if we die unexpectedly
* because we don't know if a ghost thread will got created again.
* History:
* 12-Oct-00 MSadek      Created.
\***************************************************************************/
VOID ResetGhostThreadInfo(
    PTHREADINFO pti)
{
    PGHOST* ppghost;
    PGHOST pghost;

    UNREFERENCED_PARAMETER(pti);

    ppghost = &gpghostFirst;

    if (gpghostFirst != NULL) {
        RIPMSGF0(RIP_WARNING,
                 "Ghost thread died while the ghost list is not empty");
    }

    while (*ppghost != NULL) {
        pghost = *ppghost;
        CleanupGhost(ppghost, pghost);
    }

    UserAssert(pti == gptiGhost);
    gptiGhost = NULL;
}

/***************************************************************************\
* ScanGhosts
*
* This is our core function that will scan through the ghost list. It must
* always be called in the context of the ghost thread which assures that all
* creation and destruction of ghost windows happen in the context of that
* thread. When in the ghost structure
*
* pwnd is NULL - the hung window has been destroyed or the thread it's on
* woke up and so we need to destroy the ghost window.
*
* pwndGhost is NULL - the thread that pwnd is on is hung and so create the
* ghost window for it.
*
* 6-2-1999   vadimg      created
\***************************************************************************/
BOOL xxxScanGhosts(
    VOID)
{
    PGHOST* ppghost;
    PGHOST pghost;
    PWND pwndTemp;
    ULONG uGhostUnlinked;

    CheckCritIn();
    ppghost = &gpghostFirst;

    while (*ppghost != NULL) {

        pghost = *ppghost;

        /*
         * pwnd is NULL means we need to destroy the ghost window. Note, we
         * need to remove the ghost from the list first to make sure that
         * xxxFreeWindow can't find the ghost in the list and try to destroy
         * the ghost window again causing an infinite loop.
         */
        if (pghost->pwnd == NULL) {
            pwndTemp = CleanupGhost(ppghost, pghost);

            if (pwndTemp != NULL) {
                uGhostUnlinked = guGhostUnlinked;
                xxxDestroyWindow(pwndTemp);

                /*
                 * If we have called back, the pointers might be invalid.
                 * Let's start the search again.
                 */
                if (uGhostUnlinked != guGhostUnlinked) {
                    ppghost = &gpghostFirst;
                    continue;
                }
            }
        } else if (pghost->pwndGhost == NULL) {
            HWND hwnd;
            PGHOST pghostTemp = pghost;

            pwndTemp = pghost->pwnd;
            hwnd = PtoHq(pwndTemp);
            uGhostUnlinked = guGhostUnlinked;
            if (!xxxCreateGhostWindow(pghost)) {
                /*
                 * If window creation failed, clean up by removing the struct
                 * from the list altogether.
                 */
                if (RevalidateCatHwnd(hwnd) && (pghost = GhostFromPwnd(pwndTemp))) {
                    UserAssert(pghost->pwndGhost == NULL);
                    RemoveGhost(pwndTemp);
                }
            } else {
#if DBG
                if (RevalidateCatHwnd(hwnd) && (pghost = GhostFromPwnd(pwndTemp)) && (pghost == pghostTemp)) {
                    UserAssert(pghost->pwndGhost != NULL);
                }
#endif
            }

            /*
             * If we have called back, the pointers might be invalid. Let's
             * start the search again.
             */
             if (uGhostUnlinked != guGhostUnlinked) {
                ppghost = &gpghostFirst;
                continue;
             }
        } else {
            ppghost = &pghost->pghostNext;
        }
    }

    /*
     * If there are no more ghosts left, cleanup and terminate this
     * thread. by returning FALSE.
     */
    if (gpghostFirst == NULL) {
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* GhostThread
*
* The thread that will service hung windows. It's created on demand and is
* terminated when the last ghost window is destroyed.
\***************************************************************************/
VOID GhostThread(
    PDESKTOP pdesk)
{
    NTSTATUS status;
    DWORD dwResult;
    MSG msg;
    PKEVENT rgEvents[2];
    BOOL fLoop = TRUE;
    BOOL fCSRSSThread = ISCSRSS();
    TL tlGhost;

    if (fCSRSSThread) {
        /*
         * Make this a GUI thread.
         */
        status = InitSystemThread(NULL);
    }

    EnterCrit();

    /*
     * Don't allow multiple ghost threads to be created.
     */
    if (NULL != gptiGhost) {
        LeaveCrit();
        return;
    }
    gptiGhost = PtiCurrent();
    ThreadLockPoolCleanup(gptiGhost, gptiGhost, &tlGhost, ResetGhostThreadInfo);

    /*
     * Try to assign this thread to the desktop. Any ghost windows can be
     * created only on that desktop.
     */
    if (fCSRSSThread) {
        if (!NT_SUCCESS(status) || !xxxSetThreadDesktop(NULL, pdesk)) {
            goto Cleanup;
        }
    }
    gptiGhost->pwinsta = pdesk->rpwinstaParent;

    rgEvents[0] = gpEventScanGhosts;

    /*
     * Scan the list, since gptiGhost was NULL up to now and thus no posted
     * messages could reach us.
     */

    while (fLoop) {

        /*
         * Wait for any message sent or posted to this queue, while calling
         * ProcessDeviceChanges whenever the mouse change event (pkeHidChange)
         * is set.
         */
        dwResult = xxxMsgWaitForMultipleObjects(1, rgEvents, NULL, NULL);

        /*
         * result tells us the type of event we have:
         * a message or a signalled handle
         *
         * if there are one or more messages in the queue ...
         */
        if (dwResult == WAIT_OBJECT_0) {
            fLoop = xxxScanGhosts();
        } else if (dwResult == STATUS_USER_APC){
            goto Cleanup;
        } else {
            UserAssert(dwResult == WAIT_OBJECT_0 + 1);

            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                xxxDispatchMessage(&msg);
            }
        }
    }

Cleanup:
    ThreadUnlockPoolCleanup(gptiGhost, &tlGhost);
    ResetGhostThreadInfo(PtiCurrent());
    LeaveCrit();
}

/***************************************************************************\
* xxxCreateGhost
*
* This function will create a ghost thread when needed and add a request
* to create a ghost to the ghost list.
\***************************************************************************/
BOOL xxxCreateGhost(
    PWND pwnd)
{
    USER_API_MSG m;
    NTSTATUS Status;
    PDESKTOP pdesk;
    BOOL bRemoteThread = FALSE;
    HANDLE UniqueProcessId = 0;

    CheckLock(pwnd);

    /*
     * Bail out early for winlogon windows.
     */
    pdesk = pwnd->head.rpdesk;
    if (pdesk == grpdeskLogon) {
        return FALSE;
    }

    /*
     * We can only service windows on the same desktop.
     */
    if (gptiGhost != NULL && gptiGhost->rpdesk != pdesk) {
        return FALSE;
    }

    /*
     * Don't try to ghost windows from the ghost thread itself.
     */
    if (GETPTI(pwnd) == gptiGhost) {
        return FALSE;
    }

    /*
     * Not much we can do if this hung window doesn't have a caption.
     */
    if (TestWF(pwnd, WFCAPTION) != LOBYTE(WFCAPTION)) {
        return FALSE;
    }

    /*
     * Try to create a ghost thread. Note that the event can have a value
     * though the thread is NULL. This could happen if the thread died
     * before making it to the kernel.
     */
    if (gptiGhost == NULL) {
        PPROCESSINFO ppi, ppiShellProcess = NULL;

        if (gpEventScanGhosts == NULL) {
            gpEventScanGhosts = CreateKernelEvent(SynchronizationEvent, FALSE);
            if (gpEventScanGhosts == NULL) {
                return FALSE;
            }
        }
        UserAssert (ISCSRSS());

        ppi = GETPTI(pwnd)->ppi;
        if (ppi->rpdeskStartup && ppi->rpdeskStartup->pDeskInfo) {
            ppiShellProcess = ppi->rpdeskStartup->pDeskInfo->ppiShellProcess;
        }
        if (ppiShellProcess && ppiShellProcess->Process != gpepCSRSS) {
             bRemoteThread = TRUE;

             UniqueProcessId = PsGetProcessId(ppiShellProcess->Process);
        }

        if (!InitCreateSystemThreadsMsg(&m, CST_GHOST, pdesk, UniqueProcessId, bRemoteThread)) {
            return FALSE;
        }

        /*
         * Since we are in CSRSS context use LpcRequestPort to send
         * LPC_DATAGRAM message type. Do not use LpcRequestWaitReplyPort
         * because it will send LPC_REQUEST which will fail (in server side).
         */
        LeaveCrit();
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);
        EnterCrit();

        if (gpEventScanGhosts == NULL) {
            return FALSE;
        }
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    if (!(TestWF(pwnd, WFINDESTROY) || TestWF(pwnd, WFDESTROYED))) {
        return AddGhostOwnersAndOwnees(pwnd);
    }

    return FALSE;
}

/***************************************************************************\
* RemoveGhost
*
* This function is called from xxxFreeWindow to check and takes care
* of business when pwnd is either a ghost or a hung window.
\***************************************************************************/
VOID RemoveGhost(
    PWND pwnd)
{
    PGHOST* ppghost;
    PGHOST pghost;

    CheckCritIn();
    for (ppghost = &gpghostFirst; *ppghost != NULL;
            ppghost = &(*ppghost)->pghostNext) {

        pghost = *ppghost;

        /*
         * If this window matches the hung window, then set an event to
         * destroy the corresponding ghost window. If the ghost window hasn't
         * been created yet, we can nuke the structure in context.
         */
        if (pghost->pwnd == pwnd) {
            if (pghost->pwndGhost == NULL) {
                UnlinkAndFreeGhost(ppghost, pghost);
            } else {
                pghost->pwnd = NULL;
                KeSetEvent(gpEventScanGhosts, EVENT_INCREMENT, FALSE);
            }
            break;
        }

        /*
         * If this window matches the ghost window, just remove the
         * structure from the list.
         */
        if (pghost->pwndGhost == pwnd) {
            UnlinkAndFreeGhost(ppghost, pghost);
            break;
        }
    }
}

/***************************************************************************\
* PaintGhost
*
* Draw the ghost window look.
\***************************************************************************/
VOID PaintGhost(
    PWND pwnd,
    HDC hdc)
{
    PGHOST pghost;
    HBITMAP hbmOld;
    RECT rc;
    LONG cx, cy;
#if GHOST_AGGRESSIVE
    HFONT hfont, hfontOld;
    WCHAR szHung[MAXSTRING];
    ULONG cch;
    SIZE size;
    LONG xText;
    LOGFONTW lf;
#endif

    pghost = GhostFromGhostPwnd(pwnd);
    if (pghost == NULL) {
        return;
    }

    rc.left = rc.top = 0;
    rc.right = pwnd->rcClient.right - pwnd->rcClient.left;
    rc.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;

    if (pghost->hbm != NULL) {
        cx = pghost->rcClient.right - pghost->rcClient.left;
        cy = pghost->rcClient.bottom - pghost->rcClient.top;

        hbmOld = GreSelectBitmap(ghdcMem, pghost->hbm);
        GreExtSelectClipRgn(hdc, pghost->hrgn, RGN_COPY);

        GreBitBlt(hdc, pghost->rcClient.left, pghost->rcClient.top,
                  cx, cy, ghdcMem, 0, 0, SRCCOPY, 0);

        GreSelectBitmap(ghdcMem, hbmOld);

        SetRectRgnIndirect(ghrgnGDC, &rc);
        SubtractRgn(ghrgnGDC, ghrgnGDC, pghost->hrgn);
        GreExtSelectClipRgn(hdc, ghrgnGDC, RGN_COPY);
    }

    FillRect(hdc, &rc, SYSHBR(WINDOW));

    GreExtSelectClipRgn(hdc, NULL, RGN_COPY);

#if GHOST_AGGRESSIVE
    ServerLoadString(hModuleWin, STR_HUNG, szHung, ARRAY_SIZE(szHung));
    cch = wcslen(szHung);

    GreSetTextColor(hdc, RGB(0, 0, 255));
    GreSetBkColor(hdc, RGB(255, 255, 0));

    GreExtGetObjectW(gpsi->hCaptionFont, sizeof(LOGFONTW), &lf);
    lf.lfHeight = (lf.lfHeight * 3) / 2;
    lf.lfWeight = FW_BOLD;
    hfont = GreCreateFontIndirectW(&lf);
    hfontOld = GreSelectFont(hdc, hfont);

    GreGetTextExtentW(hdc, szHung, cch, &size, GGTE_WIN3_EXTENT);
    xText = max(0, ((rc.right - rc.left) - size.cx) / 2);
    GreExtTextOutW(hdc, xText, 0, 0, NULL, szHung, cch, NULL);

    GreSelectFont(hdc, hfontOld);
    GreDeleteObject(hfont);
#endif
}

/***************************************************************************\
* xxxGhostWndProc
*
* Processes messages for ghost windows.
\***************************************************************************/
LRESULT xxxGhostWndProc(
    PWND pwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PGHOST pghost;

    VALIDATECLASSANDSIZE(pwnd, uMsg, wParam, lParam, FNID_GHOST, WM_NCCREATE);

    switch (uMsg) {
    case WM_CLOSE:
        pghost = GhostFromGhostPwnd(pwnd);

        /*
         * Do the end task on the hung thread when the user tries to close
         * the ghost window.
         */
        if (pghost != NULL && pghost->pwnd != NULL) {
            PostShellHookMessages(HSHELL_ENDTASK, (LPARAM)HWq(pghost->pwnd));
        }
        return 0;

    case WM_LBUTTONDOWN:
        pghost = GhostFromGhostPwnd(pwnd);
        if (pghost != NULL) {
            if (pghost->fWarningText) {
                return 0;
            } else {
                pghost->fWarningText = TRUE;
            }
        }
        xxxAddWarningText(pwnd);
        return 0;

    case WM_SIZE:
        /*
         * Since we have wrapped, flowing text, repaint it when sizing.
         */
        xxxInvalidateRect(pwnd, NULL, TRUE);
        return 0;

    case WM_ERASEBKGND:
        PaintGhost(pwnd, (HDC)wParam);
        return 1;

    case WM_SETCURSOR:
        /*
         * Show the hung app cursor over the client.
         */
        if (LOWORD(lParam) == HTCLIENT) {
            zzzSetCursor(SYSCUR(WAIT));
            return 1;
        }

    case WM_EXITSIZEMOVE:
        pghost = GhostFromGhostPwnd(pwnd);
        if (pghost != NULL) {
            pghost->fSizedOrMoved = TRUE;
        }

        /*
         * FALL THROUGH to DWP.
         */

    default:
        return xxxDefWindowProc(pwnd, uMsg, wParam, lParam);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains window manager information routines
*
* History:
* 22-Oct-1990 MikeHar   Ported functions from Win 3.0 sources.
* 13-Feb-1991 MikeKe    Added Revalidation code (None)
* 08-Feb-1991 IanJa     Unicode/ANSI aware and neutral
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/****************************************************************************\
* DefSetText
*
* Processes WM_SETTEXT messages by text-alloc'ing a string in the alternate
* ds and setting 'hwnd->hName' to it's handle.
*
* History:
* 23-Oct-1990 MikeHar   Ported from Windows.
* 09-Nov-1990 DarrinM   Cleanup.
\****************************************************************************/
BOOL DefSetText(
    PWND pwnd,
    PLARGE_STRING cczpstr)
{
    /*
     * Note -- string buffer may be on client side.
     */
    PDESKTOP pdesk;
    DWORD cbString;
    BOOL fTranslateOk;

    if (pwnd->head.rpdesk == NULL || cczpstr == NULL || cczpstr->Buffer == NULL) {
        pwnd->strName.Length = 0;
        return TRUE;
    }

    /*
     * Capture the new window name
     */
    if (cczpstr->bAnsi)
        cbString = (cczpstr->Length + 1) * sizeof(WCHAR);
    else
        cbString = cczpstr->Length + sizeof(WCHAR);

    /*
     * If the current buffer is not large enough,
     * reallocate it.
     */
    pdesk = pwnd->head.rpdesk;
    if (pwnd->strName.MaximumLength < cbString) {
        if (pwnd->strName.Buffer != NULL)
            DesktopFree(pdesk, pwnd->strName.Buffer);
        pwnd->strName.Buffer = (LPWSTR)DesktopAlloc(pdesk, cbString, DTAG_TEXT);
        pwnd->strName.Length = 0;
        if (pwnd->strName.Buffer == NULL) {
            pwnd->strName.MaximumLength = 0;
            return FALSE;
        }
        pwnd->strName.MaximumLength = cbString;
    }

    fTranslateOk = TRUE;
    if (cczpstr->Length != 0) {
        try {
            if (!cczpstr->bAnsi) {
                RtlCopyMemory(pwnd->strName.Buffer, cczpstr->Buffer, cbString);
            } else {
                LPCSTR ccxpszAnsi = (LPCSTR)cczpstr->Buffer;

                fTranslateOk = NT_SUCCESS(RtlMultiByteToUnicodeN(pwnd->strName.Buffer,
                        cbString, &cbString,
                        (LPSTR)ccxpszAnsi, cbString / sizeof(WCHAR)));
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            pwnd->strName.Length = 0;
            return FALSE;
        }
    }

    if (fTranslateOk) {
        pwnd->strName.Length = cbString - sizeof(WCHAR);
        return TRUE;
    } else {
        pwnd->strName.Length = 0;
        return FALSE;
    }
}

/***************************************************************************\
* FCallerOk
*
* Ensures that no client stomps on server windows.
*
* 04-Feb-1992 ScottLu   Created.
\***************************************************************************/
BOOL FCallerOk(
    PWND pwnd)
{
    PTHREADINFO pti = PtiCurrent();

    if ((GETPTI(pwnd)->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD)) &&
            !(pti->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))) {
        return FALSE;
    }

    if (PsGetThreadProcessId(GETPTI(pwnd)->pEThread) == gpidLogon &&
            PsGetThreadProcessId(pti->pEThread) != gpidLogon) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* _SetWindowWord (supports SetWindowWordA/W API)
*
* Set a window word.  Positive index values set application window words
* while negative index values set system window words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 26-Nov-1990 DarrinM   Wrote.
\***************************************************************************/
WORD _SetWindowWord(
    PWND pwnd,
    int index,
    WORD value)
{
    WORD wOld;

    /*
     * Don't allow setting of words belonging to a system thread if the
     * caller is not a system thread. Same goes for winlogon.
     */
    if (!FCallerOk(pwnd)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * Applications can not set a WORD into a dialog Proc or any of the
     * non-public reserved bytes in DLGWINDOWEXTRA (usersrv stores pointers
     * there).
     */
    if (TestWF(pwnd, WFDIALOGWINDOW)) {
        if  (((index >= DWLP_DLGPROC) && (index < DWLP_MSGRESULT)) ||
                ((index > DWLP_USER+sizeof(LONG_PTR)-sizeof(WORD)) && (index < DLGWINDOWEXTRA))) {
            RIPERR3(ERROR_INVALID_INDEX, RIP_WARNING,
                  "SetWindowWord: Trying to set WORD of a windowproc pwnd=(%#p) index=(%ld) fnid (%lX)",
                pwnd, index, (DWORD)pwnd->fnid);
            return 0;
        } else {

            /*
             * If this is really a dialog and not some other server class
             * where usersrv has stored some data (Windows Compuserve -
             * wincim - does this) then store the data now that we have
             * verified the index limits.
             */
            if (GETFNID(pwnd) == FNID_DIALOG) {
                goto DoSetWord;
            }
        }
    }

    if (index == GWLP_USERDATA) {
        wOld = (WORD)pwnd->dwUserData;
        pwnd->dwUserData = MAKELONG(value, HIWORD(pwnd->dwUserData));
        return wOld;
    }

    // fix for RedShift, they call SetWindowWord
    // tn play with the low word of the style dword
    if (index == GWL_STYLE) {
        wOld = (WORD)pwnd->style;
        pwnd->style = MAKELONG(value, HIWORD(pwnd->style));
        return wOld;
    }

    if (GETFNID(pwnd) != 0) {
        if (index >= 0 &&
                (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
            switch (GETFNID(pwnd)) {
            case FNID_MDICLIENT:
                if (index == 0)
                    break;
                goto DoDefault;

            case FNID_BUTTON:
                /*
                 * CorelDraw, Direct Access 1.0 and WordPerfect 6.0 do a
                 * get/set on the first button window word.  Allow this
                 * for compatibility.
                 */
                if (index == 0) {
                    /*
                     *  Since we now use a lookaside buffer for the control's
                     *  private data, we need to indirect into this structure.
                     */
                    PBUTN pbutn = ((PBUTNWND)pwnd)->pbutn;
                    if (!pbutn || (LONG_PTR)pbutn == (LONG_PTR)-1) {
                        return 0;
                    } else {
                        try {
                            wOld = (WORD)ProbeAndReadUlong(&pbutn->buttonState);
                            pbutn->buttonState = value;
                        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                            wOld = 0;
                        }
                        return wOld;
                    }
                }
                goto DoDefault;

            default:
DoDefault:
                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "SetWindowWord: Trying to set private server data pwnd=(%#p) index=(%ld) fnid (%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
                break;
            }
        }
    }

DoSetWord:
    if ((index < 0) || ((UINT)index + sizeof(WORD) > (UINT)pwnd->cbwndExtra)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_WARNING,"SetWindowWord Fails because of invalid index");
        return 0;
    } else {
        WORD UNALIGNED *pw;

        pw = (WORD UNALIGNED *)((BYTE *)(pwnd + 1) + index);
        wOld = *pw;
        *pw = value;
        return (WORD)wOld;
    }
}

/***************************************************************************\
* xxxSetWindowLong (API)
*
* Set a window long.  Positive index values set application window longs
* while negative index values set system window longs.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 26-Nov-1990 DarrinM   Wrote.
\***************************************************************************/
ULONG_PTR xxxSetWindowLongPtr(
    PWND  pwnd,
    int   index,
    ULONG_PTR dwData,
    BOOL  bAnsi)
{
    ULONG_PTR dwOld;

    /*
     * The only case that leaves the critical section is where
     * xxxSetWindowData is called, which ensures that the window is locked.
     * This saves us some locks.
     *
     * Don't allow setting of words belonging to a system thread if the
     * caller is not a system thread. Same goes for winlogon.
     */
    if (!FCallerOk(pwnd)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_MSGRESULT:
                 dwOld = (ULONG_PTR)((PDIALOG)(pwnd))->resultWP;
                 ((PDIALOG)(pwnd))->resultWP = (LONG_PTR)dwData;
                 return dwOld;

            case DWLP_USER:
                 dwOld = (ULONG_PTR)((PDIALOG)(pwnd))->unused;
                 ((PDIALOG)(pwnd))->unused = (LONG_PTR)dwData;
                 return dwOld;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 && index < (int)(CBFNID(pwnd->fnid)-sizeof(WND))) {
                switch (GETFNID(pwnd)) {
                case FNID_BUTTON:
                case FNID_COMBOBOX:
                case FNID_COMBOLISTBOX:
                case FNID_DIALOG:
                case FNID_LISTBOX:
                case FNID_STATIC:
                case FNID_EDIT:
#ifdef FE_IME
                case FNID_IME:
#endif
                    /*
                     * Allow the 0 index for controls to be set if it's
                     * still NULL or the window is being destroyed. This
                     * is where controls store their private data.
                     */
                    if (index == 0) {
                        dwOld = *((PULONG_PTR)(pwnd + 1));
                        if (dwOld == 0 || TestWF(pwnd, WFDESTROYED))
                            goto SetData;
                    }
                    break;

                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     *
                     * Allow the 4 index to be set if it's still NULL or
                     * the window is being destroyed. This is where we
                     * store our private data.
                     */
#ifndef _WIN64
                    if (index == 0) {
                        goto SetData;
                    }
#endif
                    if (index == GWLP_MDIDATA) {
                        dwOld = *((PULONG_PTR)(pwnd + 1));
                        if (dwOld == 0 || TestWF(pwnd, WFDESTROYED))
                            goto SetData;
                    }
                    break;
                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "SetWindowLongPtr: Trying to set private server data pwnd=(%#p) index=(%ld) FNID=(%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        return xxxSetWindowData(pwnd, index, dwData, bAnsi);
    } else {
        if ((UINT)index + sizeof(ULONG_PTR) > (UINT)pwnd->cbwndExtra) {
            RIPERR3(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetWindowLongPtr: Index %d too big for cbWndExtra %d on pwnd %#p",
                    index, pwnd->cbwndExtra, pwnd);
            return 0;
        } else {
            ULONG_PTR UNALIGNED *pudw;

SetData:
            pudw = (ULONG_PTR UNALIGNED *)((BYTE *)(pwnd + 1) + index);
            dwOld = *pudw;
            *pudw = dwData;
            return dwOld;
        }
    }
}

#ifdef _WIN64
DWORD xxxSetWindowLong(
    PWND  pwnd,
    int   index,
    DWORD dwData,
    BOOL  bAnsi)
{
    DWORD dwOld;

    /*
     * The only case that leaves the critical section is where we call
     * xxxSetWindowData, which checks that the window is locked. This saves
     * us some locks.
     *
     * Don't allow setting of words belonging to a system thread if the
     * caller is not a system thread. Same goes for winlogon.
     */
    if (!FCallerOk(pwnd)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_MSGRESULT:
                 dwOld = (DWORD)((PDIALOG)(pwnd))->resultWP;
                 ((PDIALOG)(pwnd))->resultWP = (long)dwData;
                 return dwOld;

            case DWLP_USER:
                 dwOld = (DWORD)((PDIALOG)(pwnd))->unused;
                 ((PDIALOG)(pwnd))->unused = (long)dwData;
                 return dwOld;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     */
                    if (index == 0) {
                        goto SetData;
                    }

                    /*
                     * Allow the 4 index to be set if it's still NULL or
                     * the window is being destroyed. This is where we
                     * store our private data.
                     */
                    if (index == GWLP_MDIDATA) {
                        dwOld = *((PDWORD)(pwnd + 1));
                        if (dwOld == 0 || TestWF(pwnd, WFDESTROYED))
                            goto SetData;
                    }
                    break;
                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "SetWindowLong: Trying to set private server data pwnd=(%#p) index=(%ld) FNID=(%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        if ((index != GWL_STYLE) && (index != GWL_EXSTYLE) && (index != GWL_ID) && (index != GWLP_USERDATA)) {
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "SetWindowLong: invalid index %d", index);
            return 0;
        }
        return (DWORD)xxxSetWindowData(pwnd, index, dwData, bAnsi);
    } else {
        if ((UINT)index + sizeof(DWORD) > (UINT)pwnd->cbwndExtra) {
            RIPERR3(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetWindowLong: Index %d too big for cbWndExtra %d on pwnd %#p",
                    index, pwnd->cbwndExtra, pwnd);
            return 0;
        } else {
            DWORD UNALIGNED *pudw;

SetData:
            pudw = (DWORD UNALIGNED *)((BYTE *)(pwnd + 1) + index);
            dwOld = *pudw;
            *pudw = dwData;
            return dwOld;
        }
    }
}
#endif

/***************************************************************************\
* xxxHandleOwnerSwitch
*
\***************************************************************************/
VOID xxxHandleOwnerSwitch(
    PWND pwnd,
    PWND pwndNewParent,
    PWND pwndOldParent)
{
    CheckLock(pwnd);
    CheckLock(pwndNewParent);
    CheckLock(pwndOldParent);

    if (pwndOldParent != NULL && GETPTI(pwndOldParent) != GETPTI(pwnd)) {
        /*
         * See if it needs to be unattached.
         */
        if (pwndNewParent == NULL ||
            GETPTI(pwndNewParent) == GETPTI(pwnd) ||
            GETPTI(pwndNewParent) != GETPTI(pwndOldParent)) {
            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndOldParent), FALSE);
        }
    }

    /*
     * See if it needs to be attached.
     */
    if (pwndNewParent != NULL &&
        GETPTI(pwndNewParent) != GETPTI(pwnd) &&
        (pwndOldParent == NULL ||
            GETPTI(pwndNewParent) != GETPTI(pwndOldParent))) {
        zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndNewParent), TRUE);
    }

    /*
     * Post hook messages for tray-windows.
     */
    if (IsTrayWindow(pwnd)) {
        HWND hwnd = PtoH(pwnd);

        /*
         * If we're setting the owner and it's changing from owned to
         * unowned or vice-versa, notify the tray.
         */
        if (pwndOldParent != NULL && pwndNewParent == NULL) {
            xxxCallHook(HSHELL_WINDOWCREATED,
                        (WPARAM)hwnd,
                        (LONG)0,
                        WH_SHELL);
            PostShellHookMessages(HSHELL_WINDOWCREATED, (LPARAM)hwnd);
        } else if (pwndOldParent == NULL && pwndNewParent != NULL) {
            xxxCallHook(HSHELL_WINDOWDESTROYED,
                        (WPARAM)hwnd,
                        (LONG)0,
                        WH_SHELL);
            PostShellHookMessages(HSHELL_WINDOWDESTROYED, (LPARAM)hwnd);
        }
    }
}

/***************************************************************************\
* xxxSetWindowData
*
* SetWindowWord and ServerSetWindowLong are now identical routines because they
* both can return DWORDs.  This single routine performs the work for them both.
*
* History:
* 26-Nov-1990 DarrinM   Wrote.
\***************************************************************************/

ULONG_PTR xxxSetWindowData(
    PWND  pwnd,
    int   index,
    ULONG_PTR dwData,
    BOOL  bAnsi)
{
    ULONG_PTR dwT;
    ULONG_PTR dwOld;
    PMENU pmenu;
    PWND  *ppwnd;
    PWND  pwndNewParent;
    PWND  pwndOldParent;
    BOOL  fTopOwner;
    TL    tlpwndOld;
    TL    tlpwndNew;
    DWORD dwCPDType = 0;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    switch (index) {
    case GWLP_USERDATA:
        dwOld = pwnd->dwUserData;
        pwnd->dwUserData = dwData;
        break;

    case GWL_EXSTYLE:
    case GWL_STYLE:
        dwOld = xxxSetWindowStyle(pwnd, index, (DWORD)dwData);
        break;

    case GWLP_ID:
        /*
         * Win95 does a TestWF(pwnd, WFCHILD) here, but we'll do the same
         * check we do everywhere else or it'll cause us trouble.
         */
        if (TestwndChild(pwnd)) {

            /*
             * pwnd->spmenu is an id in this case.
             */
            dwOld = (ULONG_PTR)pwnd->spmenu;
            pwnd->spmenu = (struct tagMENU *)dwData;
        } else {
            dwOld = 0;
            if (pwnd->spmenu != NULL)
                dwOld = (ULONG_PTR)PtoH(pwnd->spmenu);

            if (dwData == 0) {
                UnlockWndMenu(pwnd, &pwnd->spmenu);
            } else {
                pmenu = ValidateHmenu((HANDLE)dwData);
                if (pmenu != NULL) {
                    LockWndMenu(pwnd, &pwnd->spmenu, pmenu);
                } else {

                    /*
                     * Menu is invalid, so don't set a new one!
                     */
                    dwOld = 0;
                }
            }
        }
        break;

    case GWLP_HINSTANCE:
        dwOld = (ULONG_PTR)pwnd->hModule;
        pwnd->hModule = (HANDLE)dwData;
        break;

    case GWLP_WNDPROC:  // See similar case DWLP_DLGPROC

        /*
         * Hide the window proc from other processes
         */
        if (PpiCurrent() != GETPTI(pwnd)->ppi) {
            RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING,
                "SetWindowLong: Window owned by another process %#p", pwnd);
            return 0;
        }

        /*
         * If the window has been zombized by a DestroyWindow but is still
         * around because the window was locked don't let anyone change
         * the window proc from DefWindowProc!
         *
         * !!! LATER long term move this test into the ValidateHWND; kind of
         * !!! LATER close to shipping for that
         */
        if (pwnd->fnid & FNID_DELETED_BIT) {
            UserAssert(pwnd->lpfnWndProc == xxxDefWindowProc);
            RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING,
                "SetWindowLong: Window is a zombie %#p", pwnd);
            return 0;
        }

        /*
         * If the application (client) subclasses a window that has a server -
         * side window proc we must return an address that the client can call:
         * this client-side wndproc expectes Unicode or ANSI depending on bAnsi
         */

        if (TestWF(pwnd, WFSERVERSIDEPROC)) {
            dwOld = MapServerToClientPfn((ULONG_PTR)pwnd->lpfnWndProc, bAnsi);

            /*
             * If we don't have a client side address (like for the DDEMLMon
             *  window) then blow off the subclassing.
             */
            if (dwOld == 0) {
                RIPMSG0(RIP_WARNING, "SetWindowLong: subclass server only window");
                return(0);
            }

            ClrWF(pwnd, WFSERVERSIDEPROC);
        } else {
            /*
             * Keep edit control behavior compatible with NT 3.51.
             */
            if (GETFNID(pwnd) == FNID_EDIT) {
                dwOld = (ULONG_PTR)MapKernelClientFnToClientFn(pwnd->lpfnWndProc);
                goto CheckAnsiUnicodeMismatch;
            } else {
                dwOld = MapClientNeuterToClientPfn(pwnd->pcls, (ULONG_PTR)pwnd->lpfnWndProc, bAnsi);
            }

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwOld == (ULONG_PTR)pwnd->lpfnWndProc) {
CheckAnsiUnicodeMismatch:
                /*
                 * May need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != (TestWF(pwnd, WFANSIPROC) ? TRUE : FALSE)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }

            UserAssert(!ISCPDTAG(dwOld));

            if (dwCPDType) {
                ULONG_PTR cpd;

                cpd = GetCPD(pwnd, dwCPDType | CPD_WND, dwOld);

                if (cpd) {
                    dwOld = cpd;
                } else {
                    RIPMSG0(RIP_WARNING, "SetWindowLong unable to alloc CPD returning handle\n");
                }
            }
        }

        /*
         * Convert a possible CallProc Handle into a real address.  They may
         * have kept the CallProc Handle from some previous mixed GetClassinfo
         * or SetWindowLong.
         *
         * WARNING bAnsi is modified here to represent real type of
         * proc rather than if SetWindowLongA or W was called
         *
         */
        if (ISCPDTAG(dwData)) {
            PCALLPROCDATA pCPD;
            if (pCPD = HMValidateHandleNoRip((HANDLE)dwData, TYPE_CALLPROC)) {
                dwData = pCPD->pfnClientPrevious;
                bAnsi = pCPD->wType & CPD_UNICODE_TO_ANSI;
            }
        }

        /*
         * If an app 'unsubclasses' a server-side window proc we need to
         * restore everything so SendMessage and friends know that it's
         * a server-side proc again.  Need to check against client side
         * stub addresses.
         */
        if ((dwT = MapClientToServerPfn(dwData)) != 0) {
            pwnd->lpfnWndProc = (WNDPROC_PWND)dwT;
            SetWF(pwnd, WFSERVERSIDEPROC);
            ClrWF(pwnd, WFANSIPROC);
        } else {
            pwnd->lpfnWndProc = (WNDPROC_PWND)MapClientNeuterToClientPfn(pwnd->pcls, dwData, bAnsi);
            if (bAnsi) {
                SetWF(pwnd, WFANSIPROC);
            } else {
                ClrWF(pwnd, WFANSIPROC);
            }

            pwnd->hMod16 = xxxClientWOWGetProcModule(pwnd->lpfnWndProc);

        }

        break;

    case GWLP_HWNDPARENT:
        /*
         * Special case for pre-1.1 versions of Windows
         * Set/GetWindowWord(GWW_HWNDPARENT) needs to be mapped
         * to the hwndOwner for top level windows.
         */
        fTopOwner = FALSE;
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            ppwnd = &pwnd->spwndOwner;
            fTopOwner = TRUE;
        } else {
            ppwnd = &pwnd->spwndParent;
        }


        /*
         * If we're a topmost, then we're only changing the owner
         * relationship.  Otherwise, we are doing a relinking of the
         * parent/child relationship.
         */
        pwndOldParent = *ppwnd;
        pwndNewParent = ValidateHwnd((HWND)dwData);

        if (pwndNewParent == NULL && dwData) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Set GWL_HWNDPARENT, invalid hwndParent 0x%p",
                    dwData);
            return 0;
        }

        dwOld = (ULONG_PTR)HW(*ppwnd);

        ThreadLock(pwndNewParent, &tlpwndNew);

        if (fTopOwner) {

            ThreadLock(pwndOldParent, &tlpwndOld);

            xxxHandleOwnerSwitch(pwnd, pwndNewParent, pwndOldParent);

            if (ValidateOwnerDepth(pwnd, pwndNewParent)) {

                /*
                 * Set the owner.
                 */
                if (pwndNewParent) {
                    Lock(ppwnd, pwndNewParent);
                } else {
                    Unlock(ppwnd);
                }
            } else {

                /*
                 * Undo the switch and set last error.
                 */
                xxxHandleOwnerSwitch(pwnd, pwndOldParent, pwndNewParent);
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_ERROR, "Detected loop in owner chain");
                dwOld = 0;
            }

            ThreadUnlock(&tlpwndOld);
        } else {
            if (!xxxSetParent(pwnd, pwndNewParent)) {
                dwOld = 0;
            }
        }

        ThreadUnlock(&tlpwndNew);
        break;

    default:
        RIPERR1(ERROR_INVALID_INDEX,
                RIP_WARNING,
                "SetWindowLong: Invalid index 0x%x",
                index);
        return 0;
    }

    return dwOld;
}

/***************************************************************************\
* FindPCPD
*
* Searches the list of CallProcData's associated with window to see if
* one already exists representing this transition.  CPD can be re-used
* and aren't deleted until a window or thread dies
*
*
* 04-Feb-1993 JohnC     Created.
\***************************************************************************/
PCALLPROCDATA FindPCPD(
    PCALLPROCDATA pCPD,
    ULONG_PTR dwClientPrevious,
    WORD wCPDType)
{
    while (pCPD) {
        if ((pCPD->pfnClientPrevious == dwClientPrevious) &&
                (pCPD->wType == wCPDType))
            return pCPD;
        pCPD = pCPD->spcpdNext;
    }

    return NULL;
}

/***************************************************************************\
* GetCPD
*
* Searches the list of CallProcData's associated with a class or window
* (if the class is not provided).  If one already exists representing this
* transition it is returned or else a new CPD is created
*
* 04-Feb-1993 JohnC     Created.
\***************************************************************************/

ULONG_PTR GetCPD(
    PVOID pWndOrCls,
    DWORD CPDOption,
    ULONG_PTR dwProc32)
{
    PCALLPROCDATA pCPD;
    PCLS          pcls;
#if DBG
    BOOL          bAnsiProc;
#endif

    PTHREADINFO ptiCurrent;

    if (CPDOption & (CPD_WND | CPD_DIALOG)) {
        UserAssert(!(CPDOption & (CPD_CLASS | CPD_WNDTOCLS)));
        pcls = ((PWND)pWndOrCls)->pcls;

#if DBG
        if (CPDOption & CPD_WND) {
            bAnsiProc = !!(TestWF(pWndOrCls, WFANSIPROC));
        } else {
            /*
             * We'll assume the client-side dialog box code knows what it's
             * doing, since we can't check it from here.
             */
            bAnsiProc = !!(CPDOption & CPD_UNICODE_TO_ANSI);
        }
#endif
    } else {
        UserAssert(CPDOption & (CPD_CLASS | CPD_WNDTOCLS));
        if (CPDOption & CPD_WNDTOCLS) {
            pcls = ((PWND)pWndOrCls)->pcls;
        } else {
            pcls = pWndOrCls;
        }
#if DBG
        bAnsiProc = !!(pcls->CSF_flags & CSF_ANSIPROC);
#endif
    }

#if DBG
    /*
     * We should never have a CallProc handle as the calling address.
     */
    UserAssert(!ISCPDTAG(dwProc32));

    if (CPDOption & CPD_UNICODE_TO_ANSI) {
        UserAssert(bAnsiProc);
    } else if (CPDOption & CPD_ANSI_TO_UNICODE) {
        UserAssert(!bAnsiProc);
    }

#endif

    /*
     * See if we already have a CallProc Handle that represents this
     * transition
     */
    pCPD = FindPCPD(pcls->spcpdFirst, dwProc32, (WORD)CPDOption);

    if (pCPD) {
        return MAKE_CPDHANDLE(PtoH(pCPD));
    }

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    pCPD = HMAllocObject(ptiCurrent,
                         ptiCurrent->rpdesk,
                         TYPE_CALLPROC,
                         sizeof(CALLPROCDATA));
    if (pCPD == NULL) {
        RIPMSG0(RIP_WARNING, "GetCPD unable to alloc CALLPROCDATA\n");
        return 0;
    }

    /*
     * Link in the new CallProcData to the class list.
     * Note -- these pointers are locked because WOWCleanup can come in
     * and delete objects, so we need to keep the pointers locked.
     */
    Lock(&pCPD->spcpdNext, pcls->spcpdFirst);
    Lock(&pcls->spcpdFirst, pCPD);

    /*
     * Initialize the CPD
     */
    pCPD->pfnClientPrevious = dwProc32;
    pCPD->wType = (WORD)CPDOption;

    return MAKE_CPDHANDLE(PtoH(pCPD));
}

/***************************************************************************\
* MapClientToServerPfn
*
* Checks to see if a dword is a client wndproc stub to a server wndproc.
* If it is, this returns the associated server side wndproc. If it isn't
* this returns 0.
*
* 13-Jan-1992 ScottLu   Created.
\***************************************************************************/
ULONG_PTR MapClientToServerPfn(
    ULONG_PTR dw)
{
    ULONG_PTR *pdw;
    int   i;

    pdw = (ULONG_PTR *)&gpsi->apfnClientW;
    for (i = FNID_WNDPROCSTART; i <= FNID_WNDPROCEND; i++, pdw++) {
        if (*pdw == dw) {
            return (ULONG_PTR)STOCID(i);
        }
    }

    pdw = (ULONG_PTR *)&gpsi->apfnClientA;
    for (i = FNID_WNDPROCSTART; i <= FNID_WNDPROCEND; i++, pdw++) {
        if (*pdw == dw) {
            return (ULONG_PTR)STOCID(i);
        }
    }

    return 0;
}

#if DBG
ULONG DBGGetWindowLong(
    PWND pwnd,
    int index)
{
    UserAssert(index >= 0);
    UserAssert((UINT)index + sizeof(DWORD) <= (UINT)pwnd->cbwndExtra);

    return __GetWindowLong(pwnd, index);
}

ULONG_PTR DBGGetWindowLongPtr(
    PWND pwnd,
    int index)
{
    UserAssert(index >= 0);
    UserAssert((UINT)index + sizeof(ULONG_PTR) <= (UINT)pwnd->cbwndExtra);

    return __GetWindowLongPtr(pwnd, index);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\hidevice.c ===
/****************************** Module Header ******************************\
* Module Name: hidevice.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* This module handles HID inputs
*
* History:
* 2000-02-16   HiroYama
\***************************************************************************/



/*
 * HidDeviceStartStop() needs to be called after both the process devlice request list
 * and the global TLC list are fully updated.
 * Each deletion of addition should only recalc the reference count of each devicetype info
 * and UsagePage-only req-list, but does not actively changes the actual read state of
 * each device.
 *
 * The device should start if:
 * - cDirectRequest > 0.
 *   This device type is in the inclusion list, so no matter the other ref counts are,
 *   the device needs to be read.
 * - or, cUsagePageRequest > cExcludeRequest
 *   if UsagePage inclusion exceeds the exclude request count, this device needs to be read.
 *
 * The device should stop if:
 * - uDrecoutRequest == 0 && cUsagePageRequest <= cExcludeRequest
 *   No process specifies this device in the inclusion list.
 *   Exclude count exceeds the UP only request.
 *
 * The above consideration assumes, in a single process, specific UsagePage/Usage only appears
 * either in inclusion list or exclusion list, but not both.
 *
 * N.b. No need to maintain the global *exclusion* list.
 * Each DeviceTLCInfo has three ref counter:
 *   - cDirectRequest
 *   - cUsagePageRequest
 *   - cExcludeRequest
 * plus, cDevices.
 *
 * N.b. Legit number of exclusive requests in TLCInfo is,
 * cExclusive - cExclusiveOrphaned.
 *
 */

#include "precomp.h"
#pragma hdrstop



#ifdef GENERIC_INPUT

#define API_PROLOGUE(type, err) \
    type retval; \
    type errval = err

#define API_ERROR(lasterr) \
    retval = errval; \
    if (lasterr) { \
        UserSetLastError(lasterr); \
    } \
    goto error_exit

#define API_CLEANUP() \
    goto error_exit; \
    error_exit: \

#define API_EPILOGUE() \
    return retval

#define StubExceptionHandler(fSetLastError)  W32ExceptionHandler((fSetLastError), RIP_WARNING)


#ifdef GI_SINK
HID_COUNTERS gHidCounters;
#endif

#if DBG
/*
 * Quick sneaky way for the memory leak check.
 */
struct HidAllocateCounter {
    int cHidData;
    int cHidDesc;
    int cTLCInfo;
    int cPageOnlyRequest;
    int cProcessDeviceRequest;
    int cProcessRequestTable;
    int cHidSinks;
    int cKbdSinks;
    int cMouseSinks;
} gHidAllocCounters;

int gcAllocHidTotal;

#define DbgInc(a)       do { UserAssert(gHidAllocCounters.a >= 0 && gcAllocHidTotal >= 0); ++gHidAllocCounters.a; ++gcAllocHidTotal; } while (FALSE)
#define DbgDec(a)       do { --gHidAllocCounters.a; --gcAllocHidTotal; UserAssert(gHidAllocCounters.a >= 0 && gcAllocHidTotal >= 0); } while (FALSE)

#define DbgFreInc(a)    do { DbgInc(a); ++gHidCounters.a; } while (FALSE)
#define DbgFreDec(a)    do { DbgDec(a); --gHidCounters.a; } while (FALSE)

#else

#define DbgInc(a)
#define DbgDec(a)

#define DbgFreInc(a)    do { ++gHidCounters.a; } while (FALSE)
#define DbgFreDec(a)    do { --gHidCounters.a; } while (FALSE)

#endif


/*
 * Short helpers
 */
__inline BOOL IsKeyboardDevice(USAGE usagePage, USAGE usage)
{
    return usagePage == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_KEYBOARD;
}

__inline BOOL IsMouseDevice(USAGE usagePage, USAGE usage)
{
    return usagePage == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_MOUSE;
}

__inline BOOL IsLegacyDevice(USAGE usagePage, USAGE usage)
{
    BOOL fRet = FALSE;

    switch (usagePage) {
    case HID_USAGE_PAGE_GENERIC:
        switch (usage) {
        case HID_USAGE_GENERIC_KEYBOARD:
        case HID_USAGE_GENERIC_MOUSE:
            fRet = TRUE;
        }
    }
    UserAssert(fRet == (IsKeyboardDevice(usagePage, usage) || IsMouseDevice(usagePage, usage)));
    return fRet;
}

/*
 * Debug helpers
 */
#if DBG
/***************************************************************************\
* CheckupHidLeak
*
* Check if there is any leaked memory.
* This one should be called after the pDeviceInfo and all process cleanup.
\***************************************************************************/
void CheckupHidLeak(void)
{
    UserAssert(gHidAllocCounters.cHidData == 0);
    UserAssert(gHidAllocCounters.cHidDesc == 0);
    UserAssert(gHidAllocCounters.cTLCInfo == 0);
    UserAssert(gHidAllocCounters.cPageOnlyRequest == 0);
    UserAssert(gHidAllocCounters.cProcessDeviceRequest == 0);
    UserAssert(gHidAllocCounters.cProcessRequestTable == 0);

#ifdef GI_SINK
    UserAssert(gHidCounters.cKbdSinks == (DWORD)gHidAllocCounters.cKbdSinks);
    UserAssert(gHidCounters.cMouseSinks == (DWORD)gHidAllocCounters.cMouseSinks);
    UserAssert(gHidCounters.cHidSinks == (DWORD)gHidAllocCounters.cHidSinks);

    UserAssert(gHidAllocCounters.cKbdSinks == 0);
    UserAssert(gHidAllocCounters.cMouseSinks == 0);
    UserAssert(gHidAllocCounters.cHidData == 0);

    UserAssert(gHidCounters.cKbdSinks == 0);
    UserAssert(gHidCounters.cMouseSinks == 0);
    UserAssert(gHidCounters.cHidSinks == 0);
#endif
}

void CheckupHidCounter(void)
{
    PLIST_ENTRY pList;

    UserAssert(gHidAllocCounters.cHidData >= 0);
    UserAssert(gHidAllocCounters.cHidDesc >= 0);
    UserAssert(gHidAllocCounters.cTLCInfo >= 0);
    UserAssert(gHidAllocCounters.cPageOnlyRequest >= 0);
    UserAssert(gHidAllocCounters.cProcessDeviceRequest >= 0);
    UserAssert(gHidAllocCounters.cProcessRequestTable >= 0);

#ifdef GI_SINK
    UserAssert(gHidCounters.cKbdSinks == (DWORD)gHidAllocCounters.cKbdSinks);
    UserAssert(gHidCounters.cMouseSinks == (DWORD)gHidAllocCounters.cMouseSinks);
    UserAssert(gHidCounters.cHidSinks == (DWORD)gHidAllocCounters.cHidSinks);

    UserAssert((int)gHidAllocCounters.cKbdSinks >= 0);
    UserAssert((int)gHidAllocCounters.cMouseSinks >= 0);
    UserAssert((int)gHidAllocCounters.cHidData >= 0);

    UserAssert((int)gHidCounters.cKbdSinks >= 0);
    UserAssert((int)gHidCounters.cMouseSinks >= 0);
    UserAssert((int)gHidCounters.cHidSinks >= 0);
#endif

    /*
     * Checkup TLC Info
     */
    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList; pList = pList->Flink) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        UserAssert((int)pTLCInfo->cDevices >= 0);
        UserAssert((int)pTLCInfo->cDirectRequest >= 0);
        UserAssert((int)pTLCInfo->cUsagePageRequest >= 0);
        UserAssert((int)pTLCInfo->cExcludeRequest >= 0);
        UserAssert((int)pTLCInfo->cExcludeOrphaned >= 0);
    }

#ifdef GI_SINK
    /*
     * Checkup process request tables.
     */
    for (pList = gHidRequestTable.ProcessRequestList.Flink; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
        PPROCESS_HID_TABLE pHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);

        UserAssert((int)pHidTable->nSinks >= 0);
    }
#endif
}

/***************************************************************************\
* DBGValidateHidRequestIsNew
*
* Make sure there's no deviceinfo that has this UsagePage/Usage.
\***************************************************************************/
void DBGValidateHidRequestIsNew(
    USAGE UsagePage,
    USAGE Usage)
{
    PDEVICEINFO pDeviceInfo;

    CheckDeviceInfoListCritIn();

    if (IsLegacyDevice(UsagePage, Usage)) {
        return;
    }

    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            UserAssert(pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage != UsagePage ||
                       pDeviceInfo->hid.pHidDesc->hidpCaps.Usage != Usage);
        }
    }
}

/***************************************************************************\
* DBGValidateHidReqNotInList
*
* Make sure this request is not in ppi->pHidTable
\***************************************************************************/
void DBGValidateHidReqNotInList(
    PPROCESSINFO ppi,
    PPROCESS_HID_REQUEST pHid)
{
    PLIST_ENTRY pList;

    for (pList = ppi->pHidTable->InclusionList.Flink; pList != &ppi->pHidTable->InclusionList; pList = pList->Flink) {
        const PPROCESS_HID_REQUEST pHidTmp = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid != pHidTmp);
    }

    for (pList = ppi->pHidTable->UsagePageList.Flink; pList != &ppi->pHidTable->UsagePageList; pList = pList->Flink) {
        const PPROCESS_HID_REQUEST pHidTmp = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid != pHidTmp);
    }

    for (pList = ppi->pHidTable->ExclusionList.Flink; pList != &ppi->pHidTable->ExclusionList; pList = pList->Flink) {
        const PPROCESS_HID_REQUEST pHidTmp = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid != pHidTmp);
    }
}

#else
/*
 * NOT DBG
 */
#define CheckupHidCounter()
#define DBGValidateHidReqNotInList(ppi, pHid)
#endif  // DBG



/*
 * Function prototypes
 */
PHID_PAGEONLY_REQUEST SearchHidPageOnlyRequest(
    USHORT usUsagePage);

PHID_TLC_INFO SearchHidTLCInfo(
    USHORT usUsagePage,
    USHORT usUsage);

void FreeHidPageOnlyRequest(
    PHID_PAGEONLY_REQUEST pPOReq);

void ClearProcessTableCache(
    PPROCESS_HID_TABLE pHidTable);

/***************************************************************************\
* HidDeviceTypeNoReference
\***************************************************************************/
__inline BOOL HidTLCInfoNoReference(PHID_TLC_INFO pTLCInfo)
{
    /*
     * Orphaned Exclusive requests are always less then cExclusive.
     */
    UserAssert(pTLCInfo->cExcludeRequest >= pTLCInfo->cExcludeOrphaned);

    /*
     * Hacky, but a bit faster than comparing 0 with each counter.
     */
    return (pTLCInfo->cDevices | pTLCInfo->cDirectRequest | pTLCInfo->cExcludeRequest | pTLCInfo->cUsagePageRequest) == 0;
}

/***************************************************************************\
* HidDeviceStartStop:
*
* This routine has to be called after the global request list is fully updated.
\***************************************************************************/
VOID HidDeviceStartStop()
{
    PDEVICEINFO pDeviceInfo;

    /*
     * The caller has to ensure being in the device list critical section.
     */
    CheckDeviceInfoListCritIn();

    /*
     * Walk through the list, and start or stop the HID device accordingly.
     */
    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            PHID_TLC_INFO pTLCInfo = pDeviceInfo->hid.pTLCInfo;

            UserAssert(pTLCInfo);

            if (HidTLCActive(pTLCInfo)) {
                if (pDeviceInfo->handle == 0) {
                    TAGMSG3(DBGTAG_PNP, "HidTLCActive: starting pDevInfo=%p (%x, %x)", pDeviceInfo,
                            pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage, pDeviceInfo->hid.pHidDesc->hidpCaps.Usage);
                    RequestDeviceChange(pDeviceInfo, GDIAF_STARTREAD, TRUE);
                }
            } else {
                UserAssert(pTLCInfo->cDirectRequest == 0 && pTLCInfo->cUsagePageRequest <= HidValidExclusive(pTLCInfo));
                if (pDeviceInfo->handle) {
                    TAGMSG3(DBGTAG_PNP, "HidTLCActive: stopping pDevInfo=%p (%x, %x)", pDeviceInfo,
                            pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage, pDeviceInfo->hid.pHidDesc->hidpCaps.Usage);
                    RequestDeviceChange(pDeviceInfo, GDIAF_STOPREAD, TRUE);
                }
            }
        }
    }
}

/***************************************************************************\
* AllocateAndLinkHidTLCInfo
*
* Allocates DeviceTypeRequest and link it to the global device type request list.
*
* N.b. the caller has the responsibility to manage the appropriate link count.
\***************************************************************************/
PHID_TLC_INFO AllocateAndLinkHidTLCInfo(USHORT usUsagePage, USHORT usUsage)
{
    PHID_TLC_INFO pTLCInfo;
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    UserAssert(!IsLegacyDevice(usUsagePage, usUsage));

    /*
     * Make sure this device type is not in the global device request list.
     */
    UserAssert(SearchHidTLCInfo(usUsagePage, usUsage) == NULL);

    pTLCInfo = UserAllocPoolZInit(sizeof *pTLCInfo, TAG_PNP);
    if (pTLCInfo == NULL) {
        RIPMSG0(RIP_WARNING, "AllocateAndLinkHidTLCInfoList: failed to allocate.");
        return NULL;
    }

    DbgInc(cTLCInfo);

    pTLCInfo->usUsagePage = usUsagePage;
    pTLCInfo->usUsage = usUsage;

    /*
     * Link it in.
     */
    InsertHeadList(&gHidRequestTable.TLCInfoList, &pTLCInfo->link);

    /*
     * Set the correct counter of UsagePage-only request.
     */
    for (pList = gHidRequestTable.UsagePageList.Flink; pList != &gHidRequestTable.UsagePageList; pList = pList->Flink) {
        PHID_PAGEONLY_REQUEST pPoReq = CONTAINING_RECORD(pList, HID_PAGEONLY_REQUEST, link);

        if (pPoReq->usUsagePage == usUsagePage) {
            pTLCInfo->cUsagePageRequest = pPoReq->cRefCount;
            break;
        }
    }

    /*
     * The caller is responsible for the further actions, including:
     * 1) increments appropriate refcount in this strucutre, or
     * 2) check & start read if this is allocated though the SetRawInputDevice API.
     * etc.
     */

    return pTLCInfo;
}

/***************************************************************************\
* FreeHidTLCInfo.
*
* Make sure that no one is interested in this device type before
* calling this function.
\***************************************************************************/
VOID FreeHidTLCInfo(PHID_TLC_INFO pTLCInfo)
{
    CheckDeviceInfoListCritIn();

    DbgDec(cTLCInfo);

    UserAssert(pTLCInfo->cDevices == 0);
    UserAssert(pTLCInfo->cDirectRequest == 0);
    UserAssert(pTLCInfo->cUsagePageRequest == 0);
    UserAssert(pTLCInfo->cExcludeRequest == 0);
    UserAssert(pTLCInfo->cExcludeOrphaned == 0);

    RemoveEntryList(&pTLCInfo->link);

    UserFreePool(pTLCInfo);
}

/***************************************************************************\
* SearchHidTLCInfo
*
* Simply searches the UsagePage/Usage in the global device type request list.
\***************************************************************************/
PHID_TLC_INFO SearchHidTLCInfo(USHORT usUsagePage, USHORT usUsage)
{
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList; pList = pList->Flink) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        UserAssert(!IsLegacyDevice(pTLCInfo->usUsagePage, pTLCInfo->usUsage));

        if (pTLCInfo->usUsagePage == usUsagePage && pTLCInfo->usUsage == usUsage) {
            return pTLCInfo;
        }
    }

    return NULL;
}


/***************************************************************************\
* FixupHidPageOnlyRequest
*
* After the page-only request is freed, fix up the reference counter in
* DeviceTypeRequest. If there's no reference, this function also frees
* the DeviceTypeRequest.
\***************************************************************************/
void SetHidPOCountToTLCInfo(USHORT usUsagePage, DWORD cRefCount, BOOL fFree)
{
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    fFree = (fFree && cRefCount == 0);

    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList;) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        pList = pList->Flink;

        if (pTLCInfo->usUsagePage == usUsagePage) {
            pTLCInfo->cUsagePageRequest = cRefCount;
            if (fFree && HidTLCInfoNoReference(pTLCInfo)) {
                /*
                 * Currently there's no devices of this type attached to the system,
                 * and nobody is interested in this type of device any more.
                 * We can free it now.
                 */
                FreeHidTLCInfo(pTLCInfo);
            }
        }
    }
}

/***************************************************************************\
* AllocateAndLinkHidPageOnlyRequest
*
* Allocates the page-only request and link it in the global request list.
* The caller is responsible for setting the proper link count.
\***************************************************************************/
PHID_PAGEONLY_REQUEST AllocateAndLinkHidPageOnlyRequest(USHORT usUsagePage)
{
    PHID_PAGEONLY_REQUEST pPOReq;

    CheckDeviceInfoListCritIn();

    /*
     * Make sure this PageOnly request is not in the global PageOnly request list.
     */
    UserAssert((pPOReq = SearchHidPageOnlyRequest(usUsagePage)) == NULL);

    pPOReq = UserAllocPoolZInit(sizeof(*pPOReq), TAG_PNP);
    if (pPOReq == NULL) {
        RIPMSG0(RIP_WARNING, "AllocateAndLinkHidPageOnlyRequest: failed to allocate.");
        return NULL;
    }

    DbgInc(cPageOnlyRequest);

    pPOReq->usUsagePage = usUsagePage;

    /*
     * Link it in
     */
    InsertHeadList(&gHidRequestTable.UsagePageList, &pPOReq->link);

    return pPOReq;
}

/***************************************************************************\
* FreeHidPageOnlyRequest
*
* Frees the page-only request in the global request list.
* The caller is responsible for setting the proper link count.
\***************************************************************************/
void FreeHidPageOnlyRequest(PHID_PAGEONLY_REQUEST pPOReq)
{
    CheckDeviceInfoListCritIn();

    UserAssert(pPOReq->cRefCount == 0);

    RemoveEntryList(&pPOReq->link);

    UserFreePool(pPOReq);

    DbgDec(cPageOnlyRequest);
}

/***************************************************************************\
* SearchHidPageOnlyRequest
*
* Searches the page-only request in the global request list.
* The caller is responsible for setting the proper link count.
\***************************************************************************/
PHID_PAGEONLY_REQUEST SearchHidPageOnlyRequest(USHORT usUsagePage)
{
    PLIST_ENTRY pList;

    for (pList = gHidRequestTable.UsagePageList.Flink; pList != &gHidRequestTable.UsagePageList; pList = pList->Flink) {
        PHID_PAGEONLY_REQUEST pPOReq = CONTAINING_RECORD(pList, HID_PAGEONLY_REQUEST, link);

        if (pPOReq->usUsagePage == usUsagePage) {
            return pPOReq;
        }
    }

    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequestInclusion
*
* Searches specific TLC in the per-process inclusion request.
\***************************************************************************/
__inline PPROCESS_HID_REQUEST SearchProcessHidRequestInclusion(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage,
    USHORT usUsage)
{
    PLIST_ENTRY pList;

    UserAssert(pHidTable);  // the caller has to validate this

    for (pList = pHidTable->InclusionList.Flink; pList != &pHidTable->InclusionList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        if (pHid->usUsagePage == usUsagePage && pHid->usUsage == usUsage) {
            return pHid;
        }
    }
    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequestUsagePage
*
* Searches specific page-only TLC in the per-process page-only request.
\***************************************************************************/
__inline PPROCESS_HID_REQUEST SearchProcessHidRequestUsagePage(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage)
{
    PLIST_ENTRY pList;

    UserAssert(pHidTable);  // the caller has to validate this

    for (pList = pHidTable->UsagePageList.Flink; pList != &pHidTable->UsagePageList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        if (pHid->usUsagePage == usUsagePage /*&& pHid->usUsage == usUsage*/) {
            return pHid;
        }
    }
    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequestExclusion
*
* Searches specifc TLC in the per-process exclusion list.
\***************************************************************************/
__inline PPROCESS_HID_REQUEST SearchProcessHidRequestExclusion(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage,
    USHORT usUsage)
{
    PLIST_ENTRY pList;

    UserAssert(pHidTable);  // the caller has to validate this

    for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid->spwndTarget == NULL);

        if (pHid->usUsagePage == usUsagePage && pHid->usUsage == usUsage) {
            return pHid;
        }
    }
    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequest
*
* Search per-process HID request list
*
* Returns the pointer and the flag to indicate which list the request is in.
* N.b. this function performs the simple search, should not be used
* to judge whether or not the TLC is requested by the process.
\***************************************************************************/
PPROCESS_HID_REQUEST SearchProcessHidRequest(
    PPROCESSINFO ppi,
    USHORT usUsagePage,
    USHORT usUsage,
    PDWORD pdwFlags
    )
{
    PPROCESS_HID_REQUEST pReq;

    if (ppi->pHidTable == NULL) {
        return NULL;
    }

    pReq = SearchProcessHidRequestInclusion(ppi->pHidTable, usUsagePage, usUsage);
    if (pReq) {
        *pdwFlags = HID_INCLUDE;
        return pReq;
    }

    if (usUsage == 0) {
        pReq = SearchProcessHidRequestUsagePage(ppi->pHidTable, usUsagePage);
        if (pReq) {
            *pdwFlags = HID_PAGEONLY;
            return pReq;
        }
    }

    pReq = SearchProcessHidRequestExclusion(ppi->pHidTable, usUsagePage, usUsage);
    if (pReq) {
        *pdwFlags = HID_EXCLUDE;
        return pReq;
    }

    *pdwFlags = 0;

    return NULL;
}

/***************************************************************************\
* InProcessDeviceTypeRequestTable
*
* Check if the device type is in the per-process device request list.
* This routine considers the returns TRUE if UsagePage/Usage is requested
* by the process.
\***************************************************************************/
PPROCESS_HID_REQUEST InProcessDeviceTypeRequestTable(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage,
    USHORT usUsage)
{
    PPROCESS_HID_REQUEST phr = NULL;
    PPROCESS_HID_REQUEST phrExclusive = NULL;
    UserAssert(pHidTable);

    /*
     * Firstly check if this is in the inclusion list.
     */
    if ((phr = SearchProcessHidRequestInclusion(pHidTable, usUsagePage, usUsage)) != NULL) {
        if (CONTAINING_RECORD(pHidTable->InclusionList.Flink, PROCESS_HID_REQUEST, link) != phr) {
            /*
             * Relink this phr to the list head for MRU list
             */
            RemoveEntryList(&phr->link);
            InsertHeadList(&pHidTable->InclusionList, &phr->link);
        }
        goto yes_this_is_requested;
    }

    /*
     * Secondly, check if this is in the UsagePage list.
     */
    if ((phr = SearchProcessHidRequestUsagePage(pHidTable, usUsagePage)) == NULL) {
        /*
         * If this UsagePage is not requested, we don't need
         * to process the input.
         */
        return NULL;
    }
    if (CONTAINING_RECORD(pHidTable->UsagePageList.Flink, PROCESS_HID_REQUEST, link) != phr) {
        /*
         * Relink this phr to the list head for MRU list
         */
        RemoveEntryList(&phr->link);
        InsertHeadList(&pHidTable->UsagePageList, &phr->link);
    }

    /*
     * Lastly, check the exclusion list.
     * If it's not in the exclusion list, this device is
     * considered as requested by this process.
     */
    if ((phrExclusive = SearchProcessHidRequestExclusion(pHidTable, usUsagePage, usUsage)) != NULL) {
        /*
         * The device in the UsagePage request, but
         * rejected as in the Exclusion list.
         */
        if (CONTAINING_RECORD(pHidTable->ExclusionList.Flink, PROCESS_HID_REQUEST, link) != phrExclusive) {
            /*
             * Relink this phr to the list head for MRU list
             */
            RemoveEntryList(&phrExclusive->link);
            InsertHeadList(&pHidTable->ExclusionList, &phrExclusive->link);
        }
        return NULL;
    }

yes_this_is_requested:
    UserAssert(phr);
    /*
     * The device is in UsagePage list, and is not rejected by exslucion list.
     */
    return phr;
}

/***************************************************************************\
* AllocateHidProcessRequest
*
* The caller has the responsibility to put this in the appropriate list.
\***************************************************************************/
PPROCESS_HID_REQUEST AllocateHidProcessRequest(
    USHORT usUsagePage,
    USHORT usUsage)
{
    PPROCESS_HID_REQUEST pHidReq;

    pHidReq = UserAllocPoolWithQuota(sizeof(PROCESS_HID_REQUEST), TAG_PNP);
    if (pHidReq == NULL) {
        return NULL;
    }

    DbgInc(cProcessDeviceRequest);

    /*
     * Initialize the contents
     */
    pHidReq->usUsagePage = usUsagePage;
    pHidReq->usUsage = usUsage;
    pHidReq->ptr = NULL;
    pHidReq->spwndTarget = NULL;
    pHidReq->fExclusiveOrphaned = FALSE;
#ifdef GI_SINK
    pHidReq->fSinkable = FALSE;
#endif

    return pHidReq;
}


/***************************************************************************\
* DerefIncludeRequest
*
\***************************************************************************/
void DerefIncludeRequest(
    PPROCESS_HID_REQUEST pHid,
    PPROCESS_HID_TABLE pHidTable,
    BOOL fLegacyDevice,
    BOOL fFree)
{
    if (fLegacyDevice) {
        /*
         * Legacy devices are not associated with TLCInfo.
         */
        UserAssert(pHid->pTLCInfo == NULL);

        // N.b. NoLegacy flag is set afterwards
        /*
         * If mouse is being removed, clear the captureMouse
         * flag.
         */
        if (pHidTable->fCaptureMouse) {
            if (IsMouseDevice(pHid->usUsagePage, pHid->usUsage)) {
                pHidTable->fCaptureMouse = FALSE;
            }
        }
        if (pHidTable->fNoHotKeys) {
            if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage)) {
                pHidTable->fNoHotKeys = FALSE;
            }
        }
        if (pHidTable->fAppKeys) {
            if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage)) {
                pHidTable->fAppKeys = FALSE;
            }
        }
    } else {
        /*
         * HID devices.
         * Decrement the counters in HidDeviceTypeRequest.
         */
        UserAssert(pHid->pTLCInfo);
        UserAssert(pHid->pTLCInfo == SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage));

        if (--pHid->pTLCInfo->cDirectRequest == 0 && fFree) {
            if (HidTLCInfoNoReference(pHid->pTLCInfo)) {
                /*
                 * Currently there's no devices of this type attached to the system,
                 * and nobody is interested in this type of device any more.
                 * We can free it now.
                 */
                FreeHidTLCInfo(pHid->pTLCInfo);
            }
        }
    }

#ifdef GI_SINK
    if (pHid->fSinkable) {
        pHid->fSinkable = FALSE;
        if (!fLegacyDevice) {
            --pHidTable->nSinks;
            UserAssert(pHidTable->nSinks >= 0); // LATER: when nSinks is changed to DWORD, remove those assertions
            DbgFreDec(cHidSinks);
        }
    }
#endif
}

/***************************************************************************\
* DerefPageOnlyRequest
*
\***************************************************************************/
void DerefPageOnlyRequest(
    PPROCESS_HID_REQUEST pHid,
    PPROCESS_HID_TABLE pHidTable,
    const BOOL fFree)
{
    /*
     * Decrement the ref count in the global pageonly list.
     */
    UserAssert(pHid->pPORequest);
    UserAssert(pHid->pPORequest == SearchHidPageOnlyRequest(pHid->usUsagePage));
    UserAssert(pHid->usUsage == 0);
    UserAssert(!IsLegacyDevice(pHid->usUsagePage, pHid->usUsage));
    UserAssert(pHid->pPORequest->cRefCount >= 1);

    --pHid->pPORequest->cRefCount;
    /*
     * Update the POCount in TLCInfo. Does not free them if fFree is false.
     */
    SetHidPOCountToTLCInfo(pHid->usUsagePage, pHid->pPORequest->cRefCount, fFree);

    /*
     * If refcount is 0 and the caller wants it freed, do it now.
     */
    if (pHid->pPORequest->cRefCount == 0 && fFree) {
        FreeHidPageOnlyRequest(pHid->pPORequest);
        pHid->pPORequest = NULL;
    }
#ifdef GI_SINK
    if (pHid->fSinkable) {
        pHid->fSinkable = FALSE;
        --pHidTable->nSinks;
        UserAssert(pHidTable->nSinks >= 0);
        DbgFreDec(cHidSinks);
    }
    /*
     * The legacy sink flags in pHidTable is calc'ed later.
     */
#endif
}

/***************************************************************************\
* DerefExcludeRequest
*
\***************************************************************************/
void DerefExcludeRequest(
    PPROCESS_HID_REQUEST pHid,
    BOOL fLegacyDevice,
    BOOL fFree)
{
    /*
     * Remove Exclude request.
     */
#ifdef GI_SINK
    UserAssert(pHid->fSinkable == FALSE);
    UserAssert(pHid->spwndTarget == NULL);
#endif
    if (!fLegacyDevice) {
        UserAssert(pHid->pTLCInfo);
        UserAssert(pHid->pTLCInfo == SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage));

        if (pHid->fExclusiveOrphaned) {
            /*
             * This is a orphaned exclusive request.
             */
            --pHid->pTLCInfo->cExcludeOrphaned;
        }
        if (--pHid->pTLCInfo->cExcludeRequest == 0 && fFree && HidTLCInfoNoReference(pHid->pTLCInfo)) {
            /*
             * If all the references are gone, let's free this TLCInfo.
             */
            FreeHidTLCInfo(pHid->pTLCInfo);
        }
    } else {
        /*
         * Legacy devices are not associated with TLCInfo.
         */
        UserAssert(pHid->pTLCInfo == NULL);
        /*
         * Legacy devices cannot be orphaned exclusive request.
         */
        UserAssert(pHid->fExclusiveOrphaned == FALSE);
    }
}

/***************************************************************************\
* FreeHidProcessRequest
*
* Frees the per-process request.
* This routine only manupilates the reference count of the global request list, so
* the caller has to call HidDeviceStartStop().
\***************************************************************************/
void FreeHidProcessRequest(
    PPROCESS_HID_REQUEST pHid,
    DWORD dwFlags,
    PPROCESS_HID_TABLE pHidTable)
{
    BOOL fLegacyDevice = IsLegacyDevice(pHid->usUsagePage, pHid->usUsage);

    CheckDeviceInfoListCritIn();    // the caller has to ensure it's in the device list crit.

    /*
     * Unlock the target window.
     */
    Unlock(&pHid->spwndTarget);

    if (dwFlags == HID_INCLUDE) {
        DerefIncludeRequest(pHid, pHidTable, fLegacyDevice, TRUE);
    } else if (dwFlags == HID_PAGEONLY) {
        DerefPageOnlyRequest(pHid, pHidTable, TRUE);
    } else if (dwFlags == HID_EXCLUDE) {
        DerefExcludeRequest(pHid, fLegacyDevice, TRUE);
    } else {
        UserAssert(FALSE);
    }

    RemoveEntryList(&pHid->link);

    DbgDec(cProcessDeviceRequest);

    CheckupHidCounter();

    UserFreePool(pHid);
}

/***************************************************************************\
* AllocateProcessHidTable
*
* The caller has to assign the returned table to ppi.
\***************************************************************************/
PPROCESS_HID_TABLE AllocateProcessHidTable(void)
{
    PPROCESS_HID_TABLE pHidTable;

    TAGMSG1(DBGTAG_PNP, "AllocateProcessHidTable: ppi=%p", PpiCurrent());

    pHidTable = UserAllocPoolWithQuotaZInit(sizeof *pHidTable, TAG_PNP);
    if (pHidTable == NULL) {
        return NULL;
    }

    DbgInc(cProcessRequestTable);

    InitializeListHead(&pHidTable->InclusionList);
    InitializeListHead(&pHidTable->UsagePageList);
    InitializeListHead(&pHidTable->ExclusionList);

#ifdef GI_SINK
    InsertHeadList(&gHidRequestTable.ProcessRequestList, &pHidTable->link);
#endif

    /*
     * Increment the number of process that are HID aware.
     * When the process goes away, this gets decremented.
     */
    ++gnHidProcess;

    return pHidTable;
}

/***************************************************************************\
* FreeProcesHidTable
*
\***************************************************************************/
void FreeProcessHidTable(PPROCESS_HID_TABLE pHidTable)
{
    BOOL fUpdate;
    UserAssert(pHidTable);

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    TAGMSG2(DBGTAG_PNP, "FreeProcessHidTable: cleaning up pHidTable=%p (possibly ppi=%p)", pHidTable, PpiCurrent());

    fUpdate = !IsListEmpty(&pHidTable->InclusionList) || !IsListEmpty(&pHidTable->UsagePageList) || !IsListEmpty(&pHidTable->ExclusionList);

    /*
     * Unlock the target window for legacy devices.
     */
    Unlock(&pHidTable->spwndTargetKbd);
    Unlock(&pHidTable->spwndTargetMouse);

    while (!IsListEmpty(&pHidTable->InclusionList)) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pHidTable->InclusionList.Flink, PROCESS_HID_REQUEST, link);
        FreeHidProcessRequest(pHid, HID_INCLUDE, pHidTable);
    }

    while (!IsListEmpty(&pHidTable->UsagePageList)) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pHidTable->UsagePageList.Flink, PROCESS_HID_REQUEST, link);
        FreeHidProcessRequest(pHid, HID_PAGEONLY, pHidTable);
    }

    while (!IsListEmpty(&pHidTable->ExclusionList)) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pHidTable->ExclusionList.Flink, PROCESS_HID_REQUEST, link);
        UserAssert(pHid->spwndTarget == NULL);
        FreeHidProcessRequest(pHid, HID_EXCLUDE, pHidTable);
    }

#ifdef GI_SINK
    UserAssert(pHidTable->nSinks == 0);
    RemoveEntryList(&pHidTable->link);

    /*
     * Those flags should have been cleared on the
     * thread destruction.
     */
    UserAssert(pHidTable->fRawKeyboardSink == FALSE);
    UserAssert(pHidTable->fRawMouseSink == FALSE);
    CheckupHidCounter();
#endif

    UserFreePool(pHidTable);

    /*
     * Decrement the number of process that are HID aware.
     */
    --gnHidProcess;

    DbgDec(cProcessRequestTable);

    if (fUpdate) {
        HidDeviceStartStop();
    }
}


/***************************************************************************\
* DestroyProcessHidRequests
*
* Upon process termination, force destroy process hid requests.
\***************************************************************************/
void DestroyProcessHidRequests(PPROCESSINFO ppi)
{
    PPROCESS_HID_TABLE pHidTable;

    CheckCritIn();
    EnterDeviceInfoListCrit();

#if DBG
    /*
     * Check out if there's a pwndTarget in the HidTable list.
     * These should be unlocked by the time the last
     * threadinfo is destroyed.
     */
    UserAssert(ppi->pHidTable->spwndTargetMouse == NULL);
    UserAssert(ppi->pHidTable->spwndTargetKbd == NULL);

#ifdef GI_SINK
    UserAssert(ppi->pHidTable->fRawKeyboardSink == FALSE);
    UserAssert(ppi->pHidTable->fRawMouseSink == FALSE);
#endif

    {
        PPROCESS_HID_TABLE pHidTableTmp = ppi->pHidTable;
        PLIST_ENTRY pList;

        for (pList = pHidTableTmp->InclusionList.Flink; pList != &pHidTableTmp->InclusionList; pList = pList->Flink) {
            PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

            UserAssert(pHid->spwndTarget == NULL);
        }

        for (pList = pHidTableTmp->UsagePageList.Flink; pList != &pHidTableTmp->UsagePageList; pList = pList->Flink) {
            PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

            UserAssert(pHid->spwndTarget == NULL);
        }

        for (pList = pHidTableTmp->ExclusionList.Flink; pList != &pHidTableTmp->ExclusionList; pList = pList->Flink) {
            PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

            UserAssert(pHid->spwndTarget == NULL);
        }
    }
#endif
    pHidTable = ppi->pHidTable;
    ppi->pHidTable = NULL;
    FreeProcessHidTable(pHidTable);
    LeaveDeviceInfoListCrit();
}

/***************************************************************************\
* DestroyThreadHidObjects
*
* When a thread is going away, destroys thread-related Hid objects.
\***************************************************************************/
void DestroyThreadHidObjects(PTHREADINFO pti)
{
    PPROCESS_HID_TABLE pHidTable = pti->ppi->pHidTable;
    PLIST_ENTRY pList;

    UserAssert(pHidTable);

    /*
     * If the target windows belong to this thread,
     * unlock them now.
     */
    if (pHidTable->spwndTargetKbd && GETPTI(pHidTable->spwndTargetKbd) == pti) {
        RIPMSG2(RIP_WARNING, "DestroyThreadHidObjects: raw keyboard is requested pwnd=%p by pti=%p",
                pHidTable->spwndTargetKbd, pti);
        Unlock(&pHidTable->spwndTargetKbd);
        pHidTable->fRawKeyboard = pHidTable->fNoLegacyKeyboard = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawKeyboardSink) {
            DbgFreDec(cKbdSinks);
            pHidTable->fRawKeyboardSink = FALSE;
        }
#endif
    }
    if (pHidTable->spwndTargetMouse && GETPTI(pHidTable->spwndTargetMouse) == pti) {
        RIPMSG2(RIP_WARNING, "DestroyThreadHidObjects: raw mouse is requested pwnd=%p by pti=%p",
                pHidTable->spwndTargetMouse, pti);
        Unlock(&pHidTable->spwndTargetMouse);
        pHidTable->fRawMouse = pHidTable->fNoLegacyMouse = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawMouseSink) {
            DbgFreDec(cMouseSinks);
            pHidTable->fRawMouseSink = FALSE;
        }
#endif
    }

    /*
     * Free up the cached input type, in case it's for the current thread.
     * LATER: clean this up only pLastRequest belongs to this thread.
     */
    ClearProcessTableCache(pHidTable);

    CheckCritIn();
    EnterDeviceInfoListCrit();

    /*
     * Delete all process device requests that have
     * a target window belongs to this thread.
     */
    for (pList = pHidTable->InclusionList.Flink; pList != &pHidTable->InclusionList;) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);
        pList = pList->Flink;

        if (pHid->spwndTarget && GETPTI(pHid->spwndTarget) == pti) {
            RIPMSG4(RIP_WARNING, "DestroyThreadHidObjects: HID inc. request (%x,%x) pwnd=%p pti=%p",
                    pHid->usUsagePage, pHid->usUsage, pHid->spwndTarget, pti);
            FreeHidProcessRequest(pHid, HID_INCLUDE GI_SINK_PARAM(pHidTable));
        }
    }

    for (pList = pHidTable->UsagePageList.Flink; pList != &pHidTable->UsagePageList;) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);
        pList = pList->Flink;

        if (pHid->spwndTarget && GETPTI(pHid->spwndTarget) == pti) {
            RIPMSG4(RIP_WARNING, "DestroyThreadHidObjects: HID page-only request (%x,%x) pwnd=%p pti=%p",
                    pHid->usUsagePage, pHid->usUsage, pHid->spwndTarget, pti);
            FreeHidProcessRequest(pHid, HID_PAGEONLY GI_SINK_PARAM(pHidTable));
        }
    }

    for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList;) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);
        pList = pList->Flink;

        UserAssert(pHid->spwndTarget == NULL);

        if (pHid->spwndTarget && GETPTI(pHid->spwndTarget) == pti) {
            RIPMSG4(RIP_WARNING, "DestroyThreadHidObjects: HID excl. request (%x,%x) pwnd=%p pti=%p",
                    pHid->usUsagePage, pHid->usUsage, pHid->spwndTarget, pti);
            FreeHidProcessRequest(pHid, HID_EXCLUDE GI_SINK_PARAM(pHidTable));
        }
    }
    LeaveDeviceInfoListCrit();
}

/***************************************************************************\
* InitializeHidRequestList
*
* Global request list initialization
\***************************************************************************/
void InitializeHidRequestList()
{
    InitializeListHead(&gHidRequestTable.TLCInfoList);
    InitializeListHead(&gHidRequestTable.UsagePageList);
#ifdef GI_SINK
    InitializeListHead(&gHidRequestTable.ProcessRequestList);
#endif
}

/***************************************************************************\
* CleanupHidRequestList
*
* Global HID requests cleanup
*
* See Win32kNtUserCleanup.
* N.b. This rountine is supposed to be called before cleaning up
* the deviceinfo list.
\***************************************************************************/
void CleanupHidRequestList()
{
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    pList = gHidRequestTable.TLCInfoList.Flink;
    while (pList != &gHidRequestTable.TLCInfoList) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        /*
         * The contents may be freed later, so get the next link as the first thing.
         */
        pList = pList->Flink;

        /*
         * Set the process reference counter to zero, so that the FreeDeviceInfo() later can actually free
         * this device request.
         */
        pTLCInfo->cDirectRequest = pTLCInfo->cUsagePageRequest = pTLCInfo->cExcludeRequest =
            pTLCInfo->cExcludeOrphaned = 0;

        if (pTLCInfo->cDevices == 0) {
            /*
             * If this has zero deviceinfo reference, it can be directly freed here.
             */
            FreeHidTLCInfo(pTLCInfo);
        }
    }

    /*
     * Free PageOnly list.
     * Since this list is not referenced from DeviceInfo, it's safe to directly free it here.
     */
    while (!IsListEmpty(&gHidRequestTable.UsagePageList)) {
        PHID_PAGEONLY_REQUEST pPOReq = CONTAINING_RECORD(gHidRequestTable.UsagePageList.Flink, HID_PAGEONLY_REQUEST, link);

        /*
         * Set the process reference count to zero.
         */
        pPOReq->cRefCount = 0;
        /*
         * No need to fixup the HidTLCInfo's page-only request
         * count, as allthe TLCInfo has been freed already.
         */
        FreeHidPageOnlyRequest(pPOReq);
    }
}

/***************************************************************************\
* GetOperationMode
*
* This function converts the RAWINPUTDEVICE::dwFlags to the internal
* operation mode.
\***************************************************************************/
__inline DWORD GetOperationMode(
    PCRAWINPUTDEVICE pDev,
    BOOL fLegacyDevice)
{
    DWORD dwFlags = 0;

    UNREFERENCED_PARAMETER(fLegacyDevice);

    /*
     * Prepare the information
     */
    if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_PAGEONLY) {
        UserAssert(pDev->usUsage == 0);
        /*
         * The app want all the Usage in this UsagePage.
         */
        dwFlags = HID_PAGEONLY;
    } else if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_EXCLUDE) {
        UserAssert(pDev->usUsage != 0);
        UserAssert(pDev->hwndTarget == NULL);
        UserAssert((pDev->dwFlags & RIDEV_INPUTSINK) == 0);
        dwFlags = HID_EXCLUDE;
    } else if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_INCLUDE || RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY) {
        UserAssert(pDev->usUsage != 0);

        /*
         * NOLEGACY can be only specified for the legacy devices.
         */
        UserAssertMsg2(RIDEV_EXMODE(pDev->dwFlags) == RIDEV_INCLUDE || fLegacyDevice,
                       "RIDEV_NOLEGACY is specified for non legacy device (%x,%x)",
                       pDev->usUsagePage, pDev->usUsage);
        dwFlags = HID_INCLUDE;
    } else {
        UserAssert(FALSE);
    }

    return dwFlags;
}

/***************************************************************************\
* SetLegacyDeviceFlags
*
* This function sets or resets the NoLegacy flags and CaptureMouse flag
* when processing each request.
\***************************************************************************/
void SetLegacyDeviceFlags(
    PPROCESS_HID_TABLE pHidTable,
    PCRAWINPUTDEVICE pDev)
{
    UserAssert(IsLegacyDevice(pDev->usUsagePage, pDev->usUsage));

    if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_INCLUDE || RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY) {
        if (IsKeyboardDevice(pDev->usUsagePage, pDev->usUsage)) {
            pHidTable->fNoLegacyKeyboard = (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY);
            pHidTable->fNoHotKeys = ((pDev->dwFlags & RIDEV_NOHOTKEYS) != 0);
            pHidTable->fAppKeys = ((pDev->dwFlags & RIDEV_APPKEYS) != 0);
        } else if (IsMouseDevice(pDev->usUsagePage, pDev->usUsage)) {
            pHidTable->fNoLegacyMouse = RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY;
            pHidTable->fCaptureMouse = (pDev->dwFlags & RIDEV_CAPTUREMOUSE) != 0;
        }
    }
}

/***************************************************************************\
* InsertProcRequest
*
* This function inserts the ProcRequest into ppi->pHidTable.
* This function also maintains the reference counter of TLCInfo and
* PORequest.
\***************************************************************************/
BOOL InsertProcRequest(
    PPROCESSINFO ppi,
    PCRAWINPUTDEVICE pDev,
    PPROCESS_HID_REQUEST pHid,
#if DBG
    PPROCESS_HID_REQUEST pHidOrg,
#endif
    DWORD dwFlags,
    BOOL fLegacyDevice,
    PWND pwnd)
{
    /*
     * Update the global list.
     */
    if (dwFlags == HID_INCLUDE) {
        if (!fLegacyDevice) {
            PHID_TLC_INFO pTLCInfo = SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage);
            if (pTLCInfo == NULL) {
                UserAssert(pHidOrg == NULL);
    #if DBG
                DBGValidateHidRequestIsNew(pHid->usUsagePage, pHid->usUsage);
    #endif
                /*
                 * There is no such device type request allocated yet.
                 * Create a new one now.
                 */
                pTLCInfo = AllocateAndLinkHidTLCInfo(pHid->usUsagePage, pHid->usUsage);
                if (pTLCInfo == NULL) {
                    RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AddNewProcDeviceRequest: failed to allocate pTLCInfo.");
                    return FALSE;
                }
            }
            pHid->pTLCInfo = pTLCInfo;
            ++pTLCInfo->cDirectRequest;
        }

        /*
         * Lock the target window.
         */
        Lock(&pHid->spwndTarget, pwnd);

        /*
         * Link it in.
         */
        InsertHeadList(&ppi->pHidTable->InclusionList, &pHid->link);

        TAGMSG2(DBGTAG_PNP, "AddNewProcDeviceRequest: include (%x, %x)", pHid->usUsagePage, pHid->usUsage);

    } else if (dwFlags == HID_PAGEONLY) {
        PHID_PAGEONLY_REQUEST pPOReq = SearchHidPageOnlyRequest(pHid->usUsagePage);

        if (pPOReq == NULL) {
            UserAssert(pHidOrg == NULL);
            /*
             * Create a new one.
             */
            pPOReq = AllocateAndLinkHidPageOnlyRequest(pHid->usUsagePage);
            if (pPOReq == NULL) {
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AddNewProcDeviceRequest: failed to allocate pPOReq");
                return FALSE;
            }


        }
        pHid->pPORequest = pPOReq;
        ++pPOReq->cRefCount;

        /*
         * Update the page-only refcount in TLCInfo
         */
        SetHidPOCountToTLCInfo(pHid->usUsagePage, pPOReq->cRefCount, FALSE);

        /*
         * Lock the target window.
         */
        Lock(&pHid->spwndTarget, pwnd);

        /*
         * Link it in.
         */
        InsertHeadList(&ppi->pHidTable->UsagePageList, &pHid->link);

        TAGMSG2(DBGTAG_PNP, "AddNewProcDeviceRequest: pageonly (%x, %x)", pHid->usUsagePage, pHid->usUsage);

    } else if (dwFlags == HID_EXCLUDE) {
        /*
         * Add new Exclude request...
         * N.b. this may become orphaned exclusive request later.
         * For now let's pretend if it's a legit exclusive request.
         */
        if (!fLegacyDevice) {
            PHID_TLC_INFO pTLCInfo = SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage);

            if (pTLCInfo == NULL) {
                UserAssert(pHidOrg == NULL);
    #if DBG
                DBGValidateHidRequestIsNew(pHid->usUsagePage, pHid->usUsage);
    #endif
                pTLCInfo = AllocateAndLinkHidTLCInfo(pHid->usUsagePage, pHid->usUsage);
                if (pTLCInfo == NULL) {
                    RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AddNewProcDeviceRequest: failed to allocate pTLCInfo for exlusion");
                    return FALSE;
                }
            }
            pHid->pTLCInfo = pTLCInfo;
            ++pTLCInfo->cExcludeRequest;
            UserAssert(pHid->fExclusiveOrphaned == FALSE);

            UserAssert(pHid->spwndTarget == NULL);  // This is a new allocation, should be no locked pwnd.
        }

        /*
         * Link it in.
         */
        InsertHeadList(&ppi->pHidTable->ExclusionList, &pHid->link);

        TAGMSG2(DBGTAG_PNP, "AddNewProcDeviceRequest: exlude (%x, %x)", pHid->usUsagePage, pHid->usUsage);
    }

    /*
     * After this point, as pHid is already linked in pHidTable,
     * no simple return is allowed, without a legit cleanup.
     */

#ifdef GI_SINK
    /*
     * Set the sinkable flag.
     */
    if (pDev->dwFlags & RIDEV_INPUTSINK) {
        /*
         * Exclude request cannot be a sink. This should have been
         * checked in the validation code by now.
         */
        UserAssert(RIDEV_EXMODE(pDev->dwFlags) != RIDEV_EXCLUDE);
        /*
         * Sink request should specify the target hwnd.
         * The validation is supposed to check it beforehand.
         */
        UserAssert(pwnd);

        UserAssert(ppi->pHidTable->nSinks >= 0);    // LATER
        if (!fLegacyDevice) {
            /*
             * We count the sink for the non legacy devices only, so that
             * we can save clocks to walk through the request list.
             */
             if (!pHid->fSinkable) {
                 ++ppi->pHidTable->nSinks;
                 DbgFreInc(cHidSinks);
             }
        }
        /*
         * Set this request as sink.
         */
        pHid->fSinkable = TRUE;
    }
#endif

    return TRUE;
}

/***************************************************************************\
* RemoveProcRequest
*
* This function temporarily removes the ProcRequest from pHidTable
* and global TLCInfo / PORequest.  This function also updates the
* reference counters in TLCInfo / PORequest. The sink counter in
* pHidTable is also updated.
\***************************************************************************/
void RemoveProcRequest(
    PPROCESSINFO ppi,
    PPROCESS_HID_REQUEST pHid,
    DWORD dwFlags,
    BOOL fLegacyDevice)
{
    /*
     * Unlock the target window.
     */
    Unlock(&pHid->spwndTarget);

    switch (dwFlags) {
    case HID_INCLUDE:
        DerefIncludeRequest(pHid, ppi->pHidTable, fLegacyDevice, FALSE);
        break;
    case HID_PAGEONLY:
        DerefPageOnlyRequest(pHid, ppi->pHidTable, FALSE);
        break;
    case HID_EXCLUDE:
        DerefExcludeRequest(pHid, fLegacyDevice, FALSE);
    }

    RemoveEntryList(&pHid->link);
}

/***************************************************************************\
* SetProcDeviceRequest
*
* This function updates the ProcHidRequest based on RAWINPUTDEVICE.
* This function also sets some of the legacy device flags, such as
* NoLegacy or CaptureMouse / NoDefSystemKeys.
\***************************************************************************/
BOOL SetProcDeviceRequest(
    PPROCESSINFO ppi,
    PCRAWINPUTDEVICE pDev,
    PPROCESS_HID_REQUEST pHidOrg,
    DWORD dwFlags)
{
    PPROCESS_HID_REQUEST pHid = pHidOrg;
    BOOL fLegacyDevice = IsLegacyDevice(pDev->usUsagePage, pDev->usUsage);
    PWND pwnd;
    DWORD dwOperation;

    TAGMSG3(DBGTAG_PNP, "SetProcDeviceRequest: processing (%x, %x) to ppi=%p",
            pDev->usUsagePage, pDev->usUsage, ppi);

    CheckDeviceInfoListCritIn();

    if (pDev->hwndTarget) {
        pwnd = ValidateHwnd(pDev->hwndTarget);
        if (pwnd == NULL) {
            RIPMSG2(RIP_WARNING, "SetProcDeviceRequest: hwndTarget (%p) in pDev (%p) is bogus",
                    pDev->hwndTarget, pDev);
            return FALSE;
        }
    } else {
        pwnd = NULL;
    }

    dwOperation = GetOperationMode(pDev, fLegacyDevice);
    if (dwFlags == 0) {
        UserAssert(pHid == NULL);
    } else {
        UserAssert(pHid);
    }

    if (pHid == NULL) {
        /*
         * If this is a new request for this TLC, allocate it here.
         */
        pHid = AllocateHidProcessRequest(pDev->usUsagePage, pDev->usUsage);
        if (pHid == NULL) {
            RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "SetRawInputDevices: failed to allocate pHid.");
            goto error_exit;
        }
    }

    /*
     * Firstly remove this guy temporarily from the list.
     */
    if (pHidOrg) {
        UserAssert(pHidOrg->usUsagePage == pDev->usUsagePage && pHidOrg->usUsage == pDev->usUsage);
        RemoveProcRequest(ppi, pHidOrg, dwFlags, fLegacyDevice);
        pHid = pHidOrg;
    }

    if (!InsertProcRequest(ppi, pDev, pHid,
#if DBG
                      pHidOrg,
#endif
                      dwOperation, fLegacyDevice, pwnd)) {
        /*
         * The error case in InsertProcRequest should be TLCInfo
         * allocation error, so it couldn't be legacy devices.
         */
        UserAssert(!fLegacyDevice);
        goto error_exit;
    }

    if (fLegacyDevice) {
        SetLegacyDeviceFlags(ppi->pHidTable, pDev);
    }

    /*
     * Succeeded.
     */
    return TRUE;

error_exit:
    if (pHid) {
        /*
         * Let's make sure it's not in the request list.
         */
        DBGValidateHidReqNotInList(ppi, pHid);

        /*
         * Free this error-prone request.
         */
        UserFreePool(pHid);
    }
    return FALSE;
}


/***************************************************************************\
* HidRequestValidityCheck
*
\***************************************************************************/
BOOL HidRequestValidityCheck(
    const PRAWINPUTDEVICE pDev)
{
    PWND pwnd = NULL;

    if (pDev->dwFlags & ~RIDEV_VALID) {
        RIPERR1(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid flag %x", pDev->dwFlags);
        return FALSE;
    }

    if (pDev->usUsagePage == 0) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: usUsagePage is 0");
        return FALSE;
    }

    /*
     * If hwndTarget is specified, validate it here.
     */
    if (pDev->hwndTarget) {
        pwnd = ValidateHwnd(pDev->hwndTarget);
    }

    /*
     * Reject invalid CaptureMouse / NoSystemKeys flags.
     */
    #if (RIDEV_CAPTUREMOUSE != RIDEV_NOHOTKEYS)
    #error The value of RIDEV_CAPTUREMOUSE and RIDEV_NOSYSTEMKEYS should match.
    #endif
    if (pDev->dwFlags & RIDEV_CAPTUREMOUSE) {
        if (IsMouseDevice(pDev->usUsagePage, pDev->usUsage)) {
            if (RIDEV_EXMODE(pDev->dwFlags) != RIDEV_NOLEGACY ||
                    pwnd == NULL || GETPTI(pwnd)->ppi != PpiCurrent()) {
                RIPERR4(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid request (%x,%x) dwf %x hwnd %p "
                        "found for RIDEV_CAPTUREMOUSE",
                        pDev->usUsagePage, pDev->usUsage, pDev->dwFlags, pDev->hwndTarget);
                return FALSE;
            }
        } else if (!IsKeyboardDevice(pDev->usUsagePage, pDev->usUsage)) {
            RIPERR4(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid request (%x,%x) dwf %x hwnd %p "
                    "found for RIDEV_CAPTUREMOUSE",
                        pDev->usUsagePage, pDev->usUsage, pDev->dwFlags, pDev->hwndTarget);
                return FALSE;
        }
    }
    if (pDev->dwFlags & RIDEV_APPKEYS) {
        if (!IsKeyboardDevice(pDev->usUsagePage, pDev->usUsage) ||
            (RIDEV_EXMODE(pDev->dwFlags) != RIDEV_NOLEGACY)) {
            RIPERR4(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid request (%x,%x) dwf %x hwnd %p "
                    "found for RIDEV_APPKEYS",
                    pDev->usUsagePage, pDev->usUsage, pDev->dwFlags, pDev->hwndTarget);
                return FALSE;
        }
    }

    /*
     * RIDEV_REMOVE only takes PAGEONLY or ADD_OR_MODIFY.
     */
    if ((pDev->dwFlags & RIDEV_MODEMASK) == RIDEV_REMOVE) {
        // LATER: too strict?
        if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_EXCLUDE || RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY) {
            RIPERR0(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: remove and (exlude or nolegacy)");
            return FALSE;
        }
        if (pDev->hwndTarget != NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: hwndTarget is specified for remove operation.");
            return FALSE;
        }
    }

    /*
     * Check EXMODE
     */
    switch (RIDEV_EXMODE(pDev->dwFlags)) {
    case RIDEV_EXCLUDE:
#ifdef GI_SINK
        if (pDev->dwFlags & RIDEV_INPUTSINK) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: Exclude request cannot have RIDEV_INPUTSINK for UP=%x, U=%x",
                    pDev->usUsagePage, pDev->usUsage);
            return FALSE;
        }
        /* FALL THROUGH */
#endif
    case RIDEV_INCLUDE:
        if (pDev->usUsage == 0) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: usUsage is 0 without RIDEV_PAGEONLY for UP=%x",
                    pDev->usUsagePage);
            return FALSE;
        }
        break;
    case RIDEV_PAGEONLY:
        if (pDev->usUsage != 0) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: UsagePage-only has Usage UP=%x, U=%x",
                    pDev->usUsagePage, pDev->usUsage);
            return FALSE;
        }
        break;
    case RIDEV_NOLEGACY:
        if (!IsLegacyDevice(pDev->usUsagePage, pDev->usUsage)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: NOLEGACY is specified to non legacy device.");
            return FALSE;
        }
        break;
    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: invalid exmode=%x", RIDEV_EXMODE(pDev->dwFlags));
        return FALSE;
    }

    /*
     * Check if pDev->hwndTarget is a valid handle.
     */
    if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_EXCLUDE) {
#ifdef GI_SINK
        if (pDev->dwFlags & RIDEV_INPUTSINK) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: input sink is specified for exclude.");
            return FALSE;
        }
#endif
        if (pDev->hwndTarget != NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: hwndTarget %p cannot be specified for exlusion.",
                    pDev->hwndTarget);
            return FALSE;
        }
    } else {
        if (pDev->hwndTarget && pwnd == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: hwndTarget %p is invalid.", pDev->hwndTarget);
            return FALSE;
        }
        if (pwnd && GETPTI(pwnd)->ppi != PpiCurrent()) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: pwndTarget %p belongs to different process",
                    pwnd);
            return FALSE;
        }
#ifdef GI_SINK
        if ((pDev->dwFlags & RIDEV_INPUTSINK) && pwnd == NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: RIDEV_INPUTSINK requires hwndTarget");
            return FALSE;
        }
#endif
    }

    return TRUE;
}

/***************************************************************************\
* ClearProcessTableCache
*
* Clear up the input type cache in the process request table.
\***************************************************************************/
void ClearProcessTableCache(PPROCESS_HID_TABLE pHidTable)
{
    pHidTable->pLastRequest = NULL;
    pHidTable->UsagePageLast = pHidTable->UsageLast = 0;
}

/***************************************************************************\
* AdjustLegacyDeviceFlags
*
* Adjust the request and sink flags for legacy devices in the process
* request table, as the last thing in RegisterRawInputDevices.
* N.b. sink and raw flags need to be set at the last thing in
* RegsiterRawInputDevices, as it may be implicitly requested through the
* page-only request.
* Also this function sets up the target window for legacy devices.
\***************************************************************************/
void AdjustLegacyDeviceFlags(PPROCESSINFO ppi)
{
    PPROCESS_HID_TABLE pHidTable = ppi->pHidTable;
    PPROCESS_HID_REQUEST phr;

    /*
     * Adjust the keyboard sink flag and target window.
     */
    if (phr = InProcessDeviceTypeRequestTable(pHidTable,
            HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD)) {

        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw keyboard is requested in ppi=%p", ppi);
        pHidTable->fRawKeyboard = TRUE;

#ifdef GI_SINK
        UserAssert(!phr->fSinkable || phr->spwndTarget);
        if (pHidTable->fRawKeyboardSink != phr->fSinkable) {
            TAGMSG2(DBGTAG_PNP, "AdjustLegacyDeviceFlags: kbd prevSink=%x newSink=%x",
                    pHidTable->fRawKeyboardSink, phr->fSinkable);
            if (phr->fSinkable) {
                DbgFreInc(cKbdSinks);
            } else {
                DbgFreDec(cKbdSinks);
            }
            pHidTable->fRawKeyboardSink = phr->fSinkable;
        }
#endif
        Lock(&pHidTable->spwndTargetKbd, phr->spwndTarget);
    } else {
        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw keyboard is NOT requested in ppi=%p", ppi);
        pHidTable->fRawKeyboard = pHidTable->fNoLegacyKeyboard = FALSE;
        pHidTable->fNoHotKeys = FALSE;
        pHidTable->fAppKeys = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawKeyboardSink) {
            DbgFreDec(cKbdSinks);
            TAGMSG0(DBGTAG_PNP, "AdjustLegacyDeviceFlags: kbd prevSink was true");
        }
        pHidTable->fRawKeyboardSink = FALSE;
#endif
        Unlock(&pHidTable->spwndTargetKbd);
    }

    /*
     * Adjust the mouse sink flags and target window.
     */
    if (phr = InProcessDeviceTypeRequestTable(pHidTable,
            HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE)) {

        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw mouse is requested in ppi=%p", ppi);
        pHidTable->fRawMouse = TRUE;
#ifdef GI_SINK
        UserAssert(!phr->fSinkable || phr->spwndTarget);
        if (pHidTable->fRawMouseSink != phr->fSinkable) {
            TAGMSG2(DBGTAG_PNP, "AdjustLegacyDeviceFlags: mouse prevSink=%x newSink=%x",
                    pHidTable->fRawMouseSink, phr->fSinkable);
            if (phr->fSinkable) {
                DbgFreInc(cMouseSinks);
            }
            else {
                DbgFreDec(cMouseSinks);
            }
            pHidTable->fRawMouseSink = phr->fSinkable;
        }
#endif
        Lock(&pHidTable->spwndTargetMouse, phr->spwndTarget);
    } else {
        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw mouse is NOT requested in ppi=%p", ppi);
        pHidTable->fRawMouse = pHidTable->fNoLegacyMouse = pHidTable->fCaptureMouse = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawMouseSink) {
            TAGMSG0(DBGTAG_PNP, "AdjustLegacyDeviceFlags: mouse prevSink was true");
            DbgFreDec(cMouseSinks);
        }
        pHidTable->fRawMouseSink = FALSE;
#endif
        Unlock(&pHidTable->spwndTargetMouse);
    }

#if DBG
    /*
     * Check NoLegacy and CaptureMouse legitimacy.
     */
    if (!pHidTable->fNoLegacyMouse) {
        UserAssert(!pHidTable->fCaptureMouse);
    }
#endif
}

/***************************************************************************\
* CleanupFreedTLCInfo
*
* This routine clears the TLCInfo and PageOnlyReq that are no longer
* ref-counted.
\***************************************************************************/
VOID CleanupFreedTLCInfo()
{
    PLIST_ENTRY pList;

    /*
     * The caller has to ensure being in the device list critical section.
     */
    CheckDeviceInfoListCritIn();

    /*
     * Walk through the list, free the TLCInfo if it's not ref-counted.
     */
    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList;) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        /*
         * Get the next link, before this gets freed.
         */
        pList = pList->Flink;

        if (HidTLCInfoNoReference(pTLCInfo)) {
            TAGMSG3(DBGTAG_PNP, "CleanupFreedTLCInfo: freeing TLCInfo=%p (%x, %x)", pTLCInfo,
                    pTLCInfo->usUsagePage, pTLCInfo->usUsage);
            FreeHidTLCInfo(pTLCInfo);
        }
    }

    /*
     * Walk though the Page-only request list, free it if it's not ref-counted.
     */
    for (pList = gHidRequestTable.UsagePageList.Flink; pList != &gHidRequestTable.UsagePageList; ) {
        PHID_PAGEONLY_REQUEST pPOReq = CONTAINING_RECORD(pList, HID_PAGEONLY_REQUEST, link);

        /*
         * Get the next link before it's freed.
         */
        pList = pList->Flink;

        if (pPOReq->cRefCount == 0) {
            FreeHidPageOnlyRequest(pPOReq);
        }
    }
}

/***************************************************************************\
* FixupOrphanedExclusiveRequests
*
* Adjust the exclusiveness counter in the global TLC info.
* Sometimes there's orphaned exclusive request that really should not take
* global effect.
\***************************************************************************/
void FixupOrphanedExclusiveRequests(PPROCESSINFO ppi)
{
    PLIST_ENTRY pList;
    PPROCESS_HID_TABLE pHidTable = ppi->pHidTable;

    for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        if (IsLegacyDevice(pHid->usUsagePage, pHid->usUsage)) {
            UserAssert(pHid->fExclusiveOrphaned == FALSE);
        } else {
            PPROCESS_HID_REQUEST pPageOnly;

            UserAssert(pHid->spwndTarget == NULL);
            UserAssert(pHid->pTLCInfo);

            /*
             * Search if we have the page-only request for this UsagePage.
             */
            pPageOnly = SearchProcessHidRequestUsagePage(pHidTable, pHid->usUsagePage);
            if (pPageOnly) {
                /*
                 * OK, corresponding page-only request is found, this one
                 * is not orphaned.
                 */
                if (pHid->fExclusiveOrphaned) {
                    /*
                     * This request was previously orphaned, but not any more.
                     */
                    UserAssert(pHid->pTLCInfo->cExcludeOrphaned >= 1);
                    --pHid->pTLCInfo->cExcludeOrphaned;
                    pHid->fExclusiveOrphaned = FALSE;
                }
            } else {
                /*
                 * This one is orphaned. Let's check the previous state
                 * to see if we need to fix up the counter(s).
                 */
                if (!pHid->fExclusiveOrphaned) {
                    /*
                     * This request was not orphaned, but unfortunately
                     * due to removal of page request or some other reasons,
                     * becoming an orphan.
                     */
                    ++pHid->pTLCInfo->cExcludeOrphaned;
                    pHid->fExclusiveOrphaned = TRUE;
                }
            }
            UserAssert(pHid->pTLCInfo->cExcludeRequest >= pHid->pTLCInfo->cExcludeOrphaned);
        }
    }
}


/***************************************************************************\
* _RegisterRawInputDevices
*
* API helper
\***************************************************************************/
BOOL _RegisterRawInputDevices(
    PCRAWINPUTDEVICE cczpRawInputDevices,
    UINT             uiNumDevices)
{
    PPROCESSINFO ppi;
    UINT         i;

    API_PROLOGUE(BOOL, FALSE);

    ppi = PpiCurrent();
    UserAssert(ppi);
    UserAssert(uiNumDevices > 0);   // should have been checked in the stub

    CheckDeviceInfoListCritOut();
    EnterDeviceInfoListCrit();

    if (ppi->pHidTable) {
        /*
         * Clear the last active UsagePage/Usage, so that
         * the next read operation will check the updated
         * request list.
         */
        ClearProcessTableCache(ppi->pHidTable);
    }

    /*
     * Firstly validate all the device request.
     */
    for (i = 0; i < uiNumDevices; ++i) {
        RAWINPUTDEVICE ridDev;

        ridDev = cczpRawInputDevices[i];

        /*
         * Validity check
         */
        if (!HidRequestValidityCheck(&ridDev)) {
            /*
             * Indicate no real change has made.
             */
            i = 0;

            /*
             * LastError is already set in the above function,
             * so let's specify zero here.
             */
            API_ERROR(0);
        }
    }

    /*
     * If the process hid request table is not yet allocated, allocate it now.
     */
    if (ppi->pHidTable == NULL) {
        ppi->pHidTable = AllocateProcessHidTable();
        if (ppi->pHidTable == NULL) {
            RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "_RegisterRawInputDevices: failed to allocate table");
            API_ERROR(0);
        }
    }

    UserAssert(ppi->pHidTable);

    for (i = 0; i < uiNumDevices; ++i) {
        PPROCESS_HID_REQUEST pHid;
        DWORD                dwFlags;

        /*
         * Check if the requested device type is already in our process hid req list here,
         * for it's commonly used in the following cases.
         */
        pHid = SearchProcessHidRequest(
                   ppi,
                   cczpRawInputDevices[i].usUsagePage,
                   cczpRawInputDevices[i].usUsage,
                   &dwFlags);

        if ((cczpRawInputDevices[i].dwFlags & RIDEV_MODEMASK) == RIDEV_ADD_OR_MODIFY) {
            if (!SetProcDeviceRequest(
                     ppi,
                     cczpRawInputDevices + i,
                     pHid,
                     dwFlags)) {
                API_ERROR(0);
            }
        } else {
            /*
             * Remove this device, if it's in the list
             */
            if (pHid) {
                TAGMSG4(DBGTAG_PNP, "_RegisterRawInputDevices: removing type=%x (%x, %x) from ppi=%p",
                        RIDEV_EXMODE(cczpRawInputDevices[i].dwFlags),
                        cczpRawInputDevices[i].usUsagePage, cczpRawInputDevices[i].usUsage, ppi);
                FreeHidProcessRequest(pHid, dwFlags GI_SINK_PARAM(ppi->pHidTable));
            } else {
                RIPMSG3(
                    RIP_WARNING,
                    "_RegisterRawInputDevices: removing... TLC (%x,%x) is not registered in ppi=%p, but just ignore it",
                    cczpRawInputDevices[i].usUsagePage,
                    cczpRawInputDevices[i].usUsage,
                    ppi);
            }
        }
    }

    /*
     * Now that we finished updating the process device request and the global request list,
     * start/stop each device.
     */
    retval = TRUE;

    /*
     * API cleanup portion
     */
    API_CLEANUP();

    if (ppi->pHidTable) {
        /*
         * Adjust the legacy flags in pHidTable.
         */
        AdjustLegacyDeviceFlags(ppi);

        /*
         * Check if there's orphaned exclusive requests.
         */
        FixupOrphanedExclusiveRequests(ppi);

        /*
         * Make sure the cache is cleared right.
         */
        UserAssert(ppi->pHidTable->pLastRequest == NULL);
        UserAssert(ppi->pHidTable->UsagePageLast == 0);
        UserAssert(ppi->pHidTable->UsageLast == 0);

        /*
         * Free TLCInfo that are no longer ref-counted.
         */
        CleanupFreedTLCInfo();

        /*
         * Start or stop reading the HID devices.
         */
        HidDeviceStartStop();
    }

    CheckupHidCounter();

    LeaveDeviceInfoListCrit();

    API_EPILOGUE();
}


/***************************************************************************\
* SortRegisteredDevices
*
* API helper:
* This function sorts the registered raw input devices by the shell sort.
* O(n^1.2)
* N.b. if the array is in the user-mode, this function may raise
* an exception, which is supposed to be handled by the caller.
\***************************************************************************/

__inline BOOL IsRawInputDeviceLarger(
    const PRAWINPUTDEVICE pRid1,
    const PRAWINPUTDEVICE pRid2)
{
    return (DWORD)MAKELONG(pRid1->usUsage, pRid1->usUsagePage) > (DWORD)MAKELONG(pRid2->usUsage, pRid2->usUsagePage);
}

void SortRegisteredDevices(
    PRAWINPUTDEVICE cczpRawInputDevices,
    const int iSize)
{
    int h;

    if (iSize <= 0) {
        // give up!
        return;
    }

    // Calculate starting block size.
    for (h = 1; h < iSize / 9; h = 3 * h + 1) {
        UserAssert(h > 0);
    }

    while (h > 0) {
        int i;

        for (i = h; i < iSize; ++i) {
            RAWINPUTDEVICE rid = cczpRawInputDevices[i];
            int j;

            for (j = i - h; j >= 0 && IsRawInputDeviceLarger(&cczpRawInputDevices[j], &rid); j -= h) {
                cczpRawInputDevices[j + h] = cczpRawInputDevices[j];
            }
            if (i != j + h) {
                cczpRawInputDevices[j + h] = rid;
            }
        }
        h /= 3;
    }

#if DBG
    // verify
    {
        int i;

        for (i = 1; i < iSize; ++i) {
            UserAssert(cczpRawInputDevices[i - 1].usUsagePage <= cczpRawInputDevices[i].usUsagePage ||
                       cczpRawInputDevices[i - 1].usUsage <= cczpRawInputDevices[i].usUsage);
        }
    }
#endif
}


/***************************************************************************\
* _GetRegisteredRawInputDevices
*
* API helper
\***************************************************************************/
UINT _GetRegisteredRawInputDevices(
    PRAWINPUTDEVICE cczpRawInputDevices,
    PUINT puiNumDevices)
{
    API_PROLOGUE(UINT, (UINT)-1);
    PPROCESSINFO ppi;
    UINT uiNumDevices;
    UINT nDevices = 0;

    CheckDeviceInfoListCritOut();
    EnterDeviceInfoListCrit();

    ppi = PpiCurrent();
    UserAssert(ppi);

    if (ppi->pHidTable == NULL) {
        nDevices = 0;
    } else {
        PLIST_ENTRY pList;

        for (pList = ppi->pHidTable->InclusionList.Flink; pList != &ppi->pHidTable->InclusionList; pList = pList->Flink) {
            ++nDevices;
        }
        TAGMSG2(DBGTAG_PNP, "_GetRawInputDevices: ppi %p # inclusion %x", ppi, nDevices);
        for (pList = ppi->pHidTable->UsagePageList.Flink; pList != &ppi->pHidTable->UsagePageList; pList = pList->Flink) {
            ++nDevices;
        }
        TAGMSG1(DBGTAG_PNP, "_GetRawInputDevices: # pageonly+inclusion %x", nDevices);
        for (pList = ppi->pHidTable->ExclusionList.Flink; pList != &ppi->pHidTable->ExclusionList; pList = pList->Flink) {
            ++nDevices;
        }
        TAGMSG1(DBGTAG_PNP, "_GetRawInputDevices: # total hid request %x", nDevices);

        /*
         * Check Legacy Devices.
         */
        UserAssert(ppi->pHidTable->fRawKeyboard || !ppi->pHidTable->fNoLegacyKeyboard);
        UserAssert(ppi->pHidTable->fRawMouse || !ppi->pHidTable->fNoLegacyMouse);

        TAGMSG1(DBGTAG_PNP, "_GetRawInputDevices: # request including legacy devices %x", nDevices);
    }

    if (cczpRawInputDevices == NULL) {
        /*
         * Return the number of the devices in the per-process device list.
         */
        try {
            ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            *puiNumDevices = nDevices;
            retval = 0;
        } except (StubExceptionHandler(TRUE)) {
            API_ERROR(0);
        }
    } else {
        try {
            ProbeForRead(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            uiNumDevices = *puiNumDevices;
            if (uiNumDevices == 0) {
                /*
                 * Non-NULL buffer is specified, but the buffer size is 0.
                 * To probe the buffer right, this case is treated as an error.
                 */
                API_ERROR(ERROR_INVALID_PARAMETER);
            }
            ProbeForWriteBuffer(cczpRawInputDevices, uiNumDevices, sizeof(DWORD));
        } except (StubExceptionHandler(TRUE)) {
            API_ERROR(0);
        }

        if (ppi->pHidTable == NULL) {
            retval = 0;
        } else {
            PLIST_ENTRY pList;
            UINT i;

            if (uiNumDevices < nDevices) {
                try {
                    ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
                    *puiNumDevices = nDevices;
                    API_ERROR(ERROR_INSUFFICIENT_BUFFER);
                } except (StubExceptionHandler(TRUE)) {
                    API_ERROR(0);
                }
            }

            try {
                for (i = 0, pList = ppi->pHidTable->InclusionList.Flink; pList != &ppi->pHidTable->InclusionList && i < uiNumDevices; pList = pList->Flink, ++i) {
                    RAWINPUTDEVICE device;
                    PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

                    device.dwFlags = 0;
#ifdef GI_SINK
                    device.dwFlags |= (pHid->fSinkable ? RIDEV_INPUTSINK : 0);
#endif
                    device.usUsagePage = pHid->usUsagePage;
                    device.usUsage = pHid->usUsage;
                    device.hwndTarget = HW(pHid->spwndTarget);
                    if ((IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fNoLegacyKeyboard) ||
                            (IsMouseDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fNoLegacyMouse)) {
                        device.dwFlags |= RIDEV_NOLEGACY;
                    }
                    if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fNoHotKeys) {
                        device.dwFlags |= RIDEV_NOHOTKEYS;
                    }
                    if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fAppKeys) {
                        device.dwFlags |= RIDEV_APPKEYS;
                    }
                    if (IsMouseDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fCaptureMouse) {
                        device.dwFlags |= RIDEV_CAPTUREMOUSE;
                    }
                    cczpRawInputDevices[i] = device;

                }
                for (pList = ppi->pHidTable->UsagePageList.Flink; pList != &ppi->pHidTable->UsagePageList && i < uiNumDevices; pList = pList->Flink, ++i) {
                    RAWINPUTDEVICE device;
                    PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

                    device.dwFlags = RIDEV_PAGEONLY;
#ifdef GI_SINK
                    device.dwFlags |= (pHid->fSinkable ? RIDEV_INPUTSINK : 0);
#endif
                    device.usUsagePage = pHid->usUsagePage;
                    device.usUsage = pHid->usUsage;
                    device.hwndTarget = HW(pHid->spwndTarget);
                    cczpRawInputDevices[i] = device;
                }
                for (pList = ppi->pHidTable->ExclusionList.Flink; pList != &ppi->pHidTable->ExclusionList && i < uiNumDevices; pList = pList->Flink, ++i) {
                    RAWINPUTDEVICE device;
                    PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

                    device.dwFlags = RIDEV_EXCLUDE;
#ifdef GI_SINK
                    UserAssert(pHid->fSinkable == FALSE);
#endif
                    device.usUsagePage = pHid->usUsagePage;
                    device.usUsage = pHid->usUsage;
                    device.hwndTarget = NULL;
                    cczpRawInputDevices[i] = device;
                }

                /*
                 * Sort the array by UsagePage and Usage.
                 */
                SortRegisteredDevices(cczpRawInputDevices, (int)nDevices);

                retval = nDevices;
            } except (StubExceptionHandler(TRUE)) {
                API_ERROR(0);
            }
        }
    }

    API_CLEANUP();

    LeaveDeviceInfoListCrit();

    API_EPILOGUE();
}


/***************************************************************************\
* AllocateHidDesc
*
* HidDesc allocation
\***************************************************************************/
PHIDDESC AllocateHidDesc(PUNICODE_STRING pustrName,
                         PVOID pPreparsedData,
                         PHIDP_CAPS pCaps,
                         PHID_COLLECTION_INFORMATION pHidCollectionInfo)
{
    PHIDDESC pHidDesc;

    CheckCritIn();

    if (pPreparsedData == NULL) {
        RIPMSG0(RIP_ERROR, "AllocateHidDesc: pPreparsedData is NULL.");
        return NULL;
    }

    if (pCaps->InputReportByteLength == 0) {
        RIPMSG2(RIP_WARNING, "AllocateHidDesc: InputReportByteLength for (%02x, %02x).", pCaps->UsagePage, pCaps->Usage);
        return NULL;
    }

    pHidDesc = UserAllocPoolZInit(sizeof(HIDDESC), TAG_HIDDESC);
    if (pHidDesc == NULL) {
        // Failed to allocate.
        RIPMSG1(RIP_WARNING, "AllocateHidDesc: failed to allocated hiddesc. name='%ws'", pustrName->Buffer);
        return NULL;
    }

    DbgInc(cHidDesc);

    /*
     * Allocate the input buffer used by the asynchronouse I/O
     */
    pHidDesc->hidpCaps = *pCaps;
    pHidDesc->pInputBuffer = UserAllocPoolNonPaged(pHidDesc->hidpCaps.InputReportByteLength * MAXIMUM_ITEMS_READ, TAG_PNP);
    TAGMSG1(DBGTAG_PNP, "AllocateHidDesc: pInputBuffer=%p", pHidDesc->pInputBuffer);
    if (pHidDesc->pInputBuffer == NULL) {
        RIPMSG1(RIP_WARNING, "AllocateHidDesc: failed to allocate input buffer (size=%x)", pHidDesc->hidpCaps.InputReportByteLength);
        FreeHidDesc(pHidDesc);
        return NULL;
    }

    pHidDesc->pPreparsedData = pPreparsedData;
    pHidDesc->hidCollectionInfo = *pHidCollectionInfo;

    TAGMSG1(DBGTAG_PNP, "AllocateHidDesc: returning %p", pHidDesc);

    return pHidDesc;

    UNREFERENCED_PARAMETER(pustrName);
}

/***************************************************************************\
* FreeHidDesc
*
* HidDesc destruction
\***************************************************************************/
void FreeHidDesc(PHIDDESC pDesc)
{
    CheckCritIn();
    UserAssert(pDesc);

    TAGMSG2(DBGTAG_PNP | RIP_THERESMORE, "FreeHidDesc entered for (%x, %x)", pDesc->hidpCaps.UsagePage, pDesc->hidpCaps.Usage);
    TAGMSG1(DBGTAG_PNP, "FreeHidDesc: %p", pDesc);

    if (pDesc->pInputBuffer) {
        UserFreePool(pDesc->pInputBuffer);
#if DBG
        pDesc->pInputBuffer = NULL;
#endif
    }

    if (pDesc->pPreparsedData) {
        UserFreePool(pDesc->pPreparsedData);
#if DBG
        pDesc->pPreparsedData = NULL;
#endif
    }

    UserFreePool(pDesc);

    DbgDec(cHidDesc);
}

/***************************************************************************\
* AllocateHidData
*
* HidData allocation
*
* This function simply calls the HMAllocateObject function.
* The rest of the initialization is the responsibility of the caller.
\***************************************************************************/
PHIDDATA AllocateHidData(
    HANDLE hDevice,
    DWORD dwType,
    DWORD dwSize,   // size of the actual data, not including RAWINPUTHEADER
    WPARAM wParam,
    PWND pwnd)
{
    PHIDDATA pHidData;
    PTHREADINFO pti;

    CheckCritIn();

#if DBG
    if (dwType == RIM_TYPEMOUSE) {
        UserAssert(dwSize == sizeof(RAWMOUSE));
    } else if (dwType == RIM_TYPEKEYBOARD) {
        UserAssert(dwSize == sizeof(RAWKEYBOARD));
    } else if (dwType == RIM_TYPEHID) {
        UserAssert(dwSize > FIELD_OFFSET(RAWHID, bRawData));
    } else {
        UserAssert(FALSE);
    }
#endif

    /*
     * N.b. The following code is copied from WakeSomeone to determine
     * which thread will receive the message.
     * When the code in WakeSomeone changes, the following code should be changed too.
     * This pti is required for the HIDDATA is specified as thread owned
     * for some reasons for now. This may be changed later.
     *
     * I think having similar duplicated code in pretty far places is not
     * really a good idea, or HIDDATA may not suit to be thread owned (perhaps
     * it'll be more clear in the future enhanced model). By making it
     * thead owned, we don't have to modify the thread cleanup code...
     * However, I don't see clear advantage other than that. For now,
     * let's make it thread owned and we'll redo the things later... (hiroyama)
     */
    UserAssert(gpqForeground);
    UserAssert(gpqForeground && gpqForeground->ptiKeyboard);

    if (pwnd) {
        pti = GETPTI(pwnd);
    } else {
        pti = PtiKbdFromQ(gpqForeground);
    }

    UserAssert(pti);

    /*
     * Allocate the handle.
     * The next code assumes HIDDATA := HEAD + RAWINPUT.
     */
    pHidData = (PHIDDATA)HMAllocObject(pti, NULL, (BYTE)TYPE_HIDDATA, dwSize + FIELD_OFFSET(HIDDATA, rid.data));

    /*
     * Recalc the size of RAWINPUT structure.
     */
    dwSize += FIELD_OFFSET(RAWINPUT, data);

    if (pHidData) {
        DbgInc(cHidData);

        /*
         * Initialize some common part.
         */
        pHidData->spwndTarget = NULL;
        Lock(&pHidData->spwndTarget, pwnd);
        pHidData->rid.header.dwSize = dwSize;
        pHidData->rid.header.dwType = dwType;
        pHidData->rid.header.hDevice = hDevice;
        pHidData->rid.header.wParam = wParam;
#if LOCK_HIDDEVICEINFO
        /*
         * do hDevice locking here...
         */
#endif
    }

    return pHidData;
}


/***************************************************************************\
* FreeHidData
*
* HidData destruction
\***************************************************************************/
void FreeHidData(PHIDDATA pData)
{
    CheckCritIn();
    if (!HMMarkObjectDestroy(pData)) {
        RIPMSG2(RIP_ERROR, "FreeHidData: HIDDATA@%p cannot be destroyed now: cLock=%x", pData, pData->head.cLockObj);
        return;
    }

    Unlock(&pData->spwndTarget);

    HMFreeObject(pData);

    DbgDec(cHidData);
}


/*
 * HID device info creation
 */

/***************************************************************************\
* xxxHidGetCaps
*
* Get the interface through IRP and call hidparse.sys!HidP_GetCaps.
* (ported from wdm/dvd/class/codguts.c)
\***************************************************************************/
NTSTATUS xxxHidGetCaps(
  IN PDEVICE_OBJECT pDeviceObject,
  IN PHIDP_PREPARSED_DATA pPreparsedData,
  OUT PHIDP_CAPS pHidCaps)
{
    NTSTATUS            status;
    KEVENT              event;
    IO_STATUS_BLOCK     iosb;
    PIRP                irp;
    PIO_STACK_LOCATION  pIrpStackNext;
    PHID_INTERFACE_HIDPARSE pHidInterfaceHidParse;
    PHIDP_GETCAPS       pHidpGetCaps = NULL;

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    pHidInterfaceHidParse = UserAllocPoolNonPaged(sizeof *pHidInterfaceHidParse, TAG_PNP);
    if (pHidInterfaceHidParse == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidGetCaps: failed to allocate pHidInterfaceHidParse");
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pHidInterfaceHidParse->Size = sizeof *pHidInterfaceHidParse;
    pHidInterfaceHidParse->Version = 1;

    //
    // LATER: check out this comment
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       pDeviceObject,
                                       NULL,
                                       0,
                                       NULL,
                                       &event,
                                       &iosb);
    if (irp == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidGetCaps: failed to allocate Irp.");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    irp->RequestorMode = KernelMode;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pIrpStackNext = IoGetNextIrpStackLocation(irp);
    UserAssert(pIrpStackNext);

    //
    // Create an interface query out of the irp.
    //
    pIrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
    pIrpStackNext->Parameters.QueryInterface.InterfaceType = (LPGUID)&GUID_HID_INTERFACE_HIDPARSE;
    pIrpStackNext->Parameters.QueryInterface.Size = sizeof *pHidInterfaceHidParse;
    pIrpStackNext->Parameters.QueryInterface.Version = 1;
    pIrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)pHidInterfaceHidParse;
    pIrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    status = IoCallDriver(pDeviceObject, irp);

    if (status == STATUS_PENDING) {
        //
        // This waits using KernelMode, so that the stack, and therefore the
        // event on that stack, is not paged out.
        //
        TAGMSG1(DBGTAG_PNP, "HidQueryInterface: pending for devobj=%p", pDeviceObject);
        LeaveDeviceInfoListCrit();
        LeaveCrit();
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        EnterCrit();
        EnterDeviceInfoListCrit();
        status = iosb.Status;
    }
    if (status == STATUS_SUCCESS) {
        UserAssert(pHidInterfaceHidParse->HidpGetCaps);
        status = pHidInterfaceHidParse->HidpGetCaps(pPreparsedData, pHidCaps);
    } else {
        RIPMSG1(RIP_WARNING, "xxxHidGetCaps: failed to get pHidpCaps for devobj=%p", pDeviceObject);
    }

Cleanup:
    UserFreePool(pHidInterfaceHidParse);

    return status;
}


/***************************************************************************\
* GetDeviceObjectPointer
*
* Description:
*    This routine returns a pointer to the device object specified by the
*    object name.  It also returns a pointer to the referenced file object
*    that has been opened to the device that ensures that the device cannot
*    go away.
*    To close access to the device, the caller should dereference the file
*    object pointer.
*
* Arguments:
*    ObjectName - Name of the device object for which a pointer is to be
*                 returned.
*    DesiredAccess - Access desired to the target device object.
*    ShareAccess - Supplies the types of share access that the caller would like
*                  to the file.
*    FileObject - Supplies the address of a variable to receive a pointer
*                 to the file object for the device.
*    DeviceObject - Supplies the address of a variable to receive a pointer
*                   to the device object for the specified device.
* Return Value:
*    The function value is a referenced pointer to the specified device
*    object, if the device exists.  Otherwise, NULL is returned.
\***************************************************************************/
NTSTATUS
GetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject)
{
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    /*
     * Initialize the object attributes to open the device.
     */
    InitializeObjectAttributes(&objectAttributes,
                               ObjectName,
                               OBJ_KERNEL_HANDLE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenFile(&fileHandle,
                        DesiredAccess,
                        &objectAttributes,
                        &ioStatus,
                        ShareAccess,
                        FILE_NON_DIRECTORY_FILE);

    if (NT_SUCCESS(status)) {
        /*
         * The open operation was successful.  Dereference the file handle
         * and obtain a pointer to the device object for the handle.
         */
        status = ObReferenceObjectByHandle(fileHandle,
                                           0,
                                           *IoFileObjectType,
                                           KernelMode,
                                           (PVOID *)&fileObject,
                                           NULL);
        if (NT_SUCCESS(status)) {
            *FileObject = fileObject;

            /*
             * Get a pointer to the device object for this file.
             */
            *DeviceObject = IoGetRelatedDeviceObject(fileObject);
        }
        ZwClose(fileHandle);
    }

    return status;
}

/***************************************************************************\
* HidCreateDeviceInfo
*
\***************************************************************************/
PHIDDESC HidCreateDeviceInfo(PDEVICEINFO pDeviceInfo)
{
    NTSTATUS status;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    IO_STATUS_BLOCK iob;
    PHIDDESC pHidDesc = NULL;
    PBYTE pPreparsedData = NULL;
    HIDP_CAPS caps;
    PHID_TLC_INFO pTLCInfo;
    HID_COLLECTION_INFORMATION hidCollection;
    KEVENT event;
    PIRP irp;

    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    BEGINATOMICCHECK();

    TAGMSG0(DBGTAG_PNP, "HidCreateDeviceInfo");

    status = GetDeviceObjectPointer(&pDeviceInfo->ustrName,
                                    FILE_READ_DATA,
                                    FILE_SHARE_READ,
                                    &pFileObject,
                                    &pDeviceObject);

    if (!NT_SUCCESS(status)) {
        RIPMSGF1(RIP_WARNING, "failed to get the device object pointer. stat=%x", status);
        goto CleanUp0;
    }

    /*
     * Reference the device object.
     */
    UserAssert(pDeviceObject);
    ObReferenceObject(pDeviceObject);
    /*
     * Remove the reference IoGetDeviceObjectPointer() has put
     * on the file object.
     */
    UserAssert(pFileObject);
    ObDereferenceObject(pFileObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_HID_GET_COLLECTION_INFORMATION,
                                  pDeviceObject,
                                  NULL,
                                  0, // No Input buffer
                                  &hidCollection,
                                  sizeof(hidCollection), // Output buffer
                                  FALSE,    // no internal device control
                                  &event,
                                  &iob);

    if (irp == NULL) {
        RIPMSGF0(RIP_WARNING, "failed to build IRP 1");
        goto CleanUpDeviceObject;
    }

    status = IoCallDriver(pDeviceObject, irp);
    if (status == STATUS_PENDING) {
        TAGMSGF0(DBGTAG_PNP, "pending IRP 1.");
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = iob.Status;
    }

    if (status != STATUS_SUCCESS) {
        RIPMSGF0(RIP_WARNING, "IoCallDriver failed!");
        goto CleanUpDeviceObject;
    }

    /*
     * Get the preparsed data for this device
     */
    pPreparsedData = UserAllocPoolNonPaged(hidCollection.DescriptorSize, TAG_PNP);
    if (pPreparsedData == NULL) {
        RIPMSGF0(RIP_WARNING, "failed to allocate preparsed data.");
        goto CleanUpDeviceObject;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                        pDeviceObject,
                                        NULL, 0,    // No input buffer
                                        pPreparsedData,
                                        hidCollection.DescriptorSize,   // Output
                                        FALSE,
                                        &event,
                                        &iob);
    if (irp == NULL) {
        RIPMSGF0(RIP_WARNING, "failed to build IRP 2");
        goto CleanUpPreparsedData;
    }

    status = IoCallDriver(pDeviceObject, irp);
    if (status == STATUS_PENDING) {
        RIPMSGF0(RIP_WARNING, "pending 2.");
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = iob.Status;
    }

    if (status != STATUS_SUCCESS) {
        RIPMSGF1(RIP_WARNING, "failed IoCallDriver(2). st=%x", status);
        goto CleanUpPreparsedData;
    }

    /*
     * Get the HID Caps, check it, and store it in HIDDESC.
     */
    status = xxxHidGetCaps(pDeviceObject, (PHIDP_PREPARSED_DATA)pPreparsedData, &caps);
    if (status != HIDP_STATUS_SUCCESS) {
        RIPMSGF2(RIP_WARNING, "failed to get caps for devobj=%p. status=%x",
                pDeviceObject, status);
        goto CleanUpPreparsedData;
    }

    TAGMSGF2(DBGTAG_PNP | RIP_THERESMORE, "UsagePage=%x, Usage=%x", caps.UsagePage, caps.Usage);
    TAGMSG2(DBGTAG_PNP, "InputReportByteLength=0x%x, FeatureByteLengt=0x%x",
            caps.InputReportByteLength,
            caps.FeatureReportByteLength);

    /*
     * Check the UsagePage/Usage to reject mice and keyboard devices as HID
     */
    if (caps.UsagePage == HID_USAGE_PAGE_GENERIC) {
        switch (caps.Usage) {
        case HID_USAGE_GENERIC_KEYBOARD:
        case HID_USAGE_GENERIC_MOUSE:
        case HID_USAGE_GENERIC_POINTER:
        case HID_USAGE_GENERIC_SYSTEM_CTL:  // LATER: what is this really?
            TAGMSGF2(DBGTAG_PNP, "(%x, %x) will be ignored.",
                    caps.UsagePage, caps.Usage);
            goto CleanUpPreparsedData;
        }
    }
#ifdef OBSOLETE
    else if (caps.UsagePage == HID_USAGE_PAGE_CONSUMER) {
        TAGMSGF0(DBGTAG_PNP, "Consumer device, ignored.");
        goto CleanUpPreparsedData;
    }
#endif

    pHidDesc = AllocateHidDesc(&pDeviceInfo->ustrName, pPreparsedData, &caps, &hidCollection);
    if (pHidDesc == NULL) {
        TAGMSGF2(DBGTAG_PNP, "AllocateHidDesc returned NULL for (%x, %x)", caps.UsagePage, caps.Usage);
        goto CleanUpPreparsedData;
    }

    /*
     * Check if there's already a HID request for this type of device.
     */
    pTLCInfo = SearchHidTLCInfo(caps.UsagePage, caps.Usage);
    if (pTLCInfo) {
        /*
         * Found the one.
         */
        TAGMSGF3(DBGTAG_PNP, "Usage (%x, %x) is already allocated at pTLCInfo=%p.", caps.UsagePage, caps.Usage, pTLCInfo);
    } else {
        /*
         * HID request for this device type is not yet created,
         * so create it now.
         */
        pTLCInfo = AllocateAndLinkHidTLCInfo(caps.UsagePage, caps.Usage);
        if (pTLCInfo == NULL) {
            RIPMSGF1(RIP_WARNING, "failed to allocate pTLCInfo for DevInfo=%p. Bailing out.",
                    pDeviceInfo);
            goto CleanUpHidDesc;
        }
        TAGMSGF3(DBGTAG_PNP, "HidRequest=%p allocated for (%x, %x)",
                pTLCInfo, caps.UsagePage, caps.Usage);
    }
    /*
     * Increment the device ref count of the Hid Request.
     */
    ++pTLCInfo->cDevices;
    TAGMSGF3(DBGTAG_PNP, "new cDevices of (%x, %x) is 0x%x",
            caps.UsagePage, caps.Usage,
            pTLCInfo->cDevices);

    /*
     * Link the Hid request to pDeviceInfo.
     */
    pDeviceInfo->hid.pTLCInfo = pTLCInfo;

    UserAssert(pHidDesc != NULL);
    ObDereferenceObject(pDeviceObject);
    goto Succeeded;

CleanUpHidDesc:
    UserAssert(pHidDesc);
    FreeHidDesc(pHidDesc);
    pHidDesc = NULL;
    /*
     * The ownership of pPreparsedData was passed to pHidDesc,
     * so it's freed in FreeHidDesc. To avoid the double
     * free, let's skip to the next cleanup code.
     */
    goto CleanUpDeviceObject;

CleanUpPreparsedData:
    UserAssert(pPreparsedData);
    UserFreePool(pPreparsedData);

CleanUpDeviceObject:
    UserAssert(pDeviceObject);
    ObDereferenceObject(pDeviceObject);

CleanUp0:
    UserAssert(pHidDesc == NULL);

Succeeded:
    ENDATOMICCHECK();

    return pHidDesc;
}


/***************************************************************************\
* HidIsRequestedByThisProcess
*
* Returns TRUE if the device type is requested by the process.
* This routines looks up the cached device type for faster processing.
*
* N.b. this routine also updates the cache locally.
\***************************************************************************/

PPROCESS_HID_REQUEST HidIsRequestedByThisProcess(
    PDEVICEINFO pDeviceInfo,
    PPROCESS_HID_TABLE pHidTable)
{
    PPROCESS_HID_REQUEST phr;
    USAGE usUsagePage, usUsage;

    if (pHidTable == NULL) {
        TAGMSG0(DBGTAG_PNP, "ProcessHidInput: the process is not HID aware.");
        return FALSE;
    }

    usUsagePage = pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage;
    usUsage = pDeviceInfo->hid.pHidDesc->hidpCaps.Usage;

    if (pHidTable->UsagePageLast == usUsagePage && pHidTable->UsageLast == usUsage) {
        /*
         * The same device type as the last input.
         */
        UserAssert(pHidTable->UsagePageLast && pHidTable->UsageLast);
        UserAssert(pHidTable->pLastRequest);
        return pHidTable->pLastRequest;
    }

    phr = InProcessDeviceTypeRequestTable(pHidTable, usUsagePage, usUsage);
    if (phr) {
        pHidTable->UsagePageLast = usUsagePage;
        pHidTable->UsageLast = usUsage;
        pHidTable->pLastRequest = phr;
    }
    return phr;
}

#ifdef GI_SINK

BOOL PostHidInput(
    PDEVICEINFO pDeviceInfo,
    PQ pq,
    PWND pwnd,
    WPARAM wParam)
{
    DWORD dwSizeData = (DWORD)pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength;
    DWORD dwLength = (DWORD)pDeviceInfo->iosb.Information;
    DWORD dwSize;
    DWORD dwCount;
    PHIDDATA pHidData;

    UserAssert(dwSizeData != 0);
#if DBG
    if (dwLength > dwSizeData) {
        TAGMSG2(DBGTAG_PNP, "PostHidInput: multiple input; %x / %x", pDeviceInfo->iosb.Information, dwSizeData);
    }
#endif

    /*
     * Validate the input length.
     */
    if (dwLength % dwSizeData != 0) {
        /*
         * Input report has invalid length.
         */
        RIPMSG0(RIP_WARNING, "PostHidInput: multiple input: unexpected report size.");
        return FALSE;
    }
    dwCount = dwLength / dwSizeData;
    UserAssert(dwCount <= MAXIMUM_ITEMS_READ);
    if (dwCount == 0) {
        RIPMSG0(RIP_WARNING, "PostHidInput: dwCount == 0");
        return FALSE;
    }
    UserAssert(dwSizeData * dwCount == dwLength);

    /*
     * Calculate the required size for RAWHID.
     */
    dwSize = FIELD_OFFSET(RAWHID, bRawData) + dwLength;

    /*
     * Allocate the input data handle.
     */
    pHidData = AllocateHidData(PtoH(pDeviceInfo), RIM_TYPEHID, dwSize, wParam, pwnd);
    if (pHidData == NULL) {
        RIPMSG0(RIP_WARNING, "PostHidInput: failed to allocate HIDDATA.");
        return FALSE;
    }

    /*
     * Fill the data in.
     */
    pHidData->rid.data.hid.dwSizeHid = dwSizeData;
    pHidData->rid.data.hid.dwCount = dwCount;
    RtlCopyMemory(pHidData->rid.data.hid.bRawData, pDeviceInfo->hid.pHidDesc->pInputBuffer, dwLength);

#if DBG
    {
        PBYTE pSrc = pDeviceInfo->hid.pHidDesc->pInputBuffer;
        PBYTE pDest = pHidData->rid.data.hid.bRawData;
        DWORD dwCountTmp = 0;

        while ((ULONG)(pSrc - (PBYTE)pDeviceInfo->hid.pHidDesc->pInputBuffer) < dwLength) {
            TAGMSG3(DBGTAG_PNP, "PostHidInput: storing %x th message from %p to %p",
                    dwCountTmp, pSrc, pDest);

            pSrc += dwSizeData;
            pDest += dwSizeData;
            ++dwCountTmp;
        }

        UserAssert(pHidData->rid.data.hid.dwCount == dwCountTmp);
    }
#endif

    /*
     * All the data are ready to fly.
     */
    if (!PostInputMessage(pq, pwnd, WM_INPUT, wParam, (LPARAM)PtoH(pHidData), 0, 0)) {
        /*
         * Failed to post the message, hHidData needs to be freed.
         */
        RIPMSG2(RIP_WARNING, "PostInputMessage: failed to post WM_INPUT (%p) to pq=%p",
                wParam, pq);
        FreeHidData(pHidData);
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* ProcessHidInput (RIT)
*
* Called from InputAPC for all input from HID devices.
\***************************************************************************/

VOID ProcessHidInput(PDEVICEINFO pDeviceInfo)
{
    PPROCESSINFO ppiForeground = NULL;
    BOOL fProcessed = FALSE;

    TAGMSG1(DBGTAG_PNP, "ProcessHidInput: pDeviceInfo=%p", pDeviceInfo);
    CheckCritOut();
    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);

    if (!NT_SUCCESS(pDeviceInfo->iosb.Status)) {
        RIPMSG1(RIP_WARNING, "ProcessHidInput: unsuccessful input apc. status=%x",
                pDeviceInfo->iosb.Status);
        return;
    }

    EnterCrit();

    TAGMSG2(DBGTAG_PNP, "ProcessHidInput: max:%x info:%x",
            pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength, pDeviceInfo->iosb.Information);

    UserAssert(pDeviceInfo->handle);

    if (gpqForeground == NULL) {
        TAGMSG0(DBGTAG_PNP, "ProcessHidInput: gpqForeground is NULL.");
    } else {
        PWND pwnd = NULL;
        PPROCESS_HID_REQUEST pHidRequest;

        UserAssert(PtiKbdFromQ(gpqForeground) != NULL);
        ppiForeground = PtiKbdFromQ(gpqForeground)->ppi;

        pHidRequest = HidIsRequestedByThisProcess(pDeviceInfo, ppiForeground->pHidTable);
        if (pHidRequest) {
            PQ pq = gpqForeground;

            pwnd = pHidRequest->spwndTarget;

            if (pwnd) {
                /*
                 * Adjust the foreground queue, if the app specified
                 * the target window.
                 */
                pq = GETPTI(pwnd)->pq;
            }

            if (pwnd && TestWF(pwnd, WFINDESTROY)) {
                /*
                 * If the target window is in destroy, let's not post
                 * a message, it's just waste of time.
                 */
                goto check_sinks;
            }

            if (PostHidInput(pDeviceInfo, pq, pwnd, RIM_INPUT)) {
                fProcessed = TRUE;
            }
        } else {
            /*
             * No request for this device from the foreground process.
             */
            TAGMSG3(DBGTAG_PNP, "ProcessHidInput: (%x, %x) is ignored for ppi=%p.",
                    pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage,
                    pDeviceInfo->hid.pHidDesc->hidpCaps.Usage,
                    PtiKbdFromQ(gpqForeground)->ppi);
        }
    }

check_sinks:
#ifdef LATER
    /*
     * Check if multiple process requests this type of devices.
     */
    if (IsSinkRequestedFor(pDeviceInfo))
#endif
    {
        /*
         * Walk through the global sink list and find the sinkable request.
         */
        PLIST_ENTRY pList = gHidRequestTable.ProcessRequestList.Flink;

        for (; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
            PPROCESS_HID_TABLE pProcessHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);
            PPROCESS_HID_REQUEST pHidRequest;

            UserAssert(pProcessHidTable);
            if (pProcessHidTable->nSinks <= 0) {
                /*
                 * No sinkable request in this table.
                 */
                continue;
            }

            pHidRequest = HidIsRequestedByThisProcess(pDeviceInfo, pProcessHidTable);
            if (pHidRequest) {
                PWND pwnd;

                UserAssert(pHidRequest->spwndTarget);

                if (!pHidRequest->fSinkable) {
                    /*
                     * It's not a sink.
                     */
                    continue;
                }

                pwnd = pHidRequest->spwndTarget;

                if (GETPTI(pwnd)->ppi == ppiForeground) {
                    /*
                     * We should have already processed this guy.
                     */
                    continue;
                }

                if (pwnd->head.rpdesk != grpdeskRitInput) {
                    /*
                     * This guy belongs to the other desktop, let's skip it.
                     */
                    continue;
                }
                if (TestWF(pwnd, WFINDESTROY) || TestWF(pwnd, WFDESTROYED)) {
                    /*
                     * The window is being destroyed, let's save some time.
                     */
                    continue;
                }

                /*
                 * OK, this guy has the right to receive the sink input.
                 */
                TAGMSG2(DBGTAG_PNP, "ProcessRequestList: posting SINK to pwnd=%p pq=%p", pwnd, GETPTI(pwnd)->pq);
                if (!PostHidInput(pDeviceInfo, GETPTI(pwnd)->pq, pwnd, RIM_INPUTSINK)) {
                    /*
                     * Something went bad... let's bail out.
                     */
                    break;
                }
                fProcessed = TRUE;
            }
        }
    }

    if (fProcessed) {
        /*
         * Exit the video power down mode.
         */
        if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
            /*
             * Call video driver here to exit power down mode.
             */
            TAGMSG0(DBGTAG_Power, "Exit video power down mode");
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        }

        /*
         * Prevents power off:
         * LATER: devices with possible chattering???
         */
        glinp.dwFlags = (glinp.dwFlags & ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES)) | LINP_KEYBOARD;
        glinp.timeLastInputMessage = gpsi->dwLastRITEventTickCount = NtGetTickCount();
        /*
         * N.b. when win32k starts to support HID input injection,
         * timeLastInputMessage should only be set after checking gbBlockSendInputResets
         * and the injection flag.
         */
        CLEAR_SRVIF(SRVIF_LASTRITWASKEYBOARD);
    }

    LeaveCrit();
}

#else
// without SINK

/***************************************************************************\
* ProcessHidInput (RIT)
*
* Called from InputAPC for all input from HID devices.
\***************************************************************************/

VOID ProcessHidInput(PDEVICEINFO pDeviceInfo)
{
    TAGMSG1(DBGTAG_PNP, "ProcessHidInput: pDeviceInfo=%p", pDeviceInfo);
    CheckCritOut();
    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);

    if (!NT_SUCCESS(pDeviceInfo->iosb.Status)) {
        RIPMSG1(RIP_WARNING, "ProcessHidInput: unsuccessful input apc. status=%x",
                pDeviceInfo->iosb.Status);
        return;
    }

    EnterCrit();

    TAGMSG2(DBGTAG_PNP, "ProcessHidInput: max:%x info:%x",
            pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength, pDeviceInfo->iosb.Information);

    UserAssert(pDeviceInfo->handle);
    if (gpqForeground == NULL) {
        RIPMSG0(RIP_WARNING, "ProcessHidInput: gpqForeground is NULL, bailing out.");
    } else {
        PWND pwnd = NULL;
        PPROCESSINFO ppi;
        PPROCESS_HID_REQUEST pHidRequest;

        UserAssert(PtiKbdFromQ(gpqForeground) != NULL);
        ppi = PtiKbdFromQ(gpqForeground)->ppi;

        pHidRequest = HidIsRequestedByThisProcess(pDeviceInfo, ppi->pHidTable);
        if (pHidRequest) {
            /*
             * The foreground thread has requested the raw input from this type of device.
             */
            PHIDDATA pHidData;
            DWORD dwSizeData;   // size of each report
            DWORD dwSize;       // size of HIDDATA
            DWORD dwCount;      // number of report
            DWORD dwLength;     // length of all input reports
            PQ pq;

            pwnd = pHidRequest->spwndTarget;


            pq = gpqForeground;

            if (pwnd) {
                /*
                 * Adjust the foreground queue, if the app specified
                 * the target window.
                 */
                pq = GETPTI(pwnd)->pq;
            }

            if (pwnd && TestWF(pwnd, WFINDESTROY)) {
                /*
                 * If the target window is in destroy, let's not post
                 * a message, it's just waste of time.
                 */
                goto exit;
            }

            dwSizeData = (DWORD)pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength;
            UserAssert(dwSizeData != 0);

            dwLength = (DWORD)pDeviceInfo->iosb.Information;
#if DBG
            if (dwLength > dwSizeData) {
                TAGMSG2(DBGTAG_PNP, "ProcessHidInput: multiple input; %x / %x", pDeviceInfo->iosb.Information, dwSizeData);
            }
#endif

            /*
             * Validate the input length.
             */
            if (dwLength % dwSizeData != 0) {
                /*
                 * Input report has invalid length.
                 */
                RIPMSG0(RIP_WARNING, "ProcessHidInput: multiple input: unexpected report size.");
                goto exit;
            }
            dwCount = dwLength / dwSizeData;
            UserAssert(dwCount <= MAXIMUM_ITEMS_READ);
            if (dwCount == 0) {
                RIPMSG0(RIP_WARNING, "ProcessHidInput: dwCount == 0");
                goto exit;
            }
            UserAssert(dwSizeData * dwCount == dwLength);

            /*
             * Calculate the required size for RAWHID.
             */
            dwSize = FIELD_OFFSET(RAWHID, bRawData) + dwLength;

            /*
             * Allocate the input data handle.
             */
            pHidData = AllocateHidData(PtoH(pDeviceInfo), RIM_TYPEHID, dwSize, RIM_INPUT, pwnd);
            if (pHidData == NULL) {
                RIPMSG0(RIP_WARNING, "ProcessHidInput: failed to allocate HIDDATA.");
                goto exit;
            }

            /*
             * Fill the data in.
             */
            pHidData->rid.data.hid.dwSizeHid = dwSizeData;
            pHidData->rid.data.hid.dwCount = dwCount;
            RtlCopyMemory(pHidData->rid.data.hid.bRawData, pDeviceInfo->hid.pHidDesc->pInputBuffer, dwLength);

#if DBG
            {
                PBYTE pSrc = pDeviceInfo->hid.pHidDesc->pInputBuffer;
                PBYTE pDest = pHidData->rid.data.hid.bRawData;
                DWORD dwCountTmp = 0;

                while ((ULONG)(pSrc - (PBYTE)pDeviceInfo->hid.pHidDesc->pInputBuffer) < dwLength) {
                    TAGMSG3(DBGTAG_PNP, "ProcessHidInput: storing %x th message from %p to %p",
                            dwCountTmp, pSrc, pDest);

                    pSrc += dwSizeData;
                    pDest += dwSizeData;
                    ++dwCountTmp;
                }

                UserAssert(pHidData->rid.data.hid.dwCount == dwCountTmp);
            }
#endif

            /*
             * All the data are ready to fly.
             */
            if (!PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoH(pHidData), 0, 0)) {
                /*
                 * Failed to post the message, hHidData needs to be freed.
                 */
                FreeHidData(pHidData);
            }

            /*
             * Prevents power off:
             * LATER: devices with possible chattering???
             */
            glinp.dwFlags &= ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES);
            glinp.timeLastInputMessage = gpsi->dwLastRITEventTickCount = NtGetTickCount();
            if (gpsi->dwLastRITEventTickCount - gpsi->dwLastSystemRITEventTickCountUpdate > SYSTEM_RIT_EVENT_UPDATE_PERIOD) {
                SharedUserData->LastSystemRITEventTickCount = gpsi->dwLastRITEventTickCount;
                gpsi->dwLastSystemRITEventTickCountUpdate = gpsi->dwLastRITEventTickCount;
            }

            CLEAR_SRVIF(SRVIF_LASTRITWASKEYBOARD);
        } else {
            /*
             * No request for this device from the foreground process.
             */
            TAGMSG3(DBGTAG_PNP, "ProcessHidInput: (%x, %x) is ignored for ppi=%p.",
                    pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage,
                    pDeviceInfo->hid.pHidDesc->hidpCaps.Usage,
                    PtiKbdFromQ(gpqForeground)->ppi);
        }
    }

exit:
    LeaveCrit();
}
#endif  // GI_SINK

#endif  // GENERIC_INPUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\handtabl.c ===
/****************************** Module Header ******************************\
* Module Name: handtabl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implements the USER handle table.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(INIT, HMInitHandleTable)

#if DBG

#define HTIENTRY(szObjectType, structName, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {szObjectType, sizeof(structName), (FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#define HTIENTRY_VARIABLESIZE(szObjectType, dwSize, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {szObjectType, dwSize, (FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#else // DBG

#define HTIENTRY(szObjectType, structName, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {(FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#define HTIENTRY_VARIABLESIZE(szObjectType, dwSize, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {(FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#endif // DBG

VOID HMNullFnDestroy(
    PVOID pobj)
{
    RIPMSG1(RIP_WARNING, "HM: No clean up function for 0x%p", pobj);
    HMDestroyObject(pobj);
}

/***************************************************************************\
*
* Table of user objects statistics.  Used by userkdx.dumhmgr debugger extension
*
\***************************************************************************/

#if DBG
PERFHANDLEINFO gaPerfhti[TYPE_CTYPES];  /* stores current counts */
PERFHANDLEINFO gaPrevhti[TYPE_CTYPES];  /* stores previous counts */
#endif // DBG

#if DBG || FRE_LOCK_RECORD
DWORD gdwLockRecordFlags;

BOOL RecordLockThisType(
    PVOID pobj)
{
    BOOL bRecord;
    PHE phe = HMPheFromObject(pobj);

    bRecord = (gdwLockRecordFlags & (1 << (phe->bType)));

    return bRecord;
}
#endif

/***************************************************************************\
*
* Table of handle type information.
*
* Desktop and Shared Heap objects can't be tagged as yet
* (TAG_WINDOW is bogus for heap windows, but not for desktop and other
* windows allocated in pool).
*
* WARNING: Keep it in sync with aszTypeNames table from ntuser\kdexts\userexts.c
*
* All HM objects must start with a HEAD structure. In addition:
* (If you find these comments to be wrong, please fix them)
*
* OCF_PROCESSOWNED: Object must start with a PROC*HEAD structure
*                   A ptiOwner must be provided
*                   The object affects the handle quota (ppi->UserHandleCount)
*                   The object will be destroyed if the process goes away.
*
* OCF_MARKPROCESS:  Object must start with a PROCMARKHEAD structure
*                   A ptiOwner must be provided
*                   It must not use OCF_DESKTOPHEAP (implementation limitation)
*
* OCF_THREADOWNED:  Object must start with a THR*HEAD structure
*                   The object affects the handle quota (ppi->UserHandleCount)
*                   The object will be destroyed if the thread goes away.
*
* OCF_DESKTOPHEAP:  Object must start with a *DESKHEAD structure
*                   A pdeskSrc must be provided at allocation time
*                   It must not use OCF_MARKPROCESS (implementation limitation)
*
\***************************************************************************/

#if (TYPE_FREE != 0)
#error TYPE_FREE must be zero.
#endif

CONST HANDLETYPEINFO gahti[TYPE_CTYPES] = {
    /* TYPE_FREE - HEAD */
    HTIENTRY("Free", HEAD,
             NULL,
             0,
             0),

    /* TYPE_WINDOW - WND(THRDESKHEAD) */
    HTIENTRY("Window", WND,
             xxxDestroyWindow,
             TAG_WINDOW,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA | OCF_DESKTOPHEAP | OCF_USEPOOLIFNODESKTOP | OCF_VARIABLESIZE),

    /* TYPE_MENU - MENU(PROCDESKHEAD) */
    HTIENTRY("Menu", MENU,
             _DestroyMenu,
             0,
             OCF_PROCESSOWNED | OCF_DESKTOPHEAP),

    /* TYPE_CURSOR - CURSOR(PROCMARKHEAD) or ACON(PROCMARKHEAD) */
    HTIENTRY("Icon/Cursor", CURSOR,
             DestroyUnlockedCursor,
             TAG_CURSOR,
             OCF_PROCESSOWNED | OCF_MARKPROCESS | OCF_USEPOOLQUOTA),

    /* TYPE_SETWINDOWPOS - SMWP(HEAD) */
    HTIENTRY("WPI(SWP) structure", SMWP,
             DestroySMWP,
             TAG_SWP,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_HOOK - HOOK(THRDESKHEAD) */
    HTIENTRY("Hook", HOOK,
             FreeHook,
             0,
             OCF_THREADOWNED | OCF_DESKTOPHEAP),

    /* TYPE_CLIPDATA -  CLIPDATA(HEAD) */
    HTIENTRY("Clipboard Data", CLIPDATA,
             HMNullFnDestroy,
             TAG_CLIPBOARD,
             OCF_VARIABLESIZE),

    /* TYPE_CALLPROC - CALLPROCDATA(THRDESKHEAD) */
    HTIENTRY("CallProcData", CALLPROCDATA,
             HMDestroyObject,
             0,
             OCF_PROCESSOWNED | OCF_DESKTOPHEAP),

    /* TYPE_ACCELTABLE - ACCELTABLE(PROCOBJHEAD) */
    HTIENTRY("Accelerator", ACCELTABLE,
             HMDestroyObject,
             TAG_ACCEL,
             OCF_PROCESSOWNED | OCF_USEPOOLQUOTA | OCF_VARIABLESIZE),

    /* TYPE_DDEACCESS - SVR_INSTANCE_INFO(THROBJHEAD) */
    HTIENTRY("DDE access", SVR_INSTANCE_INFO,
             HMNullFnDestroy,
             TAG_DDE9,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_DDECONV - DDECONV(THROBJHEAD) */
    HTIENTRY("DDE conv", DDECONV,
             FreeDdeConv,
             TAG_DDEa,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_DDEXACT - XSTATE(THROBJHEAD) */
    HTIENTRY("DDE Transaction", XSTATE,
             FreeDdeXact,
             TAG_DDEb,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_MONITOR - MONITOR(HEAD) */
    HTIENTRY("Monitor", MONITOR,
             DestroyMonitor,
             TAG_DISPLAYINFO,
             OCF_SHAREDHEAP),

    /* TYPE_KBDLAYOUT - KL(HEAD) */
    HTIENTRY("Keyboard Layout",  KL,
             DestroyKL,
             TAG_KBDLAYOUT,
             0),

    /* TYPE_KBDFILE - KBDFILE(HEAD) */
    HTIENTRY("Keyboard File", KBDFILE,
             DestroyKF,
             TAG_KBDFILE,
             0),

    /* TYPE_WINEVENTHOOK - EVENTHOOK(THROBJHEAD) */
    HTIENTRY("WinEvent hook", EVENTHOOK,
             DestroyEventHook,
             TAG_WINEVENT,
             OCF_THREADOWNED),


    /* TYPE_TIMER - TIMER(HEAD) */
    HTIENTRY("Timer", TIMER,
             FreeTimer,
             TAG_TIMER,
             0),

    /* TYPE_INPUTCONTEXT - IMC(THRDESKHEAD) */
    HTIENTRY("Input Context", IMC,
             FreeInputContext,
             TAG_IME,
             OCF_THREADOWNED | OCF_DESKTOPHEAP),

#ifdef GENERIC_INPUT
    /* TYPE_HIDDATA - HIDDATA(THROBJHEAD) */
    HTIENTRY_VARIABLESIZE("HID Raw Data",
             FIELD_OFFSET(HIDDATA, rid.data.hid.bRawData),
             FreeHidData,
             TAG_HIDDATA,
             OCF_THREADOWNED | OCF_VARIABLESIZE),

    /* TYPE_DEVICEINFO - DEVICEINFO(HEAD) */
    HTIENTRY("Device Info", GENERIC_DEVICE_INFO,
            FreeDeviceInfo,
            TAG_DEVICEINFO,
            OCF_VARIABLESIZE),

#endif  // GENERIC_INPUT
};

/*
 * Handle table allocation globals.  The purpose of keeping per-page free
 * lists is to keep the table as small as is practical and to minimize
 * the number of pages touched while performing handle table operations.
 */
#define CPAGEENTRIESINIT    4

DWORD gcHandlePages;
PHANDLEPAGE gpHandlePages;

#if DBG || FRE_LOCK_RECORD
PPAGED_LOOKASIDE_LIST LockRecordLookaside;

NTSTATUS InitLockRecordLookaside(VOID);
VOID FreeLockRecord(PLR plr);
VOID InitGlobalThreadLockArray(DWORD dwIndex);
VOID ShowLocks(PHE);
#endif

VOID HMDestroyUnlockedObject(PHE phe);
VOID HMRecordLock(PVOID ppobj, PVOID pobj, DWORD cLockObj);
BOOL HMUnrecordLock(PVOID ppobj, PVOID pobj);



/***************************************************************************\
* DBGValidateHandleQuota
*
* 11-19-97 GerardoB         Created.
\***************************************************************************/
#ifdef VALIDATEHANDLEQUOTA
VOID DBGValidateHandleQuota(
    VOID)
{
    BYTE bCreateFlags;
    DWORD dw;
    HANDLEENTRY * phe;

    PPROCESSINFO ppiT = gppiList;

    while (ppiT != NULL) {
        ppiT->lHandles = 0;
        ppiT = ppiT->ppiNextRunning;
    }

    phe = gSharedInfo.aheList;
    for (dw = 0; dw <= giheLast; dw++, phe++) {
        if (phe->bType == TYPE_FREE) {
            UserAssert(phe->pOwner == NULL);
            continue;
        }
        bCreateFlags = gahti[phe->bType].bObjectCreateFlags;
        if (bCreateFlags & OCF_PROCESSOWNED) {
            ((PPROCESSINFO)phe->pOwner)->lHandles++;
            continue;
        }
        if (bCreateFlags & OCF_THREADOWNED) {
            ((PTHREADINFO)phe->pOwner)->ppi->lHandles++;
            continue;
        }
        UserAssert(phe->pOwner == NULL);
    }

    ppiT = gppiList;
    while (ppiT != NULL) {
        UserAssert(ppiT->lHandles == ppiT->UserHandleCount);
        ppiT = ppiT->ppiNextRunning;
    }
}
#else
#define DBGValidateHandleQuota()
#endif
/***************************************************************************\
* DBGHMPheFromObject
*
* Validates and returns the HANDLEENTRY corresponding to a given object
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
PHE DBGHMPheFromObject(
    PVOID p)
{
    PHE phe = _HMPheFromObject(p);

    UserAssert(phe->phead == p);
    UserAssert(_HMObjectFromHandle(phe->phead->h) == p);
    UserAssert(phe->wUniq == HMUniqFromHandle(phe->phead->h));
    UserAssert(phe->bType < TYPE_CTYPES);
    UserAssert((phe->pOwner != NULL)
                || !(gahti[phe->bType].bObjectCreateFlags & (OCF_PROCESSOWNED | OCF_THREADOWNED)));
    UserAssert(!(phe->bFlags & ~HANDLEF_VALID));

    return phe;
}
#endif

/***************************************************************************\
* DBGHMPheFromObject
*
* Validates and returns the object corresponding to a given handle.
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
PVOID DBGHMObjectFromHandle(
    HANDLE h)
{
    PVOID p = _HMObjectFromHandle(h);

    UserAssert((h != NULL) ^ (p == NULL));
    if (p != NULL) {
        UserAssert(HMIndexFromHandle(((PHEAD)p)->h) == HMIndexFromHandle(h));
        UserAssert(p == HMRevalidateCatHandle(h));

        /*
         * This routine, unlike Validation, should return a real pointer if
         * the object exists, even if it is destroyed. But we should still
         * generate a warning.
         */
        if (HMPheFromObject(p)->bFlags & HANDLEF_DESTROY) {
            RIPMSGF1(RIP_WARNING, "Object p 0x%p is destroyed", p);
        }
    }

    return p;
}

PVOID DBGHMCatObjectFromHandle(
    HANDLE h)
{
    /*
     * Note -- at this point, _HMObjectFromHandle does not check to see if
     * an object is destroyed.
     */
    PVOID p = _HMObjectFromHandle(h);

    UserAssert((h != NULL) ^ (p == NULL));
    if (p != NULL) {
        UserAssert(HMIndexFromHandle(((PHEAD)p)->h) == HMIndexFromHandle(h));
        UserAssert(p == HMRevalidateCatHandle(h));
    }

    return p;
}
#endif

/***************************************************************************\
* DBGPtoH and DBGPtoHq
*
* Validates and returns the handle corresponding to a given object
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
VOID DBGValidatePtoH(
    PVOID p,
    HANDLE h)
{
    UserAssert((h != NULL) ^ (p == NULL));
    if (h != NULL) {
        UserAssert(p == HMRevalidateCatHandle(h));
    }
}

HANDLE DBGPtoH (PVOID p)
{
    HANDLE h = _PtoH(p);

    DBGValidatePtoH(p, h);

    return h;
}

HANDLE DBGPtoHq (PVOID p)
{
    HANDLE h;

    UserAssert(p != NULL);

    h = _PtoHq(p);
    DBGValidatePtoH(p, h);

    return h;
}
#endif

/***************************************************************************\
* DBGHW and DBGHWq
*
* Validates and returns the hwnd corresponding to a given pwnd.
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
VOID DBGValidateHW(
    PWND pwnd,
    HWND hwnd)
{
    UserAssert((hwnd != NULL) ^ (pwnd == NULL));

    if (hwnd != NULL) {
        UserAssert(pwnd == HMValidateCatHandleNoSecure(hwnd, TYPE_WINDOW));
    }
}

PVOID DBGValidateHWCCX(
    PWND ccxPwnd,
    HWND hwnd,
    PTHREADINFO pti)
{
    PVOID pobj = NULL;

    UserAssert((hwnd != NULL) ^ (ccxPwnd == NULL));
    if (hwnd != NULL) {
        pobj = HMValidateCatHandleNoSecureCCX(hwnd, TYPE_WINDOW, pti);
        UserAssert(ccxPwnd == pobj);
    }

    return pobj;
}

HWND DBGHW(
    PWND pwnd)
{
    HWND hwnd = _HW(pwnd);

    DBGValidateHW(pwnd, hwnd);

    return hwnd;
}

HWND DBGHWCCX(
    PWND ccxPwnd)
{
    HWND hwnd = _HWCCX(ccxPwnd);
    PWND pwndK = RevalidateHwnd(hwnd);
    PTHREADINFO pti = _GETPTI(pwndK);
    PWND pwnd = NULL;

    CheckCritIn();

    if (pwndK) {
        pwnd = (PWND) DBGValidateHWCCX(ccxPwnd, hwnd, pti);
    }

    if (pwnd == ccxPwnd) {
        if (!KeIsAttachedProcess()) {
            UserAssert(PpiCurrent() == _GETPTI(pwndK)->ppi);
        }
    }

    return hwnd;
}

HWND DBGHWq(
    PWND pwnd)
{
    HWND hwnd;

    UserAssert(pwnd != NULL);
    hwnd = _HWq(pwnd);

    DBGValidateHW(pwnd, hwnd);

    return hwnd;
}
#endif

/***************************************************************************\
* DBGHMValidateFreeLists
*
* Walks all handle free lists to make sure all links are fine.
*
* 10/08/97  GerardoB    Created
\***************************************************************************/
#if DBG
VOID DBGHMValidateFreeList(
    ULONG_PTR iheFreeNext,
    BOOL fEven)
{
    PHE phe;

    do {
        UserAssert(fEven ^ !!(iheFreeNext & 0x1));
        UserAssert(iheFreeNext < gpsi->cHandleEntries);
        phe = &gSharedInfo.aheList[iheFreeNext];
        UserAssert(phe->bType == TYPE_FREE);
        UserAssert(phe->pOwner == NULL);
        UserAssert(phe->bFlags == 0);
        iheFreeNext = (ULONG_PTR)phe->phead;
    } while (iheFreeNext != 0);
}

VOID DBGHMValidateFreeLists(
    VOID)
{
    DWORD dw;
    PHANDLEPAGE php = gpHandlePages;

    for (dw = 0; dw < gcHandlePages; ++dw, ++php) {
        if (php->iheFreeEven != 0) {
            DBGHMValidateFreeList(php->iheFreeEven, TRUE);
        }

        if (php->iheFreeOdd != 0) {
            DBGHMValidateFreeList(php->iheFreeOdd, FALSE);
        }
    }
}
#else
#define DBGHMValidateFreeLists()
#endif

#if DBG || FRE_LOCK_RECORD

/***************************************************************************\
* DbgDumpHandleTable
*
\***************************************************************************/
DWORD DbgDumpHandleTable(
    VOID)
{
    DWORD dw;
    PHE   phe;
    DWORD dwHandles = 0;

    phe = gSharedInfo.aheList;

    if (phe == NULL) {
        KdPrint(("\nTERMSRV\nEmpty handle table\n"));
        return 0;
    }

    KdPrint(("\nTERMSRV\nDump the handle table\n"));
    KdPrint(("---------------------------------------------------\n"));
    KdPrint(("     phead    handle   lock     pOwner   type flags\n"));
    KdPrint(("---------------------------------------------------\n"));

    for (dw = 0; dw <= giheLast; dw++, phe++) {
        if (phe->bType == TYPE_FREE) {
            UserAssert(phe->pOwner == NULL);
            continue;
        }

        KdPrint(("%04d %08x %08x %08d %08x %04x %05x\n",
                 dwHandles++,
                 phe->phead,
                 phe->phead->h,
                 phe->phead->cLockObj,
                 phe->pOwner,
                 phe->bType,
                 phe->bFlags));
    }

    KdPrint(("----------------------------------------------\n"));
    KdPrint(("Number of handles left: %d\n", dwHandles));
    KdPrint(("End of handle table\n"));

    UserAssert(dwHandles == 0);

    return dwHandles;
}

/***************************************************************************\
* HMCleanUpHandleTable
*
\***************************************************************************/
VOID HMCleanUpHandleTable(
    VOID)
{
#if DBG
    DbgDumpHandleTable();
#endif // DBG

    if (LockRecordLookaside != NULL) {
        ExDeletePagedLookasideList(LockRecordLookaside);
        UserFreePool(LockRecordLookaside);
    }
}
#endif // DBG

/***************************************************************************\
* HMInitHandleEntries
*
* 10/10/97  GerardoB    Extracted from HMInitHandleTable and HMGrowHandleTable
\***************************************************************************/
VOID HMInitHandleEntries(
    ULONG_PTR iheFirstFree)
{
    ULONG_PTR ihe;
    PHE      pheT;

    /*
     * Zero out all the new entries
     */
    RtlZeroMemory (&gSharedInfo.aheList[iheFirstFree],
                    (gpsi->cHandleEntries - iheFirstFree) * sizeof(HANDLEENTRY));
    /*
     * Link them together.
     * Each free odd/even entry points to the next odd/even free entry.
     */
    ihe = iheFirstFree;
    for (pheT = &gSharedInfo.aheList[ihe]; ihe < gpsi->cHandleEntries; ihe++, pheT++) {
        pheT->phead = (PHEAD)(ihe + 2);
        pheT->wUniq = 1;
    }

    /*
     * Terminate the lists.
     */
    if (gpsi->cHandleEntries > iheFirstFree) {
        UserAssert(pheT - 1 >= &gSharedInfo.aheList[iheFirstFree]);
        (pheT - 1)->phead = NULL;
    }
    if (gpsi->cHandleEntries > iheFirstFree + 1) {
        UserAssert(pheT - 2 >= &gSharedInfo.aheList[iheFirstFree]);
        (pheT - 2)->phead = NULL;
    }

    /*
     * Let's check that we got it right
     */
    DBGHMValidateFreeLists();
}

/***************************************************************************\
* HMInitHandleTable
*
* Initialize the handle table. Unused entries are linked together.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/
BOOL HMInitHandleTable(
    PVOID pReadOnlySharedSectionBase)
{
    NTSTATUS Status;
    SIZE_T ulCommit;

    /*
     * Allocate the handle page array. Make it big enough for 4 pages, which
     * should be sufficient for nearly all instances.
     */
    gpHandlePages = UserAllocPool(CPAGEENTRIESINIT * sizeof(HANDLEPAGE),
                                  TAG_SYSTEM);
    if (gpHandlePages == NULL) {
        return FALSE;
    }

#if DBG || FRE_LOCK_RECORD
    if (!NT_SUCCESS(InitLockRecordLookaside()))
        return FALSE;
#endif

    /*
     * Allocate the array. We have the space from
     * NtCurrentPeb()->ReadOnlySharedMemoryBase to
     * NtCurrentPeb()->ReadOnlySharedMemoryHeap reserved for
     * the handle table. All we need to do is commit the pages.
     *
     * Compute the minimum size of the table. The allocation will
     * round this up to the next page size.
     */
    ulCommit = gpsi->cbHandleTable = PAGE_SIZE;
    Status = CommitReadOnlyMemory(ghSectionShared, &ulCommit, 0, NULL);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    gSharedInfo.aheList = pReadOnlySharedSectionBase;
    gpsi->cHandleEntries = gpsi->cbHandleTable / sizeof(HANDLEENTRY);
    gcHandlePages = 1;

    /*
     * Initialize the handlepage info. Handle 0 is reserved so even free
     * list starts at 2.
     */
    gpHandlePages[0].iheFreeOdd = 1;
    gpHandlePages[0].iheFreeEven = 2;
    gpHandlePages[0].iheLimit = gpsi->cHandleEntries;

    /*
     * Initialize the handle entries.
     */
    HMInitHandleEntries(0);

    /*
     * PW(NULL) (ie, handle 0) must map to a NULL pointer.
     */
    gSharedInfo.aheList[0].phead = NULL;
    UserAssert(gSharedInfo.aheList[0].bType == TYPE_FREE);
    UserAssert(gSharedInfo.aheList[0].wUniq == 1);

#if DBG
    /*
     * Make sure we don't need to add the special case to handle HMINDEXBITS
     * in this function.
     */
    UserAssert(gpsi->cHandleEntries <= HMINDEXBITS);

    /*
     * PDESKOBJHEAD won't do the right casting unless these structs have the
     * same size.
     */
    UserAssert(sizeof(THROBJHEAD) == sizeof(PROCOBJHEAD));
    UserAssert(sizeof(THRDESKHEAD) == sizeof(PROCDESKHEAD));
    UserAssert(sizeof(THRDESKHEAD) == sizeof(DESKOBJHEAD));

    /*
     * Validate type flags to make sure that assumptions made throughout HM
     * code are OK.
     */
    {
        PHANDLETYPEINFO pahti = (PHANDLETYPEINFO)gahti;
        UINT uTypes = TYPE_CTYPES;
        BYTE bObjectCreateFlags;
        while (uTypes-- != 0) {
            bObjectCreateFlags = pahti->bObjectCreateFlags;
            /*

             * Illegal flag combinations.
             */
            UserAssert(!((bObjectCreateFlags & OCF_DESKTOPHEAP) && (bObjectCreateFlags & OCF_MARKPROCESS)));

            /*
             * Pointless (and probably illegal) flag combinations.
             */
            UserAssert(!((bObjectCreateFlags & OCF_DESKTOPHEAP) && (bObjectCreateFlags & OCF_SHAREDHEAP)));
            UserAssert(!((bObjectCreateFlags & OCF_USEPOOLQUOTA) && (bObjectCreateFlags & OCF_SHAREDHEAP)));
            UserAssert(!((bObjectCreateFlags & OCF_THREADOWNED) && (bObjectCreateFlags & OCF_PROCESSOWNED)));
            UserAssert(!(bObjectCreateFlags & OCF_USEPOOLQUOTA)
                        || !(bObjectCreateFlags & OCF_DESKTOPHEAP)
                        || (bObjectCreateFlags & OCF_USEPOOLIFNODESKTOP));

            /*
             * Required flag combinations.
             */
            UserAssert(!(bObjectCreateFlags & OCF_DESKTOPHEAP)
                        || (bObjectCreateFlags & (OCF_PROCESSOWNED | OCF_THREADOWNED)));

            UserAssert(!(bObjectCreateFlags & OCF_MARKPROCESS)
                        || (bObjectCreateFlags & OCF_PROCESSOWNED));

            UserAssert(!(bObjectCreateFlags & OCF_USEPOOLIFNODESKTOP)
                        || (bObjectCreateFlags & OCF_DESKTOPHEAP));


            pahti++;
        }
    }
#endif

    return TRUE;
}

/***************************************************************************\
* HMGrowHandleTable
*
* Grows the handle table. Assumes the handle table already exists.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/
BOOL HMGrowHandleTable(
    VOID)
{
    ULONG_PTR   i, iheFirstFree;
    PHE         pheT;
    PVOID       p;
    PHANDLEPAGE phpNew;
    DWORD       dwCommitOffset;
    SIZE_T      ulCommit;
    NTSTATUS    Status;

    /*
     * If we've run out of handle space, fail.
     */
    i = gpsi->cHandleEntries;
    if (i & ~HMINDEXBITS) {
        return FALSE;
    }

    /*
     * Grow the page table if need be.
     */
    i = gcHandlePages + 1;
    if (i > CPAGEENTRIESINIT) {
        DWORD dwSize = gcHandlePages * sizeof(HANDLEPAGE);

        phpNew = UserReAllocPool(gpHandlePages,
                                 dwSize,
                                 dwSize + sizeof(HANDLEPAGE),
                                 TAG_SYSTEM);
        if (phpNew == NULL) {
            return FALSE;
        }

        gpHandlePages = phpNew;
    }

    /*
     * Commit some more pages to the table.  First find the
     * address where the commitment needs to be.
     */
    p = (PBYTE)gSharedInfo.aheList + gpsi->cbHandleTable;
    if (p >= Win32HeapGetHandle(gpvSharedAlloc)) {
        return FALSE;
    }

    dwCommitOffset = (ULONG)((PBYTE)p - (PBYTE)gpvSharedBase);

    ulCommit = PAGE_SIZE;

    Status = CommitReadOnlyMemory(ghSectionShared, &ulCommit, dwCommitOffset, NULL);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    phpNew = &gpHandlePages[gcHandlePages++];

    /*
     * Update the global information to include the new
     * page.
     */
    iheFirstFree = gpsi->cHandleEntries;
    if (gpsi->cHandleEntries & 0x1) {
        phpNew->iheFreeOdd = gpsi->cHandleEntries;
        phpNew->iheFreeEven = gpsi->cHandleEntries + 1;
    } else {
        phpNew->iheFreeEven = gpsi->cHandleEntries;
        phpNew->iheFreeOdd = gpsi->cHandleEntries + 1;
    }
    gpsi->cbHandleTable += PAGE_SIZE;

    /*
     * Check for handle overflow.
     */
    gpsi->cHandleEntries = gpsi->cbHandleTable / sizeof(HANDLEENTRY);
    if (gpsi->cHandleEntries & ~HMINDEXBITS) {
        gpsi->cHandleEntries = (HMINDEXBITS + 1);
    }

    phpNew->iheLimit = gpsi->cHandleEntries;
    if (phpNew->iheFreeEven >= phpNew->iheLimit) {
        phpNew->iheFreeEven = 0;
    }
    if (phpNew->iheFreeOdd >= phpNew->iheLimit) {
        phpNew->iheFreeOdd = 0;
    }

    HMInitHandleEntries(iheFirstFree);

    /*
     * HMINDEXBITS has a special meaning. We used to handle this in HMAllocObject.
     * Now we handle it here right after adding that handle to the table.
     * Old Comment:
     * Reserve this table entry so that PW(HMINDEXBITS) maps to a
     * NULL pointer. Set it to TYPE_FREE so the cleanup code doesn't think
     * it is allocated. Set wUniq to 1 so that RevalidateHandles on HMINDEXBITS
     * will fail.
     */
    if ((gpsi->cHandleEntries > HMINDEXBITS)
            && (phpNew->iheFreeOdd != 0)
            && (phpNew->iheFreeOdd <= HMINDEXBITS)) {

        pheT = &gSharedInfo.aheList[HMINDEXBITS];
        if (phpNew->iheFreeOdd == HMINDEXBITS) {
            phpNew->iheFreeOdd = (ULONG_PTR)pheT->phead;
        } else {
            UserAssert(pheT - 2 >= &gSharedInfo.aheList[iheFirstFree]);
            UserAssert((pheT - 2)->phead == (PVOID)HMINDEXBITS);
            (pheT - 2)->phead = pheT->phead;
        }
        pheT->phead = NULL;
        UserAssert(pheT->bType == TYPE_FREE);
        UserAssert(pheT->wUniq == 1);
    }

    return TRUE;
}

/***************************************************************************\
* HMAllocObject
*
* Allocs a non-secure object by allocating a handle and memory for
* the object.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

PVOID HMAllocObject(
    PTHREADINFO ptiOwner,
    PDESKTOP pdeskSrc,
    BYTE bType,
    DWORD size)
{
    DWORD       i;
    PHEAD       phead;
    PHE         pheT;
    ULONG_PTR    iheFree, *piheFreeHead;
    PHANDLEPAGE php;
    BYTE        bCreateFlags;
    PPROCESSINFO ppiQuotaCharge = NULL;
    BOOL        fUsePoolIfNoDesktop;
    BOOL        fEven;
#if DBG
    SIZE_T      dwAllocSize;
#endif

    CheckCritIn();
    bCreateFlags = gahti[bType].bObjectCreateFlags;

#if DBG
    /*
     * Validate size
     */
    if (bCreateFlags & OCF_VARIABLESIZE) {
        UserAssert(gahti[bType].uSize <= size);
    } else {
        UserAssert(gahti[bType].uSize == size);
    }
#endif

    /*
     * Check for process handle quota
     */
    if (bCreateFlags & (OCF_PROCESSOWNED | OCF_THREADOWNED)) {
        UserAssert(ptiOwner != NULL);
        ppiQuotaCharge = ptiOwner->ppi;
        if (ppiQuotaCharge->UserHandleCount >= gUserProcessHandleQuota) {
            RIPERR0(ERROR_NO_MORE_USER_HANDLES,
                    RIP_WARNING,
                    "USER: HMAllocObject: out of handle quota");
            return NULL;
        }
    }

    /*
     * Find the next free handle
     * Window handles must be even; hence we try first to use odd handles
     *  for all other objects.
     * Old comment:
     * Some wow apps, like WinProj, require even Window handles so we'll
     * accomodate them; build a list of the odd handles so they won't get lost
     * 10/13/97: WinProj never fixed this; even the 32 bit version has the problem.
     */
    fEven = (bType == TYPE_WINDOW);
    piheFreeHead = NULL;
    do {
        php = gpHandlePages;
        for (i = 0; i < gcHandlePages; ++i, ++php) {
            if (fEven) {
                if (php->iheFreeEven != 0) {
                    piheFreeHead = &php->iheFreeEven;
                    break;
                }
            } else {
                if (php->iheFreeOdd != 0) {
                    piheFreeHead = &php->iheFreeOdd;
                    break;
                }
            }
        } /* for */
        /*
         * If we couldn't find an odd handle, then search for an even one
         */
        fEven = ((piheFreeHead == NULL) && !fEven);
    } while (fEven);
    /*
     * If there are no free handles we can use, grow the table
     */
    if (piheFreeHead == NULL) {
        HMGrowHandleTable();
        /*
         * If the table didn't grow, get out.
         */
        if (i == gcHandlePages) {
            RIPMSG0(RIP_WARNING, "HMAllocObject: could not grow handle space");
            return NULL;
        }
        /*
         * Because the handle page table may have moved,
         * recalc the page entry pointer.
         */
        php = &gpHandlePages[i];
        piheFreeHead = (bType == TYPE_WINDOW ? &php->iheFreeEven : &php->iheFreeOdd);
        if (*piheFreeHead == 0) {
            UserAssert(gpsi->cHandleEntries == (HMINDEXBITS + 1));
            RIPMSG0(RIP_WARNING, "HMAllocObject: handle table is full");
            return NULL;
        }
    }

    /*
     * HMINDEXBITS is a reserved value that should never be in the free lists
     * (see HMGrowHandleTable()).
     */
    UserAssert(HMIndexFromHandle(*piheFreeHead) != HMINDEXBITS);

    /*
     * Try to allocate the object. If this fails, bail out.
     */
    if ((bCreateFlags & OCF_DESKTOPHEAP) && pdeskSrc) {
        phead = (PHEAD)DesktopAlloc(pdeskSrc, size, MAKELONG(DTAG_HANDTABL, bType));
        if (phead) {
            LockDesktop(&((PDESKOBJHEAD)phead)->rpdesk, pdeskSrc, LDL_OBJ_DESK, (ULONG_PTR)phead);
            ((PDESKOBJHEAD)phead)->pSelf = (PBYTE)phead;
#if DBG
            dwAllocSize = Win32HeapSize(pdeskSrc->pheapDesktop, phead);
#endif
        }
    } else if (bCreateFlags & OCF_SHAREDHEAP) {
        UserAssert(!pdeskSrc);
        phead = (PHEAD)SharedAlloc(size);
#if DBG
        if (phead) {
            dwAllocSize = Win32HeapSize(gpvSharedAlloc, phead);
        }
#endif
    } else {
        fUsePoolIfNoDesktop = !pdeskSrc && (bCreateFlags & OCF_USEPOOLIFNODESKTOP);
        UserAssert(!(bCreateFlags & OCF_DESKTOPHEAP) || fUsePoolIfNoDesktop);

        if ((bCreateFlags & OCF_USEPOOLQUOTA) && !fUsePoolIfNoDesktop) {
            phead = (PHEAD)UserAllocPoolWithQuotaZInit(size, gahti[bType].dwAllocTag);
        } else {
            phead = (PHEAD)UserAllocPoolZInit(size, gahti[bType].dwAllocTag);
        }

#if DBG
        if (phead) {
            dwAllocSize = Win32QueryPoolSize(phead);
        }
#endif
    }

    if (phead == NULL) {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
                RIP_WARNING,
                "USER: HMAllocObject: out of memory");
        return NULL;
    }

    /*
     * We're going to use this handle so get it off its free list.
     * The free handle phead points to the next free handle.
     */
    iheFree = *piheFreeHead;
    pheT = &gSharedInfo.aheList[iheFree];
    *piheFreeHead = (ULONG_PTR)pheT->phead;
    DBGHMValidateFreeLists();

    /*
     * Track high water mark for handle allocation.
     */
    if ((DWORD)iheFree > giheLast) {
        giheLast = (DWORD)iheFree;
    }

    /*
     * Setup the handle contents, plus initialize the object header.
     */
    pheT->bType = bType;
    pheT->phead = phead;
    UserAssert(pheT->bFlags == 0);
    if (bCreateFlags & OCF_PROCESSOWNED) {
        if ((ptiOwner->TIF_flags & TIF_16BIT) && (ptiOwner->ptdb)) {
            ((PPROCOBJHEAD)phead)->hTaskWow = ptiOwner->ptdb->hTaskWow;
        } else {
            ((PPROCOBJHEAD)phead)->hTaskWow = 0;
        }
        pheT->pOwner = ptiOwner->ppi;
        if (bCreateFlags & OCF_MARKPROCESS) {
            ((PPROCMARKHEAD)phead)->ppi = ptiOwner->ppi;
        }
    } else if (bCreateFlags & OCF_THREADOWNED) {
        ((PTHROBJHEAD)phead)->pti = pheT->pOwner = ptiOwner;
    } else {
        /*
         * The caller is wasting time if ptiOwner != NULL
         * The handle entry must already have pOwner == NULL.
         */
        UserAssert(ptiOwner == NULL);
        UserAssert(pheT->pOwner == NULL);
    }

    phead->h = HMHandleFromIndex(iheFree);

    if (ppiQuotaCharge) {
        ppiQuotaCharge->UserHandleCount++;
        DBGValidateHandleQuota();
    }

#if DBG
    /*
     * Performance counters.
     */

    gaPerfhti[bType].lTotalCount++;
    gaPerfhti[bType].lCount++;
    if (gaPerfhti[bType].lCount > gaPerfhti[bType].lMaxCount) {
        gaPerfhti[bType].lMaxCount = gaPerfhti[bType].lCount;
    }

    gaPerfhti[bType].lSize += dwAllocSize;

#endif // DBG

    /*
     * Return a handle entry pointer.
     */
    return pheT->phead;
}


/***************************************************************************\
* HMFreeObject
*
* Frees an object - the handle and the referenced memory.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/
BOOL HMFreeObject(
    PVOID pobj)
{
    PHE         pheT;
    WORD        wUniqT;
    PHANDLEPAGE php;
    DWORD       i;
    ULONG_PTR    iheCurrent, *piheCurrentHead;
    BYTE        bCreateFlags;
    PDESKTOP    pdesk;
    PPROCESSINFO ppiQuotaCharge = NULL;
#if DBG || FRE_LOCK_RECORD
    PLR         plrT, plrNextT;
#endif

    UserAssert(((PHEAD)pobj)->cLockObj == 0);
    UserAssert(pobj == HtoPqCat(PtoHq(pobj)));
    /*
     * Free the object first.
     */
    pheT = HMPheFromObject(pobj);
    bCreateFlags = gahti[pheT->bType].bObjectCreateFlags;

    UserAssertMsg1(pheT->bType != TYPE_FREE,
                   "Object already marked as freed! %#p", pobj);

    /*
     * Adjust the process handle usage.
     */
    if (bCreateFlags & OCF_PROCESSOWNED) {
        ppiQuotaCharge = (PPROCESSINFO)pheT->pOwner;
        UserAssert(ppiQuotaCharge != NULL);
    } else if (bCreateFlags & OCF_THREADOWNED) {
        ppiQuotaCharge = (PPROCESSINFO)(((PTHREADINFO)(pheT->pOwner))->ppi);
        UserAssert(ppiQuotaCharge != NULL);
    } else {
        ppiQuotaCharge = NULL;
    }

    if (ppiQuotaCharge != NULL) {
        ppiQuotaCharge->UserHandleCount--;
    }

    if (pheT->bFlags & HANDLEF_GRANTED) {
        HMCleanupGrantedHandle(pheT->phead->h);
        pheT->bFlags &= ~HANDLEF_GRANTED;
    }

#if DBG
    /*
     * Performance counters.
     */
    gaPerfhti[pheT->bType].lCount--;

    if ((pheT->bFlags & HANDLEF_POOL) == 0 && (bCreateFlags & OCF_DESKTOPHEAP) && ((PDESKOBJHEAD)pobj)->rpdesk) {
        pdesk = ((PDESKOBJHEAD)pobj)->rpdesk;
        gaPerfhti[pheT->bType].lSize -= Win32HeapSize(pdesk->pheapDesktop, pobj);
    } else if ((pheT->bFlags & HANDLEF_POOL) == 0 && bCreateFlags & OCF_SHAREDHEAP) {
        gaPerfhti[pheT->bType].lSize -= Win32HeapSize(gpvSharedAlloc, pobj);
    } else {
        gaPerfhti[pheT->bType].lSize -= Win32QueryPoolSize(pobj);
    }

#endif // DBG

    if ((bCreateFlags & OCF_DESKTOPHEAP)) {
#if DBG
        BOOL bSuccess;
#endif
        if (!(pheT->bFlags & HANDLEF_POOL)) {
            UserAssert(((PDESKOBJHEAD)pobj)->rpdesk != NULL);
        }

        /*
         * pobj->rpdesk is cached and the object is freed after which the
         * reference count on the desktop is decremented. This is done in
         * this order such that if this is the last reference on the desktop
         * the desktop heap is not destroyed before we free the object.
         */
        pdesk = ((PDESKOBJHEAD)pobj)->rpdesk;
        ((PDESKOBJHEAD)pobj)->rpdesk = NULL;

        if (pheT->bFlags & HANDLEF_POOL) {
            UserFreePool(pobj);
        } else {

#if DBG
            bSuccess =
#endif
            DesktopFree(pdesk, pobj);
#if DBG
            if (!bSuccess) {
                /*
                 * We would hit this assert in HYDRA trying to free the
                 * mother desktop window which was allocated out of pool
                 */
                RIPMSG1(RIP_ERROR, "Object already freed from desktop heap! %#p", pobj);
            }
#endif
        }

        /*
         * NOTE: Using pobj after freeing the object is not a problem because
         * UnlockDesktop uses the value for tracking and doesn't dereference
         * the pointer. If this ever changes we'll get a BC.
         */
        UnlockDesktop(&pdesk, LDU_OBJ_DESK, (ULONG_PTR)pobj);
    } else if (bCreateFlags & OCF_SHAREDHEAP) {
        SharedFree(pobj);
    } else {
        UserFreePool(pobj);
    }

#if DBG || FRE_LOCK_RECORD
    /*
     * Go through and delete the lock records, if they exist.
     */
    for (plrT = pheT->plr; plrT != NULL; plrT = plrNextT) {

        /*
         * Remember the next one before freeing this one.
         */
        plrNextT = plrT->plrNext;
        FreeLockRecord((HANDLE)plrT);
    }
#endif

    /*
     * Clear the handle contents. Need to remember the uniqueness across
     * the clear. Also, advance uniqueness on free so that uniqueness checking
     * against old handles also fails.
     */
    wUniqT = (WORD)((pheT->wUniq + 1) & HMUNIQBITS);

    /*
     * Be sure that wUniqT will never be 0 nor HMUNIQBITS.
     * Then if we hit the max (i.e. HMUNIQBITS) then reset it to 1.
     */
    if (wUniqT == HMUNIQBITS) {
        wUniqT = 1;
    }
    RtlZeroMemory(pheT, sizeof(HANDLEENTRY));
    pheT->wUniq = wUniqT;

    UserAssert(pheT->bType == TYPE_FREE);

    /*
     * Put the handle on the free list of the appropriate page.
     */
    php = gpHandlePages;
    iheCurrent = pheT - gSharedInfo.aheList;
    for (i = 0; i < gcHandlePages; ++i, ++php) {
        if (iheCurrent < php->iheLimit) {
            piheCurrentHead = (iheCurrent & 0x1 ? &php->iheFreeOdd : &php->iheFreeEven);
            pheT->phead = (PHEAD)*piheCurrentHead;
            *piheCurrentHead = iheCurrent;
            DBGHMValidateFreeLists();
            break;
        }
    }

    /*
     * We must have found it.
     */
    UserAssert(i < gcHandlePages);
    UserAssert(pheT->pOwner == NULL);

    DBGValidateHandleQuota();

    return TRUE;
}


/***************************************************************************\
* HMMarkObjectDestroy
*
* Marks an object for destruction.
*
* Returns TRUE if the object can be destroyed; that is, if it's
* lock count is 0.
*
* 02-10-92 ScottLu      Created.
\***************************************************************************/
BOOL HMMarkObjectDestroy(
    PVOID pobj)
{
    PHE phe = HMPheFromObject(pobj);

#if DBG || FRE_LOCK_RECORD
    /*
     * Record where the object was marked for destruction.
     */
    if (RecordLockThisType(pobj)) {
        if (!(phe->bFlags & HANDLEF_DESTROY)) {
            HMRecordLock(LOCKRECORD_MARKDESTROY, pobj, ((PHEAD)pobj)->cLockObj);
        }
    }
#endif

    /*
     * Set the destroy flag so our unlock code will know we're trying to
     * destroy this object.
     */
    phe->bFlags |= HANDLEF_DESTROY;

    /*
     * If this object can't be destroyed, then CLEAR the HANDLEF_INDESTROY
     * flag - because this object won't be currently "in destruction"!
     * (if we didn't clear it, when it was unlocked it wouldn't get destroyed).
     */
    if (((PHEAD)pobj)->cLockObj != 0) {
        phe->bFlags &= ~HANDLEF_INDESTROY;

        /*
         * Return FALSE because we can't destroy this object.
         */
        return FALSE;
    }

#if DBG
    /*
     * Ensure that this function only returns TRUE once.
     */
    UserAssert(!(phe->bFlags & HANDLEF_MARKED_OK));
    phe->bFlags |= HANDLEF_MARKED_OK;
#endif

    /*
     * Return TRUE because Lock count is zero - ok to destroy this object.
     */
    return TRUE;
}


/***************************************************************************\
* HMDestroyObject
*
* This routine marks an object for destruction, and frees it if
* it is unlocked.
*
* 10-13-94 JimA         Created.
\***************************************************************************/

BOOL HMDestroyObject(
    PVOID pobj)
{
    /*
     * First mark the object for destruction.  This tells the locking code
     * that we want to destroy this object when the lock count goes to 0.
     * If this returns FALSE, we can't destroy the object yet (and can't get
     * rid of security yet either.)
     */

    if (!HMMarkObjectDestroy(pobj))
        return FALSE;

    /*
     * Ok to destroy...  Free the handle (which will free the object
     * and the handle).
     */
    HMFreeObject(pobj);
    return TRUE;
}

#if DBG || FRE_LOCK_RECORD
NTSTATUS
InitLockRecordLookaside()
{
    LockRecordLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                                   TAG_LOOKASIDE);
    if (LockRecordLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(LockRecordLookaside,
                                   NULL,
                                   NULL,
                                   SESSION_POOL_MASK,
                                   sizeof(LOCKRECORD),
                                   TAG_LOCKRECORD,
                                   1000);
    return STATUS_SUCCESS;
}

PLR AllocLockRecord()
{
    PLR plr;

    /*
     * Allocate a LOCKRECORD structure.
     */
    if ((plr = ExAllocateFromPagedLookasideList(LockRecordLookaside)) == NULL) {
        return NULL;
    }

    RtlZeroMemory(plr, sizeof(*plr));

    return plr;
}


VOID FreeLockRecord(
    PLR plr)
{
    ExFreeToPagedLookasideList(LockRecordLookaside, plr);
}


/***************************************************************************\
* HMRecordLock
*
* This routine records a lock on a "lock list", so that locks and unlocks
* can be tracked in the debugger. Only called if DBGTAG_TrackLocks is enabled.
*
* 02-27-92 ScottLu      Created.
\***************************************************************************/
VOID HMRecordLock(
    PVOID ppobj,
    PVOID pobj,
    DWORD cLockObj)
{
    PHE   phe;
    PLR   plr;
    int   i;
    phe = HMPheFromObject(pobj);

    if ((plr = AllocLockRecord()) == NULL) {
        RIPMSG0(RIP_WARNING, "HMRecordLock failed to allocate memory");
        return;
    }

    /*
     * Link it in front of the list
     */
    plr->plrNext = phe->plr;
    phe->plr = plr;

    /*
     * This propably happens only for unmatched locks
     */
    if (((PHEAD)pobj)->cLockObj > cLockObj) {

        RIPMSG3(RIP_WARNING, "Unmatched lock. ppobj %#p pobj %#p cLockObj %d",
               ppobj, pobj, cLockObj);

        i = (int)cLockObj;
        i = -i;
        cLockObj = (DWORD)i;
    }

    plr->ppobj    = ppobj;
    plr->cLockObj = cLockObj;

    RtlWalkFrameChain(plr->trace, LOCKRECORD_STACK, 0);
}
#endif


#if DBG
/***************************************************************************\
* HMLockObject
*
* This routine locks an object. This is a macro in retail systems.
*
* 02-24-92 ScottLu      Created.
\***************************************************************************/
VOID HMLockObject(
    PVOID pobj)
{
    HANDLE h;
    PVOID  pobjValidate;

    /*
     * Validate by going through the handle entry so that we make sure pobj
     * is not just pointing off into space. This may GP fault, but that's
     * ok: this case should not ever happen if we're bug free.
     */

    h = HMPheFromObject(pobj)->phead->h;
    pobjValidate = HMRevalidateCatHandle(h);
    if (!pobj || pobj != pobjValidate) {
        RIPMSG2(RIP_ERROR,
                "HMLockObject invalid object %#p, handle %#p",
                pobj, h);
        return;
    }

    /*
     * Inc the reference count.
     */
    ((PHEAD)pobj)->cLockObj++;

    if (((PHEAD)pobj)->cLockObj == 0) {
        RIPMSG1(RIP_ERROR, "Object lock count has overflowed: %#p", pobj);
    }
}
#endif // DBG


/***************************************************************************\
* HMUnlockObjectInternal
*
* This routine is called from the macro HMUnlockObject when an object's
* reference count drops to zero. This routine will destroy an object
* if is has been marked for destruction.
*
* 01-21-92 ScottLu      Created.
\***************************************************************************/

PVOID HMUnlockObjectInternal(
    PVOID pobj)
{
    PHE phe;

    /*
     * The object is not reference counted. If the object is not a zombie,
     * return success because the object is still around.
     */
    phe = HMPheFromObject(pobj);
    if (!(phe->bFlags & HANDLEF_DESTROY))
        return pobj;

    /*
     * We're destroying the object based on an unlock... Make sure it isn't
     * currently being destroyed! (It is valid to have lock counts go from
     * 0 to != 0 to 0 during destruction... don't want recursion into
     * the destroy routine.
     */
    if (phe->bFlags & HANDLEF_INDESTROY)
        return pobj;

    HMDestroyUnlockedObject(phe);
    return NULL;
}


/***************************************************************************\
* HMAssignmentLock
*
* This api is used for structure and global variable assignment.
* Returns pobjOld if the object was *not* destroyed. Means the object is
* still valid.
*
* 02-24-92 ScottLu      Created.
\***************************************************************************/

PVOID FASTCALL HMAssignmentLock(
    PVOID *ppobj,
    PVOID pobj)
{
    PVOID pobjOld;

    pobjOld = *ppobj;
    *ppobj = pobj;

    /*
     * Unlocks the old, locks the new.
     */
    if (pobjOld != NULL) {

        /*
         * if we are locking in the same object that is there then
         * it is a no-op but we don't want to do the Unlock and the Lock
         * because the unlock could free object and the lock would lock
         * in a freed pointer; 6410.
         */
        if (pobjOld == pobj) {
            return pobjOld;
        }

#if DBG || FRE_LOCK_RECORD
        /*
         * Track assignment locks.
         */
        if (RecordLockThisType(pobjOld)) {
            if (!HMUnrecordLock(ppobj, pobjOld)) {
                HMRecordLock(ppobj, pobjOld, ((PHEAD)pobjOld)->cLockObj - 1);
            }
        }
#endif

    }


    if (pobj != NULL) {
        UserAssert(pobj == HMValidateCatHandleNoSecure(((PHEAD)pobj)->h, TYPE_GENERIC));
        if (HMIsMarkDestroy(pobj)) {
            RIPERR2(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "HMAssignmentLock, locking object %#p marked for destruction at %#p",
                    pobj, ppobj);
        }

#if DBG || FRE_LOCK_RECORD
        /*
         * Track assignment locks.
         */
        if (RecordLockThisType(pobj)) {
            HMRecordLock(ppobj, pobj, ((PHEAD)pobj)->cLockObj + 1);
            if (HMIsMarkDestroy(pobj)) {

                RIPMSG2(RIP_WARNING,
                        "Locking object %#p marked for destruction at %#p",
                        pobj, ppobj);
            }
        }
#endif
        HMLockObject(pobj);
    }

/*
 * This unlock has been moved from up above, so that we implement a
 * "lock before unlock" strategy.  Just in case pobjOld was the
 * only object referencing pobj, pobj won't go away when we unlock
 * pobjNew -- it will have been locked above.
 */

    if (pobjOld) {
        pobjOld = HMUnlockObject(pobjOld);
    }

    return pobjOld;
}


/***************************************************************************\
* HMAssignmentUnLock
*
* This api is used for structure and global variable assignment.
* Returns pobjOld if the object was *not* destroyed. Means the object is
* still valid.
*
* 02-24-92 ScottLu      Created.
\***************************************************************************/
PVOID FASTCALL HMAssignmentUnlock(
    PVOID *ppobj)
{
    PVOID pobjOld;

    pobjOld = *ppobj;
    *ppobj = NULL;

    /*
     * Unlocks the old, locks the new.
     */
    if (pobjOld != NULL) {
#if DBG || FRE_LOCK_RECORD
        /*
         * Track assignment locks.
         */
        if (RecordLockThisType(pobjOld)) {
            if (!HMUnrecordLock(ppobj, pobjOld)) {
                HMRecordLock(ppobj, pobjOld, ((PHEAD)pobjOld)->cLockObj - 1);
            }
        }
#endif
        pobjOld = HMUnlockObject(pobjOld);
    }

    return pobjOld;
}


/***************************************************************************\
* IsValidThreadLock
*
* This routine checks to make sure that the thread lock structures passed
* in are valid.
*
* 03-17-92 ScottLu      Created.
* 02-22-99 MCostea      Also validate the shadow of the stack TL
*                       from gThreadLocksArray
\***************************************************************************/
#if DBG
VOID IsValidThreadLock(
    PTHREADINFO pti,
    PTL ptl,
    ULONG_PTR dwLimit,
    BOOLEAN fHM)
{
    /*
     * Check that ptl is a valid stack address. Allow ptl == dwLimit so we
     * can call ValidateThreadLocks passing the address of the last thing we
     * locked.
     */
    UserAssert((ULONG_PTR)ptl >= dwLimit);
    UserAssert((ULONG_PTR)ptl < (ULONG_PTR)PsGetCurrentThreadStackBase());

    /*
     * Check ptl owner.
     */
    UserAssert(ptl->pW32Thread == (PW32THREAD)pti);

    /*
     * If this is an HM object, verify handle and lock count (guess max value)
     */
    if (fHM && (ptl->pobj != NULL)) {
        /*
         * The locked object could be a destroyed object.
         */
        UserAssert(ptl->pobj == HtoPqCat(PtoHq(ptl->pobj)));
        if (((PHEAD)ptl->pobj)->cLockObj >= 32000) {
            RIPMSG2(RIP_WARNING,
                    "IsValidThreadLock: Object %#p has %d locks",
                    ptl->pobj,
                    ((PHEAD)ptl->pobj)->cLockObj);
        }
    }

    /*
     * Make sure the shadow in gThreadLocksArray is doing fine.
     */
    UserAssert(ptl->ptl->ptl == ptl);
}
#endif

#if DBG
/***************************************************************************\
* ValidateThreadLocks
*
* This routine validates the thread lock list of a thread.
*
* 03-10-92 ScottLu      Created.
\***************************************************************************/
ULONG ValidateThreadLocks(
    PTL NewLock,
    PTL OldLock,
    ULONG_PTR dwLimit,
    BOOLEAN fHM)
{
    UINT uTLCount = 0;
    PTL ptlTopLock = OldLock;
    PTHREADINFO ptiCurrent;

    BEGIN_REENTERCRIT();

    ptiCurrent = PtiCurrent();

    /*
     * Validate the new thread lock.
     */
    if (NewLock != NULL) {
        UserAssert(NewLock->next == OldLock);
        IsValidThreadLock(ptiCurrent, NewLock, dwLimit, fHM);
        uTLCount++;
    }

    /*
     * Loop through the list of thread locks and check to make sure the
     * new lock is not in the list and that list is valid.
     */
    while (OldLock != NULL) {
        /*
         * The new lock must not be the same as the old lock.
         */
        UserAssert(NewLock != OldLock);
        /*
         * Validate the old thread lock.
         */
        IsValidThreadLock(ptiCurrent, OldLock, dwLimit, fHM);
        uTLCount++;
        OldLock = OldLock->next;
    }
    /*
     * If this is thread lock, set uTLCount, else verify it
     */
    if (NewLock != NULL) {
        NewLock->uTLCount = uTLCount;
    } else {
        if (ptlTopLock == NULL) {
            RIPMSG0(RIP_WARNING, "ptlTopLock is NULL, the system will AV now");
        }
        UserAssert(uTLCount == ptlTopLock->uTLCount);
    }

    END_REENTERCRIT();

    return uTLCount;
}
#endif // DBG


#if DBG
/***************************************************************************\
* CreateShadowTL
*
* This function creates a shaddow for the stack allocated ptl parameter
* in the global thread locks arrays
*
* 08-04-99 MCostea      Created.
\***************************************************************************/
VOID CreateShadowTL(
    PTL ptl)
{
    PTL pTLNextFree;
    if (gFreeTLList->next == NULL) {
        UserAssert(gcThreadLocksArraysAllocated < MAX_THREAD_LOCKS_ARRAYS &&
                   "No more room in gpaThreadLocksArrays!  The system will bugcheck.");
        gFreeTLList->next = gpaThreadLocksArrays[gcThreadLocksArraysAllocated] =
            UserAllocPoolZInit(sizeof(TL)*MAX_THREAD_LOCKS, TAG_GLOBALTHREADLOCK);
        if (gFreeTLList->next == NULL) {
            UserAssert("Can't allocate memory for gpaThreadLocksArrays: the system will bugcheck soon!");
        }
        InitGlobalThreadLockArray(gcThreadLocksArraysAllocated);
        gcThreadLocksArraysAllocated++;
    }
    pTLNextFree = gFreeTLList->next;
    RtlCopyMemory(gFreeTLList, ptl, sizeof(TL));
    gFreeTLList->ptl = ptl;
    ptl->ptl = gFreeTLList;
    gFreeTLList = pTLNextFree;
}
#endif // DBG

/***************************************************************************\
* ThreadLock
*
* This api is used for locking objects across callbacks, so they are still
* there when the callback returns.
*
* 03-04-92 ScottLu      Created.
\***************************************************************************/

#if DBG
VOID
ThreadLock(
    PVOID pobj,
    PTL ptl)

{
    PTHREADINFO ptiCurrent;
    PVOID pfnT;

    /*
     * This is a handy place, because it is called so often, to see if we're
     * eating up too much stack.
     */
    ASSERT_STACK();

    /*
     * Store the address of the object in the thread lock structure and
     * link the structure into the thread lock list.
     *
     * N.B. The lock structure is always linked into the thread lock list
     *      regardless of whether the object address is NULL. The reason
     *      this is done is so the lock address does not need to be passed
     *      to the unlock function since the first entry in the lock list
     *      is always the entry to be unlocked.
     */

    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));
    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent);

    /*
     * Get the callers address and validate the thread lock list.
     */
    RtlGetCallersAddress(&ptl->pfnCaller, &pfnT);
    ptl->pW32Thread = (PW32THREAD)ptiCurrent;

    ptl->next = ptiCurrent->ptl;
    ptiCurrent->ptl = ptl;
    ptl->pobj = pobj;
    if (pobj != NULL) {
        HMLockObject(pobj);
    }

    CreateShadowTL(ptl);
    ValidateThreadLocks(ptl, ptl->next, (ULONG_PTR)&pobj, TRUE);
}
#endif


/***************************************************************************\
* ThreadLockExchange
*
* Reuses a TL structure by locking the new object and unlocking
* the old one. This is used where you enumerate a list of
* structure locked objects, e.g. the window list.
*
* History:
* 05-Mar-1997 adams     Created.
\***************************************************************************/

#if DBG
PVOID
ThreadLockExchange(PVOID pobj, PTL ptl)
{
    PTHREADINFO ptiCurrent;
    PVOID       pobjOld;
    PVOID       pfnT;

    /*
     * This is a handy place, because it is called so often, to see if User is
     * eating up too much stack.
     */
    ASSERT_STACK();

    /*
     * Store the address of the object in the thread lock structure and
     * link the structure into the thread lock list.
     *
     * N.B. The lock structure is always linked into the thread lock list
     *      regardless of whether the object address is NULL. The reason
     *      this is done is so the lock address does not need to be passed
     *      to the unlock function since the first entry in the lock list
     *      is always the entry to be unlocked.
     */

    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));
    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent);

    /*
     * Get the callers address.
     */
    RtlGetCallersAddress(&ptl->pfnCaller, &pfnT);
    UserAssert(ptl->pW32Thread == (PW32THREAD)ptiCurrent);

    /*
     * Remember the old object.
     */
    UserAssert(ptl->pobj == ptl->ptl->pobj);
    pobjOld = ptl->pobj;

    /*
     * Store and lock the new object. It is important to do this step
     * before unlocking the old object, since the new object might be
     * structure locked by the old object.
     */
    ptl->pobj = pobj;
    if (pobj != NULL) {
        HMLockObject(pobj);
    }

    /*
     * Unlock the old object.
     */
    if (pobjOld) {
        pobjOld = HMUnlockObject((PHEAD)pobjOld);
    }

    /*
     * Validate the entire thread lock list.
     */
    ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&pobj, TRUE);

    /*
     * Maintain gFreeTLList
     */
    UserAssert(ptl->ptl->ptl == ptl);
    ptl->ptl->pobj = pobj;
    ptl->ptl->pfnCaller = ptl->pfnCaller;

    return pobjOld;
}
#endif


/*
 * The thread locking routines should be optimized for time, not size,
 * since they get called so often.
 */
#pragma optimize("t", on)

/***************************************************************************\
* ThreadUnlock1
*
* This api unlocks a thread locked object. Returns pobj if the object
* was *not* destroyed (meaning the pointer is still valid).
*
* N.B. In a free build the first entry in the thread lock list is unlocked.
*
* 03-04-92 ScottLu      Created.
\***************************************************************************/

#if DBG
PVOID
ThreadUnlock1(
    PTL ptlIn)
#else
PVOID
ThreadUnlock1(
    VOID)
#endif
{
    PHEAD phead;
    PTHREADINFO ptiCurrent;
    PTL ptl;

    ptiCurrent = PtiCurrent();
    ptl = ptiCurrent->ptl;
    UserAssert(ptl != NULL);
     /*
      * Validate the thread lock list.
      */
     ValidateThreadLocks(NULL, ptl, (ULONG_PTR)&ptlIn, TRUE);
    /*
     * Make sure the caller wants to unlock the top lock.
     */
    UserAssert(ptlIn == ptl);
    ptiCurrent->ptl = ptl->next;
    /*
     * If the object address is not NULL, then unlock the object.
     */
    phead = (PHEAD)(ptl->pobj);
    if (phead != NULL) {

        /*
         * Unlock the object.
         */

        phead = (PHEAD)HMUnlockObject(phead);
    }
#if DBG
    {
        /*
         * Remove the corresponding element from gFreeTLList
         */
        ptl->ptl->next = gFreeTLList;
        ptl->ptl->uTLCount += TL_FREED_PATTERN;
        gFreeTLList = ptl->ptl;
    }
#endif
    return (PVOID)phead;
}

/*
 * Switch back to default optimization.
 */
#pragma optimize("", on)

#if DBG
/***************************************************************************\
* CheckLock
*
* This routine only exists in DBG builds - it checks to make sure objects
* are thread locked.
*
* 03-09-92 ScottLu      Created.
\***************************************************************************/
VOID CheckLock(
    PVOID pobj)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    PTL ptl;

    if (pobj == NULL) {
        return;
    }

    /*
     * Validate all locks first
     */
    UserAssert(ptiCurrent != NULL);
    ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&pobj, TRUE);

    for (ptl = ptiCurrent->ptl; ptl != NULL; ptl=ptl->next) {
        if (ptl->pobj == pobj)
            return;
    }

    /*
     * WM_FINALDESTROY messages get sent without thread locking, so if
     * marked for destruction, don't print the message.
     */
    if (HMPheFromObject(pobj)->bFlags & HANDLEF_DESTROY)
        return;

    RIPMSG1(RIP_ERROR, "Object not thread locked! %#p", pobj);
}
#endif


/***************************************************************************\
* HMDestroyUnlockedObject
*
* Destroy an object based on an unlock or cleanup from thread or
* process termination.
*
* The functions called to destroy a particular object can be called
* directly from code as well as the result of an unlock. Destroy
* functions have the following 4 sections.
*
*     (1) Remove the object from a list or other global
*     context. If the destroy function has to leave the
*     critical section (e.g. make an xxx call), it must
*     do so in this step.
*
*     (2) Call HMMarkDestroy, and return if HMMarkDestroy
*     returns FALSE. This is required.
*
*     (3) Destroy resources held by the objects - locks to
*     other objects, alloc'd memory, etc. This is required.
*
*     (4) Free the memory of the object and its handle by calling
*     HMFreeObject. This is required.
*
* Note that if the object is locked when it's destroy function
* is called directly, step (1) will be repeated when the object is
* unlocked. We should probably check for this in the destroy functions,
* which we currently do not do.
*
* Note that we could be destroying this object in a context different
* than the one that created it. This is very important to understand
* since in lots of code the "current thread" is referenced and assumed
* as the creator.
*
* 02-10-92 ScottLu      Created.
\***************************************************************************/
VOID HMDestroyUnlockedObject(
    PHE phe)
{
    BEGINATOMICCHECK();

    /*
     * Remember that we're destroying this object so we don't try to destroy
     * it again when the lock count goes from != 0 to 0 (especially true
     * for thread locks).
     */
    phe->bFlags |= HANDLEF_INDESTROY;

    /*
     * This'll call the destroy handler for this object type.
     */
    (*gahti[phe->bType].fnDestroy)(phe->phead);

    /*
     * HANDLEF_INDESTROY is supposed to be cleared either by HMMarkObjectDestroy
     * or by HMFreeObject; the destroy handler was supposed to call at least
     * the former.
     */
    UserAssert(!(phe->bFlags & HANDLEF_INDESTROY));

    /*
     * If the object wasn't freed, it must be marked as destroyed
     * and must have a lock count.
     */
    UserAssert((phe->bType == TYPE_FREE)
                || ((phe->bFlags & HANDLEF_DESTROY) && (phe->phead->cLockObj > 0)));

    ENDATOMICCHECK();
}


/***************************************************************************\
* HMChangeOwnerThread
*
* Changes the owning thread of an object.
*
* 09-13-93 JimA         Created.
\***************************************************************************/
VOID HMChangeOwnerThread(
    PVOID pobj,
    PTHREADINFO pti)
{
    PHE phe = HMPheFromObject(pobj);
    PTHREADINFO ptiOld = ((PTHROBJHEAD)pobj)->pti;
    PWND pwnd;
    PPCLS ppcls;
    PPROCESSINFO ppi;

    CheckCritIn();

    UserAssert(HMObjectFlags(pobj) & OCF_THREADOWNED);
    UserAssert(pti != NULL);

    ((PTHREADINFO)phe->pOwner)->ppi->UserHandleCount--;

    ((PTHROBJHEAD)pobj)->pti = phe->pOwner = pti;

    ((PTHREADINFO)phe->pOwner)->ppi->UserHandleCount++;

    DBGValidateHandleQuota();

    /*
     * If this is a window, update the window counts.
     */
    switch (phe->bType) {
    case TYPE_WINDOW:
        /*
         * Desktop thread used to hit this assert in HYDRA because
         * pti == ptiOld.
         */
        UserAssert(ptiOld->cWindows > 0 || ptiOld == pti);
        pti->cWindows++;
        ptiOld->cWindows--;

        pwnd = (PWND)pobj;

        /*
         * Make sure thread visible window count is properly updated.
         */
        if (TestWF(pwnd, WFVISIBLE) && FVisCountable(pwnd)) {
            pti->cVisWindows++;
            ptiOld->cVisWindows--;
        }

        /*
         * If the owning process is changing, fix up the window class.
         */
        if (pti->ppi != ptiOld->ppi) {

            ppcls = GetClassPtr(pwnd->pcls->atomClassName, pti->ppi, hModuleWin);

            if (ppcls == NULL) {
                if (pwnd->head.rpdesk) {
                    ppi = pwnd->head.rpdesk->rpwinstaParent->pTerm->ptiDesktop->ppi;
                } else {
                    ppi = PpiCurrent();
                }
                ppcls = GetClassPtr(gpsi->atomSysClass[ICLS_ICONTITLE], ppi, hModuleWin);
            }
            UserAssert(ppcls);
#if DBG
            if (!TestWF(pwnd, WFDESTROYED)) {
                if ((*ppcls)->rpdeskParent == NULL) {
                    /*
                     * If rpdeskParent NULL then it has to be a system thread.
                     */
                    UserAssert(pti->TIF_flags & TIF_SYSTEMTHREAD);
                } else {
                    /*
                     * The desktop of the class has to be the same as the window's desktop
                     */
                    UserAssert((*ppcls)->rpdeskParent == pwnd->head.rpdesk);
                }
            }
#endif
            {
                DereferenceClass(pwnd);
                pwnd->pcls = *ppcls;
                /*
                 * We might fail to clone the class for a zombie window in
                 * ReferenceClass since we ran out of desktop heap (see bug
                 * #375171). In this case, we just increment the class window
                 * reference since there will be no client-side reference to
                 * the class. Need to assert that the window is destroyed or
                 * we will be in trouble. A better fix would be to clone the
                 * icon title class beforehand during desktop creation.
                 * [msadek, 06/21/2001]
                 */
                if (!ReferenceClass(pwnd->pcls, pwnd)) {
                    pwnd->pcls->cWndReferenceCount++;
                    if (!TestWF(pwnd, WFDESTROYED)) {
                        FRE_RIPMSG2(RIP_ERROR,
                                    "Non destroyed window using a non cloned class. cls 0x%p, pwnd 0x%p",
                                    pwnd->pcls,
                                    pwnd);
                    }
                }
            }
        }
        break;

    case TYPE_HOOK:
        /*
         * If this is a global hook, remember this hook's desktop so we'll be
         * able to unlink it later (gptiRit might switch to a different desktop
         * at any time).
         */
        UserAssert(!!(((PHOOK)pobj)->flags & HF_GLOBAL) ^ (((PHOOK)pobj)->ptiHooked != NULL));
        if (((PHOOK)pobj)->flags & HF_GLOBAL) {
            UserAssert(pti == gptiRit);
            LockDesktop(&((PHOOK)pobj)->rpdesk, ptiOld->rpdesk, LDL_HOOK_DESK, 0);
        } else {
            /*
             * This must be a hook on another thread or it was supposed to be
             *  gone by now.
             */
            UserAssert(((PHOOK)pobj)->ptiHooked != ptiOld);
        }
        break;

    default:
        break;
    }
}

/***************************************************************************\
* HMChangeOwnerProcess
*
* Changes the owning process of an object.
*
* 04-15-97 JerrySh      Created.
* 09-23-97 GerardoB     Changed parameters (and name) so HMDestroyUnlockedObject
*                        could use this function (instead of duplicating the code there)
\***************************************************************************/
VOID HMChangeOwnerPheProcess(
    PHE phe,
    PTHREADINFO pti)
{
    PPROCESSINFO ppiOwner = (PPROCESSINFO)(phe->pOwner);
    PVOID pobj = phe->phead;

    UserAssert(HMObjectFlags(pobj) & OCF_PROCESSOWNED);
    UserAssert(pti != NULL);
    /*
     * Dec current owner handle count
     */
    ppiOwner->UserHandleCount--;
    /*
     * hTaskWow
     */
    if ((pti->TIF_flags & TIF_16BIT) && (pti->ptdb)) {
        ((PPROCOBJHEAD)pobj)->hTaskWow = pti->ptdb->hTaskWow;
    } else {
        ((PPROCOBJHEAD)pobj)->hTaskWow = 0;
    }
    /*
     * ppi
     */
    if (gahti[phe->bType].bObjectCreateFlags & OCF_MARKPROCESS) {
        ((PPROCMARKHEAD)pobj)->ppi = pti->ppi;
    }
    /*
     * Set new owner in handle entry
     */
    phe->pOwner = pti->ppi;
    /*
     * Inc new owner handle count
     */
    ((PPROCESSINFO)(phe->pOwner))->UserHandleCount++;
    /*
     * If the handle is a cursor, adjust GDI cursor handle count
     */
    if (phe->bType == TYPE_CURSOR) {
        GreDecQuotaCount((PW32PROCESS)ppiOwner);
        GreIncQuotaCount((PW32PROCESS)phe->pOwner);

        if (((PCURSOR)pobj)->hbmColor) {
            GreDecQuotaCount((PW32PROCESS)ppiOwner);
            GreIncQuotaCount((PW32PROCESS)phe->pOwner);
        }
        if (((PCURSOR)pobj)->hbmUserAlpha) {
            GreDecQuotaCount((PW32PROCESS)ppiOwner);
            GreIncQuotaCount((PW32PROCESS)phe->pOwner);
        }
    }

    DBGValidateHandleQuota();
}

/***************************************************************************\
* DestroyThreadsObjects
*
* Goes through the handle table list and destroy all objects owned by this
* thread, because the thread is going away (either nicely, it faulted, or
* was terminated). It is ok to destroy the objects in any order, because
* object locking will ensure that they get destroyed in the right order.
*
* This routine gets called in the context of the thread that is exiting.
*
* 02-08-92 ScottLu      Created.
\***************************************************************************/
VOID DestroyThreadsObjects(
    VOID)
{
    PTHREADINFO ptiCurrent;
    HANDLEENTRY volatile * (*pphe);
    PHE pheT;
    DWORD i;

    ptiCurrent = PtiCurrent();
    DBGValidateHandleQuota();

    /*
     * Before any window destruction occurs, we need to destroy any dcs
     * in use in the dc cache. When a dc is checked out, it is marked owned,
     * which makes gdi's process cleanup code delete it when a process
     * goes away. We need to similarly destroy the cache entry of any dcs
     * in use by the exiting process.
     */
    DestroyCacheDCEntries(ptiCurrent);

    /*
     * Remove any thread locks that may exist for this thread.
     */
    while (ptiCurrent->ptl != NULL) {
        UserAssert((ULONG_PTR)ptiCurrent->ptl > (ULONG_PTR)&i);
        UserAssert((ULONG_PTR)ptiCurrent->ptl < (ULONG_PTR)PsGetCurrentThreadStackBase());
        ThreadUnlock(ptiCurrent->ptl);
    }

    /*
     * CleanupPool stuff must happen before handle table clean up (as it
     * always has been). This is because SMWPs can be HM objects and still
     * be locked in ptlPool. If the handle is destroyed first (and it's not
     * locked) we would end up with a bogus pointer in ptlPool. If ptlPool
     * is cleaned up first, the handle will be freed or properly preserved
     * if locked.
     */
    CleanupW32ThreadLocks((PW32THREAD)ptiCurrent);

    /*
     * Even though HMDestroyUnlockedObject might call xxxDestroyWindow, the
     * following loop is not supposed to leave the critical section. We must
     * have called PatchThreadWindows before coming here.
     */
    BEGINATOMICCHECK();

    /*
     * Loop through the table destroying all objects created by the current
     * thread. All objects will get destroyed in their proper order simply
     * because of the object locking.
     */
    pphe = &gSharedInfo.aheList;
    for (i = 0; i <= giheLast; i++) {
        /*
         * This pointer is done this way because it can change when we leave
         * the critical section below.  The above volatile ensures that we
         * always use the most current value
         */
        pheT = (PHE)((*pphe) + i);

        /*
         * Check against free before we look at pti... because pq is stored
         * in the object itself, which won't be there if TYPE_FREE.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * If a menu refererences a window owned by this thread, unlock
         * the window. This is done to prevent calling xxxDestroyWindow
         * during process cleanup.
         */
        if (gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) {
            if (pheT->bType == TYPE_MENU) {
                PWND pwnd = ((PMENU)pheT->phead)->spwndNotify;

                if (pwnd != NULL && GETPTI(pwnd) == ptiCurrent) {
                    Unlock(&((PMENU)pheT->phead)->spwndNotify);
                }
            }

            continue;
        }

        /*
         * Destroy those objects created by this queue.
         */
        if ((PTHREADINFO)pheT->pOwner != ptiCurrent) {
            continue;
        }

        UserAssert(gahti[pheT->bType].bObjectCreateFlags & OCF_THREADOWNED);

        /*
         * Make sure this object isn't already marked to be destroyed - we'll
         * do no good if we try to destroy it now since it is locked.
         */
        if (pheT->bFlags & HANDLEF_DESTROY) {
            continue;
        }

        /*
         * Destroy this object.
         */
        HMDestroyUnlockedObject(pheT);
    }

    ENDATOMICCHECK();
    DBGValidateHandleQuota();
}

#if DBG || FRE_LOCK_RECORD
VOID ShowLocks(
    PHE phe)
{
    PLR plr = phe->plr;
    INT c;

    RIPMSG2(RIP_WARNING | RIP_THERESMORE,
            "Lock records for %s %#p:",
            gahti[phe->bType].szObjectType, phe->phead->h);
    /*
     * We have the handle entry: 'head' and 'he' are both filled in. Dump
     * the lock records. Remember the first record is the last transaction!!
     */
    c = 0;
    while (plr != NULL) {
        char achPrint[80];

        if (plr->ppobj == LOCKRECORD_MARKDESTROY) {
            strcpy(achPrint, "Destroyed with");
        } else if ((int)plr->cLockObj <= 0) {
            strcpy(achPrint, "        Unlock");
        } else {
            /*
             * Find corresponding unlock;
             */
            {
               PLR plrUnlock;
               DWORD cT;
               DWORD cUnlock;

               plrUnlock = phe->plr;
               cT =  0;
               cUnlock = (DWORD)-1;

               while (plrUnlock != plr) {
                   if (plrUnlock->ppobj == plr->ppobj) {
                       if ((int)plrUnlock->cLockObj <= 0) {
                           // a matching unlock found
                           cUnlock = cT;
                       } else {
                           // the unlock #cUnlock matches this lock #cT, thus
                           // #cUnlock is not the unlock we were looking for.
                           cUnlock = (DWORD)-1;
                       }
                   }
                   plrUnlock = plrUnlock->plrNext;
                   cT++;
               }
               if (cUnlock == (DWORD)-1) {
                   /*
                    * Corresponding unlock not found!
                    * This may not mean something is wrong: the structure
                    * containing the pointer to the object may have moved
                    * during a reallocation.  This can cause ppobj at Unlock
                    * time to differ from that recorded at Lock time.
                    * (Warning: moving structures like this may cause a Lock
                    * and an Unlock to be misidentified as a pair, if by a
                    * stroke of incredibly bad luck, the new location of a
                    * pointer to an object is now where an old pointer to the
                    * same object used to be)
                    */
                   sprintf(achPrint, "Unmatched Lock");
               } else {
                   sprintf(achPrint, "lock   #%ld", cUnlock);
               }
            }
        }

        RIPMSG4(RIP_WARNING | RIP_NONAME | RIP_THERESMORE,
                "        %s cLock=%d, pobj at %#p, code at %#p",
                achPrint,
                abs((int)plr->cLockObj),
                plr->ppobj,
                plr->trace[0]);

        plr = plr->plrNext;
        c++;
    }

    RIPMSG1(RIP_WARNING | RIP_NONAME, "        0x%lx records", c);
}
#endif

/***************************************************************************\
* FixupGlobalCursor
*
* Spins through a global cursor (a cursor who's owner is NULL), and
* reassigns ownership to the specified process.
*
* Note: This changes the owner process field inside the object itself.  It
* does not change the owner field of the handle referencing it.
*
\***************************************************************************/
VOID FixupGlobalCursor(
    PCURSOR      pcur,
    PPROCESSINFO ppi)
{
    int   i;
    PACON pacon = (PACON)pcur;

    if (pcur->head.ppi == NULL) {
        pcur->head.ppi = ppi;
    }

    if (pacon->CURSORF_flags & CURSORF_ACON) {
        for (i = 0; i < pacon->cpcur; i++) {

            UserAssert(pacon->aspcur[i]->CURSORF_flags & CURSORF_ACONFRAME);

            if (pacon->aspcur[i]->head.ppi == NULL) {
                pacon->aspcur[i]->head.ppi = ppi;
            }
        }
    }
}

/***************************************************************************\
* DestroyProcessesObjects
*
* Goes through the handle table list and destroy all objects owned by this
* process, because the process is going away (either nicely, it faulted, or
* was terminated). It is ok to destroy the objects in any order, because
* object locking will ensure that they get destroyed in the right order.
*
* This routine gets called in the context of the last thread in the process.
*
* 08-17-92 JimA         Created.
\***************************************************************************/
VOID DestroyProcessesObjects(
    PPROCESSINFO ppi)
{
    PHE  pheT, pheMax;
    BOOL fCSRSS = (ppi->Process == gpepCSRSS);

#if DBG
    BOOL fOrphaned = FALSE;
#endif // DBG

    DBGValidateHandleQuota();

    /*
     * Loop through the table destroying all objects owned by the current
     * process. All objects will get destroyed in their proper order simply
     * because of the object locking.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

        /*
         * If this handle entry is free, skip it.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * Don't destroy objects that are either not owned by a process at all, or
         * are owned by a process - but a different process than us!
         */
        if (!(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) ||
                (PPROCESSINFO)pheT->pOwner != ppi) {
            continue;
        }

        /*
         * If this is CSRSS being destroyed, then we need to clean up all
         * "global" cursors.  Note that the owner process stored in the
         * handle is CSRSS, but the owner process stored in the object is
         * NULL.  We assign ownership of the cursor (and all associated
         * frames) to CSRSS, so that it will be cleaned up during the
         * HMDestroyUnlockedObject call.
         */
        if (fCSRSS && pheT->bType == TYPE_CURSOR) {
            FixupGlobalCursor((PCURSOR)pheT->phead, ppi);
        }

        /*
         * Destroy this object - but only if it hasn't already been destroyed!
         */
        if (!(pheT->bFlags & HANDLEF_DESTROY)) {
            HMDestroyUnlockedObject(pheT);
        } else {
            //
            // If the handle was marked as having already been destroyed, it
            // should have a non-zero lock count.  When the final Unlock is
            // called, the object will be freed.
            //
            UserAssert(pheT->phead->cLockObj != 0);
        }

        /*
         * Check to see if the object was destroyed, but not freed.
         */
        if (pheT->bType != TYPE_FREE) {
            /*
             * This object has already been destroyed. Is is just waiting for its
             * lock count to reach 0 before it can be actually freed. However,
             * since this object is owned by the process that is going away, it
             * is now an "orphaned" object. Pass ownership to the RIT if possible.
             * Once the other objects that are holding locks on this object release
             * their locks, this object will evaporate. If the locks are never
             * released then we have a leak, and we will catch it later.
             *
             * Note that this might be uneccessary, as the owners of the locks
             * may all belong to this process, and as such will all be destroyed
             * during this function - and therefore the reparenting was not needed.
             * However, doing so now allows us to complete in a single pass
             * through the handle table.
             */
            if (gptiRit != NULL) {
                if (pheT->bType == TYPE_CURSOR) {
                    ZombieCursor((PCURSOR)pheT->phead);
                } else {
                    HMChangeOwnerPheProcess(pheT, gptiRit);
                }
            }

#if DBG
            fOrphaned = TRUE;
#endif // DBG
        }
    }

#if DBG
    /*
     * Check to see if we have any orphans left in the handle table that
     * used to belong to this process.  This only poses a serious problem
     * when the RIT is not available (for instance, if we are shutting down)
     * because we have no one to adopt these objects.  This would indicate
     * a serious resource leak and should be fixed.
     */
    if (fOrphaned && gptiRit == NULL) {
        pheMax = &gSharedInfo.aheList[giheLast];
        for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
            if (pheT->bType != TYPE_FREE &&
               (gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) &&
               (PPROCESSINFO)pheT->pOwner == ppi) {
               RIPMSGF1(RIP_ERROR, "Object leak detected! phe= 0x%p", pheT);
            }
        }
    }
#endif

    DBGValidateHandleQuota();
}

/***************************************************************************\
* MarkThreadsObjects
*
* This is called for the *final* exiting condition when a thread
* may have objects still around... in which case their owner must
* be changed to something "safe" that won't be going away.
*
* 03-02-92 ScottLu      Created.
\***************************************************************************/
VOID MarkThreadsObjects(
    PTHREADINFO pti)
{
    PHE pheT, pheMax;

    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        /*
         * Check against free before we look at pti... because pti is stored
         * in the object itself, which won't be there if TYPE_FREE.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * Change ownership!
         */
        if (gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED ||
                (PTHREADINFO)pheT->pOwner != pti) {
            continue;
        }

        /*
         * This is just to make sure that RIT or DT never get here.
         */
        UserAssert(pti != gptiRit && pti != gTermIO.ptiDesktop);

        HMChangeOwnerThread(pheT->phead, gptiRit);

#if DBG

        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            /*
             * Object still around: print warning message.
             */
            if (pheT->bFlags & HANDLEF_DESTROY) {
                    TAGMSG2(DBGTAG_TrackLocks,
                            "Zombie %s 0x%p still locked",
                            gahti[pheT->bType].szObjectType,
                            pheT->phead->h);
            } else {
                TAGMSG1(DBGTAG_TrackLocks,
                        "Thread object 0x%p not destroyed.",
                        pheT->phead->h);
            }

            ShowLocks(pheT);
        }

#endif
    }
}

/***************************************************************************\
* HMRelocateLockRecord
*
* If a pointer to a locked object has been relocated, then this routine will
* adjust the lock record accordingly.  Must be called after the relocation.
*
* The arguments are:
*   ppobjNew - the address of the new pointer
*              MUST already contain the pointer to the object!!
*   cbDelta  - the amount by which this pointer was moved.
*
* Using this routine appropriately will prevent spurious "unmatched lock"
* reports.  See mnchange.c for an example.
*
*
* 03-18-93 IanJa        Created.
\***************************************************************************/

#if DBG || FRE_LOCK_RECORD
BOOL HMRelocateLockRecord(
    PVOID ppobjNew,
    LONG_PTR cbDelta)
{
    PHE phe;
    PVOID ppobjOld = (PBYTE)ppobjNew - cbDelta;
    PHEAD pobj;
    PLR plr;

    if (ppobjNew == NULL) {
        return FALSE;
    }

    pobj = *(PHEAD *)ppobjNew;

    if (pobj == NULL) {
        return FALSE;
    }

    phe = HMPheFromObject(pobj);
    if (phe->phead != pobj) {
        RIPMSG3(RIP_WARNING,
                "HmRelocateLockRecord(%#p, %lx) - %#p is bad pobj",
                ppobjNew, cbDelta, pobj);

        return FALSE;
    }

    plr = phe->plr;

    while (plr != NULL) {
        if (plr->ppobj == ppobjOld) {
            (PBYTE)(plr->ppobj) += cbDelta;
            return TRUE;
        }
        plr = plr->plrNext;
    }

    RIPMSG2(RIP_WARNING,
            "HmRelocateLockRecord(%#p, %lx) - couldn't find lock record",
            ppobjNew, cbDelta);

    ShowLocks(phe);
    return FALSE;
}


BOOL HMUnrecordLock(
    PVOID ppobj,
    PVOID pobj)
{
    PHE phe;
    PLR plr;
    PLR *pplr;

    phe = HMPheFromObject(pobj);

    pplr = &(phe->plr);
    plr = *pplr;

    /*
     * Find corresponding lock;
     */
    while (plr != NULL) {
        if (plr->ppobj == ppobj) {
            /*
             * Remove the lock from the list...
             */
            *pplr = plr->plrNext;   // unlink it
            plr->plrNext = NULL;    // make the dead entry safe (?)

            /*
             * ...and free it.
             */
            FreeLockRecord(plr);
            return TRUE;
        }
        pplr = &(plr->plrNext);
        plr = *pplr;
    }

    RIPMSG2(RIP_WARNING, "Could not find lock for ppobj %#p pobj %#p",
            ppobj, pobj);

    return FALSE;
}

#endif // DBG

/***************************************************************************\
* _QueryUserHandles
*
* This function retrieves the USER handle counters for all processes
* specified by their client ID in the paPids array
* Specify QUC_PID_TOTAL to retrieve totals for all processes in the system
*
* Parameters:
*    paPids   - pointer to an array of pids (DWORDS) that we're interested in
*    dwNumInstances - number of DWORDS in paPids
*    pdwResult - will receive TYPES_CTYPESxdwNumInstances counters
*
* returns: none
*
* 07-25-97 mcostea        Created
\***************************************************************************/
VOID _QueryUserHandles(
    LPDWORD  paPids,
    DWORD    dwNumInstances,
    DWORD    dwResult[][TYPE_CTYPES])
{
    PHE         pheCurPos;                 // Current position in the table
    PHE         pheMax;                    // address of last table entry
    DWORD       index;
    DWORD       pid;
    DWORD       dwTotalCounters[TYPE_CTYPES]; // system wide counters

    RtlZeroMemory(dwTotalCounters, TYPE_CTYPES*sizeof(DWORD));
    RtlZeroMemory(dwResult, dwNumInstances*TYPE_CTYPES*sizeof(DWORD));
    /*
     * Walk the handle table and update the counters
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for(pheCurPos = gSharedInfo.aheList; pheCurPos <= pheMax; pheCurPos++) {

        UserAssert(pheCurPos->bType < TYPE_CTYPES);

        if (pheCurPos->pOwner) {

            if (gahti[pheCurPos->bType].bObjectCreateFlags & OCF_PROCESSOWNED) {
                pid = HandleToUlong(PsGetProcessId(((PPROCESSINFO)(pheCurPos->pOwner))->Process));
            } else if (gahti[pheCurPos->bType].bObjectCreateFlags & OCF_THREADOWNED) {
                pid = HandleToUlong(PsGetThreadProcessId(((PTHREADINFO)pheCurPos->pOwner)->pEThread));
            } else {
                pid = 0;
            }
        }

        /*
         * Search to see if we are interested in this process. Unowned
         * handles are reported for the "System" process whose pid is 0.
         */
        for (index = 0; index < dwNumInstances; index++) {
            if (paPids[index] == pid) {
                dwResult[index][pheCurPos->bType]++;
            }
        }

        /*
         * Update the totals.
         */
        dwTotalCounters[pheCurPos->bType]++;
    }

    /*
     * Search to see if we are interested in the totals.
     */
    for (index = 0; index < dwNumInstances; index++) {
        if (paPids[index] == QUC_PID_TOTAL) {
            RtlMoveMemory(dwResult[index], dwTotalCounters, sizeof(dwTotalCounters));
        }
    }
}

/***************************************************************************\
* HMCleanupGrantedHandle
*
* This function is called to cleanup this handle from pW32Job->pgh arrays.
* It walks the job list to find jobs that have the handle granted.
*
* HISTORY:
* 22 Jul 97      CLupu            Created
\***************************************************************************/
VOID HMCleanupGrantedHandle(
    HANDLE h)
{
    PW32JOB pW32Job;

    pW32Job = gpJobsList;

    while (pW32Job != NULL) {
        PULONG_PTR pgh;
        DWORD  dw;

        pgh = pW32Job->pgh;

        /*
         * search for the handle in the array.
         */
        for (dw = 0; dw < pW32Job->ughCrt; dw++) {
            if (*(pgh + dw) == (ULONG_PTR)h) {
                /*
                 * Found the handle granted to this process.
                 */
                RtlMoveMemory(pgh + dw,
                              pgh + dw + 1,
                              (pW32Job->ughCrt - dw - 1) * sizeof(*pgh));

                (pW32Job->ughCrt)--;

                /*
                 * we should shrink the array also
                 */

                break;
            }
        }

        pW32Job = pW32Job->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\hotkeys.c ===
/****************************** Module Header ******************************\
* Module Name: hotkeys.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of hotkey processing.
*
* History:
* 12-04-90 DavidPe      Created.
* 02-12-91 JimA         Added access checks
* 13-Feb-1991 mikeke    Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

static PHOTKEY gphkHashTable[128];

/*
 * This is the hash function for vks. The vast majority of hotkeys will have
 * vk values < 128, so we limit our table to that size. Worst case (all vks
 * > 128) we'll have the same perf (essentially) as the old, linked list
 * code.
 */
__inline BYTE HKHashVK(
    UINT vk)
{
    return (BYTE)(vk & (ARRAY_SIZE(gphkHashTable) - 1));
}

/***************************************************************************\
* HKGetHashHead
*
* This routine returns the start of the bucket keyed by the specified vk.
*
* History:
* 08-13-2002    JasonSch    Created.
\***************************************************************************/
PHOTKEY HKGetHashHead(
    UINT vk)
{
    return gphkHashTable[HKHashVK(vk)];
}

/***************************************************************************\
* HKInsertHashElement
*
* Inserts a HOTKEY structure into the hash table.
*
* History:
* 08-13-2002    JasonSch    Created.
\***************************************************************************/
VOID HKInsertHashElement(
    PHOTKEY phk)
{
    BYTE index = HKHashVK(phk->vk);
    PHOTKEY phkT;

    phkT = gphkHashTable[index];
    phk->phkNext = phkT;
    gphkHashTable[index] = phk;
}

/***************************************************************************\
* SetDebugHotKeys
*
* This routine registers the default system hotkeys for debugging.
*
* History:
* 12-04-90 DavidPe      Created.
\***************************************************************************/
VOID SetDebugHotKeys(
    VOID)
{
    UINT VkDebug;

    FastGetProfileDwordW(NULL, PMAP_AEDEBUG, L"UserDebuggerHotkey", 0, &VkDebug, 0);
    if (VkDebug == 0) {
        if (ENHANCED_KEYBOARD(gKeyboardInfo.KeyboardIdentifier)) {
            VkDebug = VK_F12;
        } else {
            VkDebug = VK_SUBTRACT;
        }
    } else {
        UserAssert((0xFFFFFF00 & VkDebug) == 0);
    }

    _UnregisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUG);
    _UnregisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUGSERVER);

    _RegisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUG, 0, VkDebug);
    _RegisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUGSERVER, MOD_SHIFT, VkDebug);
}


/***************************************************************************\
* DestroyThreadsHotKeys
*
* History:
* 26-Feb-1991 mikeke    Created.
\***************************************************************************/
VOID DestroyThreadsHotKeys(
    VOID)
{
    PHOTKEY *pphk, phk;
    PTHREADINFO ptiCurrent = PtiCurrent();
    int i = 0;

    for (; i < ARRAY_SIZE(gphkHashTable); ++i) {
        pphk = &gphkHashTable[i];
        while (*pphk) {
            if ((*pphk)->pti == ptiCurrent) {
                phk = *pphk;
                *pphk = (*pphk)->phkNext;

                /*
                 * Unlock the object stored here.
                 */
                if (phk->spwnd != PWND_FOCUS && phk->spwnd != PWND_INPUTOWNER) {
                    Unlock(&phk->spwnd);
                }

                UserFreePool(phk);
            } else {
                pphk = &((*pphk)->phkNext);
            }
        }
    }
}


/***************************************************************************\
* DestroyWindowsHotKeys
*
* Frees hotkeys associated with the specified pwnd that were not explicitly
* unregistered by the app.
*
* History:
* 23-Sep-1992 IanJa     Created.
\***************************************************************************/
VOID DestroyWindowsHotKeys(
    PWND pwnd)
{
    PHOTKEY *pphk, phk;
    int i = 0;

    for (; i < ARRAY_SIZE(gphkHashTable); ++i) {
        pphk = &gphkHashTable[i];
        while (*pphk) {
            if ((*pphk)->spwnd == pwnd) {
                phk = *pphk;
                *pphk = (*pphk)->phkNext;

                Unlock(&phk->spwnd);
                UserFreePool(phk);
            } else {
                pphk = &((*pphk)->phkNext);
            }
        }
    }
}


/***************************************************************************\
* _RegisterHotKey (API)
*
* This API registers the hotkey specified. If the specified key sequence has
* already been registered we return FALSE. If the specified hwnd and id have
* already been registered, fsModifiers and vk are reset for the HOTKEY.
*
* History:
* 12-04-90 DavidPe      Created.
* 02-12-91 JimA         Added access check
\***************************************************************************/
BOOL _RegisterHotKey(
    PWND pwnd,
    int id,
    UINT fsModifiers,
    UINT vk)
{
    PHOTKEY phk;
    BOOL fKeysExist, bSAS;
    PTHREADINFO ptiCurrent;
    WORD wFlags;

    wFlags = fsModifiers & MOD_SAS;
    fsModifiers &= ~MOD_SAS;

    ptiCurrent = PtiCurrent();

    /*
     * Blow it off if the caller is not the windowstation init thread
     * and doesn't have the proper access rights
     */
    if (PsGetCurrentProcess() != gpepCSRSS) {
        if (grpWinStaList && !CheckWinstaWriteAttributesAccess()) {
            return FALSE;
        }
    }

    /*
     * If VK_PACKET is specified, just bail out, since VK_PACKET is
     * not a real keyboard input.
     */
    if (vk == VK_PACKET) {
        return FALSE;
    }

    /*
     * If this is the SAS check that winlogon is the one registering it.
     */
    if ((wFlags & MOD_SAS) != 0 && PsGetCurrentProcessId() == gpidLogon) {
        bSAS = TRUE;
    } else {
        bSAS = FALSE;
    }

    /*
     * Can't register hotkey for a window of another queue.
     */
    if (pwnd != PWND_FOCUS && pwnd != PWND_INPUTOWNER) {
        if (GETPTI(pwnd) != ptiCurrent) {
            RIPERR1(ERROR_WINDOW_OF_OTHER_THREAD,
                    RIP_WARNING,
                    "hwnd 0x%x belongs to a different thread",
                    HWq(pwnd));

            return FALSE;
        }
    }

    phk = FindHotKey(ptiCurrent, pwnd, id, fsModifiers, vk, FALSE, &fKeysExist);

    /*
     * If the keys have already been registered, return FALSE.
     */
    if (fKeysExist) {
        RIPERR0(ERROR_HOTKEY_ALREADY_REGISTERED,
                RIP_WARNING,
                "Hotkey already exists");
        return FALSE;
    }

    if (phk == NULL) {

        /*
         * This hotkey doesn't exist yet.
         */
        phk = (PHOTKEY)UserAllocPool(sizeof(HOTKEY), TAG_HOTKEY);
        if (phk == NULL) {
            return FALSE;
        }

        phk->pti = ptiCurrent;

        if (pwnd != PWND_FOCUS && pwnd != PWND_INPUTOWNER) {
            phk->spwnd = NULL;
            Lock(&phk->spwnd, pwnd);
        } else {
            phk->spwnd = pwnd;
        }
        phk->fsModifiers = (WORD)fsModifiers;
        phk->wFlags = wFlags;

        phk->vk = vk;
        phk->id = id;

        /*
         * Add the new hotkey to our global hash.
         */
        HKInsertHashElement(phk);
    } else {
        /*
         * Hotkey already exists, reset the keys.
         */
        phk->fsModifiers = (WORD)fsModifiers;
        phk->wFlags = wFlags;
        phk->vk = vk;
    }

    if (bSAS) {
        /*
         * Store the SAS on the terminal.
         */
        gvkSAS = vk;
        gfsSASModifiers = fsModifiers;
    }

    return TRUE;
}


/***************************************************************************\
* _UnregisterHotKey (API)
*
* This API will unregister the specified hwnd/id hotkey so that the
* WM_HOTKEY message will not be generated for it.
*
* History:
* 12-04-90 DavidPe      Created.
\***************************************************************************/
BOOL _UnregisterHotKey(
    PWND pwnd,
    int id)
{
    PHOTKEY phk;
    BOOL fKeysExist;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    phk = FindHotKey(ptiCurrent, pwnd, id, 0, 0, TRUE, &fKeysExist);
    if (phk == NULL) {
        RIPERR2(ERROR_HOTKEY_NOT_REGISTERED,
                (pwnd == PWND_INPUTOWNER) ? RIP_VERBOSE : RIP_WARNING,
                "Hotkey 0x%x on pwnd 0x%p does not exist",
                id,
                pwnd);

        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* FindHotKey
*
* Both RegisterHotKey() and UnregisterHotKey() call this function to search
* for hotkeys that already exist.  If a HOTKEY is found that matches
* fsModifiers and vk, *pfKeysExist is set to TRUE.  If a HOTKEY is found that
* matches pwnd and id, a pointer to it is returned.
*
* If fUnregister is TRUE, we remove the HOTKEY from the list if we find
* one that matches pwnd and id and return (PHOTKEY)1.
*
* History:
* 12-04-90 DavidPe      Created.
\***************************************************************************/
PHOTKEY FindHotKey(
    PTHREADINFO ptiCurrent,
    PWND pwnd,
    int id,
    UINT fsModifiers,
    UINT vk,
    BOOL fUnregister,
    PBOOL pfKeysExist)
{
    PHOTKEY phk, phkRet, phkPrev;
    BYTE index = HKHashVK(vk);

    UserAssert(!fUnregister || vk == 0);

    /*
     * Initialize out 'return' values.
     */
    *pfKeysExist = FALSE;
    phkRet = NULL;

    phk = gphkHashTable[index];

hashloop:
    while (phk) {

        /*
         * If all this matches up then we've found it.
         */
        if (phk->pti == ptiCurrent && phk->spwnd == pwnd && phk->id == id) {
            if (fUnregister) {
                /*
                 * Unlink the HOTKEY from the list.
                 */
                if (phk == gphkHashTable[index]) {
                    gphkHashTable[index] = phk->phkNext;
                } else {
                    phkPrev->phkNext = phk->phkNext;
                }

                if (pwnd != PWND_FOCUS && pwnd != PWND_INPUTOWNER) {
                    Unlock(&phk->spwnd);
                }
                UserFreePool(phk);

                return (PHOTKEY)1;
            }
            phkRet = phk;
        }

        /*
         * If the key is already registered, set the exists flag so the app
         * knows it can't use this hotkey sequence.
         */
        if (phk->fsModifiers == (WORD)fsModifiers && phk->vk == vk) {
            /*
             * In the case of PWND_FOCUS, we need to check that the queues
             * are the same since PWND_FOCUS is local to the queue it was
             * registered under.
             */
            if (phk->spwnd == PWND_FOCUS) {
                if (phk->pti == ptiCurrent) {
                    *pfKeysExist = TRUE;
                }
            } else {
                *pfKeysExist = TRUE;
            }
        }

        phkPrev = phk;
        phk = phk->phkNext;
    }

    /*
     * This is needed because when called from unregister we specify 0 as
     * the VK so the hash is always 0 and we need to index through the
     * entire hash table to try to find it.
     */
    if (fUnregister && ++index < ARRAY_SIZE(gphkHashTable)) {
        phk = gphkHashTable[index];
        goto hashloop;
    }

    return phkRet;
}


/***************************************************************************\
* IsSAS
*
* Checks the physical state of keyboard modifiers that would effect SAS.
\***************************************************************************/
BOOL IsSAS(
    BYTE vk,
    UINT *pfsModifiers)
{
    CheckCritIn();

    if (gvkSAS != vk) {
        return FALSE;
    }

    /*
     * Special case for SAS - examine real physical modifier-key state!
     *
     * An evil daemon process can fool convincingly pretend to be winlogon
     * by registering Alt+Del as a hotkey, and spinning another thread that
     * continually calls keybd_event() to send the Ctrl key up: when the
     * user types Ctrl+Alt+Del, only Alt+Del will be seen by the system,
     * the evil daemon will get woken by WM_HOTKEY and can pretend to be
     * winlogon.  So look at gfsSASModifiersDown in this case, to see what keys
     * were physically pressed.
     * NOTE: If hotkeys are ever made to work under journal playback, make
     * sure they don't affect the gfsSASModifiersDown!  - IanJa.
     */
    if (gfsSASModifiersDown == gfsSASModifiers) {
        *pfsModifiers = gfsSASModifiersDown;
        return TRUE;
    }

    return FALSE;
}

/*
 * The below two states are used by xxxDoHotKeyStuff().
 * Originally function-static variables, but as it's required
 * to clear those flags after the system wakes up from hybernation,
 * they are made global,
 */
UINT gfsModifiers;
UINT gfsModOnlyCandidate;

VOID ClearCachedHotkeyModifiers(
    VOID)
{
    /*
     * Clear the cached modifiers.
     */
    gfsModifiers = 0;
    gfsModOnlyCandidate = 0;

    /*
     * Clear the special modifier cache for the Ctrl+Alt+Del recognition.
     * (See comments in IsSAS()).
     */
    gfsSASModifiersDown = 0;
}


/***************************************************************************\
* xxxDoHotKeyStuff
*
* This function gets called for every key event from low-level input
* processing.  It keeps track of the current state of modifier keys
* and when gfsModifiers and vk match up with one of the registered
* hotkeys, a WM_HOTKEY message is generated. DoHotKeyStuff() will
* tell the input system to eat both the make and break for the 'vk'
* event.  This prevents apps from getting input that wasn't really
* intended for them.  DoHotKeyStuff() returns TRUE if it wants to 'eat'
* the event, FALSE if the system can pass on the event like it normally
* would.
*
* A Note on Modifier-Only Hotkeys
* Some hotkeys involve VK_SHIFT, VK_CONTROL, VK_MENU and/or VK_WINDOWS only.
* These are called Modifier-Only hotkeys.
* In order to distinguish hotkeys such as Alt-Shift-S and and Alt-Shift alone,
* modifier-only hotkeys must operate on a break, not a make.
* In order to prevent Alt-Shift-S from activating the Alt-Shift hotkey when
* the keys are released, modifier-only hotkeys are only activated when a
* modifier keyup (break) was immediately preceded by a modifier keydown (break)
* This also lets Alt-Shift,Shift,Shift activate the Alt-Shift hotkey 3 times.
*
* History:
* 12-05-90 DavidPe      Created.
*  4-15-93 Sanfords  Added code to return TRUE for Ctrl-Alt-Del events.
\***************************************************************************/
BOOL xxxDoHotKeyStuff(
    UINT vk,
    BOOL fBreak,
    DWORD fsReserveKeys)
{
    UINT fsModOnlyHotkey;
    UINT fs;
    PHOTKEY phk;
    BOOL fCancel;
    BOOL fEatDebugKeyBreak;
    PWND pwnd;
    BOOL bSAS;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    if (gfInNumpadHexInput & NUMPAD_HEXMODE_LL) {
        RIPMSGF0(RIP_VERBOSE,
                 "Since we're in gfInNumpadHexInput, just bail out.");
        return FALSE;
    }

    /*
     * Update gfsModifiers.
     */
    fs = 0;
    fsModOnlyHotkey = 0;

    switch (vk) {
    case VK_SHIFT:
        fs = MOD_SHIFT;
        break;

    case VK_CONTROL:
        fs = MOD_CONTROL;
        break;

    case VK_MENU:
        fs = MOD_ALT;
        break;

    case VK_LWIN:
    case VK_RWIN:
        fs = MOD_WIN;
        break;

    default:
        /*
         * A non-modifier key rules out Modifier-Only hotkeys
         */
        gfsModOnlyCandidate = 0;
        break;
    }

    if (fBreak) {
        gfsModifiers &= ~fs;
        /*
         * If a modifier key is coming up, the current modifier only hotkey
         * candidate must be tested to see if it is a hotkey.  Store this
         * in fsModOnlyHotkey, and prevent the next key release from
         * being a candidate by clearing fsModOnlyCandidate.
         */
        if (fs != 0) {
            fsModOnlyHotkey = gfsModOnlyCandidate;
            gfsModOnlyCandidate = 0;
        }
    } else {
        gfsModifiers |= fs;
        /*
         * If a modifier key is going down, we have a modifier-only hotkey
         * candidate.  Save current modifier state until the following break.
         */
        if (fs != 0) {
            gfsModOnlyCandidate = gfsModifiers;
        }
    }

    /*
     * We look at the physical state for the modifiers because they cannot be
     * manipulated and this prevents someone from writing a trojan winlogon
     * look alike (see comment in AreModifiersIndicatingSAS).
     */
    bSAS = IsSAS((BYTE)vk, &gfsModifiers);

    /*
     * If the key is not a hotkey then we're done but first check if the
     * key is an Alt-Escape if so we need to cancel journalling.
     *
     * NOTE: Support for Alt+Esc to cancel journalling dropped in NT 4.0
     */
    if (fsModOnlyHotkey && fBreak) {
        /*
         * A hotkey involving only VK_SHIFT, VK_CONTROL, VK_MENU or VK_WINDOWS
         * must only operate on a key release.
         */
        if ((phk = IsHotKey(fsModOnlyHotkey, VK_NONE)) == NULL) {
            return FALSE;
        }
    } else if ((phk = IsHotKey(gfsModifiers, vk)) == NULL) {
        return FALSE;
    }

    /*
     * If we tripped a SAS hotkey, but it's not really the SAS, don't do it.
     */
    if ((phk->wFlags & MOD_SAS) && !bSAS) {
        return FALSE;

    }

#ifdef GENERIC_INPUT
    if (gpqForeground && TestRawInputMode(PtiKbdFromQ(gpqForeground), NoHotKeys) &&
            (phk->wFlags & MOD_SAS) == 0) {
        /*
         * NOTE:
         * If the foreground thread does not want the hotkey handling,
         * just bail out.
         *
         * Exception: Ctrl+Alt+Del should be strictly handled by the system.
         */
        return FALSE;
    }
#endif

    if (phk->id == IDHOT_WINDOWS) {
        pwnd = GETDESKINFO(PtiCurrent())->spwndShell;
        if (pwnd != NULL) {
            gfsModOnlyCandidate = 0; /* Make it return TRUE */
            goto PostTaskListSysCmd;
        }
    }

    if (phk->id == IDHOT_DEBUG || phk->id == IDHOT_DEBUGSERVER) {
        if (!fBreak) {
            /*
             * The DEBUG key has been pressed. Break the appropriate thread
             * into the debugger. We won't need phk after this callback
             * because we return immediately.
             */
            fEatDebugKeyBreak = xxxActivateDebugger(phk->fsModifiers);
        } else {
            fEatDebugKeyBreak = FALSE;
        }

        /*
         * This'll eat the debug key down and break if we broke into the
         * debugger on the server only on the down.
         */
        return fEatDebugKeyBreak;
    }

    /*
     * Don't allow hotkeys (except for ones owned by the logon process) if
     * the window station is locked.
     */
    if (((grpdeskRitInput->rpwinstaParent->dwWSF_Flags & WSF_SWITCHLOCK) != 0) &&
            (PsGetThreadProcessId(phk->pti->pEThread) != gpidLogon)) {
        RIPMSG0(RIP_WARNING, "Ignoring hotkey because Workstation locked");
        return FALSE;
    }

    if (fsModOnlyHotkey == 0 && fBreak) {
        /*
         * Do Modifier-Only hotkeys on break events, else return here.
         */
        return FALSE;
    }

    /*
     * Unhook hooks if a control-escape, alt-escape, or control-alt-del
     * comes through, so the user can cancel if the system seems hung.
     *
     * Note the hook may be locked so even if the unhook succeeds it
     * won't remove the hook from the global asphkStart array.  So
     * we have to walk the list manually.  This code works because
     * we are in the critical section and we know other hooks won't
     * be deleted.
     *
     * Once we've unhooked, post a WM_CANCELJOURNAL message to the app
     * that set the hook so it knows we did this.
     *
     * NOTE: Support for Alt+Esc to cancel journalling dropped in NT 4.0
     */
    fCancel = FALSE;
    if (vk == VK_ESCAPE && (gfsModifiers == MOD_CONTROL)) {
        fCancel = TRUE;
    }

    if (bSAS) {
        fCancel = TRUE;
    }

    if (fCancel) {
        zzzCancelJournalling(); // BUG BUG phk might go away IANJA
    }

    /*
     * See if the key is reserved by a console window.  If it is,
     * return FALSE so the key will be passed to the console.
     */
    if (fsReserveKeys != 0) {
        switch (vk) {
        case VK_TAB:
            if ((fsReserveKeys & CONSOLE_ALTTAB) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        case VK_ESCAPE:
            if ((fsReserveKeys & CONSOLE_ALTESC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            if ((fsReserveKeys & CONSOLE_CTRLESC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_CONTROL)) {
                return FALSE;
            }
            break;
        case VK_RETURN:
            if ((fsReserveKeys & CONSOLE_ALTENTER) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        case VK_SNAPSHOT:
            if ((fsReserveKeys & CONSOLE_PRTSC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == 0)) {
                return FALSE;
            }
            if ((fsReserveKeys & CONSOLE_ALTPRTSC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        case VK_SPACE:
            if ((fsReserveKeys & CONSOLE_ALTSPACE) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        }
    }

    /*
     * If this is the task-list hotkey, go ahead and set foreground
     * status to the task-list queue right now.  This prevents problems
     * where the user hits ctrl-esc and types-ahead before the task-list
     * processes the hotkey and brings up the task-list window.
     */
    if ((gfsModifiers == MOD_CONTROL) && (vk == VK_ESCAPE) && !fBreak) {
        PWND pwndSwitch;
        TL tlpwndSwitch;

        if (ghwndSwitch != NULL) {
            pwndSwitch = PW(ghwndSwitch);
            ThreadLock(pwndSwitch, &tlpwndSwitch);
            xxxSetForegroundWindow2(pwndSwitch, NULL, 0);  // BUG BUG phk might go away IANJA
            ThreadUnlock(&tlpwndSwitch);
        }
    }

    /*
     * Get the hot key contents.
     */
    if (phk->spwnd == NULL) {
        _PostThreadMessage(phk->pti,
                           WM_HOTKEY,
                           phk->id,
                           MAKELONG(gfsModifiers, vk));
        /*
         * Since this hotkey is for this guy, he owns the last input.
         */
        glinp.ptiLastWoken = phk->pti;

    } else {
        if (phk->spwnd == PWND_INPUTOWNER) {
            if (gpqForeground != NULL) {
                pwnd = gpqForeground->spwndFocus;
            } else {
                return FALSE;
            }
        } else {
            pwnd = phk->spwnd;
        }

        if (pwnd) {
            if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndShell && phk->id == SC_TASKLIST) {
PostTaskListSysCmd:
                _PostMessage(pwnd, WM_SYSCOMMAND, SC_TASKLIST, 0);
            } else {
                _PostMessage(pwnd, WM_HOTKEY, phk->id, MAKELONG(gfsModifiers, vk));
            }

            /*
             * Since this hotkey is for this guy, he owns the last input.
             */
            glinp.ptiLastWoken = GETPTI(pwnd);
        }
    }

    /*
     * If this is a Modifier-Only hotkey, let the modifier break through
     * by returning FALSE, otherwise we will have modifier keys stuck down.
     */
    return (fsModOnlyHotkey == 0);
}


/***************************************************************************\
* IsHotKey
*
*
* History:
* 03-10-91 DavidPe      Created.
\***************************************************************************/
PHOTKEY IsHotKey(
    UINT fsModifiers,
    UINT vk)
{
    PHOTKEY phk;

    CheckCritIn();

    phk = HKGetHashHead(vk);
    while (phk != NULL) {
        /*
         * Do the modifiers and vk for this hotkey match the current state?
         */
        if (phk->fsModifiers == fsModifiers && phk->vk == vk) {
            return phk;
        }

        phk = phk->phkNext;
    }

    return phk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\imehotky.c ===
/****************************** Module Header ******************************\
* Module Name: imehotky.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contents:   Manage IME hotkey
*
* There are the following two kind of hotkeys defined in the IME specification.
*
* 1) IME hotkeys that changes the mode/status of current IME
* 2) IME hotkeys that causes IME (keyboard layout) change
*
* History:
* 10-Sep-1995 takaok   Created for NT 3.51.
* 15-Mar-1996 takaok   Ported to NT 4.0
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PIMEHOTKEYOBJ DeleteImeHotKey(PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pDelete);
VOID AddImeHotKey(PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pAdd);
PIMEHOTKEYOBJ FindImeHotKeyByKey(PIMEHOTKEYOBJ pHead, UINT uModifyKeys, UINT uRL, UINT uVKey);
PIMEHOTKEYOBJ FindImeHotKeyByID(PIMEHOTKEYOBJ pHead, DWORD dwHotKeyID);
PIMEHOTKEYOBJ FindImeHotKeyByKeyWithLang(PIMEHOTKEYOBJ pHead, UINT uModifyKeys, UINT uRL, UINT uVKey, LANGID langId);


#define L_CHS   MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)
#define L_JPN   MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)
#define L_KOR   MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT)
#define L_CHT   MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)

enum {
    ILANG_NO_MATCH = 0,         // 0: does not match.
    ILANG_MATCH_SYSTEM,         // 1: matches the system locale
    ILANG_MATCH_THREAD,         // 2: matches the thread locale
    ILANG_MATCH_PERFECT,        // 3: matches the current HKL, or direct KL switching hotkey.
};


// Make sure constants are within the range we expect
#if IME_CHOTKEY_FIRST != 0x10 || IME_JHOTKEY_FIRST != 0x30 || IME_KHOTKEY_FIRST != 0x50 || IME_THOTKEY_FIRST != 0x70
#error unexpected IME_xHOTKEY range !
#endif

LANGID GetHotKeyLangID(DWORD dwHotKeyID)
{
    LANGID langId = -1;
    static CONST LANGID aLangId[] = {
        ~0,             // 0x00 - 0x0f: illegal
        L_CHS, L_CHS,   // 0x10 - 0x2f
        L_JPN, L_JPN,   // 0x30 - 0x4f
        L_KOR, L_KOR,   // 0x50 - 0x6f
        L_CHT, L_CHT,   // 0x70 - 0x8f
    };

    if (dwHotKeyID >= IME_CHOTKEY_FIRST && dwHotKeyID <= IME_THOTKEY_LAST) {
        langId = aLangId[dwHotKeyID >> 4];
    }
    else {
        langId = LANG_NEUTRAL;
    }

    // Because KOR IME does not want IME hot key handling
    UserAssert(langId != L_KOR);

    return langId;
}

BOOL
GetImeHotKey(
    DWORD dwHotKeyID,
    PUINT puModifiers,
    PUINT puVKey,
    HKL   *phKL )
{
    PIMEHOTKEYOBJ ph;

    ph = FindImeHotKeyByID( gpImeHotKeyListHeader, dwHotKeyID );
    if ( ph == NULL ) {
        RIPERR0(ERROR_HOTKEY_NOT_REGISTERED, RIP_VERBOSE, "No such IME hotkey");
        return (FALSE);
    }

    //
    // it is OK for NULL phKL, if the target hKL is NULL
    //
    if ( phKL ) {
       *phKL = ph->hk.hKL;
    } else if ( ph->hk.hKL != NULL ) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "phKL is null");
        return (FALSE);
    }

    *puModifiers = ph->hk.uModifiers;
    *puVKey = ph->hk.uVKey;

    return (TRUE);
}

//
// Insert/remove the specified IME hotkey into/from
// the IME hotkey list (gpImeHotKeyListHeader).
//
BOOL
SetImeHotKey(
    DWORD  dwHotKeyID,
    UINT   uModifiers,
    UINT   uVKey,
    HKL    hKL,
    DWORD  dwAction )
{
    PIMEHOTKEYOBJ ph;

    switch ( dwAction ) {
    case ISHK_REMOVE:
        ph = FindImeHotKeyByID( gpImeHotKeyListHeader, dwHotKeyID );
        if ( ph != NULL ) {
            if ( DeleteImeHotKey( &gpImeHotKeyListHeader, ph ) == ph ) {
                UserFreePool( ph );
                return ( TRUE );
            } else {
                RIPMSG0( RIP_ERROR, "IME hotkey list is messed up" );
                return FALSE;
            }
        } else {
            RIPERR0( ERROR_INVALID_PARAMETER,
                     RIP_WARNING,
                     "no such IME hotkey registered");
            return FALSE;
        }
        break;

    case ISHK_INITIALIZE:
        ph = gpImeHotKeyListHeader;
        while ( ph != NULL ) {
            PIMEHOTKEYOBJ phNext;

            phNext = ph->pNext;
            UserFreePool( ph );
            ph = phNext;
        }
        gpImeHotKeyListHeader = NULL;
        return TRUE;

    case ISHK_ADD:
        if (dwHotKeyID >= IME_KHOTKEY_FIRST && dwHotKeyID <= IME_KHOTKEY_LAST) {
            // Korean IME does not want any IMM hotkey handling.
            // We should not register any Korean IME hot keys.
            return FALSE;
        }

        if ((WORD)uVKey == VK_PACKET) {
            //
            // VK_PACKET should not be a IME hot key.
            //
            return FALSE;
        }

        ph = FindImeHotKeyByKeyWithLang(gpImeHotKeyListHeader,
                                uModifiers & MOD_MODIFY_KEYS,
                                uModifiers & MOD_BOTH_SIDES,
                                uVKey,
                                GetHotKeyLangID(dwHotKeyID));
        if ( ph != NULL ) {
            if ( ph->hk.dwHotKeyID != dwHotKeyID ) {
                RIPERR0( ERROR_HOTKEY_ALREADY_REGISTERED,
                         RIP_WARNING,
                         "There is an IME hotkey that has the same vkey/modifiers/Lang Id");
                return FALSE;
            }
            // So far we found a hotkey that has the
            // same vkey and same ID.
            // But because modifiers may be slightly
            // different, so go ahead and change it.
        } else {
            //
            // the specified vkey/modifiers combination cound not be found
            // in the hotkey list. The caller may want to change the key
            // assignment of an existing hotkey or add a new hotkey.
            //
            ph = FindImeHotKeyByID( gpImeHotKeyListHeader, dwHotKeyID );
        }

        if ( ph == NULL ) {
        //
        // adding a new hotkey
        //
            ph = (PIMEHOTKEYOBJ)UserAllocPool( sizeof(IMEHOTKEYOBJ), TAG_IMEHOTKEY );
            if ( ph == NULL ) {
                RIPERR0( ERROR_OUTOFMEMORY,
                         RIP_WARNING,
                        "Memory allocation failed in SetImeHotKey");
                return FALSE;
            }
            ph->hk.dwHotKeyID = dwHotKeyID;
            ph->hk.uModifiers = uModifiers;
            ph->hk.uVKey = uVKey;
            ph->hk.hKL = hKL;
            ph->pNext = NULL;
            AddImeHotKey( &gpImeHotKeyListHeader, ph );

        } else {
        //
        // changing an existing hotkey
        //
            ph->hk.uModifiers = uModifiers;
            ph->hk.uVKey = uVKey;
            ph->hk.hKL = hKL;

        }
        return TRUE;
    }

    return FALSE;
}


PIMEHOTKEYOBJ DeleteImeHotKey( PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pDelete )
{
    PIMEHOTKEYOBJ ph;

    if ( pDelete == *ppHead ) {
        *ppHead = pDelete->pNext;
        return pDelete;
    }

    for ( ph = *ppHead; ph != NULL; ph = ph->pNext ) {
        if ( ph->pNext == pDelete ) {
            ph->pNext = pDelete->pNext;
            return pDelete;
        }
    }
    return NULL;
}

VOID AddImeHotKey( PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pAdd )
{
    PIMEHOTKEYOBJ ph;

    if ( *ppHead == NULL ) {
        *ppHead = pAdd;
    } else {
        ph = *ppHead;
        while( ph->pNext != NULL )
            ph = ph->pNext;
        ph->pNext = pAdd;
    }
    return;
}

VOID FreeImeHotKeys(VOID)
{
    PIMEHOTKEYOBJ phk;

    while (gpImeHotKeyListHeader != NULL) {
        phk = gpImeHotKeyListHeader->pNext;
        UserFreePool(gpImeHotKeyListHeader);
        gpImeHotKeyListHeader = phk;
    }
}


LCID glcidSystem;

int GetLangIdMatchLevel(HKL hkl, LANGID langId)
{

    if (langId == LANG_NEUTRAL) {
        //
        // If langId is LANG_NEUTRAL, the hot key does not depend on
        // the current HKL. Make it perfect match always.
        //
        return ILANG_MATCH_PERFECT;
    }

    {
        LCID lcid;
#ifdef CUAS_ENABLE
        PTHREADINFO ptiCurrent = PtiCurrent();
        BOOL bMSCTF = FALSE;

        try {
            bMSCTF = ((ptiCurrent->pClientInfo->CI_flags & CI_CUAS_MSCTF_RUNNING) != 0);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }

        if (bMSCTF && !IS_IME_KBDLAYOUT(hkl)) {

            return ILANG_NO_MATCH;
        }
#endif // CUAS_ENABLE

        if (LOWORD(HandleToUlong(hkl)) == langId) {
            // langId matches the current KL locale
            return ILANG_MATCH_PERFECT;
        }

        try {
            lcid = NtCurrentTeb()->CurrentLocale;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              lcid = LOCALE_NEUTRAL;
        }

        if (LANGIDFROMLCID(lcid) == langId) {
            // langId matches the current thread's locale
            return ILANG_MATCH_THREAD;
        }

        if (glcidSystem == 0) {
            // If we've not got system default locale yet, get it here.
            ZwQueryDefaultLocale(FALSE, &glcidSystem);
        }
        if (LANGIDFROMLCID(glcidSystem) == langId) {
            // langId matches the system locale.
            return ILANG_MATCH_SYSTEM;
        }
    }

    return ILANG_NO_MATCH;
}

////////////////////////////////////////////////////////////////////////
// FindImeHotKeyByKey()
// Return Value:
//      pHotKey - IMEHOTKEY pointer with the key,
//      else NULL - failure
//
// Finds the best matching of IME hot keys considering the current
// input locale.
//
////////////////////////////////////////////////////////////////////////

PIMEHOTKEYOBJ FindImeHotKeyByKey(   // Finds pHotKey with this input key
    PIMEHOTKEYOBJ pHead,
    UINT uModifyKeys,               // the modify keys of this input key
    UINT uRL,                       // the right and left hand side
    UINT uVKey)                     // the input key
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PIMEHOTKEYOBJ phResult = NULL;
    PIMEHOTKEYOBJ ph;
    HKL hkl = GetActiveHKL();
    WORD langPrimary = PRIMARYLANGID(LOWORD(HandleToUlong(hkl)));
    int iLevel = ILANG_NO_MATCH;

    for (ph = pHead; ph != NULL; ph = ph->pNext) {

        if (ph->hk.uVKey == uVKey) {
            BOOL fDoCheck = FALSE;

            // Check if the modifiers match
            if ((ph->hk.uModifiers & MOD_IGNORE_ALL_MODIFIER)) {
                fDoCheck = TRUE;
            } else if ((ph->hk.uModifiers & MOD_MODIFY_KEYS) != uModifyKeys) {
                continue;
            }

            if ((ph->hk.uModifiers & MOD_BOTH_SIDES) == uRL ||
                    (ph->hk.uModifiers & MOD_BOTH_SIDES) & uRL) {
                fDoCheck = TRUE;
            }

            if (fDoCheck) {
                LANGID langId = GetHotKeyLangID(ph->hk.dwHotKeyID);
                int iMatch = GetLangIdMatchLevel(hkl, langId);

#if 0   // Test only
                if (iMatch != ILANG_NO_MATCH) {
                    DbgPrint("GetIdMatchLevel(%X, %X)=%d\n", hkl, langId);
                }
#endif

                if (iMatch == ILANG_MATCH_PERFECT) {
                    // Perfect match !
                    return ph;
                }

                // If the hotkey is DSWITCH, GetLangIdMatchLevel() must return 3.
                UserAssert(ph->hk.dwHotKeyID < IME_HOTKEY_DSWITCH_FIRST ||
                           ph->hk.dwHotKeyID > IME_HOTKEY_DSWITCH_LAST);

                if (langPrimary == LANG_KOREAN) {
                    // Korean IME wants no hotkeys except the direct
                    // keyboard layout switching hotkeys.
                    continue;
                }

                if (iMatch == ILANG_NO_MATCH) {
                    // Special case for CHT/CHS toggle
                    if (ph->hk.dwHotKeyID == IME_CHOTKEY_IME_NONIME_TOGGLE ||
                            ph->hk.dwHotKeyID == IME_THOTKEY_IME_NONIME_TOGGLE) {
                        //
                        // If the key is for CHT/CHS toggle and the previous
                        // hkl is either CHT/CHS, it is a IME hotkey.
                        //
                        if (LOWORD(HandleToUlong(ptiCurrent->hklPrev)) == langId) {
#if 0   // Test only
                            DbgPrint("FindImeHotKeyByKey() found CHT/CHS hotkey.\n");
#endif
                            return ph;
                        }
                    }
                }
                else if (iMatch > iLevel) {
                    // Current ph is the strongest candidate so far.
                    iLevel = iMatch;
                    phResult = ph;
                }
            }
        }
    }

    return phResult;
}

/**********************************************************************/
/* FindImeHotKeyByID()                                                */
/* Return Value:                                                      */
/*      pHotKey   - IMEHOTKEY pointer with the dwHotKeyID,            */
/*      else NULL - failure                                           */
/**********************************************************************/
PIMEHOTKEYOBJ FindImeHotKeyByID( PIMEHOTKEYOBJ pHead, DWORD dwHotKeyID )
{
    PIMEHOTKEYOBJ ph;

    for ( ph = pHead; ph != NULL; ph = ph->pNext ) {
        if ( ph->hk.dwHotKeyID == dwHotKeyID )
                return (ph);
    }
    return (PIMEHOTKEYOBJ)NULL;
}

/**********************************************************************/
/* FindImeHotKeyByKeyWithLang()                                       */
/* Return Value:                                                      */
/*      pHotKey - IMEHOTKEY pointer with the key,                     */
/*      else NULL - failure                                           */
/**********************************************************************/
PIMEHOTKEYOBJ FindImeHotKeyByKeyWithLang(      // Finds pHotKey with this input key
    PIMEHOTKEYOBJ pHead,
    UINT uModifyKeys,               // the modify keys of this input key
    UINT uRL,                       // the right and left hand side
    UINT uVKey,                     // the input key
    LANGID langIdKey)               // the language id
{
    PIMEHOTKEYOBJ ph;

    for (ph = pHead; ph != NULL; ph = ph->pNext) {

        if (ph->hk.uVKey == uVKey) {
            BOOL fDoCheck = FALSE;

            // Check if the modifiers match
            if ((ph->hk.uModifiers & MOD_IGNORE_ALL_MODIFIER)) {
                fDoCheck = TRUE;
            } else if ((ph->hk.uModifiers & MOD_MODIFY_KEYS) != uModifyKeys) {
                continue;
            }

            if ((ph->hk.uModifiers & MOD_BOTH_SIDES) == uRL ||
                    (ph->hk.uModifiers & MOD_BOTH_SIDES) & uRL) {
                fDoCheck = TRUE;
            }

            if (fDoCheck) {
                LANGID langId = GetHotKeyLangID(ph->hk.dwHotKeyID);

                if (langIdKey == langId || langId == LANG_NEUTRAL) {
                    return ph;
                }
            }
        }
    }

    return NULL;
}

PIMEHOTKEYOBJ
CheckImeHotKey(
    PQ   pq,            // input queue
    UINT uVKey,         // virtual key
    LPARAM lParam       // lparam of WM_KEYxxx message
    )
{
    static UINT uVKeySaved = 0;
    PIMEHOTKEYOBJ ph;
    UINT uModifiers = 0;
    BOOL fKeyUp;

    //
    // early return for key up message
    //
    fKeyUp = ( lParam & 0x80000000 ) ? TRUE : FALSE;
    if ( fKeyUp ) {
        //
        // if the uVKey is not same as the vkey
        // we previously saved, there is no chance
        // that this is a hotkey.
        //
        if ( uVKeySaved != uVKey ) {
            uVKeySaved = 0;
            return NULL;
        }
        uVKeySaved = 0;
        //
        // If it's same, we still need to check
        // the hotkey list because there is a
        // chance that the hotkey list is modified
        // between the key make and break.
        //
    }

    //
    // Current specification doesn't allow us to use a complex
    // hotkey such as LSHIFT+RMENU+SPACE
    //

    //
    // Setup the shift, control, alt key states
    //
    uModifiers |= TestKeyStateDown(pq, VK_LSHIFT) ? (MOD_SHIFT | MOD_LEFT) : 0;
    uModifiers |= TestKeyStateDown(pq, VK_RSHIFT) ? (MOD_SHIFT | MOD_RIGHT) : 0;

    uModifiers |= TestKeyStateDown(pq, VK_LCONTROL) ? (MOD_CONTROL | MOD_LEFT) : 0;
    uModifiers |= TestKeyStateDown(pq, VK_RCONTROL) ? (MOD_CONTROL | MOD_RIGHT) : 0;

    uModifiers |= TestKeyStateDown(pq, VK_LMENU) ? (MOD_ALT | MOD_LEFT) : 0;
    uModifiers |= TestKeyStateDown(pq, VK_RMENU) ? (MOD_ALT | MOD_RIGHT) : 0;

    ph = FindImeHotKeyByKey( gpImeHotKeyListHeader,
                             uModifiers & MOD_MODIFY_KEYS,
                             uModifiers & MOD_BOTH_SIDES,
                             uVKey );

    if ( ph != NULL ) {
        if ( fKeyUp ) {
            if ( ph->hk.uModifiers & MOD_ON_KEYUP ) {
                return ph;
            }
        } else {
            if ( ph->hk.uModifiers & MOD_ON_KEYUP ) {
            //
            // save vkey for next keyup message time
            //
            // when ALT+Z is a hotkey, we don't want
            // to handle #2 as the hotkey sequence.
            // 1) ALT make -> 'Z' make -> 'Z' break
            // 2) 'Z' make -> ALT make -> 'Z' break
            //
                uVKeySaved = uVKey;
            } else {
                return ph;
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\hungapp.c ===
/****************************** Module Header ******************************\
* Module Name: hungapp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
* History:
* 03-10-92 DavidPe      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* SetHungFlag
*
* Sets the specified redraw-if-hung flag in the window and adds the
* window to the list of windows to redraw if hung.
* Windows that are not top-level get the bit set, but aren't added to the list
*
* 08-23-93  JimA        Created.
\***************************************************************************/
#define CHRLINCR 10

VOID SetHungFlag(
    PWND pwnd,
    WORD wFlag)
{
    /*
     * If the window has no hung redraw bits set and it's a top-level
     * window, add it to the redraw list.
     */
    if (!TestWF(pwnd, WFANYHUNGREDRAW) && pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        /*
         * Add pwnd to the Hung Redraw Volatile Window Pointer List.
         */
        VWPLAdd(&gpvwplHungRedraw, pwnd, CHRLINCR);
    }

    SetWF(pwnd, wFlag);
}


/***************************************************************************\
* ClearHungFlag
*
* Clears the specified redraw-if-hung flag in the window and if no other
* redraw-if-hung flags remain, remove the window from list of windows
* to be redrawn if hung.
* Many windows have WFREDRAW* bits set, but aren't in the list (only those
* that were top-level were added).
*
* 08-23-93  JimA        Created.
\***************************************************************************/

VOID ClearHungFlag(
    PWND pwnd,
    WORD wFlag)
{
    BOOL fInRedrawList = TestWF(pwnd, WFANYHUNGREDRAW);

    ClrWF(pwnd, wFlag);
    if (!TestWF(pwnd, WFANYHUNGREDRAW) && fInRedrawList) {
        /*
         * Remove the window from the redraw list and possibly compact it.
         */
        VWPLRemove(&gpvwplHungRedraw, pwnd);
    }
}


/***************************************************************************\
* FHungApp
*
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/

BOOL FHungApp(
    PTHREADINFO pti,
    DWORD dwTimeFromLastRead)
{

    /*
     * An app is considered hung if it isn't waiting for input, isn't in
     * startup processing, and hasn't called PeekMessage() within the
     * specified timeout.
     */
    if (((NtGetTickCount() - GET_TIME_LAST_READ(pti)) > dwTimeFromLastRead) &&
            !((pti->pcti->fsWakeMask & QS_INPUT) && (PsGetThreadFreezeCount(pti->pEThread) == 0)) &&
            !(pti->ppi->W32PF_Flags & W32PF_APPSTARTING)) {
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* xxxRedrawHungWindowFrame
*
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/
VOID xxxRedrawHungWindowFrame(
    PWND pwnd,
    BOOL fActive)
{
    HDC hdc;
    UINT wFlags = DC_NC | DC_NOSENDMSG;

    CheckLock(pwnd);

#ifdef HUNGAPP_GHOSTING
        ClearHungFlag(pwnd, WFREDRAWFRAMEIFHUNG);
        SignalGhost(pwnd);
        return;
#endif // HUNGAPP_GHOSTING

    if (IsInsideUserApiHook()) {
        return;
    }

    if (fActive) {
        wFlags |= DC_ACTIVE;
    }

    hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW);
    xxxDrawCaptionBar(pwnd, hdc, wFlags);
    _ReleaseDC(hdc);
}


/***************************************************************************\
* xxxRedrawHungWindow
*
* If the hrgnFullDrag is NULL, redraw the hung window's entire update
* region, otherwise, only redraw the intersection of the window's update
* region with the FullDrag region.
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/
VOID xxxRedrawHungWindow(
    PWND pwnd,
    HRGN hrgnFullDrag)
{
    HDC     hdc;
    HBRUSH  hbr;
    HRGN    hrgnUpdate;
    RECT    rc;
    TL tlpwnd;
    UINT    flags;
    W32PID  sid;
    DWORD   dwColor;
    PWND    pwndDesk;
    TL      tlpwndDesk;

    CheckCritIn();
    CheckLock(pwnd);

    if (pwnd->hrgnUpdate == NULL) {
        return;
    }

#ifdef HUNGAPP_GHOSTING

    /*
     * Don't bother doing anything here when the window isn't even visible.
     */
    if (!TestWF(pwnd, WFVISIBLE)) {
        return;
    }

    /*
     * This function can be called from the full-drag code to quick redraw
     * windows that aren't hung. In that case check if that thread is hung.
     */
    if ((hrgnFullDrag == NULL) || (hrgnFullDrag != NULL &&
            FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT))) {
        SignalGhost(pwnd);
        return;
    }
    UserAssert(gptiCurrent != gptiRit);
#endif

    /*
     * First calculate hrgnUpdate.
     */
    if (pwnd->hrgnUpdate > HRGN_FULL) {
        hrgnUpdate = CreateEmptyRgn();
        if (hrgnUpdate == NULL) {
            hrgnUpdate = HRGN_FULL;

        } else if (CopyRgn(hrgnUpdate, pwnd->hrgnUpdate) == ERROR) {
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = HRGN_FULL;
        }

    } else {

        /*
         * For our purposes, we need a real hrgnUpdate, so try and
         * create one if even if the entire window needs updating.
         */
        CopyRect(&rc, &pwnd->rcWindow);
        hrgnUpdate = GreCreateRectRgnIndirect(&rc);
        if (hrgnUpdate == NULL) {
            hrgnUpdate = HRGN_FULL;
        }
    }


    /*
     * If we're redrawing because we're full dragging and if the window's
     * update region does not intersect with the Full drag
     * update region, don't erase the hung window again. This is to prevent
     * flickering when a window has been invalidated by another window doing
     * full drag and hasn't received the paint message yet.
     * This way, only if there is a new region that has been invalidated will
     * we redraw the hung window.
     */
    if (hrgnFullDrag && hrgnUpdate != HRGN_FULL &&
            IntersectRgn(hrgnUpdate, hrgnUpdate, hrgnFullDrag) == NULLREGION) {
        GreDeleteObject(hrgnUpdate);
        return;
    }

    ThreadLock(pwnd, &tlpwnd);

    if (IsInsideUserApiHook()) {
        xxxInternalInvalidate(pwnd, hrgnUpdate, RDW_INVALIDATE |
                RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
    } else {
        hdc = _GetDCEx(pwnd, hrgnUpdate, DCX_USESTYLE | DCX_WINDOW |
                DCX_INTERSECTRGN | DCX_NODELETERGN | DCX_LOCKWINDOWUPDATE);
        xxxDrawWindowFrame(pwnd, hdc, DF_HUNGREDRAW | (TestwndFrameOn(pwnd) ? DF_ACTIVE : 0L));
        _ReleaseDC(hdc);
    }

    CopyRect(&rc, &pwnd->rcWindow);
    xxxCalcClientRect(pwnd, &rc, TRUE);
    SetRectRgnIndirect(ghrgnInv2, &rc);

    if (hrgnUpdate > HRGN_FULL) {
        switch (IntersectRgn(hrgnUpdate, hrgnUpdate, ghrgnInv2)) {

        case ERROR:
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = HRGN_FULL;
            break;

        case NULLREGION:
            /*
             * There is nothing in the client area to repaint.
             * Blow the region away, and decrement the paint count
             * if possible.
             */
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = NULL;
            break;
        }
    }

    /*
     * Erase the rest of the window.
     * When pwnd isn't WFCLIPCHILDREN, make sure valid children bits
     * don't get overwritten if the child is in the middle of BeginPaint
     * or just completed it's painting and it's hrgnUpdate is NULL.
     */
    if (hrgnUpdate != NULL && !TestWF(pwnd, WFCLIPCHILDREN)) {
        RECT rcT;
        PWND pwndT;

        if (hrgnUpdate == HRGN_FULL) {
            rc = pwnd->rcWindow;
        } else {
            GreGetRgnBox(hrgnUpdate, &rc);
        }

        for (pwndT = pwnd->spwndChild; pwndT != NULL;
                pwndT = pwndT->spwndNext) {

            if (TestWF(pwndT, WFVISIBLE) &&
                    (TestWF(pwndT, WFSTARTPAINT) || pwndT->hrgnUpdate == NULL) &&
                    IntersectRect(&rcT, &rc, &pwndT->rcWindow)) {

                /*
                 * This invalidate call won't leave the critial section. In
                 * reality the entire xxxRedrawHungWindow must not leave
                 * the critical section.
                 */
                BEGINATOMICCHECK();
                xxxInternalInvalidate(pwndT, hrgnUpdate, RDW_INVALIDATE |
                        RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
                ENDATOMICCHECK();
            }
        }
    }

    /*
     * Get a window dc so that the menu and scroll bar areas are erased
     * appropriately. But make sure it is clipped so that the children
     * get clipped out correctly! If we don't do this, this we could erase
     * children that aren't invalid.
     *
     * Note: DCX_WINDOW and DCX_USESTYLE will never clip out children.
     * Need to pass the clipping styles in directly, instead of passing
     * DCX_USESTYLE.
     */
    flags = DCX_INTERSECTRGN | DCX_WINDOW | DCX_CACHE;
    if (TestWF(pwnd, WFCLIPSIBLINGS))
        flags |= DCX_CLIPSIBLINGS;
    if (TestWF(pwnd, WFCLIPCHILDREN))
        flags |= DCX_CLIPCHILDREN;

    hdc = _GetDCEx(pwnd, hrgnUpdate, flags);

    if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndBkGnd) {
        pwndDesk = PWNDDESKTOP(pwnd);
        ThreadLock(pwndDesk, &tlpwndDesk);
        xxxInternalPaintDesktop(PWNDDESKTOP(pwnd), hdc, TRUE);
        ThreadUnlock(&tlpwndDesk);
    } else {
         rc = pwnd->rcWindow;

         OffsetRect(&rc, -pwnd->rcWindow.left, -pwnd->rcWindow.top);

         /*
          * Erase the rest of the window using the window's class background
          * brush.
          */
         if ((hbr = pwnd->pcls->hbrBackground) != NULL) {
             if (hbr <= (HBRUSH)COLOR_ENDCOLORS + 1) {
                 hbr = SYSHBRUSH((ULONG_PTR)hbr - 1);
             }
         } else {
             /*
              * Use the window brush for windows and 3.x dialogs, and use
              * the COLOR3D brush for 4.x dialogs.
              */
             if (TestWF(pwnd, WFDIALOGWINDOW) && TestWF(pwnd, WFWIN40COMPAT)) {
                 hbr = SYSHBR(3DFACE);
             } else {
                 hbr = SYSHBR(WINDOW);
             }
         }

        /*
         * If the window's class background brush is public, use it.
         */
        sid = (W32PID)GreGetObjectOwner((HOBJ)hbr, BRUSH_TYPE);
        if (sid == OBJECT_OWNER_PUBLIC ||
            sid == (W32PID)(ULONG_PTR)PsGetCurrentProcessId()) {

            FillRect(hdc, &rc, hbr);
        } else {
            /*
             * The window's class background brush is not public.
             *
             * We get its color and set the color of our own public brush
             * and use that for the background brush.
             */

            /*
             * If the window is a console window, get the console background brush.
             * This brush will be different than the console class brush if the user
             * changed the console background color.
             */
            if (gatomConsoleClass == pwnd->pcls->atomClassName) {
                dwColor = _GetWindowLong(pwnd, GWL_CONSOLE_BKCOLOR);
            } else {
                if ((dwColor = GreGetBrushColor(hbr)) == -1) {
                    dwColor = GreGetBrushColor(SYSHBR(WINDOW));
                }
            }

            GreSetSolidBrush(ghbrHungApp, dwColor);

            FillRect(hdc, &rc, ghbrHungApp);
        }
    }
    _ReleaseDC(hdc);

    /*
     * The window has been erased and framed. It only did this because the
     * app hasn't done it yet:
     *
     * - the app hasn't erased and frame yet.
     * - the app is in the middle of erasing and framing.
     *
     * The app could not of completed erasing and framing, because the
     * WFREDRAWIFHUNG bit is cleared when this successfully completes.
     *
     * Given that the app may be in the middle of erasing and framing, we
     * need to set both the erase and frame bits *again* so it erasing and
     * frames over again (if we don't, it never will). If the app hasn't
     * done any erasing/framing yet, this is a nop.
     */
    SetWF(pwnd, WFSENDNCPAINT);
    SetWF(pwnd, WFSENDERASEBKGND);

    /*
     * Always set WFUPDATEDIRTY: we don't want the app to draw, then stop
     * and have the hung app thread draw, and then allow the app to validate
     * itself: Mark the update region dirty - cannot be validated until the
     * app calls a painting function and acknowledges the update region.
     */
    SetWF(pwnd, WFUPDATEDIRTY);

    ThreadUnlock(&tlpwnd);
}


/***************************************************************************\
* xxxHungAppDemon
*
* NOTE: RIT timers (like this one) get called while inside the critical
* section.
*
* We keep a list of redraw-if-hung windows in a list that remains in a
* single page to avoid touching the windows themselves each time through
* this routine. Touching the windows causes a bunch of unnecessary paging
* and in effect keeps all of the pages that contain top-level windows
* resident at all times; this is very wasteful.
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/
VOID xxxHungAppDemon(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    TL tlpwnd;
    DWORD nPwndHungRedraw;
    PWND pwndHungRedraw;

    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(pwnd);

    CheckLock(pwnd);

    /*
     * See if we should start the screen saver.
     */
    IdleTimerProc();

    /*
     * If it is time to hide the app starting cursor, do it.
     */
    if (NtGetTickCount() >= gtimeStartCursorHide) {
        /*
         * No need to DeferWinEventNotify()
         */
        zzzCalcStartCursorHide(NULL, 0);
    }

    /*
     * Now check to see if there are any top-level windows that need
     * redrawing.
     */
    if (grpdeskRitInput == NULL || grpdeskRitInput->pDeskInfo->spwnd == NULL) {
        return;
    }

    /*
     * Walk down the list of redraw-if-hung windows. Loop until we hit the
     * end of the array or find a NULL.
     */
    nPwndHungRedraw = 0;
    pwndHungRedraw = NULL;
    while (pwndHungRedraw = VWPLNext(gpvwplHungRedraw, pwndHungRedraw, &nPwndHungRedraw)) {
        /*
         * See if the app is hung. If so, do the appropriate redrawing.
         */
        if (FHungApp(GETPTI(pwndHungRedraw), CMSHUNGAPPTIMEOUT)) {
            ThreadLock(pwndHungRedraw, &tlpwnd);
            if (TestWF(pwndHungRedraw, WFREDRAWFRAMEIFHUNG)) {
                /*
                 * WFREDRAWFRAMEIFHUNG will be cleared in the process of
                 * drawing the frame, so no need to clear it here.
                 */
                xxxRedrawHungWindowFrame(pwndHungRedraw,
                                         TestwndFrameOn(pwndHungRedraw));
            }

            if (TestWF(pwndHungRedraw, WFREDRAWIFHUNG)) {
                ClearHungFlag(pwndHungRedraw, WFREDRAWIFHUNG);
                xxxRedrawHungWindow(pwndHungRedraw, NULL);
            }

            ThreadUnlock(&tlpwnd);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\init.c ===
/****************************** Module Header ******************************\
* Module Name: init.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the init code for win32k.sys.
*
* History:
* 18-Sep-1990 DarrinM   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if DBG
LIST_ENTRY gDesktopList;
#endif

PVOID gpCountTable;

//
// External references
//
extern PVOID *apObjects;


extern PKWAIT_BLOCK gWaitBlockArray;
extern PVOID UserAtomTableHandle;
extern PKTIMER gptmrWD;

extern UNICODE_STRING* gpastrSetupExe;
extern WCHAR* glpSetupPrograms;

extern PHANDLEPAGE gpHandlePages;

extern PBWL pbwlCache;

//
// Forward references
//

#if DBG
VOID InitGlobalThreadLockArray(
    DWORD dwIndex);
#endif

VOID CheckLUIDDosDevicesEnabled(
    PBOOL result);

/*
 * Local Constants.
 */
#define GRAY_STRLEN         40

/*
 * Globals local to this file only.
 */
BOOL bPermanentFontsLoaded;

/*
 * Globals shared with W32
 */
CONST ULONG W32ProcessSize = sizeof(PROCESSINFO);
CONST ULONG W32ProcessTag = TAG_PROCESSINFO;
CONST ULONG W32ThreadSize = sizeof(THREADINFO);
CONST ULONG W32ThreadTag = TAG_THREADINFO;
PFAST_MUTEX gpW32FastMutex;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);

#pragma alloc_text(INIT, DriverEntry)

NTSTATUS Win32UserInitialize(VOID);

#if defined(_X86_)
ULONG Win32UserProbeAddress;
#endif

/*
 * holds the result of "Are LUID DosDevices maps enabled?"
 * TRUE  - LUID DosDevices are enabled
 * FALSE - LUID DosDevices are not enabled
 */
ULONG gLUIDDeviceMapsEnabled;

VOID FreeSMS(PSMS psms);
VOID FreeImeHotKeys(VOID);

extern PPAGED_LOOKASIDE_LIST SMSLookaside;
extern PPAGED_LOOKASIDE_LIST QEntryLookaside;

/*
 * Max time is 10 minutes. The count is 10 min * 60 sec * 4 for 250 ms.
 */
#define MAX_TIME_OUT  (10 * 60 * 4)

/***************************************************************************\
* Win32kNtUserCleanup
*
* History:
* 5-Jan-1997 CLupu   Created.
\***************************************************************************/
BOOL Win32kNtUserCleanup(
    VOID)
{
    int i;

    TRACE_HYDAPI(("Win32kNtUserCleanup: Cleanup Resources\n"));

    if (gpresUser != NULL) {
        EnterCrit();
    }

    DbgDumpTrackedDesktops(TRUE);

    /*
     * Anything in this list must be cleaned up when threads go away.
     */
    UserAssert(gpbwlList == NULL);
    UserAssert(gpWinEventHooks == NULL);
    UserAssert(gpScancodeMap == NULL);

    /*
     * Free IME hotkeys.
     */
    FreeImeHotKeys();

    /*
     * Free the wallpaper name string.
     */
    if (gpszWall != NULL) {
        UserFreePool(gpszWall);
        gpszWall = NULL;
    }

    /*
     * Free the hung redraw stuff.
     */
    if (gpvwplHungRedraw != NULL) {
        UserFreePool(gpvwplHungRedraw);
        gpvwplHungRedraw = NULL;
    }

    /*
     * Free the arrary of setup app names.
     */
    if (gpastrSetupExe) {
        UserFreePool(gpastrSetupExe);
        gpastrSetupExe = NULL;
    }

    if (glpSetupPrograms) {
        UserFreePool(glpSetupPrograms);
        glpSetupPrograms = NULL;
    }

    /*
     * Free the cached window list.
     */
    if (pbwlCache != NULL) {
        UserFreePool(pbwlCache);
        pbwlCache = NULL;
    }


    /*
     * Free outstanding timers.
     */
    while (gptmrFirst != NULL) {
        FreeTimer(gptmrFirst);
    }

    if (gptmrWD) {
        KeCancelTimer(gptmrWD);
        UserFreePool(gptmrWD);
        gptmrWD = NULL;
    }

    if (gptmrMaster) {
        KeCancelTimer(gptmrMaster);
        UserFreePool(gptmrMaster);
        gptmrMaster = NULL;
    }

    /*
     * Cleanup monitors and windows layout  snapshots
     */
    CleanupMonitorsAndWindowsSnapShot();

    /*
     * Cleanup PnP input device synchronization event.
     */
    if (gpEventPnPWainting != NULL) {
        FreeKernelEvent(&gpEventPnPWainting);
    }

    /*
     * Cleanup mouse & kbd change events
     */
    for (i = 0; i <= DEVICE_TYPE_MAX; i++) {
        UserAssert(gptiRit == NULL);
        if (aDeviceTemplate[i].pkeHidChange) {
            FreeKernelEvent(&aDeviceTemplate[i].pkeHidChange);
        }
    }

    /*
     * Cleanup any system thread parameters.
     */
    CSTCleanupStack(FALSE);
    CSTCleanupStack(TRUE);


    EnterDeviceInfoListCrit();

#ifdef GENERIC_INPUT
    CleanupHidRequestList();
#endif

    while (gpDeviceInfoList) {
        /*
         * Assert that there is no outstanding read or PnP thread waiting
         * in RequestDeviceChanges() for this device.
         * Clear these flags anyway, to force the free.
         */
        UserAssert((gpDeviceInfoList->bFlags & GDIF_READING) == 0);
        UserAssert((gpDeviceInfoList->usActions & GDIAF_PNPWAITING) == 0);
        gpDeviceInfoList->bFlags &= ~GDIF_READING;
        gpDeviceInfoList->usActions &= ~GDIAF_PNPWAITING;
        FreeDeviceInfo(gpDeviceInfoList);
    }

#ifdef TRACK_PNP_NOTIFICATION
    CleanupPnpNotificationRecord();
#endif

    LeaveDeviceInfoListCrit();

    /*
     * Cleanup object references
     */
    if (gThinwireFileObject)
        ObDereferenceObject(gThinwireFileObject);

    if (gVideoFileObject)
        ObDereferenceObject(gVideoFileObject);

    if (gpRemoteBeepDevice)
        ObDereferenceObject(gpRemoteBeepDevice);

    /*
     * Cleanup our resources. There should be no threads in here
     * when we get called.
     */
    if (gpresMouseEventQueue) {
        ExDeleteResourceLite(gpresMouseEventQueue);
        ExFreePool(gpresMouseEventQueue);
        gpresMouseEventQueue = NULL;
    }

    if (gpresDeviceInfoList) {
        ExDeleteResourceLite(gpresDeviceInfoList);
        ExFreePool(gpresDeviceInfoList);
        gpresDeviceInfoList = NULL;
    }

    if (gpkeMouseData != NULL) {
        FreeKernelEvent(&gpkeMouseData);
    }

    if (apObjects) {
        UserFreePool(apObjects);
        apObjects = NULL;
    }

    if (gWaitBlockArray) {
        UserFreePool(gWaitBlockArray);
        gWaitBlockArray = NULL;
    }

    if (gpEventDiconnectDesktop != NULL) {
        FreeKernelEvent(&gpEventDiconnectDesktop);
    }

    if (gpevtDesktopDestroyed != NULL) {
        FreeKernelEvent(&gpevtDesktopDestroyed);
    }

    if (gpEventScanGhosts != NULL) {
        FreeKernelEvent(&gpEventScanGhosts);
    }

    if (gpevtVideoportCallout != NULL) {
        FreeKernelEvent(&gpevtVideoportCallout);
    }

    if (UserAtomTableHandle != NULL) {
        RtlDestroyAtomTable(UserAtomTableHandle);
        UserAtomTableHandle = NULL;
    }

    /*
     * cleanup the SMS lookaside buffer
     */
    {
        PSMS psmsNext;

        while (gpsmsList != NULL) {
            psmsNext = gpsmsList->psmsNext;
            UserAssert(gpsmsList->spwnd == NULL);
            FreeSMS(gpsmsList);
            gpsmsList = psmsNext;
        }

        if (SMSLookaside != NULL) {
            ExDeletePagedLookasideList(SMSLookaside);
            UserFreePool(SMSLookaside);
            SMSLookaside = NULL;
        }
    }

    /*
     * Let go of the attached queue for hard error handling.
     * Do this before we free the Qlookaside !
     */
    if (gHardErrorHandler.pqAttach != NULL) {

        UserAssert(gHardErrorHandler.pqAttach > 0);
        UserAssert(gHardErrorHandler.pqAttach->QF_flags & QF_INDESTROY);

        FreeQueue(gHardErrorHandler.pqAttach);
        gHardErrorHandler.pqAttach = NULL;
    }

    /*
     * Free the cached array of queues
     */
    FreeCachedQueues();

    /*
     * cleanup the QEntry lookaside buffer
     */
    if (QEntryLookaside != NULL) {
        ExDeletePagedLookasideList(QEntryLookaside);
        UserFreePool(QEntryLookaside);
        QEntryLookaside = NULL;
    }

    /*
     * Cleanup the keyboard layouts
     */
    CleanupKeyboardLayouts();

    {
        PWOWTHREADINFO pwti;

        /*
         * Cleanup gpwtiFirst list. This list is supposed to be empty
         * at this point. In one case during stress we hit the case where
         * it was not empty. The assert is to catch that case in
         * checked builds.
         */

        while (gpwtiFirst != NULL) {
            pwti = gpwtiFirst;
            gpwtiFirst = pwti->pwtiNext;
            UserFreePool(pwti);
        }
    }

    /*
     * Cleanup cached SMWP array
     */
    if (gSMWP.acvr != NULL) {
        UserFreePool(gSMWP.acvr);
    }

    /*
     * Free gpsdInitWinSta. This is != NULL only if the session didn't
     * make it to UserInitialize.
     */
    if (gpsdInitWinSta != NULL) {
        UserFreePool(gpsdInitWinSta);
        gpsdInitWinSta = NULL;
    }

    if (gpHandleFlagsMutex != NULL) {
        ExFreePool(gpHandleFlagsMutex);
        gpHandleFlagsMutex = NULL;
    }

    /*
     * Delete the power request structures.
     */
    DeletePowerRequestList();

    if (gpresUser != NULL) {
        LeaveCrit();
        ExDeleteResourceLite(gpresUser);
        ExFreePool(gpresUser);
        gpresUser = NULL;
    }
#if DBG
    /*
     * Cleanup the global thread lock structures
     */
    for (i = 0; i < gcThreadLocksArraysAllocated; i++) {
        UserFreePool(gpaThreadLocksArrays[i]);
        gpaThreadLocksArrays[i] = NULL;
    }
#endif // DBG

#ifdef GENERIC_INPUT
#if DBG
    /*
     * Checkup the HID related memory leak.
     */
    CheckupHidLeak();
#endif // DBG
#endif // GENERIC_INPUT

    return TRUE;
}

#if DBG

/***************************************************************************\
* TrackAddDesktop
*
* Track desktops for cleanup purposes
*
* History:
* 04-Dec-1997 clupu     Created.
\***************************************************************************/
VOID TrackAddDesktop(
    PVOID pDesktop)
{
    PLIST_ENTRY Entry;
    PVOID       Atom;

    TRACE_HYDAPI(("TrackAddDesktop %#p\n", pDesktop));

    Atom = (PVOID)UserAllocPool(sizeof(PVOID) + sizeof(LIST_ENTRY),
                                TAG_TRACKDESKTOP);
    if (Atom) {

        *(PVOID*)Atom = pDesktop;

        Entry = (PLIST_ENTRY)(((PCHAR)Atom) + sizeof(PVOID));

        InsertTailList(&gDesktopList, Entry);
    }
}

/***************************************************************************\
* TrackRemoveDesktop
*
* Track desktops for cleanup purposes
*
* History:
* 04-Dec-1997 clupu     Created.
\***************************************************************************/
VOID TrackRemoveDesktop(
    PVOID pDesktop)
{
    PLIST_ENTRY NextEntry;
    PVOID       Atom;

    TRACE_HYDAPI(("TrackRemoveDesktop %#p\n", pDesktop));

    NextEntry = gDesktopList.Flink;

    while (NextEntry != &gDesktopList) {

        Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

        if (pDesktop == *(PVOID*)Atom) {

            RemoveEntryList(NextEntry);

            UserFreePool(Atom);

            break;
        }

        NextEntry = NextEntry->Flink;
    }
}

/***************************************************************************\
* DumpTrackedDesktops
*
* Dumps the tracked desktops
*
* History:
* 04-Dec-1997 clupu     Created.
\***************************************************************************/
VOID DumpTrackedDesktops(
    BOOL bBreak)
{
    PLIST_ENTRY NextEntry;
    PVOID       pdesk;
    PVOID       Atom;
    int         nAlive = 0;

    TRACE_HYDAPI(("DumpTrackedDesktops\n"));

    NextEntry = gDesktopList.Flink;

    while (NextEntry != &gDesktopList) {

        Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

        pdesk = *(PVOID*)Atom;

        KdPrint(("pdesk %#p\n", pdesk));

        /*
         * Restart at the begining of the list since our
         * entry got deleted
         */
        NextEntry = NextEntry->Flink;

        nAlive++;
    }
    if (bBreak && nAlive > 0) {
        RIPMSG0(RIP_ERROR, "Desktop objects still around\n");
    }
}

#endif // DBG

VOID DestroyRegion(
    HRGN* prgn)
{
    if (*prgn != NULL) {
        GreSetRegionOwner(*prgn, OBJECT_OWNER_CURRENT);
        GreDeleteObject(*prgn);
        *prgn = NULL;
    }
}

VOID DestroyBrush(
    HBRUSH* pbr)
{
    if (*pbr != NULL) {
        //GreSetBrushOwner(*pbr, OBJECT_OWNER_CURRENT);
        GreDeleteObject(*pbr);
        *pbr = NULL;
    }
}

VOID DestroyBitmap(
    HBITMAP* pbm)
{
    if (*pbm != NULL) {
        GreSetBitmapOwner(*pbm, OBJECT_OWNER_CURRENT);
        GreDeleteObject(*pbm);
        *pbm = NULL;
    }
}

VOID DestroyDC(
    HDC* phdc)
{
    if (*phdc != NULL) {
        GreSetDCOwner(*phdc, OBJECT_OWNER_CURRENT);
        GreDeleteDC(*phdc);
        *phdc = NULL;
    }
}

VOID DestroyFont(
    HFONT* pfnt)
{
    if (*pfnt != NULL) {
        GreDeleteObject(*pfnt);
        *pfnt = NULL;
    }
}

/***************************************************************************\
* CleanupGDI
*
* Cleanup all the GDI global objects used in USERK
*
* History:
* 29-Jan-1998 clupu     Created.
\***************************************************************************/
VOID CleanupGDI(
    VOID)
{
    int i;

    /*
     * Free gpDispInfo stuff
     */
    DestroyDC(&gpDispInfo->hdcScreen);
    DestroyDC(&gpDispInfo->hdcBits);
    DestroyDC(&gpDispInfo->hdcGray);
    DestroyDC(&ghdcMem);
    DestroyDC(&ghdcMem2);
    DestroyDC(&gfade.hdc);

    /*
     * Free the cache DC stuff before the GRE cleanup.
     * Also notice that we call DelayedDestroyCacheDC which
     * we usualy call from DestroyProcessInfo. We do it
     * here because this is the last WIN32 thread.
     */
    DestroyCacheDCEntries(PtiCurrent());
    DestroyCacheDCEntries(NULL);
    DelayedDestroyCacheDC();

    UserAssert(gpDispInfo->pdceFirst == NULL);

    /*
     * Free bitmaps
     */
    DestroyBitmap(&gpDispInfo->hbmGray);
    DestroyBitmap(&ghbmBits);
    DestroyBitmap(&ghbmCaption);

    /*
     * Cleanup brushes
     */
    DestroyBrush(&ghbrHungApp);
    DestroyBrush(&gpsi->hbrGray);
    DestroyBrush(&ghbrWhite);
    DestroyBrush(&ghbrBlack);

    for (i = 0; i < COLOR_MAX; i++) {
        DestroyBrush(&(SYSHBRUSH(i)));
    }

    /*
     * Cleanup regions
     */
    DestroyRegion(&gpDispInfo->hrgnScreen);
    DestroyRegion(&ghrgnInvalidSum);
    DestroyRegion(&ghrgnVisNew);
    DestroyRegion(&ghrgnSWP1);
    DestroyRegion(&ghrgnValid);
    DestroyRegion(&ghrgnValidSum);
    DestroyRegion(&ghrgnInvalid);
    DestroyRegion(&ghrgnInv0);
    DestroyRegion(&ghrgnInv1);
    DestroyRegion(&ghrgnInv2);
    DestroyRegion(&ghrgnGDC);
    DestroyRegion(&ghrgnSCR);
    DestroyRegion(&ghrgnSPB1);
    DestroyRegion(&ghrgnSPB2);
    DestroyRegion(&ghrgnSW);
    DestroyRegion(&ghrgnScrl1);
    DestroyRegion(&ghrgnScrl2);
    DestroyRegion(&ghrgnScrlVis);
    DestroyRegion(&ghrgnScrlSrc);
    DestroyRegion(&ghrgnScrlDst);
    DestroyRegion(&ghrgnScrlValid);

    /*
     * Cleanup fonts
     */
    DestroyFont(&ghSmCaptionFont);
    DestroyFont(&ghMenuFont);
    DestroyFont(&ghMenuFontDef);
    DestroyFont(&ghStatusFont);
    DestroyFont(&ghIconFont);
    DestroyFont(&ghFontSys);

#ifdef LAME_BUTTON
    DestroyFont(&ghLameFont);
#endif  // LAME_BUTTON

    /*
     * wallpaper stuff.
     */
    if (ghpalWallpaper != NULL) {
        GreSetPaletteOwner(ghpalWallpaper, OBJECT_OWNER_CURRENT);
        GreDeleteObject(ghpalWallpaper);
        ghpalWallpaper = NULL;
    }
    DestroyBitmap(&ghbmWallpaper);

    /*
     * Unload the video driver
     */
    if (gpDispInfo->pmdev) {
        DrvDestroyMDEV(gpDispInfo->pmdev);
        GreFreePool(gpDispInfo->pmdev);
        gpDispInfo->pmdev = NULL;
        gpDispInfo->hDev = NULL;
    }

    /*
     * Free the monitor stuff
     */
    {
        PMONITOR pMonitor;
        PMONITOR pMonitorNext;

        pMonitor = gpDispInfo->pMonitorFirst;

        while (pMonitor != NULL) {
            pMonitorNext = pMonitor->pMonitorNext;
            DestroyMonitor(pMonitor);
            pMonitor = pMonitorNext;
        }

        UserAssert(gpDispInfo->pMonitorFirst == NULL);

        if (gpMonitorCached != NULL) {
            DestroyMonitor(gpMonitorCached);
        }
    }
}


/***************************************************************************\
*   DestroyHandleTableObjects
*
*   Destroy any object still in the handle table.
*
\***************************************************************************/

VOID DestroyHandleFirstPass(PHE phe)
{
    /*
     * First pass for the handle object destruction.
     * Destroy the object, when we can. Otherwise,
     * links to the other handle object should be cleared
     * so that there will not be a dependency issues
     * in the final, second pass.
     */

    if (phe->phead->cLockObj == 0) {
        HMDestroyObject(phe->phead);
    } else {
        /*
         * The object couldn't be destroyed.
         */
        if (phe->bType == TYPE_KBDLAYOUT) {
            PKL pkl = (PKL)phe->phead;
            UINT i;

            /*
             * Clear out the pkf references (they will be
             * destroyed cleanly in the second run anyway)
             */
            pkl->spkf = NULL;
            pkl->spkfPrimary = NULL;
            if (pkl->pspkfExtra) {
                for (i = 0; i < pkl->uNumTbl; ++i) {
                    pkl->pspkfExtra[i] = NULL;
                }
            }
            pkl->uNumTbl = 0;
        }
    }
}

VOID DestroyHandleSecondPass(PHE phe)
{
    /*
     * Destroy the object.
     */
    if (phe->phead->cLockObj > 0) {

        RIPMSG2(RIP_WARNING, "DestroyHandleSecondPass: phe %#p still locked (%d)!", phe, phe->phead->cLockObj);

        /*
         * We're going to die, why bothered by the lock count?
         * We're forcing the lockcount to 0, and call the destroy routine.
         */
        phe->phead->cLockObj = 0;
    }
    HMDestroyUnlockedObject(phe);
    UserAssert(phe->bType == TYPE_FREE);
}

VOID DestroyHandleTableObjects(VOID)
{
    PHE         pheT;
    DWORD       i;
    VOID (*HandleDestroyer)(PHE);
#if DBG
    DWORD       nLeak;
#endif

    /*
     * Make sure the handle table was created !
     */
    if (gSharedInfo.aheList == NULL) {
        return;
    }

    /*
     * Loop through the table destroying all remaining objects.
     */

#if DBG
    RIPMSG0(RIP_WARNING, "==== Start handle leak check\n");
    nLeak = 0;
    for (i = 0; i <= giheLast; ++i) {
        pheT = gSharedInfo.aheList + i;

        if (pheT->bType != TYPE_FREE) {
            ++nLeak;
            RIPMSG3(RIP_WARNING, "  LEAK -- Handle %p @%p type=%x\n", pheT->phead->h, pheT, pheT->bType);
        }
    }
    RIPMSG1(RIP_WARNING, "==== Handle leak check finished: 0n%d leaks detected.\n", nLeak);
#endif

    /*
     * First pass: destroy it, or cut the link to other handle based object
     */
    HandleDestroyer = DestroyHandleFirstPass;

repeat:
    for (i = 0; i <= giheLast; ++i) {
        pheT = gSharedInfo.aheList + i;

        if (pheT->bType == TYPE_FREE)
            continue;

        UserAssert(!(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) &&
                   !(gahti[pheT->bType].bObjectCreateFlags & OCF_THREADOWNED));

        UserAssert(!(pheT->bFlags & HANDLEF_DESTROY));

        HandleDestroyer(pheT);
    }

    if (HandleDestroyer == DestroyHandleFirstPass) {
        /*
         * Go for the second pass.
         */
        HandleDestroyer = DestroyHandleSecondPass;
        goto repeat;
    }
}

/***************************************************************************\
* Win32KDriverUnload
*
* Exit point for win32k.sys
*
\***************************************************************************/
#ifdef TRACE_MAP_VIEWS
extern PWin32Section gpSections;
#endif

VOID Win32KDriverUnload(
    IN PDRIVER_OBJECT DriverObject)
{
    TRACE_HYDAPI(("Win32KDriverUnload\n"));

    UNREFERENCED_PARAMETER(DriverObject);

    HYDRA_HINT(HH_DRIVERUNLOAD);

    /*
     * Cleanup all resources in GRE
     */
    MultiUserNtGreCleanup();

    HYDRA_HINT(HH_GRECLEANUP);

    /*
     * Cleanup CSRSS
     */
    if (gpepCSRSS) {
        ObDereferenceObject(gpepCSRSS);
        gpepCSRSS = NULL;
    }

    /*
     * BUG 305965. There might be cases when we end up with DCEs still
     * in the list. Go ahead and clean it up here.
     */
    if (gpDispInfo != NULL && gpDispInfo->pdceFirst != NULL) {
        PDCE pdce, pdceNext;

        RIPMSG0(RIP_ERROR, "Win32KDriverUnload: the DCE list is not empty");

        pdce = gpDispInfo->pdceFirst;

        while (pdce != NULL) {
            pdceNext = pdce->pdceNext;

            UserFreePool(pdce);

            pdce = pdceNext;
        }
        gpDispInfo->pdceFirst = NULL;
    }

    /*
     * Cleanup all resources in ntuser
     */
    Win32kNtUserCleanup();

    /*
     * Cleanup the handle table for any object that is neither process
     * owned nor thread owned
     */
    DestroyHandleTableObjects();


    HYDRA_HINT(HH_USERKCLEANUP);

#if DBG || FRE_LOCK_RECORD
    HMCleanUpHandleTable();
#endif

    /*
     * Free the handle page array
     */

    if (gpHandlePages != NULL) {
        UserFreePool(gpHandlePages);
        gpHandlePages = NULL;
    }

    if (CsrApiPort != NULL) {
        ObDereferenceObject(CsrApiPort);
        CsrApiPort = NULL;
    }

    /*
     * Destroy the shared memory.
     */
    if (ghSectionShared != NULL) {
        NTSTATUS Status;

        gpsi = NULL;

        if (gpvSharedBase != NULL) {
            Win32HeapDestroy(gpvSharedAlloc);
            Status = Win32UnmapViewInSessionSpace(gpvSharedBase);
            UserAssert(NT_SUCCESS(Status));
        }

        Win32DestroySection(ghSectionShared);
    }

    CleanupWin32HeapStubs();

#ifdef TRACE_MAP_VIEWS
    if (gpSections != NULL) {
        FRE_RIPMSG3(RIP_ERROR, "Section being leaked; do \"d%cs 0x%p l%x\" to find stacktrace of the offender and triage against that", (sizeof(ULONG_PTR) == 8 ? 'q' : 'd'), (ULONG_PTR)gpSections + FIELD_OFFSET(Win32Section, trace), ARRAY_SIZE(gpSections->trace));
    }
#endif // TRACE_MAP_VIEWS

    /*
     * Cleanup all the user pool allocations by hand
     */
    CleanupMediaChange();
    CleanupPoolAllocations();

    CleanUpPoolLimitations();
    CleanUpSections();

    /*
     * Cleanup W32 structures.
     */
    if (gpW32FastMutex != NULL) {
        ExFreePool(gpW32FastMutex);
        gpW32FastMutex = NULL;
    }

    /*
     * Remove and free the service vector.
     */
    if (!gbRemoteSession) {
        KeRemoveSystemServiceTable(W32_SERVICE_NUMBER);
        if (gpCountTable != NULL) {
            ExFreePool(gpCountTable);
            gpCountTable = NULL;
        }
    }
}

/***************************************************************************\
* DriverEntry
*
* Entry point needed to initialize win32k.sys.
*
\***************************************************************************/
NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING strName;
    HANDLE hEventFirstSession;

    UNREFERENCED_PARAMETER(RegistryPath);

    HYDRA_HINT(HH_DRIVERENTRY);

    gpvWin32kImageBase = DriverObject->DriverStart;

#if DBG
    /*
     * Initialize the desktop tracking list.
     */
    InitializeListHead(&gDesktopList);
#endif // DBG

#ifdef GENERIC_INPUT
    /*
     * Initialize the global HID request list.
     */
    InitializeHidRequestList();
#endif

    /*
     * Find out if this is a remote session.
     */
    RtlInitUnicodeString(&strName, L"\\UniqueSessionIdEvent");

    InitializeObjectAttributes(&obja,
                               &strName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwCreateEvent(&hEventFirstSession,
                           EVENT_ALL_ACCESS,
                           &obja,
                           SynchronizationEvent,
                           FALSE);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            gbRemoteSession = TRUE;
        } else {
            goto Failure;
        }
    } else {
        gbRemoteSession = FALSE;
    }

    /*
     * Set the unload address
     */
    DriverObject->DriverUnload = Win32KDriverUnload;

    /*
     * Initialize data used for the timers. We want to do this really early,
     * before any Win32 Timer will be created. We need to be very careful to
     * not do anything that will need Win32 initialized yet.
     */

    gcmsLastTimer = NtGetTickCount();


    /*
     * Initialize the Win32 structures. We need to do this before we create
     * any threads.
     */
    gpW32FastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(FAST_MUTEX),
                                           TAG_SYSTEM);
    if (gpW32FastMutex == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }
    ExInitializeFastMutex(gpW32FastMutex);

    if (!gbRemoteSession) {

#if DBG
        /*
         * Allocate and zero the system service count table. Do not use
         * UserAllocPool for this allocation.
         */
        gpCountTable = ExAllocatePoolWithTag(NonPagedPool,
                                             W32pServiceLimit * sizeof(ULONG),
                                             'llac');
        if (gpCountTable == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Failure;
        }

        RtlZeroMemory(gpCountTable, W32pServiceLimit * sizeof(ULONG));
#endif

        /*
         * We only establish the system entry table once for the
         * whole system, even though WIN32K.SYS is instanced on a winstation
         * basis. This is because the VM changes assure that all loads of
         * WIN32K.SYS are at the exact same address, even if a fixup had
         * to occur.
         */
        UserVerify(KeAddSystemServiceTable(W32pServiceTable,
                                           gpCountTable,
                                           W32pServiceLimit,
                                           W32pArgumentTable,
                                           W32_SERVICE_NUMBER));
    }

    /*
     * Initialize the critical section before establishing the callouts so
     * we can assume that it's always valid.
     */
    if (!InitCreateUserCrit()) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    if (!gbRemoteSession) {
        WIN32_CALLOUTS_FPNS Win32Callouts;

        Win32Callouts.ProcessCallout = W32pProcessCallout;
        Win32Callouts.ThreadCallout = W32pThreadCallout;
        Win32Callouts.GlobalAtomTableCallout = UserGlobalAtomTableCallout;
        Win32Callouts.PowerEventCallout = UserPowerEventCallout;
        Win32Callouts.PowerStateCallout = UserPowerStateCallout;
        Win32Callouts.JobCallout = UserJobCallout;
        Win32Callouts.BatchFlushRoutine = (PVOID)NtGdiFlushUserBatch;

        Win32Callouts.DesktopOpenProcedure = (PKWIN32_OBJECT_CALLOUT)DesktopOpenProcedure;
        Win32Callouts.DesktopOkToCloseProcedure = (PKWIN32_OBJECT_CALLOUT)OkayToCloseDesktop;
        Win32Callouts.DesktopCloseProcedure = (PKWIN32_OBJECT_CALLOUT)UnmapDesktop;
        Win32Callouts.DesktopDeleteProcedure = (PKWIN32_OBJECT_CALLOUT)FreeDesktop;

        Win32Callouts.WindowStationOkToCloseProcedure = (PKWIN32_OBJECT_CALLOUT)OkayToCloseWindowStation;
        Win32Callouts.WindowStationCloseProcedure = (PKWIN32_OBJECT_CALLOUT)DestroyWindowStation;
        Win32Callouts.WindowStationDeleteProcedure = (PKWIN32_OBJECT_CALLOUT)FreeWindowStation;
        Win32Callouts.WindowStationParseProcedure = (PKWIN32_OBJECT_CALLOUT)ParseWindowStation;
        Win32Callouts.WindowStationOpenProcedure = (PKWIN32_OBJECT_CALLOUT)WindowStationOpenProcedure;

        PsEstablishWin32Callouts(&Win32Callouts);
    }

    Status = InitSectionTrace();
    if (!NT_SUCCESS(Status)) {
        goto Failure;
    }

    if (!InitWin32HeapStubs()) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    /*
     * Initialize pool limitation array.
     */
    Status = InitPoolLimitations();
    if (!NT_SUCCESS(Status)) {
        goto Failure;
    }

    /*
     * Create the event that is signaled when a desktop does away
     */
    gpevtDesktopDestroyed = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (gpevtDesktopDestroyed == NULL) {
        RIPMSG0(RIP_WARNING, "Couldn't create gpevtDesktopDestroyed");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    /*
     * Create the event that is signaled when no disconnect/reconnect is pending
     */
    gpevtVideoportCallout = CreateKernelEvent(NotificationEvent, FALSE);
    if (gpevtVideoportCallout == NULL) {
        RIPMSG0(RIP_WARNING, "Couldn't create gpevtVideoportCallout");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

#if defined(_X86_)
    /*
     * Keep our own copy of this to avoid double indirections on probing
     */
    Win32UserProbeAddress = *MmUserProbeAddress;
#endif

    if ((hModuleWin = MmPageEntireDriver(DriverEntry)) == NULL) {
        RIPMSG0(RIP_WARNING, "MmPageEntireDriver failed");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

#if DBG
    /*
     * Initialize the gpaThreadLocksArray mechanism
     */
    gFreeTLList = gpaThreadLocksArrays[gcThreadLocksArraysAllocated] =
    UserAllocPoolZInit(sizeof(TL)*MAX_THREAD_LOCKS, TAG_GLOBALTHREADLOCK);
    if (gFreeTLList == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }
    InitGlobalThreadLockArray(0);
    gcThreadLocksArraysAllocated = 1;
#endif


    if (!InitializeGre()) {
        RIPMSG0(RIP_WARNING, "InitializeGre failed");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    Status = Win32UserInitialize();

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Win32UserInitialize failed with Status %x",
                Status);
        goto Failure;
    }

    /*
     * Remember Session Creation Time. This is used to decide if power
     * messages need to be sent.
     */
    gSessionCreationTime = KeQueryInterruptTime();

    //
    // Initialize rundown protection for WindowStation objects.
    //
    ExInitializeRundownProtection(&gWinstaRunRef);

    /*
     * Check if LUID DosDevices are enabled
     */
    CheckLUIDDosDevicesEnabled(&gLUIDDeviceMapsEnabled);

    return STATUS_SUCCESS;

Failure:

    RIPMSG1(RIP_WARNING,
            "Initialization of WIN32K.SYS failed with Status = 0x%x",
            Status);

    Win32KDriverUnload(NULL);
    return Status;
}

/***************************************************************************\
* xxxAddFontResourceW
*
*
* History:
\***************************************************************************/

int xxxAddFontResourceW(
    LPWSTR lpFile,
    FLONG  flags,
    DESIGNVECTOR *pdv)
{
    UNICODE_STRING strFile;

    RtlInitUnicodeString(&strFile, lpFile);

    return xxxClientAddFontResourceW(&strFile, flags, pdv);
}

/***************************************************************************\
* LW_DriversInit
*
*
* History:
\***************************************************************************/

VOID LW_DriversInit(VOID)
{
    /*
     * Initialize the keyboard typematic rate.
     */
    SetKeyboardRate((UINT)gnKeyboardSpeed);

    /*
     * Adjust VK modification table if not default (type 4) kbd.
     */
    if (gKeyboardInfo.KeyboardIdentifier.Type == 3)
        gapulCvt_VK = gapulCvt_VK_84;

    /*
     * Adjust VK modification table for IBM 5576 002/003 keyboard.
     */
    if (JAPANESE_KEYBOARD(gKeyboardInfo.KeyboardIdentifier) &&
        (gKeyboardInfo.KeyboardIdentifier.Subtype == 3))
        gapulCvt_VK = gapulCvt_VK_IBM02;

    /*
     * Initialize NLS keyboard globals.
     */
    NlsKbdInitializePerSystem();
}

/***************************************************************************\
* LoadCPUserPreferences
*
* 06/07/96  GerardoB  Created
\***************************************************************************/
BOOL LoadCPUserPreferences(
    PUNICODE_STRING pProfileUserName,
    DWORD dwPolicyOnly)
{
    DWORD pdwValue[SPI_BOOLMASKDWORDSIZE], dw;
    PPROFILEVALUEINFO ppvi = gpviCPUserPreferences;

    UserAssert(1 + SPI_DWORDRANGECOUNT == ARRAY_SIZE(gpviCPUserPreferences));

    /*
     * The first value in gpviCPUserPreferences corresponds to the bit mask
     */
    dw =  FastGetProfileValue(pProfileUserName,
                              ppvi->uSection,
                              ppvi->pwszKeyName,
                              NULL,
                              (LPBYTE)pdwValue,
                              sizeof(*pdwValue),
                              dwPolicyOnly);

    /*
     * Copy only the amount of data read and no more than what we expect.
     */
    if (dw != 0) {
        if (dw > sizeof(gpdwCPUserPreferencesMask)) {
            dw = sizeof(gpdwCPUserPreferencesMask);
        }

        RtlCopyMemory(gpdwCPUserPreferencesMask, pdwValue, dw);
    }

    ppvi++;

    /*
     * DWORD values
     */
    for (dw = 1; dw < 1 + SPI_DWORDRANGECOUNT; dw++, ppvi++) {
        if (FastGetProfileValue(pProfileUserName,
                                ppvi->uSection,
                                ppvi->pwszKeyName,
                                NULL,
                                (LPBYTE)pdwValue,
                                sizeof(DWORD),
                                dwPolicyOnly)) {

            ppvi->dwValue = *pdwValue;
        }
    }

    /*
     * Propagate gpsi flags
     */
    PropagetUPBOOLTogpsi(COMBOBOXANIMATION);
    PropagetUPBOOLTogpsi(LISTBOXSMOOTHSCROLLING);
    PropagetUPBOOLTogpsi(KEYBOARDCUES);
    SET_OR_CLEAR_SRVIF(SRVIF_KEYBOARDPREF, TEST_BOOL_ACCF(ACCF_KEYBOARDPREF));

    gpsi->uCaretWidth = UP(CARETWIDTH);
    SYSMET(CXFOCUSBORDER) = UP(FOCUSBORDERWIDTH);
    SYSMET(CYFOCUSBORDER) = UP(FOCUSBORDERHEIGHT);

    PropagetUPBOOLTogpsi(UIEFFECTS);

    EnforceColorDependentSettings();

    return TRUE;
}

/***************************************************************************\
* LW_LoadProfileInitData
*
* Only stuff that gets initialized at boot should go here. Per user settings
* should be initialized in xxxUpdatePerUserSystemParameters.
\***************************************************************************/
VOID LW_LoadProfileInitData(
    PUNICODE_STRING pProfileUserName)
{
    FastGetProfileIntFromID(pProfileUserName,
                            PMAP_WINDOWSM,
                            STR_DDESENDTIMEOUT,
                            0,
                            &guDdeSendTimeout,
                            0);
}

/***************************************************************************\
* LW_LoadResources
*
*
* History:
\***************************************************************************/
VOID LW_LoadResources(
    PUNICODE_STRING pProfileUserName)
{
    WCHAR rgch[4];

    /*
     * See if the Mouse buttons need swapping.
     */
    FastGetProfileStringFromIDW(pProfileUserName,
                                PMAP_MOUSE,
                                STR_SWAPBUTTONS,
                                szN,
                                rgch,
                                ARRAY_SIZE(rgch),
                                0);
    SYSMET(SWAPBUTTON) = (*rgch == '1' || *rgch == *szY || *rgch == *szy);

    /*
     * See if we should beep.
     */
    FastGetProfileStringFromIDW(pProfileUserName,
                                PMAP_BEEP,
                                STR_BEEP,
                                szY,
                                rgch,
                                ARRAY_SIZE(rgch),
                                0);

    SET_OR_CLEAR_PUDF(PUDF_BEEP, (rgch[0] == *szY) || (rgch[0] == *szy));

    /*
     * See if we should have extended sounds.
     */
    FastGetProfileStringFromIDW(pProfileUserName,
                                PMAP_BEEP,
                                STR_EXTENDEDSOUNDS,
                                szN,
                                rgch,
                                ARRAY_SIZE(rgch),
                                0);

    SET_OR_CLEAR_PUDF(PUDF_EXTENDEDSOUNDS, (rgch[0] == *szY || rgch[0] == *szy));
}

/***************************************************************************\
* xxxLoadSomeStrings
*
* This function loads a bunch of strings from the user32 resource string
* table
* This is done to keep all the localizable strings in user side to be MUI
* Manageable.
*
* History:
* 4-Mar-2000 MHamid    Created.
\***************************************************************************/
VOID xxxLoadSomeStrings(
    VOID)
{
    int i, str, id;

    /*
     * MessageBox strings.
     */
    for (i = 0, str = STR_OK, id = IDOK; i<MAX_MB_STRINGS; i++, str++, id++) {
        gpsi->MBStrings[i].uStr = str;
        gpsi->MBStrings[i].uID = id;
        xxxClientLoadStringW(str,
                             gpsi->MBStrings[i].szName,
                             ARRAY_SIZE(gpsi->MBStrings[i].szName));
    }

    /*
     * Load ToolTip strings.
     */
    xxxClientLoadStringW(STR_TT_MIN,     gszMIN,     ARRAY_SIZE(gszMIN));
    xxxClientLoadStringW(STR_TT_MAX,     gszMAX,     ARRAY_SIZE(gszMAX));
    xxxClientLoadStringW(STR_TT_RESUP,   gszRESUP,   ARRAY_SIZE(gszRESUP));
    xxxClientLoadStringW(STR_TT_RESDOWN, gszRESDOWN, ARRAY_SIZE(gszRESDOWN));
    xxxClientLoadStringW(STR_TT_SCLOSE,  gszSCLOSE,  ARRAY_SIZE(gszSCLOSE));
    xxxClientLoadStringW(STR_TT_HELP,    gszHELP,    ARRAY_SIZE(gszHELP));
}

/***************************************************************************\
* xxxInitWindowStation
*
* History:
* 6-Sep-1996 CLupu   Created.
* 21-Jan-98  SamerA  Renamed to xxxInitWindowStation since it may leave the
*                    critical section.
\***************************************************************************/
BOOL xxxInitWindowStation(
    VOID)
{
    TL tlName;
    PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
    BOOL fRet;

    /*
     * Load all profile data first
     */
    LW_LoadProfileInitData(pProfileUserName);

    /*
     * Initialize User in a specific order.
     */
    LW_DriversInit();

    xxxLoadSomeStrings();

    /*
     * This is the initialization from Chicago
     */
    if (!(fRet = xxxSetWindowNCMetrics(pProfileUserName, NULL, TRUE, -1))) {
        RIPMSG0(RIP_WARNING, "xxxInitWindowStation failed in xxxSetWindowNCMetrics");
        goto Exit;
    }

    SetMinMetrics(pProfileUserName, NULL);

    if (!(fRet = SetIconMetrics(pProfileUserName, NULL))) {
        RIPMSG0(RIP_WARNING, "xxxInitWindowStation failed in SetIconMetrics");
        goto Exit;
    }

    if (!(fRet = FinalUserInit())) {
        RIPMSG0(RIP_WARNING, "xxxInitWindowStation failed in FinalUserInit");
        goto Exit;
    }

    /*
     * Initialize the key cache index.
     */
    gpsi->dwKeyCache = 1;

Exit:
    FreeProfileUserName(pProfileUserName, &tlName);

    return fRet;
}

/***************************************************************************\
* CreateTerminalInput
*
*
* History:
* 6-Sep-1996 CLupu   Created.
\***************************************************************************/
BOOL CreateTerminalInput(
    PTERMINAL pTerm)
{
    UserAssert(pTerm != NULL);

    /*
     * call to the client side to clean up the [Fonts] section
     * of the registry. This will only take significant chunk of time
     * if the [Fonts] key changed during since the last boot and if
     * there are lots of fonts loaded
     */
    ClientFontSweep();

    /*
     * Load the standard fonts before we create any DCs. At this time we can
     * only add the fonts that do not reside on the net. They may be needed
     * by winlogon. Our winlogon needs only ms sans serif, but private
     * winlogon's may need some other fonts as well. The fonts on the net
     * will be added later, right after all the net connections have been
     * restored.
     */
    xxxLW_LoadFonts(FALSE);

    /*
     * Initialize the input system.
     */
    if (!xxxInitInput(pTerm)) {
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* CI_GetClrVal
*
* Returns the RGB value of a color string from WIN.INI.
*
* History:
\***************************************************************************/
DWORD CI_GetClrVal(
    LPWSTR p,
    DWORD clrDefval)
{
    LPBYTE pl;
    BYTE val;
    int i;
    DWORD clrval;

    if (*p == UNICODE_NULL) {
        return clrDefval;
    }

    /*
     * Initialize the pointer to the LONG return value. Set to MSB.
     */
    pl = (LPBYTE)&clrval;

    /*
     * Get three goups of numbers seprated by non-numeric characters.
     */
    for (i = 0; i < 3; i++) {

        /*
         * Skip over any non-numeric characters within the string.
         */
        while ((*p != UNICODE_NULL) && !(*p >= TEXT('0') && *p <= TEXT('9'))) {
            p++;
        }

        /*
         * Are we (prematurely) at the end of the string?
         */
        if (*p == UNICODE_NULL) {
            RIPMSG0(RIP_WARNING, "CI_GetClrVal: Color string is corrupted");
            return clrDefval;
        }

        /*
         * Get the next series of digits.
         */
        val = 0;
        while (*p >= TEXT('0') && *p <= TEXT('9'))
            val = (BYTE)((int)val*10 + (int)*p++ - '0');

        /*
         * HACK! Store the group in the LONG return value.
         */
        *pl++ = val;
    }
    /*
     * Force the MSB to zero for GDI.
     */
    *pl = 0;

    return clrval;
}

/***************************************************************************\
* xxxODI_ColorInit
*
*
* History:
\***************************************************************************/

VOID xxxODI_ColorInit(PUNICODE_STRING pProfileUserName)
{
    int      i;
    COLORREF colorVals[STR_COLOREND - STR_COLORSTART + 1];
    INT      colorIndex[STR_COLOREND - STR_COLORSTART + 1];
    WCHAR    rgchValue[25];

#if COLOR_MAX - (STR_COLOREND - STR_COLORSTART + 1)
#error "COLOR_MAX value conflicts with STR_COLOREND - STR_COLORSTART"
#endif

    /*
     * Now set up default color values.
     * These are not in display drivers anymore since we just want default.
     * The real values are stored in the profile.
     */
    RtlCopyMemory(gpsi->argbSystem, gargbInitial, sizeof(COLORREF) * COLOR_MAX);
    RtlCopyMemory(gpsi->argbSystemUnmatched, gpsi->argbSystem, sizeof(COLORREF) * COLOR_MAX);

    for (i = 0; i < COLOR_MAX; i++) {
        LUID    luidCaller;

        /*
         * Try to find a WIN.INI entry for this object.
         */
        *rgchValue = 0;
        /*
         * Special case the background color. Try using Winlogon's value
         * if present. If the value doesn't exist then use USER's value.
         */
        if ((COLOR_BACKGROUND == i) &&
            NT_SUCCESS(GetProcessLuid(NULL, &luidCaller)) &&
            RtlEqualLuid(&luidCaller, &luidSystem)) {

            FastGetProfileStringFromIDW(pProfileUserName,
                                        PMAP_WINLOGON,
                                        STR_COLORSTART + COLOR_BACKGROUND,
                                        szNull,
                                        rgchValue,
                                        ARRAY_SIZE(rgchValue),
                                        0);
        }
        if (*rgchValue == 0) {
            FastGetProfileStringFromIDW(pProfileUserName,
                                        PMAP_COLORS,
                                        STR_COLORSTART + i,
                                        szNull,
                                        rgchValue,
                                        ARRAY_SIZE(rgchValue),
                                        0);
        }

        /*
         * Convert the string into an RGB value and store. Use the
         * default RGB value if the profile value is missing.
         */
        colorVals[i]  = CI_GetClrVal(rgchValue, gpsi->argbSystem[i]);
        colorIndex[i] = i;
    }

    xxxSetSysColors(pProfileUserName,
                    i,
                    colorIndex,
                    colorVals,
                    SSCF_FORCESOLIDCOLOR | SSCF_SETMAGICCOLORS);
}


/***********************************************************************\
* _LoadIconsAndCursors
*
* Used in parallel with the client side - LoadIconsAndCursors. This
* assumes that only the default configurable cursors and icons have
* been loaded and searches the global icon cache for them to fixup
* the default resource ids to standard ids. Also initializes the
* rgsys arrays allowing SYSCUR and SYSICO macros to work.
*
* 14-Oct-1995 SanfordS  created.
\***********************************************************************/
VOID _LoadCursorsAndIcons(
    VOID)
{
    PCURSOR pcur;
    int     i;

    pcur = gpcurFirst;

    /*
     * Only CSR can call this (and only once).
     */
    if (!ISCSRSS()) {
        return;
    }

    HYDRA_HINT(HH_LOADCURSORS);

    while (pcur) {
        UserAssert(!IS_PTR(pcur->strName.Buffer));

        switch (pcur->rt) {
        case RT_ICON:
            UserAssert((LONG_PTR)pcur->strName.Buffer >= OIC_FIRST_DEFAULT);

            UserAssert((LONG_PTR)pcur->strName.Buffer <
                    OIC_FIRST_DEFAULT + COIC_CONFIGURABLE);

            i = PTR_TO_ID(pcur->strName.Buffer) - OIC_FIRST_DEFAULT;
            pcur->strName.Buffer = (LPWSTR)gasysico[i].Id;

            if (pcur->CURSORF_flags & CURSORF_LRSHARED) {
                UserAssert(gasysico[i].spcur == NULL);
                Lock(&gasysico[i].spcur, pcur);
            } else {
                UserAssert(gpsi->hIconSmWindows == NULL);
                UserAssert((int)pcur->cx == SYSMET(CXSMICON));
                /*
                 * The special small winlogo icon is not shared.
                 */
                gpsi->hIconSmWindows = PtoH(pcur);
            }
            break;

        case RT_CURSOR:
            UserAssert((LONG_PTR)pcur->strName.Buffer >= OCR_FIRST_DEFAULT);

            UserAssert((LONG_PTR)pcur->strName.Buffer <
                    OCR_FIRST_DEFAULT + COCR_CONFIGURABLE);

            i = PTR_TO_ID(pcur->strName.Buffer) - OCR_FIRST_DEFAULT;
            pcur->strName.Buffer = (LPWSTR)gasyscur[i].Id;
            Lock(&gasyscur[i].spcur, pcur);
            break;

        default:
            // Should be nothing in the cache but these!
            RIPMSG1(RIP_ERROR, "Bogus object in cursor list: 0x%p", pcur);
        }

        pcur = pcur->pcurNext;
    }

    /*
     * copy special icon handles to global spots for later use.
     */
    gpsi->hIcoWindows = PtoH(SYSICO(WINLOGO));
}

/***********************************************************************\
* UnloadCursorsAndIcons
*
* Used for cleanup of win32k.
*
* Dec-10-1997 clupu  created.
\***********************************************************************/
VOID UnloadCursorsAndIcons(
    VOID)
{
    PCURSOR pcur;
    int     ind;

    TRACE_HYDAPI(("UnloadCursorsAndIcons\n"));

    /*
     * Unlock the icons.
     */
    for (ind = 0; ind < COIC_CONFIGURABLE; ind++) {
        pcur = gasysico[ind].spcur;

        if (pcur == NULL) {
            continue;
        }

        pcur->head.ppi = PpiCurrent();
        Unlock(&gasysico[ind].spcur);
    }

    /*
     * Unlock the cursors.
     */
    for (ind = 0; ind < COCR_CONFIGURABLE; ind++) {
        pcur = gasyscur[ind].spcur;

        if (pcur == NULL) {
            continue;
        }

        pcur->head.ppi = PpiCurrent();
        Unlock(&gasyscur[ind].spcur);
    }
}

/***********************************************************************\
* xxxUpdateSystemCursorsFromRegistry
*
* Reloads all customizable cursors from the registry.
*
* 09-Oct-1995 SanfordS  created.
\***********************************************************************/
VOID xxxUpdateSystemCursorsFromRegistry(
    PUNICODE_STRING pProfileUserName)
{
    int            i;
    UNICODE_STRING strName;
    TCHAR          szFilename[MAX_PATH];
    PCURSOR        pCursor;
    UINT           LR_flags;

    for (i = 0; i < COCR_CONFIGURABLE; i++) {
        FastGetProfileStringFromIDW(pProfileUserName,
                                    PMAP_CURSORS,
                                    gasyscur[i].StrId,
                                    TEXT(""),
                                    szFilename,
                                    ARRAY_SIZE(szFilename),
                                    0);

        if (*szFilename) {
            RtlInitUnicodeString(&strName, szFilename);
            LR_flags = LR_LOADFROMFILE | LR_ENVSUBST | LR_DEFAULTSIZE;
        } else {
            RtlInitUnicodeStringOrId(&strName,
                                     MAKEINTRESOURCE(i + OCR_FIRST_DEFAULT));
            LR_flags = LR_ENVSUBST | LR_DEFAULTSIZE;
        }

        pCursor = xxxClientLoadImage(&strName,
                                     0,
                                     IMAGE_CURSOR,
                                     0,
                                     0,
                                     LR_flags,
                                     FALSE);

        if (pCursor) {
            zzzSetSystemImage(pCursor, gasyscur[i].spcur);
        } else {
            RIPMSG1(RIP_WARNING, "Unable to update cursor. id=%x.", i + OCR_FIRST_DEFAULT);

        }
    }
}

/***********************************************************************\
* xxxUpdateSystemIconsFromRegistry
*
* Reloads all customizable icons from the registry.
*
* 09-Oct-1995 SanfordS  created.
\***********************************************************************/
VOID xxxUpdateSystemIconsFromRegistry(
    PUNICODE_STRING pProfileUserName)
{
    int            i;
    UNICODE_STRING strName;
    TCHAR          szFilename[MAX_PATH];
    PCURSOR        pCursor;
    UINT           LR_flags;

    for (i = 0; i < COIC_CONFIGURABLE; i++) {
        FastGetProfileStringFromIDW(pProfileUserName,
                                    PMAP_ICONS,
                                    gasysico[i].StrId,
                                    TEXT(""),
                                    szFilename,
                                    ARRAY_SIZE(szFilename),
                                    0);

        if (*szFilename) {
            RtlInitUnicodeString(&strName, szFilename);
            LR_flags = LR_LOADFROMFILE | LR_ENVSUBST;
        } else {
            RtlInitUnicodeStringOrId(&strName,
                                     MAKEINTRESOURCE(i + OIC_FIRST_DEFAULT));
            LR_flags = LR_ENVSUBST;
        }

        pCursor = xxxClientLoadImage(&strName,
                                     0,
                                     IMAGE_ICON,
                                     0,
                                     0,
                                     LR_flags,
                                     FALSE);

        RIPMSG3(RIP_VERBOSE,
                (!IS_PTR(strName.Buffer)) ?
                        "%#.8lx = Loaded id %ld" :
                        "%#.8lx = Loaded file %ws for id %ld",
                PtoH(pCursor),
                strName.Buffer,
                i + OIC_FIRST_DEFAULT);

        if (pCursor) {
            zzzSetSystemImage(pCursor, gasysico[i].spcur);
        } else {
            RIPMSG1(RIP_WARNING, "Unable to update icon. id=%ld", i + OIC_FIRST_DEFAULT);
        }

        /*
         * update the small winlogo icon which is referenced by gpsi.
         * Seems like we should load the small version for all configurable
         * icons anyway. What is needed is for CopyImage to support
         * copying of images loaded from files with LR_COPYFROMRESOURCE
         * allowing a reaload of the bits. (SAS)
         */
        if (i == OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT) {
            PCURSOR pCurSys = HtoP(gpsi->hIconSmWindows);

            if (pCurSys != NULL) {
                pCursor = xxxClientLoadImage(&strName,
                                             0,
                                             IMAGE_ICON,
                                             SYSMET(CXSMICON),
                                             SYSMET(CYSMICON),
                                             LR_flags,
                                             FALSE);

                if (pCursor) {
                    zzzSetSystemImage(pCursor, pCurSys);
                } else {
                    RIPMSG0(RIP_WARNING, "Unable to update small winlogo icon.");
                }
            }
        }
    }
}

/***************************************************************************\
* LW_BrushInit
*
*
* History:
\***************************************************************************/
BOOL LW_BrushInit(
    VOID)
{
    HBITMAP hbmGray;
    CONST static WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

    /*
     * Create a gray brush to be used with GrayString.
     */
    hbmGray = GreCreateBitmap(8, 8, 1, 1, (LPBYTE)patGray);
    if (hbmGray == NULL) {
        return FALSE;
    }

    gpsi->hbrGray  = GreCreatePatternBrush(hbmGray);
    ghbrWhite = GreGetStockObject(WHITE_BRUSH);
    ghbrBlack = GreGetStockObject(BLACK_BRUSH);

    UserAssert(ghbrWhite != NULL && ghbrBlack != NULL);

    if (gpsi->hbrGray == NULL) {
        return FALSE;
    }

    GreDeleteObject(hbmGray);
    GreSetBrushOwnerPublic(gpsi->hbrGray);
    ghbrHungApp = GreCreateSolidBrush(0);

    if (ghbrHungApp == NULL) {
        return FALSE;
    }

    GreSetBrushOwnerPublic(ghbrHungApp);

    return TRUE;
}

/***************************************************************************\
* LW_RegisterWindows
*
*
* History:
\***************************************************************************/
BOOL LW_RegisterWindows(
    VOID)
{
    int i;
    WNDCLASSVEREX wndcls;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fSuccess = TRUE;
    BOOL fSystem = (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) != 0;

    CONST static struct {
        BOOLEAN     fSystem;
        BOOLEAN     fGlobalClass;
        WORD        fnid;
        UINT        style;
        WNDPROC     lpfnWndProc;
        int         cbWndExtra;
        BOOL        fNormalCursor : 1;
        HBRUSH      hbrBackground;
        LPCTSTR     lpszClassName;
    } rc[] = {
        { TRUE, TRUE, FNID_DESKTOP,
            CS_DBLCLKS,
            (WNDPROC)xxxDesktopWndProc,
            sizeof(DESKWND) - sizeof(WND),
            TRUE,
            (HBRUSH)(COLOR_BACKGROUND + 1),
            DESKTOPCLASS},
        { TRUE, FALSE, FNID_SWITCH,
            CS_VREDRAW | CS_HREDRAW | CS_SAVEBITS,
            (WNDPROC)xxxSwitchWndProc,
            sizeof(SWITCHWND) - sizeof(WND),
            TRUE,
            NULL,
            SWITCHWNDCLASS},
        { TRUE, FALSE, FNID_MENU,
            CS_DBLCLKS | CS_SAVEBITS | CS_DROPSHADOW,
            (WNDPROC)xxxMenuWindowProc,
            sizeof(PPOPUPMENU),
            FALSE,
            (HBRUSH)(COLOR_MENU + 1),
            MENUCLASS},
        { FALSE, FALSE, FNID_SCROLLBAR,
            CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_PARENTDC,
            (WNDPROC)xxxSBWndProc,
            sizeof(SBWND) - sizeof(WND),
            TRUE,
            NULL,
            L"ScrollBar"},
        { TRUE, FALSE, FNID_TOOLTIP,
            CS_DBLCLKS | CS_SAVEBITS,
            (WNDPROC)xxxTooltipWndProc,
            sizeof(TOOLTIPWND) - sizeof(WND),
            TRUE,
            NULL,
            TOOLTIPCLASS},
        { TRUE, TRUE, FNID_ICONTITLE,
            0,
            (WNDPROC)xxxDefWindowProc,
            0,
            TRUE,
            NULL,
            ICONTITLECLASS},
        { FALSE, FALSE, 0,
            0,
            (WNDPROC)xxxEventWndProc,
            sizeof(PSVR_INSTANCE_INFO),
            FALSE,
            NULL,
            L"DDEMLEvent"},
#ifdef HUNGAPP_GHOSTING
        { TRUE, TRUE, FNID_GHOST,
            0,
            (WNDPROC)xxxGhostWndProc,
            0,
            TRUE,
            NULL,
            L"Ghost"},
#endif // HUNGAPP_GHOSTING
        { TRUE, TRUE, 0,
            0,
            (WNDPROC)xxxDefWindowProc,
            0,
            TRUE,
            NULL,
            L"SysShadow"},
        { TRUE, TRUE, FNID_MESSAGEWND,
            0,
            (WNDPROC)xxxDefWindowProc,
            4,
            TRUE,
            NULL,
            szMESSAGE}
    };


    /*
     * All other classes are registered via the table.
     */
    wndcls.cbClsExtra   = 0;
    wndcls.hInstance    = hModuleWin;
    wndcls.hIcon        = NULL;
    wndcls.hIconSm      = NULL;
    wndcls.lpszMenuName = NULL;

    for (i = 0; i < ARRAY_SIZE(rc); i++) {
        if (fSystem && !rc[i].fSystem) {
            continue;
        }
        wndcls.style        = rc[i].style;
        wndcls.lpfnWndProc  = rc[i].lpfnWndProc;
        wndcls.cbWndExtra   = rc[i].cbWndExtra;
        wndcls.hCursor      = rc[i].fNormalCursor ? PtoH(SYSCUR(ARROW)) : NULL;
        wndcls.hbrBackground= rc[i].hbrBackground;
        wndcls.lpszClassName= rc[i].lpszClassName;
        wndcls.lpszClassNameVer= rc[i].lpszClassName;

        if (InternalRegisterClassEx(&wndcls,
                                    rc[i].fnid,
                                    CSF_SERVERSIDEPROC | CSF_WIN40COMPAT) == NULL) {
            RIPMSG0(RIP_WARNING, "LW_RegisterWindows: InternalRegisterClassEx failed");
            fSuccess = FALSE;
            break;
        }

        if (fSystem && rc[i].fGlobalClass) {
            if (InternalRegisterClassEx(&wndcls,
                                    rc[i].fnid,
                                    CSF_SERVERSIDEPROC | CSF_SYSTEMCLASS | CSF_WIN40COMPAT) == NULL) {

                RIPMSG0(RIP_WARNING, "LW_RegisterWindows: InternalRegisterClassEx failed");
                fSuccess = FALSE;
                break;
            }
        }
    }

    if (fSuccess) {
        ptiCurrent->ppi->W32PF_Flags |= W32PF_CLASSESREGISTERED;
#ifndef LAZY_CLASS_INIT
        if (!fSystem && ptiCurrent->pClientInfo) {
            try {
                ptiCurrent->pClientInfo->CI_flags |= CI_REGISTERCLASSES;
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                   fSuccess = FALSE;
            }
        }
#endif
    }

    return fSuccess;
}

/**********************************************************\
* VOID vCheckMMInstance
*
* History:
*  Feb-06-98    Xudong Wu [TessieW]
* Wrote it.
\**********************************************************/
VOID vCheckMMInstance(
    LPWSTR pchSrch,
    DESIGNVECTOR  *pdv)
{
    LPWSTR  pKeyName;
    WCHAR   szName[MAX_PATH], *pszName = szName;
    WCHAR   szCannonicalName[MAX_PATH];
    ULONG   NumAxes;

    pdv->dvNumAxes = 0;
    pKeyName = pchSrch;
    while (*pKeyName && (*pKeyName++ != TEXT('('))) {
        /* do nothing */;
    }

    if (*pKeyName){
        if (!_wcsicmp(pKeyName, L"OpenType)")) {
            pKeyName = pchSrch;
            while(*pKeyName != TEXT('(')) {
                *pszName++ = *pKeyName++;
            }
            *pszName = 0;

            GreGetCannonicalName(szName, szCannonicalName, &NumAxes, pdv);
        }
    }
}

BOOL bEnumerateRegistryFonts(
    BOOL bPermanent)
{
    LPWSTR pchKeys, pchSrch, lpchT;
    int cchReal, cFont;
    WCHAR szFontFile[MAX_PATH];
    FLONG flAFRW;
    TL tlPool;
    DESIGNVECTOR  dv;
    WCHAR szPreloadFontFile[MAX_PATH];
    static int LastFontLoaded = -1;

    /*
     * if we are not just checking whether this is a registry font
     */
    flAFRW = (bPermanent ? AFRW_ADD_LOCAL_FONT : AFRW_ADD_REMOTE_FONT);

    cchReal = (int)FastGetProfileKeysW(NULL,
            PMAP_FONTS,
            TEXT("vgasys.fnt"),
            &pchKeys
            );

#if DBG
    if (cchReal == 0) {
        RIPMSG0(RIP_WARNING, "bEnumerateRegistryFonts: cchReal is 0");
    }
#endif

    if (!pchKeys) {
        return FALSE;
    }

    ThreadLockPool(PtiCurrent(), pchKeys, &tlPool);

    /*
     * If we got here first, we load the fonts until this preload font.
     * Preload fonts will be used by Winlogon UI, then we need to make sure
     * the font is available when Winlogon UI comes up.
     */
    if (LastFontLoaded == -1) {
        FastGetProfileStringW(NULL, PMAP_WINLOGON,
                              TEXT("PreloadFontFile"),
                              TEXT("Micross.ttf"),
                              szPreloadFontFile,
                              MAX_PATH,
                              0);
        RIPMSG1(RIP_VERBOSE, "Winlogon preload font = %ws\n",szPreloadFontFile);
    }

    /*
     * Now we have all the key names in pchKeys.
     */
    if (cchReal != 0) {

        cFont   = 0;
        pchSrch = pchKeys;

        do {
            // check to see whether this is MM(OpenType) instance
            vCheckMMInstance(pchSrch, &dv);

            if (FastGetProfileStringW(NULL,
                                      PMAP_FONTS,
                                      pchSrch,
                                      TEXT("vgasys.fon"),
                                      szFontFile,
                                      (MAX_PATH - 5),
                                      0)) {

                /*
                 * If no extension, append ".FON"
                 */
                for (lpchT = szFontFile; *lpchT != TEXT('.'); lpchT++) {

                    if (*lpchT == 0) {
                        wcscat(szFontFile, TEXT(".FON"));
                        break;
                    }
                }

                if ((cFont > LastFontLoaded) && bPermanent) {

                    /*
                     * skip if we've already loaded this local font.
                     */
                    xxxAddFontResourceW(szFontFile, flAFRW, dv.dvNumAxes ? &dv : NULL);
                }

                if (!bPermanent) {
                    xxxAddFontResourceW(szFontFile, flAFRW, dv.dvNumAxes ? &dv : NULL);
                }

                if ((LastFontLoaded == -1) &&
                    /*
                     * Compare with the font file name from Registry.
                     */
                    (!_wcsnicmp(szFontFile, szPreloadFontFile, wcslen(szPreloadFontFile))) &&
                    (bPermanent)) {

                    /*
                     * On the first time through only load up until
                     * ms sans serif for winlogon to use. Later we
                     * will spawn off a thread which loads the remaining
                     * fonts in the background.
                     */
                    LastFontLoaded = cFont;

                    ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
                    return TRUE;
                }
            }

            /*
             * Skip to the next key.
             */
            while (*pchSrch++) {
                /* do nothing */;
            }

            cFont += 1;
        } while (pchSrch < ((LPWSTR)pchKeys + cchReal));
    }

    /*
     * signal that all the permanent fonts have been loaded
     */
    bPermanentFontsLoaded = TRUE;

    ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);

    if (!bPermanent) {
        SET_PUDF(PUDF_FONTSARELOADED);
    }

    return TRUE;
}

extern VOID CloseFNTCache(VOID);

/***************************************************************************\
* xxxLW_LoadFonts
*
*
* History:
\***************************************************************************/
VOID xxxLW_LoadFonts(
    BOOL bRemote)
{
    BOOL bTimeOut = FALSE;

    if (bRemote) {
        LARGE_INTEGER li;
        ULONG         ulWaitCount = 0;

        /*
         * Before we can proceed we must make sure that all the permanent
         * fonts  have been loaded.
         */

        while (!bPermanentFontsLoaded) {
            if (!gbRemoteSession || ulWaitCount < MAX_TIME_OUT) {
                LeaveCrit();
                li.QuadPart = (LONGLONG)-10000 * CMSSLEEP;
                KeDelayExecutionThread(KernelMode, FALSE, &li);
                EnterCrit();
            } else {
                bTimeOut = TRUE;
                break;
            }

            ulWaitCount++;
        }

        if (!bTimeOut) {
            if (!bEnumerateRegistryFonts(FALSE)) {
                return; // Nothing we can do.
            }

            // Add remote type 1 fonts.
            ClientLoadRemoteT1Fonts();
        }
    } else {
        xxxAddFontResourceW(L"marlett.ttf", AFRW_ADD_LOCAL_FONT,NULL);
        if (!bEnumerateRegistryFonts(TRUE)) {
            return; // Nothing we can do.
        }

        //
        // Add local type 1 fonts.
        // Only want to be called once, the second time after ms sans serif
        // was installed
        //
        if (bPermanentFontsLoaded) {
            ClientLoadLocalT1Fonts();

            // All the fonts loaded, we can close the FNTCache.
            CloseFNTCache();
        }

    }
}

/***************************************************************************\
* FinalUserInit
*
* History:
\***************************************************************************/
BOOL FinalUserInit(
    VOID)
{
    HBITMAP hbm;
    PPCLS   ppcls;

    gpDispInfo->hdcGray = GreCreateCompatibleDC(gpDispInfo->hdcScreen);

    if (gpDispInfo->hdcGray == NULL) {
        return FALSE;
    }

    GreSelectFont(gpDispInfo->hdcGray, ghFontSys);
    GreSetDCOwner(gpDispInfo->hdcGray, OBJECT_OWNER_PUBLIC);

    gpDispInfo->cxGray = gpsi->cxSysFontChar * GRAY_STRLEN;
    gpDispInfo->cyGray = gpsi->cySysFontChar + 2;
    gpDispInfo->hbmGray = GreCreateBitmap(gpDispInfo->cxGray, gpDispInfo->cyGray, 1, 1, 0L);

    if (gpDispInfo->hbmGray == NULL) {
        return FALSE;
    }

    GreSetBitmapOwner(gpDispInfo->hbmGray, OBJECT_OWNER_PUBLIC);

    hbm = GreSelectBitmap(gpDispInfo->hdcGray, gpDispInfo->hbmGray);
    GreSetTextColor(gpDispInfo->hdcGray, 0x00000000L);
    GreSelectBrush(gpDispInfo->hdcGray, gpsi->hbrGray);
    GreSetBkMode(gpDispInfo->hdcGray, OPAQUE);
    GreSetBkColor(gpDispInfo->hdcGray, 0x00FFFFFFL);

    /*
     * Setup menu animation dc for global menu state
     */
    if (MNSetupAnimationDC(&gMenuState)) {
        GreSetDCOwner(gMenuState.hdcAni, OBJECT_OWNER_PUBLIC);
    } else {
        RIPMSG0(RIP_WARNING, "FinalUserInit: MNSetupAnimationDC failed");
    }

    /*
     * Creation of the queue registers some bogus classes. Get rid
     * of them and register the real ones.
     */
    ppcls = &PpiCurrent()->pclsPublicList;
    while ((*ppcls != NULL) && !((*ppcls)->style & CS_GLOBALCLASS)) {
        DestroyClass(ppcls);
    }

    return TRUE;
}

/***************************************************************************\
* InitializeClientPfnArrays
*
* This routine gets called by the client to tell the kernel where
* its important functions can be located.
*
* 18-Apr-1995 JimA  Created.
\***************************************************************************/
NTSTATUS InitializeClientPfnArrays(
    CONST PFNCLIENT *ppfnClientA,
    CONST PFNCLIENT *ppfnClientW,
    CONST PFNCLIENTWORKER *ppfnClientWorker,
    HANDLE hModUser)
{
    static BOOL fHaveClientPfns = FALSE;

    /*
     * Remember client side addresses in this global structure. These are
     * always constant, so this is ok. Note that if either of the pointers
     * are invalid, the exception will be handled in the thunk and
     * fHaveClientPfns will not be set.
     */
    if (!fHaveClientPfns && ppfnClientA != NULL) {
        if (!ISCSRSS()) {
            RIPMSG0(RIP_WARNING, "InitializeClientPfnArrays failed !csrss");
            return STATUS_ACCESS_DENIED;
        }
        gpsi->apfnClientA = *ppfnClientA;
        gpsi->apfnClientW = *ppfnClientW;
        gpsi->apfnClientWorker = *ppfnClientWorker;

        gpfnwp[ICLS_BUTTON]  = gpsi->apfnClientW.pfnButtonWndProc;
        gpfnwp[ICLS_EDIT]  = gpsi->apfnClientW.pfnDefWindowProc;
        gpfnwp[ICLS_STATIC]  = gpsi->apfnClientW.pfnStaticWndProc;
        gpfnwp[ICLS_LISTBOX]  = gpsi->apfnClientW.pfnListBoxWndProc;
        gpfnwp[ICLS_SCROLLBAR]  = (PROC)xxxSBWndProc;
        gpfnwp[ICLS_COMBOBOX]  = gpsi->apfnClientW.pfnComboBoxWndProc;
        gpfnwp[ICLS_DESKTOP]  = (PROC)xxxDesktopWndProc;
        gpfnwp[ICLS_DIALOG]  = gpsi->apfnClientW.pfnDialogWndProc;
        gpfnwp[ICLS_MENU]  = (PROC)xxxMenuWindowProc;
        gpfnwp[ICLS_SWITCH]  = (PROC)xxxSwitchWndProc;
        gpfnwp[ICLS_ICONTITLE] = gpsi->apfnClientW.pfnTitleWndProc;
        gpfnwp[ICLS_MDICLIENT] = gpsi->apfnClientW.pfnMDIClientWndProc;
        gpfnwp[ICLS_COMBOLISTBOX] = gpsi->apfnClientW.pfnComboListBoxProc;
        gpfnwp[ICLS_TOOLTIP] = (PROC)xxxTooltipWndProc;

        /*
         * Change this assert when new classes are added.
         */
        UserAssert(ICLS_MAX == ICLS_GHOST + 1);

        hModClient = hModUser;
        fHaveClientPfns = TRUE;
    }

    /*
     * Assert that user32.dll on the client side has loaded at the correct
     * address.
     */
    UserAssert(ppfnClientA == NULL ||
               gpsi->apfnClientA.pfnButtonWndProc == ppfnClientA->pfnButtonWndProc);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* GetKbdLangSwitch
*
* read the kbd language hotkey setting - if any - from the registry and set
* LangToggle[] appropriately.
*
* values are:
*              1 : VK_MENU     (this is the default)
*              2 : VK_CONTROL
*              3 : none
* History:
\***************************************************************************/
BOOL GetKbdLangSwitch(
    PUNICODE_STRING pProfileUserName)
{
    DWORD dwToggle;
    LCID  lcid;

    FastGetProfileIntW(pProfileUserName,
                                  PMAP_UKBDLAYOUTTOGGLE,
                                  TEXT("Hotkey"),
                                  1,
                                  &dwToggle,
                                  0);

    gbGraveKeyToggle = FALSE;

    switch (dwToggle) {
    case 4:
        /*
         * Grave accent keyboard switch for thai locales
         */
        ZwQueryDefaultLocale(FALSE, &lcid);
        gbGraveKeyToggle = (PRIMARYLANGID(lcid) == LANG_THAI) ? TRUE : FALSE;
        /*
         * fall through (intentional) and disable the ctrl/alt toggle mechanism
         */
    case 3:
        gLangToggle[0].bVkey = 0;
        gLangToggle[0].bScan = 0;
        break;

    case 2:
        gLangToggle[0].bVkey = VK_CONTROL;
        break;

    default:
        gLangToggle[0].bVkey = VK_MENU;
        break;
    }

    return TRUE;
}

/***************************************************************************\
* HideMouseTrails
*
* Hide the mouse trails one by one.
*
* History:
* 04-10-00 MHamid     Created.
\***************************************************************************/
VOID HideMouseTrails(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    if (gMouseTrailsToHide > 0) {
        if (InterlockedDecrement(&gMouseTrailsToHide) < gMouseTrails) {
            GreMovePointer(gpDispInfo->hDev, gpsi->ptCursor.x, gpsi->ptCursor.y,
                           MP_PROCEDURAL);
        }
    }

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
*
*  SetMouseTrails
*
*      n = 0,1 turn off mouse trails.
*      n > 1   turn on mouse trails (Trials = n-1).
*
\***************************************************************************/
VOID SetMouseTrails(
    UINT n)
{
    CheckCritIn();

    SetPointer(FALSE);
    gMouseTrails = n ? n-1 : n;
    SetPointer(TRUE);

    if (!IsRemoteConnection() && (!!gtmridMouseTrails ^ !!gMouseTrails)) {
        if (gMouseTrails) {
            /*
             * Create the gtmridMouseTrails timer in the desktop thread,
             * becuase if we creat it here it will get killed when the current
             * thread (App thread calling SPI_SETMOUSETRAILS) get destroied.
             */
            _PostMessage(gTermIO.ptiDesktop->pDeskInfo->spwnd, WM_CREATETRAILTIMER, 0, 0);
        } else {
            FindTimer(NULL, gtmridMouseTrails, TMRF_RIT, TRUE);
            gtmridMouseTrails = 0;
        }
    }
}

#ifdef IMM_PER_LOGON
extern BOOL IsIMMEnabledSystem(VOID);
extern BOOL IsCTFIMEEnabledSystem(VOID);

BOOL UpdatePerUserImmEnabling(
    VOID)
{
    /*
     * Update the IME enabling flag
     */
    SET_OR_CLEAR_SRVIF(SRVIF_IME, IsIMMEnabledSystem());
    RIPMSGF1(RIP_VERBOSE, "New Imm flag = %d", !!IS_IME_ENABLED());

    /*
     * Update the CTFIME enabling flag
     */
    SET_OR_CLEAR_SRVIF(SRVIF_CTFIME_ENABLED, IsCTFIMEEnabledSystem());
    RIPMSG1(RIP_VERBOSE, "_UpdatePerUserImmEnabling: new CTFIME flag = %d", !!IS_CICERO_ENABLED());

    return TRUE;
}
#endif

/***************************************************************************\
* xxxUpdatePerUserSystemParameters
*
* Called by winlogon to set Window system parameters to the current user's
* profile.
*
* 18-Sep-1992 IanJa     Created.
* 18-Nov-1993 SanfordS  Moved more winlogon init code to here for speed.
* 31-Mar-2001 Msadek    Changed parm from BOOL to flags for TS Slow Link
*                       Perf DCR.
* 02-Feb-2002 MMcCr     Added SPI_SETBLOCKSENDINPUTRESETS feature
\***************************************************************************/
BOOL xxxUpdatePerUserSystemParameters(
    DWORD  dwFlags)
{
    /*
     * NB - Any local variables that are used in appiPolicy must be initialized.
     * Otherwise, during a policy change, it is possible for them to be used w/o
     * being initialized and all heck breaks loose. Windows Bug #314150.
     */
    int             i;
    HANDLE          hKey;
    DWORD           dwFontSmoothing = GreGetFontEnumeration();
    DWORD           dwFontSmoothingContrast;
    DWORD           dwFontSmoothingOrientation;
    BOOL            fDragFullWindows = TEST_PUDF(PUDF_DRAGFULLWINDOWS);
    TL              tlName;
    PUNICODE_STRING pProfileUserName = NULL;
    DWORD           dwPolicyFlags = 0;
    DWORD           dwData;
    BOOL            bPolicyChange;
    BOOL            bUserLoggedOn;
    BOOL            bRemoteSettings;

    SPINFO spiPolicy[] = {
        { PMAP_DESKTOP,  SPI_SETBLOCKSENDINPUTRESETS, STR_BLOCKSENDINPUTRESETS, 0 },
        { PMAP_DESKTOP,  SPI_SETSCREENSAVETIMEOUT,    STR_SCREENSAVETIMEOUT,    0 },
        { PMAP_DESKTOP,  SPI_SETSCREENSAVEACTIVE,     STR_SCREENSAVEACTIVE,     0 },
        { PMAP_DESKTOP,  SPI_SETDRAGHEIGHT,           STR_DRAGHEIGHT,           4 },
        { PMAP_DESKTOP,  SPI_SETDRAGWIDTH,            STR_DRAGWIDTH,            4 },
        { PMAP_DESKTOP,  SPI_SETWHEELSCROLLLINES,     STR_WHEELSCROLLLINES,     3 },
    };

    SPINFO spiNotPolicy[] = {
        { PMAP_KEYBOARD, SPI_SETKEYBOARDDELAY,     STR_KEYDELAY,          0 },
        { PMAP_KEYBOARD, SPI_SETKEYBOARDSPEED,     STR_KEYSPEED,         15 },
        { PMAP_MOUSE,    SPI_SETDOUBLECLICKTIME,   STR_DBLCLKSPEED,     500 },
        { PMAP_MOUSE,    SPI_SETDOUBLECLKWIDTH,    STR_DOUBLECLICKWIDTH,  4 },
        { PMAP_MOUSE,    SPI_SETDOUBLECLKHEIGHT,   STR_DOUBLECLICKHEIGHT, 4 },
        { PMAP_MOUSE,    SPI_SETSNAPTODEFBUTTON,   STR_SNAPTO,            0 },
        { PMAP_WINDOWSU, SPI_SETMENUDROPALIGNMENT, STR_MENUDROPALIGNMENT, 0 },
        { PMAP_INPUTMETHOD, SPI_SETSHOWIMEUI,      STR_SHOWIMESTATUS,     1 },
    };

    PROFINTINFO apiiPolicy[] = {
        { PMAP_DESKTOP,  (LPWSTR)STR_MENUSHOWDELAY,       400, &gdtMNDropDown },
        { PMAP_DESKTOP,  (LPWSTR)STR_DRAGFULLWINDOWS,       2, &fDragFullWindows },
        { PMAP_DESKTOP,  (LPWSTR)STR_FASTALTTABROWS,        3, &gnFastAltTabRows },
        { PMAP_DESKTOP,  (LPWSTR)STR_FASTALTTABCOLUMNS,     7, &gnFastAltTabColumns },
        { PMAP_DESKTOP,  (LPWSTR)STR_MAXLEFTOVERLAPCHARS,   3, &(gpsi->wMaxLeftOverlapChars) },
        { PMAP_DESKTOP,  (LPWSTR)STR_MAXRIGHTOVERLAPCHARS,  3, &(gpsi->wMaxRightOverlapChars) },
        { PMAP_DESKTOP,  (LPWSTR)STR_FONTSMOOTHING,         0, &dwFontSmoothing },
        { 0,             NULL,                              0, NULL }
    };

    PROFINTINFO apiiNoPolicy[] = {
        { PMAP_MOUSE,       (LPWSTR)STR_MOUSETHRESH1, 6,  &gMouseThresh1 },
        { PMAP_MOUSE,       (LPWSTR)STR_MOUSETHRESH2, 10, &gMouseThresh2 },
        { PMAP_MOUSE,       (LPWSTR)STR_MOUSESPEED,   1,  &gMouseSpeed },
        { PMAP_INPUTMETHOD, (LPWSTR)STR_HEXNUMPAD,    0,  &gfEnableHexNumpad },
        { 0,                NULL,                     0,  NULL }
    };

    UserAssert(IsWinEventNotifyDeferredOK());

    bPolicyChange = dwFlags & UPUSP_POLICYCHANGE;
    bUserLoggedOn = dwFlags & UPUSP_USERLOGGEDON;
    bRemoteSettings = dwFlags & UPUSP_REMOTESETTINGS;

    /*
     * Make sure the caller is the logon process.
     */
    if (PsGetCurrentProcessId() != gpidLogon) {
        if (!bPolicyChange) {
            RIPMSG0(RIP_WARNING, "Access denied in xxxUpdatePerUserSystemParameters");
        }

        return FALSE;
    }

    pProfileUserName = CreateProfileUserName(&tlName);

    /*
     * If the desktop policy hasn't changed and we came here because we
     * thought it had, we're done.
     */
    if (bPolicyChange && !bRemoteSettings) {
        if (!CheckDesktopPolicyChange(pProfileUserName)) {
            FreeProfileUserName(pProfileUserName, &tlName);
            return FALSE;
        }
        dwPolicyFlags = POLICY_ONLY;
        UserAssert(!bUserLoggedOn);
    }

    /*
     * If new user is logging in, we need to recheck for
     * user policy changes.
     */
    if (bUserLoggedOn) {
        gdwPolicyFlags |= POLICY_USER;
    }

    /*
     * We don't want remote settings to be read all the time so spcify it here
     * if the caller wants to.Update it here since we do not save it in
     * gdwPolicyFlags [msadek].
     */
    if (bRemoteSettings) {
        dwPolicyFlags |= POLICY_REMOTE;
    }

    /*
     * Get the timeout for low level hooks from the registry.
     */
    dwData = 300;
    FastGetProfileValue(pProfileUserName,
                        PMAP_DESKTOP,
                        (LPWSTR)STR_LLHOOKSTIMEOUT,
                        (LPBYTE)&dwData,
                        (LPBYTE)&gnllHooksTimeout,
                        sizeof(int),
                        dwPolicyFlags);

    /*
     * Control Panel User Preferences.
     */
    LoadCPUserPreferences(pProfileUserName, dwPolicyFlags);

#ifdef LAME_BUTTON

    /*
     * Lame button text.
     */
    FastGetProfileValue(pProfileUserName,
                        PMAP_DESKTOP,
                        (LPWSTR)STR_LAMEBUTTONENABLED,
                        NULL,
                        (LPBYTE)&gdwLameFlags,
                        sizeof(DWORD),
                        dwPolicyFlags);
#endif  // LAME_BUTTON


    if (!bPolicyChange) {
        /*
         * Set syscolors from registry.
         */
        xxxODI_ColorInit(pProfileUserName);

        LW_LoadResources(pProfileUserName);

        /*
         * This is the initialization from Chicago.
         */
        xxxSetWindowNCMetrics(pProfileUserName, NULL, TRUE, -1); // Colors must be set first
        SetMinMetrics(pProfileUserName, NULL);
        SetIconMetrics(pProfileUserName, NULL);

        /*
         * Read the keyboard layout switching hot key.
         */
        GetKbdLangSwitch(pProfileUserName);

        /*
         * Set the default thread locale for the system based on the value
         * in the current user's registry profile.
         */
        ZwSetDefaultLocale( TRUE, 0 );

        /*
         * Set the default UI language based on the value in the current
         * user's registry profile.
         */
        ZwSetDefaultUILanguage(0);

        /*
         * And then Get it.
         */
        ZwQueryDefaultUILanguage(&(gpsi->UILangID));

        /*
         * Now load strings using the currnet UILangID.
         */
        xxxLoadSomeStrings();

        /*
         * Destroy the desktop system menus, so that they're recreated with
         * the correct UI language if the current user's UI language is
         * different from the previous one. This is done by finding the
         * interactive window station and destroying all its desktops's
         * system menus.
         */
        if (grpWinStaList != NULL) {
            PDESKTOP        pdesk;
            PMENU           pmenu;

            UserAssert(!(grpWinStaList->dwWSF_Flags & WSF_NOIO));
            for (pdesk = grpWinStaList->rpdeskList; pdesk != NULL; pdesk = pdesk->rpdeskNext) {
                if (pdesk->spmenuSys != NULL) {
                    pmenu = pdesk->spmenuSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuSys)) {
                        _DestroyMenu(pmenu);
                    }
                }
                if (pdesk->spmenuDialogSys != NULL) {
                    pmenu = pdesk->spmenuDialogSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuDialogSys)) {
                        _DestroyMenu(pmenu);
                    }
                }
            }
        }

        xxxUpdateSystemCursorsFromRegistry(pProfileUserName);

        /*
         * now go set a bunch of random values from the win.ini file.
         */
        for (i = 0; i < ARRAY_SIZE(spiNotPolicy); i++) {
            if (FastGetProfileIntFromID(pProfileUserName,
                                    spiNotPolicy[i].idSection,
                                    spiNotPolicy[i].idRes,
                                    spiNotPolicy[i].def,
                                    &dwData,
                                    0)) {
                xxxSystemParametersInfo(spiNotPolicy[i].id, dwData, 0L, 0);
            }
        }

        FastGetProfileIntsW(pProfileUserName, apiiNoPolicy, 0);
    }

    /*
     * Reset desktop pattern now. Note no parameters. It just goes off
     * and reads the registry and sets the desktop pattern.
     */
    xxxSystemParametersInfo(SPI_SETDESKPATTERN, (UINT)-1, 0L, 0); // 265 version

    /*
     * Initialize IME show status
     */
    if (bUserLoggedOn) {
        gfIMEShowStatus = IMESHOWSTATUS_NOTINITIALIZED;
    }

    /*
     * Now go set a bunch of random values from the registry.
     */
    for (i = 0; i < ARRAY_SIZE(spiPolicy); i++) {
        if (FastGetProfileIntFromID(pProfileUserName,
                                spiPolicy[i].idSection,
                                spiPolicy[i].idRes,
                                spiPolicy[i].def,
                                &dwData,
                                dwPolicyFlags)) {
            xxxSystemParametersInfo(spiPolicy[i].id, dwData, 0L, 0);
        }
    }

    /*
     * Read profile integers and do any fixups.
     */
    FastGetProfileIntsW(pProfileUserName, apiiPolicy, dwPolicyFlags);

    if (gnFastAltTabColumns < 2) {
        gnFastAltTabColumns = 7;
    }

    if (gnFastAltTabRows < 1) {
        gnFastAltTabRows = 3;
    }

    /*
     * If this is the first time the user logs on, set the DragFullWindows
     * to the default. If we have an accelerated device, enable full drag.
     */
    if (fDragFullWindows == 2) {
        WCHAR szTemp[40], szDragFullWindows[40];

        SET_OR_CLEAR_PUDF(
                PUDF_DRAGFULLWINDOWS,
                GreGetDeviceCaps(gpDispInfo->hdcScreen, BLTALIGNMENT) == 0);

        if (bUserLoggedOn) {
            swprintf(szTemp, L"%d", TEST_BOOL_PUDF(PUDF_DRAGFULLWINDOWS));

            ServerLoadString(hModuleWin,
                             STR_DRAGFULLWINDOWS,
                             szDragFullWindows,
                             ARRAY_SIZE(szDragFullWindows));

            FastWriteProfileStringW(pProfileUserName,
                                    PMAP_DESKTOP,
                                    szDragFullWindows,
                                    szTemp);
        }
    } else {
        SET_OR_CLEAR_PUDF(PUDF_DRAGFULLWINDOWS, fDragFullWindows);
    }

    /*
     * !!!LATER!!! (adams) See if the following profile retrievals can't
     * be done in the "spi" array above (e.g. SPI_SETSNAPTO).
     */

    /*
     * For remote connections or remote assistance, we may not want a
     * blinking caret for perf reasons. So, we try to read the value from
     * the registry, if there is one set. If nothing is set, we will
     * default to whatever is on desktop.
     */
    dwData = gpsi->dtCaretBlink;

    if (FastGetProfileIntFromID(pProfileUserName,
                                PMAP_DESKTOP,
                                STR_BLINK,
                                500,
                                &dwData,
                                bRemoteSettings? dwPolicyFlags : bPolicyChange)) {
        _SetCaretBlinkTime(dwData);
    }

    if (!bPolicyChange) {
        /*
         * Set mouse settings
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSESENSITIVITY, MOUSE_SENSITIVITY_DEFAULT, &gMouseSensitivity, 0);

        if ((gMouseSensitivity < MOUSE_SENSITIVITY_MIN) || (gMouseSensitivity > MOUSE_SENSITIVITY_MAX)) {
            gMouseSensitivity = MOUSE_SENSITIVITY_DEFAULT;
        }
        gMouseSensitivityFactor = CalculateMouseSensitivity(gMouseSensitivity);

#ifdef SUBPIXEL_MOUSE
        ReadDefaultAccelerationCurves(pProfileUserName);
        ResetMouseAccelerationCurves();
#endif

        /*
         * Set mouse trails.
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSETRAILS, 0, &dwData, 0);
        SetMouseTrails(dwData);

        /*
         * Font Information
         */
        FastGetProfileIntW(pProfileUserName, PMAP_TRUETYPE, TEXT("TTOnly"), FALSE, &dwData, 0);
        GreSetFontEnumeration(dwData);

        /*
         * Window animation
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_METRICS, STR_MINANIMATE, TRUE, &dwData, 0);
        SET_OR_CLEAR_PUDF(PUDF_ANIMATE, dwData);

        /*
         * Mouse tracking variables
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSEHOVERWIDTH, SYSMET(CXDOUBLECLK), &gcxMouseHover, 0);
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSEHOVERHEIGHT, SYSMET(CYDOUBLECLK), &gcyMouseHover, 0);
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSEHOVERTIME, gdtMNDropDown, &gdtMouseHover, 0);
    }

    /*
     * Initial Keyboard state:  ScrollLock, NumLock and CapsLock state;
     * global (per-user) kbd layout attributes (such as ShiftLock/CapsLock)
     */
    if (!bPolicyChange) {
        UpdatePerUserKeyboardIndicators(pProfileUserName);
        UpdatePerUserKeyboardMappings(pProfileUserName);
        FastGetProfileDwordW(pProfileUserName, PMAP_UKBDLAYOUT, L"Attributes", 0, &gdwKeyboardAttributes, 0);
        gdwKeyboardAttributes = KLL_GLOBAL_ATTR_FROM_KLF(gdwKeyboardAttributes);

        xxxUpdatePerUserAccessPackSettings(pProfileUserName);
    }

    /*
     * If we successfully opened this, we assume we have a network.
     */
    if (hKey = OpenCacheKeyEx(NULL, PMAP_NETWORK, KEY_READ, NULL)) {
        RIPMSG0(RIP_WARNING | RIP_NONAME, "");
        SYSMET(NETWORK) = RNC_NETWORKS;

        ZwClose(hKey);
    }

    SYSMET(NETWORK) |= RNC_LOGON;

    /*
     * Font smoothing
     */

    /* clear the flags from what could have been set for the previous user */
    GreSetFontEnumeration(FE_SET_AA);
    GreSetFontEnumeration(FE_SET_CT);

    if (dwFontSmoothing & FE_AA_ON)
        GreSetFontEnumeration( dwFontSmoothing | FE_SET_AA );

    if (UPDWORDValue(SPI_GETFONTSMOOTHINGTYPE) & FE_FONTSMOOTHINGCLEARTYPE)
        GreSetFontEnumeration( dwFontSmoothing | FE_SET_CT | FE_CT_ON);

    dwFontSmoothingContrast = UPDWORDValue(SPI_GETFONTSMOOTHINGCONTRAST);

    if (dwFontSmoothingContrast == 0)
        dwFontSmoothingContrast = DEFAULT_CT_CONTRAST;

    GreSetFontContrast(dwFontSmoothingContrast);

    dwFontSmoothingOrientation = UPDWORDValue(SPI_GETFONTSMOOTHINGORIENTATION);

    GreSetLCDOrientation(dwFontSmoothingOrientation);

    /*
     * Desktop Build Number Painting
     */
    if (USER_SHARED_DATA->SystemExpirationDate.QuadPart || gfUnsignedDrivers) {
        gdwCanPaintDesktop = 1;
    } else {
         FastGetProfileDwordW(pProfileUserName, PMAP_DESKTOP, L"PaintDesktopVersion", 0, &gdwCanPaintDesktop, dwPolicyFlags);
    }

    if (!bPolicyChange) {
        FastGetProfileStringW(pProfileUserName,
                              PMAP_WINLOGON,
                              TEXT("DefaultUserName"),
                              TEXT("Unknown"),
                              gszUserName,
                              ARRAY_SIZE(gszUserName),
                              0);
        FastGetProfileStringW(pProfileUserName,
                              PMAP_WINLOGON,
                              TEXT("DefaultDomainName"),
                              TEXT("Unknown"),
                              gszDomainName,
                              ARRAY_SIZE(gszDomainName),
                              0);
        FastGetProfileStringW(pProfileUserName,
                              PMAP_COMPUTERNAME,
                              TEXT("ComputerName"),
                              TEXT("Unknown"),
                              gszComputerName,
                              ARRAY_SIZE(gszComputerName),
                              0);
    }
    FreeProfileUserName(pProfileUserName, &tlName);

    /*
     * Do this if we are here for real policy change
     * i.e. not a remote settings policy change.
     */
    if (dwFlags == UPUSP_POLICYCHANGE) {
        xxxUserResetDisplayDevice();
    }

    return TRUE;
}

/*
 * Called by InitOemXlateTables via SFI_INITANSIOEM
 */
VOID InitAnsiOem(PCHAR pOemToAnsi, PCHAR pAnsiToOem)
{
    UserAssert(gpsi != NULL);
    UserAssert(pOemToAnsi != NULL);
    UserAssert(pAnsiToOem != NULL);

    try {
        ProbeForRead(pOemToAnsi, NCHARS, sizeof(BYTE));
        ProbeForRead(pAnsiToOem, NCHARS, sizeof(BYTE));

        RtlCopyMemory(gpsi->acOemToAnsi, pOemToAnsi, NCHARS);
        RtlCopyMemory(gpsi->acAnsiToOem, pAnsiToOem, NCHARS);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }
}

/***************************************************************************\
* RegisterLPK
*
* Called by InitializeLpkHooks on the client side after an LPK is
* loaded for the current process.
*
* 05-Nov-1996 GregoryW  Created.
\***************************************************************************/
VOID RegisterLPK(
    DWORD dwLpkEntryPoints)
{
    PpiCurrent()->dwLpkEntryPoints = dwLpkEntryPoints;
}

/***************************************************************************\
* Enforce color-depth dependent settings on systems with less
* then 256 colors.
*
* 2/13/1998   vadimg          created
\***************************************************************************/
VOID EnforceColorDependentSettings(VOID)
{
    if (gpDispInfo->fAnyPalette) {
        gbDisableAlpha = TRUE;
    } else if (GreGetDeviceCaps(gpDispInfo->hdcScreen, NUMCOLORS) == -1) {
        gbDisableAlpha = FALSE;
    } else {
        gbDisableAlpha = TRUE;
    }
}

#if DBG
VOID InitGlobalThreadLockArray(
    DWORD dwIndex)
{
    PTL pTLArray = gpaThreadLocksArrays[dwIndex];
    int i;

    for (i = 0; i < MAX_THREAD_LOCKS - 1; i++) {
        pTLArray[i].next = &pTLArray[i + 1];
    }

    pTLArray[MAX_THREAD_LOCKS - 1].next = NULL;
}
#endif


/***************************************************************************\
* CheckLUIDDosDevicesEnabled
*
* Checks if LUID DosDevices are Enabled.
*
* 8/20/2000   ELi          created
\***************************************************************************/
VOID CheckLUIDDosDevicesEnabled(
    PBOOL pResult)
{
    ULONG LUIDDeviceMapsEnabled;
    NTSTATUS Status;

    UserAssert(pResult != NULL);

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessLUIDDeviceMapsEnabled,
                                       &LUIDDeviceMapsEnabled,
                                       sizeof(LUIDDeviceMapsEnabled),
                                       NULL);
    if (NT_SUCCESS(Status)) {
        *pResult = (LUIDDeviceMapsEnabled != 0);
    } else {
        *pResult = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of the input sub-system
*
* History:
* 10-18-90 DavidPe      Created.
* 02-14-91 mikeke       Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

//#define MARKPATH
#ifdef MARKPATH
BOOL gfMarkPath;
#endif

#define IsOnInputDesktop(pti) (pti->rpdesk == grpdeskRitInput)

#if DBG

int  gnSysPeekSearch;

VOID CheckPtiSysPeek(
    int where, PQ pq,
    ULONG_PTR newIdSysPeek)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    DWORD dwRip;

    dwRip = (newIdSysPeek > 1) ? RIP_THERESMORE : 0;
    TAGMSG5(DBGTAG_SysPeek | dwRip,
            "%d pti %#p sets id %#p to pq %#p ; old id %#p",
            where, ptiCurrent, newIdSysPeek, pq, pq->idSysPeek);

    if (newIdSysPeek > 1) {
        PQMSG pqmsg = (PQMSG)newIdSysPeek;
        TAGMSG5(DBGTAG_SysPeek | RIP_NONAME,
                "-> msg %lx hwnd %#p w %#p l %#p pti %#p",
                pqmsg->msg.message, pqmsg->msg.hwnd,  pqmsg->msg.wParam,
                pqmsg->msg.lParam,  pqmsg->pti);
    }
}

VOID CheckSysLock(
    int where,
    PQ pq,
    PTHREADINFO ptiSysLock)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    TAGMSG5(DBGTAG_SysPeek,
            "%d pti 0x%p sets ptiSL 0x%p to pq 0x%p ; old ptiSL 0x%p",
            where,
            ptiCurrent,
            ptiSysLock,
            pq,
            pq->ptiSysLock);
}
#endif

#if DBG
BOOL gfLogPlayback;

LPCSTR aszMouse[] = {
    "WM_MOUSEMOVE",
    "WM_LBUTTONDOWN",
    "WM_LBUTTONUP",
    "WM_LBUTTONDBLCLK",
    "WM_RBUTTONDOWN",
    "WM_RBUTTONUP",
    "WM_RBUTTONDBLCLK",
    "WM_MBUTTONDOWN",
    "WM_MBUTTONUP",
    "WM_MBUTTONDBLCLK"
    "WM_MOUSEWHEEL",
    "WM_XBUTTONDOWN",
    "WM_XBUTTONUP",
    "WM_XBUTTONDBLCLK",
};
LPCSTR aszKey[] = {
    "WM_KEYDOWN",
    "WM_KEYUP",
    "WM_CHAR",
    "WM_DEADCHAR",
    "WM_SYSKEYDOWN",
    "WM_SYSKEYUP",
    "WM_SYSCHAR",
    "WM_SYSDEADCHAR",
    "WM_CONVERTREQUESTEX",
    "WM_YOMICHAR",
    "WM_UNICHAR"
};
#endif  // DBG

#define CANCEL_ACTIVESTATE  0
#define CANCEL_FOCUSSTATE   1
#define CANCEL_CAPTURESTATE 2

#define KEYSTATESIZE    (CBKEYSTATE + CBKEYSTATERECENTDOWN)


/*
 * xxxGetNextSysMsg return values
 */
#define PQMSG_PLAYBACK       ((PQMSG)1)

BOOL xxxScanSysQueue(PTHREADINFO ptiCurrent, LPMSG lpMsg, PWND pwndFilter,
        UINT msgMinFilter, UINT msgMaxFilter, DWORD flags, DWORD fsReason);
BOOL xxxReadPostMessage(PTHREADINFO pti, LPMSG lpMsg, PWND pwndFilter,
        UINT msgMin, UINT msgMax, BOOL fRemoveMsg);
void CleanEventMessage(PQMSG pqmsg);

#ifdef MESSAGE_PUMP_HOOK

/***************************************************************************\
* xxxWaitMessageEx (API)
*
* This API will block until an input message is received on
* the current queue.
*
* History:
* 10-25-1990    DavidPe     Created.
* 06-12-2000    JStall      Changed to "Ex"
\***************************************************************************/
BOOL xxxWaitMessageEx(
    UINT fsWakeMask,
    DWORD Timeout)
{
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;

    if (IsInsideMPH()) {
        /*
         * This thread is has MPH's installed, so we need to callback into User
         * mode to allow the application to provide an implementation
         */

        return ClientWaitMessageExMPH(fsWakeMask, Timeout);
    } else {
        /*
         * This thread does not have any MPH's installed, so we can just
         * directly process.
         */

        return xxxRealWaitMessageEx(fsWakeMask, Timeout);
    }
}


BOOL xxxRealWaitMessageEx(
    UINT fsWakeMask,
    DWORD Timeout)
{
    return xxxSleepThread(fsWakeMask, Timeout, TRUE);
}

#else // MESSAGE_PUMP_HOOK

/***************************************************************************\
* xxxWaitMessage (API)
*
* This API will block until an input message is received on
* the current queue.
*
* History:
* 10-25-90 DavidPe      Created.
\***************************************************************************/
BOOL xxxWaitMessage(
    VOID)
{
    return xxxSleepThread(QS_ALLINPUT | QS_EVENT, 0, TRUE);
}

#endif // MESSAGE_PUMP_HOOK


/***************************************************************************\
* CheckProcessBackground/Foreground
*
* This checks to see if the process is at the right priority. If CSPINS is
* greater than CSPINBACKGROUND and the process isn't at the background
* priority, put it there. If it is less than this and should be foreground
* and isn't put it there.
*
* Need to put foreground spinning apps in the background (make it the same
* priority as all other background apps) so that bad apps can still communicate
* with apps in the background via dde, for example. There are other cases
* where spinning foreground apps affect the server, the printer spooler, and
* mstest scenarios. On Win3.1, calling PeekMessage() involves making a trip
* through the scheduler, forcing other apps to run. Processes run with
* priority on NT, where the foreground process gets foreground priority for
* greater responsiveness.
*
* If an app calls peek/getmessage without idling, count how many times this
* happens - if it happens CSPINBACKGROUND or more times, make the process
* background. This handles most of the win3.1 app compatibility spinning
* cases. If there is no priority contention, the app continues to run at
* full speed (no performance scenarios should be adversely affected by this).
*
* This solves these cases:
*
* - high speed timer not allowing app to go idle
* - post/peek loop (receiving a WM_ENTERIDLE, and posting a msg, for example)
* - peek no remove loop (winword "idle" state, most dde loops, as examples)
*
* But doesn't protect against these sort of cases:
*
* - app calls getmessage, then goes into a tight loop
* - non-gui threads in tight cpu loops
*
* 02-08-93 ScottLu      Created.
\***************************************************************************/

NTSTATUS CheckProcessForeground(
    PTHREADINFO pti)
{
    PTHREADINFO ptiT;

    /*
     * Check to see if we need to move this process into foreground
     * priority.
     */
    try {
        pti->pClientInfo->cSpins = 0;
        pti->pClientInfo->dwTIFlags = pti->TIF_flags & ~TIF_SPINNING;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return GetExceptionCode();
    }
    pti->TIF_flags &= ~TIF_SPINNING;

    if (pti->ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY) {
        /*
         * See if any thread of this process is spinning. If none
         * are, we can remove the force to background.
         */
        for (ptiT = pti->ppi->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {
            if (ptiT->TIF_flags & TIF_SPINNING)
                return STATUS_SUCCESS;
        }

        pti->ppi->W32PF_Flags &= ~W32PF_FORCEBACKGROUNDPRIORITY;
        if (pti->ppi == gppiWantForegroundPriority) {
            SetForegroundPriority(pti, TRUE);
        }
    }
    return STATUS_SUCCESS;
}

/***************************************************************************\
* xxxInternalGetMessage
*
* This routine is the worker for both xxxGetMessage() and xxxPeekMessage()
* and is modelled after its win3.1 counterpart. From Win3.1:
*
* Get msg from the app queue or sys queue if there is one that matches
* hwndFilter and matches msgMin/msgMax. If no messages in either queue, check
* the QS_PAINT and QS_TIMER bits, call DoPaint or DoTimer to Post the
* appropriate message to the application queue, and then Read that message.
* Otherwise, if in GetMessage, Sleep until a wake bit is set indicating there
* is something we need to do.  If in PeekMessage, return to caller. Before
* reading messages from the queues, check to see if the QS_SENDMESSAGE bit
* is set, and if so, call ReceiveMessage().
*
* New for NT5: HIWORD(flags) contains a wake mask provided by the caller.
*   This mask is passed to CalcWakeMask to be combined with the mask generated
*   from msgMin and MsgMax. The default mask includes QS_SENDMESSAGE
*   now; we won't call xxxReceiveMessages (directly) unless this bit is set;
*   however, to avoid potentail deadlocks and maintain NT4 compatibility as
*   much as possible, we fail the call if QS_SENDMESSAGE is set in fsWakeBits
*   but not requested by the caller. The same applies to QS_EVENT which we would
*   always process in NT4.
*
*
* 10-19-92 ScottLu      Created.
\***************************************************************************/

#ifdef MARKPATH
#define PATHTAKEN(x)  pathTaken  |= x
#define DUMPPATHTAKEN() if (gfMarkPath) DbgPrint("xxxInternalGetMessage path:%08x\n", pathTaken)
#else
#define PATHTAKEN(x)
#define DUMPPATHTAKEN()
#endif


BOOL xxxInternalGetMessage(
    LPMSG lpMsg,
    HWND hwndFilter,
    UINT msgMin,
    UINT msgMax,
    UINT flags,
    BOOL fGetMessage)
{
#ifdef MESSAGE_PUMP_HOOK
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;

    if (IsInsideMPH()) {
        /*
         * This thread has MPH's installed, so we need to callback into User
         * mode to allow the application to provide an implementation
         */
        return ClientGetMessageMPH(lpMsg, hwndFilter, msgMin, msgMax, flags, fGetMessage);
    } else {
        /*
         * This thread does not have any MPH's installed, so we can just
         * directly process.
         */
        return xxxRealInternalGetMessage(lpMsg, hwndFilter, msgMin, msgMax, flags, fGetMessage);
    }
}


BOOL xxxRealInternalGetMessage(
    LPMSG lpMsg,
    HWND hwndFilter,
    UINT msgMin,
    UINT msgMax,
    UINT flags,
    BOOL fGetMessage)
{
#endif MESSAGE_PUMP_HOOK
    UINT fsWakeBits;
    UINT fsWakeMask;
    UINT fsRemoveBits;
    PTHREADINFO ptiCurrent;
    PW32PROCESS W32Process;
    PWND pwndFilter;
    BOOL fLockPwndFilter;
    TL tlpwndFilter;
    BOOL fRemove;
    BOOL fExit;
    PQ pq;
#ifdef MARKPATH
    DWORD pathTaken = 0;
#endif
    BOOL  bBackground;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    ptiCurrent = PtiCurrent();

    /*
     * PeekMessage accepts NULL, 0x0000FFFF, and -1 as valid HWNDs.
     * If hwndFilter is invalid we can't just return FALSE because that will
     * hose existing badly behaved apps who might attempt to dispatch
     * the random contents of pmsg.
     */
    if ((hwndFilter == (HWND)-1) || (hwndFilter == (HWND)0x0000FFFF)) {
        hwndFilter = (HWND)1;
    }

    if ((hwndFilter != NULL) && (hwndFilter != (HWND)1)) {
        if ((pwndFilter = ValidateHwnd(hwndFilter)) == NULL) {
            lpMsg->hwnd = NULL;
            lpMsg->message = WM_NULL;
            PATHTAKEN(1);
            DUMPPATHTAKEN();
            if (fGetMessage)
                return -1;
            else
                return 0;
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwndFilter, &tlpwndFilter);
        fLockPwndFilter = TRUE;

    } else {
        pwndFilter = (PWND)hwndFilter;
        fLockPwndFilter = FALSE;
    }

    /*
     * Add one to our spin count. At this end of this routine we'll check
     * to see if the spin count gets >= CSPINBACKGROUND. If so we'll put this
     * process into the background.
     */
    try {
        ptiCurrent->pClientInfo->cSpins++;
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return -1;
    }

    /*
     * Check to see if the startglass is on, and if so turn it off and update.
     */
    W32Process = W32GetCurrentProcess();
    if (W32Process->W32PF_Flags & W32PF_STARTGLASS) {

        /*
         * This app is no longer in "starting" mode. Recalc when to hide
         * the app starting cursor.
         */
        W32Process->W32PF_Flags &= ~W32PF_STARTGLASS;
        /*
         * Don't need DeferWinEventNotify() - xxxDoSysExpunge below doesn't
         */
        zzzCalcStartCursorHide(NULL, 0);
    }

    /*
     * Next check to see if any .dlls need freeing in
     * the context of this client (used for windows hooks).
     */
    if (ptiCurrent->ppi->cSysExpunge != gcSysExpunge) {
        ptiCurrent->ppi->cSysExpunge = gcSysExpunge;
        if (ptiCurrent->ppi->dwhmodLibLoadedMask & gdwSysExpungeMask)
            xxxDoSysExpunge(ptiCurrent);
    }

    /*
     * Set up BOOL fRemove local variable from for ReadMessage()
     */
    fRemove = flags & PM_REMOVE;

    /*
     * Unlock the system queue if it's owned by us.
     */
    /*
     * If we're currently processing a message, unlock the input queue
     * because the sender, who is blocked, might be the owner, and in order
     * to reply, the receiver may need to read keyboard / mouse input.
     */
    /*
     * If this thread has the input queue locked and the last message removed
     * is the last message we looked at, then unlock - we're ready for anyone
     * to get the next message.
     */
    pq = ptiCurrent->pq;
    if (   (ptiCurrent->psmsCurrent != NULL)
        || (pq->ptiSysLock == ptiCurrent && pq->idSysLock == ptiCurrent->idLast)
       ) {
        CheckSysLock(1, pq, NULL);
        pq->ptiSysLock = NULL;
        PATHTAKEN(2);
    } else if (pq->ptiSysLock
                && (pq->ptiSysLock->cVisWindows == 0)
                && (PhkFirstGlobalValid(ptiCurrent, WH_JOURNALPLAYBACK) != NULL)) {
        /*
         * If the thread that has the system queue lock has no windows visible
         * (can happen if it just hid its last window), don't expect it to call
         * GetMessage() again! - unlock the system queue. --- ScottLu
         * This condition creates a hole by which a second thread attached to
         * the same queue as thread 1 can alter pq->idSysPeek during a callback
         * made by thread 1 so that thread 1 will delete the wrong message
         * (losing keystrokes - causing Shift to appear be stuck down editing a
         * Graph5 caption embedded in Word32 document #5032.  However, MSTEST
         * requires this hole, so allow it if Journal Playback is occurring
         * #8850 (yes, a hack)  Chicago also has this behavior.  --- IanJa
         */
        CheckSysLock(2, pq, NULL);
        pq->ptiSysLock = NULL;
        PATHTAKEN(3);
    }
    if (pq->ptiSysLock != ptiCurrent) {
        ptiCurrent->pcti->CTIF_flags &= ~CTIF_SYSQUEUELOCKED;
    }

    /*
     * If msgMax == 0 then msgMax = -1: that makes our range checking only
     * have to deal with msgMin < msgMax.
     */
    if (msgMax == 0)
        msgMax--;

    /*
     * Compute the QS* mask that corresponds to the message range
     *  and the wake mask filter (HIWORD(flags))
     */
    fsWakeMask = CalcWakeMask(msgMin, msgMax, HIWORD(flags));
    ptiCurrent->fsChangeBitsRemoved = 0;

    /*
     * If we can yield and one or more events were skipped,
     * set the wakebits for event
     */
    if (!(flags & PM_NOYIELD) && ptiCurrent->TIF_flags & TIF_DELAYEDEVENT) {

        try {
            ptiCurrent->pClientInfo->dwTIFlags = ptiCurrent->TIF_flags & ~TIF_DELAYEDEVENT;
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
              return -1;
        }
        ptiCurrent->pcti->fsWakeBits |= QS_EVENT;
        ptiCurrent->pcti->fsChangeBits |= QS_EVENT;
        ptiCurrent->TIF_flags &= ~TIF_DELAYEDEVENT;
    }

    while (TRUE) {

        /*
         * Restore any wake bits saved while journalling
         */
        ptiCurrent->pcti->fsWakeBits |= ptiCurrent->pcti->fsWakeBitsJournal;

        /*
         * If we need to recalc queue attachments, do it here. Do it on the
         * right desktop or else the queues will get created in the wrong
         * heap.
         */
        if (ptiCurrent->rpdesk == gpdeskRecalcQueueAttach) {
            gpdeskRecalcQueueAttach = NULL;

            if (ptiCurrent->rpdesk != NULL && !FJOURNALRECORD() && !FJOURNALPLAYBACK()) {
                /*
                 * No need to DeferWinEventNotify(): a call to
                 * xxxReceiveMessages is made just below
                 */
                zzzReattachThreads(FALSE);
                PATHTAKEN(4);
            }
        }

        /*
         * Remember what change bits we're clearing. This is important to
         * fix a bug in the input model: If an app receives a sent message
         * from within SleepThread(), then does PostMessage() (which sets
         * QS_POSTMESSAGE), then does a PeekMessage(...) for some different
         * posted message (clears QS_POSTMESSAGE in fsChangeBits), then returns
         * back into SleepThread(), it won't wake up to retrieve that newly
         * posted message because the change bits are cleared.
         *
         * What we do is remember the change bits that are being cleared.
         * Then, when we return to SleepThread(), we put these remembered
         * bits back into the change bits that also have corresponding
         * bits in the wakebits (so we don't set changebits that represent
         * input that isn't there anymore). This way, the app will retrieve
         * the newly posted message refered to earlier.
         * - scottlu
         *
         * New for NT5: Since QS_SENDMESSAGE was never set it fsWakeMask before (NT4),
         *  it was never cleared from fsChangeBits. For compatibility, we won't clear
         *  it now even if specified in fsWakeMask; hence we won't affect any one
         *  checking for QS_SENDMESSAGE in pcti->fsChangeBits.
         */
        fsRemoveBits = fsWakeMask & ~QS_SENDMESSAGE;
        ptiCurrent->fsChangeBitsRemoved |= ptiCurrent->pcti->fsChangeBits & fsRemoveBits;

        /*
         * Clear the change bits that we're looking at, in order to detect
         * incoming events that may occur the last time we checked the wake
         * bits.
         */
        ptiCurrent->pcti->fsChangeBits &= ~fsRemoveBits;

        /*
         * Check for sent messages. Check the the actual wake bits (i.e, from pcti)
         *  so we know for real.
         */
        if (ptiCurrent->pcti->fsWakeBits & fsWakeMask & QS_SENDMESSAGE) {
            xxxReceiveMessages(ptiCurrent);
        } else if (ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
            RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(1st test) sendmsgs pending. Bits:%#lx Mask:%#lx",
                        ptiCurrent->pcti->fsWakeBits, fsWakeMask);
            goto NoMessages;
        }

        /*
         * Check to see if we have any input we want.
         */
        if ((ptiCurrent->pcti->fsWakeBits & fsWakeMask) == 0) {
            PATHTAKEN(8);
            goto NoMessages;
        }
        fsWakeBits = ptiCurrent->pcti->fsWakeBits;

        /*
         * If the queue lock is != NULL (ptiSysLock) and it is this thread that
         * locked it, then go get the message from the system queue. This is
         * to prevent messages posted after a PeekMessage/no-remove from being
         * seen before the original message from the system queue. (Aldus
         * Pagemaker requires this) (bobgu 8/5/87).
         */
        if (ptiCurrent->pq->ptiSysLock == ptiCurrent &&
                (ptiCurrent->pq->QF_flags & QF_LOCKNOREMOVE)) {
            /*
             * Does the caller want mouse / keyboard?
             */
            if (fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT)) {

                /*
                 * It should never get here during exit.
                 */
                UserAssert(gbExitInProgress == FALSE);

                if (xxxScanSysQueue(ptiCurrent, lpMsg, pwndFilter,
                        msgMin, msgMax, flags,
                        fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT))) {

                    PATHTAKEN(0x10);
                    break;
                }
            } else if (fsWakeBits & QS_EVENT) {
                RIPMSG2(RIP_WARNING,
                    "xxxInternalGetMessage:(1st test)events pending. Bits:%#lx Mask:%#lx",
                    fsWakeBits, fsWakeMask);
                goto NoMessages;
            }
        }

        /*
         * See if there's a message in the application queue.
         */
        if (fsWakeBits & fsWakeMask & QS_POSTMESSAGE) {
            if (xxxReadPostMessage(ptiCurrent, lpMsg, pwndFilter,
                    msgMin, msgMax, fRemove)) {
                PATHTAKEN(0x20);
                break;
            }
        }

        /*
         * If pwndFilter == 1, this app was only interested in messages
         * that were posted via PostThreadMessage. Since we checked the
         * posted message queue above, let's skip doing needless work.
         */
        if (pwndFilter == (PWND)1) {
            goto NoMessages;
        }

        /*
         * Time to scan the raw input queue for input. First check to see
         * if the caller wants mouse / keyboard input.
         */
        if (fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT)) {

            /*
             * It should never get here during exit.
             */
            UserAssert(gbExitInProgress == FALSE);

            if (xxxScanSysQueue(ptiCurrent, lpMsg, pwndFilter,
                    msgMin, msgMax, flags,
                    fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT))) {
                PATHTAKEN(0x40);
                break;
            }
        } else if (fsWakeBits & QS_EVENT) {
            RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(2nd test)events pending. Bits:%#lx Mask:%#lx",
                        fsWakeBits, fsWakeMask);
            goto NoMessages;
        }

        /*
         * Check for sent messages. Check the the actual wake bits (i.e, from pcti)
         *  so we know for real.
         */
        if (ptiCurrent->pcti->fsWakeBits & fsWakeMask & QS_SENDMESSAGE) {
            xxxReceiveMessages(ptiCurrent);
        } else if (ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
            RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(2nd test)sendmsgs pending. Bits:%#lx Mask:%#lx",
                        ptiCurrent->pcti->fsWakeBits, fsWakeMask);
            goto NoMessages;
        }

        /*
         * Get new input bits.
         */
        if ((ptiCurrent->pcti->fsWakeBits & fsWakeMask) == 0) {
            PATHTAKEN(0x80);
            goto NoMessages;
        }
        fsWakeBits = ptiCurrent->pcti->fsWakeBits;

        /*
         * Does the caller want paint messages? If so, try to find a paint.
         */
        if (fsWakeBits & fsWakeMask & QS_PAINT) {
            if (xxxDoPaint(pwndFilter, lpMsg)) {
                PATHTAKEN(0x100);
                break;
            }
        }

        /*
         * We must yield for 16 bit apps before checking timers or an app
         * that has a fast timer could chew up all the time and never let
         * anyone else run.
         *
         * NOTE: This could cause PeekMessage() to yield TWICE, if the user
         * is filtering with a window handle. If the DoTimer() call fails
         * then we end up yielding again.
         */
        if (!(flags & PM_NOYIELD)) {
            /*
             * This is the point where windows would yield.  Here we wait to wake
             * up any threads waiting for this thread to hit "idle state".
             */
            zzzWakeInputIdle(ptiCurrent);

            /*
             * Yield and receive pending messages.
             */
            xxxUserYield(ptiCurrent);

            /*
             * Check new input buts and receive pending messages.
             */
            if (ptiCurrent->pcti->fsWakeBits & fsWakeMask & QS_SENDMESSAGE) {
                xxxReceiveMessages(ptiCurrent);
            } else if (ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
                RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(3rd test) sendmsgs pending. Bits:%#lx Mask:%#lx",
                            ptiCurrent->pcti->fsWakeBits, fsWakeMask);
                goto NoMessages;
            }

            if ((ptiCurrent->pcti->fsWakeBits & fsWakeMask) == 0) {

                PATHTAKEN(0x200);
                goto NoMessages;
            }
            fsWakeBits = ptiCurrent->pcti->fsWakeBits;
        }

        /*
         * Does the app want timer messages, and if there one pending?
         */
        if (fsWakeBits & fsWakeMask & QS_TIMER) {
            if (DoTimer(pwndFilter)) {
                /*
                 * DoTimer() posted the message into the app's queue,
                 * so start over and we'll grab it from there.
                 */
                 PATHTAKEN(0x400);
                 continue;
            }
        }

NoMessages:
        /*
         * Looks like we have no input. If we're being called from GetMessage()
         * then go to sleep until we find something.
         */
        if (!fGetMessage) {
            /*
             * This is one last check for pending sent messages. It also
             * yields. Win3.1 does this.
             */
            if (!(flags & PM_NOYIELD)) {
                /*
                 * This is the point where windows yields. Here we wait to wake
                 * up any threads waiting for this thread to hit "idle state".
                 */
                zzzWakeInputIdle(ptiCurrent);

                /*
                 * Yield and receive pending messages.
                 */
                xxxUserYield(ptiCurrent);
            }
            PATHTAKEN(0x800);
            goto FalseExit;
        }

        /*
         * This is a getmessage not a peekmessage, so sleep. When we sleep,
         * zzzWakeInputIdle() is called to wake up any apps waiting on this
         * app to go idle.
         */
        if (!xxxSleepThread(fsWakeMask, 0, TRUE))
            goto FalseExit;
    } /* while (TRUE) */

    /*
     * If we're here then we have input for this queue. Call the
     * GetMessage() hook with this input.
     */
    if (IsHooked(ptiCurrent, WHF_GETMESSAGE))
        xxxCallHook(HC_ACTION, flags, (LPARAM)lpMsg, WH_GETMESSAGE);

    /*
     * If called from PeekMessage(), return TRUE.
     */
    if (!fGetMessage) {
        PATHTAKEN(0x1000);
        goto TrueExit;
    }

    /*
     * Being called from GetMessage(): return FALSE if the message is WM_QUIT,
     * TRUE otherwise.
     */
    if (lpMsg->message == WM_QUIT) {
        PATHTAKEN(0x2000);
        goto FalseExit;
    }

    /*
     * Fall through to TrueExit...
     */

TrueExit:
    /*
     * Update timeLastRead. We use this for hung app calculations.
     */
    SET_TIME_LAST_READ(ptiCurrent);
    fExit = TRUE;

#ifdef GENERIC_INPUT
    if (fRemove) {
        /*
         * This version simply frees the previous HIDDATA.
         */
        if (ptiCurrent->hPrevHidData) {
            PHIDDATA pPrevHidData = HMValidateHandleNoRip(ptiCurrent->hPrevHidData, TYPE_HIDDATA);

            TAGMSG1(DBGTAG_PNP, "xxxInternalGetMessage: WM_INPUT prev=%p", ptiCurrent->hPrevHidData);

            if (pPrevHidData) {
                FreeHidData(pPrevHidData);
            } else {
                RIPMSG1(RIP_WARNING, "xxxInternalGetMessage: WM_INPUT bogus hPrev=%p",
                        ptiCurrent->hPrevHidData);
            }

            ptiCurrent->hPrevHidData = NULL;
        }

        if (lpMsg->message == WM_INPUT) {
            if (lpMsg->wParam == RIM_INPUT
#ifdef GI_SINK
                || lpMsg->wParam == RIM_INPUTSINK
#endif
                ) {
                ptiCurrent->hPrevHidData = (HANDLE)lpMsg->lParam;

#if DBG
                {
                    PHIDDATA pHidData = HMValidateHandle((HANDLE)lpMsg->lParam, TYPE_HIDDATA);

                    TAGMSG1(DBGTAG_PNP, "xxxInternalGetMessage: WM_INPUT new=%p", PtoH(pHidData));
                    if (pHidData == NULL) {
                        RIPMSG2(RIP_WARNING, "xxxInternalGetMessage: WM_INPUT bogus parameter wp=%x, lp=%x",
                                lpMsg->wParam, lpMsg->lParam);
                    }
                }
#endif
            } else {
                RIPMSG1(RIP_WARNING, "xxxInternalGetMessage: WM_INPUT bogus wParam %x",
                        lpMsg->wParam);
            }
        }
    }
#endif
    PATHTAKEN(0x4000);
    goto Exit;

FalseExit:
    fExit = FALSE;

Exit:
    if (fLockPwndFilter)
        ThreadUnlock(&tlpwndFilter);

    /*
     * see CheckProcessBackground() comment above
     * Check to see if we need to move this process into background
     * priority.
     */
    try {
        bBackground = ((ptiCurrent->pClientInfo->cSpins >= CSPINBACKGROUND) != 0);
        if (bBackground) {
            ptiCurrent->pClientInfo->cSpins = 0;
            if (!(ptiCurrent->TIF_flags & TIF_SPINNING)) {
                ptiCurrent->pClientInfo->dwTIFlags = ptiCurrent->TIF_flags | TIF_SPINNING;
            }
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        fExit = FALSE;
        goto Error;
    }

    if (bBackground) {
        if (!(ptiCurrent->TIF_flags & TIF_SPINNING)) {

            ptiCurrent->TIF_flags |= TIF_SPINNING;

            if (!(ptiCurrent->ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY)) {

                ptiCurrent->ppi->W32PF_Flags |= W32PF_FORCEBACKGROUNDPRIORITY;

                if (ptiCurrent->ppi == gppiWantForegroundPriority) {
                    SetForegroundPriority(ptiCurrent, FALSE);
                }
            }
        }

        /*
         * For spinning Message loops, we need to take the 16bit-thread out
         * of the scheduler temporarily so that other processes can get a chance
         * to run.  This is appearent in OLE operations where a 16bit foreground
         * thread starts an OLE activation on a 32bit process.  The 32bit process
         * gets starved of CPU while the 16bit thread spins.
         */
        if (ptiCurrent->TIF_flags & TIF_16BIT) {

            /*
             * Take the 16bit thread out of the scheduler.  This wakes any
             * other 16bit thread needing time, and takes the current thread
             * out.  We will do a brief sleep so that apps can respond in time.
             * When done, we will reschedule the thread.  The zzzWakeInputIdle()
             * should have been called in the no-messages section, so we have
             * already set the Idle-Event.
             */
            xxxSleepTask(FALSE, HEVENT_REMOVEME);

            LeaveCrit();
            ZwYieldExecution();
            EnterCrit();

            xxxDirectedYield(DY_OLDYIELD);
        }
    }

Error:
    PATHTAKEN(0x8000);
    DUMPPATHTAKEN();
    return fExit;
}
#undef PATHTAKEN
#undef DUMPPATHTAKEN


__inline PTIMER FindSystemTimer(
    PMSG pmsg)
{
    PTIMER ptmr;
    const BOOL fWow64 =
#ifdef _WIN64
        PtiCurrent()->TIF_flags & TIF_WOW64;
#else
        FALSE;
#endif

    for (ptmr = gptmrFirst; ptmr; ptmr = ptmr->ptmrNext) {
        if (ptmr->flags & TMRF_SYSTEM) {
            if (pmsg->lParam == (LPARAM)ptmr->pfn) {
                return ptmr;
            }
            /*
             * 64bit only: lParam might be truncated, if the application is 32bit.
             * We do our best to pick up the right guy, by comparing the
             * lower 32bit in the pointer and the timer id.
             */
            if (fWow64 && (ULONG)pmsg->lParam == PtrToUlong(ptmr->pfn) && pmsg->wParam == ptmr->nID) {
                return ptmr;
            }
        }
    }
    return NULL;
}


/***************************************************************************\
* ValidateTimerCallback
*
* Checks if the timer callback (with lParam != 0) is legitimate,
* in order to avoid mulicious applications to break the other applications.
*
* History:
* 08-10-2002 Hiro   Created.
\***************************************************************************/

BOOL ValidateTimerCallback(
    PTHREADINFO pti,
    LPARAM pfnCallback)
{
    PTIMER pTimer;

    UserAssert(pti);

    /*
     * AppCompat: if the flag is set, skip the checking and allow
     * lParam based callbacks.
     */
    if (GetAppCompatFlags2ForPti(pti, VER51) & GACF2_NOTIMERCBPROTECTION) {
        /*
         * But we always protect CSRSS and WinLogon.
         */
        if ((pti->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)) == 0 &&
                PsGetProcessId(pti->ppi->Process) != gpidLogon) {
            return TRUE;
        }
    }

    for (pTimer = gptmrFirst; pTimer; pTimer = pTimer->ptmrNext) {
        /*
         * Is this the timer we're looking for?
         */
        if (pTimer->pti->ppi == pti->ppi &&
               (pTimer->flags & (TMRF_SYSTEM | TMRF_RIT)) == 0 &&
                pTimer->pfn == (TIMERPROC_PWND)pfnCallback) {
            /*
             * Found the timer, tell the caller so.
             */
            return TRUE;
        }
    }

    /*
     * No, we didn't find a matching timer.
     */
    return FALSE;
}


/***************************************************************************\
* xxxDispatchMessage (API)
*
* Calls the appropriate window procedure or function with pmsg.
*
* History:
* 10-25-90 DavidPe      Created.
\***************************************************************************/

LRESULT xxxDispatchMessage(
    LPMSG pmsg)
{
    LRESULT lRet;
    PWND pwnd;
    WNDPROC_PWND lpfnWndProc;
    TL tlpwnd;

    pwnd = NULL;
    if (pmsg->hwnd != NULL) {
        if ((pwnd = ValidateHwnd(pmsg->hwnd)) == NULL)
            return 0;
    }

    /*
     * If this is a synchronous-only message (takes a pointer in wParam or
     * lParam), then don't allow this message to go through since those
     * parameters have not been thunked, and are pointing into outer-space
     * (which would case exceptions to occur).
     *
     * (This api is only called in the context of a message loop, and you
     * don't get synchronous-only messages in a message loop).
     */
    if (TESTSYNCONLYMESSAGE(pmsg->message, pmsg->wParam)) {
        /*
         * Fail if 32 bit app is calling.
         */
        if (!(PtiCurrent()->TIF_flags & TIF_16BIT)) {
            RIPERR1(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "xxxDispatchMessage: Sync only message 0x%lX",
                    pmsg->message);
            return 0;
        }

        /*
         * For wow apps, allow it to go through (for compatibility). Change
         * the message id so our code doesn't understand the message - wow
         * will get the message and strip out this bit before dispatching
         * the message to the application.
         */
        pmsg->message |= MSGFLAG_WOW_RESERVED;
    }

    ThreadLock(pwnd, &tlpwnd);

    /*
     * Is this a timer?  If there's a proc address, call it,
     * otherwise send it to the wndproc.
     */
    if ((pmsg->message == WM_TIMER) || (pmsg->message == WM_SYSTIMER)) {
        if (pmsg->lParam != 0) {

            /*
             * System timers must be executed on the server's context.
             */
            if (pmsg->message == WM_SYSTIMER) {

                /*
                 * Verify that it's a valid timer proc. If so,
                 * don't leave the critsect to call server-side procs
                 * and pass a PWND, not HWND.
                 */
                PTIMER ptmr;
                lRet = 0;
                ptmr = FindSystemTimer(pmsg);
                if (ptmr) {
                    ptmr->pfn(pwnd, WM_SYSTIMER, (UINT)pmsg->wParam,
                              NtGetTickCount());
                }
                goto Exit;
            } else {
                /*
                 * WM_TIMER is the same for Unicode/ANSI.
                 */
                PTHREADINFO ptiCurrent = PtiCurrent();

                if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {
                    lRet = 0;
                    goto Exit;
                }

                /*
                 * Check the legitimacy of this  WM_TIMER callback,
                 * and bail out if it's not valid.
                 */
                if (!ValidateTimerCallback(ptiCurrent, pmsg->lParam)) {
                    RIPMSGF2(RIP_WARNING, "Bogus WM_TIMER callback: nID=%p, pfn=%p", pmsg->wParam, pmsg->lParam);
                    lRet = 0;
                    goto Exit;
                }

                lRet = CallClientProcA(pwnd, WM_TIMER,
                       pmsg->wParam, NtGetTickCount(), pmsg->lParam);

                goto Exit;
            }
        }
    }

    /*
     * Check to see if pwnd is NULL AFTER the timer check.  Apps can set
     * timers with NULL hwnd's, that's totally legal.  But NULL hwnd messages
     * don't get dispatched, so check here after the timer case but before
     * dispatching - if it's NULL, just return 0.
     */
    if (pwnd == NULL) {
        lRet = 0;
        goto Exit;
    }

    /*
     * If we're dispatching a WM_PAINT message, set a flag to be used to
     * determine whether it was processed properly.
     */
    if (pmsg->message == WM_PAINT)
        SetWF(pwnd, WFPAINTNOTPROCESSED);

    /*
     * If this window's proc is meant to be executed from the server side
     * we'll just stay inside the semaphore and call it directly.  Note
     * how we don't convert the pwnd into an hwnd before calling the proc.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC)) {
        ULONG_PTR fnMessageType;

        fnMessageType = pmsg->message >= WM_USER ? (ULONG_PTR)SfnDWORD :
                (ULONG_PTR)gapfnScSendMessage[MessageTable[pmsg->message].iFunction];

        /*
         * Convert the WM_CHAR from ANSI to UNICODE if the source was ANSI
         */
        if (fnMessageType == (ULONG_PTR)SfnINWPARAMCHAR && TestWF(pwnd, WFANSIPROC)) {
            UserAssert(PtiCurrent() == GETPTI(pwnd)); // use receiver's codepage
            RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
        }

        lRet = pwnd->lpfnWndProc(pwnd, pmsg->message, pmsg->wParam,
                pmsg->lParam);
        goto Exit;
    }

    /*
     * Cool people dereference any window structure members before they
     * leave the critsect.
     */
    lpfnWndProc = pwnd->lpfnWndProc;

    {
        /*
         * If we're dispatching the message to an ANSI wndproc we need to
         * convert the character messages from Unicode to Ansi.
         */
        if (TestWF(pwnd, WFANSIPROC)) {
            UserAssert(PtiCurrent() == GETPTI(pwnd)); // use receiver's codepage
            RtlWCSMessageWParamCharToMB(pmsg->message, &pmsg->wParam);
            lRet = CallClientProcA(pwnd, pmsg->message,
                    pmsg->wParam, pmsg->lParam, (ULONG_PTR)lpfnWndProc);
        } else {
            lRet = CallClientProcW(pwnd, pmsg->message,
                    pmsg->wParam, pmsg->lParam, (ULONG_PTR)lpfnWndProc);
        }
    }

    /*
     * If we dispatched a WM_PAINT message and it wasn't properly
     * processed, do the drawing here.
     */
    if (pmsg->message == WM_PAINT && RevalidateHwnd(pmsg->hwnd) &&
            TestWF(pwnd, WFPAINTNOTPROCESSED)) {
        //RIPMSG0(RIP_WARNING,
        //    "Missing BeginPaint or GetUpdateRect/Rgn(fErase == TRUE) in WM_PAINT");
        ClrWF(pwnd, WFWMPAINTSENT);
        xxxSimpleDoSyncPaint(pwnd);
    }

Exit:
    ThreadUnlock(&tlpwnd);
    return lRet;
}

/***************************************************************************\
* AdjustForCoalescing
*
* If message is in the coalesce message range, and it's message and hwnd
* equals the last message in the queue, then coalesce these two messages
* by simple deleting the last one.
*
* 11-12-92 ScottLu      Created.
\***************************************************************************/

void AdjustForCoalescing(
    PMLIST pml,
    HWND hwnd,
    UINT message)
{
    /*
     * First see if this message is in that range.
     */
    if (!CheckMsgFilter(message, WM_COALESCE_FIRST, WM_COALESCE_LAST) &&
            (message != WM_TIMECHANGE))
        return;

    if (pml->pqmsgWriteLast == NULL)
        return;

    if (pml->pqmsgWriteLast->msg.message != message)
        return;

    if (pml->pqmsgWriteLast->msg.hwnd != hwnd)
        return;

    /*
     * The message and hwnd are the same, so delete this message and
     * the new one will added later.
     */
    DelQEntry(pml, pml->pqmsgWriteLast);
}

/***************************************************************************\
* _PostMessage (API)
*
* Writes a message to the message queue for pwnd.  If pwnd == -1, the message
* is broadcasted to all windows.
*
* History:
* 11-06-90 DavidPe      Created.
\***************************************************************************/
BOOL _PostMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PQMSG pqmsg;
    BOOL fPwndUnlock;
    BOOL fRet;
    DWORD dwPostCode;
    TL tlpwnd;
    PTHREADINFO pti;

    /*
     * First check to see if this message takes DWORDs only. If it does not,
     * fail the post. Cannot allow an app to post a message with pointers or
     * handles in it - this can cause the server to fault and cause other
     * problems - such as causing apps in separate address spaces to fault.
     * (or even an app in the same address space to fault!)
     *
     * Block certain messages cross LUIDs to avoid security threats.
     */
    if (TESTSYNCONLYMESSAGE(message, wParam) || 
        BLOCKMESSAGECROSSLUID(message, 
                              PpiCurrent(),
                              GETPTI(pwnd)->ppi)) {
        RIPERR1(ERROR_MESSAGE_SYNC_ONLY,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to _PostMessage",
                message);

        return FALSE;
    }

    /*
     * Is this a BroadcastMsg()?
     */
    if (pwnd == PWND_BROADCAST) {
        xxxBroadcastMessage(NULL, message, wParam, lParam, BMSG_POSTMSG, NULL);
        return TRUE;
    }

    pti = PtiCurrent();

    /*
     * Is this posting to the current thread info?
     */
    if (pwnd == NULL) {
        return _PostThreadMessage(pti, message, wParam, lParam);
    }

    fPwndUnlock = FALSE;
    if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST) {
        ThreadLockAlwaysWithPti(pti, pwnd, &tlpwnd);
        dwPostCode = xxxDDETrackPostHook(&message, pwnd, wParam, &lParam, FALSE);

        if (dwPostCode != DO_POST) {
            ThreadUnlock(&tlpwnd);
            return (BOOL)dwPostCode;
        }

        fPwndUnlock = TRUE;
    }

    pti = GETPTI(pwnd);

    /*
     * Check to see if this message is in the multimedia coalescing range.
     * If so, see if it can be coalesced with the previous message.
     */
    AdjustForCoalescing(&pti->mlPost, HWq(pwnd), message);

#ifdef GENERIC_INPUT
#if LOCK_HIDDATA
    /*
     * If someone is posting this message, we need to bump up the reference
     * count of the HID data so it doesn't get freed too early.
     */
    if (message == WM_INPUT) {
        // lParam is an HRAWINPUT
        PHIDDATA pHidData = HMValidateHandle((HANDLE)lParam, TYPE_HIDDATA);

        TAGMSG1(DBGTAG_PNP, "_PostMessage: Got WM_INPUT pHidData=%p", pHidData);
        if (pHidData != NULL) {
            HMLockObject(pHidData);
        } else {
            RIPMSG1(RIP_WARNING, "_PostMessage: invalid handle %p for WM_INPUT", lParam);
            return FALSE;
        }
    } else
#endif
#endif // GENERIC_INPUT

    /*
     * Allocate a key state update event if needed.
     */
    if (message >= WM_KEYFIRST && message <= WM_KEYLAST) {
        PostUpdateKeyStateEvent(pti->pq);
    }

    /*
     * Put this message on the 'post' list.
     */
    fRet = FALSE;
    if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {
        /*
         * Set the QS_POSTMESSAGE bit so the thread knows it has a message.
         */
        StoreQMessage(pqmsg, pwnd, message, wParam, lParam, 0, 0, 0);
        SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);

        /*
         * If it's a hotkey, set the QS_HOTKEY bit since we have a separate
         * bit for those messages.
         */
        if (message == WM_HOTKEY)
            SetWakeBit(pti, QS_HOTKEY);

        fRet = TRUE;
    }

    /*
     * Are we posting to the thread currently reading from the input queue?
     * If so, update idSysLock with this pqmsg so that the input queue will
     * not be unlocked until this message is read.
     */
    if (pti == pti->pq->ptiSysLock)
        pti->pq->idSysLock = (ULONG_PTR)pqmsg;

    if (fPwndUnlock)
        ThreadUnlock(&tlpwnd);

    return fRet;
}

/***************************************************************************\
* _PostQuitMessage (API)
*
* Writes a message to the message queue for pwnd.  If pwnd == -1, the message
* is broadcasted to all windows.
*
* History:
* 11-06-90 DavidPe      Created.
* 05-16-91 mikeke       Changed to return BOOL
\***************************************************************************/
BOOL IPostQuitMessage(PTHREADINFO pti, int nExitCode)
{
    pti->TIF_flags |= TIF_QUITPOSTED;
    pti->exitCode = nExitCode;
    SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
    return TRUE;
}

BOOL _PostQuitMessage(int nExitCode)
{
    return IPostQuitMessage(PtiCurrent(), nExitCode);
}

/***************************************************************************\
* _PostThreadMessage (API)
*
* Given a thread ID, the function will post the specified message to this
* thread with pmsg->hwnd == NULL..
*
* History:
* 11-21-90 DavidPe      Created.
\***************************************************************************/
BOOL _PostThreadMessage(
    PTHREADINFO pti,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PQMSG       pqmsg;

    if ((pti == NULL)                                ||
        !(pti->TIF_flags & TIF_GUITHREADINITIALIZED) ||
        (pti->TIF_flags & TIF_INCLEANUP)) {

        RIPERR0(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, "");
        return FALSE;
    }

    /*
     * First check to see if this message takes DWORDs only. If it does not,
     * fail the post. Cannot allow an app to post a message with pointers or
     * handles in it - this can cause the server to fault and cause other
     * problems - such as causing apps in separate address spaces to fault.
     * (or even an app in the same address space to fault!)
     *
     * Block certain messages cross LUIDs to avoid security threats.
     */
    if (TESTSYNCONLYMESSAGE(message, wParam) || 
        BLOCKMESSAGECROSSLUID(message,
                              PpiCurrent(),
                              pti->ppi)) {
        RIPERR1(ERROR_MESSAGE_SYNC_ONLY,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to _PostThreadMessage",
                message);

        return FALSE;
    }

    /*
     * Check to see if this message is in the multimedia coalescing range.
     * If so, see if it can be coalesced with the previous message.
     */
    AdjustForCoalescing(&pti->mlPost, NULL, message);

    /*
     * Put this message on the 'post' list.
     */
    if ((pqmsg = AllocQEntry(&pti->mlPost)) == NULL) {
        RIPMSG1(RIP_WARNING, "_PostThreadMessage: Failed to alloc Q entry: Target pti=0x%p",
                pti);
        return FALSE;
    }

    /*
     * Set the QS_POSTMESSAGE bit so the thread knows it has a message.
     */
    StoreQMessage(pqmsg, NULL, message, wParam, lParam, 0, 0, 0);
    SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);

    /*
     * If it's a hotkey, set the QS_HOTKEY bit since we have a separate
     * bit for those messages.
     */
    if (message == WM_HOTKEY)
        SetWakeBit(pti, QS_HOTKEY);

    /*
     * Are we posting to the thread currently reading from the input queue?
     * If so, update idSysLock with this pqmsg so that the input queue will
     * not be unlocked until this message is read.
     */
    if (pti == pti->pq->ptiSysLock)
        pti->pq->idSysLock = (ULONG_PTR)pqmsg;

    return TRUE;
}


/***************************************************************************\
* _GetMessagePos (API)
*
* This API returns the cursor position when the last message was read from
* the current message queue.
*
* History:
* 11-19-90 DavidPe      Created.
\***************************************************************************/

DWORD _GetMessagePos(VOID)
{
    PTHREADINFO pti;

    pti = PtiCurrent();

    return MAKELONG((SHORT)pti->ptLast.x, (SHORT)pti->ptLast.y);
}



#ifdef SYSMODALWINDOWS
/***************************************************************************\
* _SetSysModalWindow (API)
*
* History:
* 01-25-91 DavidPe      Created stub.
\***************************************************************************/

PWND APIENTRY _SetSysModalWindow(
    PWND pwnd)
{
    pwnd;
    return NULL;
}


/***************************************************************************\
* _GetSysModalWindow (API)
*
* History:
* 01-25-91 DavidPe      Created stub.
\***************************************************************************/

PWND APIENTRY _GetSysModalWindow(VOID)
{
    return NULL;
}
#endif //LATER

/***************************************************************************\
* PostMove
*
* This routine gets called when it is detected that the QF_MOUSEMOVED bit
* is set in a particular queue.
*
* 11-03-92 ScottLu      Created.
\***************************************************************************/

VOID PostMove(
    PQ pq)
{
#ifdef REDIRECTION
    POINT pt;
#endif // REDIRECTION

    CheckCritIn();

    /*
     * set gdwMouseMoveTimeStamp to 0 after posting the move so
     * subsequent calls to SetFMouseMove doesn't use the same value
     * of gdwMouseMoveTimeStamp. Bug 74508.
     */
    if (gdwMouseMoveTimeStamp == 0) {
        gdwMouseMoveTimeStamp = NtGetTickCount();
    }

#ifdef GENERIC_INPUT
    if (TestRawInputMode(pq->ptiMouse, NoLegacyMouse)) {
        goto nopost;
    }
#endif

#ifdef REDIRECTION

    PopMouseMove(pq, &pt);

    PostInputMessage(pq, NULL, WM_MOUSEMOVE, 0,
            MAKELONG((SHORT)pt.x, (SHORT)pt.y),
            gdwMouseMoveTimeStamp, gdwMouseMoveExtraInfo);
#else
    PostInputMessage(pq, NULL, WM_MOUSEMOVE, 0,
            MAKELONG((SHORT)gpsi->ptCursor.x, (SHORT)gpsi->ptCursor.y),
            gdwMouseMoveTimeStamp, gdwMouseMoveExtraInfo);
#endif // REDIRECTION

#ifdef GENERIC_INPUT
nopost:
#endif
    gdwMouseMoveTimeStamp = 0;

    pq->QF_flags &= ~QF_MOUSEMOVED;
}

#ifdef REDIRECTION

typedef struct tagQMOUSEMOVE {
    PQ    pq;
    POINT pt;
} QMOUSEMOVE;

#define MAX_QMOUSEMOVE  16

QMOUSEMOVE gqMouseMove[MAX_QMOUSEMOVE];

int gnLastMouseMove;

VOID PushMouseMove(
    PQ    pq,
    POINT pt)
{
    int ind;

    CheckCritIn();

    UserAssert(gnLastMouseMove < MAX_QMOUSEMOVE - 1);

    for (ind = 0; ind < gnLastMouseMove; ind++) {
        if (pq == gqMouseMove[ind].pq) {

            gqMouseMove[ind].pt = pt;
            return;
        }
    }

    gqMouseMove[gnLastMouseMove].pq = pq;
    gqMouseMove[gnLastMouseMove].pt = pt;

    gnLastMouseMove++;
}

VOID PopMouseMove(
    PQ     pq,
    POINT* ppt)
{
    int ind;

    CheckCritIn();

    for (ind = 0; ind < gnLastMouseMove; ind++) {
        if (pq == gqMouseMove[ind].pq) {
            *ppt = gqMouseMove[ind].pt;

            RtlMoveMemory(&gqMouseMove[ind],
                          &gqMouseMove[ind + 1],
                          (gnLastMouseMove - ind - 1) * sizeof(QMOUSEMOVE));

            gnLastMouseMove--;

            return;
        }
    }
    UserAssert(0);
}
#endif // REDIRECTION

/***************************************************************************\
* zzzSetFMouseMoved
*
* Send a mouse move through the system. This usually occurs when doing
* window management to be sure that the mouse shape accurately reflects
* the part of the window it is currently over (window managment may have
* changed this).
*
* 11-02-92 ScottLu      Created.
\***************************************************************************/
VOID zzzSetFMouseMoved(
    VOID)
{
    PWND pwnd;
    PWND pwndOldCursor;
    PQ   pq;

#ifdef REDIRECTION
    PWND  pwndStart;
    POINT ptMouse = gpsi->ptCursor;
#endif // REDIRECTION

    /*
     * Need to first figure out what queue this mouse event is in. Do NOT
     * check for mouse capture here !! Talk to scottlu.
     */
    if ((pwnd = gspwndScreenCapture) == NULL) {

#ifdef REDIRECTION
        /*
         * Call the speed hit test hook
         */
        pwndStart = xxxCallSpeedHitTestHook(&ptMouse);
#endif // REDIRECTION

        if ((pwnd = gspwndMouseOwner) == NULL) {
            if ((pwnd = gspwndInternalCapture) == NULL) {

                UserAssert(grpdeskRitInput != NULL);

#ifdef REDIRECTION
                if (pwndStart == NULL) {
                    pwndStart = grpdeskRitInput->pDeskInfo->spwnd;
                }
                pwnd = SpeedHitTest(pwndStart, ptMouse);
#else
                pwnd = SpeedHitTest(grpdeskRitInput->pDeskInfo->spwnd, gpsi->ptCursor);
#endif // REDIRECTION

            }
        }
    }

    if (pwnd == NULL)
        return;

    /*
     * This is apparently needed by the attach/unattach code for some
     * reason. I'd like to get rid of it - scottlu.
     */
    pwndOldCursor = Lock(&gspwndCursor, pwnd);

    /*
     * If we're giving a mouse move to a new queue, be sure the cursor
     * image represents what this queue thinks it should be.
     */
    pq = GETPTI(pwnd)->pq;

    /*
     * Protect pq by deferring WinEvent notification
     */
    DeferWinEventNotify();

    if (pq != gpqCursor) {
        /*
         * If the old queue had the mouse captured, let him know that
         * the mouse moved first. Need this to fix tooltips in
         * WordPerfect Office. Do the same for mouse tracking.
         */
        if (gpqCursor != NULL) {

            if (gpqCursor->spwndCapture != NULL) {
                gpqCursor->QF_flags |= QF_MOUSEMOVED;
                SetWakeBit(GETPTI(gpqCursor->spwndCapture), QS_MOUSEMOVE);

#ifdef REDIRECTION
                PushMouseMove(gpqCursor, ptMouse);
#endif // REDIRECTION

            }

            if ((pwndOldCursor != NULL) && (PtoHq(pwndOldCursor) != PtoHq(pwnd))) {
                PDESKTOP pdesk = GETPDESK(pwndOldCursor);
                if (pdesk->dwDTFlags & DF_MOUSEMOVETRK) {
                    PTHREADINFO pti = GETPTI(pdesk->spwndTrack);
                    PostEventMessage(pti, pti->pq, QEVENT_CANCELMOUSEMOVETRK,
                                     pdesk->spwndTrack, pdesk->dwDTFlags, pdesk->htEx,
                                     DF_MOUSEMOVETRK);
                    pdesk->dwDTFlags &= ~DF_MOUSEMOVETRK;
                }
            }
        }

        /*
         * First re-assign gpqCursor so any zzzSetCursor() calls
         * will only take effect if done by the thread that
         * owns the window the mouse is currently over.
         */
        gpqCursor = pq;

        /*
         * Call zzzUpdateCursorImage() so the new gpqCursor's
         * notion of the current cursor is represented.
         */
        zzzUpdateCursorImage();

    }

    /*
     * Set the mouse moved bit for this queue so we know later to post
     * a move message to this queue.
     */
    pq->QF_flags |= QF_MOUSEMOVED;

#ifdef REDIRECTION
    PushMouseMove(pq, ptMouse);
#endif // REDIRECTION


    /*
     * Reassign mouse input to this thread - this indicates which thread
     * to wake up when new input comes in.
     */
    pq->ptiMouse = GETPTI(pwnd);

    /*
     * Wake some thread within this queue to process this mouse event.
     */
    WakeSomeone(pq, WM_MOUSEMOVE, NULL);

    /*
     * We're possibly generating a fake mouse move message - it has no
     * extra info associated with it - so 0 it out.
     */
    gdwMouseMoveExtraInfo = 0;

    zzzEndDeferWinEventNotify();
}

/***************************************************************************\
* CancelForegroundActivate
*
* This routine cancels the foreground activate that we allow apps starting
* up to have. This means that if you make a request to start an app,
* if this routine is called before the app becomes foreground, it won't
* become foreground. This routine gets called if the user down clicks or
* makes a keydown event, with the idea being that if the user did this,
* the user is using some other app and doesn't want the newly starting
* application to appear on top and force itself into the foreground.
*
* 09-15-92 ScottLu      Created.
\***************************************************************************/

void CancelForegroundActivate()
{
    PPROCESSINFO ppiT;

    if (TEST_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE)) {

        for (ppiT = gppiStarting; ppiT != NULL; ppiT = ppiT->ppiNext) {
            /*
             * Don't cancel activation if the app is being debugged - if
             * the debugger stops the application before it has created and
             * activated its first window, the app will come up behind all
             * others - not what you want when being debugged.
             */
            if (!PsGetProcessDebugPort(ppiT->Process)) {
                ppiT->W32PF_Flags &= ~W32PF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "CancelForegroundActivate clear W32PF %#p", ppiT);
            }
        }

        CLEAR_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
        TAGMSG0(DBGTAG_FOREGROUND, "CancelForegroundActivate clear PUDF");
    }
}

/***************************************************************************\
* RestoreForegroundActivate
*
* This routine re-enables an app's right to foreground activate (activate and
* come on top) if it is starting up. This is called when we minimize or when
* the last window of a thread goes away, for example.
*
* 01-26-93 ScottLu      Created.
\***************************************************************************/

void RestoreForegroundActivate()
{
    PPROCESSINFO ppiT;

    for (ppiT = gppiStarting; ppiT != NULL; ppiT = ppiT->ppiNext) {
        if (ppiT->W32PF_Flags & W32PF_APPSTARTING) {
            ppiT->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "RestoreForegroundActivate set W32PF %#p", ppiT);
            SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
            TAGMSG0(DBGTAG_FOREGROUND, "RestoreForegroundActivate set PUDF");
        }
    }
}

/***************************************************************************\
* PostInputMessage
*
* Puts a message on the 'input' linked-list of message for the specified
* queue.
*
* History:
* 10-25-90 DavidPe      Created.
* 01-21-92 DavidPe      Rewrote to deal with OOM errors gracefully.
\***************************************************************************/
BOOL PostInputMessage(
    PQ    pq,
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD time,
    ULONG_PTR dwExtraInfo)
{
    PQMSG pqmsgInput, pqmsgPrev;
    short sWheelDelta;

#ifdef GENERIC_INPUT
#if DBG
    /*
     * Verify that the wParam that'll be sent with the WM_INPUT matches
     * what's stored in the RAWINPUTHEADER.
     */
    if (message == WM_INPUT) {
        PHIDDATA pHidData = HtoP(lParam);

        UserAssert(pHidData->rid.header.wParam == wParam);
    }
#endif // DBG
#endif // GENERIC_INPUT

    /*
     * Grab the last written message before we start allocing new ones,
     * so we're sure to point to the correct message.
     */
    pqmsgPrev = pq->mlInput.pqmsgWriteLast;

    /*
     * Allocate a key state update event if needed.
     */
    if (pq->QF_flags & QF_UPDATEKEYSTATE) {
        PostUpdateKeyStateEvent(pq);
    }

#ifdef GENERIC_INPUT
    /*
     * We don't want WM_INPUT messages inhibiting the coalescing of
     * WM_MOUSEMOVE and WM_MOUSEWHEEL, so if the message being posted
     * is one of those we check to see if there are any previous ones
     * that would be "hidden" by a WM_INPUT.
     */
    if (message == WM_MOUSEMOVE || message == WM_MOUSEWHEEL) {
        while (pqmsgPrev && pqmsgPrev->msg.message == WM_INPUT) {
            pqmsgPrev = pqmsgPrev->pqmsgPrev;
        }
    }
#endif // GENERIC_INPUT

    /*
     * We want to coalesce sequential WM_MOUSEMOVE and WM_MOUSEWHEEL.
     * WM_MOUSEMOVEs are coalesced by just storing the most recent
     * event over the last one.
     * WM_MOUSEWHEELs also add up the wheel rolls.
     */
    if (pqmsgPrev != NULL &&
        pqmsgPrev->msg.message == message &&
        (message == WM_MOUSEMOVE || message == WM_MOUSEWHEEL)) {

        if (message == WM_MOUSEWHEEL) {
            sWheelDelta = (short)HIWORD(wParam) + (short)HIWORD(pqmsgPrev->msg.wParam);

#if 0
            /*
             * LATER: We can't remove a wheel message with zero delta
             * unless we know it hasn't been peeked. Ideally,
             * we would check idsyspeek for this, but we're too close
             * to ship and idsyspeek is too fragile. Consider also
             * checking to see if mouse move messages have been peeked.
             */

            if (sWheelDelta == 0) {
                if ((PQMSG)pq->idSysPeek == pqmsgPrev) {
                    RIPMSG0(RIP_VERBOSE,
                            "Coalescing of mouse wheel messages causing "
                            "idSysPeek to be reset to 0");

                    pq->idSysPeek = 0;
                }

                DelQEntry(&pq->mlInput, pqmsgPrev);
                return;
            }
#endif

            wParam = MAKEWPARAM(LOWORD(wParam), sWheelDelta);
        }

        StoreQMessage(pqmsgPrev, pwnd, message, wParam, lParam, time, 0, dwExtraInfo);
        WakeSomeone(pq, message, pqmsgPrev);
        return TRUE;
    }

    /*
     * Fill in pqmsgInput.
     */
    pqmsgInput = AllocQEntry(&pq->mlInput);
    if (pqmsgInput == NULL) {
        return FALSE;
    }
    StoreQMessage(pqmsgInput, pwnd, message, wParam, lParam, time, 0, dwExtraInfo);
    WakeSomeone(pq, message, pqmsgInput);

    return TRUE;
}

/***************************************************************************\
* WakeSomeone
*
* Figures out which thread to wake up based on the queue and message.
* If the queue pointer is NULL, figures out a likely queue.
*
* 10-23-92 ScottLu      Created.
\***************************************************************************/

void WakeSomeone(
    PQ pq,
    UINT message,
    PQMSG pqmsg)
{
    BOOL fSetLastWoken = FALSE;
    PTHREADINFO ptiT;

    /*
     * Set the appropriate wakebits for this queue.
     */
    ptiT = NULL;
    switch (message) {

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        /*
         * Don't change input ownership if the user is holding down
         *  a modifier key. When doing a ctrl-drag operation for example,
         *  the ctrl key must be down when the user drops the object (ie, mouse up).
         *  On mouse up the RIT gives input ownership to the target; but since
         *  ctrl is down, on the next repeat key we used to give input ownership
         *  to the focus window (usually the drag source). Hence the target
         *  would lose owenerhip and couldn't take the foreground.
         */
        if (pqmsg != NULL) {
            switch (pqmsg->msg.wParam) {
                case VK_SHIFT:
                case VK_CONTROL:
                case VK_MENU:
                    if (TestKeyStateDown(pq, pqmsg->msg.wParam)) {
                        break;
                    }
                    /* Fall through */

                default:
                    fSetLastWoken = TRUE;
                    break;
            }
        } else {
            fSetLastWoken = TRUE;
        }
        /* fall through */

    case WM_SYSCHAR:
    case WM_CHAR:
        /* Freelance graphics seems to pass in WM_SYSCHARs and WM_CHARs into
         * the journal playback hook, so we need to set an input bit for
         * this case since that is what win3.1 does. VB2 "learning" demo does
         * the same, as does Excel intro.
         *
         * On win3.1, the WM_CHAR would by default set the QS_MOUSEBUTTON bit.
         * On NT, the WM_CHAR sets the QS_KEY bit. This is because
         * ScanSysQueue() calls TransferWakeBit() with the QS_KEY bit when
         * a WM_CHAR message is passed in. By using the QS_KEY bit on NT,
         * we're more compatible with what win3.1 wants to be.
         *
         * This fixes a case where the mouse was over progman, the WM_CHAR
         * would come in via journal playback, wakesomeone would be called,
         * and set the mouse bit in progman. Progman would then get into
         * ScanSysQueue(), callback the journal playback hook, get the WM_CHAR,
         * and do it again, looping. This caught VB2 in a loop.
         */

        CancelForegroundActivate();

        /* fall through */

    case WM_KEYUP:
    case WM_SYSKEYUP:
    case WM_MOUSEWHEEL:
        /*
         * Win3.1 first looks at what thread has the active status. This
         * means that we don't depend on the thread owning ptiKeyboard
         * to wake up and process this key in order to give it to the
         * active window, which is potentially newly active. Case in
         * point: excel bringing up CBT, cbt has an error, brings up
         * a message box: since excel is filtering for CBT messages only,
         * ptiKeyboard never gets reassigned to CBT so CBT doesn't get
         * any key messages and appears hung.
         */
        ptiT = pq->ptiKeyboard;
        if (pq->spwndActive != NULL)
            ptiT = GETPTI(pq->spwndActive);
#ifdef GENERIC_INPUT
        UserAssert(ptiT == PtiKbdFromQ(pq));
#endif

        SetWakeBit(ptiT, message == WM_MOUSEWHEEL ? QS_MOUSEBUTTON : QS_KEY);
        break;

    case WM_MOUSEMOVE:
        /*
         * Make sure we wake up the thread with the capture, if there is
         * one. This fixes PC Tools screen capture program, which sets
         * capture and then loops trying to remove messages from the
         * queue.
         */
        if (pq->spwndCapture != NULL)
            ptiT = GETPTI(pq->spwndCapture);
        else
            ptiT = pq->ptiMouse;
#ifdef GENERIC_INPUT
        UserAssert(ptiT == PtiMouseFromQ(pq));
#endif
        SetWakeBit(ptiT, QS_MOUSEMOVE);
        break;


    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONDBLCLK:
    case WM_XBUTTONDOWN:
    case WM_XBUTTONDBLCLK:
            fSetLastWoken = TRUE;

        /* fall through */

    default:
        /*
         * The default case in Win3.1 for this is QS_MOUSEBUTTON.
         */

        CancelForegroundActivate();

        /* fall through */

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
        /*
         * Make sure we wake up the thread with the capture, if there is
         * one. This fixes PC Tools screen capture program, which sets
         * capture and then loops trying to remove messages from the
         * queue.
         */
        if (pq->spwndCapture != NULL &&
                message >= WM_MOUSEFIRST && message <= WM_MOUSELAST)
            ptiT = GETPTI(pq->spwndCapture);
        else
            ptiT = pq->ptiMouse;
        SetWakeBit(ptiT, QS_MOUSEBUTTON);
        break;

#ifdef GENERIC_INPUT
    case WM_INPUT:
        if (pqmsg->msg.hwnd) {
            PWND pwnd = ValidateHwnd(pqmsg->msg.hwnd);
            if (pwnd) {
                ptiT = GETPTI(pwnd);
                TAGMSG2(DBGTAG_PNP, "WakeSomeone: adjusted receiver pti %p for pwndTarget %p", ptiT, pwnd);
            }
        }
        if (ptiT == NULL) {
            ptiT = PtiKbdFromQ(pq);
        }
        SetWakeBit(ptiT, QS_RAWINPUT);
        break;
#endif
    }

    /*
     * If a messaged was passed in, remember in it who we woke up for this
     * message. We do this so each message is ownership marked. This way
     * we can merge/unmerge message streams when zzzAttachThreadInput() is
     * called.
     */
    if (ptiT != NULL) {
        if (pqmsg != NULL) {

            StoreQMessagePti(pqmsg, ptiT);

            UserAssert(!(ptiT->TIF_flags & TIF_INCLEANUP));
        }

        /*
         * Remember who got the last key/click down.
         */
        if (fSetLastWoken) {
            glinp.ptiLastWoken = ptiT;
        }
    }

}


/***************************************************************************\
* PostUpdateKeyStateEvent
*
* This routine posts an event which updates the local thread's keystate
* table. This makes sure the thread's key state is always up-to-date.
*
* An example is: control-esc from cmd to taskman.
* Control goes to cmd, but taskman is activated. Control state is still down
* in cmd - switch back to cmd, start typing, nothing appears because it thinks
* the control state is still down.
*
* As events go into a particular queue (queue A), the async key state table is
* updated. As long as transition events are put into queue A, the key
* state at the logical "end of the queue" is up-to-date with the async key
* state. As soon as the user posts transition events (up/down msgs) into queue
* B, the queue A's end-of-queue key state is out of date with the user. If
* the user then again added messages to queue A, when those messages are read
* the thread specific key state would not be updated correctly unless we
* did some synchronization (which this routine helps to do).
*
* As soon as transition events change queues, we go mark all the other queues
* with the QF_UPDATEKEYSTATE flag. Before any input event is posted into
* a queue, this flag is checked, and if set, this routine is called. This
* routine makes a copy of the async key state, and a copy of the bits
* representing the keys that have changed since the last update (we need to
* keep track of which keys have changed so that any state set by the
* app with SetKeyboardState() doesn't get wiped out). We take this data
* and post a new event of the type QEVENT_UPDATEKEYSTATE, which points to this
* key state and transition information. When this message is read out of the
* queue, this key state copy is copied into the thread specific key state
* table for those keys that have changed, and the copy is deallocated.
*
* This ensures all queues are input-synchronized with key transitions no matter
* where they occur. The side affect of this is that an application may suddenly
* have a key be up without seeing the up message. If this causes any problems
* we may have to generate false transition messages (this could have more nasty
* side affects as well, so it needs to be considered closely before being
* implemented.)
*
* 06-07-91 ScottLu      Created.
\***************************************************************************/

void PostUpdateKeyStateEvent(
    PQ pq)
{
    BYTE *pb;
    PQMSG pqmsg;

    if (!(pq->QF_flags & QF_UPDATEKEYSTATE))
        return;

    /*
     * Exclude the RIT - it's queue is never read, so don't waste memory
     */
    if (pq->ptiKeyboard == gptiRit) {
        return;
    }

    /*
     * If there's no mousebutton or keystroke input pending, process the
     * UpdateKeyState Event now: thus saving memory allocation and giving
     * applications the correct KeyState immediately.
     * NOTE: There may be event/activation msgs in pq->mlInput that don't
     * affect keystate, so I'd like to just test QS_KEY | QS_MOUSEBUTTON
     * specifically, instead of the cMsgss.  However, sometimes there are
     * keystroke or mousebutton msgs in the q without those bits set! - IanJa
     */
    if (pq->mlInput.cMsgs == 0) {
        ProcessUpdateKeyStateEvent(pq, gafAsyncKeyState, pq->afKeyRecentDown);
        goto SyncQueue;
    }
#if DBG
    else if ((!pq->ptiKeyboard || !(pq->ptiKeyboard->pcti->fsWakeBits & QS_KEY)) &&
             (!pq->ptiMouse    || !(pq->ptiMouse->pcti->fsWakeBits & QS_MOUSEBUTTON))) {
        /*
         * See if there are any key or mousebutton messages that aren't
         * indicated by QS_KEY or QS_MOUSEBUTTON bits.
         */
        PQMSG pqmsgT;
        for (pqmsgT = pq->mlInput.pqmsgRead; pqmsgT; pqmsgT = pqmsgT->pqmsgNext) {
            if (pqmsgT->msg.message >= WM_KEYFIRST && pqmsgT->msg.message <= WM_KEYLAST) {
                TAGMSG1(DBGTAG_InputWithoutQS,
                        "PostUpdateKeyStateEvent() pushing in front of a keystroke: Q %#p", pq);
            } else if (pqmsgT->msg.message >= WM_LBUTTONDOWN && pqmsgT->msg.message <= WM_XBUTTONDBLCLK) {
                TAGMSG1(DBGTAG_InputWithoutQS,
                        "PostUpdateKeyStateEvent() pushing in front of a mousebutton: Q %#p", pq);
            }
        }
    }
#endif

    UserAssert(pq->mlInput.pqmsgWriteLast != NULL);

    /*
     * If the last input message is an UPDATEKEYSTATE event, coalesce with it.
     * (Prevents big memory leaks on apps that don't read input messages)
     */
    pqmsg = pq->mlInput.pqmsgWriteLast;
    if (pqmsg->dwQEvent == QEVENT_UPDATEKEYSTATE) {
        int i;
        DWORD *pdw;

        pb = (PBYTE)(pqmsg->msg.wParam);
        pdw = (DWORD *) (pb + CBKEYSTATE);

        /*
         * Copy in the new key state
         */
        RtlCopyMemory(pb, gafAsyncKeyState, CBKEYSTATE);

        /*
         * Or in the recent key down state (DWORD at a time)
         */
#if (CBKEYSTATERECENTDOWN % 4) != 0
#error "CBKEYSTATERECENTDOWN assumed to be an integral number of DWORDs"
#endif
        for (i = 0; i < CBKEYSTATERECENTDOWN / sizeof(*pdw); i++) {
            *pdw++ |= ((DWORD *)(pq->afKeyRecentDown))[i];
        }

        /*
         * Set QS_EVENTSET as in PostEventMessage, although this is
         * usually, but not always already set
         */
        SetWakeBit(pq->ptiKeyboard, QS_EVENTSET);
        goto SyncQueue;
    }

    /*
     * Make a copy of the async key state buffer, point to it, and add an
     * event to the end of the input queue.
     */
    if ((pb = UserAllocPool(KEYSTATESIZE, TAG_KBDSTATE)) == NULL) {
        return;
    }

    RtlCopyMemory(pb, gafAsyncKeyState, CBKEYSTATE);
    RtlCopyMemory(pb + CBKEYSTATE, pq->afKeyRecentDown, CBKEYSTATERECENTDOWN);

    if (!PostEventMessage(pq->ptiKeyboard, pq, QEVENT_UPDATEKEYSTATE,
                          NULL, 0 , (WPARAM)pb, 0)) {
        UserFreePool(pb);
        return;
    }

    /*
     * The key state of the queue is input-synchronized with the user.  Erase
     * all 'recent down' flags.
     */
SyncQueue:
    RtlZeroMemory(pq->afKeyRecentDown, CBKEYSTATERECENTDOWN);
    pq->QF_flags &= ~QF_UPDATEKEYSTATE;
}


/***************************************************************************\
* ProcessUpdateKeyStateEvent
*
* This is part two of the above routine, called when the QEVENT_UPDATEKEYSTATE
* message is read out of the input queue.
*
* 06-07-91 ScottLu      Created.
\***************************************************************************/

void ProcessUpdateKeyStateEvent(
    PQ pq,
    CONST PBYTE pbKeyState,
    CONST PBYTE pbRecentDown)
{
    int i, j;
    BYTE *pbChange;
    int vk;

    pbChange = pbRecentDown;
    for (i = 0; i < CBKEYSTATERECENTDOWN; i++, pbChange++) {

        /*
         * Find some keys that have changed.
         */
        if (*pbChange == 0)
            continue;

        /*
         * Some keys have changed in this byte.  find out which key it is.
         */
        for (j = 0; j < 8; j++) {

            /*
             * Convert our counts to a virtual key index and check to see
             * if this key has changed.
             */
            vk = (i << 3) + j;
            if (!TestKeyRecentDownBit(pbRecentDown, vk))
                continue;

            /*
             * This key has changed.  Update it's state in the thread key
             * state table.
             */

            if (TestKeyDownBit(pbKeyState, vk)) {
                SetKeyStateDown(pq, vk);
            } else {
                ClearKeyStateDown(pq, vk);
            }

            if (TestKeyToggleBit(pbKeyState, vk)) {
                SetKeyStateToggle(pq, vk);
            } else {
                ClearKeyStateToggle(pq, vk);
            }
        }
    }

    /*
     * Update the key cache index.
     */
    gpsi->dwKeyCache++;

    /*
     * All updated.  Free the key state table if it was posted as an Event Message
     */
    if (pbKeyState != gafAsyncKeyState) {
        UserFreePool(pbKeyState);
    }
}


/***************************************************************************\
* PostEventMessage
*
*
* History:
* 03-04-91 DavidPe      Created.
\***************************************************************************/

BOOL PostEventMessage(
    PTHREADINFO pti,
    PQ    pq,
    DWORD dwQEvent,
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam)
{
    PQMSG pqmsgEvent;

    CheckCritIn();

    /*
     * If the thread is in cleanup, then it's possible the queue has
     * already been removed for this thread.  If this is the case, then
     * we should fail to post the event to a dying thread.
     */
    if (pti && (pti->TIF_flags & TIF_INCLEANUP))
        return FALSE;

    if ((pqmsgEvent = AllocQEntry(&pq->mlInput)) == NULL)
        return FALSE;

    StoreQMessage(pqmsgEvent, pwnd, message, wParam, lParam, 0, dwQEvent, 0);

    StoreQMessagePti(pqmsgEvent, pti);

    /*
     * Let this thread know it has an event message to process.
     */
    if (pti == NULL) {
        UserAssert(pti);
        SetWakeBit(pq->ptiMouse, QS_EVENTSET);
        SetWakeBit(pq->ptiKeyboard, QS_EVENTSET);
    } else {
        SetWakeBit(pti, QS_EVENTSET);
    }

    return TRUE;
}

/***************************************************************************\
* CheckOnTop
*
* Usually windows come to the top and activate all at once. Occasionally, a
* starting app will create a window, pause for awhile, then make itself
* visible. During that pause, if the user clicks down, the window won't be
* allowed to activate (because of our foreground activation model). But this
* still leaves the new window on top of the active window. When this click
* happens, we get here: if this window is active and is not on top, bring it
* to the top.
*
* Case in point: start winquote, click down. The window
* you clicked on is active, but winquote is on top.
*
* This rarely does anything because 99.99% of the time the active
* window is already where it should be - on top. Note that
* CalcForegroundInsertAfter() takes into account owner-based zordering.
*
*
* NOTE: the following was the original function written.  However, this
*       function has been disabled for now.  in WinWord and Excel especially,
*       this tends to cause savebits to be blown-away on mouse-activation of
*       its dialog-boxes.  This could be a problem with GW_HWNDPREV and/or
*       CalcForground not being the same, which causes a SetWindowPos to be
*       called, resulting in the freeing of the SPB.  This also solves a
*       problem with the ComboBoxes in MsMoney hiding/freeing the dropdown
*       listbox on activation as well.
*
* We need this for ActiveWindowTracking support. xxxBringWindowToTop used to be a call
*  to SetWindowPos but now it's gone.
*
* It returns TRUE if the window was brought the top; if no z-order change
*  took place, it returns FALSE.
*
* 05-20-93 ScottLu      Created.
* 10-17-94 ChrisWil     Made into stub-macro.
* 05-30-96 GerardoB     Brought it back to live for AWT
\***************************************************************************/
BOOL CheckOnTop(PTHREADINFO pti, PWND pwndTop, UINT message)
{
    if (pwndTop != pti->pq->spwndActive)
        return FALSE;

    switch (message) {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_XBUTTONDOWN:
            if (   TestWF(pwndTop, WEFTOPMOST)
                    || (_GetWindow(pwndTop, GW_HWNDPREV) != CalcForegroundInsertAfter(pwndTop))) {

                 return xxxSetWindowPos(pwndTop, PWND_TOP, 0, 0, 0, 0,
                        SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
             }
             break;
    }

    return FALSE;
}


#define MA_PASSTHRU     0
#define MA_SKIP         1
#define MA_REHITTEST    2

/***************************************************************************\
* zzzActiveCursorTracking
*
* If active window tracking is enabled, activation follows
*  the mouse. If the mouse is NOT on the active window
* (i.e., it was activated by a keyboard operation),
*  activation will change as soon as the mouse moves.
* So we have to make sure the mouse is on the active window.
*
* History
* 12/07/96  GerardoB  Created
\***************************************************************************/
void zzzActiveCursorTracking (PWND pwnd)
{
    BOOL fVisible;
    POINT pt;

    /*
     * If the last input event wasn't from the keyboard, bail
     * The user is probably moving the mouse.
     */
    if (!(glinp.dwFlags & LINP_KEYBOARD)) {
        return;
    }

    /*
     * If we're already there, bail.
     */
    if (PtInRect((LPRECT)&pwnd->rcWindow, gptCursorAsync)) {
        return;
    }

    /*
     * If the window the mouse is on is not "active-trackable", then
     *  we can leave the mouse right where it is
     */
     if ((gspwndCursor != NULL) && (GetActiveTrackPwnd(gspwndCursor, NULL) == NULL)) {
         return;
     }

     /*
      * If this window doesn't have a point visible in the screen, bail
      */
     pt.x = pwnd->rcWindow.left + ((pwnd->rcWindow.right  - pwnd->rcWindow.left) / 2);
     pt.y = pwnd->rcWindow.top  + ((pwnd->rcWindow.bottom - pwnd->rcWindow.top)  / 2);
     BoundCursor(&pt);
     if (!PtInRect((LPRECT)&pwnd->rcWindow, pt)) {
         return;
     }

    /*
     * We need to make sure that this window is marked as visible or someone
     *  else will be waken up to update the cursor (and might
     *  activate itself because of the active tracking).
     *
     * Later5.0 GerardoB: If the window is still not visible when
     *  it wakes up, then we're out of luck.
     */
    fVisible = TestWF(pwnd, WFVISIBLE);
    if (!fVisible) {
        SetVisible(pwnd, SV_SET);
    }

    /*
     * Move the cursor to the center of this window
     */
    zzzInternalSetCursorPos(pt.x, pt.y);

    /*
     * Restore visible bit.
     */
    if (!fVisible) {
        SetVisible(pwnd, SV_UNSET);
    }
}
/***************************************************************************\
* GetActiveTrackPwnd
*
* History
* 12/07/96  GerardoB  Extracted from xxxActiveWindowTracking.
\***************************************************************************/
PWND GetActiveTrackPwnd(PWND pwnd, Q **ppq)
{
    PWND pwndActivate;
    Q *pq;

    CheckCritIn();
    pwndActivate = pwnd;

    /*
     * Find the top parent
     */
    while (TestwndChild(pwndActivate)) {
        pwndActivate = pwndActivate->spwndParent;
    }

    /*
     * If disabled, get a enabled popup owned by it.
     */
    if (TestWF(pwndActivate, WFDISABLED)) {
        /*
         * This is what we do elsewhere when someone clicks on a
         *  disabled non-active window. It might be cheaper to check
         *  pwnd->spwndLastActive first (we might need to walk up
         *  the owner chain though, as this is where we set spwndLastAcitve
         *  when activating a new window. see xxxActivateThisWindow).
         * But let's do the same here; this should be fixed/improved
         *  in DWP_GetEnabledPopup anyway. There might be a reason
         *  why we don't grab spwndLastActive if OK.... perhaps it has
         *  something to do with nested owner windows
         */
         pwndActivate = DWP_GetEnabledPopup(pwndActivate);
    }

    /*
     * Bail if we didn't find a visible window
     */
    if ((pwndActivate == NULL) || !TestWF(pwndActivate, WFVISIBLE)) {
        return NULL;
    }

    /*
     * If already active in the foreground queue, nothing to do
     * Don't activate the modeless menu notification window (it would
     *  dismiss the menu)
     */
    pq = GETPTI(pwndActivate)->pq;
    if ((pq == gpqForeground)
            && ((pwndActivate == pq->spwndActive)
                || IsModelessMenuNotificationWindow(pwndActivate))) {

        return NULL;
    }

    /*
     * Don't activate the shell window.
     */
    if (pwndActivate == pwndActivate->head.rpdesk->pDeskInfo->spwndShell) {
        return NULL;
    }

    /*
     * Return the queue if requested
     */
    if (ppq != NULL) {
        *ppq = pq;
    }

    return pwndActivate;
}
/***************************************************************************\
* xxxActivateWindowTracking
*
* Activates a window without z-ordering it to the top
*
* 06/05/96  GerardoB  Created
\***************************************************************************/
int xxxActiveWindowTracking(
    PWND pwnd,
    UINT uMsg,
    int iHitTest)
{

    BOOL fSuccess;
    int iRet;
    PWND pwndActivate;
    Q *pq;
    TL tlpwndActivate;

    CheckLock(pwnd);
    UserAssert(TestUP(ACTIVEWINDOWTRACKING));

    /*
     * If the mouse hasn't been long enough on this queue, bail.
     */
    pq = GETPTI(pwnd)->pq;
    if (!(pq->QF_flags & QF_ACTIVEWNDTRACKING)) {
        return MA_PASSTHRU;
    }
    pq->QF_flags &= ~QF_ACTIVEWNDTRACKING;

    /*
     * If the foreground is locked, bail
     */
    if (IsForegroundLocked()) {
        return MA_PASSTHRU;
    }

    /*
     * Get the window we need to activate. If none, bail.
     */
    pwndActivate = GetActiveTrackPwnd(pwnd, &pq);
    if (pwndActivate == NULL) {
        return MA_PASSTHRU;
    }

    /*
     * Lock if needed because we're about to callback
     */
    if (pwnd != pwndActivate) {
        ThreadLockAlways(pwndActivate, &tlpwndActivate);
    }

    /*
     * Let's ask if it's OK to do this
     *
     * This message is supposed to go to the window the mouse is on.
     * This could be a child window which might return MA_NOACTIVATE*.
     * For mouse clicks (which is what we want to emulate here)
     *  xxxButtonEvent calls xxxSetForegroundWindow2 so their
     *  pwndActivate gets brought to the foreground regardless.
     * So we send the message to pwndActivate instead.
     */
    iRet = (int)xxxSendMessage(pwndActivate, WM_MOUSEACTIVATE,
            (WPARAM)(HWq(pwndActivate)), MAKELONG((SHORT)iHitTest, uMsg));


    switch (iRet) {
        case MA_ACTIVATE:
        case MA_ACTIVATEANDEAT:
            if (pq == gpqForeground) {
                fSuccess = xxxActivateThisWindow(pwndActivate, 0,
                        (TestUP(ACTIVEWNDTRKZORDER) ? 0 : ATW_NOZORDER));
            } else {
                fSuccess = xxxSetForegroundWindow2(pwndActivate, NULL,
                        SFW_SWITCH | (TestUP(ACTIVEWNDTRKZORDER) ? 0 : SFW_NOZORDER));
            }

            /*
             * Eat the message if activation failed.
             */
            if (!fSuccess) {
                iRet = MA_SKIP;
            } else if (iRet == MA_ACTIVATEANDEAT) {
               iRet = MA_SKIP;
            }
            break;

        case MA_NOACTIVATEANDEAT:
            iRet = MA_SKIP;
            break;


        case MA_NOACTIVATE:
        default:
            iRet = MA_PASSTHRU;
            break;
    }

    if (pwnd != pwndActivate) {
        ThreadUnlock(&tlpwndActivate);
    }

    return iRet;

}
/***************************************************************************\
* xxxMouseActivate
*
* This is where activation due to mouse clicks occurs.
*
* IMPLEMENTATION:
*     The message is sent to the specified window.  In xxxDefWindowProc, the
*     message is sent to the window's parent.  The receiving window may
*            a) process the message,
*            b) skip the message totally, or
*            c) re-hit test message
*
*     A WM_SETCURSOR message is also sent through the system to set the cursor.
*
* History:
* 11-22-90 DavidPe      Ported.
\***************************************************************************/

int xxxMouseActivate(
    PTHREADINFO pti,
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPPOINT lppt,
    int ht)
{
    UINT x, y;
    PWND pwndTop;
    int result;
    TL tlpwndTop;
    BOOL fSend;

    CheckLock(pwnd);

    UserAssert(_GETPDESK(pwnd) != NULL);

    /*
     * No mouse activation if the mouse is captured. Must check for the capture
     * ONLY here. 123W depends on it - create a graph, select Rearrange..
     * flip horizontal, click outside the graph. If this code checks for
     * anything beside just capture, 123w will get the below messages and
     * get confused.
     */
    if (pti->pq->spwndCapture != NULL) {
        return MA_PASSTHRU;
    }

    result = MA_PASSTHRU;

    pwndTop = pwnd;
    ThreadLockWithPti(pti, pwndTop, &tlpwndTop);

        /*
         * B#1404
         * Don't send WM_PARENTNOTIFY messages if the child has
         * WS_EX_NOPARENTNOTIFY style.
         *
         * Unfortunately, this breaks people who create controls in
         * MDI children, like WinMail.  They don't get WM_PARENTNOTIFY
         * messages, which don't get passed to DefMDIChildProc(), which
         * then can't update the active MDI child.  Grrr.
         */

    fSend = (!TestWF(pwnd, WFWIN40COMPAT) || !TestWF(pwnd, WEFNOPARENTNOTIFY));

    /*
     * If it's a buttondown event, send WM_PARENTNOTIFY.
     */
    switch (message) {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_XBUTTONDOWN:
        while (TestwndChild(pwndTop)) {
            pwndTop = pwndTop->spwndParent;

            if (fSend) {
                ThreadUnlock(&tlpwndTop);
                ThreadLockWithPti(pti, pwndTop, &tlpwndTop);
                x = (UINT)(lppt->x - pwndTop->rcClient.left);
                y = (UINT)(lppt->y - pwndTop->rcClient.top);

                /* Get the xbutton from the hiword of wParam */
                UserAssert(message == WM_XBUTTONDOWN || HIWORD(wParam) == 0);
                UserAssert(LOWORD(wParam) == 0);
                xxxSendMessage(pwndTop, WM_PARENTNOTIFY, (WPARAM)(message | wParam), MAKELPARAM(x, y));
            }
        }

        if (!fSend) {
            ThreadUnlock(&tlpwndTop);
            ThreadLockAlwaysWithPti(pti, pwndTop, &tlpwndTop);
        }

        /*
         * NOTE: We break out of this loop with pwndTop locked.
         */
        break;
    }

    /*
     * The mouse was moved onto this window: make it foreground
     */
    if (TestUP(ACTIVEWINDOWTRACKING) && (message == WM_MOUSEMOVE)) {
        result = xxxActiveWindowTracking(pwnd, WM_MOUSEMOVE, ht);
    }

    /*
     * Are we hitting an inactive top-level window WHICH ISN'T THE DESKTOP(!)?
     *
     * craigc 7-14-89 hitting either inactive top level or any child window,
     * to be compatible with 2.X.  Apps apparently needs this message.
     */
    else if ((pti->pq->spwndActive != pwnd || pti->pq->QF_flags & QF_EVENTDEACTIVATEREMOVED) &&
            (pwndTop != PWNDDESKTOP(pwndTop))) {
        switch (message) {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_XBUTTONDOWN:

            /*
             * Send the MOUSEACTIVATE message.
             */
            result = (int)xxxSendMessage(pwnd, WM_MOUSEACTIVATE,
                    (WPARAM)(HW(pwndTop)), MAKELONG((SHORT)ht, message));

            switch (result) {

            case 0:
            case MA_ACTIVATE:
            case MA_ACTIVATEANDEAT:

                /*
                 * If activation fails, swallow the message.
                 */
                if ((pwndTop != pti->pq->spwndActive ||
                        pti->pq->QF_flags & QF_EVENTDEACTIVATEREMOVED) &&
                        !xxxActivateWindow(pwndTop,
                          (UINT)((pti->pq->codeCapture == NO_CAP_CLIENT) ?
                          AW_TRY2 : AW_TRY))) {
                    result = MA_SKIP;
                } else if (TestWF(pwndTop, WFDISABLED)) {
#ifdef NEVER

                    /*
                     * Althoug this is what win3 does, it is not good: it
                     * can easily cause infinite loops.  Returning "rehittest"
                     * means process this event over again - nothing causes
                     * anything different to happen, and we get an infinite
                     * loop.  This case never gets executed on win3 because if
                     * the window is disabled, it got the HTERROR hittest
                     * code.  This can only be done on Win32 where input is
                     * assigned to a window BEFORE process occurs to pull
                     * it out of the queue.
                     */
                    result = MA_REHITTEST;
#endif

                    /*
                     * Someone clicked on a window before it was disabled...
                     * Since it is disabled now, don't send this message to
                     * it: instead eat it.
                     */
                    result = MA_SKIP;
                } else if (result == MA_ACTIVATEANDEAT) {
                    result = MA_SKIP;
                } else {
                    result = MA_PASSTHRU;
                    goto ItsActiveJustCheckOnTop;
                }
                break;

            case MA_NOACTIVATEANDEAT:
                result = MA_SKIP;
                break;
            }
        }
    } else {
ItsActiveJustCheckOnTop:
        /*
         * Make sure this active window is on top (see comment
         * in CheckOnTop).
         */
        if (TestUP(ACTIVEWINDOWTRACKING)) {
            if (CheckOnTop(pti, pwndTop, message)) {
                /*
                 * The window was z-ordered to the top.
                 * If it is a console window, skip the message
                 *  so it won't go into "selecting" mode
                 * Hard error boxes are created by csrss as well
                 * If we have topmost console windows someday, this
                 *  will need to change
                 */
                 if ((ht == HTCLIENT)
                        && (GETPTI(pwndTop)->TIF_flags & TIF_CSRSSTHREAD)
                        && !(TestWF(pwndTop, WEFTOPMOST))) {

                     RIPMSG2(RIP_WARNING, "xxxMouseActivate: Skipping msg %#lx for pwnd %#p",
                            message, pwndTop);
                     result = MA_SKIP;
                 }
            }
        } /* if (TestUP(ACTIVEWINDOWTRACKING)) */
    }

    /*
     * Now set the cursor shape.
     */
    if (pti->pq->spwndCapture == NULL) {
        xxxSendMessage(pwnd, WM_SETCURSOR, (WPARAM)HW(pwnd),
                MAKELONG((SHORT)ht, message));
    }

    ThreadUnlock(&tlpwndTop);
    return result;
}

/***************************************************************************\
*  ResetMouseHover()
*
*  Resets mouse hover state information.
*
*  11/03/95    francish    created.
*  09/04/97    GerardoB    Rewritten to use per desktop tracking
\***************************************************************************/

void ResetMouseHover(PDESKTOP pdesk, POINT pt)
{
    /*
     * Reset the timer and hover rect
     */
    InternalSetTimer(pdesk->spwndTrack, IDSYS_MOUSEHOVER,
                     pdesk->dwMouseHoverTime,
                    xxxSystemTimerProc, TMRF_SYSTEM);

    SetRect(&pdesk->rcMouseHover,
            pt.x - gcxMouseHover / 2,
            pt.y - gcyMouseHover / 2,
            pt.x + gcxMouseHover / 2,
            pt.y + gcyMouseHover / 2);

}

/***************************************************************************\
*  QueryTrackMouseEvent()
*
*  Fills in a TRACKMOUSEEVENT structure describing current tracking state.
*
*  11/03/95    francish    created.
*  09/04/97    GerardoB    Rewritten to use per desktop tracking
\***************************************************************************/

BOOL QueryTrackMouseEvent(
    LPTRACKMOUSEEVENT lpTME)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOP pdesk = ptiCurrent->rpdesk;

    /*
     * initialize the struct
     */
    RtlZeroMemory(lpTME, sizeof(*lpTME));
    lpTME->cbSize = sizeof(*lpTME);
    /*
     * Bail if not tracking any mouse event
     *  or if the current thread is not in spwndTrack's queue
     */
    if (!(pdesk->dwDTFlags & DF_TRACKMOUSEEVENT)
            || (ptiCurrent->pq != GETPTI(pdesk->spwndTrack)->pq)) {
        return TRUE;
    }
    /*
     * fill in the requested information
     */
    if (pdesk->htEx != HTCLIENT) {
        lpTME->dwFlags |= TME_NONCLIENT;
    }
    if (pdesk->dwDTFlags & DF_TRACKMOUSELEAVE) {
        lpTME->dwFlags |= TME_LEAVE;
    }
    if (pdesk->dwDTFlags & DF_TRACKMOUSEHOVER) {
        lpTME->dwFlags |= TME_HOVER;
        lpTME->dwHoverTime = pdesk->dwMouseHoverTime;
    }

    lpTME->hwndTrack = HWq(pdesk->spwndTrack);

    return TRUE;
}

/***************************************************************************\
*  TrackMouseEvent()
*
*  API for requesting extended mouse notifications (hover, leave, ...)
*
*  11/03/95    francish    created.
*  09/04/97    GerardoB    Rewritten to use per desktop tracking
\***************************************************************************/
BOOL TrackMouseEvent(
    LPTRACKMOUSEEVENT lpTME)
{
    PDESKTOP pdesk = PtiCurrent()->rpdesk;
    PWND     pwnd;

    /*
     * Validate hwndTrack
     */
    pwnd = ValidateHwnd(lpTME->hwndTrack);
    if (pwnd == NULL) {
        return FALSE;
    }
    /*
     * If we're not tracking this window or not in correct hittest, bail
     */
    if ((pwnd != pdesk->spwndTrack)
            || (!!(lpTME->dwFlags & TME_NONCLIENT) ^ (pdesk->htEx != HTCLIENT))) {

        if ((lpTME->dwFlags & TME_LEAVE) && !(lpTME->dwFlags & TME_CANCEL)) {
            _PostMessage(pwnd,
                         ((lpTME->dwFlags & TME_NONCLIENT) ? WM_NCMOUSELEAVE : WM_MOUSELEAVE),
                         0, 0);
        }
        return TRUE;
    }

    /*
     * Process cancel request
     */
    if (lpTME->dwFlags & TME_CANCEL) {
        if (lpTME->dwFlags & TME_LEAVE) {
            pdesk->dwDTFlags &= ~DF_TRACKMOUSELEAVE;
        }
        if (lpTME->dwFlags & TME_HOVER) {
            if (pdesk->dwDTFlags & DF_TRACKMOUSEHOVER) {
                _KillSystemTimer(pwnd, IDSYS_MOUSEHOVER);
                pdesk->dwDTFlags &= ~DF_TRACKMOUSEHOVER;
            }
        }
        return TRUE;
    }

    /*
     * Track mouse leave
     */
    if (lpTME->dwFlags & TME_LEAVE) {
        pdesk->dwDTFlags |= DF_TRACKMOUSELEAVE;
    }
    /*
     * Track mouse hover
     */
    if (lpTME->dwFlags & TME_HOVER) {
        pdesk->dwDTFlags |= DF_TRACKMOUSEHOVER;

        pdesk->dwMouseHoverTime = lpTME->dwHoverTime;
        if ((pdesk->dwMouseHoverTime == 0) || (pdesk->dwMouseHoverTime == HOVER_DEFAULT)) {
            pdesk->dwMouseHoverTime = gdtMouseHover;
        }

        ResetMouseHover(pdesk, GETPTI(pwnd)->ptLast);
    }

    return TRUE;
}

/***************************************************************************\
* xxxGetNextSysMsg
*
* Returns the queue pointer of the next system message or
*  NULL             - no more messages (may be a journal playback delay)
*  PQMSG_PLAYBACK   - got a journal playback message
* (Anything else is a real pointer)
*
* 10-23-92 ScottLu      Created.
\***************************************************************************/

PQMSG xxxGetNextSysMsg(
    PTHREADINFO pti,
    PQMSG pqmsgPrev,
    PQMSG pqmsg)
{
    DWORD dt;
    PMLIST pml;
    PQMSG pqmsgT;

    /*
     * If there is a journal playback hook, call it to get the next message.
     */
    if (PhkFirstGlobalValid(pti, WH_JOURNALPLAYBACK) != NULL && IsOnInputDesktop(pti)) {
        /*
         * We can't search through journal messages: we only get the current
         * journal message. So if the caller has already called us once
         * before, then exit with no messages.
         */
        if (pqmsgPrev != 0)
            return NULL;

        /*
         * Tell the journal playback hook that we're done
         * with this message now.
         */
        dt = xxxCallJournalPlaybackHook(pqmsg);
        if (dt == 0xFFFFFFFF)
            return NULL;

        /*
         * If dt == 0, then we don't need to wait: set the right wake
         * bits and return this message.
         */
        if (dt == 0) {
            WakeSomeone(pti->pq, pqmsg->msg.message, NULL);
            /*
             * Remember input is coming through journalling so we'll know this is
             *  an automation scenario.
             * Note that we don't change any of the glinp information here so it
             *  continues to hold what the actual last hardware or SendInput input event was.
             *  I'm not changing it now to avoid any unexpected side effects from it since
             *   there's no scenario requesting so.
             *  This could pontentially be reconsidered so glinp completely reflects
             *   what the last input event was, regardless of its source.
             */
            glinp.dwFlags = glinp.dwFlags | LINP_JOURNALLING;
            return PQMSG_PLAYBACK;
        } else {
            /*
             * There is logically no more input in the "queue", so clear the
             * bits so that we will sleep when GetMessage is called.
             */
            pti->pcti->fsWakeBits &= ~QS_INPUT;
            pti->pcti->fsChangeBits &= ~QS_INPUT;

            /*
             * Need to wait before processing this next message. Set
             * a journal timer.
             */
            SetJournalTimer(dt, pqmsg->msg.message);

            return NULL;
        }
    }

    /*
     * No journalling going on... return next message in system queue.
     */

    /*
     * Queue up a mouse move if the mouse has moved.
     */
    if (pti->pq->QF_flags & QF_MOUSEMOVED) {
        PostMove(pti->pq);
    }

    /*
     * If no messages in the input queue, return with 0.
     */
    pml = &pti->pq->mlInput;
    if (pml->cMsgs == 0)
        return NULL;

    /*
     * If this is the first call to xxxGetNextSysMsg(), return the
     * first message.
     */
    if (pqmsgPrev == NULL || pti->pq->idSysPeek <= (ULONG_PTR)PQMSG_PLAYBACK) {
        pqmsgT = pml->pqmsgRead;
    } else {
        /*
         * Otherwise return the next message in the queue. Index with
         * idSysPeek, because that is updated by recursive calls through
         * this code.
         */
        pqmsgT = ((PQMSG)(pti->pq->idSysPeek))->pqmsgNext;
    }

    /*
     * Fill in the structure passed, and return the pointer to the
     * current message in the message list. This will become the new
     * pq->idSysPeek.
     */
    if (pqmsgT != NULL)
        *pqmsg = *pqmsgT;
    return pqmsgT;
}

/***************************************************************************\
* UpdateKeyState
*
* Updates queue key state tables.
*
* 11-11-92 ScottLu      Created.
\***************************************************************************/

void UpdateKeyState(
    PQ pq,
    UINT vk,
    BOOL fDown)
{
    if (vk != 0) {
        /*
         * If we're going down, toggle only if the key isn't
         * already down.
         */
        if (fDown && !TestKeyStateDown(pq, vk)) {
            if (TestKeyStateToggle(pq, vk)) {
                ClearKeyStateToggle(pq, vk);
            } else {
                SetKeyStateToggle(pq, vk);
            }
        }

        /*
         * Now set/clear the key down state.
         */
        if (fDown) {
            SetKeyStateDown(pq, vk);
        } else {
            ClearKeyStateDown(pq, vk);
        }

        /*
         * If this is one of the keys we cache, update the key cache index.
         */
        if (vk < CVKKEYCACHE) {
            gpsi->dwKeyCache++;
        }
    }
}

/***************************************************************************\
* EqualMsg
*
* This routine is called in case that idSysPeek points to a message
* and we are trying to remove a different message
*
* 04-25-96 CLupu      Created.
\***************************************************************************/

BOOL EqualMsg(PQMSG pqmsg1, PQMSG pqmsg2)
{
    if (pqmsg1->msg.hwnd    != pqmsg2->msg.hwnd ||
        pqmsg1->msg.message != pqmsg2->msg.message)
        return FALSE;

    /*
     * This might be a coalesced WM_MOUSEMOVE
     */
    if (pqmsg1->msg.message == WM_MOUSEMOVE)
        return TRUE;

    if (pqmsg1->pti      != pqmsg2->pti ||
        pqmsg1->msg.time != pqmsg2->msg.time)
        return FALSE;

    return TRUE;
}

/***************************************************************************\
* xxxSkipSysMsg
*
* This routine "skips" an input message: either by calling the journal
* hooks if we're journalling or by "skipping" the message in the input
* queue. Internal keystate tables are updated as well.
*
* 10-23-92 ScottLu      Created.
\***************************************************************************/

void xxxSkipSysMsg(
    PTHREADINFO pti,
    PQMSG pqmsg)
{
    PQMSG pqmsgT;
    BOOL  fDown;
    BYTE  vk;
    PHOOK phook;

    /*
     * If idSysPeek is 0, then the pqmsg that we were looking at has been
     * deleted, probably because of a callout from ScanSysQueue, and that
     * callout then called PeekMessage(fRemove == TRUE), and then returned.
     */
    if (pti->pq->idSysPeek == 0)
        return;

    phook = PhkFirstGlobalValid(pti, WH_JOURNALPLAYBACK);
    if (phook != NULL && IsOnInputDesktop(pti)) {
        /*
         * Tell the journal playback hook that we're done
         * with this message now.
         */
        phook->flags |= HF_NEEDHC_SKIP;
    } else {
        phook = PhkFirstGlobalValid(pti, WH_JOURNALRECORD);
        if (phook != NULL) {
            /*
             * We've processed a new message: tell the journal record
             * hook what the message is.
             */
            xxxCallJournalRecordHook(pqmsg);
        }

        /*
         * If idSysPeek is 0 now, it means we've been recursed into yet
         * again. This would confuse a journalling app, but it would confuse
         * us more because we'd fault. Return if idSysPeek is 0.
         */
        if ((pqmsgT = (PQMSG)pti->pq->idSysPeek) == NULL)
            return;

        /*
         * Delete this message from the input queue. Make sure pqmsgT isn't
         * 1: this could happen if an app unhooked a journal record hook
         * during a callback from xxxScanSysQueue.
         */
        if (pqmsgT != PQMSG_PLAYBACK) {
            /*
             * There are cases when idSysPeek points to a different message
             * than the one we are trying to remove. This can happen if
             * two threads enters in xxxScanSysQueue, sets the idSysPeek and
             * after this their queues got redistributed. The first thread
             * will have the idSysPeek preserved but the second one has to
             * search the queue for its message. - ask CLupu
             */
            if (!EqualMsg(pqmsgT, pqmsg)) {

                PQMSG pqmsgS;

#if DBG
                if (IsDbgTagEnabled(DBGTAG_SysPeek)) {
                    gnSysPeekSearch++;
                }
#endif

                TAGMSG0(DBGTAG_SysPeek | RIP_THERESMORE,              "Different message than idSysPeek\n");
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "pqmsg   = %#p  idSysPeek = %#p",  pqmsg,              pqmsgT);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "pti     = %#p  pti       = %#p",  pqmsg->pti,         pqmsgT->pti);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "msg     = %08lx  msg       = %08lx",  pqmsg->msg.message, pqmsgT->msg.message);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "hwnd    = %#p  hwnd      = %#p",  pqmsg->msg.hwnd,    pqmsgT->msg.hwnd);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "wParam  = %#p  wParam    = %#p",  pqmsg->msg.wParam,  pqmsgT->msg.wParam);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "lParam  = %#p  lParam    = %#p",  pqmsg->msg.lParam,  pqmsgT->msg.lParam);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "time    = %08lx  time      = %08lx",  pqmsg->msg.time,    pqmsgT->msg.time);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "Extra   = %08lx  Extra     = %08lx",  pqmsg->ExtraInfo,   pqmsgT->ExtraInfo);
                TAGMSG1(DBGTAG_SysPeek | RIP_NONAME,                  "\npqmsgT  = %#p", pqmsgT);

                /*
                 * Begin to search for this message
                 */
                pqmsgS = pti->pq->mlInput.pqmsgRead;

                while (pqmsgS != NULL) {
                    if (EqualMsg(pqmsgS, pqmsg)) {
                        TAGMSG2(DBGTAG_SysPeek | RIP_THERESMORE,
                                "Deleting pqmsg %#p, pti %#p",
                                pqmsgS, pqmsgS->pti);

                        TAGMSG4(DBGTAG_SysPeek | RIP_NONAME,
                                "m %04lx, w %#p, l %#p, t %lx",
                                pqmsgS->msg.message, pqmsgS->msg.hwnd,
                                pqmsgS->msg.lParam, pqmsgS->msg.time);

                        pqmsgT = pqmsgS;
                        break;
                    }
                    pqmsgS = pqmsgS->pqmsgNext;
                }
                if (pqmsgS == NULL) {
                    TAGMSG0(DBGTAG_SysPeek, "Didn't find a matching message. No message removed.");
                    return;
                }
            }

            if (pqmsgT == (PQMSG)pti->pq->idSysPeek) {
                /*
                 * We'll remove this message from the input queue
                 * so set idSysPeek to 0.
                 */
                CheckPtiSysPeek(1, pti->pq, 0);
                pti->pq->idSysPeek = 0;
            }
            DelQEntry(&pti->pq->mlInput, pqmsgT);
        }
    }

    fDown = TRUE;
    vk = 0;

    switch (pqmsg->msg.message) {
    case WM_MOUSEMOVE:
    case WM_QUEUESYNC:
    default:
        /*
         * No state change.
         */
        break;

    case WM_KEYUP:
    case WM_SYSKEYUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        vk = LOBYTE(LOWORD(pqmsg->msg.wParam));
        break;

    case WM_LBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_LBUTTONDOWN:
        vk = VK_LBUTTON;
        break;

    case WM_RBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_RBUTTONDOWN:
        vk = VK_RBUTTON;
        break;

    case WM_MBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_MBUTTONDOWN:
        vk = VK_MBUTTON;
        break;

    case WM_XBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_XBUTTONDOWN:
        UserAssert(GET_XBUTTON_WPARAM(pqmsg->msg.wParam) == XBUTTON1 ||
                   GET_XBUTTON_WPARAM(pqmsg->msg.wParam) == XBUTTON2);

        switch (GET_XBUTTON_WPARAM(pqmsg->msg.wParam)) {
        case XBUTTON1:
            vk = VK_XBUTTON1;
            break;

        case XBUTTON2:
            vk = VK_XBUTTON2;
            break;
        }

        break;
    }

    /*
     * Set toggle and down bits appropriately.
     */
    if ((vk == VK_SHIFT) || (vk == VK_MENU) || (vk == VK_CONTROL)) {
        BYTE vkHanded, vkOtherHand;
        /*
         * Convert this virtual key into a differentiated (Left/Right) key
         * depending on the extended key bit.
         */
        vkHanded = (vk - VK_SHIFT) * 2 + VK_LSHIFT +
                ((pqmsg->msg.lParam & EXTENDED_BIT) ? 1 : 0);
        vkOtherHand = vkHanded ^ 1;

        if (vk == VK_SHIFT) {
            /*
             * Clear extended bit for r.h. Shift, since it isn't really
             * extended (bit was set to indicate right-handed)
             */
            pqmsg->msg.lParam &= ~EXTENDED_BIT;
        }

        /*
         * Update the key state for the differentiated (Left/Right) key.
         */
        UpdateKeyState(pti->pq, vkHanded, fDown);

        /*
         * Update key state for the undifferentiated (logical) key.
         */
        if (fDown || !TestKeyStateDown(pti->pq, vkOtherHand)) {
            UpdateKeyState(pti->pq, vk, fDown);
        }
    } else {
        UpdateKeyState(pti->pq, vk, fDown);
    }
}



#if DBG
/***************************************************************************\
* LogPlayback
*
*
* History:
* 02-13-95 JimA             Created.
\***************************************************************************/

void LogPlayback(
    PWND pwnd,
    PMSG lpmsg)
{
    static PWND pwndM = NULL, pwndK = NULL;
    LPCSTR lpszMsg;
    CHAR achBuf[20];

    if ((lpmsg->message >= WM_MOUSEFIRST) && (lpmsg->message <= WM_MOUSELAST)) {
        lpszMsg = aszMouse[lpmsg->message - WM_MOUSEFIRST];
        if (pwnd != pwndM) {
            DbgPrint("*** Mouse input to window \"%ws\" of class \"%s\"\n",
                    pwnd->strName.Length ? pwnd->strName.Buffer : L"",
                    pwnd->pcls->lpszAnsiClassName);
            pwndM = pwnd;
        }
    } else if ((lpmsg->message >= WM_KEYFIRST) && (lpmsg->message <= WM_KEYLAST)) {
        lpszMsg = aszKey[lpmsg->message - WM_KEYFIRST];
        if (pwnd != pwndK) {
            DbgPrint("*** Kbd input to window \"%ws\" of class \"%s\"\n",
                    pwnd->strName.Length ? pwnd->strName.Buffer : L"",
                    pwnd->pcls->lpszAnsiClassName);
            pwndK = pwnd;
        }
    } else if (lpmsg->message == WM_QUEUESYNC) {
        lpszMsg = "WM_QUEUESYNC";
    } else {
        sprintf(achBuf, "0x%4x", lpmsg->message);
        lpszMsg = achBuf;
    }
    DbgPrint("msg = %s, wP = %x, lP = %x\n", lpszMsg,
            lpmsg->wParam, lpmsg->lParam);
}
#endif  // DBG

/***************************************************************************\
*
*  GetMouseKeyFlags()
*
*  Computes MOST of the MK_ flags given a Q.
*  Does not compute MK_MOUSEENTER.
*
\***************************************************************************/

UINT GetMouseKeyFlags(
    PQ pq)
{
    UINT wParam = 0;

    if (TestKeyStateDown(pq, VK_LBUTTON))
        wParam |= MK_LBUTTON;
    if (TestKeyStateDown(pq, VK_RBUTTON))
        wParam |= MK_RBUTTON;
    if (TestKeyStateDown(pq, VK_MBUTTON))
        wParam |= MK_MBUTTON;
    if (TestKeyStateDown(pq, VK_XBUTTON1))
        wParam |= MK_XBUTTON1;
    if (TestKeyStateDown(pq, VK_XBUTTON2))
        wParam |= MK_XBUTTON2;
    if (TestKeyStateDown(pq, VK_SHIFT))
        wParam |= MK_SHIFT;
    if (TestKeyStateDown(pq, VK_CONTROL))
        wParam |= MK_CONTROL;

    return wParam;
}

/***************************************************************************\
* xxxScanSysQueue
*
* This routine looks at the hardware message, determines what
* window it will be in, determines what the input message will
* be, and then checks the destination window against hwndFilter,
* and the input message against msgMinFilter and msgMaxFilter.
*
* It also updates various input synchronized states like keystate info.
*
* This is almost verbatim from Win3.1.
*
* 10-20-92 ScottLu      Created.
\***************************************************************************/

#ifdef MARKPATH
#define PATHTAKEN(x)  pathTaken  |= x
#define PATHTAKEN2(x) pathTaken2 |= x
#define PATHTAKEN3(x) pathTaken3 |= x
#define DUMPPATHTAKEN() if (gfMarkPath) DbgPrint("xxxScanSysQueue path:%08x %08x %08x\n", pathTaken, pathTaken2, pathTaken3)
#define DUMPSUBPATHTAKEN(p, x) if (gfMarkPath && p & x) { DbgPrint("  %08x %08x %08x\n", pathTaken, pathTaken2, pathTaken3); pathTaken = pathTaken2 = pathTaken3 = 0; }
#else
#define PATHTAKEN(x)
#define PATHTAKEN2(x)
#define PATHTAKEN3(x)
#define DUMPPATHTAKEN()
#define DUMPSUBPATHTAKEN(p, x)
#endif

BOOL xxxScanSysQueue(
    PTHREADINFO ptiCurrent,
    LPMSG lpMsg,
    PWND pwndFilter,
    UINT msgMinFilter,
    UINT msgMaxFilter,
    DWORD flags,
    DWORD fsReason)
{
    QMSG qmsg;
    HWND hwnd;
    PWND pwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    PTHREADINFO ptiKeyWake, ptiMouseWake, ptiEventWake;
#ifdef GENERIC_INPUT
    PTHREADINFO ptiRawInputWake;
#endif
    POINT pt, ptScreen;
    UINT codeMouseDown;
    BOOL fMouseHookCalled;
    BOOL fKbdHookCalled;
    BOOL fOtherApp;
    int part;
    MOUSEHOOKSTRUCTEX mhs;
    PWND pwndT;
    BOOL fPrevDown;
    BOOL fDown;
    BOOL fAlt;
    TL tlpwnd;
    TL tlpwndT;
    TL tlptiKeyWake;
    TL tlptiMouseWake;
    TL tlptiEventWake;
#ifdef GENERIC_INPUT
    TL tlptiRawInputWake;
#endif
    BOOL fRemove = (flags & PM_REMOVE);
    DWORD dwImmRet = 0;
#ifdef MARKPATH
    DWORD pathTaken = 0;
    DWORD pathTaken2 = 0;
    DWORD pathTaken3 = 0;
#endif

    UserAssert(IsWinEventNotifyDeferredOK());
    UserAssert((fsReason & ~(QS_EVENT | QS_INPUT)) == 0 &&
               (fsReason & (QS_EVENT | QS_INPUT)) != 0);

    /*
     * If we are looking at a peeked message currently (recursion into this
     * routine) and the only reason we got here was because of an event
     * message (an app was filtering for a non-input message), then just
     * return so we don't mess up idSysPeek. If we do enter this code
     * idSysPeek will get set back to 0, and when we return back into
     * the previous xxxScanSysQueue(), SkipSysMsg() will do nothing, so the
     * message won't get removed. (MS Publisher 2.0 does this).
     */
    if (fsReason == QS_EVENT) {
        if (ptiCurrent->pq->idSysPeek != 0) {
            PATHTAKEN(1);
            DUMPPATHTAKEN();
            return FALSE;
        }
    }

    fDown = FALSE;
    fMouseHookCalled = FALSE;
    fKbdHookCalled = FALSE;

    /*
     * Lock the queue if it's currently unlocked.
     */
    if (ptiCurrent->pq->ptiSysLock == NULL) {
        CheckSysLock(3, ptiCurrent->pq, ptiCurrent);
        ptiCurrent->pq->ptiSysLock = ptiCurrent;
        ptiCurrent->pcti->CTIF_flags |= CTIF_SYSQUEUELOCKED;
    }

    /*
     * Flag to tell if locker was removing messages. If not, then next time
     * Get/PeekMessage is called, the input message list is scanned before the
     * post msg list.
     *
     * Under Win3.1, this flag only gets modified for key and mouse messages.
     * Since under NT ScanSysQueue() can be called to execute event messages,
     * we make this check to be compatible.
     */
    if (fsReason & QS_INPUT) {
        if (fRemove) {
            PATHTAKEN(2);
            ptiCurrent->pq->QF_flags &= ~QF_LOCKNOREMOVE;
        } else {
            PATHTAKEN(4);
            ptiCurrent->pq->QF_flags |= QF_LOCKNOREMOVE;
        }
    }

    /*
     * Return FALSE if the current thread is not the one that lock this queue.
     */
    if (ptiCurrent->pq->ptiSysLock != ptiCurrent) {
        PATHTAKEN(8);
        DUMPPATHTAKEN();
        return FALSE;
    }

    ptiEventWake = ptiKeyWake = ptiMouseWake = NULL;
#ifdef GENERIC_INPUT
    ptiRawInputWake = NULL;
#endif
    ThreadLockPti(ptiCurrent, ptiKeyWake,   &tlptiKeyWake);
    ThreadLockPti(ptiCurrent, ptiMouseWake, &tlptiMouseWake);
    ThreadLockPti(ptiCurrent, ptiEventWake, &tlptiEventWake);
#ifdef GENERIC_INPUT
    ThreadLockPti(ptiCurrent, ptiRawInputWake, &tlptiRawInputWake);
#endif

    /*
     * Initialize the thread lock structure here so we can unlock/lock in
     * the main loop.
     */
    pwnd = NULL;
    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);

RestartScan:
    CheckPtiSysPeek(2, ptiCurrent->pq, 0);
    ptiCurrent->pq->idSysPeek = 0;

ContinueScan:
    while (TRUE) {
        ULONG_PTR idSysPeek;

        DUMPSUBPATHTAKEN(pathTaken, 0xf0);
        /*
         * Store idSysPeek in a local which forces pq to be reloaded
         * in case it changed during the xxx call (the compiler can
         * evaluate the LValue at any time)
         */
        idSysPeek = (ULONG_PTR)xxxGetNextSysMsg(ptiCurrent,
                (PQMSG)ptiCurrent->pq->idSysPeek, &qmsg);
        CheckPtiSysPeek(3, ptiCurrent->pq, idSysPeek);
        ptiCurrent->pq->idSysPeek = idSysPeek;

        if (ptiCurrent->pq->idSysPeek == 0) {
            /*
             * If we are only looking for event messages and we didn't
             * find any, then clear the QS_EVENT bit
             */
            if (fsReason == QS_EVENT)
                ClearWakeBit(ptiCurrent, QS_EVENT, FALSE);
            PATHTAKEN(0x10);
            goto NoMessages;
        }

        /*
         * pwnd should be locked for the duration of this routine.
         * For most messages right out of GetNextSysMsg, this is
         * NULL.
         */
        ThreadUnlock(&tlpwnd);
        pwnd = RevalidateHwnd(qmsg.msg.hwnd);
        ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);

        /*
         * See if this is an event message. If so, execute it regardless
         * of message and window filters, but only if it is the first element
         * of the input queue.
         */
        if (qmsg.dwQEvent != 0) {
            PTHREADINFO pti;

            PATHTAKEN(0x20);
            /*
             * Most event messages can be executed out of order relative to
             * its place in the queue. There are some examples were this is
             * not allowed, and we check that here. For example, we would not
             * want a keystate synchronization event to be processed before
             * the keystrokes that came before it in the queue!
             *
             * We need to have most event messages be able to get processed
             * out of order because apps can be filtering for message ranges
             * that don't include input (like dde) - those scenarios still
             * need to process events such as deactivate event messages even
             * if there is input in the input queue.
             */
            switch (qmsg.dwQEvent) {
            case QEVENT_UPDATEKEYSTATE:
                /*
                 * If the message is not the next message in the queue, don't
                 * process it.
                 */
                if (ptiCurrent->pq->idSysPeek !=
                        (ULONG_PTR)ptiCurrent->pq->mlInput.pqmsgRead) {
                    PATHTAKEN(0x40);
                    continue;
                }
                break;
            }

            /*
             * If this event isn't for this thread, wake the thread it is
             * for.  A NULL qmsg.hti means that any thread can process
             * the event.
             */
            if (qmsg.pti != NULL && (pti = qmsg.pti) != ptiCurrent) {

                /*
                 * If somehow this event message got into the wrong queue,
                 * then ignore it.
                 */
                UserAssert(pti->pq == ptiCurrent->pq);
                if (pti->pq != ptiCurrent->pq) {
                    CleanEventMessage((PQMSG)ptiCurrent->pq->idSysPeek);
                    DelQEntry(&ptiCurrent->pq->mlInput,
                            (PQMSG)ptiCurrent->pq->idSysPeek);
                    PATHTAKEN(0x80);
                    goto RestartScan;
                }

                /*
                 * If ptiEventWake is already set, it means we've already
                 * found a thread to wake for event.
                 */
                if (ptiEventWake == NULL) {
                    ptiEventWake = pti;
                    ThreadLockExchangePti(ptiEventWake, &tlptiEventWake);
                }

                /*
                 * Clear idSysPeek so that the targeted thread
                 * can always get it.  Look at the test at the
                 * start of this routine for more info.
                 */
                CheckPtiSysPeek(4, ptiCurrent->pq, 0);
                ptiCurrent->pq->idSysPeek = 0;
                PATHTAKEN(0x100);
                goto NoMessages;
            }

            /*
             * If this is called with PM_NOYIELD from a 16-bit app, skip
             * processing any event that can generate activation messages.  An
             * example is printing from PageMaker 5.0.  Bug #12662.
             */
            if ((flags & PM_NOYIELD) && (ptiCurrent->TIF_flags & TIF_16BIT)) {
                PATHTAKEN(0x200);
                switch (qmsg.dwQEvent) {

                /*
                 * The following events are safe to process if no yield
                 * is to occur.
                 */
                case QEVENT_UPDATEKEYSTATE:
                case QEVENT_ASYNCSENDMSG:
                    break;

                /*
                 * Skip all other events.
                 */
                default:
                    try {
                        ptiCurrent->pClientInfo->dwTIFlags = ptiCurrent->TIF_flags | TIF_DELAYEDEVENT;
                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                        goto ContinueScan;
                    }
                    ptiCurrent->TIF_flags |= TIF_DELAYEDEVENT;
                    PATHTAKEN(0x400);
                    goto ContinueScan;
                }
            }

            /*
             * Delete this before it gets processed so there are no
             * recursion problems.
             */
            DelQEntry(&ptiCurrent->pq->mlInput,
                    (PQMSG)ptiCurrent->pq->idSysPeek);

            /*
             * Clear idSysPeek before processing any events messages, because
             * they may recurse and want to use idSysPeek.
             */
            CheckPtiSysPeek(5, ptiCurrent->pq, 0);
            ptiCurrent->pq->idSysPeek = 0;
            xxxProcessEventMessage(ptiCurrent, &qmsg);

            /*
             * Restart the scan from the start so we start with 0 in
             * pq->idSysPeek (since that message is now gone!).
             */
            PATHTAKEN(0x800);
            goto RestartScan;
        }

        /*
         * If the reason we called was just to process event messages, don't
         * enumerate any other mouse or key messages!
         */
        if (fsReason == QS_EVENT) {
            PATHTAKEN(0x1000);
            continue;
        }

        switch (message = qmsg.msg.message) {
        case WM_QUEUESYNC:
            PATHTAKEN(0x2000);
            /*
             * This message is for CBT. Its parameters should already be
             * set up correctly.
             */
            wParam = 0;
            lParam = qmsg.msg.lParam;

            /*
             * Check if this is intended for the current app. Use the mouse
             * bit for WM_QUEUESYNC.
             */
            if (pwnd != NULL && GETPTI(pwnd) != ptiCurrent) {
                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen with
                 * WM_QUEUESYNC if the app passed a window handle
                 * to the wrong queue. This isn't likely to happen in
                 * this case because WM_QUEUESYNCs come in while journalling,
                 * which has all threads sharing the same queue.
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN(0x4000);
                    goto SkipMessage;
                }

                if (ptiMouseWake == NULL) {
                    ptiMouseWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiMouseWake, &tlptiMouseWake);
                }
                PATHTAKEN(0x8000);
                goto NoMessages;
            }

            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter)) {
                PATHTAKEN(0x10000);
                goto NoMessages;
            }

            /*
             * Eat the message.
             */
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            /*
             * !!HARDWARE HOOK!! goes here.
             */

            /*
             * Return the message.
             */
            PATHTAKEN(0x20000);
            goto ReturnMessage;
            break;

        /*
         * Mouse message or generic hardware messages
         * Key messages are handled in case statements
         * further down in this switch.
         */
        default:
ReprocessMsg:
            DUMPSUBPATHTAKEN(pathTaken, 0x40000);
            PATHTAKEN(0x40000);
            /*
             * !!GENERIC HARDWARE MESSAGE!! support goes here.
             */

            /*
             * Take the mouse position out of the message.
             */
            pt.x = (int)(short)LOWORD(qmsg.msg.lParam);
            pt.y = (int)(short)HIWORD(qmsg.msg.lParam);

            /*
             * Assume we have a capture.
             */
            part = HTCLIENT;

            /*
             * We have a special global we use for when we're full screen.
             * All mouse input will go to this window.
             */
            if (gspwndScreenCapture != NULL) {
                /*
                 * Change the mouse coordinates to full screen.
                 */
                pwnd = gspwndScreenCapture;
                lParam = MAKELONG((WORD)qmsg.msg.pt.x,
                        (WORD)qmsg.msg.pt.y);
                PATHTAKEN(0x80000);
            } else if ((pwnd = ptiCurrent->pq->spwndCapture) == NULL) {

                PATHTAKEN(0x100000);
                /*
                 * We don't have the capture. Figure out which window owns
                 * this message.
                 *
                 * NOTE: Use gptiRit and not ptiCurrent to get the desktop
                 * window because if ptiCurrent is the thread that created
                 * the main desktop, it's associated desktop is the logon
                 * desktop - don't want to hittest against the logon desktop
                 * while switched into the main desktop!
                 */
                pwndT = gptiRit->rpdesk->pDeskInfo->spwnd;

                ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

                hwnd = xxxWindowHitTest(pwndT, pt, &part, WHT_IGNOREDISABLED);
                ThreadUnlock(&tlpwndT);

                if ((pwnd = RevalidateHwnd(hwnd)) == NULL) {
                    pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;
                    PATHTAKEN(0x200000);
                    if (pwnd == NULL) {
                        pwnd = gptiRit->rpdesk->pDeskInfo->spwnd;
                    }
                }

                if (part == HTCLIENT) {
                    /*
                     * Part of the client... normal mouse message.
                     * NO_CAP_CLIENT means "not captured, in client area
                     * of window".
                     */
                    ptiCurrent->pq->codeCapture = NO_CAP_CLIENT;
                    PATHTAKEN(0x400000);
                } else {
                    /*
                     * Not part of the client... must be an NCMOUSEMESSAGE.
                     * NO_CAP_SYS is a creative name by raor which means
                     * "not captured, in system area of window."
                     */
                    ptiCurrent->pq->codeCapture = NO_CAP_SYS;
                    PATHTAKEN(0x800000);
                }
            }

            /*
             * We've reassigned pwnd, so lock it.
             */
            ThreadLockExchange(pwnd, &tlpwnd);

            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {

                PATHTAKEN(0x1000000);
                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    zzzSetCursor(SYSCUR(ARROW));
                    PATHTAKEN(0x2000000);
                    goto SkipMessage;
                }

                /*
                 * If we haven't already found a message that is intended
                 * for another app, remember that we have one.
                 */
                if (ptiMouseWake == NULL) {
                    ptiMouseWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiMouseWake, &tlptiMouseWake);
                    PATHTAKEN(0x4000000);
                }
            }

            /*
             * Map mouse coordinates based on hit test area code.
             */
            ptScreen = pt;
            switch (ptiCurrent->pq->codeCapture) {
            case CLIENT_CAPTURE:
            case NO_CAP_CLIENT:
                //Screen To Client
                if (TestWF(pwnd, WEFLAYOUTRTL)) {
                    pt.x = pwnd->rcClient.right - pt.x;
                } else {
                    pt.x -= pwnd->rcClient.left;
                }
                pt.y -= pwnd->rcClient.top;
                PATHTAKEN2(2);
                break;

            case WINDOW_CAPTURE:
                //Screen To Window
                if (TestWF(pwnd, WEFLAYOUTRTL)) {
                    pt.x = pwnd->rcWindow.right - pt.x;
                } else {
                    pt.x -= pwnd->rcWindow.left;
                }
                pt.y -= pwnd->rcWindow.top;
                PATHTAKEN2(4);
                break;
            }

            /*
             * Track mouse moves when it moves to a different window or
             * a different hit-test area for hot-tracking, tooltips,
             * active window tracking and TrackMouseEvent.
             * Mouse clicks reset tracking state too.
             * Do it only if the message is for the current thread;
             *  otherwise, the hit test code (part) is not valid
             *  (it's always HTCLIENT; see xxxWindowHitTest2).
             *  Tracking will take place when that thread wakes up
             * We also don't do it if this thread is not on pqCursor;
             *  that would be the case for a slow app that gets the
             *  input message when the mouse has already left its queue
             */
             if (!fOtherApp && (ptiCurrent->pq == gpqCursor)) {
                 BOOL fNewpwndTrack = (ptiCurrent->rpdesk->spwndTrack != pwnd);
                 int htEx = FindNCHitEx(pwnd, part, pt);
                 if ((message != WM_MOUSEMOVE)
                        || fNewpwndTrack
                        || (ptiCurrent->rpdesk->htEx != htEx)) {

                     xxxTrackMouseMove(pwnd, htEx, message);
                     ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&tlpwnd, TRUE);
                 }

                 /*
                  * Reset mouse hovering if needed.
                  *
                  */
                 if (!fNewpwndTrack && (ptiCurrent->rpdesk->dwDTFlags & DF_TRACKMOUSEHOVER)) {
                     if ((message != WM_MOUSEMOVE)
                            || !PtInRect(&ptiCurrent->rpdesk->rcMouseHover, ptScreen)) {

                         ResetMouseHover(ptiCurrent->rpdesk, ptScreen);
                     }
                 } else {
                     /*
                      * Hover must be canceled.
                      */
                     UserAssert(!(ptiCurrent->rpdesk->dwDTFlags & DF_TRACKMOUSEHOVER));
                 }

             } /* if (!fOtherApp.... */

            /*
             * Now see if it matches the window handle filter. If not,
             * get the next message.
             */
            if (!CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN(0x8000000);
                continue;
            }

            /*
             * See if we need to map to a double click.
             */
            codeMouseDown = 0;
            switch (message) {
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_XBUTTONDOWN:
                if (TestCF(pwnd, CFDBLCLKS) ||
                        ptiCurrent->pq->codeCapture == NO_CAP_SYS ||
                        IsMenuStarted(ptiCurrent)) {
                    codeMouseDown++;
                    PATHTAKEN(0x10000000);
                    if (qmsg.msg.time <= ptiCurrent->pq->timeDblClk &&
                            (!gbClientDoubleClickSupport) &&
                            HW(pwnd) == ptiCurrent->pq->hwndDblClk &&
                            message == ptiCurrent->pq->msgDblClk &&
                            (message != WM_XBUTTONDOWN ||
                              GET_XBUTTON_WPARAM(qmsg.msg.wParam) == ptiCurrent->pq->xbtnDblClk)) {
                        RECT rcDblClk = {
                            ptiCurrent->pq->ptDblClk.x - SYSMET(CXDOUBLECLK) / 2,
                            ptiCurrent->pq->ptDblClk.y - SYSMET(CYDOUBLECLK) / 2,
                            ptiCurrent->pq->ptDblClk.x + SYSMET(CXDOUBLECLK) / 2,
                            ptiCurrent->pq->ptDblClk.y + SYSMET(CYDOUBLECLK) / 2
                        };
                        if (PtInRect(&rcDblClk, qmsg.msg.pt)) {
                            message += (WM_LBUTTONDBLCLK - WM_LBUTTONDOWN);
                            codeMouseDown++;
                            PATHTAKEN(0x20000000);
                        }
                    }
                }

            // FALL THROUGH!!!

            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_MBUTTONUP:
            case WM_XBUTTONUP:
                /*
                 * Note that the mouse button went up or down if we were
                 * in menu status mode of alt-key down
                 */

                PATHTAKEN(0x40000000);
                if (ptiCurrent->pq->QF_flags & QF_FMENUSTATUS) {
                    ptiCurrent->pq->QF_flags |= QF_FMENUSTATUSBREAK;
                    PATHTAKEN(0x80000000);
                }
            }

            /*
             * Map message number based on hit test area code.
             */
            if (ptiCurrent->pq->codeCapture == NO_CAP_SYS) {
                message += (UINT)(WM_NCMOUSEMOVE - WM_MOUSEMOVE);
                wParam = (UINT)part;
                PATHTAKEN2(1);
            }

            /*
             * Message number has been mapped: see if it fits the filter.
             * If not, get the next message.
             */
            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter)) {
                PATHTAKEN2(8);
                continue;
            }

             /*
             * If message is for another app but it fits our filter, then
             * we should stop looking for messages: this will ensure that
             * we don't keep looking and find and process a message that
             * occured later than the one that should be processed by the
             * other guy.
             */
            if (fOtherApp) {
                PATHTAKEN2(0x10);
                goto NoMessages;
            }

            /*
             * If we're doing full drag, the mouse messages should go to
             * the xxxMoveSize PeekMessage loop. So we get the next message.
             * This can happen when an application does a PeekMessage in
             * response to a message sent inside the movesize dragging loop.
             * This causes the dragging loop to not get the WM_LBUTTONUP
             * message and dragging continues after the button is up
             * (fix for Micrografx Draw). -johannec
             */
            if (message >= WM_MOUSEFIRST && message <= WM_MOUSELAST &&
                    ptiCurrent->TIF_flags & TIF_MOVESIZETRACKING) {
                PATHTAKEN2(0x20);
                continue;
            }

            if (ptiCurrent->TIF_flags & TIF_MSGPOSCHANGED) {
                ptiCurrent->TIF_flags &= ~TIF_MSGPOSCHANGED;
                xxxWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, NULL,
                    OBJID_CURSOR, INDEXID_CONTAINER, TRUE);
                ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&tlpwnd, TRUE);
            }

            /*
             * Let us call the mouse hook to find out if this click is
             * permitted by it.
             *
             * We want to inform the mouse hook before we test for
             * HTNOWHERE and HTERROR; Otherwise, the mouse hook won't
             * get these messages (sankar 12/10/91).
             */
            if (IsHooked(ptiCurrent, WHF_MOUSE)) {
                fMouseHookCalled = TRUE;
                mhs.pt = qmsg.msg.pt;
                mhs.hwnd = HW(pwnd);
                mhs.wHitTestCode = (UINT)part;
                mhs.dwExtraInfo = qmsg.ExtraInfo;
                UserAssert(LOWORD(qmsg.msg.wParam) == 0);
                mhs.mouseData = (DWORD)qmsg.msg.wParam;

                if (xxxCallMouseHook(message, &mhs, fRemove)) {
                    /*
                     * Not allowed by mouse hook; so skip it.
                     */
                    PATHTAKEN2(0x40);
                    goto SkipMessage;
                }
                PATHTAKEN2(0x80);
                ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&tlpwnd, TRUE);
            }

            /*
             * If a HTERROR or HTNOWHERE occured, send the window the
             * WM_SETCURSOR message so it can beep or whatever. Then skip
             * the message and try the next one.
             */
            switch (part) {
            case HTERROR:
            case HTNOWHERE:
                /*
                 * Now set the cursor shape.
                 */
                xxxSendMessage(pwnd, WM_SETCURSOR, (WPARAM)HW(pwnd),
                        MAKELONG(part, qmsg.msg.message));

                /*
                 * Skip the message.
                 */
                PATHTAKEN2(0x100);
                goto SkipMessage;
                break;
            }

            if (fRemove) {
                PATHTAKEN2(0x200);
                /*
                 * Since the processing of a down click may cause the next
                 * message to be interpreted as a double click, we only want
                 * to do the double click setup if we're actually going to
                 * remove the message.  Otherwise, the next time we read the
                 * same message it would be interpreted as a double click.
                 */
                switch (codeMouseDown) {
                case 1:
                    /*
                     * Down clock: set up for later possible double click.
                     */
                    ptiCurrent->pq->msgDblClk = qmsg.msg.message;

                    /*
                     * Note that even if the following assertion were not true,
                     * we could still put bogus data in ptiCurrent->pq->xbtnDblClk
                     * when the message is not WM_XBUTTONDOWN, since when we check
                     * for dblclick we compare the message number before the xbtnDblClk.
                     */
                    UserAssert(qmsg.msg.message == WM_XBUTTONDOWN || GET_XBUTTON_WPARAM(qmsg.msg.wParam) == 0);
                    ptiCurrent->pq->xbtnDblClk = GET_XBUTTON_WPARAM(qmsg.msg.wParam);

                    ptiCurrent->pq->timeDblClk = qmsg.msg.time + gdtDblClk;
                    ptiCurrent->pq->hwndDblClk = HW(pwnd);
                    ptiCurrent->pq->ptDblClk = qmsg.msg.pt;
                    PATHTAKEN2(0x400);
                    break;

                case 2:
                    /*
                     * Double click: finish processing.
                     */
                    ptiCurrent->pq->timeDblClk = 0L;
                    PATHTAKEN2(0x800);
                    break;

                default:
                    PATHTAKEN2(0x1000);
                    break;
                }

                /*
                 * Set mouse cursor and allow app to activate window
                 * only if we're removing the message.
                 */
                switch (xxxMouseActivate(ptiCurrent, pwnd,
                        qmsg.msg.message, qmsg.msg.wParam, &qmsg.msg.pt, part)) {
SkipMessage:
                case MA_SKIP:
                    DUMPSUBPATHTAKEN(pathTaken2, 0x2000);
                    PATHTAKEN2(0x2000);
                    xxxSkipSysMsg(ptiCurrent, &qmsg);

                    /*
                     * Inform the CBT hook that we skipped a mouse click.
                     */
                    if (fMouseHookCalled) {
                        if (IsHooked(ptiCurrent, WHF_CBT)) {
                            xxxCallHook(HCBT_CLICKSKIPPED, message,
                                    (LPARAM)&mhs, WH_CBT);
                            PATHTAKEN2(0x4000);
                        }
                        fMouseHookCalled = FALSE;
                    }

                    /*
                     * Inform the CBT hook that we skipped a key
                     */
                    if (fKbdHookCalled) {
                        if (IsHooked(ptiCurrent, WHF_CBT)) {
                            xxxCallHook(HCBT_KEYSKIPPED, wParam, lParam,
                                    WH_CBT);
                            PATHTAKEN2(0x8000);
                        }
                        fKbdHookCalled = FALSE;
                    }

                    /*
                     * If we aren't removing messages, don't reset idSysPeek
                     * otherwise we will go into an infinite loop if
                     * the keyboard hook says to ignore the message.
                     * (bobgu 4/7/87).
                     */
                    if (!fRemove) {
                        PATHTAKEN2(0x10000);
                        goto ContinueScan;
                    } else {
                        PATHTAKEN2(0x20000);
                        goto RestartScan;
                    }
                    break;

                case MA_REHITTEST:
                    /*
                     * Reprocess the message.
                     */
                    PATHTAKEN2(0x40000);
                    goto ReprocessMsg;
                }
            }

            /*
             * Eat the message from the input queue (and set the keystate
             * table).
             */
            PATHTAKEN2(0x80000);
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            if (fRemove && fMouseHookCalled && IsHooked(ptiCurrent, WHF_CBT)) {
                xxxCallHook(HCBT_CLICKSKIPPED, message,
                        (LPARAM)&mhs, WH_CBT);
            }
            fMouseHookCalled = FALSE;

            lParam = MAKELONG((short)pt.x, (short)pt.y);

            /*
             * Calculate virtual key state bitmask for wParam.
             */
            if (message >= WM_MOUSEFIRST) {
                /*
                 * This is a USER mouse message. Calculate the bit mask for the
                 * virtual key state.
                 */
                wParam = GetMouseKeyFlags(ptiCurrent->pq);
                PATHTAKEN2(0x100000);
            }

            if (    (WM_NCXBUTTONFIRST <= message && message <= WM_NCXBUTTONLAST) ||
                    (WM_XBUTTONFIRST <= message && message <= WM_XBUTTONLAST)) {

                /*
                 * The hiword of wParam is assigned the xbutton number when
                 * the message is queued.
                 */
                UserAssert(LOWORD(qmsg.msg.wParam) == 0);
                UserAssert(HIWORD(wParam) == 0);
                wParam |= qmsg.msg.wParam;
            }

            PATHTAKEN2(0x200000);

            /*
             * If this app has a modeles menu bar,
             *  then the menu code should get the first shot at messages on the menu
             * Note that this assumes that xxxHandleMenuMessages
             *  doens't need any of the stuff set after ReturnMessage
             */
            if ((part == HTMENU)
                    && fRemove
                    && (ptiCurrent->pMenuState != NULL)
                    && ptiCurrent->pMenuState->fModelessMenu
                    && (ptiCurrent->pMenuState->pGlobalPopupMenu != NULL)
                    && (ptiCurrent->pMenuState->pGlobalPopupMenu->fIsMenuBar)) {

                if (xxxCallHandleMenuMessages(ptiCurrent->pMenuState, pwnd, message, wParam, lParam)) {
                    goto RestartScan;
                }
            }

            goto ReturnMessage;
            break;

        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            fDown = TRUE;

            /*
             * If we are sending keyboard input to an app that has been
             * spinning then boost it back up.  If we don't you use spinning
             * apps like Write or Project and do two builds in the
             * background.  Note the app will also be unboosted again shortly
             * after you stop typing by the old logic. #11188
             */
            if (ptiCurrent->TIF_flags & TIF_SPINNING) {
                if (!NT_SUCCESS(CheckProcessForeground(ptiCurrent))) {
                    goto NoMessages;
                }
            }

            /*
             * Apps doing journal playback sometimes put trash in the hiword
             * of wParam... zero it out here.
             */
            wParam = qmsg.msg.wParam & 0xFF;

            /*
             * Clear QF_FMENUSTATUS if a key other than Alt it hit
             * since this means the break of the Alt wouldn't be a
             * menu key anymore.
             */
            if (wParam != VK_MENU)
                ptiCurrent->pq->QF_flags &= ~(QF_FMENUSTATUS|QF_FMENUSTATUSBREAK);

            /*
             * Check for keyboard language toggle.  Build the key state
             * here for use during key up processing (where the layout
             * switching takes place.  This code is skipped if layout
             * switching via the keyboard is disabled.
             */
            if (gLangToggle[0].bVkey && (gLangToggleKeyState < KLT_NONE)) {
                DWORD i;
                BYTE scancode = LOBYTE(HIWORD(qmsg.msg.lParam));
                BYTE vkey = LOBYTE(qmsg.msg.wParam);

                for (i = 0; i < LANGTOGGLEKEYS_SIZE; i++) {
                    if (gLangToggle[i].bScan) {
                        if (gLangToggle[i].bScan == scancode) {
                            gLangToggleKeyState |= gLangToggle[i].iBitPosition;
                            break;
                        }
                    } else {
                        if (gLangToggle[i].bVkey == vkey) {
                            gLangToggleKeyState |= gLangToggle[i].iBitPosition;
                            break;
                        }
                    }
                }

                if (i == LANGTOGGLEKEYS_SIZE) {
                    gLangToggleKeyState = KLT_NONE;   // not a language toggle combination
                }
            }

            /*
             * Check if it is the PrintScrn key.
             */
            fAlt = TestKeyStateDown(ptiCurrent->pq, VK_MENU);
            if (wParam == VK_SNAPSHOT &&
                ((fAlt && !(ptiCurrent->fsReserveKeys & CONSOLE_ALTPRTSC)) ||
                 (!fAlt && !(ptiCurrent->fsReserveKeys & CONSOLE_PRTSC)))) {

                /*
                 * Remove this message from the input queue.
                 */
                PATHTAKEN2(0x400000);
                xxxSkipSysMsg(ptiCurrent, &qmsg);

                /*
                 * PRINTSCREEN          -> Snap the whole screen.
                 * ALT-PRINTSCREEN      -> Snap the current window.
                 */
                pwndT = ptiCurrent->pq->spwndActive;

                /*
                 * check also the scan code to see if we got here
                 * through keybd_event(VK_SNAPSHOT, ...
                 * the scan code is in lParam bits 16-23
                 */
                if (!fAlt && ((qmsg.msg.lParam & 0x00FF0000) != 0x00010000)) {
                    pwndT = ptiCurrent->rpdesk->pDeskInfo->spwnd;
                }

                if (pwndT != NULL) {
                    ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);
                    xxxSnapWindow(pwndT);
                    ThreadUnlock(&tlpwndT);
                }

                PATHTAKEN2(0x800000);
                goto RestartScan;
            }

            /*
             * Check for hot keys being hit if any are defined.
             */
            if (gcHotKey != 0 && (!gfEnableHexNumpad || (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) == 0)) {
                UINT key;
                key = (UINT)wParam;

                if (TestKeyStateDown(ptiCurrent->pq, VK_MENU))
                    key |= 0x0400;

                if (TestKeyStateDown(ptiCurrent->pq, VK_CONTROL))
                    key |= 0x0200;

                if (TestKeyStateDown(ptiCurrent->pq, VK_SHIFT))
                    key |= 0x0100;

                pwndT = HotKeyToWindow(key);

                if (pwndT != NULL) {
                    /*
                     * VK_PACKET shouldn't be a hot key.
                     */
                    UserAssert((key & 0xff) != VK_PACKET);

                    _PostMessage(ptiCurrent->pq->spwndActive, WM_SYSCOMMAND,
                                (WPARAM)SC_HOTKEY, (LPARAM)HWq(pwndT));

                    /*
                     * Remove this message from the input queue.
                     */
                    xxxSkipSysMsg(ptiCurrent, &qmsg);
                    PATHTAKEN2(0x1000000);
                    goto RestartScan;
                }

                PATHTAKEN2(0x2000000);
            }

#if DBG
            else if (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) {
                RIPMSG0(RIP_VERBOSE, "xxxScanSysQueue: gfInNumpadHexInput is true, so we skipped hotkey.");
            }
#endif

            if (wParam == VK_PACKET) {
                /*
                 * Save the character in thread's cache for TranslateMessage
                 */
                ptiCurrent->wchInjected = HIWORD(qmsg.msg.wParam);
                qmsg.msg.wParam = wParam;
                UserAssert(qmsg.msg.wParam == VK_PACKET);
            }

            /*
             * Fall through.
             */

        case WM_SYSKEYUP:
        case WM_KEYUP:
            wParam = qmsg.msg.wParam & 0xFF;
            if (wParam == VK_PACKET) {
                qmsg.msg.wParam = wParam;
            }

            /*
             * Special processing for thai locale toggle using grave accent key
             * Remove key message irrespective of fDown otherwise it will
             * generate WM_CHAR message
             */
            if (gbGraveKeyToggle &&
                //
                // In case of mstsc.exe, should not eat Grave Accent key message.
                // TS client must send Grave Accent key message to server side.
                //
                !(GetAppImeCompatFlags(NULL) & IMECOMPAT_HYDRACLIENT) &&
                LOBYTE(HIWORD(qmsg.msg.lParam)) == SCANCODE_THAI_LAYOUT_TOGGLE &&
                fRemove &&
                !TestKeyStateDown(ptiCurrent->pq, VK_SHIFT)   &&
                !TestKeyStateDown(ptiCurrent->pq, VK_MENU)    &&
                !TestKeyStateDown(ptiCurrent->pq, VK_CONTROL) &&
                !TestKeyStateDown(ptiCurrent->pq, VK_LWIN)    &&
                !TestKeyStateDown(ptiCurrent->pq, VK_RWIN)){

                if ((pwnd = ptiCurrent->pq->spwndFocus) == NULL){
                    pwnd = ptiCurrent->pq->spwndActive;
                }

                /*
                 * Post message only on WM_KEYUP
                 */
                if (!fDown && pwnd){
                    PTHREADINFO     ptiToggle = GETPTI(pwnd);
                    PKL             pkl = ptiToggle->spklActive;

                    if (pkl && (pkl = HKLtoPKL(ptiToggle, (HKL)HKL_NEXT))) {
                        _PostMessage(
                            pwnd,
                            WM_INPUTLANGCHANGEREQUEST,
                            (WPARAM)(((pkl->dwFontSigs & gSystemFS) ? INPUTLANGCHANGE_SYSCHARSET : 0) | INPUTLANGCHANGE_FORWARD),
                            (LPARAM)pkl->hkl
                            );
                    }
                }
                /*
                 * eat Accent Grave's key msgs
                 */
                xxxSkipSysMsg(ptiCurrent, &qmsg);
                goto RestartScan;
            }

            {
                /*
                 * Process keyboard toggle keys only if this is
                 * a break event and fRemove == TRUE.  Some apps,
                 * for instance Word 95, call PeekMessage with
                 * PM_NOREMOVE followed by a call with PM_REMOVE.
                 * We only want to process this once.  Skip all
                 * of this is layout switching via the keyboard
                 * is disabled.
                 */
#ifdef CUAS_ENABLE
                BOOL bMSCTF;
                try {
                    bMSCTF = ((ptiCurrent->pClientInfo->CI_flags & CI_CUAS_MSCTF_RUNNING) != 0);
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto NoMessages;
                }
#endif // CUAS_ENABLE
                if (
#ifdef CUAS_ENABLE
                    !(bMSCTF) &&
#endif // CUAS_ENABLE
                    !fDown && fRemove && gLangToggle[0].bVkey) {
                    BOOL bDropToggle = FALSE;
                    DWORD dwDirection = 0;
                    PKL pkl;
                    PTHREADINFO ptiToggle;
                    BOOL bArabicSwitchPresent = FALSE;
                    LCID lcid;

                    ZwQueryDefaultLocale(FALSE, &lcid);

                    pwnd = ptiCurrent->pq->spwndFocus;
                    if (pwnd == NULL) {
                        pwnd = ptiCurrent->pq->spwndActive;
                        if (!pwnd) {
                            goto NoLayoutSwitch;
                        }
                    }

                    ptiToggle = GETPTI(pwnd);
                    pkl = ptiToggle->spklActive;
                    UserAssert(ptiToggle->spklActive != NULL);

                    /*
                     * Check for Arabic toggle context
                     */
                    if (gLangToggleKeyState < KLT_NONE && PRIMARYLANGID(lcid) == LANG_ARABIC){
                        PKL pkl_next = HKLtoPKL (ptiToggle, (HKL)HKL_NEXT);

                        /*
                         * test if there are exactly two pkl's and at least one
                         * of them is arabic
                         */
                         if (pkl && pkl_next &&
                            pkl->hkl != pkl_next->hkl && pkl_next == HKLtoPKL(ptiToggle, (HKL)HKL_PREV) &&
                            (PRIMARYLANGID(HandleToUlong(pkl->hkl)) == LANG_ARABIC || PRIMARYLANGID(HandleToUlong(pkl_next->hkl)) == LANG_ARABIC)){
                            bArabicSwitchPresent = TRUE;
                         }
                    }

                    /*
                     * NT has always had Alt LShift going forward (down) the list,
                     * and Alt RShift going backwards. Windows '95 is different.
                     */
                    switch (gLangToggleKeyState) {
                    case KLT_ALTLEFTSHIFT:
                       bDropToggle = TRUE;
                       dwDirection = INPUTLANGCHANGE_FORWARD;
                       if (!bArabicSwitchPresent || PRIMARYLANGID(HandleToUlong(pkl->hkl)) == LANG_ARABIC){
                           pkl = HKLtoPKL(ptiToggle, (HKL)HKL_NEXT);
                       }
                       break;

                    case KLT_ALTRIGHTSHIFT:
                       bDropToggle = TRUE;
                       dwDirection = INPUTLANGCHANGE_BACKWARD;
                       if (!bArabicSwitchPresent || PRIMARYLANGID(HandleToUlong(pkl->hkl)) != LANG_ARABIC){
                           pkl = HKLtoPKL(ptiToggle, (HKL)HKL_PREV);
                       }
                       break;

                    case KLT_ALTBOTHSHIFTS:
                       pkl = gspklBaseLayout;
                       break;

                    default:
                       goto NoLayoutSwitch;
                       break;
                    }

                    if (pkl == NULL) {
                        pkl = GETPTI(pwnd)->spklActive;
                    }

                    /*
                     * If these two are not NULL, then winlogon hasn't loaded
                     * any keyboard layouts yet: but nobody should be getting
                     * input yet, so Assert but check pkl anyway. #99321
                     */
                    UserAssert(gspklBaseLayout != NULL);
                    UserAssert(pkl);
                    if (pkl) {
                        /*
                         * Not a very satisfactory window to post to, but it's hard
                         * to figure out a better window. Just do as Memphis does.
                         * Note: The following went up too high, bypassing Word
                         * when using wordmail - IanJa bug #64744.
                         *    if ((pwndTop = GetTopLevelWindow(pwnd)) != NULL) {
                         *       pwnd = pwndTop;
                         *    }
                         */
                        _PostMessage(pwnd, WM_INPUTLANGCHANGEREQUEST,
                                (DWORD)(((pkl->dwFontSigs & gSystemFS) ? INPUTLANGCHANGE_SYSCHARSET : 0) | dwDirection),
                                (LPARAM)pkl->hkl);
                    }

NoLayoutSwitch:

                    if (bDropToggle) {
                        /*
                         * Clear this key from the key state so that multiple key
                         * presses will work (i.e., Alt+Shft+Shft).  We don't do
                         * this when both shift keys are pressed simultaneously to
                         * avoid two activates.
                         */
                        DWORD i;
                        BYTE scancode = LOBYTE(HIWORD(qmsg.msg.lParam));
                        BYTE vkey = LOBYTE(qmsg.msg.wParam);

                        for (i = 0; i < LANGTOGGLEKEYS_SIZE; i++) {
                            if (gLangToggle[i].bScan) {
                                if (gLangToggle[i].bScan == scancode) {
                                    gLangToggleKeyState &= ~(gLangToggle[i].iBitPosition);
                                }
                            } else {
                                if (gLangToggle[i].bVkey == vkey) {
                                    gLangToggleKeyState &= ~(gLangToggle[i].iBitPosition);
                                }
                            }
                        }
                    } else {
                        gLangToggleKeyState = 0;
                    }
                }
            }

            /*
             * Convert F10 to syskey for new apps.
             */
            if (wParam == VK_F10)
                message |= (WM_SYSKEYDOWN - WM_KEYDOWN);

            if (TestKeyStateDown(ptiCurrent->pq, VK_CONTROL) &&
                    wParam == VK_ESCAPE) {
                message |= (WM_SYSKEYDOWN - WM_KEYDOWN);
            }

            /*
             * Clear the 'simulated keystroke' bit for all applications except
             * console so it can pass it to 16-bit vdms. VDM keyboards need to
             * distinguish between AltGr (where Ctrl keystroke is simulated)
             * and a real Ctrl+Alt. Check TIF_CSRSSTHREAD for the console
             * input thread because it lives in the server. This is a cheap
             * way to check for it.
             */
            if (!(ptiCurrent->TIF_flags & TIF_CSRSSTHREAD))
                qmsg.msg.lParam &= ~FAKE_KEYSTROKE;
            PATHTAKEN2(0x4000000);

            /*
             * Fall through.
             */

            /*
             * Some apps want to be able to feed WM_CHAR messages through
             * the playback hook. Why? Because they want to be able to
             * convert a string of characters info key messages
             * and feed them to themselves or other apps. Unfortunately,
             * there are no machine independent virtual key codes for
             * some characters (for example '$'), so they need to send
             * those through as WM_CHARs. (6/10/87).
             */

        case WM_CHAR:
            wParam = qmsg.msg.wParam & 0xFF;

            /*
             * Assign the input to the focus window. If there is no focus
             * window, assign it to the active window as a SYS message.
             */
            pwnd = ptiCurrent->pq->spwndFocus;
            if (ptiCurrent->pq->spwndFocus == NULL) {
                if ((pwnd = ptiCurrent->pq->spwndActive) != NULL) {
                    if (CheckMsgFilter(message, WM_KEYDOWN, WM_DEADCHAR)) {
                        message += (WM_SYSKEYDOWN - WM_KEYDOWN);
                        PATHTAKEN2(0x8000000);
                    }
                } else {
                    PATHTAKEN2(0x10000000);
                    goto SkipMessage;
                }
            }

            /*
             * If there is no active window or focus window, eat this
             * message.
             */
            if (pwnd == NULL) {
                PATHTAKEN2(0x20000000);
                goto SkipMessage;
            }

            ThreadLockExchangeAlways(pwnd, &tlpwnd);

            /*
             * Check if this is intended for the current app.
             */
            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {
                PWND pwndModalLoop;

                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN2(0x40000000);
                    goto SkipMessage;
                }

                /*
                 * If the current thread is in the menu or movesize loop
                 *  then we need to give it the input
                 */
                if (IsInsideMenuLoop(ptiCurrent)) {
                    pwndModalLoop = ptiCurrent->pMenuState->pGlobalPopupMenu->spwndNotify;
                } else if (ptiCurrent->pmsd != NULL) {
                    pwndModalLoop = ptiCurrent->pmsd->spwnd;
                    RIPMSG0(RIP_WARNING, "xxxScanSysQueue: returning key to movesize loop");
                } else {
                    pwndModalLoop = NULL;
                }

                /*
                 * If we're switching windows, lock the new one
                 */
                if (pwndModalLoop != NULL) {
                    pwnd = pwndModalLoop;
                    fOtherApp = (GETPTI(pwnd) != ptiCurrent);
                    ThreadLockExchangeAlways(pwnd, &tlpwnd);
                    PATHTAKEN2(0x80000000);
                }

                /*
                 * If not for us, then remember who it is for.
                 */
                if (ptiKeyWake == NULL) {
                    PATHTAKEN3(1);
                    ptiKeyWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiKeyWake, &tlptiKeyWake);
                }
            }

            /*
             * See if this thing matches our filter.
             */
            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter) ||
                    !CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN3(2);
                continue;
            }

            /*
             * This message matches our filter. If it is not for us then
             * stop searching to make sure the real owner processes this
             * message first.
             */
            if (fOtherApp) {
                PATHTAKEN3(4);
                goto NoMessages;
            }

            /*
             * Generate some special messages if we are removing and we are
             * not inside the menu loop.
             */
            if (fRemove && !IsInsideMenuLoop(ptiCurrent)) {
                /*
                 * Generate a WM_CONTEXTMENU for the VK_APPS key
                 */
                if ((wParam == VK_APPS) && (message == WM_KEYUP)) {
                    _PostMessage(pwnd, WM_CONTEXTMENU, (WPARAM)PtoH(pwnd), KEYBOARD_MENU);
                }

                /*
                 * If this is a WM_KEYDOWN message for F1 key then we must generate
                 * the WM_KEYF1 message.
                 */
                if ((wParam == VK_F1) && (message == WM_KEYDOWN)) {
                    _PostMessage(pwnd, WM_KEYF1, 0, 0);
                }
            }

            /*
             * If one Shift key is released while the other Shift key is held
             * down, this keystroke is normally skipped, presumably to prevent
             * applications from thinking that the shift condition no longer
             * applies.
             */
            if (wParam == VK_SHIFT) {
                BYTE vkHanded, vkOtherHand;

                if (qmsg.msg.lParam & EXTENDED_BIT) {
                    vkHanded = VK_RSHIFT;
                } else {
                    vkHanded = VK_LSHIFT;
                }
                vkOtherHand = vkHanded ^ 1;

                if (!fDown && TestKeyStateDown(ptiCurrent->pq, vkOtherHand)) {
                    /*
                     * Unlike normal apps, Console MUST be sent a Shift break
                     * even when the other Shift key is still down, since it
                     * has to be passed on to VDM, which maintains it's own
                     * state. Check TIF_CSRSSTHREAD for the console input
                     * thread because it lives in the server. This is a cheap
                     * way to check for it.
                     */
                    if ((ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) == 0) {
                        /*
                         * We ignore this key event, so we must update
                         * it's key state whether fRemove is TRUE or not.
                         * (ignoring an key event is same as removing it)
                         */
                        qmsg.msg.wParam = vkHanded;
                        xxxSkipSysMsg(ptiCurrent, &qmsg);
                        PATHTAKEN3(8);
                        goto RestartScan;
                    }
                    PATHTAKEN3(0x10);
                }
            }

            /*
             * Get the previous up/down state of the key here since
             * SkipSysMsg() sets the key state table and destroys
             * the previous state info.
             */
            fPrevDown = FALSE;
            if (TestKeyStateDown(ptiCurrent->pq, wParam))
                fPrevDown = TRUE;

            /*
             * Eat the message from the input queue and set the keystate
             * table.
             */
            PATHTAKEN3(0x20);
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            /*
             * This gets us the LOWORD of lParam, the repeat count,
             * the bit in the hi byte indicating whether this is an extended
             * key, and the scan code.  We also need to re-get the wParam in
             * case xxxSkipSysMsg called a hook which modified the message.
             * AfterDark's password protection does this.
             */
            lParam = qmsg.msg.lParam;
            wParam = qmsg.msg.wParam;

            /*
             * Indicate if it was previously down.
             */
            if (fPrevDown)
                lParam |= 0x40000000;           // KF_REPEAT

            /*
             * Set the transition bit.
             */
            switch (message) {
            case WM_KEYUP:
            case WM_SYSKEYUP:
                lParam |= 0x80000000;           // KF_UP
                break;
            }

            /*
             * Set the alt key down bit.
             */
            if (TestKeyStateDown(ptiCurrent->pq, VK_MENU)) {
                lParam |= 0x20000000;           // KF_ALTDOWN
            }

            /*
             * Set the menu state flag.
             */
            if (IsMenuStarted(ptiCurrent)) {
                lParam |= 0x10000000;           // KF_MENUMODE
            }

            /*
             * Set the dialog state flag.
             */
            if (ptiCurrent->pq->QF_flags & QF_DIALOGACTIVE) {
                lParam |= 0x08000000;           // KF_DLGMODE
            }

            /*
             * 0x80000000 is set if up, clear if down
             * 0x40000000 is previous up/down state of key
             * 0x20000000 is whether the alt key is down
             * 0x10000000 is whether currently in menumode.
             * 0x08000000 is whether in dialog mode
             * 0x04000000 is not used
             * 0x02000000 is not used
             * 0x01000000 is whether this is an extended keyboard key
             *
             * Low word is repeat count, low byte hiword is scan code,
             * hi byte hiword is all these bits.
             */

            /*
             * Callback the client IME before calling the keyboard hook.
             * If the vkey is one of the IME hotkeys, the vkey will not
             * be passed to the keyboard hook.
             * If IME needs this vkey, VK_PROCESSKEY will be put into the
             * application queue instead of real vkey.
             */
            UserAssert(ptiCurrent != NULL);
            if (gpImeHotKeyListHeader != NULL &&
                    fRemove &&
                    !IsMenuStarted(ptiCurrent) &&
                    !(ptiCurrent->TIF_flags & TIF_DISABLEIME) &&
                    pwnd != NULL) {

                WPARAM wParamTemp = wParam;

                if (wParam == VK_PACKET) {
                    wParamTemp = MAKEWPARAM(wParam, ptiCurrent->wchInjected);
                }

                /*
                 * xxxImmProcessKey also checks the registered IME hotkeys.
                 */
                dwImmRet = xxxImmProcessKey( ptiCurrent->pq,
                                             pwnd,
                                             message,
                                             wParamTemp,
                                             lParam);
                if ( dwImmRet & (IPHK_HOTKEY | IPHK_SKIPTHISKEY) ) {
                    dwImmRet = 0;
                    goto SkipMessage;
                }
            }

            /*
             * If we are removing the message, call the keyboard hook
             * with HC_ACTION, otherwise call the hook with HC_NOREMOVE
             * to let it know that the message is not being removed.
             */
            if (IsHooked(ptiCurrent, WHF_KEYBOARD)) {
                fKbdHookCalled = TRUE;
                if (xxxCallHook(fRemove ? HC_ACTION : HC_NOREMOVE,
                        wParam, lParam, WH_KEYBOARD)) {
                    PATHTAKEN3(0x40);
                    goto SkipMessage;
                }
            }

            if (fKbdHookCalled && fRemove && IsHooked(ptiCurrent, WHF_CBT)) {
                xxxCallHook(HCBT_KEYSKIPPED, wParam, lParam, WH_CBT);
                PATHTAKEN3(0x80);
            }

            fKbdHookCalled = FALSE;
            PATHTAKEN3(0x100);
            goto ReturnMessage;

        case WM_MOUSEWHEEL:
            /*
             * If we are sending keyboard input to an app that has been
             * spinning then boost it back up.  If we don't you use spinning
             * apps like Write or Project and do two builds in the
             * background.  Note the app will also be unboosted again shortly
             * after you stop typing by the old logic. #11188
             */
            if (ptiCurrent->TIF_flags & TIF_SPINNING) {
                if (!NT_SUCCESS(CheckProcessForeground(ptiCurrent))) {
                    goto NoMessages;
                }
            }

            /*
             * Assign the input to the focus window. If there is no focus
             * window, or we are in a menu loop, eat this message.
             */
            pwnd = ptiCurrent->pq->spwndFocus;
            if (pwnd == NULL || IsInsideMenuLoop(ptiCurrent)) {
                PATHTAKEN2(0x20000000);
                goto SkipMessage;
            }

            ThreadLockExchangeAlways(pwnd, &tlpwnd);

            /*
             * Check if this is intended for the current app.
             */
            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {

                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN2(0x40000000);
                    goto SkipMessage;
                }

                /*
                 * If not for us, then remember who it is for.
                 */
                if (ptiKeyWake == NULL) {
                    PATHTAKEN3(1);
                    ptiKeyWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiKeyWake, &tlptiKeyWake);
                }
            }

            /*
             * See if this thing matches our filter.
             * NOTE: We need to check whether the caller is filtering
             * for all mouse messages - if so, we assume the caller
             * wants mouse wheel messages too.
             */
            if (    !CheckMsgFilter(WM_MOUSEWHEEL, msgMinFilter, msgMaxFilter) ||
                    !CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN3(2);
                continue;
            }

            /*
             * This message matches our filter. If it is not for us then
             * stop searching to make sure the real owner processes this
             * message first.
             */
            if (fOtherApp) {
                PATHTAKEN3(4);
                goto NoMessages;
            }

            /*
             * Eat the message from the input queue and set the keystate
             * table.
             */
            PATHTAKEN3(0x20);
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            wParam = GetMouseKeyFlags(ptiCurrent->pq);
            UserAssert(LOWORD(qmsg.msg.wParam) == 0);
            UserAssert(HIWORD(wParam) == 0);
            wParam |= qmsg.msg.wParam;
            lParam = qmsg.msg.lParam;

            /*
             * If we are removing the message, call the mouse hook
             * with HC_ACTION, otherwise call the hook with HC_NOREM
             * to let it know that the message is not being removed.
             */
            if (IsHooked(ptiCurrent, WHF_MOUSE)) {
                fMouseHookCalled = TRUE;
                mhs.pt = qmsg.msg.pt;
                mhs.hwnd = HW(pwnd);
                mhs.wHitTestCode = HTNOWHERE;
                mhs.dwExtraInfo = qmsg.ExtraInfo;
                mhs.mouseData = (DWORD)qmsg.msg.wParam;
                if (xxxCallMouseHook(message, &mhs, fRemove)) {
                    /*
                     * Not allowed by mouse hook; so skip it.
                     */
                    PATHTAKEN3(0x40);
                    goto SkipMessage;
                }
            }

            if (fMouseHookCalled && fRemove && IsHooked(ptiCurrent, WHF_CBT)) {
                /*
                 * CONSIDER: Add new HCBT_ constant for the mouse wheel?
                 */
                xxxCallHook(HCBT_CLICKSKIPPED, message, (LPARAM)&mhs, WH_CBT);
                PATHTAKEN3(0x80);
            }

            fMouseHookCalled = FALSE;
            PATHTAKEN3(0x100);
            goto ReturnMessage;

#ifdef GENERIC_INPUT
        case WM_INPUT:
            /*
             * Generic Input messages.
             * There is not much we should look at here. The best practice is just
             * omit most of the processing and just return the current message.
             */
            wParam = qmsg.msg.wParam;
            lParam = qmsg.msg.lParam;

            /*
             * Assign the input to the focus window. If there is no focus
             * window, assign it to the active window as a SYS message.
             */
            pwnd = NULL;
            if (lParam) {
                PHIDDATA pHidData = HMValidateHandle((LPVOID)lParam, TYPE_HIDDATA);

                if (pHidData) {
                    pwnd = pHidData->spwndTarget;
                }
            }
            if (pwnd == NULL) {
                pwnd = ptiCurrent->pq->spwndFocus;
                if (pwnd == NULL) {
                    pwnd = ptiCurrent->pq->spwndActive;
                    if (pwnd == NULL) {
                        PATHTAKEN2(0x10000000);
                        goto SkipMessage;
                    }
                }
            }
            TAGMSG1(DBGTAG_PNP, "xxxScanSysQueue: pwnd=%p", pwnd);
            UserAssert(pwnd != NULL);

            ThreadLockExchangeAlways(pwnd, &tlpwnd);

            /*
             * Check if this is intended for the current app.
             */
            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {
                PWND pwndModalLoop;

                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN2(0x40000000);
                    goto SkipMessage;
                }

                /*
                 * If the current thread is in the menu or movesize loop
                 *  then we need to give it the input
                 */
                if (IsInsideMenuLoop(ptiCurrent)) {
                    pwndModalLoop = ptiCurrent->pMenuState->pGlobalPopupMenu->spwndNotify;
                } else if (ptiCurrent->pmsd != NULL) {
                    pwndModalLoop = ptiCurrent->pmsd->spwnd;
                    RIPMSG0(RIP_WARNING, "xxxScanSysQueue: returning key to movesize loop");
                } else {
                    pwndModalLoop = NULL;
                }

                /*
                 * If we're switching windows, lock the new one
                 */
                if (pwndModalLoop != NULL) {
                    pwnd = pwndModalLoop;
                    fOtherApp = (GETPTI(pwnd) != ptiCurrent);
                    ThreadLockExchangeAlways(pwnd, &tlpwnd);
                    PATHTAKEN2(0x80000000);
                }

                /*
                 * If not for us, then remember who it is for.
                 */
                if (ptiRawInputWake == NULL) {
                    PATHTAKEN3(1);
                    ptiRawInputWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiRawInputWake, &tlptiRawInputWake);
                }
            }

            /*
             * See if this thing matches our filter.
             */
            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter) ||
                    !CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN3(2);
                continue;
            }

            /*
             * This message matches our filter. If it is not for us then
             * stop searching to make sure the real owner processes this
             * message first.
             */
            if (fOtherApp) {
                PATHTAKEN3(4);
                goto NoMessages;
            }

            /*
             * Remove the message from the input queue.
             */
            if (fRemove) {
#if LOCK_HIDDATA
                PHIDDATA pHidData = HMValidateHandle((LPVOID)lParam, TYPE_HIDDATA);

                if (pHidData) {
                    /*
                     * Lock the object so that hRawInput is not destroyed
                     * while the message is removed from the input queue.
                     */
                    HMLockObject(pHidData);
                }
                else {
                    RIPMSG1(RIP_WARNING, "xxxScanSysQueue: invalid WM_INPUT's lParam %p", lParam);
                }
#endif

                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            /*
             * N.b.
             * WM_INPUT is not handed to input hooks.
             */

            PATHTAKEN3(0x00010000);
            goto ReturnMessage;
#endif

        } /* End of switch (message = qmsg.msg.message) */
    } /* End of the GetNextSysMsg() loop */

ReturnMessage:
    if (!RtlEqualMemory(&ptiCurrent->ptLast, &qmsg.msg.pt, sizeof(POINT))) {
        ptiCurrent->TIF_flags |= TIF_MSGPOSCHANGED;
    }
    ptiCurrent->ptLast = qmsg.msg.pt;
    ptiCurrent->timeLast = qmsg.msg.time;
    ptiCurrent->pq->ExtraInfo = qmsg.ExtraInfo;

    /*
     * idSysLock value of 1 indicates that the message came from the input
     * queue.
     */
    ptiCurrent->idLast = ptiCurrent->pq->idSysLock = 1;

    /*
     * Now see if our input bit is set for this input. If it isn't, set ours
     * and clear the guy who had it previously.
     */
    TransferWakeBit(ptiCurrent, message);

    /*
     * Clear the input bits if no messages in the input queue.
     */
    ClearWakeBit(ptiCurrent, QS_MOUSE | QS_KEY | QS_EVENT |
#ifdef GENERIC_INPUT
                 QS_RAWINPUT |
#endif
                 QS_TRANSFER, TRUE);

    /*
     * Get the message and split.
     */
    lpMsg->hwnd = HW(pwnd);
    lpMsg->message = message;

    /*
     * If the IME claims that it needs this vkey, replace it
     * with VK_PROCESSKEY. The real vkey has been saved in
     * the input context in the client side.
     */
    lpMsg->wParam = (dwImmRet & IPHK_PROCESSBYIME) ? VK_PROCESSKEY : wParam;

    lpMsg->lParam = lParam;
    lpMsg->time = qmsg.msg.time;
    lpMsg->pt = qmsg.msg.pt;

#if DBG
    if (gfLogPlayback && ptiCurrent->pq->idSysPeek == (LONG_PTR)PQMSG_PLAYBACK)
        LogPlayback(pwnd, lpMsg);
#endif  // DBG

#ifdef GENERIC_INPUT
    ThreadUnlockPti(ptiCurrent, &tlptiRawInputWake);
#endif
    ThreadUnlockPti(ptiCurrent, &tlptiEventWake);
    ThreadUnlockPti(ptiCurrent, &tlptiMouseWake);
    ThreadUnlockPti(ptiCurrent, &tlptiKeyWake);

    ThreadUnlock(&tlpwnd);

    PATHTAKEN3(0x200);
    DUMPPATHTAKEN();
    return TRUE;

NoMessages:
    /*
     * The message was for another app, or none were found that fit the
     * filter.
     */

    /*
     * Unlock the system queue.
     */
    ptiCurrent->pq->idSysLock  = 0;
    CheckSysLock(4, ptiCurrent->pq, NULL);
    ptiCurrent->pq->ptiSysLock = NULL;
    ptiCurrent->pcti->CTIF_flags &= ~CTIF_SYSQUEUELOCKED;

    /*
     * Wake up someone else if we found a message for him.  QS_TRANSFER
     * signifies that the thread was woken due to input transfer
     * from another thread, rather than from a real input event.
     */
    if (ptiKeyWake != NULL || ptiMouseWake != NULL || ptiEventWake != NULL
#ifdef GENERIC_INPUT
        || ptiRawInputWake != NULL
#endif
        ) {
        PATHTAKEN3(0x400);
        if (ptiKeyWake != NULL) {
            SetWakeBit(ptiKeyWake, QS_KEY | QS_TRANSFER);
            ClearWakeBit(ptiCurrent, QS_KEY | QS_TRANSFER, FALSE);
            PATHTAKEN3(0x800);
        }

        if (ptiMouseWake != NULL) {
            SetWakeBit(ptiMouseWake, QS_MOUSE | QS_TRANSFER);
            ClearWakeBit(ptiCurrent, QS_MOUSE | QS_TRANSFER, FALSE);
            PATHTAKEN3(0x1000);
        }

#ifdef GENERIC_INPUT
        if (ptiRawInputWake != NULL) {
            SetWakeBit(ptiRawInputWake, QS_RAWINPUT | QS_TRANSFER);
            ClearWakeBit(ptiCurrent, QS_RAWINPUT | QS_TRANSFER, FALSE);
        }
#endif

        if (ptiEventWake != NULL) {
            SetWakeBit(ptiEventWake, QS_EVENTSET);
            ClearWakeBit(ptiCurrent, QS_EVENT, FALSE);
            PATHTAKEN3(0x2000);
        } else if (FJOURNALPLAYBACK()) {

            /*
             * If journal playback is occuring, clear the input bits.  This will
             * help prevent a race condition between two threads that call
             * WaitMessage/PeekMessage.  This can occur when embedding an OLE
             * object.  An example is inserting a Word object into an Excel
             * spreadsheet.
             * Also clear change bits else this thread might not xxxSleepThread.
             */
            ptiCurrent->pcti->fsWakeBitsJournal |= (ptiCurrent->pcti->fsWakeBits &
                    (QS_MOUSE | QS_KEY |
#ifdef GENERIC_INPUT
                     QS_RAWINPUT |
#endif
                     QS_TRANSFER));
            ClearWakeBit(ptiCurrent, QS_MOUSE | QS_KEY |
#ifdef GENERIC_INPUT
                         QS_RAWINPUT |
#endif
                         QS_TRANSFER, FALSE);
            ptiCurrent->pcti->fsChangeBits &= ~(QS_MOUSE | QS_KEY |
#ifdef GENERIC_INPUT
                                                QS_RAWINPUT |
#endif
                                                QS_TRANSFER);
        }
    } else {
        /*
         * Clear the input bits if no messages in the input queue.
         */
        ptiCurrent->pcti->fsWakeBitsJournal = 0;
        ClearWakeBit(ptiCurrent, QS_MOUSE | QS_KEY | QS_EVENT |
#ifdef GENERIC_INPUT
                     QS_RAWINPUT |
#endif
                QS_TRANSFER, TRUE);
        PATHTAKEN3(0x4000);
    }

#ifdef GENERIC_INPUT
    ThreadUnlockPti(ptiCurrent, &tlptiRawInputWake);
#endif
    ThreadUnlockPti(ptiCurrent, &tlptiEventWake);
    ThreadUnlockPti(ptiCurrent, &tlptiMouseWake);
    ThreadUnlockPti(ptiCurrent, &tlptiKeyWake);

    ThreadUnlock(&tlpwnd);

    PATHTAKEN3(0x8000);
    DUMPPATHTAKEN();
    return FALSE;
}
#undef PATHTAKEN
#undef PATHTAKEN2
#undef PATHTAKEN3
#undef DUMPPATHTAKEN
#undef DUMPSUBPATHTAKEN


/***************************************************************************\
* IdleTimerProc
*
* This will start the screen saver app
*
* History:
* 09-06-91  mikeke      Created.
* 03-26-92  DavidPe     Changed to be run from hungapp timer on RIT.
\***************************************************************************/

VOID IdleTimerProc(VOID)
{

    CheckCritIn();

    if (    (TestAsyncKeyStateDown(VK_LBUTTON)) ||
            (TestAsyncKeyStateDown(VK_RBUTTON)) ||
            (TestAsyncKeyStateDown(VK_MBUTTON)) ||
            (TestAsyncKeyStateDown(VK_XBUTTON1)) ||
            (TestAsyncKeyStateDown(VK_XBUTTON2))) {

        return;
    }


    if (giScreenSaveTimeOutMs > 0) {

        if (IsTimeFromLastInput((DWORD)(giScreenSaveTimeOutMs))) {

            if (gppiScreenSaver != NULL) {

                if (!(gppiScreenSaver->W32PF_Flags & W32PF_IDLESCREENSAVER)) {
                    /*
                     * Bump the priority of the screen saver down to idle.
                     */
                    gppiScreenSaver->W32PF_Flags |= W32PF_IDLESCREENSAVER;
                    SetForegroundPriorityProcess(gppiScreenSaver, gppiScreenSaver->ptiMainThread, TRUE);
                }
            } else {
                /*
                 * Tell the system that it needs to bring up a screen saver.
                 *
                 * Carefull with the case when the active window is hung. If this
                 * is the case the screen saver won't be started by winlogon because
                 * DefWindowProc won't call StartScreenSaver(FALSE).
                 */
                if ((gpqForeground != NULL) &&
                    (gpqForeground->spwndActive != NULL) &&
                    !FHungApp(GETPTI(gpqForeground->spwndActive), CMSHUNGAPPTIMEOUT)) {

                    /*
                     * Tell winlogon to start the screen saver if we have a secure
                     * screen saver. In case we do have a secure one, the next PostMessage
                     * will be ignored in winlogon.
                     */
                    StartScreenSaver(TRUE);
                    _PostMessage(gpqForeground->spwndActive, WM_SYSCOMMAND, SC_SCREENSAVE, 0L);
                } else {
                    StartScreenSaver(FALSE);
                }
            }
        }
    }

    if ((giLowPowerTimeOutMs > 0) && ((glinp.dwFlags & LINP_LOWPOWER) == 0)) {
        if (IsTimeFromLastInput((DWORD)(giLowPowerTimeOutMs))) {
            if ((gpqForeground != NULL) && (gpqForeground->spwndActive != NULL)) {
                _PostMessage(gpqForeground->spwndActive, WM_SYSCOMMAND, SC_MONITORPOWER, LOWPOWER_PHASE);
            }
        }
    }

    if ((giPowerOffTimeOutMs > 0) && ((glinp.dwFlags & LINP_POWEROFF) == 0)) {
        if (IsTimeFromLastInput((DWORD)(giPowerOffTimeOutMs))) {
            if ((gpqForeground != NULL) && (gpqForeground->spwndActive != NULL)) {
                _PostMessage(gpqForeground->spwndActive, WM_SYSCOMMAND, SC_MONITORPOWER, POWEROFF_PHASE);
            }
        }
    }

}

/***************************************************************************\
* zzzWakeInputIdle
*
* The calling thread is going "idle". Wake up any thread waiting for this.
*
* 09-24-91 ScottLu      Created.
\***************************************************************************/

void zzzWakeInputIdle(
    PTHREADINFO pti)
{
    PW32PROCESS W32Process = W32GetCurrentProcess();

    /*
     * clear out the TIF_FIRSTIDLE since here we are
     */
    pti->TIF_flags &= ~TIF_FIRSTIDLE;


    /*
     * Shared Wow Apps use the per thread idle event for synchronization.
     * Separate Wow VDMs use the regular mechanism.
     */
    if (pti->TIF_flags & TIF_SHAREDWOW) {
        UserAssert(pti->TIF_flags & TIF_16BIT);
        if (pti->ptdb->pwti) {
            SET_PSEUDO_EVENT(&pti->ptdb->pwti->pIdleEvent);
        }
    } else {
        /*
         * If the main thread is NULL, set it to this queue: it is calling
         * GetMessage().
         */
        if (pti->ppi->ptiMainThread == NULL)
            pti->ppi->ptiMainThread = pti;

        /*
         * Wake up anyone waiting on this event.
         */
        if (pti->ppi->ptiMainThread == pti) {
            SET_PSEUDO_EVENT(&W32Process->InputIdleEvent);
        }
    }

    /*
     * Check to see if the startglass is on, and if so turn it off and update.
     */
    if (W32Process->W32PF_Flags & W32PF_STARTGLASS) {
        /*
         * This app is no longer in "starting" mode. Recalc when to hide
         * the app starting cursor.
         */
        W32Process->W32PF_Flags &= ~W32PF_STARTGLASS;
        zzzCalcStartCursorHide(NULL, 0);
    }
}

void SleepInputIdle(
    PTHREADINFO pti)
{
    PW32PROCESS W32Process;

    /*
     * Shared Wow Apps use the per thread idle event for synchronization.
     * Separate Wow VDMs use the regular mechanism.
     */
    if (pti->TIF_flags & TIF_SHAREDWOW) {
        UserAssert(pti->TIF_flags & TIF_16BIT);
        if (pti->ptdb->pwti) {
            RESET_PSEUDO_EVENT(&pti->ptdb->pwti->pIdleEvent);
        }
    } else {
        /*
         * If the main thread is NULL, set it to this queue: it is calling
         * GetMessage().
         */
        if (pti->ppi->ptiMainThread == NULL)
            pti->ppi->ptiMainThread = pti;

        /*
         * Put to sleep up anyone waiting on this event.
         */
        if (pti->ppi->ptiMainThread == pti) {
            W32Process = W32GetCurrentProcess();
            RESET_PSEUDO_EVENT(&W32Process->InputIdleEvent);
        }
    }
}

/***************************************************************************\
* zzzRecalcThreadAttachment
* zzzRecalc2
* zzzAddAttachment
* CheckAttachment
*
* Runs through all the attachinfo fields for all threads and calculates
* which threads share which queues. Puts calculated result in pqAttach
* field in each threadinfo structure. This is a difficult problem
* whose only solution in iterative. The basic algorithm is:
*
* 0. Find next unattached thread and attach a queue to it. If none, stop.
* 1. Loop through all threads: If thread X assigned to this queue or any
*    of X's attach requests assigned to this queue, assign X and all X's
*    attachments to this queue. Remember if we ever attach a 16 bit thread.
* 2. If thread X is a 16 bit thread and we've already attached another
*    16 bit thread, assign X and all X's attachments to this queue.
* 3. If any change found in 1-2, goto 1
* 4. Goto 0
*
* 12-11-92 ScottLu      Created.
* 01-Oct-1993 mikeke    Fixed to work with MWOWs
\***************************************************************************/

void zzzAddAttachment(
    PTHREADINFO pti,
    PQ pqAttach,
    LPBOOL pfChanged)
{
    if (pti->pqAttach != pqAttach) {
        /*
         * LATER
         * !!! This is totally messed up,  The only reason that this thing
         * could be non null is because two threads are going through
         * zzzAttachThreadInput() at the same time.  No one can predict
         * what kind of problems are going to be caused by that.
         * We leave the critical section in one place where we send
         * WM_CANCELMODE below.  We should figure out how to remove
         * the sendmessage.
         *
         * If there already is a queue there, as there may be, destroy it.
         * Note that zzzDestroyQueue() will only get rid of the queue if the
         * thread reference count goes to 0.
         */
        PQ pqDestroy = pti->pqAttach;
        pti->pqAttach = pqAttach;
        if (pqDestroy != NULL)
            zzzDestroyQueue(pqDestroy, pti);
        pqAttach->cThreads++;
        *pfChanged = TRUE;
    }
}

void zzzRecalc2(
    PQ pqAttach)
{
    PATTACHINFO pai;
    PTHREADINFO pti;
    BOOL fChanged;
    PLIST_ENTRY pHead, pEntry;

    /*
     * Defer Win Event notifications so we can traverse PtiList with impunity
     * #bug number from shiflet
     */
    DeferWinEventNotify();
    BEGINATOMICCHECK();

    /*
     * Keep adding attachments until everything that should be attached to this
     * queue is attached
     */
    do {
        fChanged = FALSE;

        /*
         * If a thread is attached to this Q attach all of it's attachments
         * and MWOW buddies if they aren't already attached.
         */
        pHead = &PtiCurrent()->rpdesk->PtiList;
        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
            pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

            if (pti->pqAttach == pqAttach) {
                /*
                 * check each of the attachments to see if this thread is attached
                 * to any other threads
                 */
                for (pai = gpai; pai != NULL; pai = pai->paiNext) {
                    /*
                     * if they weren't attached already, attach them
                     */
                    if (pai->pti1 == pti || pai->pti2 == pti) {
                        zzzAddAttachment((pai->pti1 == pti) ? pai->pti2 : pai->pti1,
                                pqAttach, &fChanged);
                    }
                }

                /*
                 * If this is a 16bit thread attach to all other threads in
                 * it's MWOW
                 */
                if (pti->TIF_flags & TIF_16BIT) {
                    PTHREADINFO ptiAttach;
                    PLIST_ENTRY pHeadAttach, pEntryAttach;

                    pHeadAttach = &pti->rpdesk->PtiList;
                    for (pEntryAttach = pHeadAttach->Flink;
                            pEntryAttach != pHeadAttach;
                            pEntryAttach = pEntryAttach->Flink) {
                        ptiAttach = CONTAINING_RECORD(pEntryAttach, THREADINFO, PtiLink);

                        if (ptiAttach->TIF_flags & TIF_16BIT &&
                            ptiAttach->ppi == pti->ppi) {
                            zzzAddAttachment(ptiAttach, pqAttach, &fChanged);
                        }
                    }
                }
            }
        }
    } while (fChanged);
    ENDATOMICCHECK();
    zzzEndDeferWinEventNotify();
}


void zzzRecalcThreadAttachment()
{
    PTHREADINFO pti;
    PLIST_ENTRY pHead, pEntry;

    /*
     * Win Event notifications must be defered so we can traverse PtiList with impunity
     */
    UserAssert(IsWinEventNotifyDeferred());

    /*
     * For all threads, start an attach queue if a thread hasn't been
     * attached yet.
     */
    pHead = &PtiCurrent()->rpdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        /*
         * Assert: We should not leave the critsect from xxxCreateThreadInfo
         * with the new thread in the rpdesk->PtiList but not yet with a queue.
         */
        UserAssert(pti->pq != NULL);

        if (pti->pqAttach == NULL) {

            /*
             * Allocate a new queue for this thread if more than
             * one thread references it.
             */
            if (pti->pq->cThreads > 1) {
                pti->pqAttach = AllocQueue(NULL, NULL);

                if (pti->pqAttach == NULL) {
                    RIPMSG0(RIP_WARNING, "zzzRecalcThreadAttachment: AllocQueue failed");
                    break;
                }

                pti->pqAttach->cThreads++;
            } else {
                pti->pqAttach = pti->pq;
            }

            /*
             * Attach every thread that is directly or indirectly attached
             * to this thread.
             */
            zzzRecalc2(pti->pqAttach);
        }
    }
}


/***************************************************************************\
* RedistributeInput
*
* This routine takes a input stream from the queue being left, and
* redistributes it. This effectively filters out the messages destined
* to the thread that left the queue.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/

void RedistributeInput(
    PQMSG pqmsgS,
    PQ    pqRedist)
{
    PTHREADINFO ptiSave;
    PTHREADINFO ptiT;
    PQMSG *ppqmsgD;
    PQMSG pqmsgT;
    PMLIST pmlInput;

    /*
     * Since the thread attaching or unattaching may have left a queue
     * shared by other threads, the messages we are going to requeue
     * may have multiple destinations. On top of this, once we find
     * a home queue for a message, it needs to be inserted in the
     * list ordered by its time stamp (older messages go at the end).
     */

    /*
     * Loop through a given dest's messages to find where to insert
     * the source messages, based on message time stamp. Be sure
     * to deal with empty message lists (meaning, check for NULL).
     */

    ptiT = NULL;
    ppqmsgD = NULL;
    pmlInput = NULL;

    while (pqmsgS != NULL) {

        /*
         * Find out where this message should go.
         */
        ptiSave = ptiT;
        ptiT = pqmsgS->pti;

        /*
         * Get rid of some event messages.
         *
         * QEVENT_UPDATEKEYSTATE: key state already up to date
         */
        if (pqmsgS->dwQEvent == QEVENT_UPDATEKEYSTATE) {
            ptiT = NULL;
        }

        if (ptiT == NULL) {
            /*
             * Unlink it. pqmsgS should be the first in the list
             */

            UserAssert(!pqmsgS->pqmsgPrev);
            if (pqmsgS->pqmsgNext != NULL) {
                pqmsgS->pqmsgNext->pqmsgPrev = NULL;
            }

            pqmsgT = pqmsgS;
            pqmsgS = pqmsgS->pqmsgNext;

            /*
             * Clean it / free it.
             */
            CleanEventMessage(pqmsgT);
            FreeQEntry(pqmsgT);

            ptiT = ptiSave;
            continue;
        }

        /*
         * Point to the pointer that points to the first message
         * that this message should go to, so that pointer is easy to
         * update, no matter where it is.
         */
        if (ppqmsgD == NULL || ptiSave != ptiT) {

            /*
             * If the source is younger than the last message in the
             * destination, go to the end.  Otherwise, start at the
             * head of the desination list and find a place to insert
             * the message.
             */
            if (ptiT->pq->mlInput.pqmsgWriteLast != NULL &&
                    pqmsgS->msg.time >= ptiT->pq->mlInput.pqmsgWriteLast->msg.time) {
                ppqmsgD = &ptiT->pq->mlInput.pqmsgWriteLast->pqmsgNext;
            } else {
                ppqmsgD = &ptiT->pq->mlInput.pqmsgRead;
            }

            pmlInput = &ptiT->pq->mlInput;
        }

        /*
         * If we're not at the end of the destination AND the destination
         * message time is younger than the source time, go on to
         * the next message.
         */
        while (*ppqmsgD != NULL && ((*ppqmsgD)->msg.time <= pqmsgS->msg.time)) {
            ppqmsgD = &((*ppqmsgD)->pqmsgNext);
        }

        /*
         * Link in the source before the dest message. Update
         * it's next and prev pointers. Update the dest prev
         * pointer.
         */
        pqmsgT = pqmsgS;
        pqmsgS = pqmsgS->pqmsgNext;
        pqmsgT->pqmsgNext = *ppqmsgD;

        if (*ppqmsgD != NULL) {
            pqmsgT->pqmsgPrev = (*ppqmsgD)->pqmsgPrev;
            (*ppqmsgD)->pqmsgPrev = pqmsgT;
        } else {
            pqmsgT->pqmsgPrev = pmlInput->pqmsgWriteLast;
            pmlInput->pqmsgWriteLast = pqmsgT;
        }
        *ppqmsgD = pqmsgT;
        ppqmsgD = &pqmsgT->pqmsgNext;
        pmlInput->cMsgs++;

        /*
         * If the thread has an event message, make sure it's going to wake
         * up to process it. The QS_EVENT flag might not be set if the thread
         * previously found an event message for another thread and passed
         * control over to him.
         */
        if (pqmsgT->dwQEvent != 0 && !(ptiT->pcti->fsWakeBits & QS_EVENT)) {
            SetWakeBit(ptiT, QS_EVENTSET);
        }

        /*
         * Preserve the 'idSysPeek' from the old queue, checking if the
         * redistributed queue is the same as ptiT->pq.
         */
        if (pqmsgT == (PQMSG)(pqRedist->idSysPeek) && pqRedist != ptiT->pq) {
            if (ptiT->pq->idSysPeek == 0) {
                CheckPtiSysPeek(6, ptiT->pq, pqRedist->idSysPeek);
                ptiT->pq->idSysPeek = pqRedist->idSysPeek;
            } else {
                TAGMSG2(DBGTAG_SysPeek,
                        "idSysPeek %#p already set in pq %#p",
                        ptiT->pq->idSysPeek, ptiT->pq);

            }

            /*
             * Set the 'idSysPeek' of this queue to 0 since
             * we moved the idSysPeek to other queue
             */
            CheckPtiSysPeek(7, pqRedist, 0);
            pqRedist->idSysPeek = 0;

            /*
             * Preserve also 'ptiSysLock'.
             * Set ptiSysLock to the ptiT->pq only if it points to
             * that queue.
             */
            if (ptiT->pq->ptiSysLock == NULL &&
                pqRedist->ptiSysLock != NULL &&
                pqRedist->ptiSysLock->pq == ptiT->pq) {

                CheckSysLock(4, ptiT->pq, pqRedist->ptiSysLock);
                ptiT->pq->ptiSysLock = pqRedist->ptiSysLock;

                CheckSysLock(5, pqRedist, NULL);
                pqRedist->ptiSysLock = NULL;
            } else {
                TAGMSG2(DBGTAG_SysPeek,
                        "ptiSysLock %#p already set in pq %#p\n",
                        ptiT->pq->ptiSysLock, ptiT->pq);
            }
        }

        /*
         * Don't want the prev pointer on our message list to point
         * to this message which is on a different list (doesn't
         * really matter because we're about to link it anyway,
         * but completeness shouldn't hurt).
         */
        if (pqmsgS != NULL) {
            pqmsgS->pqmsgPrev = NULL;
        }
    }
}

/***************************************************************************\
* CancelInputState
*
* This routine takes a queue and "cancels" input state in it - i.e., if the
* app thinks it is active, make it think it is not active, etc.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/

VOID CancelInputState(
    PTHREADINFO pti,
    DWORD cmd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndChild;
    AAS aas;

    /*
     * In all cases, do not leave do any send messages or any callbacks!
     * This is because this code is called from
     * SetWindowsHook(WH_JOURNALPLAYBACK | WH_JOURNALRECORD). No app currently
     * calling this routine expects to be called before this routine returns.
     * (If you do callback before it returns, you'll break at least Access
     * for Windows). - scottlu
     */
    switch (cmd) {
    case CANCEL_ACTIVESTATE:
        /*
         * Active state.
         */
        pwndT = pti->pq->spwndActive;
        ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

        QueueNotifyMessage(pwndT, WM_NCACTIVATE, FALSE, 0);
        QueueNotifyMessage(pwndT, WM_ACTIVATE,
                MAKELONG(WA_INACTIVE, TestWF(pwndT, WFMINIMIZED)),
                0);

        if (pwndT == pti->pq->spwndActive)
            Unlock(&pti->pq->spwndActive);

        aas.ptiNotify = GETPTI(pwndT);
        aas.tidActDeact = TIDq(GETPTI(pwndT));
        aas.fActivating = FALSE;
        aas.fQueueNotify = TRUE;

        /*
         * Even though this in an xxx call, it does NOT leave any critical
         * sections (because fQueueNotify is TRUE).
         */
        ThreadLockWithPti(ptiCurrent, GETPTI(pwndT)->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
        xxxInternalEnumWindow(GETPTI(pwndT)->rpdesk->pDeskInfo->spwnd->spwndChild,
                (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
        ThreadUnlock(&tlpwndChild);

        ThreadUnlock(&tlpwndT);
        break;

    case CANCEL_FOCUSSTATE:
        /*
         * Focus state.
         */
        pwndT = pti->pq->spwndFocus;
        ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

        QueueNotifyMessage(pwndT, WM_KILLFOCUS, 0, 0);
#ifdef FE_IME
        if (IS_IME_ENABLED()) {
            /*
             * Even though this in an xxx call, it does NOT leave any
             * critical section (because fQueueMsg is TRUE).
             */
            xxxFocusSetInputContext(pwndT, FALSE, TRUE);
        }
#endif
        if (pwndT == pti->pq->spwndFocus)
            Unlock(&pti->pq->spwndFocus);

        ThreadUnlock(&tlpwndT);
        break;

    case CANCEL_CAPTURESTATE:
        /*
         * Capture state.
         */

        /*
         * We shouldn't be nuking the capture of a modal menu mode.
         */
        UserAssert((pti->pMenuState == NULL)
                    || pti->pMenuState->fModelessMenu
                    || pti->pMenuState->fInDoDragDrop);

        pti->pq->QF_flags &= ~QF_CAPTURELOCKED;
        pwndT = pti->pq->spwndCapture;
        ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

        QueueNotifyMessage(pwndT, WM_CANCELMODE, 0, 0);
        if (pwndT == pti->pq->spwndCapture)
            UnlockCaptureWindow(pti->pq);

        ThreadUnlock(&tlpwndT);
        break;
    }
}

/***************************************************************************\
* DBGValidateQueueStates
*
* Verifies that all queues point to stuff owned by a thread attached to
*  the queue.
*
* 07/29/97 GerardoB     Created
\***************************************************************************/
#if DBG
#define VALIDATEQSPWND(spwnd) \
        if (pq-> ## spwnd != NULL) { \
            ptiwnd = GETPTI(pq-> ## spwnd); \
            fDestroyedOK = (TestWF(pq-> ## spwnd, WFDESTROYED) && (ptiwnd == gptiRit)); \
            UserAssert((pti->rpdesk == ptiwnd->rpdesk) || fDestroyedOK); \
            UserAssert((pti == ptiwnd) \
                        || (fAttached && (pq == ptiwnd->pq)) \
                        || fDestroyedOK); \
        }


void DBGValidateQueueStates (PDESKTOP pdesk)
{
    BOOL fAttached, fDestroyedOK;
    PQ pq;
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO pti, ptiwnd;
    DWORD dwInForeground = 0;

    UserAssert((gpqForeground == NULL)
                || ((gpqForeground->ptiMouse->rpdesk == grpdeskRitInput)
                    && (gpqForeground->cThreads != 0)));

    if (pdesk == NULL) {
        RIPMSG0(RIP_WARNING, "DBGValidateQueueStates: Null pdesk parameter");
        return;
    }
    pHead = &pdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
        pq = pti->pq;
        if (pq == NULL) {
            RIPMSG2(RIP_WARNING, "DBGValidateQueueStates: Null pq. pti:%#p. pdesk:%#p", pti, pdesk);
            continue;
        }
        /*
         * The queue should have a non-null cThreads excepting when it is
         * QF_INDESTROY
         */
        if (!(pq->QF_flags & QF_INDESTROY)) {
            UserAssert(pq->cThreads != 0);
        }
        fAttached = (pq->cThreads > 1);
        if (pti->pq == gpqForeground) {
            dwInForeground++;
        }
        /*
         * pti's
         */
        UserAssert((pti == pq->ptiMouse)
                    || (fAttached && (pq == pq->ptiMouse->pq)));
        UserAssert(pti->rpdesk == pq->ptiMouse->rpdesk);
        UserAssert((pti == pq->ptiKeyboard)
                    || (fAttached && (pq == pq->ptiKeyboard->pq)));
        UserAssert(pti->rpdesk == pq->ptiKeyboard->rpdesk);
        if (pq->ptiSysLock != NULL) {
            UserAssert((pti == pq->ptiSysLock)
                        || (fAttached && (pq == pq->ptiSysLock->pq)));
        }
        /*
         * pwnd's.
         */
        VALIDATEQSPWND(spwndActive);
        VALIDATEQSPWND(spwndFocus);
        VALIDATEQSPWND(spwndCapture);
        VALIDATEQSPWND(spwndActivePrev);
    }

    UserAssert((gpqForeground == NULL)
                || (dwInForeground == 0)
                || (gpqForeground->cThreads == dwInForeground));
}

/***************************************************************************\
* DBGValidateQueue
*
* Verifies that queue is readable and fields are valid.
*
* 02-Sep-1999 JerrySh   Created.
\***************************************************************************/
void DBGValidateQueue(PQ pq)
{
    if (pq != NULL) {
        Q q = *pq;
        UserAssert(q.spwndActive == HtoP(PtoH(q.spwndActive)));
        UserAssert(q.spwndFocus == HtoP(PtoH(q.spwndFocus)));
        UserAssert(q.spwndCapture == HtoP(PtoH(q.spwndCapture)));
        UserAssert(q.spwndActivePrev == HtoP(PtoH(q.spwndActivePrev)));
        UserAssert(q.spcurCurrent == HtoP(PtoH(q.spcurCurrent)));
    }
}
#endif /* DBG */
/***************************************************************************\
* zzzAttachThreadInput (API)
* zzzReattachThreads
* zzzAttachToQueue
* CheckTransferState
*
* Attaches a given thread to another input queue, either by attaching to
* a queue (referenced by another thread id), or detaching from one.
*
* 12-09-92  ScottLu     Created.
\***************************************************************************/

#define CTS_DONOTHING 0
#define CTS_CANCELOLD 1
#define CTS_TRANSFER  2

DWORD CheckTransferState(
    PTHREADINFO pti,
    PQ pqAttach,
    LONG offset,
    BOOL fJoiningForeground)
{
    PWND pwndOld, pwndNew, pwndForegroundState;

    /*
     * return 0: do nothing.
     * return 1: cancel the old state.
     * return 2: transfer the old state to the new state
     */
    pwndOld = *(PWND *)(((BYTE *)pti->pq) + offset);
    pwndNew = *(PWND *)(((BYTE *)pqAttach) + offset);

    /*
     * Make sure the old state even exists, and that the old state is
     * owned by this thread. If not, nothing happens.
     */
    if (pwndOld == NULL || GETPTI(pwndOld) != pti)
        return CTS_DONOTHING;

    /*
     * If the new state already exists, cancel the old state.
     */
    if (pwndNew != NULL)
        return CTS_CANCELOLD;

    /*
     * Transfer this old state if this thread is not joining the foreground.
     */
    if (gpqForeground == NULL || !fJoiningForeground)
        return CTS_TRANSFER;

    /*
     * We're joining the foreground - only transfer the old state if we own
     * that foreground state or if there is no foreground state.
     */
    pwndForegroundState = *(PWND *)(((BYTE *)gpqForeground) + offset);
    if (pwndForegroundState == NULL || pwndOld == pwndForegroundState)
        return CTS_TRANSFER;

    /*
     * We're joining the foreground but we didn't set that foreground state.
     * Don't allow the transfer of that state.
     */
    return CTS_CANCELOLD;
}

VOID zzzAttachToQueue(
    PTHREADINFO pti,
    PQ   pqAttach,
    PQ   pqJournal,
    BOOL fJoiningForeground)
{
    PQMSG pqmsgT;
    PQ pqDestroy;

    /*
     * Check active state.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndActive), fJoiningForeground)) {
    case CTS_CANCELOLD:
        CancelInputState(pti, CANCEL_ACTIVESTATE);
        break;

    case CTS_TRANSFER:
        Lock(&pqAttach->spwndActive, pti->pq->spwndActive);
        Unlock(&pti->pq->spwndActive);

        /*
         * The caret usually follows the focus window, which follows
         * the active window...
         */
        if (pti->pq->caret.spwnd != NULL) {

            if (GETPTI(pti->pq->caret.spwnd) == pti) {
                /*
                 * Just copy the entire caret structure... that way we
                 * don't need to deal with locking/unlocking the spwnd.
                 */
                if (pqAttach->caret.spwnd == NULL) {
                    pqAttach->caret = pti->pq->caret;
                    pti->pq->caret.spwnd = NULL;
                }
            }
        }
        break;
    }

    /*
     * Check focus state.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndFocus), fJoiningForeground)) {
    case CTS_CANCELOLD:
        CancelInputState(pti, CANCEL_FOCUSSTATE);
        break;

    case CTS_TRANSFER:
        Lock(&pqAttach->spwndFocus, pti->pq->spwndFocus);
        Unlock(&pti->pq->spwndFocus);
        break;
    }

    /*
     * Check capture state.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndCapture), fJoiningForeground)) {
    case CTS_CANCELOLD:
        CancelInputState(pti, CANCEL_CAPTURESTATE);
        break;

    case CTS_TRANSFER:
        LockCaptureWindow(pqAttach, pti->pq->spwndCapture);
        UnlockCaptureWindow(pti->pq);
        pqAttach->codeCapture = pti->pq->codeCapture;
        pqAttach->QF_flags ^= ((pqAttach->QF_flags ^ pti->pq->QF_flags) & QF_CAPTURELOCKED);
        break;

#if DBG
    case CTS_DONOTHING:
        /*
         * We should always transfer the capture state of a thread
         * in modal menu mode.
         */
        UserAssert((pti->pMenuState == NULL)
                    || ExitMenuLoop(pti->pMenuState, pti->pMenuState->pGlobalPopupMenu)
                    || pti->pMenuState->fModelessMenu
                    || pti->pMenuState->fInDoDragDrop);

        break;
#endif
    }

    /*
     * Check spwndActivePrev state.  This check has some considerations.
     * If the CTS_TRANSFER is returned, it usually means there was no
     * prev-active in the attach-queue, and it will use the first
     * window it encounters.  Since we walk the thread-list, a out-of-zorder
     * window could be chosen.  So, to counter this, we'll check the
     * attach-queue-next-prev against the thread-previous window to see
     * if it is truly the next-zorder window.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndActivePrev), fJoiningForeground)) {
    case CTS_TRANSFER:
        Lock(&pqAttach->spwndActivePrev, pti->pq->spwndActivePrev);
        Unlock(&pti->pq->spwndActivePrev);
        break;

    case CTS_CANCELOLD:

        /*
         * Check to see if the previous window is what we would expect it
         * to be.
         */
        if (pqAttach->spwndActive &&
            (pqAttach->spwndActivePrev && pti->pq->spwndActivePrev) &&
            (pqAttach->spwndActive->spwndNext == pti->pq->spwndActivePrev)) {

            Lock(&pqAttach->spwndActivePrev, pti->pq->spwndActivePrev);
            Unlock(&pti->pq->spwndActivePrev);
        }
        break;
    }

    if (pti == pti->pq->ptiSysLock) {
        /*
         * Preserve any of the flags we might have already been set on pqAttach.
         * Note that these flags might have been set on a previous call
         * to this function that received the same pqAttach.
         */
        pqAttach->QF_flags ^= ((pqAttach->QF_flags ^ pti->pq->QF_flags)
                                & ~(QF_CAPTURELOCKED));

        /*
         * Fix for 29967 "Start menu disappears when clicked  and Office
         * taskbar has focus!". Win95 uses a global counter instead of this
         * flag. In NT when we click on Office taskbar and then on the Start
         * Menu, MSoffice calls zzzAttachThreadInput() which changes the Start
         * Menu's queue and the new queue has the QF_ACTIVATIONCHANGE flag on.
         * Inside the xxxMNLoop we test if this flag is on and if it is we
         * exit the menu.
         */
        if (!IsInsideMenuLoop(pti)) {
            pqAttach->QF_flags &= ~QF_ACTIVATIONCHANGE;
        }

        /*
         * Unlock the queue since pti is moving to anotther queue.
         */
        /* CheckSysLock(6, pq, NULL); what number? */
        pti->pq->ptiSysLock = NULL;
    }

    if (gspwndCursor != NULL && pti == GETPTI(gspwndCursor)) {
        LockQCursor(pqAttach, pti->pq->spcurCurrent);
    }

    /*
     * Each thread has its own cursor level, which is a count of the number
     * of times that app has called show/hide cursor. This gets added into
     * the queue's count for a completely accurate count every time this
     * queue recalculation is done.
     */
    /*
     * LATER
     * We need to adjust the iCursorLevel of the old queue to reflect
     * the fact that a thread is departing.
     * FritzS
     */
    pqAttach->iCursorLevel += pti->iCursorLevel;

    /*
     * Pump up the new queue with the right input variables.
     */
    pqAttach->ptiMouse    = pti;
    pqAttach->ptiKeyboard = pti;

    pqDestroy = pti->pq;

    /*
     * Don't increment the thread count here because we already incremented
     * it when we put it in pti->pqAttach. Since we're moving it from pqAttach
     * to pq, we don't mess with the reference count.
     */
    pti->pq = pqAttach;

    /*
     * If the thread is using the journal queue, leave the message list
     * alone.  Otherwise, redistribute the messages.
     */
    if (pqDestroy != pqJournal) {

        /*
         * Remember the current message list so it can get redistributed taking
         * into account ptiAttach's new queue.
         */
        pqmsgT = pqDestroy->mlInput.pqmsgRead;
        pqDestroy->mlInput.pqmsgRead      = NULL;
        pqDestroy->mlInput.pqmsgWriteLast = NULL;
        pqDestroy->mlInput.cMsgs          = 0;

        /*
         * Now redistribute the input messages from the old queue they go into the
         * right queues.
         *
         * Preserve the 'idSysPeek' when redistributing the queue
         */
        RedistributeInput(pqmsgT, pqDestroy);

        /*
         * Officially attach the new queue to this thread. Note that zzzDestroyQueue()
         * doesn't actually destroy anything until the thread reference count goes
         * to 0.
         */
        zzzDestroyQueue(pqDestroy, pti);

    } else {
        UserAssert(pqDestroy->cThreads);
        pqDestroy->cThreads--;
    }
}

BOOL zzzReattachThreads(
    BOOL fJournalAttach)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTHREADINFO pti;
    PQ          pqForegroundPrevNew;
    PQ          pqForegroundNew;
    PQ          pqAttach;
    PQ          pqJournal;
    PLIST_ENTRY pHead, pEntry;
    BOOL        bHadAnActiveForegroundWindow;

    /*
     * In all cases, do not leave do any send messages or any callbacks!
     * This is because this code is called from
     * SetWindowsHook(WH_JOURNALPLAYBACK | WH_JOURNALRECORD). No app currently
     * calling this routine expects to be called before this routine returns.
     * (If you do callback before it returns, you'll break at least Access
     * for Windows). - scottlu
     */

#if DBG
    DBGValidateQueueStates(ptiCurrent->rpdesk);
#endif

    /*
     * Defer Win Event notifications so we can traverse PtiList with impunity
     * Also, we don't want to callback while we're half way attached
     */
    DeferWinEventNotify();
    BEGINATOMICCHECK();

    /*
     * Don't recalc attach info if this is a journal attach, because
     * the journal attach code has already done this for us.
     */
    if (!fJournalAttach) {

        /*
         * Now recalculate all the different queue groups, based on the
         * attach requests. This fills in the pqAttach of each thread info
         * with the new queue this thread belongs to. Always takes into
         * account all attachment requests.
         */
        zzzRecalcThreadAttachment();

        /*
         * Make a guess about which queue is the journal queue.
         */
        pqJournal = gpqForeground;
        if (pqJournal == NULL)
            pqJournal = ptiCurrent->pq;

        /*
         * If the queue is only used by one thread, perform normal processing.
         */
        if (pqJournal->cThreads == 1) {
            pqJournal = NULL;
        } else {

            /*
             * Lock the queue to ensure that it stays valid
             * until we have redistributed the input.
             */
            (pqJournal->cLockCount)++;
        }
    } else {
        pqJournal = NULL;
    }

    /*
     * What will be the new foreground queue?
     */
    pqForegroundNew = NULL;

    /*
     * Remember if there is a foreground window so we don't force one
     * at the end if there wasn't one before the attach
     */
    if (gpqForeground != NULL && gpqForeground->spwndActive != NULL) {
        bHadAnActiveForegroundWindow = TRUE;
        pqForegroundNew = GETPTI(gpqForeground->spwndActive)->pqAttach;
    } else {
        bHadAnActiveForegroundWindow = FALSE;
    }

    pqForegroundPrevNew = NULL;
    if (gpqForegroundPrev != NULL && gpqForegroundPrev->spwndActivePrev != NULL) {
        pqForegroundPrevNew = GETPTI(gpqForegroundPrev->spwndActivePrev)->pqAttach;
    }


    pHead = &ptiCurrent->rpdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        if (pti->pqAttach == pti->pq) {
            pti->pqAttach = NULL;
        } else if(pti->pqAttach != NULL) {
            /*
             * It is crucial that we NULL out pqAttach for this queue once
             * we have it in a local variable because the NULL-ness of this
             * field is checked in attach operations.
             */
            pqAttach = pti->pqAttach;
            pti->pqAttach = NULL;

            zzzAttachToQueue(pti, pqAttach, pqJournal, pqForegroundNew == pqAttach);
        }

    }

    /*
     * If we are doing a journal detach, redistribute the input messages
     * from the old queue.
     */
    if (pqJournal != NULL) {
        PQMSG pqmsgRedist;

        UserAssert(pqJournal->cLockCount);
        (pqJournal->cLockCount)--;
        pqmsgRedist = pqJournal->mlInput.pqmsgRead;

        pqJournal->mlInput.pqmsgRead      = NULL;
        pqJournal->mlInput.pqmsgWriteLast = NULL;
        pqJournal->mlInput.cMsgs          = 0;
        RedistributeInput(pqmsgRedist, pqJournal);

        /*
         * Only destroy the queue if it is no longer is use.
         */
        if (pqJournal->cThreads == 0) {
            pqJournal->cThreads = 1;    // prevent underflow
            zzzDestroyQueue(pqJournal, pti); // DeferWinEventNotify() ?? IANJA ??
        } else {
            /*
             * Make sure that this queue doesn't point to a pti
             *  no longer attached to it.
             * Hopefully we'll go to zzzDestroyQueue only once
             * Increment cThreads so the queue won't be destroyed
             *  but we'll simply reassign the pti fields.
             */
            if ((pqJournal->ptiMouse != NULL)
                    && (pqJournal != pqJournal->ptiMouse->pq)) {
                pqJournal->cThreads++;
                zzzDestroyQueue(pqJournal, pqJournal->ptiMouse);
            }
            if ((pqJournal->ptiKeyboard != NULL)
                    && (pqJournal != pqJournal->ptiKeyboard->pq)) {
                pqJournal->cThreads++;
                zzzDestroyQueue(pqJournal, pqJournal->ptiKeyboard);
            }
        }
    }

#if DBG
    DBGValidateQueueStates(ptiCurrent->rpdesk);
#endif

    /*
     * If the current thread is not on the active desktop, do not
     * change the global foreground state.
     */
    if (PtiCurrent()->rpdesk != grpdeskRitInput) {
        EXITATOMICCHECK();
        zzzEndDeferWinEventNotify();
        return TRUE;
    }

    /*
     * We're done attaching. gptiForeground hasn't changed... but
     * gpqForeground has!  Try not to leave NULL as the foreground.
     */
#if DBG
    DBGValidateQueue(pqForegroundNew);
#endif
    gpqForeground = pqForegroundNew;
    // So we can Alt-Esc xxxNextWindow without an AV
    // If we have a non-NULL gpqForeground, its kbd input thread better have an rpdesk!
    UserAssert(!gpqForeground || (gpqForeground->ptiKeyboard && gpqForeground->ptiKeyboard->rpdesk));
    gpqForegroundPrev = pqForegroundPrevNew;

    ENDATOMICCHECK();
    zzzEndDeferWinEventNotify();

    if ((gpqForeground == NULL) && (bHadAnActiveForegroundWindow))  {
        PWND pwndNewForeground;
        PTHREADINFO pti = PtiCurrent();

        pwndNewForeground = _GetNextQueueWindow(pti->rpdesk->pDeskInfo->spwnd->spwndChild, 0, FALSE);

        /*
         * Don't use xxxSetForegroundWindow2 because we must not leave
         * the critical section.  There is no currently active foreground
         * so all that is needed is to post an activate event to the
         * new foreground queue.
         */
        if (pwndNewForeground != NULL) {
            PostEventMessage(GETPTI(pwndNewForeground),
                    GETPTI(pwndNewForeground)->pq, QEVENT_ACTIVATE, NULL, 0,
                    0, (LPARAM)HWq(pwndNewForeground));
        }
    }

    zzzSetFMouseMoved();

    UserAssert(gpqForeground == NULL || gpqForeground->ptiMouse->rpdesk == grpdeskRitInput);

    return TRUE;
}

BOOL zzzAttachThreadInput(
    PTHREADINFO ptiAttach,
    PTHREADINFO ptiAttachTo,
    BOOL fAttach)
{
    CheckCritIn();

    /*
     * Attaching to yourself doesn't make any sense.
     */
    if (ptiAttach == ptiAttachTo)
        return FALSE;

#if defined(FE_IME)
    /*
     * For console IME issue
     *
     * Console IME do attach to console input thread message queue.
     * So needs share message queue for synchronize a key state.
     */
    if (IS_IME_ENABLED()) {
        PTHREADINFO ptiConsoleIME;
        PTHREADINFO ptiConsoleInput;

        if ( ((ptiConsoleIME   = PtiFromThreadId(ptiAttach->rpdesk->dwConsoleIMEThreadId)) != NULL) &&
             ((ptiConsoleInput = PtiFromThreadId(ptiAttach->rpdesk->dwConsoleThreadId)) != NULL)    &&
             (ptiAttach == ptiConsoleIME)     &&
             (ptiAttachTo == ptiConsoleInput) &&
             (ptiConsoleIME->TIF_flags & TIF_DONTATTACHQUEUE)
           )
        {
            goto SkipCheck;
        }
    }
#endif
    /*
     * Will this thread allow attaching? Shell threads and system threads
     * won't allow attaching.
     */
    if (ptiAttachTo->TIF_flags & TIF_DONTATTACHQUEUE) {
        return FALSE;
    }
    if (ptiAttach->TIF_flags & TIF_DONTATTACHQUEUE) {
        return FALSE;
    }

#if defined(FE_IME)
SkipCheck:
#endif
    /*
     * Don't allow attaching across desktops, either.
     */
    if (ptiAttachTo->rpdesk != ptiAttach->rpdesk) {
        return FALSE;
    }

    /*
     * If attaching, make a new attachinfo structure for this thread.
     * If not attaching, remove an existing attach reference.
     */
    if (fAttach) {
        PATTACHINFO pai;

         /*
         * Alloc a new attachinfo struct, fill it in, link it in.
         */
        if ((pai = (PATTACHINFO)UserAllocPool(sizeof(ATTACHINFO), TAG_ATTACHINFO)) == NULL)
            return FALSE;

        pai->pti1 = ptiAttach;
        pai->pti2 = ptiAttachTo;;
        pai->paiNext = gpai;
        gpai = pai;
    } else {
        PATTACHINFO *ppai;
        BOOL fFound = FALSE;

        /*
         * Search for this attachinfo struct. If we can't find it, fail.
         * If we do find it, unlink it and free it.
         */
        for (ppai = &gpai; (*ppai) != NULL; ppai = &(*ppai)->paiNext) {
            if (((*ppai)->pti2 == ptiAttachTo) && ((*ppai)->pti1 == ptiAttach)) {
                PATTACHINFO paiKill = *ppai;
                fFound = TRUE;
                *ppai = (*ppai)->paiNext;
                UserFreePool((HLOCAL)paiKill);
                break;
            }
        }

        /*
         * If we couldn't find this reference, then fail.
         */
        if (!fFound) {
            return FALSE;
        }
    }

    /*
     * Now do the actual reattachment work for all threads - unless we're
     * journalling. If we did by mistake do attachment while journalling
     * was occuring, journalling would be hosed because journalling requires
     * all threads to be attached - but it is also treated as a special
     * case so it doesn't affect the ATTACHINFO structures. Therefore
     * recalcing attach info based on ATTACHINFO structures would break
     * the attachment required for journalling.
     */
    if (!FJOURNALRECORD() && !FJOURNALPLAYBACK()) {
        return zzzReattachThreads(FALSE);
    }

    return TRUE;
}

/***************************************************************************\
* _SetMessageExtraInfo (API)
*
* History:
* 1-May-1995 FritzS
\***************************************************************************/
LONG_PTR _SetMessageExtraInfo(LONG_PTR lData)
{
    LONG_PTR lRet;
    PTHREADINFO pti = PtiCurrent();

    lRet = pti->pq->ExtraInfo;
    pti->pq->ExtraInfo = lData;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\inctlpan.c ===
/***************************************************************************\
*
*  INCTLPAN.C
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*  Init Routines which are also used by Control Panel
*
*  -- Scalable Window Frame Support
*
*  exports from this module:
*   > xxxSetWindowNCMetrics  -- called by LoadWindows & SystemParametersInfo
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

__inline int
MetricGetID(
        PUNICODE_STRING pProfileUserName,
        UINT    idStr,
        int     defValue
        )
{
    int iRet;
    FastGetProfileIntFromID(
            pProfileUserName, PMAP_METRICS, idStr, defValue, &iRet, 0);
    return iRet;
}

static CONST WORD sysBmpStyles[OBI_COUNT][2] = {

    DFC_CAPTION,   DFCS_CAPTIONCLOSE,                               // OBI_CLOSE
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_PUSHED,                 // OBI_CLOSE_D
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_HOT,                    // OBI_CLOSE_H
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INACTIVE,               // OBI_CLOSE_I
    DFC_CAPTION,   DFCS_CAPTIONMIN,                                 // OBI_REDUCE
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_PUSHED,                   // OBI_REDUCE_D
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_HOT,                      // OBI_REDUCE_H
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INACTIVE,                 // OBI_REDUCE_I
    DFC_CAPTION,   DFCS_CAPTIONRESTORE,                             // OBI_RESTORE
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_PUSHED,               // OBI_RESTORE_D
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_HOT,                  // OBI_RESTORE_H
    DFC_CAPTION,   DFCS_CAPTIONHELP,                                // OBI_HELP
    DFC_CAPTION,   DFCS_CAPTIONHELP | DFCS_PUSHED,                  // OBI_HELP_D
    DFC_CAPTION,   DFCS_CAPTIONHELP | DFCS_HOT,                     // OBI_HELP_H
    DFC_CAPTION,   DFCS_CAPTIONMAX,                                 // OBI_ZOOM
    DFC_CAPTION,   DFCS_CAPTIONMAX | DFCS_PUSHED,                   // OBI_ZOOM_D
    DFC_CAPTION,   DFCS_CAPTIONMAX | DFCS_HOT,                      // OBI_ZOOM_H
    DFC_CAPTION,   DFCS_CAPTIONMAX | DFCS_INACTIVE,                 // OBI_ZOOM_I
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU,                 // OBI_CLOSE_MBAR
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU | DFCS_PUSHED,   // OBI_CLOSE_MBAR_D
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU | DFCS_HOT,      // OBI_CLOSE_MBAR_H
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU | DFCS_INACTIVE, // OBI_CLOSE_MBAR_I
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU,                   // OBI_REDUCE_MBAR
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU | DFCS_PUSHED,     // OBI_REDUCE_MBAR_D
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU | DFCS_HOT,        // OBI_REDUCE_MBAR_H
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU | DFCS_INACTIVE,   // OBI_REDUCE_MBAR_I
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_INMENU,               // OBI_RESTORE_MBAR
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_INMENU | DFCS_PUSHED, // OBI_RESTORE_MBAR_D
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_INMENU | DFCS_HOT,    // OBI_RESTORE_MBAR_H
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON1
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON1_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON2
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON2_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON3
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON3_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON4
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON4_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON5
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON5_I
    DFC_CACHE,     DFCS_CACHEBUTTONS,                               // OBI_CAPBTNS
    DFC_CACHE,     DFCS_CACHEBUTTONS | DFCS_INACTIVE,               // OBI_CAPBTNS_I
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL,                // OBI_CLOSE_PAL
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL | DFCS_PUSHED,  // OBI_CLOSE_PAL_D
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL | DFCS_HOT,     // OBI_CLOSE_PAL_H
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL | DFCS_INACTIVE,// OBI_CLOSE_PAL_I
    DFC_SCROLL,    DFCS_SCROLLSIZEGRIP,                             // OBI_NCGRIP
    DFC_SCROLL,    DFCS_SCROLLUP,                                   // OBI_UPARROW
    DFC_SCROLL,    DFCS_SCROLLUP | DFCS_PUSHED | DFCS_FLAT,         // OBI_UPARROW_D
    DFC_SCROLL,    DFCS_SCROLLUP | DFCS_HOT,                        // OBI_UPARROW_H
    DFC_SCROLL,    DFCS_SCROLLUP | DFCS_INACTIVE,                   // OBI_UPARROW_I
    DFC_SCROLL,    DFCS_SCROLLDOWN,                                 // OBI_DNARROW
    DFC_SCROLL,    DFCS_SCROLLDOWN | DFCS_PUSHED | DFCS_FLAT,       // OBI_DNARROW_D
    DFC_SCROLL,    DFCS_SCROLLDOWN | DFCS_HOT,                      // OBI_DNARROW_H
    DFC_SCROLL,    DFCS_SCROLLDOWN | DFCS_INACTIVE,                 // OBI_DNARROW_I
    DFC_SCROLL,    DFCS_SCROLLRIGHT,                                // OBI_RGARROW
    DFC_SCROLL,    DFCS_SCROLLRIGHT | DFCS_PUSHED | DFCS_FLAT,      // OBI_RGARROW_D
    DFC_SCROLL,    DFCS_SCROLLRIGHT | DFCS_HOT,                     // OBI_RGARROW_H
    DFC_SCROLL,    DFCS_SCROLLRIGHT | DFCS_INACTIVE,                // OBI_RGARROW_I
    DFC_SCROLL,    DFCS_SCROLLLEFT,                                 // OBI_LFARROW
    DFC_SCROLL,    DFCS_SCROLLLEFT | DFCS_PUSHED | DFCS_FLAT,       // OBI_LFARROW_D
    DFC_SCROLL,    DFCS_SCROLLLEFT | DFCS_HOT,                      // OBI_LFARROW_H
    DFC_SCROLL,    DFCS_SCROLLLEFT | DFCS_INACTIVE,                 // OBI_LFARROW_I
    DFC_MENU,      DFCS_MENUARROW,                                  // OBI_MENUARROW
    DFC_MENU,      DFCS_MENUCHECK,                                  // OBI_MENUCHECK
    DFC_MENU,      DFCS_MENUBULLET,                                 // OBI_MENUBULLET
    DFC_MENU,      DFCS_MENUARROWUP,                                // OBI_MENUARROWUP
    DFC_MENU,      DFCS_MENUARROWUP | DFCS_HOT,                     // OBI_MENUARROWUP_H
    DFC_MENU,      DFCS_MENUARROWUP | DFCS_INACTIVE,                // OBI_MENUARROWUP_I
    DFC_MENU,      DFCS_MENUARROWDOWN,                              // OBI_MENUARROWDOWN
    DFC_MENU,      DFCS_MENUARROWDOWN | DFCS_HOT,                   // OBI_MENUARROWDOWN_H
    DFC_MENU,      DFCS_MENUARROWDOWN | DFCS_INACTIVE,              // OBI_MENUARROWDOWN_I
    DFC_BUTTON,    DFCS_BUTTONRADIOMASK,                            // OBI_RADIOMASK
    DFC_BUTTON,    DFCS_BUTTONCHECK,                                // OBI_CHECK
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_CHECKED,                 // OBI_CHECK_C
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_PUSHED,                  // OBI_CHECK_D
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_CHECKED | DFCS_PUSHED,   // OBI_CHECK_CD
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_CHECKED | DFCS_INACTIVE, // OBI_CHECK_CDI
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE,                           // OBI_RADIO
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_CHECKED,            // OBI_RADIO_C
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_PUSHED,             // OBI_RADIO_D
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_CHECKED | DFCS_PUSHED,  // OBI_RADIO_CD
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_CHECKED | DFCS_INACTIVE,  // OBI_RADIO_CDI
    DFC_BUTTON,    DFCS_BUTTON3STATE,                               // OBI_3STATE
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_CHECKED,                // OBI_3STATE_C
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_PUSHED,                 // OBI_3STATE_D
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_CHECKED | DFCS_PUSHED,  // OBI_3STATE_CD
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_CHECKED | DFCS_INACTIVE,  // OBI_3STATE_CDI
    DFC_POPUPMENU, DFCS_CAPTIONCLOSE | DFCS_INMENU,                   // OBI_CLOSE_POPUP
    DFC_POPUPMENU, DFCS_CAPTIONRESTORE | DFCS_INMENU,                 // OBI_RESTORE_POPUP
    DFC_POPUPMENU, DFCS_CAPTIONMAX | DFCS_INMENU,                     // OBI_ZOOM_POPUP
    DFC_POPUPMENU, DFCS_CAPTIONMIN | DFCS_INMENU,                     // OBI_REDUCE_POPUP
    DFC_SCROLL,    DFCS_SCROLLSIZEGRIPRIGHT,                        // OBI_NCGRIP_L
    DFC_MENU,      DFCS_MENUARROWRIGHT                              // OBI_MENUARROW_L
};

#define DIVISOR 72
#define DU_BTNWIDTH       50  // D.U. of minimum button width in a message box

UINT xxxMB_FindLongestString(HDC hdc);

#ifdef LATER
/***************************************************************************\
\***************************************************************************/

WCHAR NibbleToChar(
    BYTE x)
{
    WCHAR static N2C[] =
      {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
      };

    return N2C[x];
}

BYTE CharToNibble(
    WCHAR ch)
{
    BYTE x = (BYTE)ch;

    return x >= '0' && x <= '9' ?
        x - '0' :
        ((10 + x - 'A' ) & 0x0f);
}

BOOL TextToBinary(
    LPBYTE pbyte,
    LPWSTR pwstr,
    int length)
{
    BYTE checksum = 0;

    while (TRUE) {
        BYTE byte;

        byte = (CharToNibble(pwstr[0]) << 4) | CharToNibble(pwstr[1]);

        if (length == 0) {
            return checksum == byte;
        }

        checksum += byte;
        *pbyte = byte;

        pwstr += 2;
        length--;
        pbyte++;
    }
}

void BinaryToText(
    LPWSTR pwstr,
    LPBYTE pbyte,
    int length)
{
    BYTE checksum = 0;

    while (length > 0) {
        checksum += *pbyte;

        pwstr[0] = NibbleToChar((BYTE)((*pbyte >> 4) & 0x0f));
        pwstr[1] = NibbleToChar((BYTE)(*pbyte & 0x0f));

        pbyte++;
        pwstr += 2;
        length--;
    }

    pwstr[0] = NibbleToChar((BYTE)((checksum >> 4) & 0x0f));
    pwstr[1] = NibbleToChar((BYTE)(checksum & 0x0f));
    pwstr[2] = '\0';
}

/***************************************************************************\
\***************************************************************************/

// these are the exported apis.  The User* versions are for server use only
// I didn't get them to work since no one calls them yet.

BOOL GetPrivateProfileStruct(
    LPWSTR szSection,
    LPWSTR szKey,
    LPWSTR lpStruct,
    DWORD uSizeStruct,
    LPWSTR szFile)
{
    WCHAR szBuf[256];
    BOOL  fAlloc = FALSE;
    LPSTR lpBuf, lpBufTemp;
    int   nLen;
    BOOL fError = FALSE;

    nLen = uSizeStruct * 4 + 10;
    if (nLen > (WORD)sizeof(szBuf)) {
        fAlloc = TRUE;
        lpBuf = (LPSTR)UserAllocPoolWithQuota(nLen, TAG_PROFILE);
        if (lpBuf == NULL)
            return FALSE;
    } else {
        lpBuf = (LPSTR)szBuf;
    }

    if (szFile && *szFile) {
        nLen = GetPrivateProfileString(szSection, szKey, NULL, lpBuf, nLen, szFile);
    } else {
        nLen = GetProfileString(szSection, szKey, NULL, lpBuf, nLen);
    }

    if (nLen == (int)(uSizeStruct * 4 + 4)) {
        /*
         * decode the string
         */
        fError = TextToBinary(lpStruct, lpBufTemp, uSizeStruct);
    }

    if (fAlloc)
        UserFreePool(lpBuf);

    return fError;
}

BOOL WritePrivateProfileStruct(
    LPWSTR szSection,
    LPWSTR szKey,
    LPWSTR lpStruct,
    WORD uSizeStruct,
    LPWSTR szFile)
{
    LPWSTR lpBuf;
    BOOL bRet;
    BOOL fAlloc;
    WCHAR szBuf[256];
    BYTE checksum=0;
    int allocsize = (uSizeStruct * 2 + 3) * sizeof(WCHAR);

    /* NULL lpStruct erases the the key */

    if (lpStruct == NULL) {
        if (szFile && *szFile) {
            return WritePrivateProfileString(szSection, szKey, (LPSTR)NULL, szFile);
        } else {
            return WriteProfileString(szSection, szKey, (LPSTR)NULL);
        }
    }

    fAlloc = (allocsize > sizeof(szBuf));
    if (fAlloc) {
        lpBuf = (LPSTR)UserAllocPoolWithQuota(allocsize, TAG_PROFILE);
        if (!lpBuf)
            return FALSE;
    } else {
        lpBuf = (LPSTR)szBuf;
    }

    BinaryToText(lpBuf, lpStruct, uSizeStruct);

    if (szFile && *szFile) {
        bRet = WritePrivateProfileString(szSection, szKey, lpBuf, szFile);
    } else {
        bRet = WriteProfileString(szSection, szKey, lpBuf);
    }

    if (fAlloc)
        UserFreePool(lpBuf);

    return bRet;
}
#endif

/***************************************************************************\
*
*  GetFrameControlMetrics
*
*  (cx = 0) is a code meaning cy is the obi of the "shared" bitmap
*
\***************************************************************************/
int GetFrameControlMetrics(
        UINT         obi,
        int          cxMax )
{
    int cx, cy;
    UINT wType  = sysBmpStyles[obi][0];
    UINT wState = sysBmpStyles[obi][1];
    POEMBITMAPINFO pOem = gpsi->oembmi + obi;

    switch (wType) {
        case DFC_SCROLL:
            if (wState & DFCS_SCROLLSIZEGRIP) {
                cx = SYSMET(CXVSCROLL);
                cy = SYSMET(CYHSCROLL);
                break;
            } else if (wState & DFCS_SCROLLHORZ) {
                cx = SYSMET(CXHSCROLL);
                cy = SYSMET(CYHSCROLL);
            } else {
                cx = SYSMET(CXVSCROLL);
                cy = SYSMET(CYVSCROLL);
            }
            break;

        case DFC_MENU:
        case DFC_POPUPMENU:
            if (wState & (DFCS_MENUARROWUP | DFCS_MENUARROWDOWN)) {
                cy = gcyMenuScrollArrow;
            } else {
                /*
                 * Add on proper space for space above underscore.
                 * the 0xFFFE and -1 are to insure an ODD height
                 */
                cy = ((gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYBORDER)) & 0xFFFE) - 1;
            }
            cx = cy;
            break;

        case DFC_CAPTION:
            if (wState & DFCS_INSMALL) {
                cx = SYSMET(CXSMSIZE);
                cy = SYSMET(CYSMSIZE);
            } else if (wState & DFCS_INMENU) {
                if ((SYSMET(CXSIZE) == SYSMET(CXMENUSIZE)) &&
                    (SYSMET(CYSIZE) == SYSMET(CYMENUSIZE))) {
                    cx = 0;
                    cy = obi - DOBI_MBAR;
                    break;
                } else {
                    cx = SYSMET(CXMENUSIZE);
                    cy = SYSMET(CYMENUSIZE);
                }
            } else {
                cx = SYSMET(CXSIZE);
                cy = SYSMET(CYSIZE);
            }

            cx -= SYSMET(CXEDGE);
            cy -= 2 * SYSMET(CYEDGE);
            break;

        case DFC_CACHE:
            if (wState & DFCS_CACHEBUTTONS) {
                cx = SYSMET(CXSIZE) * 4;
                cy = SYSMET(CYSIZE);
            } else
                cx = cy = SYSMET(CYSIZE);
            break;

        case DFC_BUTTON:
            if (((wState & 0x00FF) & DFCS_BUTTON3STATE) && !(wState & DFCS_CHECKED)) {
                cx = 0;
                cy = obi - DOBI_3STATE;
            } else {
                /*
                 * Scale button size with screen DPI so we look OK on high
                 * resolution monitors.
                 */
                cx = cy = (gpsi->dmLogPixels / 8) + 1;
            }
            break;
    }

    pOem->cx = cx;
    pOem->cy = cy;

    return((cx > cxMax) ? cx : cxMax);
}


/***************************************************************************\
*
*  PackFrameControls
*
*  Given the dimensions that GetFrameControlMetrics has calculated, this
*  arranges all the system bitmaps to fit within a bitmap of the given width
*
\***************************************************************************/

int PackFrameControls(int cxMax, BOOL fRecord) {
    UINT    obi;
    int     cy = 0;
    int     x  = 0;
    int     y  = 0;


    POEMBITMAPINFO pOem = gpsi->oembmi;

    for (obi = 0; obi < OBI_COUNT; obi++, pOem++) {
        if (pOem->cx) {
            if ((x + pOem->cx) > cxMax) {
                y += cy;
                cy = 0;
                x = 0;
            }

            if (fRecord) {
                pOem->x = x;
                pOem->y = y;
            }

            if (cy < pOem->cy)
                cy = pOem->cy;

            x += pOem->cx;
        }
    }

    return(y + cy);
}


void DrawCaptionButtons(
    int          x,
    int          y
    )
{
    x += SYSMET(CXEDGE);
    y += SYSMET(CYEDGE);

    BitBltSysBmp(HDCBITS(), x, y, OBI_REDUCE);
    x += SYSMET(CXSIZE) - SYSMET(CXEDGE);
    BitBltSysBmp(HDCBITS(), x, y, OBI_ZOOM);
    x += SYSMET(CXSIZE);
    BitBltSysBmp(HDCBITS(), x, y, OBI_CLOSE);
    x += SYSMET(CXSIZE);
    BitBltSysBmp(HDCBITS(), x, y, OBI_HELP);
}

/***************************************************************************\
* CreateCaptionStrip
*
*
\***************************************************************************/
HBITMAP CreateCaptionStrip(VOID)
{
    HBITMAP hbm;

    hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen,
                                    SYSMET(CXVIRTUALSCREEN),
                                    (SYSMET(CYCAPTION) - 1) * 2);

    if (hbm)
        GreSetBitmapOwner(hbm, OBJECT_OWNER_PUBLIC);

    return hbm;
}

/***************************************************************************\
*
*  CreateBitmapStrip
*
*  This routine sets up either the color or monochrome strip bitmap -- a
*  large horizontal bitmap which contains all of the system bitmaps.  By
*  having all of these bitmaps in one long bitmap, we can have that one
*  bitmap always selected in, speeding up paint time by not having to do
*  a SelectBitmap() everytime we need to Blt one of the system bitmaps.
*
\***************************************************************************/

BOOL CreateBitmapStrip(VOID)
{
    int     cxBmp = 0;
    int     cyBmp = 0;
    int     iCache = 0;
    int     cy[5];
    HBITMAP hOldBitmap;
    HBITMAP hNewBmp;
    UINT    iType;
    RECT    rc;
    UINT    wBmpType;
    UINT    wBmpStyle;
    POEMBITMAPINFO  pOem;

    /*
     * Each OBI_ must have an entry in sysBmpStyles
     */
    UserAssert(OBI_COUNT == sizeof(sysBmpStyles) / sizeof(*sysBmpStyles));
    UserAssert(OBI_COUNT == sizeof(gpsi->oembmi) / sizeof(*(gpsi->oembmi)));

    /*
     * load all the bitmap dimensions into the OEMBITMAPINFO array oemInfo.bm
     */
    for (iType = 0; iType < OBI_COUNT; iType++)
        cxBmp = GetFrameControlMetrics(iType, cxBmp);

    for (iType = 0; iType < 5; iType++)
        cy[iType] = PackFrameControls(cxBmp * (iType + 1), FALSE) * (iType + 1);

    cyBmp = min(cy[0], min(cy[1], min(cy[2], min(cy[3], cy[4]))));
    for (iType = 0; cyBmp != cy[iType]; iType++);

    cxBmp *= iType + 1;
    cyBmp = PackFrameControls(cxBmp, TRUE);

    hNewBmp = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cxBmp, cyBmp);

    if (hNewBmp == NULL) {
        RIPMSG0(RIP_WARNING, "CreateBitmapStrip: failed to create bitmap");
        return FALSE;
    }

    GreSetBitmapOwner(hNewBmp, OBJECT_OWNER_PUBLIC);

    /*
     * Select in Bitmap Strip -- then delete old one if it exists.
     */
    hOldBitmap = GreSelectBitmap(HDCBITS(), hNewBmp);

    if (ghbmBits) {
#if DBG
        /*
         * Don't RIP if we're out of memory.
         */
        if (hOldBitmap != NULL && ghbmBits != hOldBitmap) {
            RIPMSG0(RIP_WARNING, "ghbmBits != hOldBitmap");
        }
#endif
        GreDeleteObject(ghbmCaption);
        GreDeleteObject(hOldBitmap);
    }

    ghbmBits = hNewBmp;

    ghbmCaption = CreateCaptionStrip();

    if (ghbmCaption == NULL) {
        RIPMSG0(RIP_WARNING, "CreateBitmapStrip: failed to create bitmap for caption");
        return FALSE;
    }

    /*
     * Draw individual bitmaps into the strip bitmap and record the offsets.
     */
    for (pOem = gpsi->oembmi, iType = 0; iType < OBI_COUNT; iType++, pOem++) {
        if (!pOem->cx) {
            *pOem = gpsi->oembmi[pOem->cy];
        } else {
            rc.left = pOem->x;
            rc.top = pOem->y;
            rc.right = rc.left + pOem->cx;
            rc.bottom = rc.top + pOem->cy;

            wBmpType  = sysBmpStyles[iType][0];
            wBmpStyle = sysBmpStyles[iType][1];

            if (wBmpType == DFC_CACHE) {
                if (wBmpStyle & DFCS_CACHEBUTTONS) {
                    HBRUSH hbr;
                    if (TestALPHA(GRADIENTCAPTIONS)) {
                        hbr = (wBmpStyle & DFCS_INACTIVE) ? SYSHBR(GRADIENTINACTIVECAPTION) : SYSHBR(GRADIENTACTIVECAPTION);
                    } else {
                        hbr = (wBmpStyle & DFCS_INACTIVE) ? SYSHBR(INACTIVECAPTION) : SYSHBR(ACTIVECAPTION);
                    }
                    FillRect(HDCBITS(), &rc, hbr);
                    DrawCaptionButtons(rc.left, rc.top);
                } else if (!(wBmpStyle & DFCS_INACTIVE)) {
                    /*
                     * Setup Caption Cache Entry
                     */
                    UserAssert(iCache < CCACHEDCAPTIONS);
                    if (gcachedCaptions[iCache].spcursor) {
                        Unlock(&(gcachedCaptions[iCache].spcursor));
                    }
                    gcachedCaptions[iCache++].pOem = pOem;
                }
            } else {
                DrawFrameControl(HDCBITS(), &rc, wBmpType, wBmpStyle);
            }
        }
    }

    /*
     * Setup other frame metric dependent values.
     */
    SYSMET(CXMENUCHECK) = gpsi->oembmi[OBI_MENUCHECK].cx;
    SYSMET(CYMENUCHECK) = gpsi->oembmi[OBI_MENUCHECK].cy;

    return TRUE;
}

void
SetNCMetrics(
    LPNONCLIENTMETRICS lpnc)
{
    int nMin;

    /*
     * Scroll metrics
     */
    SYSMET(CXVSCROLL) = SYSMET(CYHSCROLL)   = (int) lpnc->iScrollWidth;
    SYSMET(CYVSCROLL) = SYSMET(CXHSCROLL)   = (int) lpnc->iScrollHeight;
    SYSMET(CYVTHUMB)  = SYSMET(CXHTHUMB)    = (int) lpnc->iScrollHeight;

    /*
     * Caption metrics
     */
    SYSMET(CXSIZE)            = (int) lpnc->iCaptionWidth;
    SYSMET(CYSIZE)            = (int) lpnc->iCaptionHeight;
    SYSMET(CYCAPTION)         = SYSMET(CYSIZE) + SYSMET(CYBORDER);

    /*
     * Keep small icon square?
     * ?? Should we allow rectangles?
     */
    SYSMET(CXSMICON)          = (SYSMET(CXSIZE) - SYSMET(CXEDGE)) & ~1;
    SYSMET(CYSMICON)          = (SYSMET(CYSIZE) - SYSMET(CYEDGE)) & ~1;
    nMin = min(SYSMET(CXSMICON), SYSMET(CYSMICON));
    SYSMET(CXSMICON)          = nMin;
    SYSMET(CYSMICON)          = nMin;

    /*
     * Small Caption metrics
     */
    SYSMET(CXSMSIZE)          = (int) lpnc->iSmCaptionWidth;
    SYSMET(CYSMSIZE)          = (int) lpnc->iSmCaptionHeight;
    SYSMET(CYSMCAPTION)       = SYSMET(CYSMSIZE) + SYSMET(CYBORDER);

    /*
     * Menu metrics
     */
    SYSMET(CXMENUSIZE)        = (int) lpnc->iMenuWidth;
    SYSMET(CYMENUSIZE)        = (int) lpnc->iMenuHeight;
    SYSMET(CYMENU)            = SYSMET(CYMENUSIZE) + SYSMET(CYBORDER);

    /*
     * Border metrics
     */
    gpsi->gclBorder = (int) lpnc->iBorderWidth;

    SYSMET(CXFRAME)           = SYSMET(CXEDGE) + (gpsi->gclBorder+1)*SYSMET(CXBORDER);
    SYSMET(CYFRAME)           = SYSMET(CYEDGE) + (gpsi->gclBorder+1)*SYSMET(CYBORDER);

    /*
     * Minimium tracking size is
     *      Across:  Space for small icon, 4 chars & space + 3 buttons + borders
     *      Down:    Space for caption + borders
     * Yes, we use CYSIZE.  This is because the width of any small icon
     * is the same as the height, and the height is CYSIZE.
     */
    SYSMET(CXMINTRACK)    = SYSMET(CYSIZE) + (gcxCaptionFontChar * 4) + 2 * SYSMET(CXEDGE) +
            (SYSMET(CXSIZE) * 3) + (SYSMET(CXSIZEFRAME) * 2);
    SYSMET(CYMINTRACK)    = SYSMET(CYCAPTION) + (SYSMET(CYSIZEFRAME) * 2);

    /*
     * Max track size
     * Yeah, max track is bigger than maximized.  The reason why is the DOS
     * box.  It has a normal sizing border plus the sunken edge around the
     * client.  We need to make this big enough to allow the dos box to grow.
     * When it hits its max size, it maximizes automatically.
     */
    SYSMET(CXMAXTRACK)    = SYSMET(CXVIRTUALSCREEN) + (2 * (SYSMET(CXSIZEFRAME) + SYSMET(CXEDGE)));
    SYSMET(CYMAXTRACK)    = SYSMET(CYVIRTUALSCREEN) + (2 * (SYSMET(CYSIZEFRAME) + SYSMET(CYEDGE)));

    SYSMET(CXMIN) = SYSMET(CXMINTRACK);
    SYSMET(CYMIN) = SYSMET(CYMINTRACK);

    SYSMET(CYMINIMIZED) = 2*SYSMET(CYFIXEDFRAME) + SYSMET(CYSIZE);

    /*
     * Desktop stuff--working area
     */
    bSetDevDragWidth(gpDispInfo->hDev,
                     gpsi->gclBorder + BORDER_EXTRA);

    SetDesktopMetrics();
}



/***************************************************************************\
*
*  CreateFontFromWinIni() -
*
*  If lplf is NULL, we do a first time, default initialization.
*  Otherwise, lplf is a pointer to the logfont we will use.
*
\***************************************************************************/
HFONT CreateFontFromWinIni(
    PUNICODE_STRING pProfileUserName,
    LPLOGFONTW      lplf,
    UINT            idFont)
{
    LOGFONTW lf;
    HFONT   hFont;

    if (lplf == NULL) {
        static CONST WCHAR szDefFont[] = TEXT("MS Shell Dlg");
        /*
         * Fill logfont w/ 0 so we can check if values were filled in.
         */
        lplf = &lf;
        RtlZeroMemory(&lf, sizeof(lf));
        lf.lfCharSet = gSystemCPCharSet;

        FastGetProfileValue(pProfileUserName,PMAP_METRICS, (LPWSTR)UIntToPtr( idFont ), NULL, (LPBYTE)&lf, sizeof(lf), 0);

        /*
         * Default font is MS Shell Dlg
         */
        if (! lf.lfFaceName[0]) {
            RtlCopyMemory(lf.lfFaceName, szDefFont, sizeof(szDefFont));
        }

        /*
         * Warning! these values are different then Win 95.  They did not have a True Type
         * font so they would round up when they asked for a 6 pt font.  We have to ask
         * for an 8 point font ICONFONT to be the same.
         */
        if (!lf.lfHeight) {
            switch (idFont) {
                case STR_SMCAPTIONFONT:
                case STR_MINFONT:
                case STR_ICONFONT:
                default:
                    lf.lfHeight = 8;
                    break;
            }
        }

        /*
         * We need to convert the point size properly.  GDI expects a
         * height in pixels, not points.
         */
        if (lf.lfHeight > 0) {
            lf.lfHeight = -MultDiv(lf.lfHeight, gpsi->dmLogPixels, 72);
        }

        if (! lf.lfWeight) {
            switch (idFont) {
                case STR_CAPTIONFONT:
                case STR_MINFONT:
                    lf.lfWeight = FW_BOLD;
                    break;

                default:
                    lf.lfWeight = FW_NORMAL;
                    break;
            }
        }

        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
    }


    hFont = GreCreateFontIndirectW(lplf);

    if (hFont) {
        LOGFONTW lfT;

        GreExtGetObjectW(hFont, sizeof(LOGFONTW), &lfT);
        if (lfT.lfHeight != lplf->lfHeight) {
            /*
             * Couldn't find a font with the height that we
             * wanted so use the system font instead.
             */
            GreDeleteObject(hFont);
            hFont = NULL;
        } else {
            GreMarkUndeletableFont(hFont);
            GreSetLFONTOwner((HLFONT)hFont, OBJECT_OWNER_PUBLIC);
        }
    }

    if (!hFont) {
        /*
         * We've tried to create the font from the app-supplied description.
         * If failure, return NULL so that we don't change the previous
         * font.
         */
        if (lplf)
            hFont = NULL;
        else
            hFont = ghFontSys;
    }

    return hFont;
}


/***************************************************************************\
*
\***************************************************************************/

BOOL UserSetFont(
    PUNICODE_STRING pProfileUserName,
    LPLOGFONTW      lplf,
    UINT            idFont,
    HFONT*          phfont)
{
    HFONT hNewFont;

    if (hNewFont = CreateFontFromWinIni(pProfileUserName, lplf, idFont)) {
        if (*phfont != NULL && *phfont != ghFontSys) {
            GreMarkDeletableFont(*phfont);
            GreDeleteObject(*phfont);
        }

        *phfont = hNewFont;
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
*
*  xxxSetNCFonts() -
*
*  Creates fonts to be used in the frame components:
*          Caption
*          Small caption
*          Menu
*          Minimized
*          Icon
*
*  01-21-98    [SamerA]   Renamed to xxxSetNCFonts since it may leave the
*                         critical section when a client LPK is installed.
\***************************************************************************/
BOOL xxxSetNCFonts(
    PUNICODE_STRING    pProfileUserName,
    LPNONCLIENTMETRICS lpnc)
{
    HFONT      hOldFont;
    TEXTMETRIC tm;
    LOGFONTW   lf;
    LPLOGFONTW lplf = (lpnc) ? &lf : 0;

    /*
     * Caption font
     */
    if (lplf) {
       *lplf = lpnc->lfCaptionFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_CAPTIONFONT, &gpsi->hCaptionFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for gpsi->hCaptionFont");
        return FALSE;
    }

    hOldFont = GreSelectFont(HDCBITS(), gpsi->hCaptionFont);
    gcxCaptionFontChar = GetCharDimensions(
            HDCBITS(), NULL, &gcyCaptionFontChar);

#ifdef LAME_BUTTON
    /*
     * Lame! button font
     */
    {
        LOGFONTW lfLame;
        WCHAR    szLameButtonKey[60];
        SIZE     btnSize;

        if (ghLameFont != NULL) {
            GreMarkDeletableFont(ghLameFont);
            GreDeleteObject(ghLameFont);
        }

        GreExtGetObjectW(gpsi->hCaptionFont, sizeof(LOGFONTW), &lfLame);

        lfLame.lfUnderline = 1;
        lfLame.lfWeight    = FW_THIN;

        ghLameFont = GreCreateFontIndirectW(&lfLame);
        if (ghLameFont == NULL) {
            RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghLameFont");
            return FALSE;
        } else {
            GreMarkUndeletableFont(ghLameFont);
            GreSetLFONTOwner((HLFONT)ghLameFont, OBJECT_OWNER_PUBLIC);
        }

        ServerLoadString(hModuleWin, STR_LAMEBUTTONTEXT, szLameButtonKey, ARRAY_SIZE(szLameButtonKey));

        FastGetProfileStringW(pProfileUserName,
                              PMAP_DESKTOP,
                              szLameButtonKey,
                              TEXT("Comments?"),
                              gpsi->gwszLame,
                              50,
                              0);

        GreSelectFont(HDCBITS(), ghLameFont);

        GreGetTextExtentW(HDCBITS(),
                          gpsi->gwszLame,
                          wcslen(gpsi->gwszLame),
                          &btnSize,
                          GGTE_WIN3_EXTENT);

        gpsi->ncxLame = btnSize.cx;
    }
#endif // LAME_BUTTON

    /*
     * Small caption font
     */
    if (lplf) {
       *lplf = lpnc->lfSmCaptionFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_SMCAPTIONFONT, &ghSmCaptionFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghSmCaptionFont");
        return FALSE;
    }

    GreSelectFont(HDCBITS(), ghSmCaptionFont);
    gcxSmCaptionFontChar = GetCharDimensions(
            HDCBITS(), NULL, &gcySmCaptionFontChar);

    /*
     * Menu font
     */
    if (lplf) {
       *lplf = lpnc->lfMenuFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_MENUFONT, &ghMenuFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghMenuFont");
        return FALSE;
    }

    /*
     * if ghMenuFont is selected in cached animation DC, select the new one.
     */
    if (gMenuState.hdcAni != NULL) {
        GreSelectFont(gMenuState.hdcAni, ghMenuFont);
    }

    GreSelectFont(HDCBITS(), ghMenuFont);
    gcxMenuFontChar = GetCharDimensions(
            HDCBITS(), &tm, &gcyMenuFontChar);
    gcxMenuFontOverhang = tm.tmOverhang;

    gcyMenuFontExternLeading = tm.tmExternalLeading;
    gcyMenuScrollArrow = gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE);
    gcyMenuFontAscent = tm.tmAscent;

    /*
     * We only use gcyMenuFontAscent in mndraw.c once, and in U.S. we
     * always add on CYBORDER!  So calculate gcyMenuFontAscent+CYBORDER
     * once only.
     * Legacy NT4: For Korean version, don't add it on; the underline would
     * be too low.
     * NT5: according to #254327, Korean version now sees underline is
     * too close to menu strings. Korean hack is pulled out so.
     */
    gcyMenuFontAscent += SYSMET(CYBORDER);

    /*
     * Default menu item font:  bolder version of menu font
     */

    /*
     * Create default menu font by bolding hMenuFont.  If this doesn't
     * work, then fall back to using simulation.
     */
    if (ghMenuFontDef != NULL && ghMenuFontDef != ghFontSys) {
        GreMarkDeletableFont(ghMenuFontDef);
        GreDeleteObject(ghMenuFontDef);
        ghMenuFontDef = NULL;
    }

    GreExtGetObjectW(ghMenuFont, sizeof(LOGFONTW), &lf);
    if (lf.lfWeight < FW_BOLD) {
        lf.lfWeight += 200;

        ghMenuFontDef = GreCreateFontIndirectW(&lf);
        if (ghMenuFontDef) {
            GreMarkUndeletableFont(ghMenuFontDef);
            GreSetLFONTOwner((HLFONT)ghMenuFontDef, OBJECT_OWNER_PUBLIC);
        }
    }

    /*
     * Status Bar font
     */
    if (lplf) {
       *lplf = lpnc->lfStatusFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_STATUSFONT, &ghStatusFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghStatusFont");
        return FALSE;
    }

    /*
     * Message Box font
     */
    if (lplf) {
       *lplf = lpnc->lfMessageFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_MESSAGEFONT, &gpsi->hMsgFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for gpsi->hMsgFont");
        return FALSE;
    }

    GreSelectFont(HDCBITS(), gpsi->hMsgFont);
    gpsi->cxMsgFontChar = GetCharDimensions(
            HDCBITS(), NULL, &gpsi->cyMsgFontChar);

    /*
     * Recalculate length of the widest MessageBox button
     * Make sure the width is no less than DU_BTNWIDTH dialog units MCostea #170582
     */
    gpsi->wMaxBtnSize = max((UINT)XPixFromXDU(DU_BTNWIDTH, gpsi->cxMsgFontChar),
                            xxxMB_FindLongestString(HDCBITS()));
    GreSelectFont(HDCBITS(), hOldFont);

    return TRUE;
}


BOOL
SetIconFonts(
    PUNICODE_STRING pProfileUserName,
    LPICONMETRICS   lpicon)
{
    LOGFONTW     lf;
    LPLOGFONTW   lplf = 0;

    if (lpicon) {
        lplf = &lf;
        lf = lpicon->lfFont;
    }

    return UserSetFont(pProfileUserName, lplf, STR_ICONFONT, &ghIconFont);
}

/***************************************************************************\
* GetWindowMetrics
*
* Retrieve the current NC metrics.
*
*
\***************************************************************************/

VOID GetWindowNCMetrics(
    LPNONCLIENTMETRICS lpnc)
{
    lpnc->cbSize           = sizeof(NONCLIENTMETRICS);
    lpnc->iBorderWidth     = gpsi->gclBorder;
    lpnc->iScrollWidth     = SYSMET(CXVSCROLL);
    lpnc->iScrollHeight    = SYSMET(CYVSCROLL);
    lpnc->iCaptionWidth    = SYSMET(CXSIZE);
    lpnc->iCaptionHeight   = SYSMET(CYSIZE);
    lpnc->iSmCaptionWidth  = SYSMET(CXSMSIZE);
    lpnc->iSmCaptionHeight = SYSMET(CYSMSIZE);
    lpnc->iMenuWidth       = SYSMET(CXMENUSIZE);
    lpnc->iMenuHeight      = SYSMET(CYMENUSIZE);

    /*
     * Get the font info.
     */
    GreExtGetObjectW(gpsi->hCaptionFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfCaptionFont));

    GreExtGetObjectW(ghSmCaptionFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfSmCaptionFont));

    GreExtGetObjectW(ghMenuFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfMenuFont));

    GreExtGetObjectW(ghStatusFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfStatusFont));

    GreExtGetObjectW(gpsi->hMsgFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfMessageFont));
}

/***************************************************************************\
*
*  xxxSetWindowNCMetrics() -
*
*  creates system fonts and bitmaps and sets the system metrics based on the
*  values of the given FRAMEMETRICS struct.  If NULL is passed in, the
*  default values (found in WIN.INI) are used instead.
*
*  01-21-98   [SamerA]  Renamed to xxxSetWindowNCMetrics since it may leave the
*                       critical section if an LPK is installed.
\***************************************************************************/

BOOL xxxSetWindowNCMetrics(
    PUNICODE_STRING    pProfileUserName,
    LPNONCLIENTMETRICS lpnc,
    BOOL               fSizeChange,
    int                clNewBorder)
{
    NONCLIENTMETRICS    nc;
    int                 cxEdge4;

    if (fSizeChange) {
        if (!xxxSetNCFonts(pProfileUserName, lpnc)) {
            RIPMSG0(RIP_WARNING, "xxxSetWindowNCMetrics failed in xxxSetNCFonts");
            return FALSE;
        }

        if (lpnc == NULL) {
            if (clNewBorder < 0)
                nc.iBorderWidth = MetricGetID(pProfileUserName,STR_BORDERWIDTH, 1);
            else
                nc.iBorderWidth = clNewBorder;

            nc.iScrollWidth     = MetricGetID(pProfileUserName,STR_SCROLLWIDTH, 16       );
            nc.iScrollHeight    = MetricGetID(pProfileUserName,STR_SCROLLHEIGHT, 16      );
            nc.iCaptionWidth    = MetricGetID(pProfileUserName,STR_CAPTIONWIDTH, 18      );
            nc.iCaptionHeight   = MetricGetID(pProfileUserName,STR_CAPTIONHEIGHT, 18     );
            nc.iSmCaptionWidth  = MetricGetID(pProfileUserName,STR_SMCAPTIONWIDTH, 13    );
            nc.iSmCaptionHeight = MetricGetID(pProfileUserName,STR_SMCAPTIONHEIGHT, 13   );
            nc.iMenuWidth       = MetricGetID(pProfileUserName,STR_MENUWIDTH, 18         );
            nc.iMenuHeight      = MetricGetID(pProfileUserName,STR_MENUHEIGHT, 18        );

            lpnc = &nc;
        }

        /*
         * SANITY CHECK for metric values
         */
        cxEdge4 = 4 * SYSMET(CXEDGE);

        /*
         * Border
         */
        lpnc->iBorderWidth = max(lpnc->iBorderWidth, 1);
        lpnc->iBorderWidth = min(lpnc->iBorderWidth, 50);

        /*
         * Scrollbar
         */
        lpnc->iScrollWidth  = max(lpnc->iScrollWidth,  cxEdge4);
        lpnc->iScrollHeight = max(lpnc->iScrollHeight, 4 * SYSMET(CYEDGE));

        /*
         * Caption -- Buttons must be wide enough to draw edges, and text
         * area must be tall enough to fit caption font with a border above
         * and below.  If we have to reset the caption height, should we
         * reset the button width as well?
         */
        lpnc->iCaptionWidth  = max(lpnc->iCaptionWidth,  cxEdge4);
        lpnc->iCaptionHeight = max(lpnc->iCaptionHeight, gcyCaptionFontChar + SYSMET(CYEDGE));

        /*
         * Small caption -- Buttons must be wide enough to draw edges, and
         * text area must be tall enough to fit small caption font with a
         * border above and below.  Again, if we have to reset the height,
         * reset the width as well?
         */
        lpnc->iSmCaptionWidth  = max(lpnc->iSmCaptionWidth,  cxEdge4);
        lpnc->iSmCaptionHeight = max(lpnc->iSmCaptionHeight, gcySmCaptionFontChar + SYSMET(CYEDGE));

        /*
         * Menu -- Buttons must be wide enough to draw edges, and text
         * area must be tall enough to fit menu font with underscore.
         */
        lpnc->iMenuWidth  = max(lpnc->iMenuWidth,  cxEdge4);
        lpnc->iMenuHeight = max(lpnc->iMenuHeight, gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE));

        /*
         * SET UP SYSTEM METRIC VALUES
         */
        SetNCMetrics(lpnc);
    }

    if (!CreateBitmapStrip()) {
        RIPMSG0(RIP_WARNING, "CreateBitmapStrip failed");
        return FALSE;
    }

    return TRUE;
}


VOID SetMinMetrics(
    PUNICODE_STRING    pProfileUserName,
    LPMINIMIZEDMETRICS lpmin)
{
    MINIMIZEDMETRICS min;

    if (!lpmin) {

        /*
         * Minimized
         */
        min.iWidth   = MetricGetID(pProfileUserName,STR_MINWIDTH,   154);
        min.iHorzGap = MetricGetID(pProfileUserName,STR_MINHORZGAP, 0);
        min.iVertGap = MetricGetID(pProfileUserName,STR_MINVERTGAP, 0);
        min.iArrange = MetricGetID(pProfileUserName,STR_MINARRANGE, ARW_BOTTOMLEFT | ARW_RIGHT);
        lpmin = &min;
    }

    /*
     * SANITY CHECK for metric values
     */

    /*
     * Minimized window -- Text area must be >= 0, as must gap between
     * windows horizontally and vertically.
     */
    lpmin->iWidth    = max(lpmin->iWidth, 0);
    lpmin->iHorzGap  = max(lpmin->iHorzGap, 0);
    lpmin->iVertGap  = max(lpmin->iVertGap, 0);
    lpmin->iArrange &= ARW_VALID;

    /*
     * Minimized size
     */
    SYSMET(CXMINIMIZED) = 2*SYSMET(CXFIXEDFRAME) + (int) lpmin->iWidth;
    SYSMET(CYMINIMIZED) = 2*SYSMET(CYFIXEDFRAME) + SYSMET(CYSIZE);

    SYSMET(CXMINSPACING) = SYSMET(CXMINIMIZED) + (int) lpmin->iHorzGap;
    SYSMET(CYMINSPACING) = SYSMET(CYMINIMIZED) + (int) lpmin->iVertGap;

    SYSMET(ARRANGE) = (int) lpmin->iArrange;
}

BOOL SetIconMetrics(
    PUNICODE_STRING pProfileUserName,
    LPICONMETRICS   lpicon)
{
    ICONMETRICS icon;

    if (!SetIconFonts(pProfileUserName,lpicon)) {
        RIPMSG0(RIP_WARNING, "SetIconMetrics failed in SetIconFonts");
        return FALSE;
    }

    if (!lpicon) {

        icon.iTitleWrap   = MetricGetID(pProfileUserName,
                STR_ICONTITLEWRAP, TRUE);

        icon.iHorzSpacing = MetricGetID(pProfileUserName,
                STR_ICONHORZSPACING,
                (GreGetDeviceCaps(HDCBITS(), LOGPIXELSX) * 75) / 96);

        icon.iVertSpacing = MetricGetID(pProfileUserName,
                STR_ICONVERTSPACING,
                (GreGetDeviceCaps(HDCBITS(), LOGPIXELSY) * 75) / 96);

        lpicon = &icon;
    }

    /*
     * SANITY CHECK for metric values
     */
    lpicon->iHorzSpacing = max(lpicon->iHorzSpacing, (int)SYSMET(CXICON));
    lpicon->iVertSpacing = max(lpicon->iVertSpacing, (int)SYSMET(CYICON));

    SYSMET(CXICONSPACING) = (int) lpicon->iHorzSpacing;
    SYSMET(CYICONSPACING) = (int) lpicon->iVertSpacing;
    SET_OR_CLEAR_PUDF(PUDF_ICONTITLEWRAP, lpicon->iTitleWrap);

    return TRUE;
}

/***************************************************************************\
* xxxMB_FindLongestString
*
* History:
* 10-23-90 DarrinM      Ported from Win 3.0 sources.
* 01-21-98 SamerA       Renamed to xxx since it may leave the crit sec if
*                       a client LPK is installed.
\***************************************************************************/

UINT xxxMB_FindLongestString(HDC hdc)
{
    UINT wRetVal;
    int i, iMaxLen = 0, iNewMaxLen;
    LPWSTR pszCurStr, szMaxStr;
    SIZE sizeOneChar;
    SIZE sizeMaxStr;
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    /*
     * Be sure that MBStrings are already loaded.
     */
    UserAssert(gpsi->MBStrings[0].szName[0] != TEXT('\0'));

    /*
     * We are assuming that the longest string is the widest one,
     * which is not always true.
     * What we really have to do is call PSMGetTextExtent for each string
     * and get the max width.
     * This behavior get rectified by workaround for bug #170582
     * in CheckMsgFontDimensions(). Mhamid.
     */


    for (i = 0; i < MAX_SEB_STYLES; i++) {
        pszCurStr = GETGPSIMBPSTR(i);
        if ((iNewMaxLen = wcslen(pszCurStr)) > iMaxLen) {
            iMaxLen = iNewMaxLen;
            szMaxStr = pszCurStr;
        }
    }

    /*
     * Find the longest string
     */
    if (CALL_LPK(ptiCurrent)) {
        xxxClientGetTextExtentPointW(hdc, (PWSTR)szOneChar, 1, &sizeOneChar);
    } else {
        GreGetTextExtentW(hdc, (PWSTR)szOneChar, 1, &sizeOneChar, GGTE_WIN3_EXTENT);
    }
    xxxPSMGetTextExtent(hdc, szMaxStr, iMaxLen, &sizeMaxStr);
    wRetVal = (UINT)(sizeMaxStr.cx + (sizeOneChar.cx * 2));

    return wRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\hooks.c ===
/****************************** Module Header ******************************\
* Module Name: hooks.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the user hook APIs and support routines.
*
* History:
* 01-28-91 DavidPe      Created.
* 08 Feb 1992 IanJa     Unicode/ANSI aware & neutral
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * This table is used to determine whether a particular hook
 * can be set for the system or a task, and other hook-ID specific things.
 */
#define HKF_SYSTEM          0x01
#define HKF_TASK            0x02
#define HKF_JOURNAL         0x04    // JOURNAL the mouse on set
#define HKF_NZRET           0x08    // Always return NZ hook for <=3.0 compatibility
#define HKF_INTERSENDABLE   0x10    // OK to call hookproc in context of hooking thread
#define HKF_LOWLEVEL        0x20    // Low level hook

CONST int ampiHookError[CWINHOOKS] = {
    0,                                   // WH_MSGFILTER (-1)
    0,                                   // WH_JOURNALRECORD 0
    -1,                                  // WH_JOURNALPLAYBACK 1
    0,                                   // WH_KEYBOARD 2
    0,                                   // WH_GETMESSAGE 3
    0,                                   // WH_CALLWNDPROC 4
    0,                                   // WH_CBT 5
    0,                                   // WH_SYSMSGFILTER 6
    0,                                   // WH_MOUSE 7
    0,                                   // WH_HARDWARE 8
    0,                                   // WH_DEBUG 9
    0,                                   // WH_SHELL 10
    0,                                   // WH_FOREGROUNDIDLE 11
    0,                                   // WH_CALLWNDPROCRET 12
    0,                                   // WH_KEYBOARD_LL 13
    0                                    // WH_MOUSE_LL 14
#ifdef REDIRECTION
   ,0                                    // WH_HITTEST
#endif // REDIRECTION
};

CONST BYTE abHookFlags[CWINHOOKS] = {
    HKF_SYSTEM | HKF_TASK | HKF_NZRET                       , // WH_MSGFILTER (-1)
    HKF_SYSTEM | HKF_JOURNAL          | HKF_INTERSENDABLE   , // WH_JOURNALRECORD 0
    HKF_SYSTEM | HKF_JOURNAL          | HKF_INTERSENDABLE   , // WH_JOURNALPLAYBACK 1
    HKF_SYSTEM | HKF_TASK | HKF_NZRET | HKF_INTERSENDABLE   , // WH_KEYBOARD 2
    HKF_SYSTEM | HKF_TASK                                   , // WH_GETMESSAGE 3
    HKF_SYSTEM | HKF_TASK                                   , // WH_CALLWNDPROC 4
    HKF_SYSTEM | HKF_TASK                                   , // WH_CBT 5
    HKF_SYSTEM                                              , // WH_SYSMSGFILTER 6
    HKF_SYSTEM | HKF_TASK             | HKF_INTERSENDABLE   , // WH_MOUSE 7
    HKF_SYSTEM | HKF_TASK                                   , // WH_HARDWARE 8
    HKF_SYSTEM | HKF_TASK                                   , // WH_DEBUG 9
    HKF_SYSTEM | HKF_TASK                                   , // WH_SHELL 10
    HKF_SYSTEM | HKF_TASK                                   , // WH_FOREGROUNDIDLE 11
    HKF_SYSTEM | HKF_TASK                                   , // WH_CALLWNDPROCRET 12
    HKF_SYSTEM | HKF_LOWLEVEL         | HKF_INTERSENDABLE   , // WH_KEYBOARD_LL 13
    HKF_SYSTEM | HKF_LOWLEVEL         | HKF_INTERSENDABLE     // WH_MOUSE_LL 14

#ifdef REDIRECTION
   ,HKF_SYSTEM | HKF_LOWLEVEL         | HKF_INTERSENDABLE     // WH_HITTEST 15
#endif // REDIRECTION
};


/*
 * HACK (hiroyama) see xxxCallJournalPlaybackHook()
 * Optimization: faster determination whether the message is one of
 * WM_[SYS][DEAD]CHAR.
 * Argument (msg) requires to be one of keyboard messages. Range check
 * should be done before calling IS_CHAR_MSG() macro.
 *
 * (i.e. WM_KEYFIRST <= msg < WM_KEYLAST)
 *
 * We expect bit 0x02 of all WM_*CHAR messages to be set.
 * and bit 0x02 of all WM_*KEY* messages to be clear
 *
 * WM_KEYDOWN       0x100   000
 * WM_KEYUP         0x101   001
 * WM_CHAR          0x102   010
 * WM_DEADCHAR      0x103   011
 *
 * WM_SYSKEYDOWN    0x104   100
 * WM_SYSKEYUP      0x105   101
 * WM_SYSCHAR       0x106   110
 * WM_SYSDEADCHAR   0x107   111
 *
 */

  /*
   */
#if (WM_KEYFIRST != 0x100) ||           \
    (WM_KEYLAST != 0x109) ||            \
    (WM_KEYLAST != WM_UNICHAR) ||       \
    (WM_KEYDOWN & 0x2) ||               \
    (WM_KEYUP & 0x2) ||                 \
    (WM_SYSKEYDOWN & 0x2) ||            \
    (WM_SYSKEYUP & 0x2) ||              \
    !(WM_CHAR & 0x02) ||                \
    !(WM_DEADCHAR & 0x02) ||            \
    !(WM_SYSCHAR & 0x02) ||             \
    !(WM_SYSDEADCHAR & 0x02)
#error "unexpected value in keyboard messages."
#endif


#if DBG

BOOL IsCharMsg(UINT msg)
{
    UserAssert(msg >= WM_KEYFIRST && msg < WM_KEYLAST);

    return msg & 0x02;
}

#define IS_CHAR_MSG(msg)    IsCharMsg(msg)

#else

#define IS_CHAR_MSG(msg)    ((msg) & 0x02)

#endif




void UnlinkHook(PHOOK phkFree);
/***************************************************************************\
* DbgValidateThisHook
*
* Validates a hook structure and returns the start of its chain.
*
* History:
* 03-25-97  GerardoB    Created
\***************************************************************************/
#if DBG
PHOOK * DbgValidateThisHook (PHOOK phk, int iType, PTHREADINFO ptiHooked)
{
    CheckCritIn();
    /*
     * No bogus flags
     */
    UserAssert(!(phk->flags & ~HF_DBGUSED));
    /*
     * Type
     */
    UserAssert(phk->iHook == iType);
    /*
     * HF_GLOBAL & ptiHooked. return the start of its hook chain.
     */
    if (phk->flags & HF_GLOBAL) {
        UserAssert(phk->ptiHooked == NULL);
        if (phk->rpdesk != NULL) {
            UserAssert(GETPTI(phk) == gptiRit);
            return &phk->rpdesk->pDeskInfo->aphkStart[iType + 1];
        } else {
            return &GETPTI(phk)->pDeskInfo->aphkStart[iType + 1];
        }
    } else {
        UserAssert((phk->ptiHooked == ptiHooked)
                    || (abHookFlags[iType + 1] & HKF_INTERSENDABLE));

        return &(phk->ptiHooked->aphkStart[iType + 1]);
    }
}
/***************************************************************************\
* DbgValidatefsHook
*
* Make sure that the fsHook bit masks are in sync. If the bits
*  are out of sync, some hook must have the HF_INCHECKWHF flag
*  (this means the bits are being adjusted right now)
*
* History:
* 05-20-97  GerardoB    Extracted from PhkFirst*Valid
\***************************************************************************/
void DbgValidatefsHook(PHOOK phk, int nFilterType, PTHREADINFO pti, BOOL fGlobal)
{
    CheckCritIn();
    /*
     * If no pti is provided, figure out what it should be.
     *  phk is expected to be NULL.
     */
    if (pti == NULL) {
        fGlobal = (phk->flags & HF_GLOBAL);
        if (fGlobal) {
            pti = GETPTI(phk);
        } else {
            pti = phk->ptiHooked;
            UserAssert(pti != NULL);
        }
    }

    if (fGlobal) {
        if ((phk != NULL) ^ IsGlobalHooked(pti, WHF_FROM_WH(nFilterType))) {
            PHOOK phkTemp = pti->pDeskInfo->aphkStart[nFilterType + 1];
            while ((phkTemp != NULL) && !(phkTemp->flags & HF_INCHECKWHF)) {
                phkTemp = phkTemp->phkNext;
            }
            UserAssert(phkTemp != NULL);
        }
    } else {
        if ((phk != NULL) ^ IsHooked(pti, WHF_FROM_WH(nFilterType))) {
            PHOOK phkTemp = pti->aphkStart[nFilterType + 1];
            while ((phkTemp != NULL) && !(phkTemp->flags & HF_INCHECKWHF)) {
                phkTemp = phkTemp->phkNext;
            }
            if (phkTemp == NULL) {
                phkTemp = pti->pDeskInfo->aphkStart[nFilterType + 1];
                while ((phkTemp != NULL) && !(phkTemp->flags & HF_INCHECKWHF)) {
                    phkTemp = phkTemp->phkNext;
                }
            }
            UserAssert(phkTemp != NULL);
        }
    }
}
/***************************************************************************\
* DbgValidateHooks
*
* This functions expects valid (not destroyed) and properly linked.
* History:
* 03-25-97  GerardoB    Created
\***************************************************************************/
void DbgValidateHooks (PHOOK phk, int iType)
{
    PHOOK *pphkStart, *pphkNext;
    if (phk == NULL) {
        return;
    }
    /*
     * It shouldn't be destroyed
     */
    UserAssert(!(phk->flags & (HF_DESTROYED | HF_FREED)));
    /*
     * Validate fsHooks
     */
    DbgValidatefsHook(phk, iType, NULL, FALSE);
    /*
     * Validate this hook and get the beginning of the hook chain
     */
    pphkStart = DbgValidateThisHook(phk, iType, phk->ptiHooked);
    /*
     * There must be at least one hook in the chain
     */
    UserAssert(*pphkStart != NULL);
    /*
     * Validate the link.
     * And while your're at it, validate all hooks!
     */
    pphkNext = pphkStart;
    while ((*pphkNext != phk) && (*pphkNext != NULL)) {
       UserAssert(pphkStart == DbgValidateThisHook(*pphkNext, iType, phk->ptiHooked));
       pphkNext = &(*pphkNext)->phkNext;
    }
    /*
     * Verify that we found it.
     */
    UserAssert(*pphkNext == phk);
    /*
     * Walk until the end of the chain
     */
    while (*pphkNext != NULL) {
       UserAssert(pphkStart == DbgValidateThisHook(*pphkNext, iType, phk->ptiHooked));
       pphkNext = &(*pphkNext)->phkNext;
    }
}
#else
#define DbgValidatefsHook(phk, nFilterType, pti, fGlobal)
#endif /* DBG */
/***************************************************************************\
* zzzJournalAttach
*
* This attaches/detaches threads to one input queue so input is synchronized.
* Journalling requires this.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/

BOOL zzzJournalAttach(
    PTHREADINFO pti,
    BOOL fAttach)
{
    PTHREADINFO ptiT;
    PQ pq;
    PLIST_ENTRY pHead, pEntry;

    /*
     * If we're attaching, calculate the pqAttach for all threads journalling.
     * If we're unattaching, just call zzzReattachThreads() and it will calculate
     * the non-journalling queues to attach to.
     */
    if (fAttach) {
        if ((pq = AllocQueue(pti, NULL)) == NULL)
            return FALSE;

        pHead = &pti->rpdesk->PtiList;
        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
            ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

            /*
             * This is the Q to attach to for all threads that will do
             * journalling.
             */
            if (!(ptiT->TIF_flags & (TIF_DONTJOURNALATTACH | TIF_INCLEANUP))) {
                ptiT->pqAttach = pq;
                ptiT->pqAttach->cThreads++;
            }
        }
    }

    return zzzReattachThreads(fAttach);
}
/***************************************************************************\
* InterQueueMsgCleanup
*
* Walk gpsmsList looking for inter queue messages with a hung receiver;
*  if one is found and it's a message that would have been an async event or
*  intra queue if not journalling, then it cleans it up.
*
* While Journalling most threads are attached to the same queue. This causes
*  activation and input stuff to be synchronous; if a thread hangs or dies,
*  any other thread sending a message to the hung/dead thread will be
*  blocked for good.
* This is critical when the blocked thread is cssr; this can happen with
*  console windows or when some one requests a hard error box, specially
*  during window activation.
*
* This function must be called when all queues have been detached (unless previously attached),
*  so we can take care of hung/dead receivers with pending SMSs.
*
* 03-28-96 GerardoB     Created
\***************************************************************************/
void InterQueueMsgCleanup (DWORD dwTimeFromLastRead)
{
    PSMS *ppsms;
    PSMS psmsNext;

    CheckCritIn();

    /*
     * Walk  gpsmsList
     */
    for (ppsms = &gpsmsList; *ppsms; ) {
        psmsNext = (*ppsms)->psmsNext;
        /*
         * If this is an inter queue message
         */
        if (((*ppsms)->ptiSender != NULL)
                && ((*ppsms)->ptiReceiver != NULL)
                && ((*ppsms)->ptiSender->pq != (*ppsms)->ptiReceiver->pq)) {
            /*
             * If the receiver has been hung for a while
             */
            if (FHungApp ((*ppsms)->ptiReceiver, dwTimeFromLastRead)) {

                switch ((*ppsms)->message) {
                    /*
                     * Activation messages
                     */
                    case WM_NCACTIVATE:
                    case WM_ACTIVATEAPP:
                    case WM_ACTIVATE:
                    case WM_SETFOCUS:
                    case WM_KILLFOCUS:
                    case WM_QUERYNEWPALETTE:
                    /*
                     * Sent to spwndFocus, which now can be in a different queue
                     */
                    case WM_INPUTLANGCHANGE:
                        RIPMSG3 (RIP_WARNING, "InterQueueMsgCleanup: ptiSender:%#p ptiReceiver:%#p message:%#lx",
                                    (*ppsms)->ptiSender, (*ppsms)->ptiReceiver, (*ppsms)->message);
                        ReceiverDied(*ppsms, ppsms);
                        break;

                } /* switch */

            } /* If hung receiver */

        } /* If inter queue message */

         /*
          * If the message was not unlinked, go to the next one.
          */
        if (*ppsms != psmsNext)
            ppsms = &(*ppsms)->psmsNext;

    } /* for */
}
/***************************************************************************\
* zzzCancelJournalling
*
* Journalling is cancelled with control-escape is pressed, or when the desktop
* is switched.
*
* 01-27-93 ScottLu      Created.
\***************************************************************************/

void zzzCancelJournalling(void)
{
    PTHREADINFO ptiCancelJournal;
    PHOOK phook;
    PHOOK phookNext;

    /*
     * Mouse buttons sometimes get stuck down due to hardware glitches,
     * usually due to input concentrator switchboxes or faulty serial
     * mouse COM ports, so clear the global button state here just in case,
     * otherwise we may not be able to change focus with the mouse.
     * Also do this in Alt-Tab processing.
     */
#if DBG
    if (gwMouseOwnerButton)
        RIPMSG1(RIP_WARNING,
                "gwMouseOwnerButton=%x, being cleared forcibly\n",
                gwMouseOwnerButton);
#endif
    gwMouseOwnerButton = 0;

    /*
     * Remove journal hooks. This'll cause threads to associate with
     * different queues.
     * DeferWinEventNotify() so we can traverse the phook list safely
     */
    DeferWinEventNotify();
    UserAssert(gptiRit->pDeskInfo == grpdeskRitInput->pDeskInfo);
    phook = PhkFirstGlobalValid(gptiRit, WH_JOURNALPLAYBACK);
    while (phook != NULL) {
        ptiCancelJournal = phook->head.pti;

        if (ptiCancelJournal != NULL) {
            /*
             * Let the thread that set the journal hook know this is happening.
             */
            _PostThreadMessage(ptiCancelJournal, WM_CANCELJOURNAL, 0, 0);

            /*
             * If there was an app waiting for a response back from the journal
             * application, cancel that request so the app can continue running
             * (for example, we don't want winlogon or console to wait for an
             * app that may be hung!)
             */
            SendMsgCleanup(ptiCancelJournal);
        }

        phookNext = PhkNextValid(phook);
        zzzUnhookWindowsHookEx(phook);        // May free phook memory
        phook = phookNext;
    }
    zzzEndDeferWinEventNotify();

    /*
     * DeferWinEventNotify() so we can traverse the phook list safely
     */
    DeferWinEventNotify();
    UserAssert(gptiRit->pDeskInfo == grpdeskRitInput->pDeskInfo);
    phook = PhkFirstGlobalValid(gptiRit, WH_JOURNALRECORD);
    while (phook != NULL) {
        ptiCancelJournal = phook->head.pti;

        if (ptiCancelJournal != NULL) {
            /*
             * Let the thread that set the journal hook know this is happening.
             */
            _PostThreadMessage(ptiCancelJournal, WM_CANCELJOURNAL, 0, 0);

            /*
             * If there was an app waiting for a response back from the journal
             * application, cancel that request so the app can continue running
             * (for example, we don't want winlogon or console to wait for an
             * app that may be hung!)
             */
            SendMsgCleanup(ptiCancelJournal);
        }

        phookNext = PhkNextValid(phook);
        zzzUnhookWindowsHookEx(phook);        // May free phook memory
        phook = phookNext;
    }
    zzzEndDeferWinEventNotify();


    /*
     * Make sure journalling ssync mode didn't hose any one
     */
    InterQueueMsgCleanup(CMSWAITTOKILLTIMEOUT);

    /*
     * Unlock SetForegroundWindow (if locked)
     */
    gppiLockSFW = NULL;

    /*
     * NT5's last minute hack for evil applications, who disables the desktop window
     * (perhaps by accidents though) leaving the system pretty unusable.
     * See Raid #423704.
     */
    if (grpdeskRitInput && grpdeskRitInput->pDeskInfo) {
        PWND pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;

        if (pwndDesktop && TestWF(pwndDesktop, WFDISABLED)) {
            ClrWF(pwndDesktop, WFDISABLED);
        }
    }
}

/***************************************************************************\
* zzzSetWindowsHookAW (API)
*
* This is the Win32 version of the SetWindowsHook() call.  It has the
* same characteristics as far as return values, but only sets 'local'
* hooks.  This is because we weren't provided a DLL we can load into
* other processes.  Because of this WH_SYSMSGFILTER is no longer a
* valid hook.  Apps will either need to call with WH_MSGFILTER or call
* the new API SetWindowsHookEx().  Essentially this API is obsolete and
* everyone should call SetWindowsHookEx().
*
* History:
* 10-Feb-1991 DavidPe       Created.
* 30-Jan-1992 IanJa         Added bAnsi parameter
\***************************************************************************/

PROC zzzSetWindowsHookAW(
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags)
{
    PHOOK phk;

    phk = zzzSetWindowsHookEx(NULL, NULL, PtiCurrent(),
            nFilterType, pfnFilterProc, dwFlags);

    /*
     * If we get an error from zzzSetWindowsHookEx() then we return
     * -1 to be compatible with older version of Windows.
     */
    if (phk == NULL) {
        return (PROC)-1;
    }

    /*
     * Handle the backwards compatibility return value cases for
     * SetWindowsHook.  If this was the first hook in the chain,
     * then return NULL, else return something non-zero.  HKF_NZRET
     * is a special case where SetWindowsHook would always return
     * something because there was a default hook installed.  Some
     * apps relied on a non-zero return value in those cases.
     */
    if ((phk->phkNext != NULL) || (abHookFlags[nFilterType + 1] & HKF_NZRET)) {
        return (PROC)phk;
    }

    return NULL;
}


/***************************************************************************\
* zzzSetWindowsHookEx
*
* SetWindowsHookEx() is the updated version of SetWindowsHook().  It allows
* applications to set hooks on specific threads or throughout the entire
* system.  The function returns a hook handle to the application if
* successful and NULL if a failure occured.
*
* History:
* 28-Jan-1991 DavidPe      Created.
* 15-May-1991 ScottLu      Changed to work client/server.
* 30-Jan-1992 IanJa        Added bAnsi parameter
\***************************************************************************/

PHOOK zzzSetWindowsHookEx(
    HANDLE hmod,
    PUNICODE_STRING pstrLib,
    PTHREADINFO ptiThread,
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags)
{
    ACCESS_MASK amDesired;
    PHOOK       phkNew;
    TL          tlphkNew;
    PHOOK       *pphkStart;
    PTHREADINFO ptiCurrent;

    /*
     * Check to see if filter type is valid.
     */
    if (nFilterType < WH_MIN || nFilterType > WH_MAX) {
        RIPERR1(ERROR_INVALID_HOOK_FILTER,
                RIP_WARNING,
                "Invalid hook type 0x%x",
                nFilterType);
        return NULL;
    }

    /*
     * Check to see if filter proc is valid.
     */
    if (pfnFilterProc == NULL) {
        RIPERR0(ERROR_INVALID_FILTER_PROC,
                RIP_WARNING,
                "NULL hook callback");
        return NULL;
    }

    ptiCurrent = PtiCurrent();

    if (ptiThread == NULL) {
        /*
         * Is the app trying to set a global hook without a library?
         * If so return an error.
         */
         if (hmod == NULL) {
             RIPERR0(ERROR_HOOK_NEEDS_HMOD,
                     RIP_WARNING,
                     "Global hook requires a non-NULL hmod");
             return NULL;
         }
    } else {
        /*
         * Is the app trying to set a local hook that is global-only?
         * If so return an error.
         */
        if (!(abHookFlags[nFilterType + 1] & HKF_TASK)) {
            RIPERR1(ERROR_GLOBAL_ONLY_HOOK,
                    RIP_WARNING,
                    "Hook type 0x%x must be global",
                    nFilterType);
            return NULL;
        }

        /*
         * Can't hook outside our own desktop.
         */
        if (ptiThread->rpdesk != ptiCurrent->rpdesk) {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_WARNING,
                    "Access denied to desktop in zzzSetWindowsHookEx - can't hook other desktops");

            return NULL;
        }

        if (ptiCurrent->ppi != ptiThread->ppi) {
            /*
             * Is the app trying to set hook in another process without a library?
             * If so return an error.
             */
            if (hmod == NULL) {
                RIPERR0(ERROR_HOOK_NEEDS_HMOD,
                        RIP_WARNING,
                        "Cross-thread hook needs a non-NULL hmod");
                return NULL;
            }

            /*
             * Is the app hooking another user without access?
             * If so return an error. Note that this check is done
             * for global hooks every time the hook is called.
             */
            if ((!RtlEqualLuid(&ptiThread->ppi->luidSession,
                               &ptiCurrent->ppi->luidSession)) &&
                        !(ptiThread->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK)) {

                RIPERR0(ERROR_ACCESS_DENIED,
                        RIP_WARNING,
                        "Access denied to other user in zzzSetWindowsHookEx");

                return NULL;
            }

            if ((ptiThread->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)) &&
                    !(abHookFlags[nFilterType + 1] & HKF_INTERSENDABLE)) {

                /*
                 * Can't hook console or GUI system thread if inter-thread
                 * calling isn't implemented for this hook type.
                 */
                 RIPERR1(ERROR_HOOK_TYPE_NOT_ALLOWED,
                         RIP_WARNING,
                         "nFilterType (%ld) not allowed in zzzSetWindowsHookEx",
                         nFilterType);

                 return NULL;
            }
        }
    }

    /*
     * Check if this thread has access to hook its desktop.
     */
    switch( nFilterType ) {
    case WH_JOURNALRECORD:
        amDesired = DESKTOP_JOURNALRECORD;
        break;

    case WH_JOURNALPLAYBACK:
        amDesired = DESKTOP_JOURNALPLAYBACK;
        break;

    default:
        amDesired = DESKTOP_HOOKCONTROL;
        break;
    }

    /*
     * The console input thread *must* be allowed to set this hook, even if
     * the account it's impersonating doesn't have hook access to the desktop
     * in question.
     */
    if (!RtlAreAllAccessesGranted(ptiCurrent->amdesk, amDesired) &&
        !(ISCSRSS() && nFilterType == WH_MSGFILTER)) {

        UserAssert(!ISCSRSS() ||
                       (PsGetCurrentThreadId() ==
                            UlongToHandle(ptiCurrent->rpdesk->dwConsoleThreadId)));

        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied to desktop in zzzSetWindowsHookEx");

        return NULL;
    }

    if (amDesired != DESKTOP_HOOKCONTROL &&
        (ptiCurrent->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO)) {
        RIPERR0(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION,
                RIP_WARNING,
                "Journal hooks invalid on a desktop belonging to a non-interactive WindowStation.");

        return NULL;
    }

    /*
     * Allocate the new HOOK structure.
     */
    phkNew = HMAllocObject(ptiCurrent, ptiCurrent->rpdesk, TYPE_HOOK, sizeof(HOOK));
    if (phkNew == NULL) {
        return NULL;
    }

    /*
     * If a DLL is required for this hook, register the library with
     * the library management routines so we can assure it's loaded
     * into all the processes necessary.
     */
    phkNew->ihmod = -1;
    if (hmod != NULL) {

        phkNew->ihmod = GetHmodTableIndex(pstrLib);

        if (phkNew->ihmod == -1) {
            RIPERR2(ERROR_MOD_NOT_FOUND,
                    RIP_WARNING,
                    "Couldn't load DLL %.*ws",
                    pstrLib->Length,
                    pstrLib->Buffer);
            HMFreeObject((PVOID)phkNew);
            return NULL;
        }

        /*
         * Add a dependency on this module - meaning, increment a count
         * that simply counts the number of hooks set into this module.
         */
        if (phkNew->ihmod >= 0) {
            AddHmodDependency(phkNew->ihmod);
        }
    }

    /*
     * Depending on whether we're setting a global or local hook,
     * get the start of the appropriate linked-list of HOOKs.  Also
     * set the HF_GLOBAL flag if it's a global hook.
     */
    if (ptiThread != NULL) {
        pphkStart = &ptiThread->aphkStart[nFilterType + 1];

        /*
         * Set the WHF_* in the THREADINFO so we know it's hooked.
         */
        ptiThread->fsHooks |= WHF_FROM_WH(nFilterType);

        /*
         * Set the flags in the thread's TEB
         */
        if (ptiThread->pClientInfo) {
            BOOL fAttached;

            /*
             * If the thread being hooked is in another process, attach
             * to that process so that we can access its ClientInfo.
             */
            if (ptiThread->ppi != ptiCurrent->ppi) {
                KeAttachProcess(PsGetProcessPcb(ptiThread->ppi->Process));
                fAttached = TRUE;
            } else
                fAttached = FALSE;
            try {
                ptiThread->pClientInfo->fsHooks = ptiThread->fsHooks;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                /*
                 * Worst case scenario is the the cleint side will
                 * be out of sync of which hooks are installed
                 */
            }
            if (fAttached) {
                KeDetachProcess();
            }
        }

        /*
         * Remember which thread we're hooking.
         */
        phkNew->ptiHooked = ptiThread;

    } else {
        pphkStart = &ptiCurrent->pDeskInfo->aphkStart[nFilterType + 1];
        phkNew->flags |= HF_GLOBAL;

        /*
         * Set the WHF_* in the SERVERINFO so we know it's hooked.
         */
        ptiCurrent->pDeskInfo->fsHooks |= WHF_FROM_WH(nFilterType);

        phkNew->ptiHooked = NULL;
    }

    /*
     * Does the hook function expect ANSI or Unicode text?
     */
    phkNew->flags |= (dwFlags & HF_ANSI);

    /*
     * Initialize the HOOK structure.  Unreferenced parameters are assumed
     * to be initialized to zero by LocalAlloc().
     */
    phkNew->iHook = nFilterType;

    /*
     * Libraries are loaded at different linear addresses in different
     * process contexts.  For this reason, we need to convert the filter
     * proc address into an offset while setting the hook, and then convert
     * it back to a real per-process function pointer when calling a
     * hook.  Do this by subtracting the 'hmod' (which is a pointer to the
     * linear and contiguous .exe header) from the function index.
     */
    phkNew->offPfn = ((ULONG_PTR)pfnFilterProc) - ((ULONG_PTR)hmod);

#ifdef HOOKBATCH
    phkNew->cEventMessages = 0;
    phkNew->iCurrentEvent  = 0;
    phkNew->CacheTimeOut = 0;
    phkNew->aEventCache = NULL;
#endif //HOOKBATCH

    /*
     * Link this hook into the front of the hook-list.
     */
    phkNew->phkNext = *pphkStart;
    *pphkStart = phkNew;

    /*
     * If this is a journal hook, setup synchronized input processing
     * AFTER we set the hook - so this synchronization can be cancelled
     * with control-esc.
     */
    if (abHookFlags[nFilterType + 1] & HKF_JOURNAL) {
        /*
         * Attach everyone to us so journal-hook processing
         * will be synchronized.
         * No need to DeferWinEventNotify() here, since we lock phkNew.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, phkNew, &tlphkNew);
        if (!zzzJournalAttach(ptiCurrent, TRUE)) {
            RIPMSG1(RIP_WARNING, "zzzJournalAttach failed, so abort hook %#p", phkNew);
            if (ThreadUnlock(&tlphkNew) != NULL) {
                zzzUnhookWindowsHookEx(phkNew);
            }
            return NULL;
        }
        if ((phkNew = ThreadUnlock(&tlphkNew)) == NULL) {
            return NULL;
        }
    }

    UserAssert(phkNew != NULL);

    /*
     * Later 5.0 GerardoB: The old code just to check this but
     *  I think it's some left over stuff from server side days.
    .* Let's assert on it for a while
     * Also, I added the assertions in the else's below because I reorganized
     *  the code and want to make sure we don't change behavior
     */
    UserAssert(ptiCurrent->pEThread && PsGetThreadProcess(ptiCurrent->pEThread));

    /*
     * Can't allow a process that has set a global hook that works
     * on server-side winprocs to run at background priority! Bump
     * up it's dynamic priority and mark it so it doesn't get reset.
     */
    if ((phkNew->flags & HF_GLOBAL) &&
            (abHookFlags[nFilterType + 1] & HKF_INTERSENDABLE)) {

        ptiCurrent->TIF_flags |= TIF_GLOBALHOOKER;
        KeSetPriorityThread(PsGetThreadTcb(ptiCurrent->pEThread), LOW_REALTIME_PRIORITY-2);

        if (abHookFlags[nFilterType + 1] & HKF_JOURNAL) {
            ThreadLockAlwaysWithPti(ptiCurrent, phkNew, &tlphkNew);
            /*
             * If we're changing the journal hooks, jiggle the mouse.
             * This way the first event will always be a mouse move, which
             * will ensure that the cursor is set properly.
             */
            zzzSetFMouseMoved();
            phkNew = ThreadUnlock(&tlphkNew);
            /*
             * If setting a journal playback hook, this process is the input
             *  provider. This gives it the right to call SetForegroundWindow
             */
            if (nFilterType == WH_JOURNALPLAYBACK) {
                gppiInputProvider = ptiCurrent->ppi;
            }
        } else {
            UserAssert(nFilterType != WH_JOURNALPLAYBACK);
        }
    } else {
        UserAssert(!(abHookFlags[nFilterType + 1] & HKF_JOURNAL));
        UserAssert(nFilterType != WH_JOURNALPLAYBACK);
    }




    /*
     * Return pointer to our internal hook structure so we know
     * which hook to call next in CallNextHookEx().
     */
    DbgValidateHooks(phkNew, phkNew->iHook);
    return phkNew;
}


/***************************************************************************\
* xxxCallNextHookEx
*
* In the new world DefHookProc() is a bit deceptive since SetWindowsHook()
* isn't returning the actual address of the next hook to call, but instead
* a hook handle.  CallNextHookEx() is a slightly clearer picture of what's
* going on so apps don't get tempted to try and call the value we return.
*
* As a side note we don't actually use the hook handle passed in.  We keep
* track of which hooks is currently being called on a thread in the Q
* structure and use that.  This is because SetWindowsHook() will sometimes
* return NULL to be compatible with the way it used to work, but even though
* we may be dealing with the last 'local' hook, there may be further 'global'
* hooks we need to call.  PhkNext() is smart enough to jump over to the
* 'global' hook chain if it reaches the end of the 'local' hook chain.
*
* History:
* 01-30-91  DavidPe         Created.
\***************************************************************************/

LRESULT xxxCallNextHookEx(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL bAnsiHook;

    if (PtiCurrent()->sphkCurrent == NULL) {
        return 0;
    }

    return xxxCallHook2(PhkNextValid(PtiCurrent()->sphkCurrent), nCode, wParam, lParam, &bAnsiHook);
}


/***************************************************************************\
* CheckWHFBits
*
* This routine checks to see if any hooks for nFilterType exist, and clear
* the appropriate WHF_ in the THREADINFO and SERVERINFO.
*
* History:
* 08-17-92  DavidPe         Created.
\***************************************************************************/

VOID CheckWHFBits(
    PTHREADINFO pti,
    int nFilterType)
{
    BOOL fClearThreadBits;
    BOOL fClearDesktopBits;
    PHOOK phook;


    /*
     * Assume we're are going to clear local(thread) and
     *   global(desktop) bits.
     */
    fClearThreadBits = TRUE;
    fClearDesktopBits = TRUE;
    /*
     * Get the first valid hook for this thread
     */
    phook = PhkFirstValid(pti, nFilterType);
    if (phook != NULL) {
        /*
         * If it found a global hook, don't clear the desktop bits
         * (that would mean that there are no local(thread) hooks
         *  so we fall through to clear the thread bits)
         */
        if (phook->flags & HF_GLOBAL) {
            fClearDesktopBits = FALSE;
        } else {
            /*
             * It found a thread hook so don't clear the thread bits
             */
            fClearThreadBits = FALSE;
            /*
             * Check for global hooks now. If there is one, don't
             *  clear the desktop bits
             */
            phook = PhkFirstGlobalValid(pti, nFilterType);
            fClearDesktopBits = (phook == NULL);
        }
    } /* if (phook != NULL) */

    if (fClearThreadBits) {
        pti->fsHooks &= ~(WHF_FROM_WH(nFilterType));
        /*
         * Set the flags in the thread's TEB
         */
        if (pti->pClientInfo) {
            BOOL fAttached;
            /*
             * If the hooked thread is in another process, attach
             * to that process to access its address space.
             */
            if (pti->ppi != PpiCurrent()) {
                KeAttachProcess(PsGetProcessPcb(pti->ppi->Process));
                fAttached = TRUE;
            } else
                fAttached = FALSE;

            try {
                pti->pClientInfo->fsHooks = pti->fsHooks;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                /*
                 * Worst case scenario is the the cleint side will
                 * be out of sync of which hooks are installed
                 */
            }

            if (fAttached)
                KeDetachProcess();
        }
    }

    if (fClearDesktopBits) {
        pti->pDeskInfo->fsHooks &= ~(WHF_FROM_WH(nFilterType));
    }
}


/***************************************************************************\
* zzzUnhookWindowsHook (API)
*
* This is the old version of the Unhook API.  It does the same thing as
* zzzUnhookWindowsHookEx(), but takes a filter-type and filter-proc to
* identify which hook to unhook.
*
* History:
* 01-28-91  DavidPe         Created.
\***************************************************************************/

BOOL zzzUnhookWindowsHook(
    int nFilterType,
    PROC pfnFilterProc)
{
    PHOOK phk;
    PTHREADINFO ptiCurrent;

    if ((nFilterType < WH_MIN) || (nFilterType > WH_MAX)) {
        RIPERR0(ERROR_INVALID_HOOK_FILTER, RIP_VERBOSE, "");
        return FALSE;
    }

    ptiCurrent = PtiCurrent();

    for (phk = PhkFirstValid(ptiCurrent, nFilterType); phk != NULL; phk = PhkNextValid(phk)) {
        /*
         * Is this the hook we're looking for?
         */
        if (PFNHOOK(phk) == pfnFilterProc) {

            /*
             * Are we on the thread that set the hook?
             * If not return an error.
             */
            if (GETPTI(phk) != ptiCurrent) {
                RIPERR0(ERROR_ACCESS_DENIED,
                        RIP_WARNING,
                        "Access denied in zzzUnhookWindowsHook: "
                        "this thread is not the same as that which set the hook");

                return FALSE;
            }

            return zzzUnhookWindowsHookEx( phk );
        }
    }

    /*
     * Didn't find the hook we were looking for so return FALSE.
     */
    RIPERR0(ERROR_HOOK_NOT_INSTALLED, RIP_VERBOSE, "");
    return FALSE;
}


/***************************************************************************\
* zzzUnhookWindowsHookEx (API)
*
* Applications call this API to 'unhook' a hook.  First we check if someone
* is currently calling this hook.  If no one is we go ahead and free the
* HOOK structure now.  If someone is then we simply clear the filter-proc
* in the HOOK structure.  In xxxCallHook2() we check for this and if by
* that time no one is calling the hook in question we free it there.
*
* History:
* 01-28-91  DavidPe         Created.
\***************************************************************************/

BOOL zzzUnhookWindowsHookEx(
    PHOOK phkFree)
{
    PTHREADINFO pti;

    pti = GETPTI(phkFree);

    /*
     * If this hook is already destroyed, bail
     */
    if (phkFree->flags & HF_DESTROYED) {
        RIPMSG1(RIP_WARNING, "_UnhookWindowsHookEx(%#p) already destroyed", phkFree);
        return FALSE;
    }

    /*
     * Clear the journaling flags in all the queues.
     */
    if (abHookFlags[phkFree->iHook + 1] & HKF_JOURNAL) {
        zzzJournalAttach(pti, FALSE);
        /*
         * If someone got stuck because of the hook, let him go
         *
         * I want to get some performance numbers before checking this in.
         * MSTest hooks and unhooks all the time when running a script.
         * This code has never been in. 5/22/96. GerardoB
         */
        // InterQueueMsgCleanup(3 * CMSWAITTOKILLTIMEOUT);
    }

    /*
     * If no one is currently calling this hook,
     * go ahead and free it now.
     */
    FreeHook(phkFree);

    /*
     * If this thread has no more global hooks that are able to hook
     * server-side window procs, we must clear it's TIF_GLOBALHOOKER bit.
     */
    if (pti->TIF_flags & TIF_GLOBALHOOKER) {
        int iHook;
        PHOOK phk;
        for (iHook = WH_MIN ; iHook <= WH_MAX ; ++iHook) {
            /*
             * Ignore those that can't hook server-side winprocs
             */
            if (!(abHookFlags[iHook + 1] & HKF_INTERSENDABLE)) {
                continue;
            }

            /*
             * Scan the global hooks
             */
            for (phk = PhkFirstGlobalValid(pti, iHook);
                    phk != NULL; phk = PhkNextValid(phk)) {

                if (GETPTI(phk) == pti) {
                    goto StillHasGlobalHooks;
                }
            }
        }
        pti->TIF_flags &= ~TIF_GLOBALHOOKER;
    }

StillHasGlobalHooks:
    /*
     * Success, return TRUE.
     */
    return TRUE;
}


/***************************************************************************\
* _CallMsgFilter (API)
*
* CallMsgFilter() allows applications to call the WH_*MSGFILTER hooks.
* If there's a sysmodal window we return FALSE right away.  WH_MSGFILTER
* isn't called if WH_SYSMSGFILTER returned non-zero.
*
* History:
* 01-29-91  DavidPe         Created.
\***************************************************************************/

BOOL _CallMsgFilter(
    LPMSG pmsg,
    int nCode)
{
    PTHREADINFO pti;

    pti = PtiCurrent();

    /*
     * First call WH_SYSMSGFILTER.  If it returns non-zero, don't
     * bother calling WH_MSGFILTER, just return TRUE.  Otherwise
     * return what WH_MSGFILTER gives us.
     */
    if (IsHooked(pti, WHF_SYSMSGFILTER) && xxxCallHook(nCode, 0, (LPARAM)pmsg,
            WH_SYSMSGFILTER)) {
        return TRUE;
    }

    if (IsHooked(pti, WHF_MSGFILTER)) {
        return (BOOL)xxxCallHook(nCode, 0, (LPARAM)pmsg, WH_MSGFILTER);
    }

    return FALSE;
}


/***************************************************************************\
* xxxCallHook
*
* User code calls this function to call the first hook of a specific
* type.
*
* History:
* 01-29-91  DavidPe         Created.
\***************************************************************************/

int xxxCallHook(
    int nCode,
    WPARAM wParam,
    LPARAM lParam,
    int iHook)
{
    BOOL bAnsiHook;

    return (int)xxxCallHook2(PhkFirstValid(PtiCurrent(), iHook), nCode, wParam, lParam, &bAnsiHook);
}


/***************************************************************************\
* xxxCallHook2
*
* When you have an actual HOOK structure to call, you'd use this function.
* It will check to see if the hook hasn't already been unhooked, and if
* is it will free it and keep looking until it finds a hook it can call
* or hits the end of the list.  We also make sure any needed DLLs are loaded
* here.  We also check to see if the HOOK was unhooked inside the call
* after we return.
*
* Note: Hooking server-side window procedures (such as the desktop and console
* windows) can only be done by sending the hook message to the hooking app.
* (This is because we must not load the hookproc DLL into the server process).
* The hook types this can be done with are currently WH_JOURNALRECORD,
* WH_JOURNALPLAYBACK, WH_KEYBOARD and WH_MOUSE : these are all marked as
* HKF_INTERSENDABLE.  In order to prevent a global hooker from locking up the whole
* system, the hook message is sent with a timeout.  To ensure minimal
* performance degradation, the hooker process is set to foreground priority,
* and prevented from being set back to background priority with the
* TIF_GLOBALHOOKER bit in hooking thread's pti->flags.
* Hooking emulated DOS apps is prevented with the TIF_DOSEMULATOR bit in the
* console thread: this is because these apps typically hog the CPU so much that
* the hooking app does not respond rapidly enough to the hook messsages sent
* to it.  IanJa Nov 1994.
*
* History:
* 02-07-91     DavidPe     Created.
* 1994 Nov 02  IanJa       Hooking desktop and console windows.
\***************************************************************************/

LRESULT xxxCallHook2(
    PHOOK phkCall,
    int nCode,
    WPARAM wParam,
    LPARAM lParam,
    LPBOOL lpbAnsiHook)
{
    UINT        iHook;
    PHOOK       phkSave;
    LONG_PTR     nRet;
    PTHREADINFO ptiCurrent;
    BOOL        fLoadSuccess;
    TL          tlphkCall;
    TL          tlphkSave;
    BYTE        bHookFlags;
    BOOL        fMustIntersend;

    CheckCritIn();

    if (phkCall == NULL) {
        return 0;
    }

    iHook = phkCall->iHook;

    ptiCurrent = PtiCurrent();
    /*
     * Only low level hooks are allowed in the RIT context
     * (This check used to be done in PhkFirstValid).
     */
    if (ptiCurrent == gptiRit) {
        switch (iHook) {
        case WH_MOUSE_LL:
        case WH_KEYBOARD_LL:

#ifdef REDIRECTION
        case WH_HITTEST:
#endif // REDIRECTION

            break;

        default:
            return 0;
        }
    }

    /*
     * If this queue is in cleanup, exit: it has no business calling back
     * a hook proc. Also check if hooks are disabled for the thread.
     */
    if (    ptiCurrent->TIF_flags & (TIF_INCLEANUP | TIF_DISABLEHOOKS) ||
            ((ptiCurrent->rpdesk == NULL) && (phkCall->iHook != WH_MOUSE_LL))) {
        return ampiHookError[iHook + 1];
    }

    /*
     * Try to call each hook in the list until one is successful or
     * we reach the end of the list.
     */
    do {
        *lpbAnsiHook = phkCall->flags & HF_ANSI;
        bHookFlags = abHookFlags[phkCall->iHook + 1];

        /*
         * Some WH_SHELL hook types can be called from console
         * HSHELL_APPCOMMAND added for bug 346575 DefWindowProc invokes a shell hook
         * for console windows if they don't handle the wm_appcommand message - we need the hook
         * to go through for csrss.
         */
        if ((phkCall->iHook == WH_SHELL) && (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD)) {
            if ((nCode == HSHELL_LANGUAGE) || (nCode == HSHELL_WINDOWACTIVATED) ||
                (nCode == HSHELL_APPCOMMAND)) {
                bHookFlags |= HKF_INTERSENDABLE;
            }
        }

        if ((phkCall->iHook == WH_SHELL) && (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {
            if ((nCode == HSHELL_ACCESSIBILITYSTATE) ) {
                bHookFlags |= HKF_INTERSENDABLE;
            }
        }

        fMustIntersend =
            (GETPTI(phkCall) != ptiCurrent) &&
            (
                /*
                 * We always want to intersend journal hooks.
                 * CONSIDER (adams): Why? There's a performance hit by
                 * doing so, so if we haven't a reason, we shouldn't
                 * do it.
                 *
                 * we also need to intersend low level hooks. They can be called
                 * from the desktop thread, the raw input thread AND also from
                 * any thread that calls CallNextHookEx.
                 */
                (bHookFlags & (HKF_JOURNAL | HKF_LOWLEVEL))

                /*
                 * We must intersend if a 16bit app hooks a 32bit app
                 * because we can't load a 16bit dll into a 32bit process.
                 * We must also intersend if a 16bit app hooks another 16bit app
                 * in a different VDM, because we can't load a 16bit dll from
                 * one VDM into a 16bit app in another VDM (because that
                 * VDM is actually a 32bit process).
                 */
                ||
                (   GETPTI(phkCall)->TIF_flags & TIF_16BIT &&
                    (   !(ptiCurrent->TIF_flags & TIF_16BIT) ||
                        ptiCurrent->ppi != GETPTI(phkCall)->ppi))

#if defined(_WIN64)

                /*
                 * Intersend if a 64bit app hooks a 32bit app or
                 * a 32bit app hooks a 64bit app.
                 * This is necessary since a hook DLL can not be loaded
                 * cross bit type.
                 */
                ||
                (   (GETPTI(phkCall)->TIF_flags & TIF_WOW64) !=
                    (ptiCurrent->TIF_flags & TIF_WOW64)
                )

#endif /* defined(_WIN64) */

                /*
                 * We must intersend if a console or system thread is calling a hook
                 * that is not in the same console or the system process.
                 */
                ||
                (   ptiCurrent->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD) &&
                    GETPTI(phkCall)->ppi != ptiCurrent->ppi)

                /*
                 * If this is a global and non-journal hook, do a security
                 * check on the current desktop to see if we can call here.
                 * Note that we allow processes with the SYSTEM_LUID to hook
                 * other processes even if the other process says that it
                 * doesn't allow other accounts to hook them.  We did this
                 * because there was a bug in NT 3.x that allowed it and some
                 * services were written to use it.
                 */
                ||
                (   phkCall->flags & HF_GLOBAL &&
                    !RtlEqualLuid(&GETPTI(phkCall)->ppi->luidSession, &ptiCurrent->ppi->luidSession) &&
                    !(ptiCurrent->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK) &&
                    !RtlEqualLuid(&GETPTI(phkCall)->ppi->luidSession, &luidSystem))

                /*
                 * We must intersend if the hooking thread is running in
                 * another process and is restricted.
                 */
                ||
                (   GETPTI(phkCall)->ppi != ptiCurrent->ppi &&
                    IsRestricted(GETPTI(phkCall)->pEThread))
             );

        /*
         * We're calling back... make sure the hook doesn't go away while
         * we're calling back. We've thread locked here: we must unlock before
         * returning or enumerating the next hook in the chain.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, phkCall, &tlphkCall);

        if (!fMustIntersend) {
            /*
             * Make sure the DLL for this hook, if any, has been loaded
             * for the current process.
             */
            if ((phkCall->ihmod != -1) &&
                    (TESTHMODLOADED(ptiCurrent, phkCall->ihmod) == 0)) {

                /*
                 * Try loading the library, since it isn't loaded in this processes
                 * context.  First lock this hook so it doesn't go away while we're
                 * loading this library.
                 */
                fLoadSuccess = (xxxLoadHmodIndex(phkCall->ihmod) != NULL);

                /*
                 * If the LoadLibrary() failed, skip to the next hook and try
                 * again.
                 */
                if (!fLoadSuccess) {
                    goto LoopAgain;
                }
            }

            /*
             * Is WH_DEBUG installed?  If we're not already calling it, do so.
             */
            if (IsHooked(ptiCurrent, WHF_DEBUG) && (phkCall->iHook != WH_DEBUG)) {
                DEBUGHOOKINFO debug;

                debug.idThread = TIDq(ptiCurrent);
                debug.idThreadInstaller = 0;
                debug.code = nCode;
                debug.wParam = wParam;
                debug.lParam = lParam;

                if (xxxCallHook(HC_ACTION, phkCall->iHook, (LPARAM)&debug, WH_DEBUG)) {
                    /*
                     * If WH_DEBUG returned non-zero, skip this hook and
                     * try the next one.
                     */
                    goto LoopAgain;
                }
            }

            /*
             * Make sure the hook is still around before we
             * try and call it.
             */
            if (HMIsMarkDestroy(phkCall)) {
                goto LoopAgain;
            }

            /*
             * Time to call the hook! Lock it first so that it doesn't go away
             * while we're using it. Thread lock right away in case the lock frees
             * the previous contents.
             */

#if DBG
            if (phkCall->flags & HF_GLOBAL) {
                UserAssert(phkCall->ptiHooked == NULL);
            } else {
                UserAssert(phkCall->ptiHooked == ptiCurrent);
            }
#endif
            phkSave = ptiCurrent->sphkCurrent;
            ThreadLockWithPti(ptiCurrent, phkSave, &tlphkSave);

            if (ptiCurrent->pClientInfo) {
                try {
                    ptiCurrent->pClientInfo->phkCurrent = phkCall;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    nRet = 0;
                    goto Error;
                }
            }
            Lock(&ptiCurrent->sphkCurrent, phkCall);

            nRet = xxxHkCallHook(phkCall, nCode, wParam, lParam);

            Lock(&ptiCurrent->sphkCurrent, phkSave);
            if (ptiCurrent->pClientInfo) {
                try {
                    ptiCurrent->pClientInfo->phkCurrent = phkSave;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    nRet = 0;
                    goto Error;
                }
            }
            ThreadUnlock(&tlphkSave);

            /*
             * This hook proc faulted, so unhook it and try the next one.
             */
            if (phkCall->flags & HF_HOOKFAULTED) {
                PHOOK   phkFault;

                phkCall = PhkNextValid(phkCall);
                phkFault = ThreadUnlock(&tlphkCall);
                if (phkFault != NULL) {
                    FreeHook(phkFault);
                }

                continue;
            }

            /*
             * Lastly, we're done with this hook so it is ok to unlock it (it may
             * get freed here!
             */
            ThreadUnlock(&tlphkCall);

            return nRet;

        } else if (bHookFlags & HKF_INTERSENDABLE) {

            /*
             * Receiving thread can access this structure since the
             * sender thread's stack is locked down during xxxInterSendMsgEx
             */
            HOOKMSGSTRUCT hkmp;
            int           timeout = 200; // 1/5 second !!!

            hkmp.lParam = lParam;
            hkmp.phk = phkCall;
            hkmp.nCode = nCode;

            /*
             * Thread lock right away in case the lock frees the previous contents
             */
            phkSave = ptiCurrent->sphkCurrent;

            ThreadLockWithPti(ptiCurrent, phkSave, &tlphkSave);

            Lock(&ptiCurrent->sphkCurrent, phkCall);
            if (ptiCurrent->pClientInfo) {
                try {
                    ptiCurrent->pClientInfo->phkCurrent = phkCall;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    nRet = 0;
                    goto Error;
                }
            }

            /*
             * Make sure we don't get hung!
             */
            if (bHookFlags & HKF_LOWLEVEL) {
                timeout = gnllHooksTimeout;
                if (phkCall->fLastHookHung) {
                    /*
                     * WindowsBug: 307738
                     * Ever Quest hooks the Low Level hook.
                     * If the timeout occurred in the last hook
                     * callback, let's make the timeout shorter
                     * so that the RIT is not blocked by that.
                     */
                    TAGMSG1(DBGTAG_KBD, "xxxCallHook2: LL Hook target pti=%p is marked as hung, adjusting timeout to 20", GETPTI(phkCall));
                    timeout = 20;
                }
            }

            /*
             * CONSIDER(adams): Why should a journaling hook be allowed to
             * hang the console or a system thread? Will that interfere with
             * the user's ability to cancel journaling through Ctrl+Esc?
             */
            if (((bHookFlags & HKF_LOWLEVEL) == 0) &&
                (   (bHookFlags & HKF_JOURNAL) ||
                    !(ptiCurrent->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)))) {

                nRet = xxxInterSendMsgEx(NULL, WM_HOOKMSG, wParam,
                    (LPARAM)&hkmp, ptiCurrent, GETPTI(phkCall), NULL);
            } else {
                /*
                 * We are a server thread (console/desktop) and we aren't
                 * journalling, so we can't allow the hookproc to hang us -
                 * we must use a timeout.
                 */
                INTRSENDMSGEX ism;

                ism.fuCall     = ISM_TIMEOUT;
                ism.fuSend     = SMTO_ABORTIFHUNG | SMTO_NORMAL;
                ism.uTimeout   = timeout;
                ism.lpdwResult = &nRet;

                /*
                 * Don't hook DOS apps connected to the emulator - they often
                 * grab too much CPU for the callback to the hookproc to
                 * complete in a timely fashion, causing poor response.
                 */
                if ((ptiCurrent->TIF_flags & TIF_DOSEMULATOR) ||
                    FHungApp(GETPTI(phkCall), CMSHUNGAPPTIMEOUT) ||
                    !xxxInterSendMsgEx(NULL, WM_HOOKMSG, wParam,
                            (LPARAM)&hkmp, ptiCurrent, GETPTI(phkCall), &ism)) {
                    nRet = ampiHookError[iHook + 1];
                }

                /*
                 * If the low-level hook is eaten, the app may wake up from
                 * MsgWaitForMultipleObjects, clear the wake mask, but not get
                 * anything in GetMessage / PeekMessage and we will think it's
                 * hung. This causes problems in DirectInput because then the
                 * app may miss some hooks if FHungApp returns true, see bug
                 * NTBug 430342 for more details on this.
                 */
                if ((bHookFlags & HKF_LOWLEVEL) && nRet) {
                    SET_TIME_LAST_READ(GETPTI(phkCall));
                }
            }

            Lock(&ptiCurrent->sphkCurrent, phkSave);
            if (ptiCurrent->pClientInfo) {
                try {
                    ptiCurrent->pClientInfo->phkCurrent = phkSave;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    nRet = 0;
                }
            }
Error:
            ThreadUnlock(&tlphkSave);
            ThreadUnlock(&tlphkCall);
            return nRet;
        }
        // fall-through

LoopAgain:
        phkCall = PhkNextValid(phkCall);
        ThreadUnlock(&tlphkCall);
    } while (phkCall != NULL);

    return ampiHookError[iHook + 1];
}

/***************************************************************************\
* xxxCallMouseHook
*
* This is a helper routine that packages up a MOUSEHOOKSTRUCTEX and calls
* the WH_MOUSE hook.
*
* History:
* 02-09-91  DavidPe         Created.
\***************************************************************************/

BOOL xxxCallMouseHook(
    UINT message,
    PMOUSEHOOKSTRUCTEX pmhs,
    BOOL fRemove)
{
    BOOL bAnsiHook;

    /*
     * Call the mouse hook.
     */
    if (xxxCallHook2(PhkFirstValid(PtiCurrent(), WH_MOUSE), fRemove ?
            HC_ACTION : HC_NOREMOVE, (DWORD)message, (LPARAM)pmhs, &bAnsiHook)) {
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* xxxCallJournalRecordHook
*
* This is a helper routine that packages up an EVENTMSG and calls
* the WH_JOURNALRECORD hook.
*
* History:
* 02-28-91  DavidPe         Created.
\***************************************************************************/

void xxxCallJournalRecordHook(
    PQMSG pqmsg)
{
    EVENTMSG emsg;
    BOOL bAnsiHook;

    /*
     * Setup the EVENTMSG structure.
     */
    emsg.message = pqmsg->msg.message;
    emsg.time = pqmsg->msg.time;

    if (RevalidateHwnd(pqmsg->msg.hwnd)) {
        emsg.hwnd = pqmsg->msg.hwnd;
    } else {
        emsg.hwnd = NULL;
    }

    if ((emsg.message >= WM_MOUSEFIRST) && (emsg.message <= WM_MOUSELAST)) {
        emsg.paramL = (UINT)pqmsg->msg.pt.x;
        emsg.paramH = (UINT)pqmsg->msg.pt.y;

    } else if ((emsg.message >= WM_KEYFIRST) && (emsg.message <= WM_KEYLAST)) {
        BYTE bScanCode = LOBYTE(HIWORD(pqmsg->msg.lParam));
        /*
         * Build up a Win 3.1 compatible journal record key
         * Win 3.1  ParamL 00 00 SC VK  (SC=scan code VK=virtual key)
         * Also set ParamH 00 00 00 SC  to be compatible with our Playback
         *
         * If WM_*CHAR messages ever come this way we would have a problem
         * because we would lose the top byte of the Unicode character. We'd
         * We'd get ParamL 00 00 SC CH  (SC=scan code, CH = low byte of WCHAR)
         *
         */
        if ((LOWORD(pqmsg->msg.wParam) == VK_PACKET) && (bScanCode == 0)) {
            /*
             * If we have an injected Unicode char (from SendInput), the
             * character value was cached, let's give that to them too.
             */
            emsg.paramL = (UINT)MAKELONG(pqmsg->msg.wParam, PtiCurrent()->wchInjected);
        } else {
            emsg.paramL = MAKELONG(MAKEWORD(pqmsg->msg.wParam, bScanCode),0);
        }
        emsg.paramH = bScanCode;

        UserAssert((emsg.message != WM_CHAR) &&
                   (emsg.message != WM_DEADCHAR) &&
                   (emsg.message != WM_SYSCHAR) &&
                   (emsg.message != WM_SYSDEADCHAR));
        /*
         * Set extended-key bit.
         */
        if (pqmsg->msg.lParam & 0x01000000) {
            emsg.paramH |= 0x8000;
        }

    } else {
        RIPMSG2(RIP_WARNING,
                "Bad journal record message!\n"
                "   message  = 0x%08lx\n"
                "   dwQEvent = 0x%08lx",
                pqmsg->msg.message,
                pqmsg->dwQEvent);
    }

    /*
     * Call the journal recording hook.
     */
    xxxCallHook2(PhkFirstGlobalValid(PtiCurrent(), WH_JOURNALRECORD), HC_ACTION, 0,
            (LPARAM)&emsg, &bAnsiHook);

    /*
     * Write the MSG parameters back because the app may have modified it.
     * AfterDark's screen saver password actually zero's out the keydown
     * chars.
     *
     * If it was a mouse message patch up the mouse point.  If it was a
     * WM_KEYxxx message convert the Win 3.1 compatible journal record key
     * back into a half backed WM_KEYxxx format.  Only the VK and SC fields
     * where initialized at this point.
     *
     *      wParam  00 00 00 VK   lParam 00 SC 00 00
     */
    if ((pqmsg->msg.message >= WM_MOUSEFIRST) && (pqmsg->msg.message <= WM_MOUSELAST)) {
        pqmsg->msg.pt.x = emsg.paramL;
        pqmsg->msg.pt.y = emsg.paramH;

    } else if ((pqmsg->msg.message >= WM_KEYFIRST) && (pqmsg->msg.message <= WM_KEYLAST)) {
        (BYTE)pqmsg->msg.wParam = (BYTE)emsg.paramL;
        ((PBYTE)&pqmsg->msg.lParam)[2] = HIBYTE(LOWORD(emsg.paramL));
    }
}


/***************************************************************************\
* xxxCallJournalPlaybackHook
*
*
* History:
* 03-01-91  DavidPe         Created.
\***************************************************************************/

DWORD xxxCallJournalPlaybackHook(
    PQMSG pqmsg)
{
    EVENTMSG emsg;
    LONG dt;
    PWND pwnd;
    WPARAM wParam;
    LPARAM lParam;
    POINT pt;
    PTHREADINFO ptiCurrent;
    BOOL bAnsiHook = FALSE;
    PHOOK phkCall;
    TL tlphkCall;

    UserAssert(IsWinEventNotifyDeferredOK());

TryNextEvent:

    /*
     * Initialized to the current time for compatibility with
     * <= 3.0.
     */
    emsg.time = NtGetTickCount();
    ptiCurrent = PtiCurrent();
    pwnd = NULL;

    phkCall = PhkFirstGlobalValid(ptiCurrent, WH_JOURNALPLAYBACK);
    ThreadLockWithPti(ptiCurrent, phkCall, &tlphkCall);

    dt = (DWORD)xxxCallHook2(phkCall, HC_GETNEXT, 0, (LPARAM)&emsg, &bAnsiHook);

    /*
     * -1 means some error occured. Return -1 for error.
     */
    if (dt == 0xFFFFFFFF) {
        ThreadUnlock(&tlphkCall);
        return dt;
    }

    /*
     * Update the message id. Need this if we decide to sleep.
     */
    pqmsg->msg.message = emsg.message;

    if (dt > 0) {
        if (ptiCurrent->TIF_flags & TIF_IGNOREPLAYBACKDELAY) {
            /*
             * This flag tells us to ignore the requested delay (set in mnloop)
             * We clear it to indicate that we did so.
             */
            RIPMSG1(RIP_WARNING, "Journal Playback delay ignored (%lx)", emsg.message);
            ptiCurrent->TIF_flags &= ~TIF_IGNOREPLAYBACKDELAY;
            dt = 0;
        } else {
            ThreadUnlock(&tlphkCall);
            return dt;
        }
    }

    /*
     * The app is ready to be asked for the next event
     */

    if ((emsg.message >= WM_MOUSEFIRST) && (emsg.message <= WM_MOUSELAST)) {

        pt.x = (int)emsg.paramL;
        pt.y = (int)emsg.paramH;

        lParam = MAKELONG(LOWORD(pt.x), LOWORD(pt.y));
        wParam = 0;

        /*
         * If the message has changed the mouse position,
         * update the cursor.
         */
        if (pt.x != gpsi->ptCursor.x || pt.y != gpsi->ptCursor.y) {
            zzzInternalSetCursorPos(pt.x, pt.y);
        }

    } else if ((emsg.message >= WM_KEYFIRST) && (emsg.message < WM_KEYLAST)) {
        UINT wExtraStuff = 0;

        if ((emsg.message == WM_KEYUP) || (emsg.message == WM_SYSKEYUP)) {
            wExtraStuff |= 0x8000;
        }

        if ((emsg.message == WM_SYSKEYUP) || (emsg.message == WM_SYSKEYDOWN)) {
            wExtraStuff |= 0x2000;
        }

        if (emsg.paramH & 0x8000) {
            wExtraStuff |= 0x0100;
        }

        if (TestKeyStateDown(ptiCurrent->pq, (BYTE)emsg.paramL)) {
            wExtraStuff |= 0x4000;
        }
        lParam = MAKELONG(1, (UINT)((emsg.paramH & 0xFF) | wExtraStuff));

        if ((LOWORD(emsg.paramL) == VK_PACKET) && (LOBYTE(emsg.paramH) == 0)) {
            /*
             * We are playing back an injected Unicode char (see SendInput)
             * save the character for TranslateMessage to pick up.
             */
            ptiCurrent->wchInjected = HIWORD(emsg.paramL);
        } else {
            /*
             * Raid# 65331
             * WM_KEY* and WM_SYSKEY* messages should only contain 8bit Virtual Keys.
             * Some applications passes scan code in HIBYTE and could mess up
             * the system. E.g. Tab Keydown, paramL: 0x0f09 where 0f is scan code
             */
            DWORD dwMask = 0xff;

            /*
             * There are old ANSI apps that only fill in the byte for when
             * they generate journal playback so we used to strip everything
             * else off.  That however breaks unicode journalling; 22645
             * (Yes, some apps apparently do Playback WM_*CHAR msgs!)
             *
             */
            if (!bAnsiHook || IS_DBCS_ENABLED()) {
                if (IS_CHAR_MSG(emsg.message)) {
                    RIPMSG1(RIP_VERBOSE, "Unusual char message(%x) passed through JournalPlayback.", emsg.message);
                    /*
                     * Don't mask off HIBYTE(LOWORD(paramL)) for DBCS and UNICODE.
                     */
                    dwMask = 0xffff;
                }
            }

            wParam = emsg.paramL & dwMask;
        }

    } else if (emsg.message == WM_QUEUESYNC) {
        if (emsg.paramL == 0) {
            pwnd = ptiCurrent->pq->spwndActive;
        } else {
            if ((pwnd = RevalidateHwnd((HWND)IntToPtr( emsg.paramL ))) == NULL)
                pwnd = ptiCurrent->pq->spwndActive;
        }

    } else {
        /*
         * This event doesn't match up with what we're looking
         * for. If the hook is still valid, then skip this message
         * and try the next.
         */
        if (phkCall == NULL || phkCall->offPfn == 0L) {
            /* Hook is nolonger valid, return -1 */
            ThreadUnlock(&tlphkCall);
            return 0xFFFFFFFF;
        }

        RIPMSG1(RIP_WARNING,
                "Bad journal playback message=0x%08lx",
                emsg.message);

        xxxCallHook(HC_SKIP, 0, 0, WH_JOURNALPLAYBACK);
        ThreadUnlock(&tlphkCall);
        goto TryNextEvent;
    }

    StoreQMessage(pqmsg, pwnd, emsg.message, wParam, lParam, 0, 0, 0);

    ThreadUnlock(&tlphkCall);
    return 0;
}

/***************************************************************************\
* FreeHook
*
* Free hook unlinks the HOOK structure from its hook-list and removes
* any hmod dependencies on this hook.  It also frees the HOOK structure.
*
* History:
* 01-31-91  DavidPe         Created.
\***************************************************************************/

VOID FreeHook(
    PHOOK phkFree)
{
    /*
     * Paranoia...
     */
    UserAssert(!(phkFree->flags & HF_FREED));

    /*
     * If we came from zzzUnhookWindowsHookEx, journalling hooks have
     * already been cleaned up. Otherwise, they'll get cleaned up in
     * xxxInternalGetMessage through the gpdeskRecalcQueueAttach mechanism.
     */

    /*
     * Clear fsHooks bits the first time around (and mark it as destroyed).
     */
    if (!(phkFree->flags & HF_DESTROYED)) {
        DbgValidateHooks (phkFree, phkFree->iHook);
        phkFree->flags |= HF_DESTROYED;
        /*
         * This hook has been marked as destroyed so CheckWHSBits
         * won't take it into account when updating the fsHooks bits.
         * However, this means that right at this moment fsHooks is
         * out of sync. So we need a flag to make the assertion
         * happy.
         */
#if DBG
        phkFree->flags |= HF_INCHECKWHF;
#endif
        UserAssert((phkFree->ptiHooked != NULL) || (phkFree->flags & HF_GLOBAL));
        CheckWHFBits(phkFree->ptiHooked != NULL
                        ? phkFree->ptiHooked
                        : GETPTI(phkFree),
                     phkFree->iHook);
#if DBG
        phkFree->flags &= ~HF_INCHECKWHF;
#endif
    }
    /*
     * Mark it for destruction.  If it the object is locked it can't
     * be freed right now.
     */
    if (!HMMarkObjectDestroy((PVOID)phkFree)) {
        return;
    }
    /*
     * We're going to free this hook so get it off the list.
     */
    UnlinkHook(phkFree);
    /*
     * Now remove the hmod dependency and free the
     * HOOK structure.
     */
    if (phkFree->ihmod >= 0) {
        RemoveHmodDependency(phkFree->ihmod);
    }

#ifdef HOOKBATCH
    /*
     * Free the cached Events
     */
    if (phkFree->aEventCache) {
        UserFreePool(phkFree->aEventCache);
        phkFree->aEventCache = NULL;
    }
#endif //HOOKBATCH

#if DBG
    phkFree->flags |= HF_FREED;
#endif

    HMFreeObject((PVOID)phkFree);
    return;
}
/***************************************************************************\
* UnlinkHook
*
* Gets a hook out of its chain. Note that FreeThreadsWindowHooks unlinks
*  some hooks but don't free them. So this function doesn't assume that
*  the hook is going away.
*
* History:
* 04-25-97  GerardoB    Added Header
\***************************************************************************/
void UnlinkHook(
    PHOOK phkFree)
{
    PHOOK *pphkNext;
    PTHREADINFO ptiT;

    CheckCritIn();
    /*
     * Since we have the HOOK structure, we can tell if this a global
     * or local hook and start on the right list.
     */
    if (phkFree->flags & HF_GLOBAL) {
        pphkNext = &GETPTI(phkFree)->pDeskInfo->aphkStart[phkFree->iHook + 1];
    } else {
        ptiT = phkFree->ptiHooked;
        if (ptiT == NULL) {
            /*
             * Already unlinked (by FreeThreadsWindowHooks)
             */
            return;
        } else {
            /*
             * Clear ptiHooked so we won't try to unlink it again.
             */
            phkFree->ptiHooked = NULL;
        }
        pphkNext = &(ptiT->aphkStart[phkFree->iHook + 1]);
        /*
         * There must be at least one hook in the chain
         */
        UserAssert(*pphkNext != NULL);
    }
    /*
     * Find the address of the phkNext pointing to phkFree
     */
    while ((*pphkNext != phkFree) && (*pphkNext != NULL)) {
       pphkNext = &(*pphkNext)->phkNext;
    }
    /*
     * If we haven't found it, it must be global hook whose owner is gone or
     *  has switched desktops.
     */
    if (*pphkNext == NULL) {
        UserAssert(phkFree->flags & HF_GLOBAL);
        /*
         * if we saved a pdesk, use it. Else use the one we allocated it from
         */
        if (phkFree->rpdesk != NULL) {
            UserAssert(GETPTI(phkFree) == gptiRit);
            UserAssert(phkFree->rpdesk != NULL);
            UserAssert(phkFree->rpdesk->pDeskInfo != gptiRit->pDeskInfo);

            pphkNext = &phkFree->rpdesk->pDeskInfo->aphkStart[phkFree->iHook + 1];
        } else {
            UserAssert(GETPTI(phkFree)->pDeskInfo != phkFree->head.rpdesk->pDeskInfo);
            pphkNext = &phkFree->head.rpdesk->pDeskInfo->aphkStart[phkFree->iHook + 1];
        }

        UserAssert(*pphkNext != NULL);
        while ((*pphkNext != phkFree) && (*pphkNext != NULL)) {
           pphkNext = &(*pphkNext)->phkNext;
        }
    }
    /*
     * We're supposed to find it
     */
    UserAssert(*pphkNext == phkFree);
    /*
     * Unlink it
     */
    *pphkNext = phkFree->phkNext;
    phkFree->phkNext = NULL;
    /*
     * If we had a desktop, unlock it
     */
    if (phkFree->rpdesk != NULL) {
        UserAssert(phkFree->flags & HF_GLOBAL);
        UserAssert(GETPTI(phkFree) == gptiRit);
        UnlockDesktop(&phkFree->rpdesk, LDU_HOOK_DESK, 0);
    }
}

/***************************************************************************\
* PhkFirstGlobalValid
*
* Returns the first not-destroyed hook on the given desktop info.
*
* History:
* 03/24/97 GerardoB Created
\***************************************************************************/
PHOOK PhkFirstGlobalValid(PTHREADINFO pti, int nFilterType)
{
    PHOOK phk;

    CheckCritIn();
    phk = pti->pDeskInfo->aphkStart[nFilterType + 1];
    /*
     * Return the first hook that it's not destroyed (i.e, the
     *  first valid one).
     */
    if ((phk != NULL) && (phk->flags & HF_DESTROYED)) {
        phk = PhkNextValid(phk);
    }
    /*
     * Good place to check fsHooks. If the bits are out of sync,
     *  someone must be adjusting them.
     */
    DbgValidatefsHook(phk, nFilterType, pti, TRUE);
    DbgValidateHooks(phk, nFilterType);
    return phk;
}

/***************************************************************************\
* PhkFirstValid
*
* Given a filter-type PhkFirstValid() returns the first hook, if any, of the
* specified type.
*
* History:
* 02-10-91  DavidPe         Created.
\***************************************************************************/

PHOOK PhkFirstValid(
    PTHREADINFO pti,
    int nFilterType)
{
    PHOOK phk;
    CheckCritIn();
    /*
     * Grab the first hook off the local hook-list
     * for the current queue.
     */
    phk = pti->aphkStart[nFilterType + 1];
    /*
     * If there aren't any local hooks, try the global hooks.
     */
    if (phk == NULL) {
        phk = pti->pDeskInfo->aphkStart[nFilterType + 1];
    }
    /*
     * Return the first hook that it's not destroyed (i.e, the
     *  first valid one).
     */
    if ((phk != NULL) && (phk->flags & HF_DESTROYED)) {
        phk = PhkNextValid(phk);
    }
    /*
     * Good place to check fsHooks. If the bits are out of sync,
     *  someone must be adjusting them.
     */

    DbgValidatefsHook(phk, nFilterType, pti, FALSE);
    DbgValidateHooks(phk, nFilterType);
    return phk;
}

/***************************************************************************\
* FreeThreadsWindowHooks
*
* During 'exit-list' processing this function is called to free any hooks
* created on, or set for the current queue.
*
* History:
* 02-10-91  DavidPe         Created.
\***************************************************************************/

VOID FreeThreadsWindowHooks(VOID)
{
    int iHook;
    PHOOK phk, phkNext;
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * If there is not thread info, there are not hooks to worry about
     */
    if (ptiCurrent == NULL || ptiCurrent->rpdesk == NULL) {
        return;
    }
    /*
     * In case we have a hook locked in as the current hook unlock it
     * so it can be freed
     */
    Unlock(&ptiCurrent->sphkCurrent);

    UserAssert(ptiCurrent->TIF_flags & TIF_INCLEANUP);

    /*
     * Loop through all the hook types.
     */
    for (iHook = WH_MIN ; iHook <= WH_MAX ; ++iHook) {
        /*
         * Loop through all the hooks of this type, including the
         *  ones already marked as destroyed (so don't call
         *  PhkFirstValid and PhkNextValid).
         */
        phk = ptiCurrent->aphkStart[iHook + 1];
        if (phk == NULL) {
            phk = ptiCurrent->pDeskInfo->aphkStart[iHook + 1];
            UserAssert((phk == NULL) || (phk->flags & HF_GLOBAL));
        }

        while (phk != NULL) {
            /*
             * We might free phk below, so grab the next now
             * If at end of local chain, jump to the global chain
             */
            phkNext = phk->phkNext;
            if ((phkNext == NULL) && !(phk->flags & HF_GLOBAL)) {
                phkNext = ptiCurrent->pDeskInfo->aphkStart[iHook + 1];
                UserAssert((phkNext == NULL) || (phkNext->flags & HF_GLOBAL));
            }
            /*
             * If this is a local(thread) hook, unlink it and mark it as
             *  destroyed so we won't call it anymore. We want to do
             *  this even if not calling FreeHook; also note that
             *  FreeHook won't unlink it if locked so we do it here anyway.
             */
            if (!(phk->flags & HF_GLOBAL)) {
                UserAssert(ptiCurrent == phk->ptiHooked);
                UnlinkHook(phk);
                phk->flags |= HF_DESTROYED;
                phk->phkNext = NULL;
            }
            /*
             * If this hook was created by this thread, free it
             */
            if (GETPTI(phk) == ptiCurrent) {
                FreeHook(phk);
            }

            phk = phkNext;
        }
       /*
        * All local hooks should be unlinked
        */
       UserAssert(ptiCurrent->aphkStart[iHook + 1] == NULL);
    } /* for (iHook = WH_MIN....*/

    /*
     * Keep fsHooks in sync.
     */
    ptiCurrent->fsHooks = 0;
}

/***************************************************************************\
* zzzRegisterSystemThread: Private API
*
*  Used to set various attributes pertaining to a thread.
*
* History:
* 21-Jun-1994 from Chicago Created.
\***************************************************************************/

VOID zzzRegisterSystemThread (DWORD dwFlags, DWORD dwReserved)
{
    PTHREADINFO ptiCurrent;

    UserAssert(dwReserved == 0);

    if (dwReserved != 0)
        return;

    ptiCurrent = PtiCurrent();

    if (dwFlags & RST_DONTATTACHQUEUE)
        ptiCurrent->TIF_flags |= TIF_DONTATTACHQUEUE;

    if (dwFlags & RST_DONTJOURNALATTACH) {
        ptiCurrent->TIF_flags |= TIF_DONTJOURNALATTACH;

        /*
         * If we are already journaling, then this queue was already
         * journal attached.  We need to unattach and reattach journaling
         * so that we are removed from the journal attached queues.
         */
        if (FJOURNALPLAYBACK() || FJOURNALRECORD()) {
            zzzJournalAttach(ptiCurrent, FALSE);
            zzzJournalAttach(ptiCurrent, TRUE);
        }
    }
}

/***************************************************************************\
* xxxGetCursorPos
*
\***************************************************************************/

BOOL
xxxGetCursorPos(
    LPPOINT lpPt)
{
    POINT pt;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    CheckCritIn();

    if (ptiCurrent->rpdesk && ptiCurrent->rpdesk != grpdeskRitInput) {
        return FALSE;
    }

    pt.x = gpsi->ptCursor.x;
    pt.y = gpsi->ptCursor.y;

    try {
        ProbeForWrite(lpPt, sizeof(POINT), DATAALIGN);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

#ifdef REDIRECTION
    /*
     * If there is no CBT hook installed bail out.
     */
    if (IsHooked(PtiCurrent(), WHF_CBT)) {
        xxxCallHook(HCBT_GETCURSORPOS, 0, (LPARAM)&pt, WH_CBT);
    }
#endif // REDIRECTION

    try {
        RtlCopyMemory(lpPt, &pt, sizeof(POINT));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* _RegisterUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/
BOOL _RegisterUserApiHook(
    PUNICODE_STRING pstrLib,
    ULONG_PTR offPfnInitUserApiHook)
{
    /*
     * If we've already registered the UserApiHook, don't do it again.
     */
    if (IsInsideUserApiHook()) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "UserApiHook already registered");
        return FALSE;
    }

    /*
     * If this thread is restricted, don't let it install a hook.
     */
    if (IsRestricted(PsGetCurrentThread())) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Thread is restricted");
        return FALSE;
    }

    /*
     * Register the library with the library management routines so we
     * can assure it's loaded into all the processes necessary.
     */
    gihmodUserApiHook = GetHmodTableIndex(pstrLib);
    if (gihmodUserApiHook == -1) {
        RIPERR0(ERROR_MOD_NOT_FOUND, RIP_VERBOSE, "");
        return FALSE;
    }

    /*
     * Add a dependency on this module - meaning, increment a count
     * that simply counts the number of hooks set into this module.
     */
    AddHmodDependency(gihmodUserApiHook);

    /*
     * Remember which process registered the hook.
     */
    gppiUserApiHook = PpiCurrent();

    /*
     * Remember the offset to the DefWindowProc init routine.
     */
    goffPfnInitUserApiHook = offPfnInitUserApiHook;

    /*
     * Set the global flag in gpsi to signal hooking ( later used
     * as a check at beginning of hooked API's for loading DLL. )
     */
    SET_SRVIF(SRVIF_HOOKED);

    return TRUE;
}


/***************************************************************************\
* _UnregisterUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/
BOOL _UnregisterUserApiHook(VOID)
{
    /*
     * The window proc handler must be unregistered by the same process that
     * registered it.
     */
    if (PpiCurrent() != gppiUserApiHook) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Process hasn't registered UserApiHook");
        return FALSE;
    }
    gppiUserApiHook = NULL;

    /*
     * Make sure each hooked thread will unload the hook proc DLL
     */
    if (gihmodUserApiHook >= 0) {
        RemoveHmodDependency(gihmodUserApiHook);
        gihmodUserApiHook = -1;
    }

    /*
     * Clear the global flag in gpsi to signal disabled hooking ( later used
     * as a check at beginning of hooked API's for loading DLL. )
     */
    CLEAR_SRVIF(SRVIF_HOOKED);

    return TRUE;
}


#ifdef MESSAGE_PUMP_HOOK

/***************************************************************************\
* _DoInitMessagePumpHook
*
* History:
* 05-Dec-2000   JStall      Created
\***************************************************************************/
BOOL _DoInitMessagePumpHook(VOID)
{
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;
    ++pcti->cMessagePumpHooks;

    return TRUE;
}


/***************************************************************************\
* _DoUninitMessagePumpHook
*
* History:
* 05-Dec-2000   JStall      Created
\***************************************************************************/
BOOL _DoUninitMessagePumpHook(VOID)
{
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;
    if (pcti->cMessagePumpHooks <= 0) {
        return FALSE;
    }
    --pcti->cMessagePumpHooks;

    return TRUE;
}

#endif // MESSAGE_PUMP_HOOK


/***************************************************************************\
* xxxLoadUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/
BOOL xxxLoadUserApiHook(VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * A check is made here to see if hooking is still applicable after we
     * dropped to kernel.  There is a timing issue that could create a problem
     * where we check for hooking in user mode and decide to load but as we make the
     * drop to kernel, someone else is unregistering hooks and resetting all
     * globals.
     */
    if (!IsInsideUserApiHook()){
        return FALSE;
    }

    /*
     * If the DLL is already loaded in this process, we're done.
     */
    if (TESTHMODLOADED(ptiCurrent, gihmodUserApiHook)) {
        return TRUE;
    }

    /*
     * Don't load the DLL if:
     * - it's a system or CSRSS thread, it's in cleanup, or it's disabled hooks
     * - it's another user who hasn't granted access
     * - it's Win64 status doesn't match
     */
    if ((ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD | TIF_INCLEANUP | TIF_DISABLEHOOKS)) ||
        (!RtlEqualLuid(&gppiUserApiHook->luidSession, &luidSystem) &&
         !RtlEqualLuid(&gppiUserApiHook->luidSession, &ptiCurrent->ppi->luidSession) &&
         !(ptiCurrent->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK)) ||
        ((gppiUserApiHook->W32PF_Flags & W32PF_WOW64) != (ptiCurrent->ppi->W32PF_Flags & W32PF_WOW64))) {

        return FALSE;
    }

    /*
     * Try loading the library, since it isn't loaded in this processes
     * context.
     */
    return (xxxLoadHmodIndex(gihmodUserApiHook) != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\icons.c ===
/****************************** Module Header ******************************\
* Module Name: icons.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines having to do with icons.
*
* History:
* 11-14-90 DarrinM      Created.
* 13-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define DX_GAP      (SYSMET(CXMINSPACING) - SYSMET(CXMINIMIZED))
#define DY_GAP      (SYSMET(CYMINSPACING) - SYSMET(CYMINIMIZED))

/***************************************************************************\
* xxxArrangeIconicWindows
*
* Function to arrange all icons for a particular window.  Does this by
* Returns 0 if no icons or the height of one
* icon row if there are any icons.
*
* History:
* 11-14-90 darrinm      Ported from Win 3.0 sources.
*  4-17-91 mikehar      Win31 Merge
\***************************************************************************/

UINT xxxArrangeIconicWindows(
    PWND pwnd)
{
    PBWL pbwl;
    PSMWP psmwp;
    PWND pwndTest, pwndSort, pwndSwitch;
    HWND *phwnd, *phwndSort;
    CHECKPOINT *pcp, *pcpSort;
    POINT ptSort, ptSrc;
    WORD  nIcons = 0;
    RECT  rc;
    POINT ptMin;
    int   xOrg, yOrg;
    int   dx, dy;
    int   dxSlot, dySlot;
    int   cIconsPerPass, iIconPass;
    BOOL  fHorizontal, fBreak;
    TL tlpwndTest;
    BOOL fHideMe;

    CheckLock(pwnd);

    /*
     * Create a window list of all children of pwnd
     */
    if ((pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL)) == NULL)
        return 0;

    fHideMe = IsTrayWindow(pwnd->spwndChild);

    //
    // Put these into local vars for efficiency (see ParkIcon())
    //
    dxSlot = SYSMET(CXMINSPACING);
    dySlot = SYSMET(CYMINSPACING);

    //
    // We need to adjust the client rectangle if the parent has scrollbars.
    //
    GetRealClientRect(pwnd, &rc, GRC_SCROLLS, NULL);

    /*
     * find all icons
     */
    pwndSwitch = RevalidateHwnd(ghwndSwitch);
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if (((pwndTest = RevalidateHwnd(*phwnd)) == NULL) ||
                !TestWF(pwndTest , WFVISIBLE) ||
                pwndTest == pwndSwitch ||
                (pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                        PROPF_INTERNAL)) == NULL) {
            *phwnd = NULL;
            continue;
        }

        if (!TestWF(pwndTest, WFMINIMIZED)) {
            pcp->fMinInitialized = FALSE;
            pcp->ptMin.x = pcp->ptMin.y = -1;
            *phwnd = NULL;
            continue;
        }

        /*
         * inc count of icons
         */
        nIcons++;

        /*
         * we will park in default position again...
         */
        pcp->fDragged = FALSE;

        /*
         * ensure the original position is up to date
         */
        pcp->ptMin.x = pwndTest->rcWindow.left;
        pcp->ptMin.y = pwndTest->rcWindow.top;
        _ScreenToClient(pwnd, &pcp->ptMin);

        // Slide into the nearest row or column
        switch (SYSMET(ARRANGE) & ~ARW_HIDE) {
            case ARW_TOPLEFT | ARW_RIGHT:
            case ARW_TOPRIGHT | ARW_LEFT:
                // Slide into top row
                pcp->ptMin.y += dySlot / 2;
                pcp->ptMin.y -= pcp->ptMin.y % dySlot;
                break;

            case ARW_TOPLEFT | ARW_DOWN:
            case ARW_BOTTOMLEFT | ARW_UP:
                // Slide into left column
                pcp->ptMin.x += dxSlot / 2;
                pcp->ptMin.x -= pcp->ptMin.x % dxSlot;
                break;

            case ARW_BOTTOMLEFT | ARW_RIGHT:
            case ARW_BOTTOMRIGHT | ARW_LEFT:
                // Slide into bottom row
                pcp->ptMin.y = rc.bottom - pcp->ptMin.y;
                pcp->ptMin.y += dySlot / 2;
                pcp->ptMin.y -= pcp->ptMin.y % dySlot;
                pcp->ptMin.y = rc.bottom - pcp->ptMin.y;
                break;

            case ARW_BOTTOMRIGHT | ARW_UP:
            case ARW_TOPRIGHT | ARW_DOWN:
                // Slide into right column
                pcp->ptMin.x = rc.right - pcp->ptMin.x;
                pcp->ptMin.x += dxSlot / 2;
                pcp->ptMin.x -= pcp->ptMin.x % dxSlot;
                pcp->ptMin.x = rc.right - pcp->ptMin.x;
                break;
        }
    }

    if (nIcons == 0) {

        /*
         * no icons were found...  break out
         */
        FreeHwndList(pbwl);
        return 0;
    }

    if (fHideMe) {
        ptMin.x = WHERE_NOONE_CAN_SEE_ME;
        ptMin.y = WHERE_NOONE_CAN_SEE_ME;
        goto JustParkEm;
    }

    //
    // Get gravity && move vars
    //
    if (SYSMET(ARRANGE) & ARW_STARTRIGHT) {
        // Starting on right side
        ptMin.x = xOrg = rc.right - dxSlot;
        dx = -dxSlot;
    } else {
        // Starting on left
        ptMin.x = xOrg = rc.left + DX_GAP;
        dx = dxSlot;
    }

    if (SYSMET(ARRANGE) & ARW_STARTTOP) {
        // Starting on top
        ptMin.y = yOrg = rc.top + DY_GAP;
        dy = dySlot;
    } else {
        // Starting on bottom
        ptMin.y = yOrg = rc.bottom - dySlot;
        dy = -dySlot;
    }

    //
    // Get arrange dir
    //
    fHorizontal = ( (SYSMET(ARRANGE) & ARW_DOWN) ? FALSE : TRUE );

    iIconPass = fHorizontal ? (rc.right / dxSlot) : (rc.bottom / dySlot);
    cIconsPerPass = iIconPass = max(1, iIconPass);

    /*
     * insertion sort of windows by y, and by x within a row.
     */
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Check for 0 (window was not icon) and
         * Check for invalid HWND (window has been destroyed)
         */
        if (*phwnd == NULL || (pwndTest = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                PROPF_INTERNAL);
        ptSrc = pcp->ptMin;

        fBreak = FALSE;
        for (phwndSort = pbwl->rghwnd; phwndSort < phwnd; phwndSort++) {
            if (*phwndSort == NULL ||
                    (pwndSort = RevalidateHwnd(*phwndSort)) == NULL)
                continue;

            pcpSort = (CHECKPOINT*)_GetProp(pwndSort, PROP_CHECKPOINT,
                    PROPF_INTERNAL);

            ptSort = pcpSort->ptMin;

            //
            // Is this the position in which to sort this min window?
            //
            switch (SYSMET(ARRANGE) & ~ARW_HIDE) {
                case ARW_BOTTOMLEFT | ARW_RIGHT:
                    // Lower left, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x > ptSrc.x)) ||
                        (ptSort.y < ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_BOTTOMLEFT | ARW_UP:
                    // Lower left, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y < ptSrc.y)) ||
                        (ptSort.x > ptSrc.x))
                        fBreak = TRUE;
                    break;

                case ARW_BOTTOMRIGHT | ARW_LEFT:
                    // Lower right, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x < ptSrc.x)) ||
                        (ptSort.y < ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_BOTTOMRIGHT | ARW_UP:
                    // Lower right, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y < ptSrc.y)) ||
                        (ptSort.x < ptSrc.x))
                        fBreak = TRUE;
                    break;

                case ARW_TOPLEFT | ARW_RIGHT:
                    // Top left, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x > ptSrc.x)) ||
                        (ptSort.y > ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_TOPLEFT | ARW_DOWN:
                    // Top left, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y > ptSrc.y)) ||
                        (ptSort.x > ptSrc.x))
                        fBreak = TRUE;
                    break;

                case ARW_TOPRIGHT | ARW_LEFT:
                    // Top right, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x < ptSrc.x)) ||
                        (ptSort.y > ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_TOPRIGHT | ARW_DOWN:
                    // Top right, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y > ptSrc.y)) ||
                        (ptSort.x < ptSrc.x))
                        fBreak = TRUE;
                    break;
            }

            if (fBreak)
                break;
        }

        /*
         * insert the window at this position by sliding the rest up.
         * LATER IanJa, use hwnd intermediate variables, avoid PW() & HW()
         */
        while (phwndSort < phwnd) {
            pwndSort = PW(*phwndSort);
            *phwndSort = HW(pwndTest);
            pwndTest = pwndSort;
            phwndSort++;
        }

        /*
         * replace the window handle in the original position
         */
        *phwnd = HW(pwndTest);
    }

    //
    // Now park the icons.
    //

JustParkEm:

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if (*phwnd == NULL || (pwndTest = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                PROPF_INTERNAL);
        if (pcp != NULL) {
            pcp->fMinInitialized = TRUE;
            pcp->ptMin = ptMin;
        }

        if (fHideMe) {
            continue;
        }

        // Setup to process the next position
        if (--iIconPass <= 0) {
            // Need to setup next pass
            iIconPass = cIconsPerPass;

            if (fHorizontal) {
                ptMin.x = xOrg;
                ptMin.y += dy;
            } else {
                ptMin.x += dx;
                ptMin.y = yOrg;
            }
        } else {
            // Same pass
            if (fHorizontal)
                ptMin.x += dx;
            else
                ptMin.y += dy;
        }
    }

    psmwp = InternalBeginDeferWindowPos(2 * nIcons);
    if (psmwp == NULL)
        goto ParkExit;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Check for a NULL (window has gone away)
         */
        if (*phwnd == NULL || (pwndTest = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                PROPF_INTERNAL);


        ThreadLockAlways(pwndTest, &tlpwndTest);

        psmwp = _DeferWindowPos(
                psmwp,
                pwndTest,
                NULL,
                pcp->ptMin.x,
                pcp->ptMin.y,
                SYSMET(CXMINIMIZED),
                SYSMET(CYMINIMIZED),
                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

        ThreadUnlock(&tlpwndTest);

        if (psmwp == NULL)
            break;
    }
    if (psmwp != NULL) {
        /*
         * Make the swp async so we don't hang waiting for hung apps.
         */
        xxxEndDeferWindowPosEx(psmwp, TRUE);
    }

ParkExit:
    FreeHwndList(pbwl);
    return nIcons;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\kbd.c ===
/****************************** Module Header ******************************\,
* Module Name: kbd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* OEM-specific tables and routines for IBM Extended 101/102 style keyboards
*
* History:
* 30-04-91 IanJa       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* aVkToVsc[] - table associating Virtual Key codes with Virtual Scancodes
*
* Ordered, 0-terminated.
*
* This is used for those Virtual Keys that do not appear in ausVK_???[]
* These are not the base Virtual Keys.  They require some modifier key
* depression (CTRL, ALT, SHIFT) or NumLock On to be generated.
*
* All the scancodes listed below should be marked KBDMULTIVK or KBDNUMPAD in
* ausVK_???[].
*
* This table is used by MapVirtualKey(wVk, 0).
\***************************************************************************/
BYTE aVkNumpad[] = {
    VK_NUMPAD7,  VK_NUMPAD8,  VK_NUMPAD9, 0xFF, // 0x47 0x48 0x49 (0x4A)
    VK_NUMPAD4,  VK_NUMPAD5,  VK_NUMPAD6, 0xFF, // 0x4B 0x4C 0x4D (0x4E)
    VK_NUMPAD1,  VK_NUMPAD2,  VK_NUMPAD3,       // 0x4F 0x50 0x51
    VK_NUMPAD0,  VK_DECIMAL,  0                 // 0x50 0x51
};

/***************************************************************************\
* How some Virtual Key values change when a SHIFT key is held down.
\***************************************************************************/
ULONG aulShiftCvt_VK[] = {
    MAKELONG(VK_MULTIPLY, VK_SNAPSHOT),
    MAKELONG(0,0)
};

// JPN IMB02
ULONG aulShiftControlCvt_VK_IBM02[] = {
    MAKELONG(VK_SCROLL, VK_CANCEL | KBDEXT),
    MAKELONG(VK_NUMLOCK, VK_PAUSE | KBDEXT),
    MAKELONG(0,0)
};

/***************************************************************************\
* How some Virtual Key values change when a CONTROL key is held down.
\***************************************************************************/
ULONG aulControlCvt_VK[] = {
    MAKELONG(VK_NUMLOCK,  VK_PAUSE | KBDEXT),
    MAKELONG(VK_SCROLL,   VK_CANCEL),
    MAKELONG(0,0)
};

// JPN IBM02
ULONG aulControlCvt_VK_IBM02[] = {
    MAKELONG(VK_PAUSE, VK_CANCEL | KBDEXT),
    MAKELONG(VK_SCROLL, VK_CANCEL | KBDEXT),
    MAKELONG(0,0)
};

/***************************************************************************\
* How some Virtual Key values change when an ALT key is held down.
* The SHIFT and ALT keys both alter VK values the same way!!
\***************************************************************************/
#define aulAltCvt_VK aulShiftCvt_VK


/***************************************************************************\
* This table list keys that may affect Virtual Key values when held down.
*
* See kbd.h for a full description.
*
* 101/102key keyboard (type 4):
*    Virtual Key values vary only if CTRL is held down.
* 84-86 key keyboards (type 3):
*    Virtual Key values vary if one of SHIFT, CTRL or ALT is held down.
\***************************************************************************/

VK_TO_BIT aVkToBits_VK[] = {
    { VK_SHIFT,   KBDSHIFT }, // 0x01
    { VK_CONTROL, KBDCTRL  }, // 0x02
    { VK_MENU,    KBDALT   }, // 0x04
    { 0,          0        }
};

// JPN IBM02
VK_TO_BIT aVkToBits_VK_IBM02[] = {
    { VK_SHIFT,   KBDSHIFT }, // 0x01
    { VK_CONTROL, KBDCTRL  }, // 0x02
    { 0,          0        }
};

/***************************************************************************\
* Tables defining how some Virtual Key values are modified when other keys
* are held down.
* Translates key combinations into indices for gapulCvt_VK_101[] or for
* gapulCvt_VK_84[] or for
*
* See kbd.h for a full description.
*
\***************************************************************************/

MODIFIERS Modifiers_VK_STANDARD = {
    &aVkToBits_VK[0],
    4,                 // Maximum modifier bitmask/index
    {
        SHFT_INVALID,  // no keys held down    (no VKs are modified)
        0,             // SHIFT held down      84-86 key kbd
        1,             // CTRL held down       101/102 key kbd
        SHFT_INVALID,  // CTRL-SHIFT held down (no VKs are modified)
        2              // ALT held down        84-86 key kbd
    }
};

MODIFIERS Modifiers_VK_IBM02 = {
    &aVkToBits_VK_IBM02[0],
    3,                   // Maximum modifier bitmask/index
    {
        SHFT_INVALID,  // no modifier keys (no VK modification)
        SHFT_INVALID,  // Shift            (no VK modification)
        0,             // Control          (VK modification number 0)
        1              // Control Shift    (VK modification number 1)
    }
};

/***************************************************************************\
* A tables of pointers indexed by the number obtained from Modify_VK.
* If a pointer is non-NULL then the table it points to is searched for
* Virtual Key that should have their values changed.
* There are two versions: one for 84-86 key kbds, one for 101/102 key kbds.
* gapulCvt_VK is initialized with the default (101/102 key kbd).
\***************************************************************************/
ULONG *gapulCvt_VK_101[] = {
    NULL,                 // No VKs are changed by SHIFT being held down
    aulControlCvt_VK,     // Some VKs are changed by CTRL being held down
    NULL                  // No VKs are changed by ALT being held down
};

ULONG *gapulCvt_VK_84[] = {
    aulShiftCvt_VK,       // Some VKs are changed by SHIFT being held down
    aulControlCvt_VK,     // Some VKs are changed by CTRL being held down
    aulAltCvt_VK          // Some VKs are changed by ALT being held down
};

ULONG *gapulCvt_VK_IBM02[] = {
    aulControlCvt_VK_IBM02,     // VK modification number 0 (Control key)
    aulShiftControlCvt_VK_IBM02,// VK modification number 1 (Shift Control key)
};

PULONG *gapulCvt_VK = gapulCvt_VK_101;

PMODIFIERS gpModifiers_VK = &Modifiers_VK_STANDARD;

/***************************************************************************\
* The table ausNumPadCvt is used to convert a cursor movement
* virtual key value (obtained from ausVK_???[]) into a VK_NUMPAD
* virtual key value.  This translation is done when NumLock is
* on and no shift keys are pressed.
\***************************************************************************/
USHORT ausNumPadCvt[] =
{
    MAKEWORD(VK_INSERT, VK_NUMPAD0),
    MAKEWORD(VK_END, VK_NUMPAD1),
    MAKEWORD(VK_DOWN, VK_NUMPAD2),
    MAKEWORD(VK_NEXT, VK_NUMPAD3),
    MAKEWORD(VK_LEFT, VK_NUMPAD4),
    MAKEWORD(VK_CLEAR, VK_NUMPAD5),
    MAKEWORD(VK_RIGHT, VK_NUMPAD6),
    MAKEWORD(VK_HOME, VK_NUMPAD7),
    MAKEWORD(VK_UP, VK_NUMPAD8),
    MAKEWORD(VK_PRIOR, VK_NUMPAD9),
    MAKEWORD(VK_DELETE, VK_DECIMAL),
    MAKEWORD(0, 0)
};

/***************************************************************************\
* xxxNumpadCursor() - handle special case Numpad Cursor-movement Keys
*
* If NumLock is on, and Shift is up then:
*      VK_INSERT  -> VK_NUMPAD0
*      VK_END     -> VK_NUMPAD1
*      VK_DOWN    -> VK_NUMPAD2
*      VK_NEXT    -> VK_NUMPAD3
*      VK_LEFT    -> VK_NUMPAD4
*      VK_CLEAR   -> VK_NUMPAD5
*      VK_RIGHT   -> VK_NUMPAD6
*      VK_HOME    -> VK_NUMPAD7
*      VK_UP      -> VK_NUMPAD8
*      VK_PRIOR   -> VK_NUMPAD9
*      VK_DELETE  -> VK_DECIMAL (unless CTRL-ALT-DEL)
* If Numlock is on, and Shift is down then precede first Numpad Cursor key
* going down with a fake Shift key coming up & follow the Numpad Cursor key
* coming up with with a fake Shift key going down.
*
* Return value:
*   TRUE: keep this routine active: continue passing Key Events through here
*  FALSE: deactivet this routine: stop sending Key Events through here.
*
* This function will leave the critical section only if low level hooks
* are installed and the call to xxxKeyEvent is made
*
\***************************************************************************/
BOOL
xxxNumpadCursor(
    PKE pKe)
{
    static BYTE bLastNumpadCursor = 0;
    static USHORT VkFakedShiftUp;  // VK_LSHIFT or VK_RSHIFT
    static BYTE VscFakedShiftUp;   // 0x2A or 0x36 resp.
    int i;

    CheckCritIn();

    if (bLastNumpadCursor) {
        if (bLastNumpadCursor == (BYTE)(pKe->usFlaggedVk)) {
            /*
             * Same key as last one: if coming up, or going down?
             */
            if (pKe->usFlaggedVk & KBDBREAK) {
                /*
                 * Numpad Cursor key came back up. Send this key now, and make
                 * sure that the Shift key will then appear to go back down
                 * again.
                 */
                xxxKeyEvent(pKe->usFlaggedVk, pKe->bScanCode,
                            pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                            pKe->hDevice,
                            &pKe->data,
#endif
                            FALSE);
                bLastNumpadCursor = 0;
                pKe->usFlaggedVk = VkFakedShiftUp;
                pKe->bScanCode = VscFakedShiftUp;
            }
            /*
             * Going down: this key is repeating, so just pass it on
             * unaltered and keep the KEProc active
             */
            return TRUE;
        } else {
            /*
             * It is a different key.  Fake the Shift key back down again,
             * and continue (it may be another Numpad Cursor key)
             */
            xxxKeyEvent(VkFakedShiftUp,
                    (WORD)(VscFakedShiftUp | SCANCODE_SIMULATED),
                     pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                        pKe->hDevice,
                        &pKe->data,
#endif
                        FALSE);
            bLastNumpadCursor = 0;
        }
    }

    if (pKe->usFlaggedVk & KBDNUMPAD) {

        UINT fsModifiers;
        /*
         * This is the numeric pad.
         * Here, if NumLock is set, we change the virtual keycodes to
         * numeric VK_NUMPAD codes, so the keys will be translated
         * as numbers etc.  But if a shift key is down, we handle
         * these as cursor keys, but we need to make sure that these
         * are seen as UNSHIFTED
         */

        /*
         * Check for SAS.
         */
        if (IsSAS((BYTE)(pKe->usFlaggedVk), &fsModifiers)) {
            return TRUE;
        } else if (TestRawKeyToggle(VK_NUMLOCK)) {
            if (TestRawKeyDown(VK_SHIFT)) {
                /*
                 * key is down (bit(s) set in BIOS key state), so we are going
                 * to keep this as a cursor key.  To do this, we need to
                 * make sure that Windows' state vector entry for VK_SHIFT is
                 * OFF even though a shift key is actually down.
                 */
                bLastNumpadCursor = (BYTE)(pKe->usFlaggedVk);
                if (TestRawKeyDown(VK_RSHIFT)) {
                    VkFakedShiftUp = VK_RSHIFT | KBDEXT;
                    VscFakedShiftUp = 0x36;
                } else {
                    VkFakedShiftUp = VK_LSHIFT;
                    VscFakedShiftUp = 0x2A;
                }
                xxxKeyEvent((USHORT)(VkFakedShiftUp | KBDBREAK),
                        (WORD)(VscFakedShiftUp | SCANCODE_SIMULATED),
                         pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                            pKe->hDevice,
                            &pKe->data,
#endif
                            FALSE);
                return TRUE;
            }

            /*
             * NumLock ON but Shift key up: Alter the Virtual Key event,
             * but not for injected virtual keys.
             */
            if ((pKe->usFlaggedVk & KBDINJECTEDVK) == 0) {
                for (i = 0; ausNumPadCvt[i] != 0; i++) {
                    if (LOBYTE(ausNumPadCvt[i]) == LOBYTE(pKe->usFlaggedVk)) {
                        /*
                         * keep extra bits, but change VK value
                         */
                        pKe->usFlaggedVk &= ~0xFF;
                        pKe->usFlaggedVk |= (UINT)(HIBYTE(ausNumPadCvt[i]));
                        break;

                    }
                }
            }
        }
    }
    return TRUE;
}

/***************************************************************************\
*
* xxxICO_00() - handle special case '00' key
*
* LATER IanJa: should only be in ICO OEM file for kbd with '00' key
*
* This function will leave the critical section only if low level hooks
* are installed ant the call to xxxKeyEvent is made
*
\***************************************************************************/
BOOL
xxxICO_00(
    PKE pKe)
{
    CheckCritIn();

    if ((pKe->usFlaggedVk & 0xFF) != VK_ICO_00) {
        /*
         * Pass the keystroke on unaltered
         */
        return TRUE;
    }

    if (pKe->usFlaggedVk & KBDBREAK) {
        /*
         * '0' key comes up
         */
        pKe->usFlaggedVk = '0' | KBDEXT | KBDBREAK;
    } else {
        /*
         * '0' down, up, down
         */
        xxxKeyEvent('0', pKe->bScanCode, pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    pKe->hDevice,
                    &pKe->data,
#endif
                    FALSE);
        xxxKeyEvent('0' | KBDBREAK, pKe->bScanCode, pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    pKe->hDevice,
                    &pKe->data,
#endif
                    FALSE);
        pKe->usFlaggedVk = '0' | KBDEXT;
    }

    return TRUE;
}

KEPROC aKEProcOEM[] = {
    xxxICO_00,       // Bitmask 0x01
    xxxNumpadCursor, // Bitmask 0x02
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\job.c ===
/****************************** Module Header ******************************\
* Module Name: job.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the code to implement the job object in NTUSER.
*
* History:
* 29-Jul-1997 CLupu   Created.
\***************************************************************************/

#include "precomp.h"

PW32JOB CreateW32Job(PEJOB Job);
VOID UpdateJob(PW32JOB pW32Job);
void SetProcessFlags(PW32JOB pW32Job, PPROCESSINFO ppi);
BOOL JobCalloutAddProcess(PW32JOB, PPROCESSINFO);
BOOL JobCalloutTerminate(PW32JOB);

/***************************************************************************\
* UserJobCallout
*
* History:
* 29-Jul-1997 CLupu   Created.
\***************************************************************************/
NTSTATUS UserJobCallout(
    PKWIN32_JOBCALLOUT_PARAMETERS Parm)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PW32JOB  pW32Job = NULL;
    PEJOB    Job;
    PSW32JOBCALLOUTTYPE CalloutType;
    PVOID    Data;


    Job = Parm->Job;
    CalloutType = Parm->CalloutType;
    Data = Parm->Data;

    /*
     * The EJOB lock must be acquired at this time.
     */
    UserAssert(ExIsResourceAcquiredExclusiveLite(PsGetJobLock(Job)));

    UserAssert(gpresUser != NULL);

    BEGIN_REENTERCRIT();

    BEGINATOMICCHECK();

    /*
     * find the W32JOB in the global list (if any)
     */
    pW32Job = gpJobsList;

    while (pW32Job) {
        if (pW32Job->Job == Job) {
            break;
        }
        pW32Job = pW32Job->pNext;
    }

    switch (CalloutType) {
    case PsW32JobCalloutSetInformation:

        if (pW32Job == NULL) {

            /*
             * The W32Job is not created yet. Assert that this is not
             * a call to remove UI restrictions
             */
            UserAssert(Data != 0);

            if ((pW32Job = CreateW32Job(Job)) == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        } else {

            /*
             * The W32Job structure is already created. Return if
             * the restrictions are the same as before.
             */
            if (PtrToUlong(Data) == pW32Job->restrictions) {
                TAGMSG0(DBGTAG_Job, "UserJobCallout: SetInformation same as before");
                break;
            }
        }

        /*
         * Set the restrictions
         */
        pW32Job->restrictions = PtrToUlong(Data);

        UpdateJob(pW32Job);
        break;

    case PsW32JobCalloutAddProcess:

        /*
         * 'Data' parameter is a pointer to W32PROCESS. So this callout
         * happens only for GUI processes.
         */
        UserAssert(PsGetJobUIRestrictionsClass(Job) != 0);

        /*
         * Assert that the W32JOB structure is already created.
         */
        UserAssert(pW32Job != NULL);

        TAGMSG3(DBGTAG_Job, "UserJobCallout: AddProcess Job %#p W32Job %#p Process %#p",
                Job, pW32Job, (ULONG_PTR)Data);

        /*
         * this callout must be only for GUI processes
         */
        UserAssert(Data != NULL);

        JobCalloutAddProcess(pW32Job, (PPROCESSINFO)Data);

        break;

    case PsW32JobCalloutTerminate:

        TAGMSG2(DBGTAG_Job, "UserJobCallout: Terminate Job %#p W32Job %#p",
                Job, pW32Job);

        if (pW32Job) {
            JobCalloutTerminate(pW32Job);
        }
        break;

    default:
        TAGMSG2(DBGTAG_Job, "UserJobCallout: Invalid callout 0x%x Job %#p",
                CalloutType, Job);

        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    ENDATOMICCHECK();

    END_REENTERCRIT();

    return Status;
}

/***************************************************************************\
* CreateW32Job
*
* Creates a W32Job
*
* History:
* 18-Mar-1998 CLupu   Created.
\***************************************************************************/
PW32JOB CreateW32Job(
    PEJOB Job)
{
    PW32JOB pW32Job;

    TAGMSG1(DBGTAG_Job, "CreateW32Job: EJOB %#p", Job);

    pW32Job = UserAllocPoolZInit(sizeof(W32JOB), TAG_W32JOB);

    if (pW32Job == NULL) {
        RIPMSG0(RIP_ERROR, "CreateW32Job: memory allocation error");
        return NULL;
    }

    /*
     * Create the global atom table for this job
     */
    CreateGlobalAtomTable(&pW32Job->pAtomTable);

    if (pW32Job->pAtomTable == NULL) {
        RIPMSG1(RIP_ERROR, "CreateW32Job: fail to create the atom table for job %#p",
                pW32Job);

        UserFreePool(pW32Job);
        return NULL;
    }

    /*
     * Link it in the W32 job's list
     */
    pW32Job->pNext = gpJobsList;
    gpJobsList = pW32Job;

    pW32Job->Job = Job;

    TAGMSG2(DBGTAG_Job, "CreateW32Job: pW32Job %#P created for EJOB %#p",
            pW32Job, Job);

    return pW32Job;
}

/***************************************************************************\
* UpdateJob
*
* Walks the processinfo list in userk to update all the processes assigned
* to this job .
*
* History:
* 20-Mar-1998 CLupu   Created.
\***************************************************************************/
VOID UpdateJob(
    PW32JOB pW32Job)
{
    PPROCESSINFO ppi;

    UserAssert(ExIsResourceAcquiredExclusiveLite(PsGetJobLock(pW32Job->Job)));
    CheckCritIn();

    TAGMSG1(DBGTAG_Job, "UpdateJob: pW32Job %#p", pW32Job);

    /*
     * walk the GUI processes list to see if any new process got
     * assigned to the current job.
     */
    ppi = gppiList;

    while (ppi) {
        if (PsGetProcessJob(ppi->Process) == pW32Job->Job) {

            /*
             * the process is assigned to this job
             */
            if (ppi->pW32Job == NULL) {

                /*
                 * add the process to the W32 job
                 */
                JobCalloutAddProcess(pW32Job, ppi);
            } else {

                /*
                 * The process is already added to the job. Just
                 * update the restrictions.
                 */
                SetProcessFlags(pW32Job, ppi);
            }
        }
        ppi = ppi->ppiNextRunning;
    }
}

/***************************************************************************\
* RemoveProcessFromJob
*
* This is called during the delete process callout.
*
* History:
* 30-Jul-1997 CLupu   Created.
\***************************************************************************/
BOOL RemoveProcessFromJob(
    PPROCESSINFO ppi)
{
    PW32JOB pW32Job;
    UINT    ip;

    CheckCritIn();

    pW32Job = ppi->pW32Job;

    TAGMSG2(DBGTAG_Job, "RemoveProcessFromJob: ppi %#p pW32Job %#p",
            ppi, pW32Job);

    /*
     * The job might not have UI restrictions
     */
    if (pW32Job == NULL) {
        return FALSE;
    }

    /*
     * remove the ppi from the job's ppi table
     */
    for (ip = 0; ip < pW32Job->uProcessCount; ip++) {

        UserAssert(pW32Job->ppiTable[ip]->pW32Job == pW32Job);

        if (ppi == pW32Job->ppiTable[ip]) {

            ppi->pW32Job = NULL;

            RtlMoveMemory(pW32Job->ppiTable + ip,
                          pW32Job->ppiTable + ip + 1,
                          (pW32Job->uProcessCount - ip - 1) * sizeof(PPROCESSINFO));

            (pW32Job->uProcessCount)--;

            /*
             * free the process array if this is the last one.
             */
            if (pW32Job->uProcessCount == 0) {
                UserFreePool(pW32Job->ppiTable);
                pW32Job->ppiTable = NULL;
                pW32Job->uMaxProcesses = 0;
            }
            
            TAGMSG2(DBGTAG_Job, "RemoveProcessFromJob: ppi %#p removed from pW32Job %#p",
                    ppi, pW32Job);

            return TRUE;
        }
    }
    
    TAGMSG2(DBGTAG_Job, "RemoveProcessFromJob: ppi %#p not found in pW32Job %#p",
            ppi, pW32Job);

    UserAssert(0);

    return FALSE;
}

/***************************************************************************\
* SetProcessFlags
*
* History:
* 29-Jul-1997 CLupu   Created.
\***************************************************************************/
void SetProcessFlags(
    PW32JOB      pW32Job,
    PPROCESSINFO ppi)
{
    PTHREADINFO pti;

    CheckCritIn();

    TAGMSG3(DBGTAG_Job, "SetProcessFlags: pW32Job %#p ppi %#p restrictions %#p",
            pW32Job, ppi, pW32Job->restrictions);

    UserAssert(ppi->pW32Job == pW32Job);

    if (pW32Job->restrictions == 0) {
        ((PW32PROCESS)ppi)->W32PF_Flags &= ~W32PF_RESTRICTED;
    } else {
        ((PW32PROCESS)ppi)->W32PF_Flags |= W32PF_RESTRICTED;
    }

    KeAttachProcess(PsGetProcessPcb(ppi->Process));

    /*
     * walk the pti list and set the restricted flag as appropriate
     */
    pti = ppi->ptiList;

    if (pW32Job->restrictions == 0) {
        while (pti) {
            try {
                pti->pClientInfo->dwTIFlags &= ~TIF_RESTRICTED;
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
               continue;
            }
            pti->TIF_flags &= ~TIF_RESTRICTED;
            pti = pti->ptiSibling;
        }
    } else {
        while (pti) {
            try {
                pti->pClientInfo->dwTIFlags |= TIF_RESTRICTED;
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
               continue;
            }
            pti->TIF_flags |= TIF_RESTRICTED;
            pti = pti->ptiSibling;
        }
    }

    KeDetachProcess();
}

/***************************************************************************\
* JobCalloutAddProcess
*
* History:
* 30-Jul-1997 CLupu   Created.
\***************************************************************************/
BOOL JobCalloutAddProcess(
    PW32JOB      pW32Job,
    PPROCESSINFO ppi)
{
    PPROCESSINFO* ppiTable;

    CheckCritIn();

    UserAssert(pW32Job != NULL);

    /*
     * This process is not yet initialized
     */
    if (ppi->Process == NULL) {
        return FALSE;
    }

    if (!(ppi->W32PF_Flags & W32PF_PROCESSCONNECTED)) {
        TAGMSG2(DBGTAG_Job, "JobCalloutAddProcess: pW32Job %#p ppi %#p not yet initialized",
                pW32Job, ppi);
        return FALSE;
    }

    TAGMSG2(DBGTAG_Job, "JobCalloutAddProcess: pW32Job %#p ppi %#p",
            pW32Job, ppi);

#if DBG
    /*
     * Make sure the process is not already in the job's process list
     */
    {
        UINT ip;
        for (ip = 0; ip < pW32Job->uProcessCount; ip++) {

            UserAssert(pW32Job->ppiTable[ip]->pW32Job == pW32Job);
            UserAssert(ppi != pW32Job->ppiTable[ip]);
        }
    }
#endif // DBG

    /*
     * save the pW32Job pointer in the process info
     */
    UserAssert(ppi->pW32Job == NULL);

    ppi->pW32Job = pW32Job;

    if (pW32Job->uProcessCount == pW32Job->uMaxProcesses) {

        /*
         * No more room. Allocate more space for the process table
         */
        if (pW32Job->uMaxProcesses == 0) {

            UserAssert(pW32Job->ppiTable == NULL);

            ppiTable = UserAllocPool(JP_DELTA * sizeof(PPROCESSINFO), TAG_W32JOBEXTRA);

        } else {
            UserAssert(pW32Job->ppiTable != NULL);

            ppiTable = UserReAllocPool(pW32Job->ppiTable,
                                       pW32Job->uMaxProcesses * sizeof(PPROCESSINFO),
                                       (pW32Job->uMaxProcesses + JP_DELTA) * sizeof(PPROCESSINFO),
                                       TAG_W32JOBEXTRA);
        }

        if (ppiTable == NULL) {
            RIPMSG0(RIP_ERROR, "JobCalloutAddProcess: memory allocation error\n");
            return FALSE;
        }

        pW32Job->ppiTable = ppiTable;
        pW32Job->uMaxProcesses += JP_DELTA;
    }

    /*
     * now add the process to the job
     */
    pW32Job->ppiTable[pW32Job->uProcessCount] = ppi;
    (pW32Job->uProcessCount)++;

    SetProcessFlags(pW32Job, ppi);

    return TRUE;
}

/***************************************************************************\
* JobCalloutTerminate
*
* This is called during the job object delete routine.
*
* History:
* 30-Jul-1997 CLupu   Created.
\***************************************************************************/
BOOL JobCalloutTerminate(
    PW32JOB pW32Job)
{
    CheckCritIn();

    UserAssert(pW32Job != NULL);

    TAGMSG1(DBGTAG_Job, "JobCalloutTerminate: pW32Job %#p", pW32Job);

    /*
     * No processes should be attached to this job
     */
    UserAssert(pW32Job->ppiTable == NULL);
    UserAssert(pW32Job->uProcessCount == 0);
    UserAssert(pW32Job->uMaxProcesses == 0);

    if (pW32Job->pgh) {
        UserAssert(pW32Job->ughCrt > 0);
        UserAssert(pW32Job->ughMax > 0);

        UserFreePool(pW32Job->pgh);
        pW32Job->pgh    = NULL;
        pW32Job->ughCrt = 0;
        pW32Job->ughMax = 0;
    }

    /*
     * remove the W32 job from the job's list
     */
    REMOVE_FROM_LIST(W32JOB, gpJobsList, pW32Job, pNext);

    RtlDestroyAtomTable(pW32Job->pAtomTable);

    UserFreePool(pW32Job);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\keyboard.c ===
/****************************** Module Header ******************************\
* Module Name: keyboard.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-11-90 DavidPe      Created.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop



/***************************************************************************\
* _GetKeyState (API)
*
* This API returns the up/down and toggle state of the specified VK based
* on the input synchronized keystate in the current queue.  The toggle state
* is mainly for 'state' keys like Caps-Lock that are toggled each time you
* press them.
*
* History:
* 11-11-90 DavidPe      Created.
\***************************************************************************/

SHORT _GetKeyState(
    int vk)
{
    UINT wKeyState;
    PTHREADINFO pti;

    if ((UINT)vk >= CVKKEYSTATE) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"vk\" (%ld) to _GetKeyState",
                vk);

        return 0;
    }

    pti = PtiCurrentShared();

#ifdef LATER
//
// note - anything that accesses the pq structure is a bad idea since it
// can be changed between any two instructions.
//
#endif

    wKeyState = 0;

    /*
     * Set the toggle bit.
     */
    if (TestKeyStateToggle(pti->pq, vk))
        wKeyState = 0x0001;

    /*
     * Set the keyup/down bit.
     */
    if (TestKeyStateDown(pti->pq, vk)) {
        /*
         * Used to be wKeyState|= 0x8000.Fix for bug 28820; Ctrl-Enter
         * accelerator doesn't work on Nestscape Navigator Mail 2.0
         */
        wKeyState |= 0xff80;  // This is what 3.1 returned!!!!
    }

    return (SHORT)wKeyState;
}

/***************************************************************************\
* _GetAsyncKeyState (API)
*
* This function is similar to GetKeyState except it returns what could be
* considered the 'hardware' keystate or what state the key is in at the
* moment the function is called, rather than based on what key events the
* application has processed.  Also, rather than returning the toggle bit,
* it has a bit telling whether the key was pressed since the last call to
* GetAsyncKeyState().
*
* History:
* 11-11-90 DavidPe      Created.
\***************************************************************************/

SHORT _GetAsyncKeyState(
    int vk)
{
    SHORT sKeyState;

    if ((UINT)vk >= CVKKEYSTATE) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"vk\" (%ld) to _GetAsyncKeyState",
                vk);

        return 0;
    }

    /*
     * See if this key went down since the last time state for it was
     * read. Clear the flag if so.
     */
    sKeyState = 0;
    if (TestAsyncKeyStateRecentDown(vk)) {
        ClearAsyncKeyStateRecentDown(vk);
        sKeyState = 1;
    }

    /*
     * Set the keyup/down bit.
     */
    if (TestAsyncKeyStateDown(vk))
        sKeyState |= 0x8000;

    /*
     * Don't return the toggle bit since it's a new bit and might
     * cause compatibility problems.
     */
    return sKeyState;
}

/***************************************************************************\
* _SetKeyboardState (API)
*
* This function allows the app to set the current keystate.  This is mainly
* useful for setting the toggle bit, particularly for the keys associated
* with the LEDs on the physical keyboard.
*
* History:
* 11-11-90 DavidPe      Created.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL _SetKeyboardState(
    CONST BYTE *pb)
{
    int i;
    PQ pq;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    pq = ptiCurrent->pq;

    /*
     * Copy in the new state table.
     */
    for (i = 0; i < 256; i++, pb++) {
        if (*pb & 0x80) {
            SetKeyStateDown(pq, i);
        } else {
            ClearKeyStateDown(pq, i);
        }

        if (*pb & 0x01) {
            SetKeyStateToggle(pq, i);
        } else {
            ClearKeyStateToggle(pq, i);
        }
    }

    /*
     * Update the key cache index.
     */
    gpsi->dwKeyCache++;

#ifdef LATER
// scottlu 6-9-91
// I don't think we ought to do this unless someone really complains. This
// could have bad side affects, especially considering that terminal
// apps will want to do this, and terminal apps could easily not respond
// to input for awhile, causing this state to change unexpectedly while
// a user is using some other application. - scottlu.

/* DavidPe 02/05/92
 *  How about if we only do it when the calling app is foreground?
 */

    /*
     * Propagate the toggle bits for the keylight keys to the
     * async keystate table and update the keylights.
     *
     * THIS could be evil in a de-synced environment, but to do this
     * in a totally "synchronous" way is hard.
     */
    if (pb[VK_CAPITAL] & 0x01) {
        SetAsyncKeyStateToggle(VK_CAPITAL);
    } else {
        ClearAsyncKeyStateToggle(VK_CAPITAL);
    }

    if (pb[VK_NUMLOCK] & 0x01) {
        SetAsyncKeyStateToggle(VK_NUMLOCK);
    } else {
        ClearAsyncKeyStateToggle(VK_NUMLOCK);
    }

    if (pb[VK_SCROLL] & 0x01) {
        SetAsyncKeyStateToggle(VK_SCROLL);
    } else {
        ClearAsyncKeyStateToggle(VK_SCROLL);
    }

    UpdateKeyLights(TRUE);
#endif

    return TRUE;
}

/***************************************************************************\
* RegisterPerUserKeyboardIndicators
*
* Saves the current keyboard indicators in the user's profile.
*
* ASSUMPTIONS:
*
* 10-14-92 IanJa        Created.
\***************************************************************************/

static CONST WCHAR wszInitialKeyboardIndicators[] = L"InitialKeyboardIndicators";

VOID
RegisterPerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName)
{
    WCHAR wszInitKbdInd[2] = L"0";

    /*
     * Initial Keyboard state (Num-Lock only)
     */

    /*
     * For HYDRA we do not want to save this.
     */
    if (gbRemoteSession) {
        return;
    }

    wszInitKbdInd[0] += TestAsyncKeyStateToggle(VK_NUMLOCK) ? 2 : 0;
    FastWriteProfileStringW(pProfileUserName,
                            PMAP_KEYBOARD,
                            wszInitialKeyboardIndicators,
                            wszInitKbdInd);
}

/***************************************************************************\
* UpdatePerUserKeyboardIndicators
*
* Sets the initial keyboard indicators according to the user's profile.
*
* ASSUMPTIONS:
*
* 10-14-92 IanJa        Created.
\***************************************************************************/
VOID
UpdatePerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName)
{
    DWORD dw = 0x80000000;
    PQ pq;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    pq = ptiCurrent->pq;

    /*
     * For terminal server, the client is responsible for synchronizing the
     * keyboard state.
     */

    if (IsRemoteConnection()) {
        return;
    }

    /*
     * Initial Keyboard state (Num-Lock only)
     */
    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARD,
                       wszInitialKeyboardIndicators,
                       0x80000000,
                       &dw,
                       0);

    dw &= 0x80000002;


    /*
     * The special value 0x80000000 in the registry indicates that the BIOS
     * settings are to be used as the initial LED state. (This is undocumented)
     */
    if (dw == 0x80000000) {
        dw = gklpBootTime.LedFlags;
    }
    if (dw & KEYBOARD_NUM_LOCK_ON) {
        SetKeyStateToggle(pq, VK_NUMLOCK);
        SetAsyncKeyStateToggle(VK_NUMLOCK);
        SetRawKeyToggle(VK_NUMLOCK);
    } else {
        ClearKeyStateToggle(pq, VK_NUMLOCK);
        ClearAsyncKeyStateToggle(VK_NUMLOCK);
        ClearRawKeyToggle(VK_NUMLOCK);
    }

    /*
     * Initialize KANA Toggle status
     */
    gfKanaToggle = FALSE;
    ClearKeyStateToggle(pq, VK_KANA);
    ClearAsyncKeyStateToggle(VK_KANA);
    ClearRawKeyToggle(VK_KANA);

    UpdateKeyLights(FALSE);
}


/***************************************************************************\
* UpdateAsyncKeyState
*
* Based on a VK and a make/break flag, this function will update the async
* keystate table.
*
* History:
* 06-09-91 ScottLu      Added keystate synchronization across threads.
* 11-12-90 DavidPe      Created.
\***************************************************************************/

void UpdateAsyncKeyState(
    PQ pqOwner,
    UINT wVK,
    BOOL fBreak)
{
    PQ pqT;
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO pti;

    CheckCritIn();

    /*
     * First check to see if the queue this key is going to has a pending
     * key state event. If it does, post it because we need to copy the
     * async key state into this event as it is before we modify
     * this key's state, or else we'll generate a key state event with
     * the wrong key state in it.
     */
    if (pqOwner != NULL && pqOwner->QF_flags & QF_UPDATEKEYSTATE) {
        PostUpdateKeyStateEvent(pqOwner);
    }

    if (!fBreak) {
        /*
         * This key has gone down - update the "recent down" bit in the
         * async key state table.
         */
        SetAsyncKeyStateRecentDown(wVK);

        /*
         * This is a key make. If the key was not already down, update the
         * toggle bit.
         */
        if (!TestAsyncKeyStateDown(wVK)) {
            if (TestAsyncKeyStateToggle(wVK)) {
                ClearAsyncKeyStateToggle(wVK);
            } else {
                SetAsyncKeyStateToggle(wVK);
            }
        }

        /*
         * This is a make, so turn on the key down bit.
         */
        SetAsyncKeyStateDown(wVK);

    } else {
        /*
         * This is a break, so turn off the key down bit.
         */
        ClearAsyncKeyStateDown(wVK);
    }

    /*
     * If this is one of the keys we cache, update the async key cache index.
     */
    if (wVK < CVKASYNCKEYCACHE) {
        gpsi->dwAsyncKeyCache++;
    }

    /*
     * A key has changed state. Update all queues not receiving this input so
     * they know that this key has changed state. This lets us know which keys to
     * update in the thread specific key state table to keep it in sync
     * with the user.  Walking down the thread list may mean that an
     * individual queue may by updated more than once, but it is cheaper
     * than maintaining a list of queues on the desktop.
     */
    UserAssert(grpdeskRitInput != NULL);

    pHead = &grpdeskRitInput->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        /*
         * Don't update the queue this message is going to - it'll be
         * in sync because it is receiving this message.
         */
        pqT = pti->pq;
        if (pqT == pqOwner)
            continue;

        /*
         * Set the "recent down" bit. In this case this doesn't really mean
         * "recent down", it means "recent change" (since the last time
         * we synced this queue), either up or down. This tells us which
         * keys went down since the last time this thread synced with key
         * state. Set the "update key state" flag so we know that later
         * we need to sync with these keys.
         */
        SetKeyRecentDownBit(pqT->afKeyRecentDown, wVK);
        pqT->QF_flags |= QF_UPDATEKEYSTATE;
    }

    /*
     * Update the key cache index.
     */
    gpsi->dwKeyCache++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\libmgmt.c ===
/****************************** Module Header ******************************\
* Module Name: libmgmt.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the code to manage loading and freeing libraries
* in use by USER.
*
* History:
* 02-04-91 DavidPe      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*
 * Globals local to this file
 *
 *
 * Number of hmodule entries in the module management table.
 */
int catomSysTableEntries;

/*
 * Array of atoms that are the fully qualified path names of each managed
 * module.
 */
ATOM aatomSysLoaded[CLIBS];

/*
 * Count of processes that have LoadModule()'d each module.
 */
int acatomSysUse[CLIBS];

/*
 * Count of hooks set into each module.
 */
int acatomSysDepends[CLIBS];


/****************************************************************************\
* GetHmodTableIndex
*
* This routine is used to return the index of a given atom within the system
* wide hmod atom table.  If the atom is not found, an attempt to allocate a
* new table entry is made.  If the attempt fails, -1 is returned.
*
* History:
* 02-04-91  DavidPe         Ported.
\****************************************************************************/

int GetHmodTableIndex(
    PUNICODE_STRING pstrLibName)
{
    int i;
    ATOM atom;
    UNICODE_STRING strLibName;

    /*
     * Probe string
     */
    try {
        strLibName = ProbeAndReadUnicodeString(pstrLibName);
        ProbeForReadUnicodeStringBuffer(strLibName);
        atom = UserAddAtom(strLibName.Buffer, FALSE);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return -1;
    }

    /*
     * If we can't add the atom we're hosed
     * so return an error.
     */
    if (atom == 0) {
        return -1;
    }

    /*
     * Search for atom index
     */
    for (i = 0; i < catomSysTableEntries && aatomSysLoaded[i] != atom; i++)
        ;

    if (i == catomSysTableEntries) {

        /*
         * Find empty entry for atom
         */
        for (i = 0; i < catomSysTableEntries && aatomSysLoaded[i]; i++)
            ;

        /*
         * Check if no empty entry found
         */
        if (i == catomSysTableEntries) {
            if (i == CLIBS) {
                UserDeleteAtom(atom);
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
                        RIP_WARNING,
                        "Memory allocation failed in GetHmodTableIndex");

                return -1;
            }

            /*
             * Increase table size
             */
            catomSysTableEntries++;
        }

        /*
         * Set entry
         */
        aatomSysLoaded[i] = atom;
        acatomSysUse[i] = 0;
        acatomSysDepends[i] = 0;
    } else {
        UserDeleteAtom(atom);
    }

    return i;
}


/*****************************************************************************\
* AddHmodDependency
*
* This function merely increments the dependency count of a given hmod
* atom table index.
*
* History:
* 02-04-91  DavidPe         Ported.
\*****************************************************************************/

VOID AddHmodDependency(
    int iatom)
{
    UserAssert(iatom >= 0);
    if (iatom < catomSysTableEntries) {
        acatomSysDepends[iatom]++;
    }
}


/*****************************************************************************\
* RemoveHmodDependency
*
* This function removes a system dependency on a given index into the hmod
* atom table.  If all dependencies on the hmod have been removed (the Depends
* count  reaches zero) then the QS_SYSEXPUNGE bit is set in all message
* queues so the eventually each process will do a free module on it.
*
* History:
* 02-04-91  DavidPe         Ported.
\*****************************************************************************/

VOID RemoveHmodDependency(
    int iatom)
{

    UserAssert(iatom >= 0);
    if (iatom < catomSysTableEntries &&
        --acatomSysDepends[iatom] == 0) {

        if (acatomSysUse[iatom]) {

            /*
             * Cause each thread to check for expunged dlls
             * the next time they awake.
             */
            gcSysExpunge++;
            gdwSysExpungeMask |= (1 << iatom);
        } else {
            aatomSysLoaded[iatom] = 0;
        }
    }
}


/*****************************************************************************\
* xxxLoadHmodIndex
*
* This function attempts to load the hmodule specified by iatom into the
* system hmod table.  Updates the per-process bitmap accordingly.  Returns
* NULL on success.
*
* History:
* 02-04-91  DavidPe         Ported.
\*****************************************************************************/

HANDLE xxxLoadHmodIndex(
    int iatom)
{
    WCHAR pszLibName[MAX_PATH];
    HANDLE hmod;
    UNICODE_STRING strLibrary;
    PTHREADINFO    ptiCurrent = PtiCurrent();

    UserAssert((!gptiRit || gptiRit->ppi != PtiCurrent()->ppi) &&
                "Shouldn't load global hooks on system process - gptiRit->ppi is the system process");

    if (iatom >= catomSysTableEntries) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Index out of range");
        return NULL;
    }

    UserGetAtomName(aatomSysLoaded[iatom], pszLibName, sizeof(pszLibName)/sizeof(WCHAR));

    /*
     * Call back the client to load the library.
     */
    RtlInitUnicodeString(&strLibrary, pszLibName);
    hmod = ClientLoadLibrary(&strLibrary, (iatom == gihmodUserApiHook) ? goffPfnInitUserApiHook : 0);

    if (hmod != NULL) {
        /*
         * Check to make sure another thread hasn't loaded this library
         * while we were outside the critical section.
         */
        if (!TESTHMODLOADED(ptiCurrent, iatom)) {
            /*
             * Go ahead and bump the reference count.
             */
            acatomSysUse[iatom]++;
            SETHMODLOADED(ptiCurrent, iatom, hmod);

        } else {
            /*
             * Another thread loaded it while we were outside the
             * critical section.  Unload it so the system's
             * reference count is correct.
             */
            ClientFreeLibrary(ptiCurrent->ppi->ahmodLibLoaded[iatom]);
        }
    }

    return hmod;
}


/***********************************************************************\
* DoSysExpunge
*
* This function is called when a thread wakes up and finds its
* QS_SYSEXPUNGE wakebit set.
*
* History:
* 02-04-91  DavidPe         Ported.
\***********************************************************************/

VOID xxxDoSysExpunge(
    PTHREADINFO pti)
{
    int i;

    /*
     * Clear this first before we potentially leave the critical section.
     */
    pti->ppi->cSysExpunge = gcSysExpunge;

    /*
     * Scan for libraries that have been freed
     */
    for (i = 0; i < catomSysTableEntries; i++) {
        if ((acatomSysDepends[i] == 0) && (aatomSysLoaded[i] != 0) &&
                TESTHMODLOADED(pti, i)) {

            HANDLE hmodFree = pti->ppi->ahmodLibLoaded[i];

            /*
             * Clear this hmod for this process before we leave the
             * critical section.
             */
            CLEARHMODLOADED(pti, i);

            /*
             * Decrement the count of processes that have loaded this
             * .dll.  If there are no more, then destroy the reference
             * to this .dll.
             */
            if (--acatomSysUse[i] == 0) {
                UserDeleteAtom(aatomSysLoaded[i]);
                aatomSysLoaded[i] = 0;
                gdwSysExpungeMask &= ~(1 << i);
            }

            /*
             * Call back the client to free the library...
             */
            ClientFreeLibrary(hmodFree);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\kbdlyout.c ===
/**************************** Module Header ********************************\
* Module Name: kbdlyout.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Keyboard Layout API
*
* History:
* 04-14-92 IanJa      Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Workers (forward declarations)
 */
BOOL xxxInternalUnloadKeyboardLayout(PWINDOWSTATION, PKL, UINT);
VOID ReorderKeyboardLayouts(PWINDOWSTATION, PKL);

/****************************************************************************\
* HKLtoPKL
*
* pti   - thread to look in
* hkl   - HKL_NEXT or HKL_PREV
*         Finds the the next/prev LOADED layout, NULL if none.
*         (Starts from the pti's active layout, may return pklActive itself)
*       - a real HKL (Keyboard Layout handle):
*         Finds the kbd layout struct (loaded or not), NULL if no match found.
*
* History:
* 1997-02-05 IanJa     added pti parameter
\****************************************************************************/
PKL HKLtoPKL(
    PTHREADINFO pti,
    HKL hkl)
{
    PKL pklActive;
    PKL pkl;

    UserAssert(pti != NULL);
    if ((pklActive = pti->spklActive) == NULL) {
        return NULL;
    }

    pkl = pklActive;

    if (hkl == (HKL)HKL_PREV) {
        do {
            pkl = pkl->pklPrev;
            if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
                return pkl;
            }
        } while (pkl != pklActive);
        return NULL;
    } else if (hkl == (HKL)HKL_NEXT) {
        do {
            pkl = pkl->pklNext;
            if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
                return pkl;
            }
        } while (pkl != pklActive);
        return NULL;
    }

    /*
     * Find the pkl for this hkl.
     * If the kbd layout isn't specified (in the HIWORD), ignore it and look
     * for a Locale match only.  (Mohamed Hamid's fix for Word bug)
     */
    if (HandleToUlong(hkl) & 0xffff0000) {
        do {
            if (pkl->hkl == hkl) {
                return pkl;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklActive);
    } else {
        do {
            if (LOWORD(HandleToUlong(pkl->hkl)) == LOWORD(HandleToUlong(hkl))) {
                return pkl;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklActive);
    }

    return NULL;
}


/***************************************************************************\
* ReadLayoutFile
*
* Maps layout file into memory and initializes layout table.
*
* History:
* 01-10-95 JimA         Created.
\***************************************************************************/

#define GET_HEADER_FIELD(x) \
    ((fWin64Header) ? (NtHeader64->x) : (NtHeader32->x))

/*
 * Note that this only works for sections < 64K
 * Implicitly assumes pBaseVirt, pBaseDst and dwDataSize.
 */

#if DBG
BOOL gfEnableChecking = TRUE;
#else
BOOL gfEnableChecking = FALSE;
#endif

#define EXIT_READ(p) \
    RIPMSGF1(RIP_WARNING, #p " is @ invalid address %p", p); \
    if (gfEnableChecking) { \
        goto exitread; \
    }

#define VALIDATE_PTR(p) \
    if ((PBYTE)(p) < (PBYTE)pBaseDst || (PBYTE)(p) + sizeof *(p) > (PBYTE)pBaseDst + dwDataSize) { \
        EXIT_READ(p); \
    }

#define FIXUP_PTR(p) \
    if (p) { \
        p = (PVOID)((PBYTE)pBaseVirt + (WORD)(ULONG_PTR)(p)); \
        VALIDATE_PTR(p); \
    } \
    TAGMSGF1(DBGTAG_KBD, #p " validation finished %p", p);

PKBDTABLES ReadLayoutFile(
    PKBDFILE pkf,
    HANDLE hFile,
    UINT offTable,
    UINT offNlsTable
    )
{
    HANDLE hmap = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SIZE_T ulViewSize = 0;
    NTSTATUS Status;
    PIMAGE_DOS_HEADER DosHdr = NULL;
    BOOLEAN fWin64Header;
    PIMAGE_NT_HEADERS32 NtHeader32;
    PIMAGE_NT_HEADERS64 NtHeader64;
    PIMAGE_SECTION_HEADER SectionTableEntry;
    ULONG NumberOfSubsections;
    ULONG OffsetToSectionTable;
    PBYTE pBaseDst = NULL, pBaseVirt = NULL;
    PKBDTABLES pktNew = NULL;
    DWORD dwDataSize;
    PKBDNLSTABLES pknlstNew = NULL;
    BOOL fSucceeded = FALSE;

    TAGMSGF1(DBGTAG_KBD, "entering for '%ls'", pkf->awchDllName);

    /*
     * Mask off hiword.
     */
    UserAssert((offTable & ~0xffff) == 0);
    UserAssert((offNlsTable & ~0xffff) == 0);

    /*
     * Initialize KbdNlsTables with NULL.
     */
    pkf->pKbdNlsTbl = NULL;

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    /*
     * Map the layout file into memory
     */
    Status = ZwCreateSection(&hmap, SECTION_MAP_READ, &ObjectAttributes,
                             NULL, PAGE_READONLY, SEC_COMMIT, hFile);
    if (!NT_SUCCESS(Status)) {
        RIPMSGF3(RIP_WARNING, "failed to create a section for %ls, hFile=%p, stat=%08x", pkf->awchDllName, hFile, Status);
        goto exitread;
    }

    Status = ZwMapViewOfSection(hmap, NtCurrentProcess(), &DosHdr, 0, 0, NULL,
                                &ulViewSize, ViewUnmap, 0, PAGE_READONLY);
    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING, "failed to map the view for %ls", pkf->awchDllName);
        goto exitread;
    }

    if (ulViewSize < sizeof *DosHdr || ulViewSize > (128 * 1024)) {
        RIPMSGF1(RIP_WARNING, "ViewSize is too small or large %08x", ulViewSize);
        goto exitread;
    }

    /*
     * We find the .data section in the file header and by
     * subtracting the virtual address from offTable find
     * the offset in the section of the layout table.
     */
    UserAssert(sizeof *NtHeader64 >= sizeof *NtHeader32);

    try {
        NtHeader64 = (PIMAGE_NT_HEADERS64)((PBYTE)DosHdr + (ULONG)DosHdr->e_lfanew);
        NtHeader32 = (PIMAGE_NT_HEADERS32)NtHeader64;


#if defined(_WIN64)
        if ((PBYTE)NtHeader64 < (PBYTE)DosHdr ||           // signed Overflow
                (PBYTE)NtHeader64 + sizeof *NtHeader64  >= (PBYTE)DosHdr + ulViewSize) {
            RIPMSGF1(RIP_WARNING, "Header is out of Range %p", NtHeader64);
            goto exitread;
        }

        fWin64Header = (NtHeader64->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64) ||
                       (NtHeader64->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64);
#else
        if ((PBYTE)NtHeader32 < (PBYTE)DosHdr ||           // signed Overflow
                (PBYTE)NtHeader32 + sizeof *NtHeader32  >= (PBYTE)DosHdr + ulViewSize) {
            RIPMSGF1(RIP_WARNING, "Header is out of Range %p", NtHeader32);
            goto exitread;
        }

        fWin64Header = FALSE;
#endif

        TAGMSGF2(DBGTAG_KBD, "DLL='%ls', Is64=%d", pkf->awchDllName, fWin64Header);

        /*
         * At this point the object table is read in (if it was not
         * already read in) and may displace the image header.
         */
        NumberOfSubsections = GET_HEADER_FIELD(FileHeader.NumberOfSections);

        OffsetToSectionTable = sizeof(ULONG) +                   // Signature
                               sizeof(IMAGE_FILE_HEADER) +       // FileHeader
                               GET_HEADER_FIELD(FileHeader.SizeOfOptionalHeader);

        SectionTableEntry = (PIMAGE_SECTION_HEADER)((PBYTE)NtHeader32 +
                            OffsetToSectionTable);


        while (NumberOfSubsections > 0) {
            /*
             * Validate the SectionTableEntry.
             */
            if ((PBYTE)SectionTableEntry < (PBYTE)DosHdr ||
                (PBYTE)SectionTableEntry + sizeof *SectionTableEntry >= (PBYTE)DosHdr + ulViewSize) {
                RIPMSGF1(RIP_WARNING, "SectionTableEntry @ %p is not within the view section.",
                         SectionTableEntry);
                goto exitread;
            }

            /*
             * Is this the .data section that we are looking for?
             */
            if (strcmp(SectionTableEntry->Name, ".data") == 0) {
                break;
            }

            SectionTableEntry++;
            NumberOfSubsections--;
        }

        if (NumberOfSubsections == 0) {
            RIPMSGF1(RIP_WARNING, "number of sections is 0 for %ls.", pkf->awchDllName);
            goto exitread;
        }

        /*
         * We found the section, now compute starting offset and the table size.
         */
        offTable -= SectionTableEntry->VirtualAddress;
        dwDataSize = SectionTableEntry->Misc.VirtualSize;

        /*
         * Validate the offTable to see if it fits in the section.
         */
        if (offTable >= dwDataSize) {
            RIPMSGF3(RIP_WARNING, "illegal offTable=0x%x or offNlsTable=0x%x, dwDataSize=0x%x",
                     offTable, offNlsTable, dwDataSize);
            goto exitread;
        }

        /*
         * Validate the .data size not exceeding our assumption (<64KB).
         */
        if (dwDataSize >= 0xffff) {
            RIPMSGF1(RIP_WARNING, "unexpected size in .data: 0x%x", dwDataSize);
            goto exitread;
        }

        /*
         * Validate we are not over-shooting our view
         */
        if ((PBYTE)DosHdr + SectionTableEntry->PointerToRawData + dwDataSize >=
            (PBYTE)DosHdr + ulViewSize) {
            RIPMSGF1(RIP_WARNING, "Layout Table @ %p is not within the view section.",
                     (PBYTE)DosHdr + SectionTableEntry->PointerToRawData);
            goto exitread;
        }

        /*
         * Allocate layout table and copy from file.
         */
        TAGMSGF2(DBGTAG_KBD, "data size for '%S' = %x", pkf->awchDllName, dwDataSize);
        pBaseDst = UserAllocPool(dwDataSize, TAG_KBDTABLE);

#if DBG
        if (pBaseDst == NULL) {
            RIPMSGF2(RIP_WARNING, "failed to allocate 0x%x bytes of memory for %ls", dwDataSize, pkf->awchDllName);
        }
#endif

        if (pBaseDst != NULL) {
            VK_TO_WCHAR_TABLE *pVkToWcharTable;
            VSC_LPWSTR *pKeyName;

            pkf->hBase = (HANDLE)pBaseDst;

            RtlMoveMemory(pBaseDst,
                          (PBYTE)DosHdr + SectionTableEntry->PointerToRawData,
                          dwDataSize);

            if (ISTS()) {
                pkf->Size = dwDataSize; // For shadow hotkey processing
            }

            /*
             * Compute table address and fixup pointers in table.
             */
            pktNew = (PKBDTABLES)(pBaseDst + offTable);

            /*
             * The address in the data section has the virtual address
             * added in, so we need to adjust the fixup pointer to
             * compensate.
             */
            pBaseVirt = pBaseDst - SectionTableEntry->VirtualAddress;

            FIXUP_PTR(pktNew->pCharModifiers);
            FIXUP_PTR(pktNew->pCharModifiers->pVkToBit);
            /*
             * Validate pVkToBit table.
             */
            {
                PVK_TO_BIT pVkToBit;

                for (pVkToBit = pktNew->pCharModifiers->pVkToBit; ; pVkToBit++) {
                    VALIDATE_PTR(pVkToBit);
                    if (pVkToBit->Vk == 0) {
                        break;
                    }
                }
            }

            FIXUP_PTR(pktNew->pVkToWcharTable);
#if DBG
            if (pktNew->pVkToWcharTable == NULL) {
                RIPMSGF1(RIP_WARNING, "KL %ls does not have pVkToWcharTable???", pkf->awchDllName);
            }
#endif
            if (pktNew->pVkToWcharTable) {
                /*
                 * Fix up and validate VkToWchar table.
                 */
                for (pVkToWcharTable = pktNew->pVkToWcharTable; ; pVkToWcharTable++) {
                    VALIDATE_PTR(pVkToWcharTable);
                    if (pVkToWcharTable->pVkToWchars == NULL) {
                        break;
                    }
                    FIXUP_PTR(pVkToWcharTable->pVkToWchars);
                }
            }

            FIXUP_PTR(pktNew->pDeadKey);
            /*
             * Validate pDeadKey array.
             */
            {
                PDEADKEY pDeadKey = pktNew->pDeadKey;
                while (pDeadKey) {
                    VALIDATE_PTR(pDeadKey);
                    if (pDeadKey->dwBoth == 0) {
                        break;
                    }
                    pDeadKey++;
                }
            }

            /*
             * Version 1 layouts support ligatures.
             */
            if (GET_KBD_VERSION(pktNew)) {
                FIXUP_PTR(pktNew->pLigature);
            }

            FIXUP_PTR(pktNew->pKeyNames);
            if (pktNew->pKeyNames == NULL) {
                RIPMSGF1(RIP_WARNING, "KL %ls does not have pKeyNames???", pkf->awchDllName);
            }

            if (pktNew->pKeyNames) {
                for (pKeyName = pktNew->pKeyNames; ; pKeyName++) {
                    VALIDATE_PTR(pKeyName);
                    if (pKeyName->vsc == 0) {
                        break;
                    }
                    FIXUP_PTR(pKeyName->pwsz);
                }
            }

            FIXUP_PTR(pktNew->pKeyNamesExt);
            if (pktNew->pKeyNamesExt) {
                for (pKeyName = pktNew->pKeyNamesExt; ; pKeyName++) {
                    VALIDATE_PTR(pKeyName);
                    if (pKeyName->vsc == 0) {
                        break;
                    }
                    FIXUP_PTR(pKeyName->pwsz);
                }
            }

            FIXUP_PTR(pktNew->pKeyNamesDead);
            if (pktNew->pKeyNamesDead) {
                LPWSTR *lpDeadKey;
                for (lpDeadKey = pktNew->pKeyNamesDead; ; lpDeadKey++) {
                    LPCWSTR lpwstr;

                    VALIDATE_PTR(lpDeadKey);
                    if (*lpDeadKey == NULL) {
                        break;
                    }
                    FIXUP_PTR(*lpDeadKey);
                    UserAssert(*lpDeadKey);
                    for (lpwstr = *lpDeadKey; ; lpwstr++) {
                        VALIDATE_PTR(lpwstr);
                        if (*lpwstr == L'\0') {
                            break;
                        }
                    }
                };
            }

            /*
             * Fix up and validate Virtual Scan Code to VK table.
             */
            if (pktNew->pusVSCtoVK == NULL) {
                RIPMSGF1(RIP_WARNING, "KL %ls does not have the basic VSC to VK table", pkf->awchDllName);
                goto exitread;
            }
            FIXUP_PTR(pktNew->pusVSCtoVK);
            VALIDATE_PTR(pktNew->pusVSCtoVK + pktNew->bMaxVSCtoVK);

            FIXUP_PTR(pktNew->pVSCtoVK_E0);
            if (pktNew->pVSCtoVK_E0) {
                PVSC_VK pVscVk;
                for (pVscVk = pktNew->pVSCtoVK_E0; pVscVk->Vk; pVscVk++) {
                    VALIDATE_PTR(pVscVk);
                }
            }

            FIXUP_PTR(pktNew->pVSCtoVK_E1);
            if (pktNew->pVSCtoVK_E1) {
                PVSC_VK pVscVk;
                for (pVscVk = pktNew->pVSCtoVK_E1; ; pVscVk++) {
                    VALIDATE_PTR(pVscVk);
                    if (pVscVk->Vk == 0) {
                        break;
                    }
                }
            }

            if (offNlsTable) {
                /*
                 * Compute table address and fixup pointers in table.
                 */
                offNlsTable -= SectionTableEntry->VirtualAddress;
                pknlstNew = (PKBDNLSTABLES)(pBaseDst + offNlsTable);

                VALIDATE_PTR(pknlstNew);

                /*
                 * Fixup and validate the address.
                 */
                FIXUP_PTR(pknlstNew->pVkToF);
                if (pknlstNew->pVkToF) {
                    VALIDATE_PTR(&pknlstNew->pVkToF[pknlstNew->NumOfVkToF - 1]);
                }


                FIXUP_PTR(pknlstNew->pusMouseVKey);
                if (pknlstNew->pusMouseVKey) {
                    VALIDATE_PTR(&pknlstNew->pusMouseVKey[pknlstNew->NumOfMouseVKey - 1]);
                }

                /*
                 * Save the pointer.
                 */
                pkf->pKbdNlsTbl = pknlstNew;

            #if DBG_FE
                {
                    UINT NumOfVkToF = pknlstNew->NumOfVkToF;

                    DbgPrint("NumOfVkToF - %d\n",NumOfVkToF);

                    while(NumOfVkToF) {
                        DbgPrint("VK = %x\n",pknlstNew->pVkToF[NumOfVkToF-1].Vk);
                        NumOfVkToF--;
                    }
                }
            #endif  // DBG_FE
            }
        }

    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
          RIPMSGF1(RIP_WARNING, "took exception reading from %ls", pkf->awchDllName);
          goto exitread;
    }

    fSucceeded = TRUE;
exitread:

    if (!fSucceeded && pBaseDst) {
        UserFreePool(pBaseDst);
    }

    /*
     * Unmap and release the mapped section.
     */
    if (DosHdr) {
        ZwUnmapViewOfSection(NtCurrentProcess(), DosHdr);
    }

    if (hmap != NULL) {
        ZwClose(hmap);
    }

    TAGMSGF1(DBGTAG_KBD, "returning pkl = %p", pktNew);

    if (!fSucceeded) {
        return NULL;
    }

    return pktNew;
}

PKBDTABLES PrepareFallbackKeyboardFile(PKBDFILE pkf)
{
    PBYTE pBaseDst;

    pBaseDst = UserAllocPool(sizeof(KBDTABLES), TAG_KBDTABLE);
    if (pBaseDst != NULL) {
        RtlCopyMemory(pBaseDst, &KbdTablesFallback, sizeof KbdTablesFallback);
        // Note: Unlike ReadLayoutFile(),
        // we don't need to fix up pointers in struct KBDFILE.
    }
    pkf->hBase = (HANDLE)pBaseDst;
    pkf->pKbdNlsTbl = NULL;
    return (PKBDTABLES)pBaseDst;
}


/***************************************************************************\
* LoadKeyboardLayoutFile
*
* History:
* 10-29-95 GregoryW         Created.
\***************************************************************************/

PKBDFILE LoadKeyboardLayoutFile(
    HANDLE hFile,
    UINT offTable,
    UINT offNlsTable,
    LPCWSTR pwszKLID,
    LPWSTR pwszDllName,
    DWORD dwType,
    DWORD dwSubType)
{
    PKBDFILE pkf = gpkfList;

    TAGMSG4(DBGTAG_KBD | RIP_THERESMORE, "LoadKeyboardLayoutFile: new KL=%S, dllName='%S', %d:%d",
            pwszKLID, pwszDllName ? pwszDllName : L"",
            dwType, dwSubType);
    UNREFERENCED_PARAMETER(pwszKLID);

    /*
     * Search for the existing layout file.
     */
    if (pkf) {
        do {
            TAGMSG3(DBGTAG_KBD | RIP_THERESMORE, "LoadKeyboardLayoutFile: looking at dll=%S, %d:%d",
                    pkf->awchDllName,
                    pkf->pKbdTbl->dwType, pkf->pKbdTbl->dwSubType);
            if (pwszDllName && _wcsicmp(pkf->awchDllName, pwszDllName) == 0) {
                /*
                 * The layout is already loaded.
                 */
                TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutFile: duplicated KBDFILE found(#1). pwszDllName='%ls'\n", pwszDllName);
                return pkf;
            }
            pkf = pkf->pkfNext;
        } while (pkf);
    }
    TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutFile: layout %S is not yet loaded.", pwszDllName);

    /*
     * Allocate a new Keyboard File structure.
     */
    pkf = (PKBDFILE)HMAllocObject(NULL, NULL, TYPE_KBDFILE, sizeof(KBDFILE));
    if (!pkf) {
        RIPMSG0(RIP_WARNING, "Keyboard Layout File: out of memory");
        return (PKBDFILE)NULL;
    }

    /*
     * Load layout table.
     */
    if (hFile != NULL) {
        /*
         * Load NLS layout table also...
         */
        wcsncpycch(pkf->awchDllName, pwszDllName, ARRAY_SIZE(pkf->awchDllName));
        pkf->awchDllName[ARRAY_SIZE(pkf->awchDllName) - 1] = 0;
        pkf->pKbdTbl = ReadLayoutFile(pkf, hFile, offTable, offNlsTable);
        if (dwType || dwSubType) {
            pkf->pKbdTbl->dwType = dwType;
            pkf->pKbdTbl->dwSubType = dwSubType;
        }
    } else {
        /*
         * We failed to open the keyboard layout file in client side
         * because the dll was missing.
         * If this ever happens, we used to fail creating
         * a window station, but we should allow a user
         * at least to boot the system.
         */
        TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutFile: hFile is NULL for %ls, preparing the fallback.", pwszDllName);
        pkf->pKbdTbl = PrepareFallbackKeyboardFile(pkf);
        // Note: pkf->pKbdNlsTbl has been NULL'ed in PrepareFallbackKeyboardFile()
    }

    if (pkf->pKbdTbl == NULL) {
        RIPMSG0(RIP_WARNING, "LoadKeyboardLayoutFile: pkf->pKbdTbl is NULL.");
        HMFreeObject(pkf);
        return (PKBDFILE)NULL;
    }

    /*
     * Put keyboard layout file at front of list.
     */
    pkf->pkfNext = gpkfList;
    gpkfList = pkf;

    return pkf;
}

/***************************************************************************\
* RemoveKeyboardLayoutFile
*
* History:
* 10-29-95 GregoryW         Created.
\***************************************************************************/
VOID RemoveKeyboardLayoutFile(
    PKBDFILE pkf)
{
    PKBDFILE pkfPrev, pkfCur;

    // FE: NT4 SP4 #107809
    if (gpKbdTbl == pkf->pKbdTbl) {
        gpKbdTbl = &KbdTablesFallback;
    }
    if (gpKbdNlsTbl == pkf->pKbdNlsTbl) {
        gpKbdNlsTbl = NULL;
    }

    /*
     * Good old linked list management 101
     */
    if (pkf == gpkfList) {
        /*
         * Head of the list.
         */
        gpkfList = pkf->pkfNext;
        return;
    }
    pkfPrev = gpkfList;
    pkfCur = gpkfList->pkfNext;
    while (pkf != pkfCur) {
        pkfPrev = pkfCur;
        pkfCur = pkfCur->pkfNext;
    }
    /*
     * Found it!
     */
    pkfPrev->pkfNext = pkfCur->pkfNext;
}

/***************************************************************************\
* DestroyKF
*
* Called when a keyboard layout file is destroyed due to an unlock.
*
* History:
* 24-Feb-1997 adams     Created.
\***************************************************************************/

void
DestroyKF(PKBDFILE pkf)
{
    if (!HMMarkObjectDestroy(pkf))
        return;

    RemoveKeyboardLayoutFile(pkf);
    UserFreePool(pkf->hBase);
    HMFreeObject(pkf);
}

INT GetThreadsWithPKL(
    PTHREADINFO **ppptiList,
    PKL pkl)
{
    PTHREADINFO     ptiT, *pptiT, *pptiListAllocated;
    INT             cThreads, cThreadsAllocated;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    PLIST_ENTRY     pHead, pEntry;

    if (ppptiList != NULL)
        *ppptiList = NULL;

    cThreads = 0;

    /*
     * allocate a first list for 128 entries
     */
    cThreadsAllocated = 128;
    pptiListAllocated = UserAllocPool(cThreadsAllocated * sizeof(PTHREADINFO),
                            TAG_SYSTEM);

    if (pptiListAllocated == NULL) {
        RIPMSG0(RIP_WARNING, "GetPKLinThreads: out of memory");
        return 0;
    }

    // for all the winstations
    for (pwinsta = grpWinStaList; pwinsta != NULL ; pwinsta = pwinsta->rpwinstaNext) {

        // for all the desktops in that winstation
        for (pdesk = pwinsta->rpdeskList; pdesk != NULL ; pdesk = pdesk->rpdeskNext) {

            pHead = &pdesk->PtiList;

            // for all the threads in that desktop
            for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

                ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

                if (ptiT == NULL) {
                    continue;
                }

                if (pkl && (pkl != ptiT->spklActive)) { // #99321 cmp pkls, not hkls?
                    continue;
                }

                /*
                 * WindowsBug 349045
                 * Unload IMEs only for the normal apps.... leave them as is if they are
                 * loaded for services.
                 * Note, this is not really a clean fix, but some customers demand it.
                 */
                UserAssert(PsGetCurrentProcessId() == gpidLogon);
                if (ptiT->ppi->Process != gpepCSRSS && ptiT->ppi->Process != PsGetCurrentProcess()) {
                    /*
                     * By the time this routine is called (solely by WinLogon), all the other
                     * applications should be gone or terminated. So skipping like above
                     * leaves IMEs loaded in the services.
                     */
                    continue;
                }

                if (cThreads == cThreadsAllocated) {

                    cThreadsAllocated += 128;

                    pptiT = UserReAllocPool(pptiListAllocated,
                                    cThreads * sizeof(PTHREADINFO),
                                    cThreadsAllocated * sizeof(PTHREADINFO),
                                    TAG_SYSTEM);

                    if (pptiT == NULL) {
                        RIPMSG0(RIP_ERROR, "GetPKLinThreads: Out of memory");
                        UserFreePool(pptiListAllocated);
                        return 0;
                    }

                    pptiListAllocated = pptiT;

                }

                pptiListAllocated[cThreads++] = ptiT;
            }
        }
    }

    /*
     * add CSRSS threads
     */
    for (ptiT = PpiFromProcess(gpepCSRSS)->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {

        if (pkl && (pkl != ptiT->spklActive)) { // #99321 cmp pkls, not hkls?
            continue;
        }

        if (cThreads == cThreadsAllocated) {

            cThreadsAllocated += 128;

            pptiT = UserReAllocPool(pptiListAllocated,
                            cThreads * sizeof(PTHREADINFO),
                            cThreadsAllocated * sizeof(PTHREADINFO),
                            TAG_SYSTEM);

            if (pptiT == NULL) {
                RIPMSG0(RIP_ERROR, "GetPKLinThreads: Out of memory");
                UserFreePool(pptiListAllocated);
                return 0;
            }

            pptiListAllocated = pptiT;

        }

        pptiListAllocated[cThreads++] = ptiT;
    }

    if (cThreads == 0) {
        UserFreePool(pptiListAllocated);
    } else if (ppptiList != NULL) {
        *ppptiList = pptiListAllocated;
    } else {
        UserFreePool(pptiListAllocated);
    }

    return cThreads;
}


VOID xxxSetPKLinThreads(
    PKL pklNew,
    PKL pklToBeReplaced)
{
    PTHREADINFO *pptiList;
    INT cThreads, i;

    UserAssert(pklNew != pklToBeReplaced);

    CheckLock(pklNew);
    CheckLock(pklToBeReplaced);

    cThreads = GetThreadsWithPKL(&pptiList, pklToBeReplaced);

    /*
     * Will the foreground thread's keyboard layout change?
     */
    if (pklNew && gptiForeground && gptiForeground->spklActive == pklToBeReplaced) {
        ChangeForegroundKeyboardTable(pklToBeReplaced, pklNew);
    }

    if (pptiList != NULL) {
        if (pklToBeReplaced == NULL) {
            for (i = 0; i < cThreads; i++) {
                Lock(&pptiList[i]->spklActive, pklNew);
            }
        } else {
            /*
             * This is a replace. First, deactivate the *replaced* IME by
             * activating the pklNew. Second, unload the *replaced* IME.
             */
            xxxImmActivateAndUnloadThreadsLayout(pptiList, cThreads, NULL,
                                                 pklNew, HandleToUlong(pklToBeReplaced->hkl));
        }
        UserFreePool(pptiList);
    }

    /*
     * If this is a replace, link the new layout immediately after the
     * layout being replaced.  This maintains ordering of layouts when
     * the *replaced* layout is unloaded.  The input locale panel in the
     * regional settings applet depends on this.
     */
    if (pklToBeReplaced) {
        if (pklToBeReplaced->pklNext == pklNew) {
            /*
             * Ordering already correct.  Nothing to do.
             */
            return;
        }
        /*
         * Move new layout immediately after layout being replaced.
         *   1. Remove new layout from current position.
         *   2. Update links in new layout.
         *   3. Link new layout into desired position.
         */
        pklNew->pklPrev->pklNext = pklNew->pklNext;
        pklNew->pklNext->pklPrev = pklNew->pklPrev;

        pklNew->pklNext = pklToBeReplaced->pklNext;
        pklNew->pklPrev = pklToBeReplaced;

        pklToBeReplaced->pklNext->pklPrev = pklNew;
        pklToBeReplaced->pklNext = pklNew;
    }
}

VOID xxxFreeImeKeyboardLayouts(
    PWINDOWSTATION pwinsta)
{
    PTHREADINFO *pptiList;
    INT cThreads;

    if (pwinsta->dwWSF_Flags & WSF_NOIO)
        return;

    /*
     * should make GetThreadsWithPKL aware of pwinsta?
     */
    cThreads = GetThreadsWithPKL(&pptiList, NULL);
    if (pptiList != NULL) {
        xxxImmUnloadThreadsLayout(pptiList, cThreads, NULL, IFL_UNLOADIME);
        UserFreePool(pptiList);
    }

    return;
}

/***************************************************************************\
* xxxLoadKeyboardLayoutEx
*
* History:
\***************************************************************************/

HKL xxxLoadKeyboardLayoutEx(
    PWINDOWSTATION pwinsta,
    HANDLE hFile,
    HKL hklToBeReplaced,
    UINT offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    LPCWSTR pwszKLID,
    UINT KbdInputLocale,
    UINT Flags)
{
    PKL pkl, pklFirst, pklToBeReplaced;
    PKBDFILE pkf;
    CHARSETINFO cs;
    TL tlpkl;
    PTHREADINFO ptiCurrent;
    UNICODE_STRING strLcidKF;
    UNICODE_STRING strKLID;
    LCID lcidKF;
    BOOL bCharSet;
    PIMEINFOEX piiex;


    TAGMSG1(DBGTAG_KBD, "xxxLoadKeyboardLayoutEx: new KL: pwszKLID=\"%ls\"", pwszKLID);

    /*
     * If the windowstation does not do I/O, don't load the
     * layout.  Also check KdbInputLocale for #307132
     */
    if ((KbdInputLocale == 0) || (pwinsta->dwWSF_Flags & WSF_NOIO)) {
        return NULL;
    }

    /*
     * If hklToBeReplaced is non-NULL make sure it's valid.
     *    NOTE: may want to verify they're not passing HKL_NEXT or HKL_PREV.
     */
    ptiCurrent = PtiCurrent();
    if (hklToBeReplaced && !(pklToBeReplaced = HKLtoPKL(ptiCurrent, hklToBeReplaced))) {
        return NULL;
    }
    if (KbdInputLocale == HandleToUlong(hklToBeReplaced)) {
        /*
         * Replacing a layout/lang pair with itself.  Nothing to do.
         */
        return pklToBeReplaced->hkl;
    }

    if (Flags & KLF_RESET) {
        /*
         * Only WinLogon can use this flag
         */
        if (PsGetThreadProcessId(ptiCurrent->pEThread) != gpidLogon) {
             RIPERR0(ERROR_INVALID_FLAGS, RIP_WARNING,
                     "Invalid flag passed to LoadKeyboardLayout" );
             return NULL;
        }
        xxxFreeImeKeyboardLayouts(pwinsta);
        /*
         * Make sure we don't lose track of the left-over layouts
         * They have been unloaded, but are still in use by some threads).
         * The FALSE will prevent xxxFreeKeyboardLayouts from unlocking the
         * unloaded layouts.
         */
        xxxFreeKeyboardLayouts(pwinsta, FALSE);
    }

    /*
     * Does this hkl already exist?
     */
    pkl = pklFirst = pwinsta->spklList;

    if (pkl) {
        do {
            if (pkl->hkl == (HKL)IntToPtr( KbdInputLocale )) {
               /*
                * The hkl already exists.
                */

               /*
                * If it is unloaded (but not yet destroyed because it is
                * still is use), recover it.
                */
               if (pkl->dwKL_Flags & KL_UNLOADED) {
                   // stop it from being destroyed if not is use.
                   PHE phe = HMPheFromObject(pkl);
                   // An unloaded layout must be marked for destroy.
                   UserAssert(phe->bFlags & HANDLEF_DESTROY);
                   phe->bFlags &= ~HANDLEF_DESTROY;
#if DBG
                   phe->bFlags &= ~HANDLEF_MARKED_OK;
#endif
                   pkl->dwKL_Flags &= ~KL_UNLOADED;
               } else if (!(Flags & KLF_RESET)) {
                   /*
                    * If it was already loaded and we didn't change all layouts
                    * with KLF_RESET, there is nothing to tell the shell about
                    */
                   Flags &= ~KLF_NOTELLSHELL;
               }

               goto AllPresentAndCorrectSir;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklFirst);
    }

    if (IS_IME_KBDLAYOUT((HKL)IntToPtr( KbdInputLocale ))
#ifdef CUAS_ENABLE
        ||
        IS_CICERO_ENABLED_AND_NOT16BIT()
#endif // CUAS_ENABLE
       ) {
        /*
         * This is an IME keyboard layout, do a callback
         * to read the extended IME information structure.
         * Note: We can't fail the call so easily if
         *       KLF_RESET is specified.
         */
        piiex = xxxImmLoadLayout((HKL)IntToPtr( KbdInputLocale ));
        if (piiex == NULL && (Flags & (KLF_RESET | KLF_INITTIME)) == 0) {
            /*
             * Not Resetting, not creating a window station
             */
            RIPMSG1(RIP_WARNING,
                  "Keyboard Layout: xxxImmLoadLayout(%lx) failed", KbdInputLocale);
            return NULL;
        }
    } else {
        piiex = NULL;
    }

    /*
     * Get the system font's font signature.  These are 64-bit FS_xxx values,
     * but we are only asking for an  ANSI ones, so gSystemFS is just a DWORD.
     * gSystemFS is consulted when posting WM_INPUTLANGCHANGEREQUEST (input.c)
     */
    if (gSystemFS == 0) {
        LCID lcid;

        ZwQueryDefaultLocale(FALSE, &lcid);
        if (xxxClientGetCharsetInfo(lcid, &cs)) {
            gSystemFS = cs.fs.fsCsb[0];
            gSystemCPCharSet = (BYTE)cs.ciCharset;
        } else {
            gSystemFS = 0xFFFF;
            gSystemCPCharSet = ANSI_CHARSET;
        }
    }

    /*
     * Use the Keyboard Layout's LCID to calculate the charset, codepage etc,
     * so that characters from that layout don't just becomes ?s if the input
     * locale doesn't match.  This allows "dumb" applications to display the
     * text if the user chooses the right font.
     * We can't just use the HIWORD of KbdInputLocale because if a variant
     * keyboard layout was chosen, this will be something like F008 - have to
     * look inside the KF to get the real LCID of the kbdfile: this will be
     * something like L"00010419", and we want the last 4 digits.
     */
    RtlInitUnicodeString(&strLcidKF, pwszKLID + 4);
    RtlUnicodeStringToInteger(&strLcidKF, 16, (PULONG)&lcidKF);
    bCharSet = xxxClientGetCharsetInfo(lcidKF, &cs);

    /*
     * Keyboard Layout Handle object does not exist.  Load keyboard layout file,
     * if not already loaded.
     */
    if ((pkf = LoadKeyboardLayoutFile(hFile, LOWORD(offTable), HIWORD(offTable), pwszKLID, pKbdTableMulti->wszDllName, 0, 0)) == NULL) {
        goto freePiiex;
    }
    /*
     * Allocate a new Keyboard Layout structure (hkl)
     */
    pkl = (PKL)HMAllocObject(NULL, NULL, TYPE_KBDLAYOUT, sizeof(KL));
    if (!pkl) {
        RIPMSG0(RIP_WARNING, "Keyboard Layout: out of memory");
        UserFreePool(pkf->hBase);
        HMMarkObjectDestroy(pkf);
        HMUnlockObject(pkf);
freePiiex:
        if (piiex) {
            UserFreePool(piiex);
        }
        return NULL;
    }

    Lock(&pkl->spkfPrimary, pkf);

    /*
     * Load extra keyboard layouts.
     */
    UserAssert(pKbdTableMulti);
    if (pKbdTableMulti->multi.nTables) {
        RIPMSG0(RIP_WARNING, "xxxLoadKeyboardLayoutEx: going to read multiple tables.");
        /*
         * Allocate the array for extra keyboard layouts.
         */
        UserAssert(pKbdTableMulti->multi.nTables < KBDTABLE_MULTI_MAX); // check exists in the stub
        pkl->pspkfExtra = UserAllocPoolZInit(pKbdTableMulti->multi.nTables * sizeof(PKBDFILE), TAG_KBDTABLE);
        if (pkl->pspkfExtra) {
            UINT i;
            UINT n;

            /*
             * Load the extra keyboard layouts and lock them.
             */
            for (i = 0, n = 0; i < pKbdTableMulti->multi.nTables; ++i) {
                UserAssert(i < KBDTABLE_MULTI_MAX);
                if (pKbdTableMulti->files[i].hFile) {
                    // make sure dll name is null terminated.
                    pKbdTableMulti->multi.aKbdTables[i].wszDllName[ARRAY_SIZE(pKbdTableMulti->multi.aKbdTables[i].wszDllName) - 1] = 0;
                    // load it.
                    pkf = LoadKeyboardLayoutFile(pKbdTableMulti->files[i].hFile,
                                                 pKbdTableMulti->files[i].wTable,
                                                 pKbdTableMulti->files[i].wNls,
                                                 pwszKLID,
                                                 pKbdTableMulti->multi.aKbdTables[i].wszDllName,
                                                 pKbdTableMulti->multi.aKbdTables[i].dwType,
                                                 pKbdTableMulti->multi.aKbdTables[i].dwSubType);
                    if (pkf == NULL) {
                        // If allocation fails, simply exit this loop and continue KL creation.
                        RIPMSG0(RIP_WARNING, "xxxLoadKeyboardLayoutEx: failed to load the extra keyboard layout file(s).");
                        break;
                    }

                    Lock(&pkl->pspkfExtra[n], pkf);
                    ++n;
                } else {
                    RIPMSG2(RIP_WARNING, "xxxLoadKeyboardLayoutEx: pKbdTableMulti(%#p)->files[%x].hFile is NULL",
                            pKbdTableMulti, i);
                }
            }
            pkl->uNumTbl = n;
        }
    }

    /*
     * Link to itself in case we have to DestroyKL
     */
    pkl->pklNext = pkl;
    pkl->pklPrev = pkl;

    /*
     * Init KL
     */
    pkl->dwKL_Flags = 0;
    pkl->wchDiacritic = 0;
    pkl->hkl = (HKL)IntToPtr( KbdInputLocale );
    RtlInitUnicodeString(&strKLID, pwszKLID);
    RtlUnicodeStringToInteger(&strKLID, 16, &pkl->dwKLID);
    TAGMSG2(DBGTAG_KBD, "xxxLoadKeyboardLayoutEx: hkl %08p KLID:%08x", pkl->hkl, pkl->dwKLID);

    Lock(&pkl->spkf, pkl->spkfPrimary);
    pkl->dwLastKbdType = pkl->spkf->pKbdTbl->dwType;
    pkl->dwLastKbdSubType = pkl->spkf->pKbdTbl->dwSubType;

    pkl->spkf->pKbdTbl->fLocaleFlags |= KLL_LAYOUT_ATTR_FROM_KLF(Flags);

    pkl->piiex = piiex;

    if (bCharSet) {
        pkl->CodePage = (WORD)cs.ciACP;
        pkl->dwFontSigs = cs.fs.fsCsb[1];   // font signature mask (FS_xxx values)
        pkl->iBaseCharset = cs.ciCharset;   // charset value
    } else {
        pkl->CodePage = CP_ACP;
        pkl->dwFontSigs = FS_LATIN1;
        pkl->iBaseCharset = ANSI_CHARSET;
    }

    /*
     * Insert KL in the double-linked circular list, at the end.
     */
    pklFirst = pwinsta->spklList;
    if (pklFirst == NULL) {
        Lock(&pwinsta->spklList, pkl);
    } else {
        pkl->pklNext = pklFirst;
        pkl->pklPrev = pklFirst->pklPrev;
        pklFirst->pklPrev->pklNext = pkl;
        pklFirst->pklPrev = pkl;
    }

AllPresentAndCorrectSir:

    // FE_IME
    ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlpkl);

    if (hklToBeReplaced) {
        TL tlPKLToBeReplaced;
        ThreadLockAlwaysWithPti(ptiCurrent, pklToBeReplaced, &tlPKLToBeReplaced);
        xxxSetPKLinThreads(pkl, pklToBeReplaced);
        xxxInternalUnloadKeyboardLayout(pwinsta, pklToBeReplaced, KLF_INITTIME);
        ThreadUnlock(&tlPKLToBeReplaced);
    }

    if (Flags & KLF_REORDER) {
        ReorderKeyboardLayouts(pwinsta, pkl);
    }

    if (!(Flags & KLF_NOTELLSHELL) && IsHooked(PtiCurrent(), WHF_SHELL)) {
        xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)0, WH_SHELL);
        gLCIDSentToShell = 0;
    }

    if (Flags & KLF_ACTIVATE) {
        TL tlPKL;
        ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlPKL);
        xxxInternalActivateKeyboardLayout(pkl, Flags, NULL);
        ThreadUnlock(&tlPKL);
    }

    if (Flags & KLF_RESET) {
        RIPMSG2(RIP_VERBOSE, "Flag & KLF_RESET, locking gspklBaseLayout(%08x) with new kl(%08x)",
                gspklBaseLayout ? gspklBaseLayout->hkl : 0,
                pkl->hkl);
        Lock(&gspklBaseLayout, pkl);
        xxxSetPKLinThreads(pkl, NULL);
    }

    /*
     * Use the hkl as the layout handle
     * If the KL is freed somehow, return NULL for safety. -- ianja --
     */
    pkl = ThreadUnlock(&tlpkl);
    if (pkl == NULL) {
        return NULL;
    }
    return pkl->hkl;
}

HKL xxxActivateKeyboardLayout(
    PWINDOWSTATION pwinsta,
    HKL hkl,
    UINT Flags,
    PWND pwnd)
{
    PKL pkl;
    TL tlPKL;
    HKL hklRet;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);

    pkl = HKLtoPKL(ptiCurrent, hkl);
    if (pkl == NULL) {
        return 0;
    }

    if (Flags & KLF_REORDER) {
        ReorderKeyboardLayouts(pwinsta, pkl);
    }

    ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlPKL);
    hklRet = xxxInternalActivateKeyboardLayout(pkl, Flags, pwnd);
    ThreadUnlock(&tlPKL);
    return hklRet;
}

VOID ReorderKeyboardLayouts(
    PWINDOWSTATION pwinsta,
    PKL pkl)
{
    PKL pklFirst = pwinsta->spklList;

    if (pwinsta->dwWSF_Flags & WSF_NOIO) {
        RIPMSG1(RIP_WARNING, "ReorderKeyboardLayouts called for non-interactive windowstation %#p",
                pwinsta);
        return;
    }

    UserAssert(pklFirst != NULL);

    /*
     * If the layout is already at the front of the list there's nothing to do.
     */
    if (pkl == pklFirst) {
        return;
    }
    /*
     * Cut pkl from circular list:
     */
    pkl->pklPrev->pklNext = pkl->pklNext;
    pkl->pklNext->pklPrev = pkl->pklPrev;

    /*
     * Insert pkl at front of list
     */
    pkl->pklNext = pklFirst;
    pkl->pklPrev = pklFirst->pklPrev;

    pklFirst->pklPrev->pklNext = pkl;
    pklFirst->pklPrev = pkl;

    Lock(&pwinsta->spklList, pkl);
}

extern VOID AdjustPushStateForKL(PTHREADINFO ptiCurrent, PBYTE pbDone, PKL pklTarget, PKL pklPrev, PKL pklNew);
extern void ResetPushState(PTHREADINFO pti, UINT uVk);

VOID ManageKeyboardModifiers(PKL pklPrev, PKL pkl)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    if (ptiCurrent->pq) {
        if (pklPrev) {
            BYTE baDone[256 / 8];

            RtlZeroMemory(baDone, sizeof baDone);

            /*
             * Clear the toggle state if needed. First check the modifier keys
             * of pklPrev. Next check the modifier keys of pklNew.
             */
            TAGMSG2(DBGTAG_IMM, "Changing KL from %08lx to %08lx", pklPrev->hkl, pkl->hkl);
            AdjustPushStateForKL(ptiCurrent, baDone, pklPrev, pklPrev, pkl);
            AdjustPushStateForKL(ptiCurrent, baDone, pkl, pklPrev, pkl);

            if (pklPrev->spkf && (pklPrev->spkf->pKbdTbl->fLocaleFlags & KLLF_ALTGR)) {
                if (!TestRawKeyDown(VK_CONTROL)) {
                    /*
                     * If the previous keyboard has AltGr, and if the Ctrl key is not
                     * physically down, clear the left control.
                     * See xxxAltGr().
                     */
                    TAGMSG0(DBGTAG_KBD, "Clearing VK_LCONTROL for AltGr\n");
                    xxxKeyEvent(VK_LCONTROL | KBDBREAK, 0x1D | SCANCODE_SIMULATED, 0, 0,
#ifdef GENERIC_INPUT
                                NULL,
                                NULL,
#endif
                                FALSE);
                }
            }
        }
        else {
            /*
             * If the current keyboard is unknown, clear all the push state.
             */
            int i;
            for (i = 0; i < CBKEYSTATE; i++) {
                ptiCurrent->pq->afKeyState[i] &= KEYSTATE_TOGGLE_BYTEMASK;
                gafAsyncKeyState[i] &= KEYSTATE_TOGGLE_BYTEMASK;
                gafRawKeyState[i] &= KEYSTATE_TOGGLE_BYTEMASK;
            }
        }
    }
}

void SetGlobalKeyboardTableInfo(PKL pklNew)
{
    CheckCritIn();
    UserAssert(pklNew);

    /*
     * Set gpKbdTbl so foreground thread processes AltGr appropriately
     */
    gpKbdTbl = pklNew->spkf->pKbdTbl;
    if (gpKL != pklNew) {
        gpKL = pklNew;
    }
    if (ISTS()) {
        ghKbdTblBase = pklNew->spkf->hBase;
        guKbdTblSize = pklNew->spkf->Size;
    }

    TAGMSG1(DBGTAG_KBD, "SetGlobalKeyboardTableInfo:Changing KL NLS Table: new HKL=%#p\n", pklNew->hkl);
    TAGMSG1(DBGTAG_KBD, "SetGlobalKeyboardTableInfo: new gpKbdNlsTbl=%#p\n", pklNew->spkf->pKbdNlsTbl);

    gpKbdNlsTbl = pklNew->spkf->pKbdNlsTbl;
}

VOID ChangeForegroundKeyboardTable(PKL pklOld, PKL pklNew)
{
    CheckCritIn();
    UserAssert(pklNew != NULL);

    if ((pklOld == pklNew || (pklOld != NULL && pklOld->spkf == pklNew->spkf)) && gpKL) {
        return;
    }

    /*
     * Some keys (pressed to switch layout) may still be down.  When these come
     * back up, they may have different VK values due to the new layout, so the
     * original key will be left stuck down. (eg: an ISV layout from Attachmate
     * and the CAN/CSA layout, both of which redefine the right-hand Ctrl key's
     * VK so switching to that layout with right Ctrl+Shift will leave the Ctrl
     * stuck down).
     * The solution is to clear all the keydown bits whenever we switch layouts
     * (leaving the toggle bits alone to preserve CapsLock, NumLock etc.). This
     * also solves the AltGr problem, where the simulated Ctrl key doesn't come
     * back up if we switch to a non-AltGr layout before releasing AltGr - IanJa
     *
     * Clear down bits only if necessary --- i.e. if the VK value differs between
     * old and new keyboard layout. We have to take complex path for some of the
     * keys, like Ctrl or Alt, may have left and right equivalents. - HiroYama
     */
    ManageKeyboardModifiers(pklOld, pklNew);

    // Manage the VK_KANA toggle key for Japanese KL.
    // Since VK_HANGUL and VK_KANA share the same VK value and
    // VK_KANA is a toggle key, when keyboard layouts are switched,
    // VK_KANA toggle status should be restored.

    //
    // If:
    // 1) Old and New keyboard layouts are both Japanese, do nothing.
    // 2) Old and New keyboard layouts are not Japanese, do nothing.
    // 3) Old keyboard is Japanese and new one is not, clear the KANA toggle.
    // 4) New keyboard is Japanese and old one is not, restore the KANA toggle.
    //

    {
        enum { KANA_NOOP, KANA_SET, KANA_CLEAR } opKanaToggle = KANA_NOOP;

        if (JAPANESE_KBD_LAYOUT(pklNew->hkl)) {
            if (pklOld == NULL) {
                /*
                 * Let's honor the current async toggle state
                 * if the old KL is not specified.
                 */
                TAGMSG0(DBGTAG_KBD, "VK_KANA: previous KL is NULL, honoring the async toggle state.");
                gfKanaToggle = (TestAsyncKeyStateToggle(VK_KANA) != 0);
                opKanaToggle = gfKanaToggle ? KANA_SET : KANA_CLEAR;
            } else if (!JAPANESE_KBD_LAYOUT(pklOld->hkl)) {
                /*
                 * We're switching from non JPN KL to JPN.
                 * Need to restore the KANA toggle state.
                 */
                opKanaToggle = gfKanaToggle ? KANA_SET : KANA_CLEAR;
            }
        } else if (pklOld && JAPANESE_KBD_LAYOUT(pklOld->hkl)) {
            /*
             * Previous KL was Japanese, and we're switching to the other language.
             * Let's clear the KANA toggle status and preserve it for the future
             * switch back to the Japanese KL.
             */
            gfKanaToggle = (TestAsyncKeyStateToggle(VK_KANA) != 0);
            opKanaToggle = KANA_CLEAR;
        }

        if (opKanaToggle == KANA_SET) {
            TAGMSG0(DBGTAG_KBD, "VK_KANA is being set.\n");
            SetAsyncKeyStateToggle(VK_KANA);
            SetRawKeyToggle(VK_KANA);
            if (gptiForeground && gptiForeground->pq) {
                SetKeyStateToggle(gptiForeground->pq, VK_KANA);
            }
        } else if (opKanaToggle == KANA_CLEAR) {
            TAGMSG0(DBGTAG_KBD, "VK_KANA is beging cleared.\n");
            ClearAsyncKeyStateToggle(VK_KANA);
            ClearRawKeyToggle(VK_KANA);
            if (gptiForeground && gptiForeground->pq) {
                ClearKeyStateToggle(gptiForeground->pq, VK_KANA);
            }
        }

        if (opKanaToggle != KANA_NOOP) {
            UpdateKeyLights(TRUE);
        }
    }

    UserAssert(pklNew);
    SetGlobalKeyboardTableInfo(pklNew);
}


//
// Toggle and push state adjusters:
//
// ResetPushState, AdjustPushState, AdjustPushStateForKL
//

void ResetPushState(PTHREADINFO pti, UINT uVk)
{
    TAGMSG1(DBGTAG_IMM, "ResetPushState: has to reset the push state of vk=%x\n", uVk);
    if (uVk != 0) {
        ClearAsyncKeyStateDown(uVk);
        ClearAsyncKeyStateDown(uVk);
        ClearRawKeyDown(uVk);
        ClearRawKeyToggle(uVk);
        ClearKeyStateDown(pti->pq, uVk);
        ClearKeyStateToggle(pti->pq, uVk);
    }
}

void AdjustPushState(PTHREADINFO ptiCurrent, BYTE bBaseVk, BYTE bVkL, BYTE bVkR, PKL pklPrev, PKL pklNew)
{
    BOOLEAN fDownL = FALSE, fDownR = FALSE;
    BOOLEAN fVanishL = FALSE, fVanishR = FALSE;

    UINT uScanCode1, uScanCode2;

    if (bVkL) {
        fDownL = TestRawKeyDown(bVkL) || TestAsyncKeyStateDown(bVkL) || TestKeyStateDown(ptiCurrent->pq, bVkL);
        if (fDownL) {
            uScanCode1 = InternalMapVirtualKeyEx(bVkL, 0, pklPrev->spkf->pKbdTbl);
            uScanCode2 = InternalMapVirtualKeyEx(bVkL, 0, pklNew->spkf->pKbdTbl);
            fVanishL = (uScanCode1 && uScanCode2 == 0);
            if (fVanishL) {
                TAGMSG2(DBGTAG_KBD, "AdjustPushState: clearing %02x (%02x)", bVkL, uScanCode1);
                xxxKeyEvent((WORD)(bVkL | KBDBREAK), (WORD)(uScanCode1 | SCANCODE_SIMULATED), 0, 0,
#ifdef GENERIC_INPUT
                            NULL,
                            NULL,
#endif
                            FALSE);
            }
        }
    }

    if (bVkR) {
        fDownR = TestRawKeyDown(bVkR) || TestAsyncKeyStateDown(bVkR) || TestKeyStateDown(ptiCurrent->pq, bVkR);
        if (fDownR) {
            uScanCode1 = InternalMapVirtualKeyEx(bVkR, 0, pklPrev->spkf->pKbdTbl);
            uScanCode2 = InternalMapVirtualKeyEx(bVkR, 0, pklNew->spkf->pKbdTbl);
            fVanishR = (uScanCode1 && uScanCode2 == 0);
            if (fVanishR) {
                TAGMSG2(DBGTAG_KBD, "AdjustPushState: clearing %02x (%02x)", bVkR, uScanCode1);
                xxxKeyEvent((WORD)(bVkR | KBDBREAK), (WORD)(uScanCode1 | SCANCODE_SIMULATED), 0, 0,
#ifdef GENERIC_INPUT
                            NULL,
                            NULL,
#endif
                            FALSE);
            }
        }
    }

    UNREFERENCED_PARAMETER(bBaseVk);
}

VOID AdjustPushStateForKL(PTHREADINFO ptiCurrent, PBYTE pbDone, PKL pklTarget, PKL pklPrev, PKL pklNew)
{
    CONST VK_TO_BIT* pVkToBits;

    UserAssert(pklPrev);
    UserAssert(pklNew);

    if (pklTarget->spkf == NULL || pklPrev->spkf == NULL) {
        return;
    }

    pVkToBits = pklTarget->spkf->pKbdTbl->pCharModifiers->pVkToBit;

    for (; pVkToBits->Vk; ++pVkToBits) {
        BYTE bVkVar1 = 0, bVkVar2 = 0;

        //
        // Is it already processed ?
        //
        UserAssert(pVkToBits->Vk < 0x100);
        if (pbDone[pVkToBits->Vk >> 3] & (1 << (pVkToBits->Vk & 7))) {
            continue;
        }

        switch (pVkToBits->Vk) {
        case VK_SHIFT:
            bVkVar1 = VK_LSHIFT;
            bVkVar2 = VK_RSHIFT;
            break;
        case VK_CONTROL:
            bVkVar1 = VK_LCONTROL;
            bVkVar2 = VK_RCONTROL;
            break;
        case VK_MENU:
            bVkVar1 = VK_LMENU;
            bVkVar2 = VK_RMENU;
            break;
        }

        TAGMSG3(DBGTAG_IMM, "Adjusting VK=%x var1=%x var2=%x\n", pVkToBits->Vk, bVkVar1, bVkVar2);

        AdjustPushState(ptiCurrent, pVkToBits->Vk, bVkVar1, bVkVar2, pklPrev, pklNew);

        pbDone[pVkToBits->Vk >> 3] |= (1 << (pVkToBits->Vk & 7));
    }
}


__inline BOOL IsWinSrvInputThread(
    PTHREADINFO pti)
{
    UserAssert(pti);
    UserAssert(pti->TIF_flags & TIF_CSRSSTHREAD);

    if (gptiForeground && gptiForeground->rpdesk &&
            gptiForeground->rpdesk->dwConsoleThreadId == TIDq(pti)) {
        return TRUE;
    }

    return FALSE;
}

/*****************************************************************************\
* xxxInternalActivateKeyboardLayout
*
* pkl   - pointer to keyboard layout to switch the current thread to
* Flags - KLF_RESET
*         KLF_SETFORPROCESS
*         KLLF_SHIFTLOCK (any of KLLF_GLOBAL_ATTRS)
*         others are ignored
* pwnd  - If the current thread has no focus or active window, send the
*         WM_INPUTLANGCHANGE message to this window (unless it is NULL too)
*
* History:
* 1998-10-14 IanJa    Added pwnd parameter
\*****************************************************************************/
HKL xxxInternalActivateKeyboardLayout(
    PKL pkl,
    UINT Flags,
    PWND pwnd)
{
    HKL hklPrev;
    PKL pklPrev;
    TL  tlpklPrev;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pkl);
    CheckLock(pwnd);

    /*
     * Remember what is about to become the "previously" active hkl
     * for the return value.
     */
    if (ptiCurrent->spklActive != (PKL)NULL) {
        pklPrev = ptiCurrent->spklActive;
        hklPrev = ptiCurrent->spklActive->hkl;
    } else {
        pklPrev = NULL;
        hklPrev = (HKL)0;
    }

    /*
     * ShiftLock/CapsLock is a global feature applying to all layouts
     * Only Winlogon and the Input Locales cpanel applet set KLF_RESET.
     */
    if (Flags & KLF_RESET) {
        gdwKeyboardAttributes = KLL_GLOBAL_ATTR_FROM_KLF(Flags);
    }

    /*
     * Early out
     */
    if (!(Flags & KLF_SETFORPROCESS) && (pkl == ptiCurrent->spklActive)) {
        return hklPrev;
    }

    /*
     * Clear out diacritics when switching kbd layouts #102838
     */
    pkl->wchDiacritic = 0;

    /*
     * Update the active layout in the pti.  KLF_SETFORPROCESS will always be set
     * when the keyboard layout switch is initiated by the keyboard hotkey.
     */

    /*
     * Lock the previous keyboard layout for it's used later.
     */
    ThreadLockWithPti(ptiCurrent, pklPrev, &tlpklPrev);

    /*
     * Is this is a console thread, apply this change to any process in it's
     * window.  This can really help character-mode apps!  (#58025)
     */
    if (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) {
        Lock(&ptiCurrent->spklActive, pkl);
        try {
            ptiCurrent->pClientInfo->CodePage = pkl->CodePage;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
           goto UnlockAndGo;
        }
    } else if ((Flags & KLF_SETFORPROCESS) && !(ptiCurrent->TIF_flags & TIF_16BIT)) {
        /*
         * For 16 bit app., only the calling thread will have its active layout updated.
         */
       PTHREADINFO ptiT;

       if (IS_IME_ENABLED()) {
           /*
            * Only allow *NOT* CSRSS to make this call
            */
           UserAssert(PsGetCurrentProcess() != gpepCSRSS);
           // pti->pClientInfo is updated in xxxImmActivateThreadsLayout()
           if (!xxxImmActivateThreadsLayout(ptiCurrent->ppi->ptiList, NULL, pkl)) {
               RIPMSG1(RIP_WARNING, "no layout change necessary via xxxImmActivateThreadLayout() for process %lx", ptiCurrent->ppi);
               goto UnlockAndGo;
           }
       } else {
           BOOL fKLChanged = FALSE;

           for (ptiT = ptiCurrent->ppi->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {
               if (ptiT->spklActive != pkl && (ptiT->TIF_flags & TIF_INCLEANUP) == 0) {
                   Lock(&ptiT->spklActive, pkl);
                   UserAssert(ptiT->pClientInfo != NULL);
                   try {
                       ptiT->pClientInfo->CodePage = pkl->CodePage;
                       ptiT->pClientInfo->hKL = pkl->hkl;
                   } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                       goto UnlockAndGo;
                   }

                   fKLChanged = TRUE;
               }
           }
           if (!fKLChanged) {
              RIPMSG1(RIP_WARNING, "no layout change necessary for process %lx ?", ptiCurrent->ppi);
              goto UnlockAndGo;
           }
       }

    } else {
        if (IS_IME_ENABLED()) {
            xxxImmActivateLayout(ptiCurrent, pkl);
        } else {
            Lock(&ptiCurrent->spklActive, pkl);
        }
        UserAssert(ptiCurrent->pClientInfo != NULL);
        if ((ptiCurrent->TIF_flags & TIF_INCLEANUP) == 0) {
            try {
                ptiCurrent->pClientInfo->CodePage = pkl->CodePage;
                ptiCurrent->pClientInfo->hKL = pkl->hkl;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                   goto UnlockAndGo;
            }
        }
    }

    /*
     * If (
     *  1a. The process is not CSRSS. or
     *   b. it's CSRSS input thread.
     *  2. and, the process is foreground.
     * )
     * update gpKbdTbl for the proper AltGr processing,
     * and let the shell hook (primarily Internat.exe)
     * know the foreground app's new keyboard layout.
     */

//    if ((ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) == 0 || IsWinSrvInputThread(ptiCurrent)) {

        if (gptiForeground && (gptiForeground->ppi == ptiCurrent->ppi)) {
            ChangeForegroundKeyboardTable(pklPrev, pkl);

            /*
             * Call the Shell hook with the new language.
             * Only call the hook if we are the foreground process, to prevent
             * background apps from changing the indicator.  (All console apps
             * are part of the same process, but I have never seen a cmd window
             * app change the layout, let alone in the background)
             */
            if (gLCIDSentToShell != pkl->hkl && (ptiCurrent != gptiRit)) {
               if (IsHooked(ptiCurrent, WHF_SHELL)) {
                   gLCIDSentToShell = pkl->hkl;
                   xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)pkl->hkl, WH_SHELL);
               }
            }
        }
//    }

    /*
     * Tell the app what happened
     */
    if (ptiCurrent->pq) {
        PWND pwndT;
        TL tlpwndT;

        /*
         * If we have no Focus window, use the Active window.
         * eg: Console full-screen has NULL focus window.
         */
        pwndT = ptiCurrent->pq->spwndFocus;
        if (pwndT == NULL) {
            pwndT = ptiCurrent->pq->spwndActive;
            if (pwndT == NULL) {
                pwndT = pwnd;
            }
        }

        if (pwndT != NULL) {
            ThreadLockAlwaysWithPti( ptiCurrent, pwndT, &tlpwndT);
            xxxSendMessage(pwndT, WM_INPUTLANGCHANGE, (WPARAM)pkl->iBaseCharset, (LPARAM)pkl->hkl);
            ThreadUnlock(&tlpwndT);
        }
    }

    /*
     * Tell IME to send mode update notification
     */
    if (ptiCurrent && ptiCurrent->spwndDefaultIme &&
            (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) == 0) {
        if (IS_IME_KBDLAYOUT(pkl->hkl)
#ifdef CUAS_ENABLE
            ||
            IS_CICERO_ENABLED_AND_NOT16BIT()
#endif // CUAS_ENABLE
           ) {
            BOOL fForProcess = (ptiCurrent->TIF_flags & KLF_SETFORPROCESS) && !(ptiCurrent->TIF_flags & TIF_16BIT);
            TL tlpwndIme;

            TAGMSG1(DBGTAG_IMM, "Sending IMS_SENDNOTIFICATION to pwnd=%#p", ptiCurrent->spwndDefaultIme);

            ThreadLockAlwaysWithPti(ptiCurrent, ptiCurrent->spwndDefaultIme, &tlpwndIme);
            xxxSendMessage(ptiCurrent->spwndDefaultIme, WM_IME_SYSTEM, IMS_SENDNOTIFICATION, fForProcess);
            ThreadUnlock(&tlpwndIme);
        }
    }

UnlockAndGo:
    ThreadUnlock(&tlpklPrev);

    return hklPrev;
}

BOOL xxxUnloadKeyboardLayout(
    PWINDOWSTATION pwinsta,
    HKL hkl)
{
    PKL pkl;

    /*
     * Validate HKL and check to make sure an app isn't attempting to unload a system
     * preloaded layout.
     */
    pkl = HKLtoPKL(PtiCurrent(), hkl);
    if (pkl == NULL) {
        return FALSE;
    }

    return xxxInternalUnloadKeyboardLayout(pwinsta, pkl, 0);
}

HKL _GetKeyboardLayout(
    DWORD idThread)
{
    PTHREADINFO ptiT;
    PLIST_ENTRY pHead, pEntry;

    CheckCritIn();

    /*
     * If idThread is NULL return hkl of the current thread
     */
    if (idThread == 0) {
        PKL pklActive = PtiCurrentShared()->spklActive;

        if (pklActive == NULL) {
            return (HKL)0;
        }
        return pklActive->hkl;
    }
    /*
     * Look for idThread
     */
    pHead = &PtiCurrent()->rpdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
        if (GETPTIID(ptiT) == (HANDLE)LongToHandle(idThread)) {
            if (ptiT->spklActive == NULL) {
                return (HKL)0;
            }
            return ptiT->spklActive->hkl;
        }
    }
    /*
     * idThread doesn't exist
     */
    return (HKL)0;
}

UINT _GetKeyboardLayoutList(
    PWINDOWSTATION pwinsta,
    UINT nItems,
    HKL *ccxlpBuff)
{
    UINT nHKL = 0;
    PKL pkl, pklFirst;

    if (!pwinsta) {
        return 0;
    }

    pkl = pwinsta->spklList;

    /*
     * Windowstations that do not take input could have no layouts
     */
    if (pkl == NULL) {
        // SetLastError() ????
        return 0;
    }

    /*
     * The client/server thunk sets nItems to 0 if ccxlpBuff == NULL
     */
    UserAssert(ccxlpBuff || (nItems == 0));

    pklFirst = pkl;
    if (nItems) {
        try {
            do {
               if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
                   if (nItems-- == 0) {
                       break;
                   }
                   nHKL++;
                   *ccxlpBuff++ = pkl->hkl;
               }
               pkl = pkl->pklNext;
            } while (pkl != pklFirst);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_ERROR,
                    "_GetKeyBoardLayoutList: exception writing ccxlpBuff %lx", ccxlpBuff);
            return 0;
        }
    } else do {
        if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
            nHKL++;
        }
        pkl = pkl->pklNext;
    } while (pkl != pklFirst);

    return nHKL;
}

/*
 * Layouts are locked by each thread using them and possibly by:
 *    - pwinsta->spklList (head of windowstation's list)
 *    - gspklBaseLayout   (default layout for new threads)
 * The layout is marked for destruction when gets unloaded, so that it will be
 * unlinked and freed as soon as an Unlock causes the lock count to go to 0.
 * If it is reloaded before that time, it is unmarked for destruction. This
 * ensures that laoded layouts stay around even when they go out of use.
 */
BOOL xxxInternalUnloadKeyboardLayout(
    PWINDOWSTATION pwinsta,
    PKL pkl,
    UINT Flags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL tlpkl;

    UserAssert(pkl);

    /*
     * Never unload the default layout, unless we are destroying the current
     * windowstation or replacing one user's layouts with another's.
     */
    if ((pkl == gspklBaseLayout) && !(Flags & KLF_INITTIME)) {
        return FALSE;
    }

    /*
     * Keeps pkl good, but also allows destruction when unlocked later
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlpkl);

    /*
     * Mark it for destruction so it gets removed when the lock count reaches 0
     * Mark it KL_UNLOADED so that it appears to be gone from the toggle list
     */
    HMMarkObjectDestroy(pkl);
    pkl->dwKL_Flags |= KL_UNLOADED;

    /*
     * If unloading this thread's active layout, helpfully activate the next one
     * (Don't bother if KLF_INITTIME - unloading all previous user's layouts)
     */
    if (!(Flags & KLF_INITTIME)) {
        UserAssert(ptiCurrent->spklActive != NULL);
        if (ptiCurrent->spklActive == pkl) {
            PKL pklNext;
            pklNext = HKLtoPKL(ptiCurrent, (HKL)HKL_NEXT);
            if (pklNext != NULL) {
                TL tlPKL;
                ThreadLockAlwaysWithPti(ptiCurrent, pklNext, &tlPKL);
                xxxInternalActivateKeyboardLayout(pklNext, Flags, NULL);
                ThreadUnlock(&tlPKL);
            }
        }
    }

    /*
     * If this pkl == pwinsta->spklList, give it a chance to be destroyed by
     * unlocking it from pwinsta->spklList.
     */
    if (pwinsta->spklList == pkl) {
        UserAssert(pkl != NULL);
        if (pkl != pkl->pklNext) {
            pkl = Lock(&pwinsta->spklList, pkl->pklNext);
            UserAssert(pkl != NULL); // gspklBaseLayout and ThreadLocked pkl
        }
    }

    /*
     * This finally destroys the unloaded layout if it is not in use anywhere
     */
    ThreadUnlock(&tlpkl);

    /*
     * Update keyboard list.
     */
    if (IsHooked(ptiCurrent, WHF_SHELL)) {
        xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)0, WH_SHELL);
        gLCIDSentToShell = 0;
    }

    return TRUE;
}

VOID xxxFreeKeyboardLayouts(
    PWINDOWSTATION pwinsta, BOOL bUnlock)
{
    PKL pkl;

    /*
     * Unload all of the windowstation's layouts.
     * They may still be locked by some threads (eg: console), so this
     * may not destroy them all, but it will mark them all KL_UNLOADED.
     * Set KLF_INITTIME to ensure that the default layout (gspklBaseLayout)
     * gets unloaded too.
     * Note: it's much faster to unload non-active layouts, so start with
     * the next loaded layout, leaving the active layout till last.
     */
    while ((pkl = HKLtoPKL(PtiCurrent(), (HKL)HKL_NEXT)) != NULL) {
        xxxInternalUnloadKeyboardLayout(pwinsta, pkl, KLF_INITTIME);
    }

    /*
     * The WindowStation is being destroyed, or one user's layouts are being
     * replaced by another user's, so it's OK to Unlock spklList.
     * Any layout still in the double-linked circular KL list will still be
     * pointed to by gspklBaseLayout: this is important, since we don't want
     * to leak any KL or KBDFILE objects by losing pointers to them.
     * There are no layouts when we first come here (during bootup).
     */
    if (bUnlock) {
        Unlock(&pwinsta->spklList);
    }
}

/***************************************************************************\
* DestroyKL
*
* Destroys a keyboard layout. Note that this function does not
* follow normal destroy function semantics. See IanJa.
*
* History:
* 25-Feb-1997 adams     Created.
\***************************************************************************/

VOID DestroyKL(
    PKL pkl)
{
    PKBDFILE pkf;

    /*
     * Cut it out of the pwinsta->spklList circular bidirectional list.
     * We know pwinsta->spklList != pkl, since pkl is unlocked.
     */
    pkl->pklPrev->pklNext = pkl->pklNext;
    pkl->pklNext->pklPrev = pkl->pklPrev;

    /*
     * Unlock its pkf
     */
    pkf = Unlock(&pkl->spkf);
    if (pkf && (pkf = Unlock(&pkl->spkfPrimary))) {
        DestroyKF(pkf);
    }

    if (pkl->pspkfExtra) {
        UINT i;

         for (i = 0; i < pkl->uNumTbl && pkl->pspkfExtra[i]; ++i) {
             pkf = Unlock(&pkl->pspkfExtra[i]);
             if (pkf) {
                 DestroyKF(pkf);
             }
         }
         UserFreePool(pkl->pspkfExtra);
    }

    if (pkl->piiex != NULL) {
        UserFreePool(pkl->piiex);
    }

    if (pkl == gpKL) {
        /*
         * Nuke gpKL.
         */
        gpKL = NULL;
    }

    /*
     * Free the pkl itself.
     */
    HMFreeObject(pkl);
}

/***************************************************************************\
* CleanupKeyboardLayouts
*
* Frees the all keyboard layouts in this session.
*
\***************************************************************************/
VOID CleanupKeyboardLayouts()
{
    /*
     * Unlock the keyboard layouts
     */
    if (gspklBaseLayout != NULL) {

        PKL pkl;
        PKL pklNext;

        pkl = gspklBaseLayout->pklNext;

        while (pkl->pklNext != pkl) {
            pklNext = pkl->pklNext;

            DestroyKL(pkl);

            pkl = pklNext;
        }

        UserAssert(pkl == gspklBaseLayout);

        if (!HMIsMarkDestroy(gspklBaseLayout)) {
            HMMarkObjectDestroy(gspklBaseLayout);
        }

        HYDRA_HINT(HH_KBDLYOUTGLOBALCLEANUP);

        if (Unlock(&gspklBaseLayout)) {
            DestroyKL(pkl);
        }
    }

    UserAssert(gpkfList == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\logon.c ===
/**************************** Module Header ********************************\
* Module Name: logon.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Logon Support Routines
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* _RegisterLogonProcess
*
* Register the logon process and set secure mode flag
*
* History:
* 07-01-91 JimA         Created.
\***************************************************************************/

BOOL _RegisterLogonProcess(
    DWORD dwProcessId,
    BOOL fSecure)
{
    UNREFERENCED_PARAMETER(fSecure);

    /*
     * Allow only one logon process and then only if it has TCB
     * privilege.
     */
    if (gpidLogon != 0 || !IsPrivileged(&psTcb)) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _RegisterLogonProcess");

        return FALSE;
    }

    gpidLogon = (HANDLE)LongToHandle( dwProcessId );
    return TRUE;
}


/***************************************************************************\
* _LockWindowStation
*
* Locks a windowstation and its desktops and returns the busy status.
*
* History:
* 01-15-91 JimA         Created.
\***************************************************************************/
UINT _LockWindowStation(
    PWINDOWSTATION pwinsta)
{
    PDESKTOP pdesk;
    BOOL fBusy = FALSE;

    /*
     * Make sure the caller is the logon process
     */
    if (PsGetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _LockWindowStation");

        return WSS_ERROR;
    }

    /*
     * Prevent desktop switches
     */
    pwinsta->dwWSF_Flags |= WSF_SWITCHLOCK;

    /*
     * Determine whether the station is busy
     */
    pdesk = pwinsta->rpdeskList;
    while (pdesk != NULL) {
        if (pdesk != grpdeskLogon &&
                OBJECT_TO_OBJECT_HEADER(pdesk)->HandleCount != 0) {

            /*
             * This desktop is open, thus the station is busy
             */
            fBusy = TRUE;
            break;
        }
        pdesk = pdesk->rpdeskNext;
    }

    if (pwinsta->dwWSF_Flags & WSF_SHUTDOWN)
        pwinsta->dwWSF_Flags |= WSF_OPENLOCK;

    /*
     * Unlock opens if the station is busy and is not in the middle
     * of shutting down.
     */
    if (fBusy)
        return WSS_BUSY;
    else
        return WSS_IDLE;
}


/***************************************************************************\
* _UnlockWindowStation
*
* Unlocks a windowstation locked by LogonLockWindowStation.
*
* History:
* 01-15-91 JimA         Created.
\***************************************************************************/
BOOL _UnlockWindowStation(
    PWINDOWSTATION pwinsta)
{
    /*
     * Make sure the caller is the logon process.
     */
    if (PsGetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _UnlockWindowStation");

        return FALSE;
    }

    /*
     * If shutdown is occuring, only remove the switch lock.
     */
    if (pwinsta->dwWSF_Flags & WSF_SHUTDOWN) {
        pwinsta->dwWSF_Flags &= ~WSF_SWITCHLOCK;
    } else {
        pwinsta->dwWSF_Flags &= ~(WSF_OPENLOCK | WSF_SWITCHLOCK);
    }

    return TRUE;
}


/***************************************************************************\
* _SetLogonNotifyWindow
*
* Register the window to notify when logon related events occur.
*
* History:
* 01-13-92 JimA         Created.
\***************************************************************************/
BOOL _SetLogonNotifyWindow(
    PWND pwnd)
{
    /*
     * Make sure the caller is the logon process.
     */
    if (PsGetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _SetLogonNotifyWindow");

        return FALSE;
    }

    Lock(&gspwndLogonNotify, pwnd);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\keyconv.c ===
/****************************** Module Header ******************************\
* Module Name: keyconv.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-06-90 DavidPe      Created.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _TranslateMessage (API)
*
* This routine translates virtual keystroke messages as follows:
*    WM_KEYDOWN/WM_KEYUP are translated into WM_CHAR and WM_DEADCHAR
*    WM_SYSKEYDOWN/WM_SYSKEYDOWN are translated into WM_SYSCHAR and
*    WM_SYSDEADCHAR.  The WM_*CHAR messages are posted to the application
*    queue.
*
* History:
* 11-06-90 DavidPe      Created stub functionality.
* 12-07-90 GregoryW     Modified to call _ToAscii for translations.
\***************************************************************************/

BOOL xxxTranslateMessage(
    LPMSG pmsg,
    UINT uiTMFlags)
{
    PTHREADINFO pti;
    UINT wMsgType;
    int cChar;
    BOOL fSysKey = FALSE;
    DWORD dwKeyFlags;
    LPARAM lParam;
    UINT uVirKey;
    PWND pwnd;
    WCHAR awch[16];
    WCHAR *pwch;

    switch (pmsg->message) {

    default:
        return FALSE;

    case WM_SYSKEYDOWN:
        /*
         * HACK carried over from Win3 code: system messages
         * only get posted during KEYDOWN processing - so
         * set fSysKey only for WM_SYSKEYDOWN.
         */
        fSysKey = TRUE;
        /*
         * Fall thru...
         */

    case WM_SYSKEYUP:
    case WM_KEYDOWN:
    case WM_KEYUP:
        pti = PtiCurrent();

        if ((pti->pMenuState != NULL) &&
                (HW(pti->pMenuState->pGlobalPopupMenu->spwndPopupMenu) ==
                pmsg->hwnd)) {
            uiTMFlags |= TM_INMENUMODE;
        } else {
            uiTMFlags &= ~TM_INMENUMODE;
        }

        /*
         * Don't change the contents of the passed in structure.
         */
        lParam = pmsg->lParam;

        /*
         * For backward compatibility, mask the virtual key value.
         */
        uVirKey = LOWORD(pmsg->wParam);

        cChar = xxxInternalToUnicode(uVirKey,   // virtual key code
                         HIWORD(lParam),  // scan code, make/break bit
                         pti->pq->afKeyState,
                         awch, sizeof(awch)/sizeof(awch[0]),
                         uiTMFlags, &dwKeyFlags, NULL);
        lParam |= (dwKeyFlags & ALTNUMPAD_BIT);

/*
 * LATER 12/7/90 - GregoryW
 * Note: Win3.x TranslateMessage returns TRUE if ToAscii is called.
 *       Proper behavior is to return TRUE if any translation is
 *       performed by ToAscii.  If we have to remain compatible
 *       (even though apps clearly don't currently care about the
 *       return value) then the following return should be changed
 *       to TRUE.  If we want the new 32-bit apps to have a meaningful
 *       return value we should leave this as FALSE.
 *
 *      If console is calling us with the TM_POSTCHARBREAKS flag then we
 *      return FALSE if no char was actually posted
 *
 *      !!! LATER get console to change so it does not need private API
 *      TranslateMessageEx
 */

        if (!cChar) {
            if (uiTMFlags & TM_POSTCHARBREAKS)
                return FALSE;
            else
                return TRUE;
        }

        /*
         * Some translation performed.  Figure out what type of
         * message to post.
         *
         */
        if (cChar > 0)
            wMsgType = (fSysKey) ? (UINT)WM_SYSCHAR : (UINT)WM_CHAR;
        else {
            wMsgType = (fSysKey) ? (UINT)WM_SYSDEADCHAR : (UINT)WM_DEADCHAR;
            cChar = -cChar;                // want positive value
        }

        if (dwKeyFlags & KBDBREAK) {
            lParam |=  0x80000000;
        } else {
            lParam &= ~0x80000000;
        }

        /*
         * Since xxxInternalToUnicode can leave the crit sect, we need to
         * validate the message hwnd here.
         */
        pwnd = ValidateHwnd(pmsg->hwnd);
        if (!pwnd) {
            return FALSE;
        }

        for (pwch = awch; cChar > 0; cChar--) {

            /*
             * If this is a multi-character posting, all but the last one
             * should be marked as fake keystrokes for Console/VDM.
             */
            _PostMessage(pwnd, wMsgType, (WPARAM)*pwch,
                    lParam | (cChar > 1 ? FAKE_KEYSTROKE : 0));

            *pwch = 0;        // zero out old character (why?)
            pwch += 1;
        }

        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\loadbits.c ===
/****************************** Module Header ******************************\
* Module Name: loadbits.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Loads and creates icons / cursors / bitmaps. All 3 functions can either
* load from a client resource file, load from user's resource file, or
* load from the display's resource file. Beware that hmodules are not
* unique across processes!
*
* 05-Apr-1991 ScottLu   Rewrote to work with client/server
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wchar.h>

/***************************************************************************\
* _CreateEmptyCursorObject
*
* Creates a cursor object and links it into a cursor list.
*
* 08-Feb-92 ScottLu     Created.
\***************************************************************************/

HCURSOR _CreateEmptyCursorObject(
    BOOL fPublic)
{
    PCURSOR pcurT;

    /*
     * Create the cursor object.
     */
    pcurT = (PCURSOR)HMAllocObject(PtiCurrent(),
                                   NULL,
                                   TYPE_CURSOR,
                                   max(sizeof(CURSOR),
                                   sizeof(ACON)));

    if ((fPublic) && (pcurT != NULL) && (ISCSRSS())) {
        pcurT->head.ppi = NULL;
    }

    return (HCURSOR)PtoH(pcurT);
}

/***************************************************************************\
* DestroyEmptyCursorObject
* UnlinkCursor
*
* Destroys an empty cursor object (structure holds nothing that needs
* destroying).
*
* 08-Feb-1992 ScottLu   Created.
\***************************************************************************/
VOID UnlinkCursor(
    PCURSOR pcur)
{
    PCURSOR *ppcurT;
    BOOL    fTriedPublicCache;
    BOOL    fTriedThisProcessCache = FALSE;

    /*
     * First unlink this cursor object from the cursor list (it will be the
     * first one in the list, so this'll be fast...  but just in case, make
     * it a loop).
     */
    if (fTriedPublicCache = (pcur->head.ppi == NULL)) {
        ppcurT = &gpcurFirst;
    } else {
        ppcurT = &pcur->head.ppi->pCursorCache;
    }

LookAgain:

    for (; *ppcurT != NULL; ppcurT = &((*ppcurT)->pcurNext)) {
        if (*ppcurT == pcur) {
            *ppcurT = pcur->pcurNext;
FreeIt:
            pcur->pcurNext = NULL;
            pcur->CURSORF_flags &= ~CURSORF_LINKED;
            return;
        }
    }

    /*
     * If we get here, it means that the cursor used to be public but
     * got assigned to the current thread due to being unlocked.  We
     * have to look for it in the public cache.
     */
    if (!fTriedPublicCache) {
        ppcurT = &gpcurFirst;
        fTriedPublicCache = TRUE;
        goto LookAgain;
    }

    /*
     * If we got here, it means that it was locked during process
     * cleanup and got assigned to no owner.  Try the current process
     * cache.
     */
    if (!fTriedThisProcessCache) {
        ppcurT = &PpiCurrent()->pCursorCache;
        fTriedThisProcessCache = TRUE;
        goto LookAgain;
    }

    /*
     * Getting Desperate here...  Look through every cursor and process
     * cache for it.
     */
    {
        PHE pheMax, pheT;

        pheMax = &gSharedInfo.aheList[giheLast];
        for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
            if (pheT->bType == TYPE_CURSOR) {
                if (((PCURSOR)pheT->phead)->pcurNext == pcur) {
                    ((PCURSOR)pheT->phead)->pcurNext = pcur->pcurNext;
                    goto FreeIt;
                } else if (pheT->pOwner && ((PPROCESSINFO)pheT->pOwner)->pCursorCache == pcur) {
                    ((PPROCESSINFO)pheT->pOwner)->pCursorCache = pcur->pcurNext;
                    goto FreeIt;
                }
            }
        }
    }

    UserAssert(FALSE);
}

/***************************************************************************\
* DestroyEmptyCursorObject
*
\***************************************************************************/

VOID DestroyEmptyCursorObject(
    PCURSOR pcur)
{
    if (pcur->CURSORF_flags & CURSORF_LINKED) {
        UnlinkCursor(pcur);
    }

    HMFreeObject(pcur);
}

/***************************************************************************\
* ZombieCursor
*
* Unlink the cursor and set its owner to the system process.
*
* 3-Sep-1997    vadimg      created
\***************************************************************************/

VOID ZombieCursor(PCURSOR pcur)
{
    if (pcur->CURSORF_flags & CURSORF_LINKED) {
        UnlinkCursor(pcur);
    }

#if DBG
    if (ISTS()) {
        PHE phe;
        phe = HMPheFromObject(pcur);

        if (phe->pOwner == NULL) {
            RIPMSG2(RIP_ERROR, "NULL owner for cursor %#p phe %#p\n",
                    pcur, phe);
        }
    }
#endif // DBG

    HMChangeOwnerProcess(pcur, gptiRit);

    RIPMSG1(RIP_WARNING, "ZombieCursor: %#p became a zombie", pcur);
}

/***************************************************************************\
* ResStrCmp
*
* This function compares two strings taking into account that one or both
* of them may be resource IDs.  The function returns a TRUE if the strings
* are equal, instead of the zero lstrcmp() returns.
*
* History:
* 20-Apr-91 DavidPe     Created
\***************************************************************************/

BOOL ResStrCmp(
    PUNICODE_STRING cczpstr1,
    PUNICODE_STRING pstr2)
{
    BOOL retval = FALSE;
    /*
     * pstr1 is a STRING that is in kernel space, but the buffer may
     * be in client space.
     */

    if (cczpstr1->Length == 0) {

        /*
         * pstr1 is a resource ID, so just compare the values.
         */
        if (cczpstr1->Buffer == pstr2->Buffer)
            return TRUE;

    } else {

        try {
        /*
         * pstr1 is a string.  if pstr2 is an actual string compare the
         * string values; if pstr2 is not a string then pstr1 may be an
         * "integer string" of the form "#123456". so convert it to an
         * integer and compare the integers.
         * Before calling lstrcmp(), make sure pstr2 is an actual
         * string, not a resource ID.
         */
            if (pstr2->Length != 0) {

                if (RtlEqualUnicodeString(cczpstr1, pstr2, TRUE))
                    retval = TRUE;

            } else if (cczpstr1->Buffer[0] == '#') {

                UNICODE_STRING strId;
                int            id;

                strId.Length        = cczpstr1->Length - sizeof(WCHAR);
                strId.MaximumLength = strId.Length;
                strId.Buffer        = cczpstr1->Buffer + 1;
                RtlUnicodeStringToInteger(&strId, 10, (PULONG)&id);

                if (id == (LONG_PTR)pstr2->Buffer)
                    retval = TRUE;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
    }

    return retval;
}

/***********************************************************************\
* SearchIconCache
*
* Worker routine for FindExistingCursorIcon().
*
* Returns: pCurFound
*
* 28-Sep-1995 SanfordS  Created.
\***********************************************************************/

PCURSOR SearchIconCache(
    PCURSOR         pCursorCache,
    ATOM            atomModName,
    PUNICODE_STRING cczpstrResName,
    PCURSOR         pcurSrc,
    PCURSORFIND     pcfSearch)
{
    /*
     * Run through the list of 'resource' objects created,
     * and see if the cursor requested has already been loaded.
     * If so just return it.  We do this to be consistent with
     * Win 3.0 where they simply return a pointer to the res-data
     * for a cursor/icon handle.  Many apps count on this and
     * call LoadCursor/Icon() often.
     *
     * LR_SHARED implies:
     *   1) icons never get deleted till process (LATER or WOW module)
     *      goes away.
     *   2) This cache is consulted before trying to load a res.
     */
    for (; pCursorCache != NULL; pCursorCache = pCursorCache->pcurNext) {

        /*
         * If we are given a specific cursor to look for, then
         * search for that first.
         */
        if (pcurSrc && (pCursorCache == pcurSrc))
            return pcurSrc;

        /*
         * No need to look further if the module name doesn't match.
         */
        if (atomModName != pCursorCache->atomModName)
            continue;

        /*
         * We only return images that cannot be destroyed by the app.
         * so we don't have to deal with ref counts.  This is owned
         * by us, but not LR_SHARED.
         */
        if (!(pCursorCache->CURSORF_flags & CURSORF_LRSHARED))
            continue;

        /*
         * Check the other distinguishing search criteria for
         * a match.
         */
        if ((pCursorCache->rt == LOWORD(pcfSearch->rt)) &&
            ResStrCmp(cczpstrResName, &pCursorCache->strName)) {

            /*
             * Acons don't have a size per se because each frame
             * can be a different size.  We always make it a hit
             * on acons so replacement of system icons is possible.
             */
            if (pCursorCache->CURSORF_flags & CURSORF_ACON)
                return pCursorCache;

            /*
             * First hit wins.  Nothing fancy here.  Apps that use
             * LR_SHARED have to watch out for this.
             */
            if ((!pcfSearch->cx || (pCursorCache->cx == pcfSearch->cx))       &&
                (!pcfSearch->cy || ((pCursorCache->cy / 2) == pcfSearch->cy)) &&
                (!pcfSearch->bpp || (pCursorCache->bpp == pcfSearch->bpp))) {

                return pCursorCache;
            }
        }
    }

    return NULL;
}

/***********************************************************************\
* _FindExistingCursorIcon
*
* This routine searches all existing icons for one matching the properties
* given.  This routine will only return cursors/icons that are of
* the type that cannot be destroyed by the app. (CURSORF_LRSHARED or
* unowned) and will take the first hit it finds.
*
* 32bit apps that call LoadImage() will normally not have this cacheing
* feature unless they specify LR_SHARED.  If they do so, it is the apps
* responsability to be careful with how they use the cache since wild
* lookups (ie 0s in cx, cy or bpp) will result in different results
* depending on the history of icon/cursor creation.  It is thus recommended
* that apps only use the LR_SHARED option when they are only working
* with one size/colordepth of icon or when they call LoadImage() with
* specific size and/or color content requested.
*
* For the future it would be nice to have a cacheing scheeme that would
* simply be used to speed up reloading of images.  To do this right,
* you would need ref counts to allow deletes to work properly and would
* have to remember whether the images in the cache had been stretched
* or color munged so you don't allow restretching.
*
* Returns: pcurFound
*
*
* 17-Sep-1995 SanfordS  Created.
\***********************************************************************/

PCURSOR _FindExistingCursorIcon(
    ATOM            atomModName,
    PUNICODE_STRING cczpstrResName,
    PCURSOR         pcurSrc,
    PCURSORFIND     pcfSearch)
{
    PCURSOR pcurT = NULL;

    /*
     * If rt is zero we're doing an indirect create, so matching with
     * a previously loaded cursor/icon would be inappropriate.
     */
    if (pcfSearch->rt && atomModName) {

        pcurT = SearchIconCache(PpiCurrent()->pCursorCache,
                                atomModName,
                                cczpstrResName,
                                pcurSrc,
                                pcfSearch);
        if (pcurT == NULL) {
            pcurT = SearchIconCache(gpcurFirst,
                                    atomModName,
                                    cczpstrResName,
                                    pcurSrc,
                                    pcfSearch);
        }
    }

    return pcurT;
}

/***************************************************************************\
* _InternalGetIconInfo
*
* History:
* 09-Mar-1993 MikeKe    Created.
\***************************************************************************/

BOOL _InternalGetIconInfo(
    IN  PCURSOR                  pcur,
    OUT PICONINFO                ccxpiconinfo,
    OUT OPTIONAL PUNICODE_STRING pstrInstanceName,
    OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT OPTIONAL LPDWORD         ccxpbpp,
    IN  BOOL                     fInternalCursor)
{
    HBITMAP hbmBitsT;
    HBITMAP hbmDstT;
    HBITMAP hbmMask;
    HBITMAP hbmColor;

    /*
     * Note -- while the STRING structures are in kernel mode memory, the
     * buffers are in user-mode memory.  So all use of the buffers should
     * be protected bytry blocks.
     */

    /*
     * If this is an animated cursor, just grab the first frame and return
     * the info for it.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON)
        pcur = ((PACON)pcur)->aspcur[0];

    /*
     * Make copies of the bitmaps
     *
     * If the color bitmap is around, then there is no XOR mask in the
     * hbmMask bitmap.
     */
    hbmMask = GreCreateBitmap(
            pcur->cx,
            (pcur->hbmColor && !fInternalCursor) ? pcur->cy / 2 : pcur->cy,
            1,
            1,
            NULL);

    if (hbmMask == NULL)
        return FALSE;


    hbmColor = NULL;

    if (pcur->hbmColor != NULL) {
        if (pcur->bpp == 32) {
            BITMAPINFO bi;

            RtlZeroMemory(&bi, sizeof(bi));
            bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            bi.bmiHeader.biWidth = pcur->cx;
            bi.bmiHeader.biHeight = pcur->cy/2;
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biBitCount = 32;
            bi.bmiHeader.biCompression = BI_RGB;
            bi.bmiHeader.biSizeImage = 0;
            bi.bmiHeader.biClrUsed = 0;
            bi.bmiHeader.biClrImportant = 0;

            hbmColor = GreCreateDIBitmapReal(HDCBITS(),
                                             0,
                                             NULL,
                                             (LPBITMAPINFO)&bi,
                                             DIB_RGB_COLORS,
                                             sizeof(bi),
                                             0,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             0,
                                             NULL);
        } else {
            hbmColor = GreCreateCompatibleBitmap(HDCBITS(),
                                                 pcur->cx,
                                                 pcur->cy / 2);
        }

        if (hbmColor == NULL) {
            GreDeleteObject(hbmMask);
            return FALSE;
        }
    }

    hbmBitsT = GreSelectBitmap(ghdcMem2, pcur->hbmMask);
    hbmDstT  = GreSelectBitmap(ghdcMem, hbmMask);

    GreBitBlt(ghdcMem,
              0,
              0,
              pcur->cx,
              (pcur->hbmColor && !fInternalCursor) ? pcur->cy / 2 : pcur->cy,
              ghdcMem2,
              0,
              0,
              SRCCOPY,
              0x00ffffff);

    if (hbmColor != NULL) {

        GreSelectBitmap(ghdcMem2, pcur->hbmColor);
        GreSelectBitmap(ghdcMem, hbmColor);

        GreBitBlt(ghdcMem,
                  0,
                  0,
                  pcur->cx,
                  pcur->cy / 2,
                  ghdcMem2,
                  0,
                  0,
                  SRCCOPY,
                  0);
    }

    GreSelectBitmap(ghdcMem2, hbmBitsT);
    GreSelectBitmap(ghdcMem, hbmDstT);

    /*
     * Fill in the iconinfo structure.  make copies of the bitmaps.
     */
    try {

        ccxpiconinfo->fIcon = (pcur->rt == PTR_TO_ID(RT_ICON));
        ccxpiconinfo->xHotspot = pcur->xHotspot;
        ccxpiconinfo->yHotspot = pcur->yHotspot;
        ccxpiconinfo->hbmMask  = hbmMask;
        ccxpiconinfo->hbmColor = hbmColor;

        if (pstrInstanceName != NULL) {

            if (pcur->atomModName) {
                pstrInstanceName->Length = (USHORT)
                        UserGetAtomName(pcur->atomModName,
                                        pstrInstanceName->Buffer,
                                        (int) (pstrInstanceName->MaximumLength / sizeof(WCHAR))
                                        * sizeof(WCHAR));
            } else {
                pstrInstanceName->Length = 0;
            }
        }

        if (pstrResName != NULL) {

            if (IS_PTR(pcur->strName.Buffer)) {
                RtlCopyUnicodeString(pstrResName, &pcur->strName);
            } else {
                *pstrResName = pcur->strName;
            }
        }

        if (ccxpbpp)
            *ccxpbpp = pcur->bpp;

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        GreDeleteObject(hbmMask);
        GreDeleteObject(hbmColor);
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* _DestroyCursor
*
* History:
* 25-Apr-1991 DavidPe       Created.
* 04-Aug-1992 DarrinM       Now destroys ACONs as well.
\***************************************************************************/

BOOL _DestroyCursor(
    PCURSOR pcur,
    DWORD   cmdDestroy)
{
    PPROCESSINFO ppi;
    PPROCESSINFO ppiCursor;
    int          i;
    extern BOOL DestroyAniIcon(PACON pacon);

    if (pcur == NULL) {
        UserAssert(FALSE);
        return(TRUE);
    }
    ppi = PpiCurrent();
    ppiCursor = GETPPI(pcur);

    /*
     * Remove this icon from the caption icon cache.
     */
    for (i = 0; i < CCACHEDCAPTIONS; i++) {
        if (gcachedCaptions[i].spcursor == pcur) {
            Unlock( &(gcachedCaptions[i].spcursor) );
        }
    }

    /*
     * First step in destroying an cursor
     */
    switch (cmdDestroy) {

    case CURSOR_ALWAYSDESTROY:

        /*
         * Always destroy? then don't do any checking...
         */
        break;

    case CURSOR_CALLFROMCLIENT:

        /*
         * Can't destroy public cursors/icons.
         */
        if (ppiCursor == NULL)
            /*
             * Fake success if its a resource loaded icon because
             * this is how win95 responded.
             */
            return !!(pcur->CURSORF_flags & CURSORF_FROMRESOURCE);

        /*
         * If this cursor was loaded from a resource, don't free it till the
         * process exits.  This is the way we stay compatible with win3.0's
         * cursors which were actually resources.  Resources under win3 have
         * reference counting and other "features" like handle values that
         * never change.  Read more in the comment in
         * ServerLoadCreateCursorIcon().
         */
        if (pcur->CURSORF_flags & (CURSORF_LRSHARED | CURSORF_SECRET)) {
            return TRUE;
        }

        /*
         * One thread can't destroy the objects created by another.
         */
        if (ppiCursor != ppi) {
            RIPERR0(ERROR_DESTROY_OBJECT_OF_OTHER_THREAD, RIP_ERROR, "DestroyCursor: cursor belongs to another process");
            return FALSE;
        }

        /*
         * fall through.
         */

    case CURSOR_THREADCLEANUP:

        /*
         * Don't destroy public objects either (pretend it worked though).
         */
        if (ppiCursor == NULL)
            return TRUE;
        break;
    }

    /*
     * First mark the object for destruction.  This tells the locking code that
     * we want to destroy this object when the lock count goes to 0.  If this
     * returns FALSE, we can't destroy the object yet.
     */
    if (!HMMarkObjectDestroy((PHEAD)pcur))
        return FALSE;

    if (pcur->strName.Length != 0) {
        UserFreePool((LPSTR)pcur->strName.Buffer);
    }

    if (pcur->atomModName != 0) {
        UserDeleteAtom(pcur->atomModName);
    }

    /*
     * If this is an ACON call its special routine to destroy it.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON) {
        DestroyAniIcon((PACON)pcur);
    } else {
        if (pcur->hbmMask != NULL) {
            GreDeleteObject(pcur->hbmMask);
            GreDecQuotaCount((PW32PROCESS)(pcur->head.ppi));
        }
        if (pcur->hbmColor != NULL) {
            GreDeleteObject(pcur->hbmColor);
            GreDecQuotaCount((PW32PROCESS)(pcur->head.ppi));
        }
        if (pcur->hbmUserAlpha != NULL) {
            GreDeleteObject(pcur->hbmUserAlpha);
            GreDecQuotaCount((PW32PROCESS)(pcur->head.ppi));
        }
        if (pcur->hbmAlpha != NULL) {
            /*
             * This is an internal GDI object, and so not covered by quota.
             */
            GreDeleteObject(pcur->hbmAlpha);
        }
    }

    /*
     * Ok to destroy...  Free the handle (which will free the object and the
     * handle).
     */
    DestroyEmptyCursorObject(pcur);
    return TRUE;
}



/***************************************************************************\
* DestroyUnlockedCursor
*
* Called when a cursor is destoyed due to an unlock.
*
* History:
* 24-Feb-1997 adams     Created.
\***************************************************************************/

void
DestroyUnlockedCursor(void * pv)
{
    _DestroyCursor((PCURSOR)pv, CURSOR_THREADCLEANUP);
}



/***************************************************************************\
* _SetCursorContents
*
*
* History:
* 27-Apr-1992 ScottLu   Created.
\***************************************************************************/

BOOL _SetCursorContents(
    PCURSOR pcur,
    PCURSOR pcurNew)
{
    HBITMAP hbmpT;

    if (!(pcur->CURSORF_flags & CURSORF_ACON)) {

        /*
         * Swap bitmaps.
         */
        hbmpT = pcur->hbmMask;
        pcur->hbmMask = pcurNew->hbmMask;
        pcurNew->hbmMask = hbmpT;

        hbmpT = pcur->hbmColor;
        pcur->hbmColor = pcurNew->hbmColor;
        pcurNew->hbmColor = hbmpT;

        hbmpT = pcur->hbmUserAlpha;
        pcur->hbmUserAlpha = pcurNew->hbmUserAlpha;
        pcurNew->hbmUserAlpha = hbmpT;

        hbmpT = pcur->hbmAlpha;
        pcur->hbmAlpha = pcurNew->hbmAlpha;
        pcurNew->hbmAlpha = hbmpT;

        /*
         * Remember hotspot info and size info
         */
        pcur->xHotspot = pcurNew->xHotspot;
        pcur->yHotspot = pcurNew->yHotspot;
        pcur->cx = pcurNew->cx;
        pcur->cy = pcurNew->cy;

        pcur->bpp = pcurNew->bpp;
        pcur->rt = pcurNew->rt;
        pcur->rcBounds = pcurNew->rcBounds;
    }

    /*
     * Destroy the cursor we copied from.
     */
    _DestroyCursor(pcurNew, CURSOR_THREADCLEANUP);

    /*
     * If the current logical cursor is changing then force the current physical
     * cursor to change.
     */
    if (gpcurLogCurrent == pcur) {
        gpcurLogCurrent = NULL;
        gpcurPhysCurrent = NULL;
        zzzUpdateCursorImage();
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\metrics.c ===
/****************************** Module Header ******************************\
* Module Name: metrics.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* MenuRecalc
*
* Loops through all menus and resets size and item info stuff.  That's
* because it is invalid when the menu font changes.
*
* History:
\***************************************************************************/
void MenuRecalc(void)
{
    PMENU   lpMenu;
    UINT    iItem;
    PHE     pheT;
    DWORD   i;

    /*
     *  for (ppi = gppiFirst; ppi; ppi = ppi->ppiNext)
     *  {
     *      for (pMenu = ppi->lpMenus; TESTFAR(lpMenu); lpMenu = lpMenu->lpMenuNext)
     *      {
     *
     * That was the Chicao way of walking the objects.  In NT, we
     * walk the handle table.
     */
    for (pheT = gSharedInfo.aheList, i = 0; i <= giheLast; i++, pheT++) {

        if (pheT->bType == TYPE_MENU) {
            /*
             * Get a pointer to the menu.
             */
            lpMenu = (PMENU)pheT->phead;

            /*
             * Set menu size to 0 so it recalculates later when we go to
             * draw it again.
             */
            lpMenu->cxMenu = 0;
            lpMenu->cyMenu = 0;

            /*
             * Reset mnemonic underline info
             */
            for (iItem = 0; iItem < lpMenu->cItems; iItem++) {
                lpMenu->rgItems[iItem].ulX = UNDERLINE_RECALC;
                lpMenu->rgItems[iItem].ulWidth = 0;
                lpMenu->rgItems[iItem].cxBmp = MNIS_MEASUREBMP;
            }
        }
    }
}


/***************************************************************************\
* xxxRecreateSmallIcons()
*
* Recreates the class and/or window small icon when the caption height
* changes.  This needs to be done in context so that LR_COPYFROMRESOURCE
* can work right.
*
* History:
* 22-Jun-95 BradG   Ported from Win95
\***************************************************************************/

VOID xxxRecreateSmallIcons(PWND pwnd)
{
    BOOL    fSmQueryDrag;

    CheckLock(pwnd);

    if (DestroyClassSmIcon(pwnd->pcls))
        xxxCreateClassSmIcon(pwnd->pcls);

    fSmQueryDrag = (TestWF(pwnd, WFSMQUERYDRAGICON) != 0);
    if (DestroyWindowSmIcon(pwnd) && !fSmQueryDrag)
        xxxCreateWindowSmIcon(pwnd, (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\menudd.c ===
/****************************** Module Header ******************************\
* Module Name: menudd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu drag and drop - kernel
*
* History:
* 10/29/96  GerardoB    Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "callback.h"
/*
 * xxxClient* are callbacks from the kernel to call/load OLE functions
 * The other functions in this file are client calls into the kernel
 */
/**************************************************************************\
* xxxClientLoadOLE
*
* 11/06/96 GerardoB     Created
\**************************************************************************/
NTSTATUS xxxClientLoadOLE (void)
{
    NTSTATUS Status;
    PPROCESSINFO ppiCurrent = PpiCurrent();

    if (ppiCurrent->W32PF_Flags & W32PF_OLELOADED) {
        return STATUS_SUCCESS;
    }

    Status = xxxUserModeCallback(FI_CLIENTLOADOLE, NULL, 0, NULL, 0);
    if (NT_SUCCESS(Status)) {
        ppiCurrent->W32PF_Flags |= W32PF_OLELOADED;
    }
    return Status;
}
/**************************************************************************\
* xxxClientRegisterDragDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
NTSTATUS xxxClientRegisterDragDrop (HWND hwnd)
{
    return xxxUserModeCallback(FI_CLIENTREGISTERDRAGDROP, &hwnd, sizeof(&hwnd), NULL, 0);
}
/**************************************************************************\
* xxxClientRevokeDragDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
NTSTATUS xxxClientRevokeDragDrop (HWND hwnd)
{
    return xxxUserModeCallback(FI_CLIENTREVOKEDRAGDROP, &hwnd, sizeof(&hwnd), NULL, 0);

}
/**************************************************************************\
* xxxMNSetGapState
*
* 11/15/96 GerardoB     Created
\**************************************************************************/
void xxxMNSetGapState (ULONG_PTR uHitArea, UINT uIndex, UINT uFlags, BOOL fSet)
{
    int yTop;
    PITEM pItem, pItemGap;
    PPOPUPMENU ppopup;
    RECT rc;
    TL tlHitArea;

    /*
     * Bail if there is nothing to do.
     */
    if (!(uFlags & MNGOF_GAP) || !IsMFMWFPWindow(uHitArea)) {
        return;
    }

    ppopup = ((PMENUWND)uHitArea)->ppopupmenu;
    pItem = MNGetpItem(ppopup, uIndex);

    /*
     * The menu window might be destroyed by now so pItem could be NULL.
     */
    if (pItem == NULL) {
        return;
    }

    /*
     * Mark the item and set the rectangle we need to redraw.
     * Drawing/erasing the insertion bar unhilites/hiltes the
     *  item, so pItem needs to be redrawn completely. In additon,
     *  we need to draw the insertion bar in the next/previous item.
     */
    rc.left = pItem->xItem;
    rc.right = pItem->xItem + pItem->cxItem;
    rc.top = pItem->yItem;
    rc.bottom = pItem->yItem + pItem->cyItem;

    if (uFlags & MNGOF_TOPGAP) {
        pItemGap = MNGetpItem(ppopup, uIndex - 1);
        if (fSet) {
            SetMFS(pItem, MFS_TOPGAPDROP);
            if (pItemGap != NULL) {
                SetMFS(pItemGap, MFS_BOTTOMGAPDROP);
            }
        } else {
            ClearMFS(pItem, MFS_TOPGAPDROP);
            if (pItemGap != NULL) {
                ClearMFS(pItemGap, MFS_BOTTOMGAPDROP);
            }
        }
        if (pItemGap != NULL) {
            rc.top -= SYSMET(CYDRAG);
        }
    } else {
        pItemGap = MNGetpItem(ppopup, uIndex + 1);
        if (fSet) {
            SetMFS(pItem, MFS_BOTTOMGAPDROP);
            if (pItemGap != NULL) {
                SetMFS(pItemGap, MFS_TOPGAPDROP);
            }
        } else {
            ClearMFS(pItem, MFS_BOTTOMGAPDROP);
            if (pItemGap != NULL) {
                ClearMFS(pItemGap, MFS_TOPGAPDROP);
            }
        }
        if (pItemGap != NULL) {
            rc.bottom += SYSMET(CYDRAG);
        }
    }

    /*
     * Adjust to "menu" coordinates (for scrollable menus)
     */
    yTop = MNGetToppItem(ppopup->spmenu)->yItem;
    rc.top -= yTop;
    rc.bottom -= yTop;

    /*
     * Invalidate this rect to repaint it later
     */
    ThreadLockAlways((PWND)uHitArea, &tlHitArea);
    xxxInvalidateRect((PWND)uHitArea, &rc, TRUE);
    ThreadUnlock(&tlHitArea);
}
/**************************************************************************\
* xxxMNDragOver
*
* Menu windows involved in drag drop are registered as targets. This function
*  is called from the client side IDropTarget functions so the menu code can
*  update the selection given the mouse position
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
BOOL xxxMNDragOver(POINT * ppt, PMNDRAGOVERINFO pmndoi)
{
    BOOL fRet;
    PMENUSTATE pMenuState;
    PWND pwnd;
    PPOPUPMENU ppopup;
    TL tlpwnd;

    /*
     * OLE always calls us in context (proxy/marshall stuff). So the
     *  current thread must be in menu mode
     */
    pMenuState = PtiCurrent()->pMenuState;
    if (pMenuState == NULL) {
        RIPMSG0(RIP_WARNING, "xxxMNDragOver: Not in menu mode");
        return FALSE;
    }

    /*
     * This must be a drag and drop menu
     */
    UserAssert(pMenuState->fDragAndDrop);

    /*
     * We might have not initiated this DoDragDrop so make sure
     *  the internal flag is set.
     */
    pMenuState->fInDoDragDrop = TRUE;

    /*
     * Get a window to call xxxCallHandleMenuMessages
     */
    pwnd = GetMenuStateWindow(pMenuState);
    if (pwnd == NULL) {
        RIPMSG0(RIP_WARNING, "xxxMNDragOver: Failed to get MenuStateWindow");
        return FALSE;
    }

    /*
     * We need this after calling back, so lock it
     */
    LockMenuState(pMenuState);

    /*
     * Update the selection and the dragging info
     * Use WM_NCMOUSEMOVE because the point is in screen coordinates already.
     */
    ThreadLockAlways(pwnd, &tlpwnd);
    xxxCallHandleMenuMessages(pMenuState, pwnd, WM_NCMOUSEMOVE, 0, MAKELONG(ppt->x, ppt->y));
    ThreadUnlock(&tlpwnd);

    /*
     * If we're on a popup, propagate the hit test info
     */
    if (pMenuState->uDraggingHitArea != MFMWFP_OFFMENU) {
        ppopup = ((PMENUWND)pMenuState->uDraggingHitArea)->ppopupmenu;
        pmndoi->hmenu = PtoH(ppopup->spmenu);
        pmndoi->uItemIndex = pMenuState->uDraggingIndex;
        pmndoi->hwndNotify = PtoH(ppopup->spwndNotify);
        pmndoi->dwFlags = pMenuState->uDraggingFlags;
        /*
         * Bottom gap of item N corresponds to N+1 gap
         */
        if (pmndoi->dwFlags & MNGOF_BOTTOMGAP) {
            UserAssert(pmndoi->uItemIndex != MFMWFP_NOITEM);
            (pmndoi->uItemIndex)++;
        }
        fRet = TRUE;
    } else {
        fRet = FALSE;
    }

    xxxUnlockMenuState(pMenuState);
    return fRet;;

}
/**************************************************************************\
* xxxMNDragLeave
*
* 11/15/96 GerardoB     Created
\**************************************************************************/
BOOL xxxMNDragLeave (VOID)
{
    PMENUSTATE pMenuState;

    pMenuState = PtiCurrent()->pMenuState;
    if (pMenuState == NULL) {
        RIPMSG0(RIP_WARNING, "xxxMNDragLeave: Not in menu mode");
        return FALSE;
    }

    LockMenuState(pMenuState);

    /*
     * Clean up any present insertion bar state
     */
    xxxMNSetGapState(pMenuState->uDraggingHitArea,
                  pMenuState->uDraggingIndex,
                  pMenuState->uDraggingFlags,
                  FALSE);

    /*
     * Forget the last dragging area
     */
    UnlockMFMWFPWindow(&pMenuState->uDraggingHitArea);
    pMenuState->uDraggingIndex = MFMWFP_NOITEM;
    pMenuState->uDraggingFlags = 0;


    /*
     * The DoDragDrop loop has left our window.
     */
    pMenuState->fInDoDragDrop = FALSE;

    xxxUnlockMenuState(pMenuState);

    return TRUE;
}
/**************************************************************************\
* xxxMNUpdateDraggingInfo
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
void xxxMNUpdateDraggingInfo (PMENUSTATE pMenuState, ULONG_PTR uHitArea, UINT uIndex)
{
    BOOL fCross;
    int y, iIndexDelta;
    PITEM pItem;
    PPOPUPMENU ppopup;
    TL tlLastHitArea;
    ULONG_PTR uLastHitArea;
    UINT uLastIndex, uLastFlags;

    /*
     * Remember current dragging area so we can detected when
     *  crossing item/gap boundries.
     */
    UserAssert((pMenuState->uDraggingHitArea == 0) || IsMFMWFPWindow(pMenuState->uDraggingHitArea));
    ThreadLock((PWND)pMenuState->uDraggingHitArea, &tlLastHitArea);
    uLastHitArea = pMenuState->uDraggingHitArea;
    uLastIndex = pMenuState->uDraggingIndex;
    uLastFlags = pMenuState->uDraggingFlags & MNGOF_GAP;

    /*
     * Store new dragging area.
     */
    LockMFMWFPWindow(&pMenuState->uDraggingHitArea, uHitArea);
    pMenuState->uDraggingIndex = uIndex;

    /*
     * If we're not on a popup, done.
     */
    if (!IsMFMWFPWindow(pMenuState->uDraggingHitArea)) {
        pMenuState->uDraggingHitArea = MFMWFP_OFFMENU;
        pMenuState->uDraggingIndex = MFMWFP_NOITEM;
        ThreadUnlock(&tlLastHitArea);
        return;
    }

    /*
     * Get the popup and item we're on
     */
    ppopup = ((PMENUWND)pMenuState->uDraggingHitArea)->ppopupmenu;
    pItem = MNGetpItem(ppopup, pMenuState->uDraggingIndex);

    /*
     * Find out if we're on the gap, that is, the "virtual" space
     *  between items. Some apps want to distinguish between a drop
     *  ON the item and a drop BEFORE/AFTER the item; there is no
     *  actual space between items so we define a virtual gap
     *
     */
    pMenuState->uDraggingFlags = 0;
    if (pItem != NULL) {
        /*
         * Map the point to client coordinates and then to "menu"
         *  coordinates (to take care of scrollable menus)
         */
        y = pMenuState->ptMouseLast.y;
        y -= ((PWND)pMenuState->uDraggingHitArea)->rcClient.top;
        y += MNGetToppItem(ppopup->spmenu)->yItem;
#if DBG
        if ((y < (int)pItem->yItem)
                || (y > (int)(pItem->yItem + pItem->cyItem))) {
            RIPMSG4(RIP_ERROR, "xxxMNUpdateDraggingInfo: y Point not in selected item. "
                               "pwnd:%#lx ppopup:%#lx Index:%#lx pItem:%#lx",
                               pMenuState->uDraggingHitArea, ppopup, pMenuState->uDraggingIndex, pItem);
        }
#endif

        /*
         * Top/bottom gap check
         */
        if (y <= (int)(pItem->yItem + SYSMET(CYDRAG))) {
            pMenuState->uDraggingFlags = MNGOF_TOPGAP;
        } else if (y >= (int)(pItem->yItem + pItem->cyItem - SYSMET(CYDRAG))) {
            pMenuState->uDraggingFlags = MNGOF_BOTTOMGAP;
        }
    }

    /*
     * Have we crossed an item/gap boundary?
     * We don't cross a boundary when we move from the bottom
     *  of an item to the top of the next, or, from the top
     *  of an item to the bottom of the previous.
     *  (Item N is on top of and previous to item N+1).
     */
    fCross = (uLastHitArea != pMenuState->uDraggingHitArea);
    if (!fCross) {
        iIndexDelta = (int)pMenuState->uDraggingIndex - (int)uLastIndex;
        switch (iIndexDelta) {
            case 0:
                /*
                 * We're on the same item.
                 */
                fCross = (uLastFlags != pMenuState->uDraggingFlags);
                break;

            case 1:
                /*
                 * We've moved to the next item
                 */
                fCross = !((pMenuState->uDraggingFlags == MNGOF_TOPGAP)
                          && (uLastFlags == MNGOF_BOTTOMGAP));
                break;

            case -1:
                /*
                 * We've moved to the previous item
                 */
                fCross = !((pMenuState->uDraggingFlags == MNGOF_BOTTOMGAP)
                          && (uLastFlags == MNGOF_TOPGAP));
                break;

            default:
                /*
                 * We've skipped more than one item.
                 */
                fCross = TRUE;
        }
    }

    if (fCross) {
        pMenuState->uDraggingFlags |= MNGOF_CROSSBOUNDARY;

        /*
         * Update the insertion bar state.
         */
        xxxMNSetGapState(uLastHitArea, uLastIndex, uLastFlags, FALSE);
        xxxMNSetGapState(pMenuState->uDraggingHitArea,
                      pMenuState->uDraggingIndex,
                      pMenuState->uDraggingFlags,
                      TRUE);
    }

    ThreadUnlock(&tlLastHitArea);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\minmax.c ===
/****************************** Module Header ******************************\
* Module Name: minmax.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*  Window Minimize/Maximize Routines
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop



/*
 * How long we want animation to last, in milliseconds
 */
#define CMS_ANIMATION       250
#define DX_GAP      (SYSMET(CXMINSPACING) - SYSMET(CXMINIMIZED))
#define DY_GAP      (SYSMET(CYMINSPACING) - SYSMET(CYMINIMIZED))

/***************************************************************************\
* xxxInitSendValidateMinMaxInfo()
*
* Routine which initializes the minmax array, sends WM_GETMINMAXINFO to
* the caller, and validates the results.
*
* Returns FALSE is the window went away in the middle.
*
\***************************************************************************/

void
xxxInitSendValidateMinMaxInfo(PWND pwnd, LPMINMAXINFO lpmmi)
{
    PTHREADINFO     ptiCurrent;
    PMONITOR        pMonitorReal;
    PMONITOR        pMonitorPrimary;
    TL              tlpMonitorReal;
    TL              tlpMonitorPrimary;
    CHECKPOINT *    pcp;
    RECT            rcParent;
    int             cBorders;
    int             xMin, yMin;
    BOOL            bTopLevel;

    CheckLock(pwnd);

    ptiCurrent = PtiCurrent();

    /*
     * FILL IN THE MINMAXINFO WE THINK IS APPROPRIATE
     */

    /*
     * Minimized Size
     */
    lpmmi->ptReserved.x = SYSMET(CXMINIMIZED);
    lpmmi->ptReserved.y = SYSMET(CYMINIMIZED);

    /*
     * Maximized Position and Size
     * Figure out where the window would be maximized within its parent.
     */
    pMonitorPrimary = GetPrimaryMonitor();

    /*
     * [msadek], #31003
     * Cache window parent status in case some code reparents
     * the window during WM_GETMINMAXINFO
     */ 
    if (bTopLevel = (pwnd->spwndParent == PWNDDESKTOP(pwnd))) {
        /* What monitor is the window really going to maximize to? */
        pMonitorReal = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);

        /* Send dimensions based on the primary only. */
        rcParent = pMonitorPrimary->rcMonitor;
    } else {
        pMonitorReal = NULL;
        _GetClientRect(pwnd->spwndParent, &rcParent);
    }

    cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

    InflateRect(&rcParent,
                cBorders * SYSMET(CXBORDER),
                cBorders * SYSMET(CYBORDER));

    rcParent.right -= rcParent.left;
    rcParent.bottom -= rcParent.top;

    /* rcParent.right, bottom are width and height now. */
    lpmmi->ptMaxSize.x = rcParent.right;
    lpmmi->ptMaxSize.y = rcParent.bottom;

    pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);
    if (pcp && pcp->fMaxInitialized) {
        /*
         * Note:  For top level windows, we will fix this point up after
         * the fact if it has gotten out of date because the size border
         * changed.
         */
        lpmmi->ptMaxPosition = pcp->ptMax;
    } else {
        lpmmi->ptMaxPosition = *((LPPOINT)&rcParent.left);
    }

    /*
     * Normal minimum tracking size
     * Only enforce min tracking size for windows with captions
     */
    xMin = cBorders*SYSMET(CXEDGE);
    yMin = cBorders*SYSMET(CYEDGE);

    if (TestWF(pwnd, WFCAPTION) && !TestWF(pwnd, WEFTOOLWINDOW)) {
        lpmmi->ptMinTrackSize.x = SYSMET(CXMINTRACK);
        lpmmi->ptMinTrackSize.y = SYSMET(CYMINTRACK);
    } else {
        lpmmi->ptMinTrackSize.x = max(SYSMET(CXEDGE), xMin);
        lpmmi->ptMinTrackSize.y = max(SYSMET(CYEDGE), yMin);
    }

    /*
     * Normal maximum tracking size
     */
    lpmmi->ptMaxTrackSize.x = SYSMET(CXMAXTRACK);
    lpmmi->ptMaxTrackSize.y = SYSMET(CYMAXTRACK);

    /*
     * SEND THE WM_GETMINMAXINFO MESSAGE
     */

    ThreadLockWithPti(ptiCurrent, pMonitorReal, &tlpMonitorReal);
    ThreadLockAlwaysWithPti(ptiCurrent, pMonitorPrimary, &tlpMonitorPrimary);
    xxxSendMessage(pwnd, WM_GETMINMAXINFO, 0, (LPARAM)lpmmi);

    /*
     * VALIDATE THE MINMAXINFO
     */

    /*
     * Minimized Size (this is read only)
     */
    lpmmi->ptReserved.x = SYSMET(CXMINIMIZED);
    lpmmi->ptReserved.y = SYSMET(CYMINIMIZED);

    /*
     * Maximized Postion and Size (only for top level windows)
     */
    if (bTopLevel) {
        LPRECT  lprcRealMax;

        GetMonitorMaxArea(pwnd, pMonitorReal, &lprcRealMax);

        /*
         * Is the window a TRUE maximized dude, or somebody like the DOS box
         * who can maximize but not take up the entire screen?
         *
         * Is the window really maximizeable?
         */
        if ((lpmmi->ptMaxSize.x >= (pMonitorPrimary->rcMonitor.right - pMonitorPrimary->rcMonitor.left)) &&
            (lpmmi->ptMaxSize.y >= (pMonitorPrimary->rcMonitor.bottom - pMonitorPrimary->rcMonitor.top))) {

            SetWF(pwnd, WFREALLYMAXIMIZABLE);

            /*
             * Need to reload the checkpoint here, since it might have gotten
             * blown away while we were in the xxxSendMessage call above.
             */
            pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);

            if (    pcp &&
                    pcp->fMaxInitialized &&
                    TestWF(pwnd, WFSIZEBOX) &&
                    (lpmmi->ptMaxPosition.x != rcParent.left) &&
                    (pcp->ptMax.x == lpmmi->ptMaxPosition.x)) {

                /*
                 * If this window has a weird maximize point that doesn't jibe
                 * with what we'd expect and it has a checkpoint, fix up the
                 * checkpoint.  It means that somebody's WINDOWPLACEMENT
                 * got out of date when the size border changed dimensions.
                 */
                pcp->fMaxInitialized = FALSE;

                lpmmi->ptMaxPosition.y += (rcParent.left - lpmmi->ptMaxPosition.x);
                lpmmi->ptMaxPosition.x = rcParent.left;
            }

            /*
             * Transfer the maximum size over to the monitor we are REALLY
             * moving to.  And fix up guys going fullscreen.  A whole bunch
             * of Consumer titles + Word '95 and XL '95 move their caption
             * above the top of the monitor when going fullscreen.  Detect
             * these guys now, and let them take up the monitor.
             */
            if (    lpmmi->ptMaxPosition.y + SYSMET(CYCAPTION) <=
                        pMonitorPrimary->rcMonitor.top
                    &&
                    lpmmi->ptMaxPosition.y + lpmmi->ptMaxSize.y >=
                        pMonitorPrimary->rcMonitor.bottom) {

                lprcRealMax = &pMonitorReal->rcMonitor;
            }

            /*
             * Compensate for the difference between the primary monitor
             * and the monitor we are actually on.
             */
            lpmmi->ptMaxSize.x = lpmmi->ptMaxSize.x -
                (pMonitorPrimary->rcMonitor.right - pMonitorPrimary->rcMonitor.left) +
                (lprcRealMax->right - lprcRealMax->left);

            lpmmi->ptMaxSize.y = lpmmi->ptMaxSize.y -
                (pMonitorPrimary->rcMonitor.bottom - pMonitorPrimary->rcMonitor.top) +
                (lprcRealMax->bottom - lprcRealMax->top);
        } else {
            ClrWF(pwnd, WFREALLYMAXIMIZABLE);
        }

        /*
         * Now transfer the max position over to the monitor we are REALLY
         * moving to.
         */
        lpmmi->ptMaxPosition.x += lprcRealMax->left;
        lpmmi->ptMaxPosition.y += lprcRealMax->top;
    }

    ThreadUnlock(&tlpMonitorPrimary);
    ThreadUnlock(&tlpMonitorReal);

    /*
     * Normal minimum tracking size.
     */

    /*
     * WFCAPTION == WFBORDER | WFDLGFRAME; So, when we want to test for the
     * presence of CAPTION, we must test for both the bits. Otherwise we
     * might mistake WFBORDER or WFDLGFRAME to be a CAPTION.
     *
     *
     * We must not allow a window to be sized smaller than the border
     * thickness -- SANKAR -- 06/12/91 --
     */
    if (TestWF(pwnd, WFCPRESENT)) {

        /*
         * NOTE THAT IF YOU CHANGE THE SPACING OF STUFF IN THE CAPTION,
         * YOU NEED TO KEEP THE FOLLOWING IN SSYNC:
         *      (1) Default CXMINTRACK, CYMINTRACK in inctlpan.c
         *      (2) The default minimum right below
         *      (3) Hit testing
         *
         * The minimum size should be space for:
         *      * The borders
         *      * The buttons
         *      * Margins
         *      * 4 chars of text
         *      * Caption icon
         */
        yMin = SYSMET(CYMINTRACK);

        /*
         * Min track size is determined by the number of buttons in
         * the caption.
         */
        if (TestWF(pwnd, WEFTOOLWINDOW)) {

            /*
             * Add in space for close button.
             */
            if (TestWF(pwnd, WFSYSMENU))
                xMin += SYSMET(CXSMSIZE);

            /*
             * DON'T add in space for 2 characters--breaks
             * MFC toolbar stuff.  They want to make vertical undocked
             * toolbars narrower than what that would produce.
             */
            xMin += (2 * SYSMET(CXEDGE));

        } else {

            if (TestWF(pwnd, WFSYSMENU)) {

                /*
                 * Add in space for min/max/close buttons.  Otherwise,
                 * if it's a contexthelp window, then add in space
                 * for help/close buttons.
                 */
                if (TestWF(pwnd, (WFMINBOX | WFMAXBOX)))
                    xMin += 3 * SYSMET(CXSIZE);
                else if (TestWF(pwnd, WEFCONTEXTHELP))
                    xMin += 2 * SYSMET(CXSIZE);


                /*
                 * Add in space for system menu icon.
                 */
                if (_HasCaptionIcon(pwnd))
                    xMin += SYSMET(CYSIZE);
            }

            /*
             * Add in space for 4 characters and margins.
             */
            xMin += 4 * gcxCaptionFontChar + 2 * SYSMET(CXEDGE);
        }
    }

    lpmmi->ptMinTrackSize.x = max(lpmmi->ptMinTrackSize.x, xMin);
    lpmmi->ptMinTrackSize.y = max(lpmmi->ptMinTrackSize.y, yMin);
}



/***************************************************************************\
* ParkIcon
*
* Called when minimizing a window.  This parks the minwnd in the position
* given in the checkpoint or calculates a new position for it.
*
* LauraBu 10/15/92
* We now let the user specify two things that affect parking and arranging:
*     (1) The corner to start arranging from
*     (2) The direction to move in first
* MCostea 11/13/98  #246397
*   Add sanity check for the number of tries.  If the metrics are messed up
*   and pwnd has a lot of siblings, the for-ever loop would make us timeout
*
\***************************************************************************/

VOID ParkIcon(
    PWND        pwnd,
    PCHECKPOINT pcp)
{
    RECT        rcTest;
    RECT        rcT;
    UINT        xIconPositions;
    UINT        xIconT;
    PWND        pwndTest;
    PWND        pwndParent;
    int         xOrg;
    int         yOrg;
    int         dx;
    int         dy;
    int         dxSlot;
    int         dySlot;
    int         iteration;
    BOOL        fHorizontal;
    PCHECKPOINT pncp;

    /*
     * Put these into local vars immediately.  The compiler is too dumb to
     * know that we're using a constant offset into a constant address, and
     * thus a resulting constant address.
     */
    dxSlot = SYSMET(CXMINSPACING);
    dySlot = SYSMET(CYMINSPACING);

    if (IsTrayWindow(pwnd)) {

        pcp->fMinInitialized = TRUE;
        pcp->ptMin.x         = WHERE_NOONE_CAN_SEE_ME;
        pcp->ptMin.y         = WHERE_NOONE_CAN_SEE_ME;

        return;
    }

    /* We need to adjust the client rectangle for scrollbars, just like we
     * do in ArrangeIconicWindows().  If one thing is clear, it is that
     * parking and arranging must follow the same principles.  This is to
     * avoid the user arranging some windows, creating a new one, and parking
     * it in a place not consistent with the arrangement of the others.
     */
    pwndParent = pwnd->spwndParent;
    GetRealClientRect(pwndParent, &rcT, GRC_SCROLLS, NULL);

    /*
     * Get gravity & move vars.  We want gaps to start on the sides that
     * we begin arranging from.
     *
     * Horizontal gravity
     */
    if (SYSMET(ARRANGE) & ARW_STARTRIGHT) {

        /*
         * Starting on right side
         */
        rcTest.left = xOrg = rcT.right - dxSlot;
        dx = -dxSlot;

    } else {

        /*
         * Starting on left
         */
        rcTest.left = xOrg = rcT.left + DX_GAP;
        dx = dxSlot;
    }

    /*
     * Vertical gravity
     */
    if (SYSMET(ARRANGE) & ARW_STARTTOP) {

        /*
         * Starting on top side
         */
        rcTest.top = yOrg = rcT.top + DY_GAP;
        dy = dySlot;

    } else {

        /*
         * Starting on bottom
         */
        rcTest.top = yOrg = rcT.bottom - dySlot;
        dy = -dySlot;
    }

    /*
     * Get arrangement direction.  Note that ARW_HORIZONTAL is 0, so we
     * can't test for it.
     */
    fHorizontal = ((SYSMET(ARRANGE) & ARW_DOWN) ? FALSE : TRUE);

    if (fHorizontal)
        xIconPositions = xIconT = max(1, (rcT.right / dxSlot));
    else
        xIconPositions = xIconT = max(1, (rcT.bottom / dySlot));

    /*
     * BOGUS
     * LauraBu 10/15/92
     * What happens if the parent is scrolled over horizontally or
     * vertically?  Just like when you drop an object...
     */
    iteration = 0;
    while (iteration < 5000) {

        /*
         * Make a rectangle representing this position, in screen coords
         */
        rcTest.right = rcTest.left + dxSlot;
        rcTest.bottom = rcTest.top + dySlot;

        /*
         * Look for intersections with existing iconic windows
         */
        for (pwndTest = pwndParent->spwndChild; pwndTest; pwndTest = pwndTest->spwndNext) {

            if (!TestWF(pwndTest, WFVISIBLE))
                    continue;

            if (pwndTest == pwnd)
                    continue;

            if (!TestWF(pwndTest, WFMINIMIZED)) {

                /*
                 * This is a non-minimized window.  See if it has a checkpoint
                 * and find out where it would be if it were minimized.  We
                 * will try not to park an icon in this spot.
                 */
                pncp = (PCHECKPOINT)_GetProp(pwndTest,
                                             PROP_CHECKPOINT,
                                             PROPF_INTERNAL);

                if (!pncp || !pncp->fDragged || !pncp->fMinInitialized)
                    continue;

                /*
                 * Get parent coordinates of minimized window pos.
                 */
                rcT.right   = rcT.left = pncp->ptMin.x;
                rcT.right  += dxSlot;
                rcT.bottom  = rcT.top  = pncp->ptMin.y;
                rcT.bottom += dySlot;

            } else {

                /*
                 * Get parent coordinates of currently minimized window
                 */
                GetRect(pwndTest, &rcT, GRECT_WINDOW | GRECT_PARENTCOORDS);
            }

            iteration++;
            /*
             * Get out of loop if they overlap
             */
            if (IntersectRect(&rcT, &rcT, &rcTest))
                break;
        }

        /*
         * Found a position that doesn't overlap, so get out of search loop
         */
        if (!pwndTest)
            break;

        /*
         * Else setup to process the next position
         */
        if (--xIconT == 0) {

            /*
             * Setup next pass
             */
            xIconT = xIconPositions;

            if (fHorizontal) {
                rcTest.left = xOrg;
                rcTest.top += dy;
            } else {
                rcTest.left += dx;
                rcTest.top = yOrg;
            }

        } else {

            /*
             * Same pass.
             */
            if (fHorizontal)
                rcTest.left += dx;
            else
                rcTest.top += dy;
        }
    }

    /*
     * Note that rcTest is in parent coordinates already.
     */
    pcp->fMinInitialized = TRUE;
    pcp->ptMin.x         = rcTest.left;
    pcp->ptMin.y         = rcTest.top;
}

/***************************************************************************\
* xxxAnimateCaption
*
*
\***************************************************************************/

ULONG_PTR SaveScreen(PWND pwnd, ULONG iMode, ULONG_PTR iSave, int x, int y, int cx, int cy)
{
    RECT rc;

    /*
     * x and y are in the DC coordinates, make the screen in the
     * (meta hdev) coordinates for the call to Gre/driver.
     */
    rc.left = x + pwnd->rcWindow.left;
    rc.right = x + cx;
    rc.top = y + pwnd->rcWindow.top;
    rc.bottom = y + cy;

    if (IntersectRect(&rc, &rc, &gpDispInfo->rcScreen)) {
        return GreSaveScreenBits(gpDispInfo->hDev, iMode, iSave, (RECTL*)&rc);
    } else {
        return 0;
    }
}

VOID xxxAnimateCaption(
    PWND   pwnd,
    HDC    hdc,
    LPRECT lprcStart,
    LPRECT lprcEnd)
{
    DWORD        dwTimeStart;
    DWORD        iTimeElapsed;
    int          iLeftStart;
    int          iTopStart;
    int          cxStart;
    int          dLeft;
    int          dTop;
    int          dcx;
    int          iLeft;
    int          iTop;
    int          cx;
    int          iLeftNew;
    int          iTopNew;
    int          cxNew;
    int          cBorders;
    HBITMAP      hbmpOld;
    RECT         rc;
    int          cy;
    HDC          hdcMem;
    ULONG_PTR     uSave;
    PWND         pwndOrg;

    CheckLock(pwnd);

    if ((pwndOrg = _WindowFromDC(hdc)) == NULL) {
        RIPMSG0(RIP_WARNING, "SaveScreen: invalid DC passed in");
        return;
    }

    cy = SYSMET(CYCAPTION) - 1;

    /*
     *  kurtp: 29-Jan-1997
     *
     *  We don't do anything when animating the caption,
     *  because we couldn't get the desired effect at the
     *  client.  If we do use it then the
     *  cache gets a bunch of bitmaps (size: 2xCaption by CXScreen)
     *  that are never re-used.  This slows down clients
     *  because the GreBitBlts always generate new bitmaps
     *  and the cache is displaced by the new bitmaps (yuk!).
     */
    
    if (IsRemoteConnection() || SYSMETBOOL2(SM_REMOTECONTROL))
        return;

    if ((hdcMem = GreCreateCompatibleDC(ghdcMem)) == NULL)
        return;

    /*
     * If the caption strip doesn't exist, then attempt to recreate it.  This
     * might be necessary if the user does a mode-switch during low memory
     * and is not able to recreate the surface.  When the memory becomes
     * available, we'll attempt to recreate it here.
     */
    if (ghbmCaption == NULL) {
        ghbmCaption = CreateCaptionStrip();
    }

    hbmpOld = GreSelectBitmap(hdcMem, ghbmCaption);

    /*
     * initialize start values
     */
    iTopStart  = lprcStart->top;
    iLeftStart = lprcStart->left;
    cxStart    = lprcStart->right - iLeftStart;

    /*
     * initialize delta values to the destination dimensions
     */
    dLeft  = lprcEnd->left;
    dTop   = lprcEnd->top;
    dcx    = lprcEnd->right - dLeft;

    /*
     * adjust for window borders as appropriate
     */
    cBorders = GetWindowBorders(pwnd->style,
                                pwnd->ExStyle,
                                TRUE,
                                FALSE);

    if ((lprcStart->bottom - iTopStart) > SYSMET(CYCAPTION)) {

        iLeftStart += cBorders;
        iTopStart  += cBorders;
        cxStart    -= 2*cBorders;
    }

    if ((lprcEnd->bottom - dTop) > SYSMET(CYCAPTION)) {

        dLeft += cBorders;
        dTop  += cBorders;
        dcx   -= 2*cBorders;
    }

    /*
     * initialize step values
     */
    iLeft = iLeftStart;
    iTop  = iTopStart;
    cx    = cxStart;

    /*
     * initialize off screen bitmap with caption drawing and first saved rect
     */
    rc.left   = 0;
    rc.top    = cy;
    rc.right  = max(cxStart, dcx);
    rc.bottom = cy * 2;

    xxxDrawCaptionTemp(pwnd,
                       hdcMem,
                       &rc,
                       NULL,
                       NULL,
                       NULL,
                       DC_ACTIVE | DC_ICON | DC_TEXT |
                       (TestALPHA(GRADIENTCAPTIONS) ? DC_GRADIENT : 0));

    if ((uSave = SaveScreen(pwndOrg, SS_SAVE, 0,iLeft, iTop, cx, cy)) == 0) {
        if (!GreBitBlt(hdcMem,
                  0,
                  0,
                  cx,
                  cy,
                  hdc,
                  iLeft,
                  iTop,
                  SRCCOPY,
                  0)) {
            goto Cleanup;
        }
    }

    /*
     * compute delta values by subtracting source dimensions
     */
    dLeft -= iLeftStart;
    dTop  -= iTopStart;
    dcx   -= cxStart;

    /*
     * blt and time first caption on screen
     * WARNING: If you use *lpSystemTickCount here,
     * the compiler may not generate code to do a DWORD fetch;
     */
    dwTimeStart = NtGetTickCount();
    GreBitBlt(hdc,
              iLeft,
              iTop,
              cx,
              cy,
              hdcMem,
              0,
              cy,
              SRCCOPY,
              0);

    iTimeElapsed = (NtGetTickCount() - dwTimeStart);

    while (LOWORD(iTimeElapsed) <= CMS_ANIMATION) {

        iLeftNew = iLeftStart + MultDiv(dLeft, LOWORD(iTimeElapsed), CMS_ANIMATION);
        iTopNew  = iTopStart  + MultDiv(dTop,  LOWORD(iTimeElapsed), CMS_ANIMATION);
        cxNew    = cxStart    + MultDiv(dcx,   LOWORD(iTimeElapsed), CMS_ANIMATION);

        /*
         * Delay before next frame
         */
        UserSleep(1);

        /*
         * restore saved rect
         */
        if (uSave != 0) {
            SaveScreen(pwndOrg, SS_RESTORE, uSave, iLeft, iTop, cx, cy);
        } else {
            GreBitBlt(hdc,
                      iLeft,
                      iTop,
                      cx,
                      cy,
                      hdcMem,
                      0,
                      0,
                      SRCCOPY,
                      0);
        }

        iLeft = iLeftNew;
        iTop  = iTopNew;
        cx    = cxNew;

        /*
         * save new rect offscreen and then draw over it onscreen.
         */
        if (uSave != 0) {
            uSave = SaveScreen(pwndOrg, SS_SAVE, 0, iLeft, iTop, cx, cy);
        } else {
            GreBitBlt(hdcMem,
                      0,
                      0,
                      cx,
                      cy,
                      hdc,
                      iLeft,
                      iTop,
                      SRCCOPY,
                      0);
        }
        GreBitBlt(hdc,
                  iLeft,
                  iTop,
                  cx,
                  cy,
                  hdcMem,
                  0,
                  cy,
                  SRCCOPY,
                  0);

        /*
         * update elapsed time
         * WARNING: If you use *lpSystemTickCount here,
         * the compiler may not generate code to do a DWORD fetch;
         */
        iTimeElapsed = (NtGetTickCount() - dwTimeStart);
    }

    /*
     * restore saved rect
     */
    if (uSave != 0) {
        SaveScreen(pwndOrg, SS_RESTORE, uSave, iLeft, iTop, cx, cy);
    } else {
        GreBitBlt(hdc,
                  iLeft,
                  iTop,
                  cx,
                  cy,
                  hdcMem,
                  0,
                  0,
                  SRCCOPY,
                  0);
    }

Cleanup:
    GreSelectBitmap(hdcMem, hbmpOld);
    GreDeleteDC(hdcMem);
}

#if 0 // DISABLE OLD ANIMATION FOR M7
/***************************************************************************\
* DrawWireFrame
*
* Draws wire frame trapezoid
*
*
\***************************************************************************/

VOID DrawWireFrame(
    HDC    hdc,
    LPRECT prcFront,
    LPRECT prcBack)
{
    RECT rcFront;
    RECT rcBack;
    RECT rcT;
    HRGN hrgnSave;
    BOOL fClip;

    /*
     * Save these locally
     */
    CopyRect(&rcFront, prcFront);
    CopyRect(&rcBack, prcBack);

    /*
     * Front face
     */
    GreMoveTo(hdc, rcFront.left, rcFront.top);
    GreLineTo(hdc, rcFront.left, rcFront.bottom);
    GreLineTo(hdc, rcFront.right, rcFront.bottom);
    GreLineTo(hdc, rcFront.right, rcFront.top);
    GreLineTo(hdc, rcFront.left, rcFront.top);

    /*
     * Exclude front face from clipping area, only if back face isn't
     * entirely within interior.  We need variable because SaveClipRgn()
     * can return NULL.
     */
    fClip = (EqualRect(&rcFront, &rcBack)            ||
             !IntersectRect(&rcT, &rcFront, &rcBack) ||
             !EqualRect(&rcT, &rcBack));

    if (fClip) {

        hrgnSave = GreSaveClipRgn(hdc);

        GreExcludeClipRect(hdc,
                           rcFront.left,
                           rcFront.top,
                           rcFront.right,
                           rcFront.bottom);
    }

    /*
     * Edges
     */
    GreMoveTo(hdc, rcBack.left, rcBack.top);
    LineTo(hdc, rcFront.left, rcFront.top);

    GreMoveTo(hdc, rcBack.right, rcBack.top);
    GreLineTo(hdc, rcFront.right, rcFront.top);

    GreMoveTo(hdc, rcBack.right, rcBack.bottom);
    GreLineTo(hdc, rcFront.right, rcFront.bottom);

    GreMoveTo(hdc, rcBack.left, rcBack.bottom);
    GreLineTo(hdc, rcFront.left, rcFront.bottom);

    /*
     * Back face
     */
    MoveTo(hdc, rcBack.left, rcBack.top);
    LineTo(hdc, rcBack.left, rcBack.bottom);
    LineTo(hdc, rcBack.right, rcBack.bottom);
    LineTo(hdc, rcBack.right, rcBack.top);
    LineTo(hdc, rcBack.left, rcBack.top);

    if (fClip)
        GreRestoreClipRgn(hdc, hrgnSave);
}

/***************************************************************************\
* AnimateFrame
*
* Draws wire frame 3D trapezoid
*
*
\***************************************************************************/

VOID AnimateFrame(
    HDC    hdc,
    LPRECT prcStart,
    LPRECT prcEnd,
    BOOL   fGrowing)
{
    RECT  rcBack;
    RECT  rcFront;
    RECT  rcT;
    HPEN  hpen;
    int   nMode;
    int   iTrans;
    int   nTrans;
    DWORD dwTimeStart;
    DWORD dwTimeCur;

    /*
     * Get pen for drawing lines
     */
    hpen = GreSelectPen(hdc, GetStockObject(WHITE_PEN));
    nMode = GreSetROP2(hdc, R2_XORPEN);

    /*
     * Save these locally
     */
    if (fGrowing) {

        CopyRect(&rcBack, prcStart);
        CopyRect(&rcFront, prcStart);

    } else {

       /*
        * Initial is trapezoid entire way from small to big.  We're going
        * to shrink it from the front face.
        */
       CopyRect(&rcFront, prcStart);
       CopyRect(&rcBack, prcEnd);
    }

    /*
     * Offset left & top edges of rects, due to way that lines work.
     */
    rcFront.left -= 1;
    rcFront.top  -= 1;
    rcBack.left  -= 1;
    rcBack.top   -= 1;

    /*
     * Get tick count.  We'll draw then check how much time elapsed.  From
     * that we can calculate how many more transitions to draw.  For the first
     * We basically want whole animation to last 3/4 of a second, or 750
     * milliseconds.
     *
     * WARNING: If you use *lpSystemTickCount here,
     * the compiler may not generate code to do a DWORD fetch;
     */
    dwTimeStart = GetSystemMsecCount();

    DrawWireFrame(hdc, &rcFront, &rcBack);

    /*
     * WARNING: If you use *lpSystemTickCount here,
     * the compiler may not generate code to do a DWORD fetch;
     */
    dwTimeCur = GetSystemMsecCount();

    /*
     * Get rough estimate for how much time it took.
     */
    if (dwTimeCur == dwTimeStart)
        nTrans = CMS_ANIMATION / 55;
    else
        nTrans = CMS_ANIMATION / ((int)(dwTimeCur - dwTimeStart));

    iTrans = 1;
    while (iTrans <= nTrans) {

        /*
         * Grow the trapezoid out or shrink it in.  Fortunately, prcStart
         * and prcEnd are already set up for us.
         */
        rcT.left = prcStart->left +
            MultDiv(prcEnd->left - prcStart->left, iTrans, nTrans);
        rcT.top = prcStart->top +
            MultDiv(prcEnd->top - prcStart->top, iTrans, nTrans);
        rcT.right = prcStart->right +
            MultDiv(prcEnd->right - prcStart->right, iTrans, nTrans);
        rcT.bottom = prcStart->bottom +
            MultDiv(prcEnd->bottom - prcStart->bottom, iTrans, nTrans);

        /*
         * Undraw old and draw new
         */
        DrawWireFrame(hdc, &rcFront, &rcBack);
        CopyRect(&rcFront, &rcT);
        DrawWireFrame(hdc, &rcFront, &rcBack);

        /*
         * Check the time.  How many more transitions left?
         *  iTrans / nTrans AS (dwTimeCur-dwTimeStart) / 750
         *
         * WARNING: If you use *lpSystemTickCount here,
         * the compiler may not generate code to do a DWORD fetch;
         */
        dwTimeCur = GetSystemMsecCount();
        iTrans = MultDiv(nTrans,
                         (int)(dwTimeCur - dwTimeStart),
                         CMS_ANIMATION);
    }

    /*
     * Undraw wire frame
     */
    DrawWireFrame(hdc, &rcFront, &rcBack);

    /*
     * Clean up
     */
    GreSetROP2(hdc, nMode);
    hpen = GreSelectPen(hdc, hpen);
}
#endif // END DISABLE OLD ANIMATION FOR M7

/***************************************************************************\
* xxxDrawAnimatedRects
*
* General routine, like PlaySoundEvent(), that calls other routines for
* various animation effects.  Currently used for changing state from/to
* minimized.
*
\***************************************************************************/

BOOL xxxDrawAnimatedRects(
    PWND   pwndClip,
    int    idAnimation,
    LPRECT lprcStart,
    LPRECT lprcEnd)
{
    HDC   hdc;
    POINT rgPt[4];
    RECT  rcClip;
    HRGN  hrgn;
    PWND  pwndAnimate = NULL;
    int   iPt;

    CheckLock(pwndClip);

    /*
     * Get rects into variables
     */
    CopyRect((LPRECT)&rgPt[0], lprcStart);
    CopyRect((LPRECT)&rgPt[2], lprcEnd);

    /*
     * DISABLE OLD ANIMATION FOR M7
     */
    if (idAnimation != IDANI_CAPTION)
        return TRUE;

    pwndAnimate = pwndClip;
    if (!pwndAnimate || pwndAnimate == PWNDDESKTOP(pwndAnimate))
        return FALSE;

    pwndClip = pwndClip->spwndParent;
    if (!pwndClip) {
        RIPMSG0(RIP_WARNING, "xxxDrawAnimatedRects: pwndClip->spwndParent is NULL");
    } else if (pwndClip == PWNDDESKTOP(pwndClip)) {
        pwndClip = NULL;
    }

    /*
     * NOTE:
     * We do NOT need to do LockWindowUpdate().  We never yield within this
     * function!  Anything that was invalid will stay invalid, etc.  So our
     * XOR drawing won't leave remnants around.
     *
     * WIN32NT may need to take display critical section or do LWU().
     *
     * Get clipping area
     * Neat feature:
     *      NULL window means whole screen, don't clip out children
     *      hwndDesktop means working area, don't clip out children
     */
    if (pwndClip == NULL) {
        pwndClip = _GetDesktopWindow();
        CopyRect(&rcClip, &pwndClip->rcClient);
        if ((hrgn = GreCreateRectRgnIndirect(&rcClip)) == NULL) {
            hrgn = HRGN_FULL;
        }

        /*
         * Get drawing DC
         */
        hdc = _GetDCEx(pwndClip,
                       hrgn,
                       DCX_WINDOW           |
                           DCX_CACHE        |
                           DCX_INTERSECTRGN |
                           DCX_LOCKWINDOWUPDATE);
    } else {

        hdc = _GetDCEx(pwndClip,
                       HRGN_FULL,
                       DCX_WINDOW | DCX_USESTYLE | DCX_INTERSECTRGN);

        /*
         * We now have a window DC.  We need to convert client coords
         * to window coords.
         */
        for (iPt = 0; iPt < 4; iPt++) {

            rgPt[iPt].x += (pwndClip->rcClient.left - pwndClip->rcWindow.left);
            rgPt[iPt].y += (pwndClip->rcClient.top - pwndClip->rcWindow.top);
        }
    }

    /*
     * Get drawing DC:
     * Unclipped if desktop, clipped otherwise.
     * Note that ReleaseDC() will free the region if needed.
     */
    if (idAnimation == IDANI_CAPTION) {
        CheckLock(pwndAnimate);
        xxxAnimateCaption(pwndAnimate, hdc, (LPRECT)&rgPt[0], (LPRECT)&rgPt[2]);
    }

/*
 * DISABLE OLD ANIMATION FOR M7
 */
#if 0
    else {
        AnimateFrame(hdc,
                     (LPRECT)&rgPt[0],
                     (LPRECT)&rgPt[2],
                     (idAnimation == IDANI_OPEN));
    }
#endif
/*
 * END DISABLE OLD ANIMATION FOR M7
 */

    /*
     * Clean up
     */
    _ReleaseDC(hdc);

    return TRUE;
}


/***************************************************************************\
* CalcMinZOrder
*
*
* Compute the Z-order of a window to be minimized.
*
* The strategy is to find the bottom-most sibling of pwndMinimize that
* shares the same owner, and insert ourself behind that.  We must also
* take into account that a TOPMOST window should stay among other TOPMOST,
* and vice versa.
*
* We must make sure never to insert after a bottom-most window.
*
* This code works for child windows too, since they don't have owners
* and never have WEFTOPMOST set.
*
* If NULL is returned, the window shouldn't be Z-ordered.
*
\***************************************************************************/

PWND CalcMinZOrder(
    PWND pwndMinimize)
{
    BYTE bTopmost;
    PWND pwndAfter;
    PWND pwnd;

    bTopmost = TestWF(pwndMinimize, WEFTOPMOST);
    pwndAfter = NULL;

    for (pwnd = pwndMinimize->spwndNext; pwnd && !TestWF(pwnd, WFBOTTOMMOST); pwnd = pwnd->spwndNext) {

        /*
         * If we've enumerated a window that isn't the same topmost-wise
         * as pwndMinimize, we've gone as far as we can.
         */
        if (TestWF(pwnd, WEFTOPMOST) != bTopmost)
            break;

        if (pwnd->spwndOwner == pwndMinimize->spwndOwner)
            pwndAfter = pwnd;
    }

    return pwndAfter;
}

/***************************************************************************\
* xxxActivateOnMinimize
*
* Activate the previously active window, provided that window still exists
* and is a NORMAL window (not bottomost, minimized, disabled, or invisible).
* If it's not NORMAL, then activate the first non WS_EX_TOPMOST window
* that's normal. Return TRUE when no activation is needed or the activation
* has been done in this function. Return FALSE if failed to find a window
* to activate.
*
\***************************************************************************/

BOOL xxxActivateOnMinimize(PWND pwnd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndStart, pwndFirstTool, pwndT;
    BOOL fTryTopmost = TRUE;
    BOOL fPrevCheck = (ptiCurrent->pq->spwndActivePrev != NULL);
    TL tlpwndT;

    /*
     * We should always have a last-topmost window.
     */
    pwndStart = GetLastTopMostWindow();
    if (pwndStart) {
        pwndStart = pwndStart->spwndNext;
    } else {
        pwndStart = pwnd->spwndParent->spwndChild;
    }

    UserAssert(HIBYTE(WFMINIMIZED) == HIBYTE(WFVISIBLE));
    UserAssert(HIBYTE(WFVISIBLE) == HIBYTE(WFDISABLED));

SearchAgain:

    pwndT = (fPrevCheck ? ptiCurrent->pq->spwndActivePrev : pwndStart);
    pwndFirstTool = NULL;

    /*
     * TryThisWindow must be outside the beginning of the for loop such
     * that pwndT is checked for NULL before being dereferenced.
     */
TryThisWindow:

    for ( ; pwndT ; pwndT = pwndT->spwndNext) {
        /*
         * Use the first nonminimized, visible, nondisabled, and
         * nonbottommost window
         */
        if (!HMIsMarkDestroy(pwndT) &&
            !TestWF(pwndT, WEFNOACTIVATE) &&
            (TestWF(pwndT, WFVISIBLE | WFDISABLED) == LOBYTE(WFVISIBLE)) &&
            (!TestWF(pwndT, WFMINIMIZED) || GetFullScreen(pwndT) == FULLSCREEN)) {

            if (TestWF(pwndT, WEFTOOLWINDOW)) {
                if (!pwndFirstTool) {
                    pwndFirstTool = pwndT;
                }
            } else {
                break;
            }
        }

        if (fPrevCheck) {
            fPrevCheck = FALSE;
            pwndT = pwndStart;
            goto TryThisWindow;
        }
    }

    if (!pwndT) {

        if (fTryTopmost) {

            fTryTopmost = FALSE;
            if (pwndStart != NULL) {
                pwndStart = pwndStart->spwndParent->spwndChild;
            } else {
                PWND pwndDesktop = _GetDesktopWindow();
                pwndStart = (pwndDesktop != NULL) ? pwndDesktop->spwndChild : NULL;
            }
            goto SearchAgain;
        }

        pwndT = pwndFirstTool;
    }

    if (pwndT) {
        ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);
        xxxSetForegroundWindow(pwndT, FALSE);
        ThreadUnlock(&tlpwndT);
    } else {
        return FALSE;
    }

    return TRUE;
}



/***************************************************************************\
* xxxMinMaximize
*
* cmd = SW_MINIMIZE, SW_SHOWMINNOACTIVE, SW_SHOWMINIZED,
*     SW_SHOWMAXIMIZED, SW_SHOWNOACTIVE, SW_NORMAL
*
* If MINMAX_KEEPHIDDEN is set in dwFlags, keep it hidden, otherwise show it.
*    This is always cleared, except in the case we call it from
*    createwindow(), where the wnd is iconic, but hidden.  we
*    need to call this func, to set it up correctly so that when
*    the app shows the wnd, it is displayed correctly.
*
* When changing state, we always add on SWP_STATECHANGE.  This lets
* SetWindowPos() know to always send WM_WINDOWPOSCHANGING/CHANGED messages
* even if the new size is the same as the old size.  This is because
* apps watch the WM_SIZE wParam field to see when they are changing state.
* If SWP doesn't send WM_WINDOWPOSCHANGED, then they won't get a WM_SIZE
* message at all.
*
* Furthermore, when changing state to/from maximized, if we are really
* maximizing and are in multiple monitor mode, we want to set the window's
* region so that it can't draw outside of the monitor.  Otherwise, it
* will spill over onto another.  The borders are really annoying.
*
\***************************************************************************/

PWND xxxMinMaximize(
    PWND pwnd,
    UINT cmd,
    DWORD dwFlags)
{
    RECT        rc;
    RECT        rcWindow;
    RECT        rcRestore;
    BOOL        fShow = FALSE;
    BOOL        fSetFocus = FALSE;
    BOOL        fShowOwned = FALSE;
    BOOL        fSendActivate = FALSE;
    BOOL        fMaxStateChanging = FALSE;
    int         idAnimation = 0;
    BOOL        fFlushPalette = FALSE;
    UINT        swpFlags = 0;
    HWND        hwndAfter = NULL;
    PWND        pwndT;
    PCHECKPOINT pcp;
    PTHREADINFO ptiCurrent;
    TL          tlpwndParent;
    TL          tlpwndT;
    PSMWP       psmwp;
    BOOL        fIsTrayWindowNow = FALSE;
    NTSTATUS    Status;
    MINMAXINFO  mmi;
    UINT        uEvent = 0;
    PWND        pwndParent = pwnd->spwndParent;
    BOOL        bMirroredParent=FALSE;

    CheckLock(pwnd);

    /*
     * Get window rect, in parent client coordinates.
     */
    GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_PARENTCOORDS);

    /*
     * If this is NULL, we're out of memory, so punt now.
     */
    pcp = CkptRestore(pwnd, &rcWindow);
    if (!pcp)
        goto Exit;

    /*
     * If this top-level window is placed in a mirrored desktop,
     * its coordinates should be mirrored here so that xxxAnimateCaptions
     * works properly, however we shouldn't change the actual screen coordinates
     * of the window. This is why I do it after CkptRestore(...). [samera]
     */
    if (TestWF(pwndParent,WEFLAYOUTRTL) &&
            (!TestWF(pwnd,WFCHILD))) {
        int iLeft = rcWindow.left;
        rcWindow.left  = pwndParent->rcWindow.right - rcWindow.right;
        rcWindow.right = pwndParent->rcWindow.right - iLeft;
        bMirroredParent = TRUE;
    }


    /*
     * Save the previous restore size.
     */
    CopyRect(&rcRestore, &pcp->rcNormal);

    /*
     * First ask the CBT hook if we can do this operation.
     */
    if (    IsHooked(PtiCurrent(), WHF_CBT) &&
            xxxCallHook(HCBT_MINMAX, (WPARAM)HWq(pwnd), (DWORD)cmd, WH_CBT)) {

        goto Exit;
    }

    /*
     * If another MDI window is being maximized, and we want to restore this
     * one to its previous state, we can't change the zorder or the
     * activation.  We'd mess things up that way.  BTW, this SW_ value is
     * internal.
     */
    if (cmd == SW_MDIRESTORE) {

        swpFlags |= SWP_NOZORDER | SWP_NOACTIVATE;

        cmd = (pcp->fWasMinimizedBeforeMaximized ?
                SW_SHOWMINIMIZED : SW_SHOWNORMAL);
    }

    ptiCurrent = PtiCurrent();

    switch (cmd) {
    case SW_MINIMIZE:        // Bottom of zorder, make top-level active
    case SW_SHOWMINNOACTIVE: // Bottom of zorder, don't change activation

        if (gpqForeground && gpqForeground->spwndActive)
            swpFlags |= SWP_NOACTIVATE;

        if ((pwndT = CalcMinZOrder(pwnd)) == NULL) {
            swpFlags |= SWP_NOZORDER;
        } else {
            hwndAfter = PtoHq(pwndT);
        }


        /*
         * FALL THRU
         */

    case SW_SHOWMINIMIZED:   // Top of zorder, make active

        /*
         * Force a show.
         */
        fShow = TRUE;

        /*
         * If already minimized, then don't change the existing
         * parking spot.
         */
        if (TestWF(pwnd, WFMINIMIZED)) {

            /*
             * If we're already minimized and we're properly visible
             * or not visible, don't do anything
             */
            if (TestWF(pwnd, WFVISIBLE))
                return NULL;

            swpFlags |= SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE;

            goto Showit;
        }

        /*
         * We're becoming minimized although we currently are not.  So
         * we want to draw the transition animation, and ALWAYS send
         * sizing messages.
         */
        idAnimation = IDANI_CLOSE;

        if (!pcp->fDragged)
            pcp->fMinInitialized = FALSE;

        if (!pcp->fMinInitialized)
            ParkIcon(pwnd, pcp);

        rc.left   = pcp->ptMin.x;
        rc.top    = pcp->ptMin.y;
        rc.right  = pcp->ptMin.x + SYSMET(CXMINIMIZED);
        rc.bottom = pcp->ptMin.y + SYSMET(CYMINIMIZED);

        xxxShowOwnedWindows(pwnd, SW_PARENTCLOSING, NULL);

        pwndT = ptiCurrent->pq->spwndFocus;

        while (pwndT) {

            /*
             * if we or any child has the focus, punt it away
             */
            if (pwndT != pwnd) {
                pwndT = pwndT->spwndParent;
                continue;
            }

            ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);

            if (TestwndChild(pwnd)) {

                ThreadLockWithPti(ptiCurrent, pwnd->spwndParent, &tlpwndParent);
                xxxSetFocus(pwnd->spwndParent);
                ThreadUnlock(&tlpwndParent);

            } else {
                xxxSetFocus(NULL);
            }

            ThreadUnlock(&tlpwndT);
            break;
        }

        /*
         * Save the maximized state so that we can restore the window maxed
         */
        if (TestWF(pwnd, WFMAXIMIZED)) {
            pcp->fWasMaximizedBeforeMinimized = TRUE;
            fMaxStateChanging = TRUE;
        } else{
            pcp->fWasMaximizedBeforeMinimized = FALSE;
        }

        if (!TestWF(pwnd, WFWIN40COMPAT))
            fIsTrayWindowNow = IsTrayWindow(pwnd);

        /*
         * Decrement the visible-windows count only if the
         * window is visible.  If the window is marked for
         * destruction, we will not decrement for that as
         * well. Let SetMinimize take care of this.
         */
        SetMinimize(pwnd, SMIN_SET);
        ClrWF(pwnd, WFMAXIMIZED);

        uEvent = EVENT_SYSTEM_MINIMIZESTART;

        if (!TestWF(pwnd, WFWIN40COMPAT))
            fIsTrayWindowNow = (fIsTrayWindowNow != IsTrayWindow(pwnd));

        /*
         * The children of this window are now no longer visible.
         * Ensure that they no longer have any update regions...
         */
        for (pwndT = pwnd->spwndChild; pwndT; pwndT = pwndT->spwndNext)
            ClrFTrueVis(pwndT);

        /*
         * B#2919
         * Ensure that the client area gets recomputed, and make
         * sure that no bits are copied when the size is changed.  And
         * make sure that WM_SIZE messages get sent, even if our client
         * size is staying the same.
         */
        swpFlags |= (SWP_DRAWFRAME | SWP_NOCOPYBITS | SWP_STATECHANGE);

        /*
         * We are going minimized, so we want to give palette focus to
         * another app.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            fFlushPalette = (BOOL)TestWF(pwnd, WFHASPALETTE);
        }

        break;

    case SW_SHOWNOACTIVATE:
        if (gpqForeground && gpqForeground->spwndActive)
            swpFlags |= SWP_NOACTIVATE;

        /*
         * FALL THRU
         */

    case SW_RESTORE:

        /*
         * If restoring a minimized window that was maximized before
         * being minimized, go back to being maximized.
         */
        if (TestWF(pwnd, WFMINIMIZED) && pcp->fWasMaximizedBeforeMinimized)
            cmd = SW_SHOWMAXIMIZED;
        else
            cmd = SW_NORMAL;

        /*
         * FALL THRU
         */

    case SW_NORMAL:
    case SW_SHOWMAXIMIZED:

        if (cmd == SW_SHOWMAXIMIZED) {

            /*
             * If already maximized and visible, we have nothing to do
             * Otherwise, for the DOSbox, still set fMaxStateChanging
             * to TRUE so we recalc the monitor region if need be.
             * That way WinOldAp can change its "changing from maxed to
             * maxed with new bigger font" code to work right.
             */
            if (TestWF(pwnd, WFMAXIMIZED)) {
                if (TestWF(pwnd, WFVISIBLE)) {
                    return NULL;
                }
            } else {
                /*
                 * We're changing from normal to maximized, so always
                 * send WM_SIZE.
                 */
                swpFlags |= SWP_STATECHANGE;
            }
            fMaxStateChanging = TRUE;

            /*
             * If calling from CreateWindow, don't let the thing become
             * activated by the SWP call below.  Acitvation will happen
             * on the ShowWindow done by CreateWindow or the app.
             */
            if (dwFlags & MINMAX_KEEPHIDDEN)
                swpFlags |= SWP_NOACTIVATE;

            /*
             * This is for MDI's auto-restore behaviour (craigc)
             */
            if (TestWF(pwnd, WFMINIMIZED))
                pcp->fWasMinimizedBeforeMaximized = TRUE;

            xxxInitSendValidateMinMaxInfo(pwnd, &mmi);

        } else {

            /*
             * We're changing state from non-normal to normal.  Make
             * sure WM_SIZE gets sents.
             */
            UserAssert(HIBYTE(WFMINIMIZED) == HIBYTE(WFMAXIMIZED));
            if (TestWF(pwnd, WFMINIMIZED | WFMAXIMIZED)) {
                swpFlags |= SWP_STATECHANGE;
            }
            if (TestWF(pwnd, WFMAXIMIZED)) {
                fMaxStateChanging = TRUE;
            }
        }

        /*
         * If currently minimized, show windows' popups
         */
        if (TestWF(pwnd, WFMINIMIZED)) {

            /*
             * Send WM_QUERYOPEN to make sure this guy should unminimize
             */
            if (!xxxSendMessage(pwnd, WM_QUERYOPEN, 0, 0L))
                return NULL;

            idAnimation = IDANI_OPEN;
            fShowOwned  = TRUE;
            fSetFocus   = TRUE;

            /*
             * JEFFBOG B#2868
             * Condition added before setting fSendActivate prevents
             * WM_ACTIVATE message from reaching a child window.  Might
             * be backwards compatibility problems if a pre 3.1 app
             * relies on WM_ACTIVATE reaching a child.
             */
            if (!TestWF(pwnd, WFCHILD))
                fSendActivate = TRUE;

            swpFlags |= SWP_NOCOPYBITS;
        } else {
            idAnimation = IDANI_CAPTION;
        }

        if (cmd == SW_SHOWMAXIMIZED) {
            rc.left     = mmi.ptMaxPosition.x;
            rc.top      = mmi.ptMaxPosition.y;
            rc.right    = rc.left + mmi.ptMaxSize.x;
            rc.bottom   = rc.top + mmi.ptMaxSize.y;

            SetWF(pwnd, WFMAXIMIZED);

        } else {
            CopyRect(&rc, &rcRestore);
            ClrWF(pwnd, WFMAXIMIZED);
        }

        /*
         * We do this TestWF again since we left the critical section
         * above and someone might have already 'un-minimized us'.
         */
        if (TestWF(pwnd, WFMINIMIZED)) {

            if (!TestWF(pwnd, WFWIN40COMPAT))
                fIsTrayWindowNow = IsTrayWindow(pwnd);

            /*
             * Mark it as minimized and adjust cVisWindows.
             */
            SetMinimize(pwnd, SMIN_CLEAR);

            uEvent = EVENT_SYSTEM_MINIMIZEEND;

            /*
             * if we're unminimizing a window that is now
             * not seen in maximized/restore mode then remove him
             * from the tray
             */
            if (!TestWF(pwnd, WFWIN40COMPAT)             &&
                (fIsTrayWindowNow != IsTrayWindow(pwnd)) &&
                FDoTray()) {

                HWND hw = HWq(pwnd);

                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_WINDOWDESTROYED,
                                (WPARAM)hw,
                                (LPARAM)0,
                                WH_SHELL);
                }

                /*
                 * NT specific code.  Post the window-destroyed message
                 * to the shell.
                 */
                if (FPostTray(pwnd->head.rpdesk))
                    PostShellHookMessages(HSHELL_WINDOWDESTROYED, (LPARAM)hw);
            }

            fIsTrayWindowNow = FALSE;

            /*
             * If we're un-minimizing a visible top-level window, cVisWindows
             * was zero, and we're either activating a window or showing
             * the currently active window, set ourselves into the
             * foreground.  If the window isn't currently visible
             * then we can rely on SetWindowPos() to do the right
             * thing for us.
             */
            if (!TestwndChild(pwnd)                 &&
                TestWF(pwnd, WFVISIBLE)             &&
                (GETPTI(pwnd)->cVisWindows == 1)    &&
                (GETPTI(pwnd)->pq != gpqForeground) &&
                (!(swpFlags & SWP_NOACTIVATE)
                    || (GETPTI(pwnd)->pq->spwndActive == pwnd))) {

                xxxSetForegroundWindow2(pwnd, GETPTI(pwnd), SFW_STARTUP);
            }
        }

        /*
         * Ensure that client area gets recomputed, and that
         * the frame gets redrawn to reflect the new state.
         */
        swpFlags |= SWP_DRAWFRAME;
        break;
    }

    /*
     * For the iconic case, we need to also show the window because it
     * might not be visible yet.
     */

Showit:

    if (!(dwFlags & MINMAX_KEEPHIDDEN)) {

        if (TestWF(pwnd, WFVISIBLE)) {

            if (fShow)
                swpFlags |= SWP_SHOWWINDOW;

            /* if we're full screening a DOS BOX then don't draw
             * the animation 'cause it looks bad.
             * overloaded WFFULLSCREEN bit for MDI child windows --
             * use it to indicate to not animate size change.
             */
            if (IsVisible(pwnd)            &&
                (dwFlags & MINMAX_ANIMATE) &&
                idAnimation                &&
                (!TestWF(pwnd, WFCHILD) || !TestWF(pwnd, WFNOANIMATE))) {

                /*
                 * If this top-level window is placed in a mirrored desktop,
                 * its coordinates should be mirrored here so that xxxAnimateCaptions
                 * works properly, however we shouldn't change the actual screen coordinates
                 * of the window. This is why I do it here and restore it afterwards before
                 * doing the _DeferWindowPos(...). [samera]
                 */
                 RECT rcT;
                 if (bMirroredParent) {
                     int iLeft = rc.left;
                     rcT = rc;
                     rc.left  = pwndParent->rcWindow.right - rc.right;
                     rc.right = pwndParent->rcWindow.right - iLeft;
                 }

                if ((idAnimation != IDANI_CAPTION) && IsTrayWindow(pwnd)) {

                    RECT rcMin;

                    SetRectEmpty(&rcMin);
#if 0 // Win95 call.
                    CallHook(HSHELL_GETMINRECT, (WPARAM)HW16(hwnd), (LPARAM)(LPRECT)&rcMin, WH_SHELL);
#else
                    xxxSendMinRectMessages(pwnd, &rcMin);
#endif

                    if (!IsRectEmpty(&rcMin)) {

                        if (idAnimation == IDANI_CLOSE) {

                            xxxDrawAnimatedRects(pwnd,
                                                  IDANI_CAPTION,
                                                  &rcWindow,
                                                  &rcMin);

                        } else {

                            xxxDrawAnimatedRects(pwnd,
                                                  IDANI_CAPTION,
                                                  &rcMin,
                                                  &rc);
                        }
                    }

                } else {
                    xxxDrawAnimatedRects(pwnd, IDANI_CAPTION, &rcWindow, &rc);
                }
                /*
                 * Restore the original rect, after doing the animation
                 */
                if (bMirroredParent) {
                    rc = rcT;
                }
            }

        } else {
            swpFlags |= SWP_SHOWWINDOW;
        }
    }

    /*
     * hack for VB - we add their window in when their minimizing.
     */
    if (!TestWF(pwnd, WFWIN40COMPAT) && fIsTrayWindowNow && FDoTray()) {

        HWND hw = HWq(pwnd);

        if (FCallHookTray()) {
            xxxCallHook(HSHELL_WINDOWCREATED,
                        (WPARAM)hw,
                        (LPARAM)0,
                        WH_SHELL);
        }

        /*
         * NT specific code.  Post the window-created message
         * to the shell.
         */
        if (FPostTray(pwnd->head.rpdesk))
            PostShellHookMessages(HSHELL_WINDOWCREATED, (LPARAM)hw);
    }

    /*
     * BACKWARD COMPATIBILITY HACK:
     *
     * Because SetWindowPos() won't honor sizing, moving and SWP_SHOWWINDOW
     * at the same time in version 3.0 or below, we call DeferWindowPos()
     * directly here.
     */
    if (psmwp = InternalBeginDeferWindowPos(1)) {

        psmwp = _DeferWindowPos(psmwp,
                                pwnd,
                                ((hwndAfter != NULL) ? RevalidateHwnd(hwndAfter) : NULL),
                                rc.left, rc.top,
                                rc.right - rc.left,
                                rc.bottom - rc.top,
                                swpFlags);

        if (psmwp) {

            /*
             * HACK FOR MULTIPLE MONITOR TRUE MAXIMIZATION CLIPPING
             *      On a multiple monitor system, we would like the
             *      borders not to spill over onto another monitor when a
             *      window 'really' maximizes.  The only way to get this
             *      to work right is to set a rectangular region, namely
             *      a copy of the monitor region, on the window.  We can
             *      only do this if the window isn't currently regional.
             *
             *  Going to maximized:     Add the monitor region
             *  Coming from maximized:  Remove the monitor region
             */
            if (fMaxStateChanging && gpDispInfo->cMonitors > 1) {
                if (    TestWF(pwnd, WFMAXIMIZED) &&
                        pwnd->spwndParent == PWNDDESKTOP(pwnd)) {

                    psmwp->acvr[0].hrgnClip = HRGN_MONITOR;

                } else if (TestWF(pwnd, WFMAXFAKEREGIONAL)) {
                    UserAssert(pwnd->hrgnClip);
                    psmwp->acvr[0].hrgnClip = HRGN_FULL;
                }
            }

            xxxEndDeferWindowPosEx(psmwp, FALSE);
        }
    }

    if (uEvent) {
        xxxWindowEvent(uEvent, pwnd, OBJID_WINDOW, 0, WEF_USEPWNDTHREAD);
    }

    /*
     * COMPATIBILITY HACK:
     * Borland's OBEX expects a WM_PAINT message when it starts running
     * minimized and initializes all it's data during that message.
     * So, we generate a bogus WM_PAINT message here.
     * Also, Visionware's XServer can not handle getting a WM_PAINT msg, as it
     * would always get a WM_PAINTICON msg in 3.1, so make sure the logic is here
     * to generate the correct message.
     */
    if((cmd == SW_SHOWMINIMIZED)      &&
       (!TestWF(pwnd, WFWIN40COMPAT)) &&
        TestWF(pwnd, WFVISIBLE)       &&
        TestWF(pwnd, WFTOPLEVEL)) {

        if (pwnd->pcls->spicn)
            _PostMessage(pwnd, WM_PAINTICON, (WPARAM)TRUE, 0L);
        else
            _PostMessage(pwnd, WM_PAINT, 0, 0L);
    }

    if (fShowOwned)
        xxxShowOwnedWindows(pwnd, SW_PARENTOPENING, NULL);

    if ((cmd == SW_MINIMIZE) && (pwnd->spwndParent == PWNDDESKTOP(pwnd))) {
        if (!xxxActivateOnMinimize(pwnd)) {
            xxxActivateWindow(pwnd, AW_SKIP);
        }

        {
            PEPROCESS p;

            if (gptiForeground && ptiCurrent->ppi != gptiForeground->ppi && !(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {

                p = PsGetThreadProcess(ptiCurrent->pEThread);
                KeAttachProcess(PsGetProcessPcb(p));
                Status = MmAdjustWorkingSetSize((SIZE_T)-1,
                                                (SIZE_T)-1,
                                                FALSE,
                                                TRUE);
                KeDetachProcess();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_ERROR, "Error adjusting working set, status = %x\n", Status);
                }
            }
        }

        /*
         * If any app is starting, restore its right to foreground activate
         * (activate and come on top of everything else) because we just
         * minimized what we were working on.
         */
        RestoreForegroundActivate();
    }

    /*
     * If going from iconic, insure the focus is in the window.
     */
    if (fSetFocus)
        xxxSetFocus(pwnd);

    /*
     * This was added for 1.03 compatibility reasons.  If apps watch
     * WM_ACTIVATE to set their focus, sending this message will appear
     * as if the window just got activated (like in 1.03).  Before this
     * was added, opening an iconic window never sent this message since
     * it was already active (but HIWORD(lParam) != 0).
     */
    if (fSendActivate)
        xxxSendMessage(pwnd, WM_ACTIVATE, WA_ACTIVE, 0);

    /*
     * Flush the palette.  We do this on a minimize of a palette app.
     */
    if (fFlushPalette)
        xxxFlushPalette(pwnd);

Exit:
    return NULL;
}

/***************************************************************************\
* xxxMinimizeHungWindow
*
* 10/31/96      vadimg      created
\***************************************************************************/

void xxxMinimizeHungWindow(PWND pwnd)
{
    RECT rcMin;
    HRGN hrgnHung;


    CheckLock(pwnd);

    /*
     * If the window is already minimized or not visible don't do anything.
     */
   if (TestWF(pwnd, WFMINIMIZED) || !TestWF(pwnd, WFVISIBLE))
       return;

    /*
     * Animate the caption to the minimized state.
     */
    if (TEST_PUDF(PUDF_ANIMATE)) {
        SetRectEmpty(&rcMin);
        xxxSendMinRectMessages(pwnd, &rcMin);
        if (!IsRectEmpty(&rcMin)) {
            xxxDrawAnimatedRects(pwnd, IDANI_CAPTION, &pwnd->rcWindow, &rcMin);
        }
    }

    /*
     * Reset the visible bit on the window itself and ownees. At the same
     * time calculate how much needs to be repainted. We must invalidate
     * the DC cache to make sure that the visible regions get recalculated.
     */
    SetVisible(pwnd, SV_UNSET);
    hrgnHung = GreCreateRectRgnIndirect(&pwnd->rcWindow);
    xxxShowOwnedWindows(pwnd, SW_PARENTCLOSING, hrgnHung);
    zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
    xxxRedrawWindow(NULL, NULL, hrgnHung, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
    GreDeleteObject(hrgnHung);

    /*
     * Deal with activating some other window for top-level windows.
     */
    if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        xxxActivateOnMinimize(pwnd);
    }
    PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq, QEVENT_HUNGTHREAD, pwnd, 0, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\makefile.inc ===
$(O)\callcf.c: ..\callcf.tpl ..\..\inc\$(ALT_PROJECT)\$(O)\scf.lst
    listmung ..\..\inc\$(ALT_PROJECT)\$(O)\scf.lst ..\callcf.tpl >$@

..\ssend.c: ..\..\inc\ntcb.h ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst ..\..\inc\messages.h

..\ntstubs.c: ..\..\inc\messages.h

..\precomp.h: ..\userk.h ..\globals.h ..\..\inc\user.h ..\..\inc\ntuser.h $(WINDOWS_INC_PATH)\winuserp.h \
        $(WINCORE_PATH)\w32inc\winuserk.h $(WINCORE_PATH)\w32inc\w32p.h ..\access.h $(O)\strid.h

$(O)\strid.h $(O)\msg00001.bin $(O)\strid.rc: ..\strid.mc
    mc -r $(O) -h $(O) -v -U ..\strid.mc

$(O)\kbdus.c: $(MAKEDIR)\..\..\kbd\txt\kbdus.txt
    cd $(O)
    kbdtool -k $**
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\menu.c ===
/**************************** Module Header ********************************\
* Module Name: menu.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Keyboard Accelerator Routines
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***********************************************************************\
* MNGetpItemIndex
*
* 11/19/96  GerardoB  Created
\***********************************************************************/
#if DBG
UINT DBGMNGetpItemIndex(
    PMENU pmenu,
    PITEM pitem)
{
    UINT uiPos;

    UserAssert((ULONG_PTR)pitem >= (ULONG_PTR)pmenu->rgItems);
    uiPos = _MNGetpItemIndex(pmenu, pitem);
    UserAssert(uiPos < pmenu->cItems);

    return uiPos;
}
#endif // DBG

/**************************************************************************\
* xxxMNDismiss
*
* 12/03/96 GerardoB     Created
\**************************************************************************/
VOID xxxMNDismiss(
    PMENUSTATE pMenuState)
{
    xxxMNCancel(pMenuState, 0, 0, 0);
}

/***************************************************************************\
* MNFadeSelection
*
* 2/5/1998   vadimg          created
\***************************************************************************/
BOOL MNFadeSelection(
    PMENU pmenu,
    PITEM pitem)
{
    PWND pwnd;
    HDC hdc;
    RECT rc;
    PPOPUPMENU ppopup;

    if (!TestALPHA(SELECTIONFADE))
        return FALSE;

    /*
     * Don't fade the selection if the user is using the keyboard or journalling. These are performance scenarios
     */
    if (glinp.dwFlags & (LINP_KEYBOARD | LINP_JOURNALLING)) {
        return FALSE;
    }


    /*
     * Get the window for the currently active popup menu.
     */
    if ((ppopup = MNGetPopupFromMenu(pmenu, NULL)) == NULL)
        return FALSE;

    if ((pwnd = ppopup->spwndPopupMenu) == NULL)
        return FALSE;

    rc.left = pwnd->rcClient.left + pitem->xItem;
    rc.top = pwnd->rcClient.top + pitem->yItem;
    rc.right = rc.left + pitem->cxItem;
    rc.bottom = rc.top + pitem->cyItem;

    /*
     * Initialize the fade animation and get the DC to draw the selection into.
     */
    if ((hdc = CreateFade(NULL, &rc, CMS_SELECTIONFADE, 0)) == NULL)
        return FALSE;

    /*
     * Read the current menu selection right from the screen, since the menu
     * is still visible and it's always on top. In the worst case we could
     * offset the origin of the DC and call xxxDrawMenuItem, but just reading
     * from the screen is much faster.
     */
    GreBitBlt(hdc, 0, 0, pitem->cxItem, pitem->cyItem, gpDispInfo->hdcScreen,
            rc.left, rc.top, SRCCOPY, 0);

    ShowFade();

    return TRUE;
}

/**************************************************************************\
* xxxMNDismissWithNotify
*
* Generates parameters for WM_COMMAND or WM_SYSCOMMAND message.
*
* 12/03/96 GerardoB     Created
\**************************************************************************/
VOID xxxMNDismissWithNotify(
    PMENUSTATE pMenuState,
    PMENU pmenu,
    PITEM pitem,
    UINT uPos,
    LPARAM lParam)
{
    UINT uMsg;
    UINT uCmd;

    if (pMenuState->pGlobalPopupMenu->fIsSysMenu) {
        uMsg = WM_SYSCOMMAND;
        uCmd = pitem->wID;
        /* lParam set by caller */
    } else if (pMenuState->fNotifyByPos) {
        uMsg = WM_MENUCOMMAND;
        uCmd = uPos;
        lParam = (LPARAM)PtoHq(pmenu);
    } else {
        uMsg = WM_COMMAND;
        uCmd = pitem->wID;
        lParam = 0;
    }

    /*
     * The menu is about to go away, see if we want to fade out the selection.
     */
    if (MNFadeSelection(pmenu, pitem)) {
        StartFade();
    }

    /*
     * Dismiss the menu.
     */
    xxxMNCancel(pMenuState, uMsg, uCmd, lParam);
}

/**************************************************************************\
* MNGetpItem
*
* 11/15/96 GerardoB     Created
\**************************************************************************/
PITEM MNGetpItem(
    PPOPUPMENU ppopup,
    UINT uIndex)
{
    if ((ppopup == NULL) || (uIndex >= ppopup->spmenu->cItems)) {
       return NULL;
    }

    return ppopup->spmenu->rgItems + uIndex;
}

/***************************************************************************\
* xxxMNSetCapture
*
* History:
* 11/18/96 GerardoB  Created
\***************************************************************************/
VOID xxxMNSetCapture(
    PPOPUPMENU ppopup)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Set the capture and lock it so no one will be able to steal it
     * from us.
     */
    xxxCapture(ptiCurrent, ppopup->spwndNotify, SCREEN_CAPTURE);
#if DBG
    if (ptiCurrent->pq->spwndCapture != ppopup->spwndNotify) {
        RIPMSG2(RIP_WARNING, "xxxMNSetCapture: spwndCapture (%p) != spwndNotify (%p)", ptiCurrent->pq->spwndCapture, ppopup->spwndNotify);
    }
#endif

    ptiCurrent->pq->QF_flags |= QF_CAPTURELOCKED;
    ptiCurrent->pMenuState->fSetCapture = TRUE;
#if DBG
    /*
     * Unless we're in the foreground, this menu mode won't go away
     *  when the user clicks outside the menu. This is because only
     *  the foreground queue capture sees clicks outside its windows.
     */
    if (ptiCurrent->pq != gpqForeground) {
        RIPMSG0(RIP_WARNING, "xxxMNSetCapture: Menu mode is not in foreground queue");
    }
#endif
}
/***************************************************************************\
* xxxMNReleaseCapture
*
* History:
* 11/18/96 GerardoB  Created
\***************************************************************************/
VOID xxxMNReleaseCapture(
    VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Bail if we didn't set capture.
     */
    if ((ptiCurrent->pMenuState == NULL) ||
        (!ptiCurrent->pMenuState->fSetCapture)) {
        return;
    }
    ptiCurrent->pMenuState->fSetCapture = FALSE;

    /*
     * Unlock capture and release it.
     */
    PtiCurrent()->pq->QF_flags &= ~QF_CAPTURELOCKED;
    xxxReleaseCapture();
}

/***************************************************************************\
* MNCheckButtonDownState
*
* History:
* 11/14/96 GerardoB  Created
\***************************************************************************/
VOID MNCheckButtonDownState(
    PMENUSTATE pMenuState)
{
    /*
     * Modeless menus don't capture the mouse so when a mouse down
     * goes off the window, we need to keep watching its state.
     *
     * We also might not see the button up when going on DoDragDrop loop.
     */
    UserAssert(pMenuState->fDragAndDrop || pMenuState->fModelessMenu);
    pMenuState->fButtonDown = ((_GetKeyState(pMenuState->vkButtonDown) & 0x8000) != 0);
    if (!pMenuState->fButtonDown) {
        pMenuState->fDragging =
        pMenuState->fIgnoreButtonUp = FALSE;
        UnlockMFMWFPWindow(&pMenuState->uButtonDownHitArea);
    }
}

/***************************************************************************\
* GetMenuStateWindow
*
* This function is called when we need to post a message to the menu loop.
* The actual pwnd is not important since we just want to reach
* xxxHandleMenuMessages or xxxMenuWindowProc. So we just pick a window that
* has a good chance to be around as long as we are in menu mode.
*
* History:
* 10/31/96 GerardoB  Created
\***************************************************************************/
PWND GetMenuStateWindow(
    PMENUSTATE pMenuState)
{
    if (pMenuState == NULL) {
        return NULL;
    } else if (pMenuState->pGlobalPopupMenu->fIsTrackPopup) {
        return pMenuState->pGlobalPopupMenu->spwndPopupMenu;
    } else if (pMenuState->pGlobalPopupMenu->spwndNextPopup != NULL) {
        return pMenuState->pGlobalPopupMenu->spwndNextPopup;
    } else {
        return pMenuState->pGlobalPopupMenu->spwndActivePopup;
    }
}

/***************************************************************************\
* UnlockPopupMenuWindow
*
* This function is called when locking/unlocking a menu into a popup structure.
* It makes sure that pmenu doesn't keep the notification window locked
* unneccessarily.
*
* It unlocks pmenu->spwndNotify if the menu it's not locked into pmenu->spwndNotify
* itself AND it's currently locked to pwnd.
*
* It's also unlocked if pmenu->spwndNotify is marked as destroyed.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
VOID UnlockPopupMenuWindow(
    PMENU pmenu,
    PWND pwnd)
{
    /*
     * Bail if there's nothing to unlock.
     */
    if ((pmenu == NULL) || (pmenu->spwndNotify == NULL)) {
        return;
    }

    /*
     * if pmenu->spwndNotify owns the menu, bail
     */
    if ((pmenu == pmenu->spwndNotify->spmenu)
            || (pmenu == pmenu->spwndNotify->spmenuSys)) {
        return;
    }

    /*
     * If pwnd doesn't own the menu, and pmenu->spwndNotify is not destroyed, bail.
     */
    if ((pwnd != pmenu->spwndNotify)
            && !TestWF(pmenu->spwndNotify, WFDESTROYED)) {
        return;
    }
    /*
     * Unlock it
     */
    Unlock(&pmenu->spwndNotify);
}

/***************************************************************************\
* LockPopupMenu
*
* Locks a given menu into a popup strucuture and makes the
* popup's notification window the owner of the menu.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID LockPopupMenu(
    PPOPUPMENU ppopup,
    PMENU *pspmenu,
    PMENU pmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing.
     */
    UserAssert((pspmenu == &ppopup->spmenu) || (pspmenu == &ppopup->spmenuAlternate));
    Validateppopupmenu(ppopup);

    /*
     * This won't work properly if the popup hasn't locked the notification
     * window.
     */
    UserAssert(ppopup->spwndNotify != NULL);

    /*
     * When using modeless menus, menus can be shared by several active popups.
     * If the menu has owner draw items, the app better knows how to draw them
     * correctly. This shouldn't happen with modal menus though.
     */
#if DBG
        if ((*pspmenu != NULL)
                && ((*pspmenu)->spwndNotify != NULL)
                && ((*pspmenu)->spwndNotify != ppopup->spwndNotify)) {

            RIPMSG3(RIP_WARNING, "LockPopupMenu: Current Menu %#p shared by %#p and %#p",
                    *pspmenu, (*pspmenu)->spwndNotify, ppopup->spwndNotify);
        }
#endif

    /*
     * Unlock the current's menu spwndNotify if needed
     */
    UnlockPopupMenuWindow(*pspmenu, ppopup->spwndNotify);

    /*
     * Lock the notification window into the menu structure
     */
    if (pmenu != NULL) {
        /*
         * Display a warning if this menu is being shared.
         */
#if DBG
        if ((pmenu->spwndNotify != NULL)
                && (pmenu->spwndNotify != ppopup->spwndNotify)
                && (pmenu != pmenu->spwndNotify->head.rpdesk->spmenuDialogSys)) {

            RIPMSG3(RIP_WARNING, "LockPopupMenu: New Menu %#p shared by %#p and %#p",
                    pmenu, pmenu->spwndNotify, ppopup->spwndNotify);
        }
#endif

        /*
         * spwndNotify "owns" this menu now.
         */
        Lock(&pmenu->spwndNotify, ppopup->spwndNotify);
    }

    /*
     * Lock the menu into the popup structure (unlock the previous one)
     */
    return Lock(pspmenu, pmenu);
}

/***************************************************************************\
* UnlockPopupMenu
*
* Unlocks a given menu from a popup strucuture and makes sure that the
* menu is no longer "owned" by the popup's notification window; if needed.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID UnlockPopupMenu(
    PPOPUPMENU ppopup,
    PMENU * pspmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing.
     */
    UserAssert((pspmenu == &ppopup->spmenu) || (pspmenu == &ppopup->spmenuAlternate));

    /*
     * If nothing is locked, bail.
     */
    if (*pspmenu == NULL) {
        return NULL;
    }

    /*
     * This won't work properly if the popup already unlocked the notification
     * window. However, this can happen with the root popup if the
     * notification window gets destroyed while in menu mode.
     */
    UserAssert((ppopup->spwndNotify != NULL) || IsRootPopupMenu(ppopup));

    /*
     * When using modeless menus, menus can be shared by several active
     * popups/notification windows. If the menu has owner draw items,
     * the app better knows how to paint them right. It shouldn't
     * happen with modal menus though.
     */
#if DBG
    if (((*pspmenu)->spwndNotify != NULL)
            && (ppopup->spwndNotify != NULL)
            && (ppopup->spwndNotify != (*pspmenu)->spwndNotify)) {

        RIPMSG3(RIP_WARNING, "UnlockPopupMenu: Menu %#p shared by %#p and %#p",
                *pspmenu, (*pspmenu)->spwndNotify, ppopup->spwndNotify);
    }
#endif

    /*
     * Unlock the menu's spwndNotify if needed
     */
    UnlockPopupMenuWindow(*pspmenu, ppopup->spwndNotify);

    /*
     * Unlock the menu from the popup structure
     */
    return Unlock(pspmenu);
}

/***************************************************************************\
* LockWndMenu
*
* Locks a given menu into a window structure and locks the window into
*  the menu strucuture.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID LockWndMenu(
    PWND pwnd,
    PMENU *pspmenu,
    PMENU pmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing
     */
    UserAssert((pspmenu == &pwnd->spmenu) || (pspmenu == &pwnd->spmenuSys));

    /*
     * If the current menu is owned by this window, unlock it
     */
    if ((*pspmenu != NULL) && ((*pspmenu)->spwndNotify == pwnd)) {
        Unlock(&((*pspmenu)->spwndNotify));
    }

    /*
     * If nobody owns the new menu, make this window the owner
     */
    if ((pmenu != NULL) && (pmenu->spwndNotify == NULL)) {
        Lock(&pmenu->spwndNotify, pwnd);
    }

    /*
     * Lock the menu into the window structure (unlock the previous menu)
     */
    return Lock(pspmenu, pmenu);

}

/***************************************************************************\
* UnlockWndMenu
*
* Unlocks a given menu from a window strucutre and the window from the
*  menu strucuture
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID UnlockWndMenu(
    PWND pwnd,
    PMENU *pspmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing
     */
    UserAssert((pspmenu == &pwnd->spmenu) || (pspmenu == &pwnd->spmenuSys));

    /*
     * If nothing is locked, bail.
     */
    if (*pspmenu == NULL) {
        return NULL;
    }

    /*
     * If this window owns the menu, unlock it from the menu structure.
     */
    if (pwnd == (*pspmenu)->spwndNotify) {
        Unlock(&((*pspmenu)->spwndNotify));
    }

    /*
     * Unlock the menu from the window structure
     */
    return Unlock(pspmenu);
}


/***************************************************************************\
* MNSetTop
*
* Sets the first visible item in a scrollable menu to the given iNewTop.
* Returns TRUE if iTop was changed; FALSE if iNewTop is already the
* first visible item.
*
* 08/13/96 GerardoB Ported From Memphis.
\***************************************************************************/
BOOL xxxMNSetTop(
    PPOPUPMENU ppopup,
    int iNewTop)
{
    PMENU   pMenu = ppopup->spmenu;
    int     dy;

    if (iNewTop < 0) {
        iNewTop = 0;
    } else if (iNewTop > pMenu->iMaxTop) {
        iNewTop = pMenu->iMaxTop;
    }

    /*
     * If no change, done.
     */
    if (iNewTop == pMenu->iTop) {
        return FALSE;
    }

#if DBG
    /*
     * We're going to scroll, so validate iMaxTop, cyMax and cyMenu.
     */
    UserAssert((pMenu->cyMax == 0) || (pMenu->cyMax >= pMenu->cyMenu));
    if ((UINT)pMenu->iMaxTop < pMenu->cItems) {
        PITEM pitemLast = pMenu->rgItems + pMenu->cItems - 1;
        PITEM pitemMaxTop = pMenu->rgItems + pMenu->iMaxTop;
        UINT uHeight = pitemLast->yItem + pitemLast->cyItem - pitemMaxTop->yItem;
        UserAssert(uHeight <= pMenu->cyMenu);
        /*
         * Let's guess a max item height.
         */
        UserAssert(pMenu->cyMenu - uHeight <= 2 * pitemLast->cyItem);
    } else {
        UserAssert((UINT)pMenu->iMaxTop < pMenu->cItems);
    }
#endif


    /*
     * If we've made it this far, the new iTop WILL change -- thus if the
     * current iTop is at the top it won't be after this change -- same goes
     * for iTop at the bottom.
     */
    if (pMenu->dwArrowsOn == MSA_ATTOP) {
        pMenu->dwArrowsOn = MSA_ON;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_UPARROW);
        }
    } else if (pMenu->dwArrowsOn == MSA_ATBOTTOM) {
        pMenu->dwArrowsOn = MSA_ON;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_DOWNARROW);
        }
    }

    UserAssert((UINT)iNewTop < pMenu->cItems);
    dy = MNGetToppItem(pMenu)->yItem - (pMenu->rgItems + iNewTop)->yItem;

    if ((dy > 0 ? dy : -dy) > (int)pMenu->cyMenu) {
        xxxInvalidateRect(ppopup->spwndPopupMenu, NULL, TRUE);
    } else {
        xxxScrollWindowEx(ppopup->spwndPopupMenu, 0, dy, NULL, NULL, NULL, NULL, SW_INVALIDATE | SW_ERASE);
    }

    pMenu->iTop = iNewTop;

    if (iNewTop == 0) {
        pMenu->dwArrowsOn = MSA_ATTOP;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_UPARROW);
        }
    } else if (iNewTop == pMenu->iMaxTop) {
        pMenu->dwArrowsOn = MSA_ATBOTTOM;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_DOWNARROW);
        }
    }

    if (pMenu->hbrBack != NULL) {
        MNDrawFullNC(ppopup->spwndPopupMenu, NULL, ppopup);
    }

    return TRUE;
}

/***************************************************************************\
* xxxMNDoScroll
*
*  scrolls a scrollable menu (ppopup) if the given position (uArrow) is one of
*  the menu scroll arrows and sets a timer to auto-scroll when necessary;
*  returns FALSE if the given position was not a menu scroll arrow; returns
*  TRUE otherwise
*
* 08/13/96 GerardoB Ported From Memphis.
\***************************************************************************/
BOOL xxxMNDoScroll(
    PPOPUPMENU ppopup,
    UINT uArrow,
    BOOL fSetTimer)
{
    int iScrollTop = ppopup->spmenu->iTop;

    if (uArrow == MFMWFP_UPARROW) {
        iScrollTop--;
    } else if (uArrow == MFMWFP_DOWNARROW) {
        iScrollTop++;
    } else {
        return FALSE;
    }

    if (!xxxMNSetTop(ppopup, iScrollTop)) {
        if (!fSetTimer) {
            _KillTimer(ppopup->spwndPopupMenu, uArrow);
        }
    } else {
        /*
         * Set this timer just like we do in the scrollbar code:
         * the first time we wait a little longer.
         */
        _SetTimer(ppopup->spwndPopupMenu, uArrow,
                  (fSetTimer ? gpsi->dtScroll : gpsi->dtScroll / 4), NULL);
    }

    return TRUE;
}

/***************************************************************************\
* MNCheckScroll
*
* Checks to see if the given menu (pMenu) can be displayed in it's entirety
* or if it can't, in which case it sets the menu to be scrollable.
*
* 08/13/96 GerardoB Ported From Memphis.
\***************************************************************************/
int MNCheckScroll(
    PMENU pMenu,
    PMONITOR pMonitor)
{
    int     i;
    UINT    cyMax;
    PITEM   pItem;

    /*
     * Max height that fits on the monitor
     */
    cyMax = (pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top);

    /*
     * If the menu has a valid max height, use it
     */
    if ((pMenu->cyMax != 0) && (pMenu->cyMax < cyMax)) {
        cyMax = pMenu->cyMax;
    }

    /*
     * Bail if menu is either empty, multicolumn, or able to fit
     *   without scrolling
     */
    if ((pMenu->rgItems == 0)
            || (pMenu->rgItems->cxItem != pMenu->cxMenu)
            || (pMenu->cyMenu + (2 * SYSMET(CYFIXEDFRAME)) <= cyMax))  {

        pMenu->dwArrowsOn = MSA_OFF;
        pMenu->iTop = 0;
        pMenu->iMaxTop = 0;
        return pMenu->cyMenu;
    }

    /*
     * Max client height
     */
    cyMax -= 2 * (SYSMET(CYFIXEDFRAME) + gcyMenuScrollArrow);

    /*
     * Determine the menu height
     * Find the first item that won't fit.
     */
    pItem = pMenu->rgItems;
    for (i = 0; i < (int)pMenu->cItems; i++, pItem++) {
        if (pItem->yItem > (UINT)cyMax) {
            break;
        }
    }
    if (i != 0) {
        pItem--;
    }
    pMenu->cyMenu = pItem->yItem;

    /*
     * compute the last possible top item when all remaining items are fully
     * visible
     */
    cyMax = 0;
    i = pMenu->cItems - 1;
    pItem = pMenu->rgItems + i;
    for (; i >= 0; i--, pItem--) {
        cyMax += pItem->cyItem;
        if (cyMax > pMenu->cyMenu) {
            break;
        }
    }
    if ((UINT)i != pMenu->cItems - 1) {
        i++;
    }
    pMenu->iMaxTop = i;

    /*
     * Update top item and scroll state
     */
    if (pMenu->iTop > i) {
        pMenu->iTop = i;
    }

    if (pMenu->iTop == i) {
        pMenu->dwArrowsOn = MSA_ATBOTTOM;
    } else if (pMenu->iTop == 0) {
        pMenu->dwArrowsOn = MSA_ATTOP;
    } else {
        pMenu->dwArrowsOn = MSA_ON;
    }

    /*
     * This is funtion is called by MN_SIZEWINDOW which doesn't check
     *  if the scroll bars are present but simply adds (2 * SYSMET(CYFIXEDFRAME))
     *  to calculate the window height. So we add the scrollbars height
     *  here. (I believe MN_SIZEWINDOW is a private-but-publicly-known message)
     */
    return (pMenu->cyMenu + (2 * gcyMenuScrollArrow));
}

/***************************************************************************\
* MNIsPopupItem
*
*
\***************************************************************************/
BOOL MNIsPopupItem(
    ITEM *lpItem)
{
    return ((lpItem) && (lpItem->spSubMenu) && !TestMFS(lpItem, MFS_GRAYED));
}

/***************************************************************************\
* Validateppopupmenu
*
* 05-15-96 GerardoB  Created
\***************************************************************************/
#if DBG
VOID Validateppopupmenu(
    PPOPUPMENU ppopupmenu)
{
    UserAssert(ppopupmenu != NULL);
    try {
        UserAssert(!ppopupmenu->fFreed);

        /*
         * If this popup is being destroyed to soon, ppopupmenuRoot can be NULL
         */
         if (ppopupmenu->ppopupmenuRoot != NULL) {
             if (ppopupmenu->ppopupmenuRoot != ppopupmenu) {
                 /*
                  * This must be a hierarchical popup.
                  */
                 UserAssert(ppopupmenu->spwndPrevPopup != NULL);
                 UserAssert(!ppopupmenu->fIsMenuBar && !ppopupmenu->fIsTrackPopup);
                 Validateppopupmenu(ppopupmenu->ppopupmenuRoot);
             } else {
                 /*
                  * This must be the root popupmenu.
                  */
                 UserAssert(ppopupmenu->spwndPrevPopup == NULL);
                 UserAssert(ppopupmenu->fIsMenuBar || ppopupmenu->fIsTrackPopup);
             }
         }

         /*
          * This can be NULL when called from xxxDeleteThreadInfo.
          */
         if (ppopupmenu->spwndPopupMenu != NULL) {
             UserAssert(ppopupmenu->spwndPopupMenu == RevalidateCatHwnd(HW(ppopupmenu->spwndPopupMenu)));
         }

         /*
          * This can be NULL when called from xxxDestroyWindow (spwndNotify)
          * or from xxxDeleteThreadInfo.
          */
         if (ppopupmenu->spwndNotify != NULL) {
             UserAssert(ppopupmenu->spwndNotify == RevalidateCatHwnd(HW(ppopupmenu->spwndNotify)));
         }
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        RIPMSG1(RIP_ERROR, "Validateppopupmenu: Invalid popup: 0x%p", ppopupmenu);
    }
}
#endif // DBG

/***************************************************************************\
* xxxMNSwitchToAlternateMenu
*
* Switches to the alternate popupmenu. Returns TRUE if we switch,
* else FALSE.
*
* History:
* 05-25-91 Mikehar      Ported from Win3.1
\***************************************************************************/
BOOL xxxMNSwitchToAlternateMenu(
    PPOPUPMENU ppopupmenu)
{
    PMENU pmenuSwap = NULL;
    PMENUSTATE pMenuState;
    TL tlpwndPopupMenu;

    if (!ppopupmenu->fIsMenuBar || !ppopupmenu->spmenuAlternate) {
        /*
         * Do nothing if no menu or not top level menu bar.
         * ppopupmenu->spmenuAlternate can be NULL when an app has
         * either system menu or menu bar but not both. If that menu
         * has only one popup that it's not dropped, then hitting
         * VK_RIGHT or VK_LEFT causes xxxMNKeyDown to end up here.
         *
         * ppopupmenu->fIsMenuBar can be false when you drop the
         * system menu of an app with no menu bar; then hit VK_RIGHT
         * on an item that doesn't have a popup and you'll get here
         * There might be some other situations like this; in any case
         * the assertion's got to go.
         */
        return FALSE;
    }

    /*
     * If we're getting out of menu mode, do nothing.
     */
    if (ppopupmenu->fDestroyed) {
        return FALSE;
    }

    /*
     * Select no items in the current menu.
     */
    ThreadLock(ppopupmenu->spwndPopupMenu, &tlpwndPopupMenu);
    UserAssert(ppopupmenu->spwndPopupMenu != NULL);
    pMenuState = GetpMenuState(ppopupmenu->spwndPopupMenu);
    if (pMenuState == NULL) {
        RIPMSG0(RIP_ERROR, "xxxMNSwitchToAlternateMenu: pMenuState == NULL");
        ThreadUnlock(&tlpwndPopupMenu);
        return FALSE;
    }
    xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);


    UserAssert(ppopupmenu->spmenu->spwndNotify == ppopupmenu->spmenuAlternate->spwndNotify);
    Lock(&pmenuSwap, ppopupmenu->spmenuAlternate);
    Lock(&ppopupmenu->spmenuAlternate, ppopupmenu->spmenu);
    Lock(&ppopupmenu->spmenu, pmenuSwap);
    Unlock(&pmenuSwap);

    if (!TestWF(ppopupmenu->spwndNotify, WFSYSMENU)) {
        pMenuState->fIsSysMenu = FALSE;
    } else if (ppopupmenu->spwndNotify->spmenuSys != NULL) {
        pMenuState->fIsSysMenu = (ppopupmenu->spwndNotify->spmenuSys ==
                ppopupmenu->spmenu);
    } else {
        pMenuState->fIsSysMenu = !!TestMF(ppopupmenu->spmenu, MFSYSMENU);
    }

    ppopupmenu->fIsSysMenu = pMenuState->fIsSysMenu;

    xxxWindowEvent(EVENT_SYSTEM_MENUEND, ppopupmenu->spwndNotify,
        (ppopupmenu->fIsSysMenu ? OBJID_MENU : OBJID_SYSMENU), INDEXID_CONTAINER, 0);
        
    xxxWindowEvent(EVENT_SYSTEM_MENUSTART, ppopupmenu->spwndNotify,
        (ppopupmenu->fIsSysMenu ? OBJID_SYSMENU : OBJID_MENU), INDEXID_CONTAINER, 0);

    ThreadUnlock(&tlpwndPopupMenu);

    return TRUE;
}

/***************************************************************************\
* xxxMNDestroyHandler
*
* Cleans up after this menu.
*
* History:
* 05-25-91 Mikehar      Ported from Win3.1
\***************************************************************************/
VOID xxxMNDestroyHandler(
    PPOPUPMENU ppopupmenu)
{
    PITEM pItem;
    TL tlpwndT;

    if (ppopupmenu == NULL) {
        /*
         * This can happen if WM_NCCREATE failed to allocate the ppopupmenu
         * in xxxMenuWindowProc.
         */
        RIPMSG0(RIP_WARNING, "xxxMNDestroyHandler: NULL \"ppopupmenu\"");
        return;
    }

#if DBG
    Validateppopupmenu(ppopupmenu);
#endif

    if (ppopupmenu->spwndNextPopup != NULL) {
        /*
         * We used to send the message to spwndNextPopup here. The message should
         * go to the current popup so it'll close spwndNextPopup (not to the next
         * to close its next, if any).
         *
         * I don't see how the current spwndPopupMenu can be NULL but we better
         * handle it since we never accessed it before. This menu code is tricky...
         */
        PWND pwnd;
        UserAssert(ppopupmenu->spwndPopupMenu != NULL);
        pwnd = (ppopupmenu->spwndPopupMenu != NULL ? ppopupmenu->spwndPopupMenu : ppopupmenu->spwndNextPopup);
        ThreadLockAlways(pwnd, &tlpwndT);
        xxxSendMessage(pwnd, MN_CLOSEHIERARCHY, 0, 0);
        ThreadUnlock(&tlpwndT);
    }

    if ((ppopupmenu->spmenu != NULL) && MNIsItemSelected(ppopupmenu)) {
        /*
         * Unset the hilite bit on the hilited item.
         */
        if (ppopupmenu->posSelectedItem < ppopupmenu->spmenu->cItems) {
            /*
             * This extra check saves Ambiente 1.02 -- they have a menu with
             * one item in it. When that command is chosen, the app proceeds
             * to remove that one item -- leaving us in the oh so strange state
             * of having a valid hMenu with a NULL rgItems.
             */
            pItem = &(ppopupmenu->spmenu->rgItems[ppopupmenu->posSelectedItem]);
            pItem->fState &= ~MFS_HILITE;
        }
    }

    if (ppopupmenu->fShowTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNSHOW);
    }

    if (ppopupmenu->fHideTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNHIDE);
    }

    /*
     * Send WM_UNINITMENUPOPUP so the menu owner can clean up.
     */
    if (ppopupmenu->fSendUninit
            && (ppopupmenu->spwndNotify != NULL)) {

        ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndT);
        xxxSendMessage(ppopupmenu->spwndNotify, WM_UNINITMENUPOPUP,
                       (WPARAM)PtoH(ppopupmenu->spmenu),
                        MAKELONG(0, (ppopupmenu->fIsSysMenu ? MF_SYSMENU: 0)));
        ThreadUnlock(&tlpwndT);
    }

    ppopupmenu->fDestroyed = TRUE;
    if (ppopupmenu->spwndPopupMenu != NULL) {
        ((PMENUWND)(ppopupmenu->spwndPopupMenu))->ppopupmenu = NULL;
    }

    if (!ppopupmenu->fDelayedFree) {
        MNFreePopup(ppopupmenu);
    } else if (ppopupmenu->ppopupmenuRoot != NULL) {
        ppopupmenu->ppopupmenuRoot->fFlushDelayedFree = TRUE;
        #if DBG
        {
            /*
             * If this is not the rootpopup, assert that this popup is
             * linked in the delayed free list.
             */
            if (!IsRootPopupMenu(ppopupmenu)) {
                BOOL fFound = FALSE;
                PPOPUPMENU ppm = ppopupmenu->ppopupmenuRoot;
                while (ppm->ppmDelayedFree != NULL) {
                    if (ppm->ppmDelayedFree == ppopupmenu) {
                        fFound = TRUE;
                        break;
                    }
                    ppm = ppm->ppmDelayedFree;
                }
                UserAssert(fFound);
            }
        }
        #endif
    } else {
        UserAssertMsg1(FALSE, "Leaking ppopupmenu: %p?", ppopupmenu);
    }
}

/***************************************************************************\
* xxxMNChar
*
* Handles char messages for the given menu. This procedure is called
* directly if the menu char is for the top level menu bar else it is called
* by the menu window proc on behalf of the window that should process the
* key.
*
* History:
* 05-25-91 Mikehar      Ported from Win3.1
\***************************************************************************/
VOID xxxMNChar(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT character)
{
    PMENU pMenu;
    UINT flags;
    LRESULT result;
    int item;
    INT matchType;
    BOOL fExecute = FALSE;
    TL tlpwndNotify;

    pMenu = ppopupmenu->spmenu;

    Validateppopupmenu(ppopupmenu);

    /*
     * If this comes in with a NULL pMenu, then we could have problems.
     * This could happen if the xxxMNStartMenuState never gets called
     * because the fInsideMenuLoop is set.
     *
     * This is placed in here temporarily until we can discover why
     * this pMenu isn't set. We will prevent the system from crashing
     * in the meantime.
     *
     * HACK: ChrisWil
     */
    if (pMenu == NULL) {
        UserAssert(pMenu);
        xxxMNDismiss(pMenuState);
        return;
    }

    /*
     * If we're getting out of menu mode, bail.
     */
    if (ppopupmenu->fDestroyed) {
        return;
    }

    item = xxxMNFindChar(pMenu, character,
            ppopupmenu->posSelectedItem, &matchType);
    if (item != MFMWFP_NOITEM) {
        int item1;
        int firstItem = item;

        /*
         * Find first ENABLED menu item with the given mnemonic 'character'
         * !!!  If none found, exit menu loop  !!!
         */
        while (pMenu->rgItems[item].fState & MFS_GRAYED) {
            item = xxxMNFindChar(pMenu, character, item, &matchType);
            if (item == firstItem) {
                xxxMNDismiss(pMenuState);
                return;
            }
        }
        item1 = item;

        /*
         * Find next ENABLED menu item with the given mnemonic 'character'
         * This is to see if we have a DUPLICATE MNEMONIC situation
         */
        do {
            item = xxxMNFindChar(pMenu, character, item, &matchType);
        } while ((pMenu->rgItems[item].fState & MFS_GRAYED) && (item != firstItem));

        if ((firstItem == item) || (item == item1))
            fExecute = TRUE;

        item = item1;
    }

    if ((item == MFMWFP_NOITEM) && ppopupmenu->fIsMenuBar && (character == TEXT(' '))) {

        /*
         * Handle the case of the user cruising through the top level menu bar
         * without any popups dropped. We need to handle switching to and from
         * the system menu.
         */
        if (ppopupmenu->fIsSysMenu) {

            /*
             * If we are on the system menu and user hits space, bring
             * down thesystem menu.
             */
            item = 0;
            fExecute = TRUE;
        } else if (ppopupmenu->spmenuAlternate != NULL) {

            /*
             * We are not currently on the system menu but one exists. So
             * switch to it and bring it down.
             */
            item = 0;
            goto SwitchToAlternate;
        }
    }

    if ((item == MFMWFP_NOITEM) && ppopupmenu->fIsMenuBar && ppopupmenu->spmenuAlternate) {

        /*
         * No matching item found on this top level menu (could be either the
         * system menu or the menu bar). We need to check the other menu.
         */
        item = xxxMNFindChar(ppopupmenu->spmenuAlternate,
                character, 0, &matchType);

        if (item != MFMWFP_NOITEM) {
SwitchToAlternate:
            if (xxxMNSwitchToAlternateMenu(ppopupmenu)) {
                xxxMNChar(ppopupmenu, pMenuState, character);
            }
            return;
        }
    }

    if (item == MFMWFP_NOITEM) {
        flags = (ppopupmenu->fIsSysMenu) ? MF_SYSMENU : 0;

        if (!ppopupmenu->fIsMenuBar) {
            flags |= MF_POPUP;
        }

        ThreadLock(ppopupmenu->spwndNotify, &tlpwndNotify);
        result = xxxSendMessage(ppopupmenu->spwndNotify, WM_MENUCHAR,
                MAKELONG((WORD)character, (WORD)flags),
                (LPARAM)PtoH(ppopupmenu->spmenu));
        ThreadUnlock(&tlpwndNotify);

        switch (HIWORD(result)) {
        case MNC_IGNORE:
            xxxMessageBeep(0);
            /*
             * If we're on the menu bar, cancel menu mode (fall through).
             * We do this because you can really scare an end user
             *  who accidentally tapped the Alt key (causing us to go
             *  into "invisible" menu mode) and now can't type anything!
             */
            if (flags & MF_POPUP) {
                return;
            }
            /*
             * Fall through.
             */

        case MNC_CLOSE:
            xxxMNDismiss(pMenuState);
            return;

        case MNC_EXECUTE:
            fExecute = TRUE;
            /* fall thru */

        case MNC_SELECT:
            item = (UINT)(short)LOWORD(result);
            if ((WORD) item >= ppopupmenu->spmenu->cItems)
            {
                RIPMSG1(RIP_WARNING, "Invalid item number returned from WM_MENUCHAR %#lx", result);
                return;
            }
            break;
        }
    }

    if (item != MFMWFP_NOITEM) {
        xxxMNSelectItem(ppopupmenu, pMenuState, item);

        if (fExecute)
            xxxMNKeyDown(ppopupmenu, pMenuState, VK_RETURN);
    }
}

/***************************************************************************\
* GetMenuInheritedContextHelpId
*
* Given a ppopup, this function will see if that menu has a context help
* id and return it. If it does not have a context help id, it will look up
* in the parent menu, parent of the parent etc., all the way to the top
* top level menu bar till it finds a context help id and returns it. If no
* context help id is found, it returns a zero.
\***************************************************************************/
DWORD GetMenuInheritedContextHelpId(
    PPOPUPMENU ppopup)
{
    PWND  pWnd;

    /*
     * If we are already at the menubar, simply return it's ContextHelpId
     */
    UserAssert(ppopup != NULL);
    if (ppopup->fIsMenuBar) {
        goto Exit_GMI;
    }

    while(TRUE) {
        UserAssert(ppopup != NULL);

        /*
         * See if the given popup has a context help id.
         */
        if (ppopup->spmenu->dwContextHelpId) {
            /* Found the context Id */
            break;
        }

        /*
         * Get the previous popup menu;
         * Check if the previous menu is the menu bar.
         */
        if (  (ppopup->fHasMenuBar) &&
              (ppopup->spwndPrevPopup == ppopup->spwndNotify)) {

            ppopup = ppopup -> ppopupmenuRoot;
            break;
        } else {
            /*
             * See if this has a valid prevPopup; (it could be TrackPopup menu)
             */
            if ((pWnd = ppopup -> spwndPrevPopup) == NULL) {
                return ((DWORD)0);
            }

            ppopup = ((PMENUWND)pWnd)->ppopupmenu;
        }
    }

Exit_GMI:
    return ppopup->spmenu->dwContextHelpId;
}

/***************************************************************************\
* xxxMNKeyDown
*
* Handles a keydown for the given menu.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNKeyDown(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT key)
{
    LRESULT dwMDIMenu;
    UINT item;
    BOOL fHierarchyWasDropped = FALSE;
    TL tlpwndT;
    PPOPUPMENU ppopupSave;
    BOOL bFakedKey;
    UINT keyOrig = key;

    /*
     * Blow off keyboard if mouse down.
     */
    if ((pMenuState->fButtonDown) && (key != VK_F1)) {
        /*
         * Check if the user wants to cancel dragging.
         */
        if (pMenuState->fDragging && (key == VK_ESCAPE)) {
            RIPMSG0(RIP_WARNING, "xxxMNKeyDown: ESC while dragging");
            pMenuState->fIgnoreButtonUp = TRUE;
        }

        return;
    }

    switch (key) {
    case VK_MENU:
    case VK_F10:
        /*
         * Modeless don't go away when the menu key is hit. They just
         *  ignore it.
         */
        if (pMenuState->fModelessMenu) {
            return;
        }

        xxxMNDismiss(pMenuState);

        /*
         * We're going to exit menu mode but the ALT key is down, so clear
         * pMenuState->fUnderline to cause xxxMNLoop not to erase the
         * underlines.
         */
        if (key == VK_MENU) {
            pMenuState->fUnderline = FALSE;
        }
        return;

    case VK_ESCAPE:

        /*
         * Escape key was hit. Get out of one level of menus. If no active
         * popups or we are minimized and there are no active popups below
         * this, we need to get out of menu mode. Otherwise, we popup up
         * one level in the hierarchy.
         */
        if (ppopupmenu->fIsMenuBar ||
                ppopupmenu == ppopupmenu->ppopupmenuRoot ||
                TestWF(ppopupmenu->ppopupmenuRoot->spwndNotify, WFMINIMIZED)) {
            xxxMNDismiss(pMenuState);
        } else {
            /*
             * Pop back one level of menus.
             */
            if (ppopupmenu->fHasMenuBar &&
                    ppopupmenu->spwndPrevPopup == ppopupmenu->spwndNotify) {

                PPOPUPMENU ppopupmenuRoot = ppopupmenu->ppopupmenuRoot;

                ppopupmenuRoot->fDropNextPopup = FALSE;

#if 0
                /*
                 * We are on a menu bar hierarchy and there is only one popup
                 * visible. We have to cancel this popup and put focus back on
                 * the menu bar.
                 */
                if (_IsIconic(ppopupmenuRoot->spwndNotify)) {

                    /*
                     * However, if we are iconic there really is no menu
                     * bar so let's make it easier for users and get out
                     * of menu mode completely.
                     */
                    xxxMNDismiss(pMenuState);
                } else
#endif
                    /*
                     * If the popup is closed, a modeless menu won't
                     *  have a window to get the keys. So modeless menu
                     *  cancel the menu at this point. Modal menus go
                     *  to the menu bar.
                     */
                    if (pMenuState->fModelessMenu) {
                        xxxMNDismiss(pMenuState);
                    } else {
                        xxxMNCloseHierarchy(ppopupmenuRoot, pMenuState);
                    }
            } else {
                ThreadLock(ppopupmenu->spwndPrevPopup, &tlpwndT);
                xxxSendMessage(ppopupmenu->spwndPrevPopup, MN_CLOSEHIERARCHY,
                        0, 0);
                ThreadUnlock(&tlpwndT);
            }
        }
        return;

    case VK_UP:
    case VK_DOWN:
        if (ppopupmenu->fIsMenuBar) {

            /*
             * If we are on the top level menu bar, try to open the popup if
             * possible.
             */
            if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1)
                return;
        } else {
            item = MNFindNextValidItem(ppopupmenu->spmenu,
                    ppopupmenu->posSelectedItem, (key == VK_UP ? -1 : 1), 0);
            xxxMNSelectItem(ppopupmenu, pMenuState, item);
        }
        return;

    case VK_LEFT:
    case VK_RIGHT:
        bFakedKey = (!!ppopupmenu->fRtoL) ^ (!!TestWF(ppopupmenu->spwndPopupMenu, WEFLAYOUTRTL));
        if (bFakedKey)
            /*
             * turn the keys around, we drew the menu backwards.
             */
            key = (key == VK_LEFT) ? VK_RIGHT : VK_LEFT;
        if (!ppopupmenu->fIsMenuBar && (key == VK_RIGHT) &&
                !ppopupmenu->spwndNextPopup) {
            /*
             * Try to open the hierarchy at this item if there is one.
             */
            if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1)
                return;
            if (ppopupmenu->fHierarchyDropped) {
                return;
            }
        }

        if (ppopupmenu->spwndNextPopup) {
            fHierarchyWasDropped = TRUE;
            if ((key == VK_LEFT) && !ppopupmenu->fIsMenuBar) {
                xxxMNCloseHierarchy(ppopupmenu, pMenuState);
                return;
            }
        } else if (ppopupmenu->fDropNextPopup)
            fHierarchyWasDropped = TRUE;

        ppopupSave = ppopupmenu;

        item = MNFindItemInColumn(ppopupmenu->spmenu,
                ppopupmenu->posSelectedItem,
                (key == VK_LEFT ? -1 : 1),
                (ppopupmenu->fHasMenuBar &&
                ppopupmenu == ppopupmenu->ppopupmenuRoot));

        if (item == MFMWFP_NOITEM) {

            /*
             * No valid item found in the given direction so send it up to our
             * parent to handle.
             */
            if (ppopupmenu->fHasMenuBar &&
                    ppopupmenu->spwndPrevPopup == ppopupmenu->spwndNotify) {

                /*
                 * if we turned the key round, then turn it back again.
                 */
                if (bFakedKey)
                    key = (key == VK_LEFT) ? VK_RIGHT : VK_LEFT;
                /*
                 * Go to next/prev item in menu bar since a popup was down and
                 * no item on the popup to go to.
                 */
                xxxMNKeyDown(ppopupmenu->ppopupmenuRoot, pMenuState, key);
                return;
            }

            if (ppopupmenu == ppopupmenu->ppopupmenuRoot) {
                if (!ppopupmenu->fIsMenuBar) {

                    /*
                     * No menu bar associated with this menu so do nothing.
                     */
                    return;
                }
            } else {
                ThreadLock(ppopupmenu->spwndPrevPopup, &tlpwndT);
                xxxSendMessage(ppopupmenu->spwndPrevPopup, WM_KEYDOWN, keyOrig, 0);
                ThreadUnlock(&tlpwndT);
                return;
            }
        }

        if (!ppopupmenu->fIsMenuBar) {
            if (item != MFMWFP_NOITEM) {
                xxxMNSelectItem(ppopupmenu, pMenuState, item);
            }
            return;

        } else {

            /*
             * Special handling if keydown occurred on a menu bar.
             */
            if (item == MFMWFP_NOITEM) {

                if (TestWF(ppopupmenu->spwndNotify, WFSYSMENU)) {
                    PTHREADINFO ptiCurrent = PtiCurrent();
                    PWND    pwndNextMenu;
                    PMENU   pmenuNextMenu, pmenuUse;
                    MDINEXTMENU mnm;
                    TL tlpmenuNextMenu;
                    TL tlpwndNextMenu;

                    mnm.hmenuIn = (HMENU)0;
                    mnm.hmenuNext = (HMENU)0;
                    mnm.hwndNext = (HWND)0;

                    /*
                     * We are in the menu bar and need to go up to the system menu
                     * or go from the system menu to the menu bar.
                     */
                    pmenuNextMenu = ppopupmenu->fIsSysMenu ?
                        _GetSubMenu(ppopupmenu->spmenu, 0) :
                        ppopupmenu->spmenu;
                    mnm.hmenuIn = PtoH(pmenuNextMenu);
                    ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
                    dwMDIMenu = xxxSendMessage(ppopupmenu->spwndNotify,
                        WM_NEXTMENU, (WPARAM)keyOrig, (LPARAM)&mnm);
                    ThreadUnlock(&tlpwndT);

                    pwndNextMenu = RevalidateHwnd(mnm.hwndNext);
                    if (pwndNextMenu == NULL)
                        goto TryAlternate;

                    /*
                     * If this window belongs to another thread, we cannot
                     *  use it. The menu loop won't get any messages
                     *  directed to that thread.
                     */
                    if (GETPTI(pwndNextMenu) != ptiCurrent) {
                        RIPMSG1(RIP_WARNING, "xxxMNKeyDown: Ignoring mnm.hwndNext bacause it belongs to another thread: %#p", pwndNextMenu);
                        goto TryAlternate;
                    }


                    pmenuNextMenu = RevalidateHmenu(mnm.hmenuNext);
                    if (pmenuNextMenu == NULL)
                        goto TryAlternate;

                    ThreadLock(pmenuNextMenu, &tlpmenuNextMenu);
                    ThreadLock(pwndNextMenu, &tlpwndNextMenu);

                    /*
                     * If the system menu is for a minimized MDI child,
                     * make sure the menu is dropped to give the user a
                     * visual clue that they are in menu mode
                     */
                    if (TestWF(pwndNextMenu, WFMINIMIZED))
                        fHierarchyWasDropped = TRUE;

                    xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);

                    pMenuState->fIsSysMenu = TRUE;
                    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate);
                    ppopupmenu->fToggle = FALSE;
                    /*
                     * GetSystemMenu(pwnd, FALSE) and pwnd->spmenuSys are
                     * NOT equivalent -- GetSystemMenu returns the 1st submenu
                     * of pwnd->spmenuSys -- make up for that here
                     */
                    pmenuUse = (((pwndNextMenu->spmenuSys != NULL)
                                    && (_GetSubMenu(pwndNextMenu->spmenuSys, 0) == pmenuNextMenu))
                               ? pwndNextMenu->spmenuSys
                               : pmenuNextMenu);
                    /*
                     * We're going to change the notification window AND the menu.
                     * LockPopupMenu needs to unlock the current pmenu-spwndNotify
                     *  but also lock the new pmenu-spwndNotify. Since we cannot
                     *  give it the current AND the new pair, we unlock the
                     *  current one first, switch the notification window and
                     *  then call LockPopupMenu to lock the new pmenu-spwndNotify.
                     */
                    UserAssert(IsRootPopupMenu(ppopupmenu));
                    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenu);
                    Lock(&ppopupmenu->spwndNotify, pwndNextMenu);
                    Lock(&ppopupmenu->spwndPopupMenu, pwndNextMenu);
                    LockPopupMenu(ppopupmenu, &ppopupmenu->spmenu, pmenuUse);
                    /*
                     * We just switched to a new notification window so
                     *  we need to Adjust capture accordingly
                     */
                    if (!pMenuState->fModelessMenu) {
                        ptiCurrent->pq->QF_flags &= ~QF_CAPTURELOCKED;
                        xxxMNSetCapture(ppopupmenu);
                    }


                    if (!TestWF(pwndNextMenu, WFCHILD) &&
                            ppopupmenu->spmenu != NULL) {

                        /*
                         * This window has a system menu and a main menu bar
                         * Set the alternate menu to the appropriate menu
                         */
                        if (pwndNextMenu->spmenu == ppopupmenu->spmenu) {
                            LockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate,
                                    pwndNextMenu->spmenuSys);
                            pMenuState->fIsSysMenu = FALSE;
                        } else {
                            LockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate,
                                    pwndNextMenu->spmenu);
                        }
                    }

                    ThreadUnlock(&tlpwndNextMenu);
                    ThreadUnlock(&tlpmenuNextMenu);

                    ppopupmenu->fIsSysMenu = pMenuState->fIsSysMenu;

                    item = 0;
                } else
TryAlternate:
                if (xxxMNSwitchToAlternateMenu(ppopupmenu)) {
                        /*
                         * go to first or last menu item int ppopup->hMenu
                         * based on 'key'
                         */
                    int dir = (key == VK_RIGHT) ? 1 : -1;

                    item = MNFindNextValidItem(ppopupmenu->spmenu, MFMWFP_NOITEM, dir, 0);
                }
            }

            if (item != MFMWFP_NOITEM) {
                /*
                 * we found a new menu item to go to
                 * 1) close up the previous menu if it was dropped
                 * 2) select the new menu item to go to
                 * 3) drop the new menu if the previous menu was dropped
                 */

                if (ppopupSave->spwndNextPopup)
                    xxxMNCloseHierarchy(ppopupSave, pMenuState);

                xxxMNSelectItem(ppopupmenu, pMenuState, item);

                if (fHierarchyWasDropped) {
DropHierarchy:
                    if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1) {
                        return;
                    }
                }
            }
        }
        return;

    case VK_RETURN:
        {
        BOOL fEnabled;
        PITEM  pItem;

        if (ppopupmenu->posSelectedItem >= ppopupmenu->spmenu->cItems) {
            xxxMNDismiss(pMenuState);
            return;
        }

        pItem = ppopupmenu->spmenu->rgItems + ppopupmenu->posSelectedItem;
        fEnabled = !(pItem->fState & MFS_GRAYED);
        if ((pItem->spSubMenu != NULL) && fEnabled)
            goto DropHierarchy;

        /*
         * If no item is selected, throw away menu and return.
         */
        if (fEnabled) {
            xxxMNDismissWithNotify(pMenuState, ppopupmenu->spmenu, pItem, ppopupmenu->posSelectedItem, 0);
        } else {
            xxxMNDismiss(pMenuState);
        }
        return;
        }

    case VK_F1: /* Provide context sensitive help. */
        {
        PITEM  pItem;

        pItem = MNGetpItem(ppopupmenu, ppopupmenu->posSelectedItem);
        if (pItem != NULL) {
            ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
            xxxSendHelpMessage(ppopupmenu->spwndNotify, HELPINFO_MENUITEM, pItem->wID,
                    PtoHq(ppopupmenu->spmenu),
                    GetMenuInheritedContextHelpId(ppopupmenu));
            ThreadUnlock(&tlpwndT);
        }
        break;
        }

    }
}
/***************************************************************************\
* xxxMNPositionHierarchy
*
* Calculates the x.y postion to drop a hierarchy and returns the direction
* to be used when animating (PAS_* value).
*
* 11/19/96  GerardoB  Extracted from xxxMNOpenHierarchy
\***************************************************************************/
UINT xxxMNPositionHierarchy(
    PPOPUPMENU  ppopup,
    PITEM       pitem,
    int         cx,
    int         cy,
    int         *px,
    int         *py,
    PMONITOR    *ppMonitor)
{
    int         x, y;
    UINT        uPAS;
    PMONITOR    pMonitor;

    UserAssert(ppopup->fHierarchyDropped && (ppopup->spwndNextPopup != NULL));

    if (ppopup->fIsMenuBar) {
        /*
         * This is a menu being dropped from the top menu bar. We need to
         * position it differently than hierarchicals which are dropped from
         * another popup.
         */

        BOOL fIconic = (TestWF(ppopup->spwndPopupMenu, WFMINIMIZED) != 0);
        RECT rcWindow;

        /*
         * Menu bar popups animate down.
         */
        uPAS = PAS_DOWN;

        CopyRect(&rcWindow, &ppopup->spwndPopupMenu->rcWindow);
        if (fIconic && IsTrayWindow(ppopup->spwndPopupMenu)) {
            xxxSendMinRectMessages(ppopup->spwndPopupMenu, &rcWindow);
        }

        /*
         * x position
         */
        if (!SYSMET(MENUDROPALIGNMENT) && !TestMF(ppopup->spmenu,MFRTL)) {
            if (fIconic) {
                x = rcWindow.left;
            } else {
                x = rcWindow.left + pitem->xItem;
            }
        } else {
            ppopup->fDroppedLeft = TRUE;
            if (fIconic) {
                x = rcWindow.right - cx;
            } else {
                x = rcWindow.left + pitem->xItem + pitem->cxItem - cx;
            }
        }

        /*
         * For a menu bar dropdown, pin to the monitor that owns the
         * majority of the menu item. Otherwise, pin to the monitor that
         * owns the minimized window (the tray rect for min-to-tray dudes).
         */
        if (!fIconic) {
            /*
             * Use rcWindow as scratch for the menu bar item rect. We want
             * to pin this menu on whatever monitor owns most of the menu
             * item clicked on.
             */
            rcWindow.left += pitem->xItem;
            rcWindow.top  += pitem->yItem;
            rcWindow.right = rcWindow.left + pitem->cxItem;
            rcWindow.bottom = rcWindow.top + pitem->cyItem;
        }

        pMonitor = _MonitorFromRect(&rcWindow, MONITOR_DEFAULTTOPRIMARY);

        /*
         * y position
         */
        if (!fIconic) {
            y = rcWindow.bottom;
        } else {
            /*
             * If the window is iconic, pop the menu up. Since we're
             * minimized, the sysmenu button doesn't really exist.
             */
            y = rcWindow.top - cy;
            if (y < pMonitor->rcMonitor.top) {
                y = rcWindow.bottom;
            }
        }

        /*
         * Make sure the menu doesn't go off the right side of the monitor
         */
        x = min(x, pMonitor->rcMonitor.right - cx);

        if (TestWF(ppopup->spwndPopupMenu, WEFLAYOUTRTL)) {
            x = ppopup->spwndPopupMenu->rcWindow.right - x + ppopup->spwndPopupMenu->rcWindow.left - cx;
        }
    } else {

        /* Now position the hierarchical menu window.
         * We want to overlap by the amount of the frame, to help in the
         * 3D illusion.
         */

        /*
         * By default, hierachical popups animate to the right
         */
        uPAS = PAS_RIGHT;
        x = ppopup->spwndPopupMenu->rcWindow.left + pitem->xItem + pitem->cxItem;

        /* Note that we DO want the selections in the item and its popup to
         * align horizontally.
         */
        y = ppopup->spwndPopupMenu->rcWindow.top + pitem->yItem;
        if (ppopup->spmenu->dwArrowsOn != MSA_OFF) {
            y += gcyMenuScrollArrow - MNGetToppItem(ppopup->spmenu)->yItem;
        }

        /*
         * Try to make sure the menu doesn't go off right side of the
         * monitor. If it does, drop it left, overlapping the checkmark
         * area. Unless it would cover the previous menu...
         *
         * Use the monitor that the parent menu is on to keep all hierarchicals
         * in the same place.
         */
        pMonitor = _MonitorFromWindow(
                ppopup->spwndPopupMenu, MONITOR_DEFAULTTOPRIMARY);

        if ((!!ppopup->fDroppedLeft) ^ (!!TestWF(ppopup->spwndPopupMenu, WEFLAYOUTRTL))) {
            int xTmp;

            /*
             * If this menu has dropped left, see if our hierarchy can be made
             * to drop to the left also.
             */
            xTmp = ppopup->spwndPopupMenu->rcWindow.left + SYSMET(CXFIXEDFRAME) - cx;
            if (xTmp >= pMonitor->rcMonitor.left) {
                x = xTmp;
                uPAS = PAS_LEFT;
            }
        }

        /*
         * Make sure the menu doesn't go off right side of screen. Make it drop
         * left if it does.
         */
         if (x + cx > pMonitor->rcMonitor.right) {
             x = ppopup->spwndPopupMenu->rcWindow.left + SYSMET(CXFIXEDFRAME) - cx;
             uPAS = PAS_LEFT;
         }

         if (TestWF(ppopup->spwndPopupMenu, WEFLAYOUTRTL)) {
             uPAS ^= PAS_HORZ;
         }
    }

    /*
     * Does the menu extend beyond bottom of monitor?
     */
    UserAssert(pMonitor);
    if (y + cy > pMonitor->rcMonitor.bottom) {
        y -= cy;

        /*
         * Try to pop above menu bar first
         */
        if (ppopup->fIsMenuBar) {
            y -= SYSMET(CYMENUSIZE);
            if (y >= pMonitor->rcMonitor.top) {
                uPAS = PAS_UP;
            }
        } else {
            /*
             * Account for nonclient frame above & below
             */
            y += pitem->cyItem + 2*SYSMET(CYFIXEDFRAME);
        }

        /*
         * Make sure that starting point is on a monitor, and all of menu shows.
         */
        if ((y < pMonitor->rcMonitor.top) || (y + cy > pMonitor->rcMonitor.bottom)) {
            /*
             * Pin it to the bottom.
             */
            y = pMonitor->rcMonitor.bottom - cy;
        }
    }

    /*
     * Make sure Upper Left corner of menu is always visible.
     */
    x = max(x, pMonitor->rcMonitor.left);
    y = max(y, pMonitor->rcMonitor.top);

    /*
     * Propagate position
     */
    *px = x;
    *py = y;
    *ppMonitor = pMonitor;

    /*
     * Return animation direction
     */
    return uPAS;
}

/***************************************************************************\
* xxxMNOpenHierarchy
*
* Drops one level of the hierarchy at the selection.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
PWND xxxMNOpenHierarchy(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState)
{
    PWND        ret = 0;
    PITEM       pItem;
    PWND        pwndHierarchy;
    PPOPUPMENU  ppopupmenuHierarchy;
    LONG        sizeHierarchy;
    int         xLeft;
    int         yTop;
    int         cxPopup, cyPopup;
    TL          tlpwndT;
    TL          tlpwndHierarchy;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOP    pdesk = ptiCurrent->rpdesk;
    BOOL        fSendUninit = FALSE;
    HMENU       hmenuInit;
    PMONITOR    pMonitor;


    if (ppopupmenu->posSelectedItem == MFMWFP_NOITEM) {
        /*
         *  No selection so fail.
         */
        return NULL;
    }

    if (ppopupmenu->posSelectedItem >= ppopupmenu->spmenu->cItems)
        return NULL;

    if (ppopupmenu->fHierarchyDropped) {
        if (ppopupmenu->fHideTimer) {
            xxxMNCloseHierarchy(ppopupmenu,pMenuState);
        } else {
            /*
             * Hierarchy already dropped. What are we doing here?
             */
            UserAssert(!ppopupmenu->fHierarchyDropped);
            return NULL;
        }
    }

    if (ppopupmenu->fShowTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNSHOW);
        ppopupmenu->fShowTimer = FALSE;
    }

    /*
     * Get a pointer to the currently selected item in this menu.
     */
    pItem = &(ppopupmenu->spmenu->rgItems[ppopupmenu->posSelectedItem]);

    if (pItem->spSubMenu == NULL)
        goto Exit;

    /*
     * Send the initmenupopup message.
     */
    if (!ppopupmenu->fNoNotify) {
        ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
        /*
         * WordPerfect's Grammatik app doesn't know that TRUE means NON-ZERO,
         * not 1. So we must use 0 & 1 explicitly for fIsSysMenu here
         * -- Win95B B#4947 -- 2/13/95 -- jeffbog
         */
        hmenuInit = PtoHq(pItem->spSubMenu);
        xxxSendMessage(ppopupmenu->spwndNotify, WM_INITMENUPOPUP,
            (WPARAM)hmenuInit, MAKELONG(ppopupmenu->posSelectedItem,
            (ppopupmenu->fIsSysMenu ? 1: 0)));
        ThreadUnlock(&tlpwndT);
        fSendUninit = TRUE;
    }


    /*
     * B#1517
     * Check if we're still in menu loop
     */
    if (!pMenuState->fInsideMenuLoop) {
        RIPMSG0(RIP_WARNING, "Menu loop ended unexpectedly by WM_INITMENUPOPUP");
        ret = (PWND)-1;
        goto Exit;
    }

    /*
     * The WM_INITMENUPOPUP message may have resulted in a change to the
     * menu. Make sure the selection is still valid.
     */
    if (ppopupmenu->posSelectedItem >= ppopupmenu->spmenu->cItems) {
        /*
         * Selection is out of range, so fail.
         */
        goto Exit;
    }

    /*
     * Get a pointer to the currently selected item in this menu.
     * Bug #17867 - the call can cause this thing to change, so reload it.
     */
    pItem = &(ppopupmenu->spmenu->rgItems[ppopupmenu->posSelectedItem]);

    if (TestMFS(pItem, MFS_GRAYED) || (pItem->spSubMenu == NULL) || (pItem->spSubMenu->cItems == 0)) {
        /*
         * The item is disabled, no longer a popup, or empty so don't drop.
         */
        /*
         * No items in menu.
         */
        goto Exit;
    }

    /*
     * Let's make sure that the current thread is in menu mode and it uses
     * this pMenuState. Otherwise the window we're about to create (or set
     * the thread to) will point to a different pMenuState.
     */
    UserAssert(ptiCurrent->pMenuState == pMenuState);

    ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);

    pwndHierarchy = xxxNVCreateWindowEx(
            WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
            (PLARGE_STRING)MENUCLASS, NULL,
            WS_POPUP | WS_BORDER, 0, 0, 100, 100, ppopupmenu->spwndNotify,
            NULL, (HANDLE)ppopupmenu->spwndNotify->hModule,
            (LPVOID)pItem->spSubMenu, WINVER);

    ThreadUnlock(&tlpwndT);

    if (!pwndHierarchy) {
        goto Exit;
    }

    /*
     * Do this so old apps don't get weird borders on the popups of
     * hierarchical items!
     */
    ClrWF(pwndHierarchy, WFOLDUI);

    ppopupmenuHierarchy = ((PMENUWND)pwndHierarchy)->ppopupmenu;

    /*
     * Mark this as fDelayedFree and link it
     */
    ppopupmenuHierarchy->fDelayedFree = TRUE;
    ppopupmenuHierarchy->ppmDelayedFree = ppopupmenu->ppopupmenuRoot->ppmDelayedFree;
    ppopupmenu->ppopupmenuRoot->ppmDelayedFree = ppopupmenuHierarchy;

    if (TestWF(ppopupmenu->spwndPopupMenu, WEFLAYOUTRTL)) {
        SetWF(pwndHierarchy, WEFLAYOUTRTL);
    } else {
        ClrWF(pwndHierarchy, WEFLAYOUTRTL);
    }

    Lock(&(ppopupmenuHierarchy->spwndNotify), ppopupmenu->spwndNotify);
#if DBG
    /*
     * We should associate ppopupmenuHierarchy to the same menu we sent the
     *  WM_INITMsENUPOPUP message. Otherwise, the WM_UNINITMENUPOPUP
     *  will go to the wrong window. It would be the app's fault...
     */
    if (!ppopupmenu->fNoNotify && (hmenuInit != PtoHq(pItem->spSubMenu))) {
        RIPMSG2(RIP_WARNING, "xxxMNOpenHierarchy: bad app changed submenu from %#p to %#p",
                              hmenuInit, PtoHq(pItem->spSubMenu));
    }
#endif
    LockPopupMenu(ppopupmenuHierarchy, &ppopupmenuHierarchy->spmenu, pItem->spSubMenu);
    Lock(&(ppopupmenu->spwndNextPopup), pwndHierarchy);
    ppopupmenu->posDropped              = ppopupmenu->posSelectedItem;
    Lock(&(ppopupmenuHierarchy->spwndPrevPopup), ppopupmenu->spwndPopupMenu);
    ppopupmenuHierarchy->ppopupmenuRoot = ppopupmenu->ppopupmenuRoot;
    ppopupmenuHierarchy->fHasMenuBar = ppopupmenu->fHasMenuBar;
    ppopupmenuHierarchy->fIsSysMenu = ppopupmenu->fIsSysMenu;
    ppopupmenuHierarchy->fNoNotify      = ppopupmenu->fNoNotify;
    ppopupmenuHierarchy->fSendUninit = TRUE;
    ppopupmenuHierarchy->fRtoL = ppopupmenu->fRtoL;
    ppopupmenuHierarchy->fDroppedLeft = ppopupmenu->fDroppedLeft;

    /*
     * The menu window has been created and intialized so if
     *  something fails, the WM_UNINITMENUPOPUP message will
     *  be sent from xxxMNDestroyHandler
     */
    fSendUninit = FALSE;

    /*
     * Set/clear the underline flag
     */
    if (pMenuState->fUnderline) {
        SetMF(ppopupmenuHierarchy->spmenu, MFUNDERLINE);
    } else {
        ClearMF(ppopupmenuHierarchy->spmenu, MFUNDERLINE);
    }

    ppopupmenuHierarchy->fAboutToHide   = FALSE;

    /*
     * Find the size of the menu window and actually size it (wParam = 1)
     */
    ThreadLock(pwndHierarchy, &tlpwndHierarchy);
    sizeHierarchy = (LONG)xxxSendMessage(pwndHierarchy, MN_SIZEWINDOW, MNSW_SIZE, 0);

    if (!sizeHierarchy) {
        /*
         * No size for this menu so zero it and blow off.
         */
        UserAssert(ppopupmenuHierarchy->fDelayedFree);

        if (ThreadUnlock(&tlpwndHierarchy)) {
            xxxDestroyWindow(pwndHierarchy);
        }

        Unlock(&ppopupmenu->spwndNextPopup);
        goto Exit;
    }

    cxPopup = LOWORD(sizeHierarchy) + 2*SYSMET(CXFIXEDFRAME);
    cyPopup = HIWORD(sizeHierarchy) + 2*SYSMET(CYFIXEDFRAME);

    ppopupmenu->fHierarchyDropped = TRUE;

    /*
     * Find out the x,y position to drop the hierarchy and the animation
     *  direction
     */
    ppopupmenuHierarchy->iDropDir = xxxMNPositionHierarchy(
            ppopupmenu, pItem, cxPopup, cyPopup, &xLeft, &yTop, &pMonitor);

    if (ppopupmenu->fIsMenuBar && _GetAsyncKeyState(VK_LBUTTON) & 0x8000) {
        /*
         * If the menu had to be pinned to the bottom of the screen and
         * the mouse button is down, make sure the mouse isn't over the
         * menu rect.
         */
        RECT rc;
        RECT rcParent;
        int xrightdrop;
        int xleftdrop;

        /*
         * Get rect of hierarchical
         */
        CopyOffsetRect(
                &rc,
                &pwndHierarchy->rcWindow,
                xLeft - pwndHierarchy->rcWindow.left,
                yTop  - pwndHierarchy->rcWindow.top);

        /*
         * Get the rect of the menu bar popup item
         */
        rcParent.left = pItem->xItem + ppopupmenu->spwndPopupMenu->rcWindow.left;
        rcParent.top = pItem->yItem + ppopupmenu->spwndPopupMenu->rcWindow.top;
        rcParent.right = rcParent.left + pItem->cxItem;
        rcParent.bottom = rcParent.top + pItem->cyItem;

        if (IntersectRect(&rc, &rc, &rcParent)) {

            /*
             * Oh, oh... The cursor will sit right on top of a menu item.
             * If the user up clicks, a menu will be accidently selected.
             *
             * Calc x position of hierarchical if we dropped it to the
             * right/left of the menu bar item.
             */
            xrightdrop = ppopupmenu->spwndPopupMenu->rcWindow.left +
                pItem->xItem + pItem->cxItem + cxPopup;

            if (xrightdrop > pMonitor->rcMonitor.right) {
                xrightdrop = 0;
            }

            xleftdrop = ppopupmenu->spwndPopupMenu->rcWindow.left +
                pItem->xItem - cxPopup;

            if (xleftdrop < pMonitor->rcMonitor.left) {
                xleftdrop = 0;
            }

            if (((SYSMET(MENUDROPALIGNMENT) || TestMFT(pItem, MFT_RIGHTORDER))
           