 &DrvInfoData))
    { 
        SP_DRVINSTALL_PARAMS DrvInstData = {0};

        DrvInstData.cbSize = sizeof(DrvInstData);

        if ( SetupDiGetDriverInstallParams(hDevInfo,
                                           pDevInfoData,
                                           &DrvInfoData,
                                           &DrvInstData))
        {
            HKEY    hKey;
            DWORD   InstallInboxDriver;

            InstallInboxDriver = (DrvInstData.Flags & DNF_BASIC_DRIVER) ? 1 : 0;
            
            hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_WRITE);
            if (hKey != INVALID_HANDLE_VALUE)
            {
                dwRet = RegSetValueEx(hKey, cszBestDriverInbox, 0, REG_DWORD, (LPBYTE) &InstallInboxDriver, sizeof(InstallInboxDriver));

                RegCloseKey(hKey);
            }
            else
            {
                dwRet = GetLastError();
            }
        }
        else 
        {
            dwRet = GetLastError();
        }
    }
    else 
    {
        dwRet = GetLastError();
    }
    
    return dwRet;
}



DWORD
ClassInstall_AllowInstall(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for
    DIF_ALLOW_INSTALL.

    Do not allow PnP installs during GUI setup portion of system upgrade
    Do not allow install of INFs using VendorSetup if QUIETINSTALL bit is set

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    DWORD               dwReturn = ERROR_DI_DO_DEFAULT;
    PPSETUP_LOCAL_DATA  pLocalData;

    if ( pDevInstallParams->Flags & DI_QUIETINSTALL ) {

        //
        // During system setup no PnP install of printers because there ain't no spooler
        // check that the spooler is running - failing this will punt to client-side installation
        // which should happen at a point in time where the spooler actually is running - we don't 
        // want to stall system startup until the spooler is up (think USB mouse...) 
        //
        if (IsSystemSetupInProgress() ||
            !IsSpoolerRunning()) {
            //
            // store the type (inbox or not) in the devnode. This fails if this is a clean install
            // but it doesn't matter because we only need it for drivers that have been installed
            // before upgrade.
            // We use it to determine later on whether to clear the CONFIGFLAG_REINSTALL
            // or not. We don't want to clear it if the best driver is inbox so we'll install it
            // on first boot.
            //
            StoreDriverTypeInDevnode(hDevInfo, pDevInfoData);

            dwReturn = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            goto Done;
        }

        if ( (pLocalData = BuildInternalData(hDevInfo, pDevInfoData))   &&
             ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0, FALSE) ) {

            if ( pLocalData->InfInfo.pszVendorSetup &&
                 *pLocalData->InfInfo.pszVendorSetup )
                dwReturn = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
         } else {

            if ( (dwReturn = GetLastError()) == ERROR_SUCCESS )
                dwReturn = ERROR_INVALID_PARAMETER;
        }

    }

Done:
    return dwReturn;
}


DWORD
ClassInstall32(
    IN  DI_FUNCTION         InstallFunction,
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
/*++

Routine Description:
    This is the printer class installer entry point for SetupDiCallClassInstaller calls

Arguments:
    InstallFunction : The function being called
    hDevInfo        : Handle to the printer class device information list
    pDevInfoData    : Pointer to the device info element for the printer

Return Value:
    Win 32 error code

--*/
{
    SP_DEVINSTALL_PARAMS        DevInstallParams;
    DWORD                       dwReturn = ERROR_DI_DO_DEFAULT;

    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        &DevInstallParams) ) {

        dwReturn = GetLastError();
        goto Done;
    }

    switch (InstallFunction) {

        case DIF_SELECTDEVICE:
            dwReturn = ClassInstall_SelectDevice(hDevInfo, pDevInfoData);
            break;

        case DIF_INSTALLDEVICE:
            dwReturn = ClassInstall_InstallDevice(hDevInfo,
                                                  pDevInfoData,
                                                  &DevInstallParams);
            break;

        case DIF_INSTALLWIZARD:
            dwReturn = ClassInstall_InstallWizard(hDevInfo,
                                                  pDevInfoData,
                                                  &DevInstallParams);
            break;

        case DIF_DESTROYWIZARDDATA:
            dwReturn = ClassInstall_DestroyWizardData(hDevInfo,
                                                      pDevInfoData,
                                                      &DevInstallParams);
            break;

        case DIF_INSTALLDEVICEFILES:
            dwReturn = ClassInstall_InstallDeviceFiles(hDevInfo,
                                                       pDevInfoData,
                                                       &DevInstallParams);
            break;

        case DIF_REMOVE:
            dwReturn = ClassInstall_RemoveDevice(hDevInfo,
                                                 pDevInfoData,
                                                 &DevInstallParams);
            break;

        case DIF_GETWINDOWSUPDATEINFO:


            if ( !InitCodedownload(HWND_DESKTOP) )
                dwReturn = GetLastError();
            else
            {
                if ( SetPackageName(hDevInfo, pDevInfoData) )
                   dwReturn = NO_ERROR;
                else
                   dwReturn = GetLastError();
            }
            break;
        case DIF_SELECTBESTCOMPATDRV:
            dwReturn = ClassInstall_SelectBestCompatDrv(hDevInfo,
                                                        pDevInfoData,
                                                        &DevInstallParams);
            break;

        case DIF_ALLOW_INSTALL:
            dwReturn = ClassInstall_AllowInstall(hDevInfo,
                                                 pDevInfoData,
                                                 &DevInstallParams);
            break;

        case DIF_DESTROYPRIVATEDATA:
        case DIF_MOVEDEVICE:

        default:
            break;
    }

Done:
    return dwReturn;
}


BOOL
PSetupProcessPrinterAdded(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    )
/*++

Routine Description:
    Called by Add Printer Wizard after driver has been installed.
    Sets registry values in the PnPInfo subkey. If a vendor dll is given it
    is called and it also installs ICM color profiles for a printer driver
    and associates it with the printer name given.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pLocalData      : Has all the driver information and name of vendor DLL.
    pszPrinterName  : Name of printer.
    hwnd            : Window Handle

Return Value:
    TRUE on success
    FALSE else

--*/

{
    BOOL                bRet = FALSE;
    HANDLE              hPrinter = NULL;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

    bRet = OpenPrinter((LPTSTR)pszPrinterName, &hPrinter, &PrinterDefault)  &&
           SetPnPInfoForPrinter(hPrinter,
                                pLocalData->PnPInfo.pszDeviceInstanceId,
                                pLocalData->DrvInfo.pszHardwareID,
                                pLocalData->DrvInfo.pszManufacturer,
                                pLocalData->DrvInfo.pszOEMUrl);

    //
    // If a vendor dll is given we need to call into it
    //
    if ( pLocalData->InfInfo.pszVendorSetup )
        CallVendorDll(pLocalData, pszPrinterName, hwnd);

    if ( pLocalData->InfInfo.pszzICMFiles )
        (VOID)PSetupAssociateICMProfiles(pLocalData->InfInfo.pszzICMFiles,
                                         pszPrinterName);

    if ( hPrinter )
        ClosePrinter(hPrinter);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\precomp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Muhunthan Sivapragasam 17-Oct-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <objbase.h>
#define USE_SP_ALTPLATFORM_INFO_V1 0
//
// for the definition of the flag INF_STYLE_CACHE_IGNORE
//
#define _SETUPAPI_VER 0x0502
#include <setupapi.h>
#include <shellapi.h>
#include <cfgmgr32.h>
#include <winspool.h>
#include <winsprlp.h>
#include <Winver.h>
#include "splsetup.h"
#include <wincrypt.h>
#include <mscat.h>
#include <icm.h>
#include <stdio.h>
#include "tchar.h"
#include "cdm.h"
#include "web.h"
#include "local.h"
#include "spllib.hxx"
#include "printui.h"
#include "strsafe.h"
#include "splcom.h"

//
// We need to include wow64t.h to ensure that 
// WOW64_SYSTEM_DIRECTORY and WOW64_SYSTEM_DIRECTORY_U
// are defined and for 64bit file redirection in WOW64
//
#include <wow64t.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\signing.cxx ===
/*

Copyright (c) 1995-2000 Microsoft Corporation
All rights reserved.

Module Name:

    Signing.cxx

Abstract:

    Driver signing functions

Author:

    Patrick Vine (PVine) 1-Jun-2000

Revision History:

*/

#include "precomp.h"
#include "wintrust.h"

#pragma hdrstop
#include "signing.hxx"

PVOID
SetupDriverSigning( 
    IN  HDEVINFO hDevInfo,
    IN LPCTSTR   pszServerName,
    IN LPTSTR    pszInfName,
    IN LPCTSTR   pszSource,
    IN PLATFORM  platform,
    IN DWORD     dwVersion,
    IN HSPFILEQ  CopyQueue,
    IN BOOL      bWeb
    )
{
    TDriverSigning * pDSInfo;

    //
    // Create Driver Signing object and process it.
    //
    pDSInfo = new TDriverSigning();

    if(pDSInfo)
    {
        //
        // Set up the driver signing info.
        // And then call the Setup API to change the parms on the FileQueue
        //        
        if(!pDSInfo->InitDriverSigningInfo(pszServerName,pszInfName, pszSource, platform, dwVersion, bWeb) ||
           !pDSInfo->SetAltPlatformInfo(hDevInfo, CopyQueue))
        {
            delete pDSInfo;
            pDSInfo = NULL;
        }
    }

    return pDSInfo;
}

BOOL
GetCatalogFile(
    IN  HANDLE hDriverSigning,
    OUT PCWSTR *ppszCat
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = hDriverSigning && ppszCat ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *ppszCat = reinterpret_cast<TDriverSigning*>(hDriverSigning)->GetCatalogFile();
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return  SUCCEEDED(hRetval);
}

BOOL
DrvSigningIsLocalAdmin(
    IN  HANDLE hDriverSigning,
    OUT BOOL   *pbIsLocalAdmin
    )
{
    HRESULT hRetval = E_FAIL; 
    
    hRetval = hDriverSigning && pbIsLocalAdmin ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *pbIsLocalAdmin = reinterpret_cast<TDriverSigning*>(hDriverSigning)->IsLocalAdmin();
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }
    
    return  SUCCEEDED(hRetval);
}

BOOL
CleanupDriverSigning(
    IN PVOID pDSInfo
    )
{
    TDriverSigning * pDS = static_cast<TDriverSigning*>(pDSInfo);

    if(pDS)
    {
        delete pDS;
    }

    return TRUE;
}

BOOL
CheckForCatalogFileInInf(
    IN  LPCTSTR pszInfName,
    OUT LPTSTR  *lppszCatFile    OPTIONAL
    )
{
    TDriverSigning DSInfo;

    return (DSInfo.CheckForCatalogFileInInf(pszInfName,
                                            lppszCatFile));
}

BOOL
IsCatInInf(
    IN PVOID pDSInfo
    )
{
    if(!pDSInfo)
    {
        return FALSE;
    }

    return (((TDriverSigning*)pDSInfo)->CatInInf());
}



TDriverSigning::TDriverSigning( 
    ) : m_pszCatalogFileName(NULL),
        m_bCatInInf(TRUE),
        m_bDeleteTempCat(FALSE),
        m_bSetAltPlatform(FALSE),
        m_DSPlatform(MyPlatform),
        m_DSMajorVersion(dwThisMajorVersion),
        m_bIsLocalAdmin(TRUE)
{
    ZeroMemory(&m_AltPlat_Info, sizeof(SP_ALTPLATFORM_INFO));
    m_AltPlat_Info.cbSize = sizeof(SP_ALTPLATFORM_INFO);
}

TDriverSigning::~TDriverSigning()
{
    if(m_bDeleteTempCat) 
    {
        RemoveTempCat();
    }

    if(m_pszCatalogFileName) 
    {
        LocalFreeMem(m_pszCatalogFileName);
        m_pszCatalogFileName = NULL;
    }
}

/*

Function: CreateCTLContextFromFileName

Purpose:  Given a fully qualified file name, create the CCTL_CONTEXT to use
          to search for the cat OsAttr field to use for testing the signing.

Returns:  TRUE on successfully getting a PCCTL_CONTEXT
          FALSE otherwise

*/
BOOL
TDriverSigning::CreateCTLContextFromFileName(
    IN  LPCTSTR         pszFileName,
    OUT PCCTL_CONTEXT   *ppCTLContext)
{
    LPVOID  pvMappedFile = NULL;
    BOOL    bRet         = FALSE;
    HANDLE  hFile        = INVALID_HANDLE_VALUE;
    DWORD   cbFile       = 0;
    HANDLE  hMappedFile  = NULL;

    if( !ppCTLContext )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    //
    // Initialize out params
    //
    *ppCTLContext = NULL;

    //
    // Open the existing catalog file 
    //
    if(INVALID_HANDLE_VALUE == (hFile = CreateFile(pszFileName,
                                                   GENERIC_READ,
                                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                                   NULL,
                                                   OPEN_EXISTING,
                                                   FILE_ATTRIBUTE_NORMAL,
                                                   NULL)))
    {
        goto Cleanup;
    }

    if(INVALID_FILE_SIZE == (cbFile = GetFileSize(hFile, NULL)))
    {
        goto Cleanup;
    }

    if(NULL == (hMappedFile = CreateFileMapping(hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                0,
                                                NULL)))
    {
        goto Cleanup;
    }
    
    pvMappedFile = (LPVOID) MapViewOfFile(hMappedFile, 
                                          FILE_MAP_READ, 
                                          0, 
                                          0, 
                                          cbFile);
    if (pvMappedFile)
    {
        //
        // Don't need the file handle since we have a mapped file handle
        //
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        //
        // CertCreateContext uses structured exception handling internally, and will
        // catch any I/O exceptions.
        //
        if (NULL != (*ppCTLContext = (PCCTL_CONTEXT) 
                     CertCreateContext(CERT_STORE_CTL_CONTEXT,
                                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                       (LPBYTE)pvMappedFile,
                                       cbFile,
                                       0,
                                       NULL)))
        {
            bRet = TRUE;
        }
    }

Cleanup:

    if (pvMappedFile)
    {
        UnmapViewOfFile(pvMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return bRet;
}


/*
Stolen from newnt\ds\security\cryptoapi\pkitrust\softpub\drvprov.cpp - _FillVersionLongs
*/

BOOL
TDriverSigning::TranslateVersionInfo(
    IN OUT WCHAR *pwszMM, 
    IN OUT long *plMajor, 
    IN OUT long *plMinor, 
    IN OUT WCHAR *pwcFlag
    )
{
    //
    //  special characters:
    //      - = all versions less than or equal to
    //      < = all versions less than or equal to
    //      > = all versions greater than or equal to
    //      X = all sub-versions.
    //
    WCHAR   *pwszEnd;

    if(!pwszMM || !*pwszMM || !plMajor || !plMinor || !pwcFlag)
    {
        return FALSE;
    }

    *pwcFlag = L'\0';

    *plMajor = (-1L);

    *plMinor = (-1L);

    if (NULL == (pwszEnd = wcschr(pwszMM, OSATTR_VERSEP)))
    {
        return FALSE;
    }

    *pwszEnd = L'\0';

    *plMajor = _wtol(pwszMM);

    *pwszEnd = OSATTR_VERSEP;

    pwszMM = pwszEnd;

    pwszMM++;

    if (*pwszMM)
    {
       if ((*pwszMM == OSATTR_GTEQ) ||
           (*pwszMM == OSATTR_LTEQ) ||
           (*pwszMM == OSATTR_LTEQ2) ||
           (towupper(*pwszMM) == OSATTR_ALL))
        {
            *pwcFlag = towupper(*pwszMM);
            return(TRUE);
        }

        if (!(pwszEnd = wcschr(pwszMM, OSATTR_VERSEP)))
        {
            *plMinor = _wtol(pwszMM);
            return(TRUE);
        }

        *pwszEnd = L'\0';

        *plMinor = _wtol(pwszMM);

        *pwszEnd = OSATTR_VERSEP;

        pwszMM = pwszEnd;

        pwszMM++;
    }
    else
    {
        return(TRUE);
    }

    if ((*pwszMM == OSATTR_GTEQ) ||
        (*pwszMM == OSATTR_LTEQ) ||
        (*pwszMM == OSATTR_LTEQ2) ||
        (towupper(*pwszMM) == OSATTR_ALL))
    {
        *pwcFlag = towupper(*pwszMM);
    }

    return(TRUE);
}


/*

Function: CheckVersioning

Purpose:  Takes the passed pszOsAttr string and determines what OS it represents.
          The OS numbers get returned in pdwMajorVersion and pdwMinorVersion.

Returns:  TRUE if the pszOsAttr represents a valid OS for the platform and dwVersion specified.
          FALSE otherwise

Parameters: 
          IN     LPWSTR   pszOsAttr         - the OsAttr string from the cat to verify against.
          IN     PLATFORM platform          - the platform that this is cat is being installed for.
          IN     DWORD    dwVersion         - the version that of driver that this is supposed to be signed for.
          IN OUT LPDWORD  pdwMajorVersion   - Initially holds the current major version OS.  
                                              Returns with the OS major version to test against for this OsAttr field.
          IN OUT LPDWORD  pdwMinorVersion   - Initially holds the current minor version OS.  
                                              Returns with the OS minor version to test against for this OsAttr field.

Notes:    If plaform != m_DSPlatform or dwVersion != m_DSMajorVersion then we are installing 
          an additional driver, in which case we just determine what the cat file is signed 
          for and use this.  Otherwise if the cat file is signed for anything less than or 
          equal to the current OS, then set that as the OS to test signing against.  If the 
          cat is signed only for NT4 return false in this case and hope the cat is signed for
          some other OS as well.  We want to warn on NT4 "have disk" installs.

*/
BOOL
TDriverSigning::CheckVersioning( 
    IN     LPWSTR   pszOsAttr,
    IN     PLATFORM platform,
    IN     DWORD    dwVersion,
    IN OUT LPDWORD  pdwMajorVersion,
    IN OUT LPDWORD  pdwMinorVersion 
    )
{
    BOOL  bRet        = FALSE;
    WCHAR wcFlag;
    long  lMajor,
          lMinor;

    //
    // Is this signed for NT/Win9x at all.
    //
    if((*pszOsAttr == OSATTR_VER || 
        ((*pszOsAttr == OSATTR_VER_WIN9X) && platform == PlatformWin95)) &&
       (*pszOsAttr ++)                                                   &&
       *pszOsAttr++ == OSATTR_OSSEP)
    {
        if(TranslateVersionInfo(pszOsAttr, &lMajor, &lMinor, &wcFlag))
        {
            //
            // Set the minor version number if it hasn't been set.
            //
            if(lMinor == -1)
                lMinor = 0;

            if(platform != m_DSPlatform || dwVersion != m_DSMajorVersion)
            {
                //
                // This isn't to run on this platform, so just test the signing for what it is signed for.
                //
                *pdwMajorVersion = lMajor;
                *pdwMinorVersion = lMinor;
                bRet = TRUE;
            }
            else
            {
                //
                // This is to run on this platform, so make sure it isn't signed for something 
                // newer than this platform.  Warn if it signed for NT4 as we want this for
                // "have disk" installs of NT4 drivers.
                //
                if(lMajor != 4)
                {
                    if(lMajor > (long)*pdwMajorVersion)
                    {
                        //
                        // Newer major version number
                        //
                        if(wcFlag == OSATTR_LTEQ ||
                           wcFlag == OSATTR_LTEQ2)
                        {
                            bRet = TRUE;
                        }
                    }
                    else
                    {
                        if(lMajor < (long)*pdwMajorVersion)
                        {
                            //
                            // Older major version number
                            // If OSATTR_GTEQ - we don't need to change the signing info.
                            //
                            if(wcFlag != OSATTR_GTEQ)
                            {
                                *pdwMajorVersion = lMajor;
                                *pdwMinorVersion = lMinor;
                            }
                            bRet = TRUE;
                        }
                        else
                        {
                            //
                            // Same major version number
                            // look at minor numbers...
                            //
                            if(wcFlag == OSATTR_ALL)
                            {
                                bRet = TRUE;
                            }
                            else
                            {
                                if(lMinor <= (long)*pdwMinorVersion)
                                {
                                    if(wcFlag != OSATTR_GTEQ)
                                    {
                                        *pdwMinorVersion = lMinor;
                                    }
                                    bRet = TRUE;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return bRet;
}

/*

GetSigningInformation - Opens the passed catalog file and determines what the file is signed for.

Parameters:
    pszCatPathName    - The fully qualified path to the cat file to open.
    platform          - The platform we're doing this on.  There is slightly different logic for
                        if platform == m_DSPlatform vs. platform != m_DSPlatform
    dwVersion         - The printer driver version number that we are installing.
    pdwMajorVersion   - The major version number to use for testing the signing.
    pdwMinorVersion   - The minor version number to use for testing the signing.

Returns:
    The last error set.

Remarks:
    This loops through the OsAttr entry in the cat file and looks at what the cat file is signed for.
    If platform == m_DSPlatform and dwVersion == m_DSMajorVersion, then it must be signed for any 
         OS Version less than or equal to the current OS version that I'm installing on.
    Else it must be signed for some OS and we'll test the signing for that.

*/
DWORD
TDriverSigning::GetSigningInformation( 
    IN  PLATFORM platform,
    IN  DWORD    dwVersion,
    OUT LPDWORD  pdwMajorVersion,
    OUT LPDWORD  pdwMinorVersion
    )
{
    PCCTL_CONTEXT   pCTLContext  = NULL;
    CTL_INFO        *pCtlInfo    = NULL;
    CAT_NAMEVALUE   *pNV         = NULL;
    DWORD           cbDecoded;
    DWORD           i;
    OSVERSIONINFO   OSVerInfo    = {0};

    if(!pdwMajorVersion || !pdwMinorVersion)
    {
        return ERROR_INVALID_PARAMETER;
    }

    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&OSVerInfo))
    {
        //
        // Set up some defaults (why not 5.0?) and return
        // because this should never be failing.
        //
        *pdwMajorVersion = 5;
        *pdwMinorVersion = 0;
        goto Cleanup;
    }

    //
    //  Default the version info to that of the current version.
    //
    *pdwMajorVersion = OSVerInfo.dwMajorVersion;
    *pdwMinorVersion = OSVerInfo.dwMinorVersion;

    if(!m_pszCatalogFileName || !*m_pszCatalogFileName)
    {
        return ERROR_SUCCESS;
    }

    if( CreateCTLContextFromFileName(m_pszCatalogFileName, &pCTLContext) && 
        pCTLContext                                                      && 
        NULL != (pCtlInfo = pCTLContext->pCtlInfo))
    {
        for (i=0; i<pCtlInfo->cExtension; i++)
        {
            if (strcmp(CAT_NAMEVALUE_OBJID, pCtlInfo->rgExtension[i].pszObjId) == 0)
            {
                if (!CryptDecodeObject(  
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                CAT_NAMEVALUE_STRUCT,
                                pCtlInfo->rgExtension[i].Value.pbData,
                                pCtlInfo->rgExtension[i].Value.cbData,
                                0,
                                NULL,
                                &cbDecoded))
                {
                    goto Cleanup;
                }

                if (cbDecoded > 0)
                {
                    if (pNV) 
                    {
                        LocalFreeMem( pNV );
                        pNV = NULL;
                    }

                    if (NULL == (pNV = (CAT_NAMEVALUE *) LocalAllocMem(cbDecoded)))
                    {
                        goto Cleanup;
                    }

                    if (!(CryptDecodeObject(    
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                CAT_NAMEVALUE_STRUCT,
                                pCtlInfo->rgExtension[i].Value.pbData,
                                pCtlInfo->rgExtension[i].Value.cbData,
                                0,
                                pNV,
                                &cbDecoded)))
                    {
                        goto Cleanup;
                    }

                    if (_wcsicmp(pNV->pwszTag, L"OSAttr") == 0)
                    {
                        PWCHAR pVersioning = NULL;
                        PWCHAR pEnd;

                        pVersioning = (PWCHAR)pNV->Value.pbData;

                        while(pVersioning && *pVersioning)
                        {
                            pEnd = wcschr(pVersioning, OSATTR_SEP);

                            if(pEnd)
                            {
                                *pEnd = L'\0';
                            }

                            if(CheckVersioning(pVersioning, platform, dwVersion, pdwMajorVersion, pdwMinorVersion))
                            {
                                break;
                            }
    
                            if(!pEnd)
                            {
                                break;
                            }
    
                            *pEnd = OSATTR_SEP;
                            pVersioning = pEnd+1;
                        }
    
                        SetLastError(ERROR_SUCCESS);
                    }
                }

            }
        }
    }

Cleanup:

    if(pCTLContext)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if(pNV)
    {
        LocalFreeMem(pNV);
    }

    return (GetLastError());
}


/*++

Routine Description:
    Checks to see if an INF specifies a CatalogFile= entry.

Arguments:
    hInf            : Printer driver INF file handle
    lppszCatFile    : CatFileName returned - may be passed as NULL

Return Value:
    TRUE  - CatalogFile= specified in the inf file.
    FALSE - None specified.

    If lppszCatFile is not NULL, it will hold the name of the cat referenced in the inf if there is one.

--*/
BOOL
TDriverSigning::CheckForCatalogFileInInf(
    IN  LPCTSTR pszInfName,
    OUT LPTSTR  *lppszCatFile    OPTIONAL
)
{
   PSP_INF_INFORMATION pInfInfo   = NULL;
   HINF                hInf       = INVALID_HANDLE_VALUE;
   BOOL                bRet       = FALSE;
   DWORD               dwBufNeeded;

   if(!pszInfName ||
      INVALID_HANDLE_VALUE == (hInf = SetupOpenInfFile(pszInfName,
                                                       NULL,
                                                       INF_STYLE_WIN4,
                                                       NULL)))
   {
       goto Cleanup;
   }

   if(lppszCatFile)
   {
       *lppszCatFile = _TEXT('\0');
   }

   //
   // First Find out Buffer Needed
   //
   if(SetupGetInfInformation(hInf, INFINFO_INF_SPEC_IS_HINF,
                              NULL, 0, &dwBufNeeded))
   {
      //
      // Alloc Mem needed
      //
      pInfInfo = (PSP_INF_INFORMATION) LocalAllocMem(dwBufNeeded);
      if(pInfInfo)
      {
         //
         // Now get the info about the INF
         //
         if(SetupGetInfInformation(hInf, INFINFO_INF_SPEC_IS_HINF,
                                   pInfInfo, dwBufNeeded, &dwBufNeeded))
         {
            //
            // Ask Setup to find the name of the Catalog file in the INF
            //
            SP_ORIGINAL_FILE_INFO OrigInfo ={0};
            OrigInfo.cbSize = sizeof(SP_ORIGINAL_FILE_INFO);
            if(SetupQueryInfOriginalFileInformation(pInfInfo, 0, NULL, &OrigInfo))
            {
                if(lstrlen(OrigInfo.OriginalCatalogName) != 0)
                {
                    if(lppszCatFile)
                    {
                        bRet = (NULL != (*lppszCatFile = AllocStr(OrigInfo.OriginalCatalogName)));
                    }
                    else
                    {
                        bRet = TRUE;
                    }
                }
            }
         }
      }
   }

Cleanup:
   if(hInf != INVALID_HANDLE_VALUE)
   {
       SetupCloseInfFile(hInf);
   }

   //
   // Free up the Inf Info if allocated.
   //
   if(pInfInfo)
   {
      LocalFreeMem(pInfInfo);
   }

   return bRet;
}



BOOL
TDriverSigning::GetExternalCatFile(
    IN LPCTSTR  pszInfName,
    IN LPCTSTR  pszSource,
    IN DWORD    dwVersion,
    IN BOOL     bWeb
)
/*++

Routine Description:
    This routine looks for a cat file external to an inf to use for signing.
    Process:-  If inf file name matches "ntprint.inf" - look for known catalog file names 
                      - nt5prtx.cat, nt5prtx.ca_, nt4prtx.cat, nt4prta.cat.
               If no cat found - look for the first cat in the source directory.

Returns
    NULL      - no cat file found.
    Otherwise - Cat file name.

--*/
{
    LPTSTR          pszCatFile          = NULL;
    TCHAR           CatName[ MAX_PATH ] = {0};
    PTCHAR          pFileName           = NULL;
    HANDLE          hSearch;
    WIN32_FIND_DATA FindFileData;
    DWORD           dwSourceLen,
                    dwCatCount          = 0;

    if(pszSource)
    {
        //
        // +2 -> ending zero and possible extra \
        //
        if(lstrlen(pszSource) + 2 >= MAX_PATH)
            goto Cleanup;

        StringCchCopy(CatName, COUNTOF(CatName), pszSource);
        dwSourceLen = lstrlen(CatName);
        if(CatName[dwSourceLen-1] != _TEXT('\\'))
        {
            CatName[dwSourceLen++] = _TEXT('\\');
            CatName[dwSourceLen]   = 0;
        }
    }
    else
    {
        //
        // If no source specified - try the dir where the inf is placed.
        //
        if(lstrlen(pszInfName) >= MAX_PATH)
            goto Cleanup;

        StringCchCopy(CatName, COUNTOF(CatName), pszInfName);
        if(NULL != (pFileName = _tcsrchr(CatName, _TEXT('\\'))))
        {
            *(++pFileName) = 0;
            dwSourceLen = lstrlen(CatName);
        }
        else
        {
            dwSourceLen = 0;
        }
    }

    //
    //  Get the inf name.
    //
    if(NULL != (pFileName = _tcsrchr(pszInfName, _TEXT('\\'))))
    {
        *pFileName++;
    }
    else
    {
        pFileName = (PTCHAR)pszInfName;
    }

    if(pFileName && (lstrcmpi(pFileName, cszNtprintInf) == 0))
    {
        //
        //  Loop through all the known catalog files for ntprint.inf.
        //  Final cat looped through looks for the first cat in source directory.
        //
        for(dwCatCount = 0; dwCatCount < MAX_KNOWNCATS; dwCatCount++)
        {
            if(lstrlen(KnownCats[dwCatCount]) + dwSourceLen + 1 >= MAX_PATH)
                continue;

            CatName[dwSourceLen] = 0;

            StringCchCat(CatName, COUNTOF(CatName), KnownCats[dwCatCount]);
            if((hSearch = FindFirstFile( CatName, &FindFileData)) != INVALID_HANDLE_VALUE)
            {
                pszCatFile = AllocStr(CatName);
                FindClose(hSearch);
                goto Cleanup;
            }
        }
    }
    
    //
    // we ship multiple INFs for NT4 drivers on the CD, all of them signed in nt4prtx.cat
    // we warn if we try to create a queue with these driver (because the m_DSMajorVersion is 3 in this case)
    // and this is good
    //
    if (dwVersion == 2)
    {
        if(lstrlen(cszNT4CatX86) + dwSourceLen + 1 >= MAX_PATH)
            goto Cleanup;
        
        CatName[dwSourceLen] = 0;

        StringCchCat(CatName, COUNTOF(CatName), cszNT4CatX86);

        if((hSearch = FindFirstFile( CatName, &FindFileData)) != INVALID_HANDLE_VALUE)
        {
            pszCatFile = AllocStr(CatName);
            FindClose(hSearch);
            goto Cleanup;
        }
    }

    if(bWeb)
    {
        //
        // If no cat found - could be web point and print
        //
        if(lstrlen(cszCatExt) + dwSourceLen + 1 >= MAX_PATH)
            goto Cleanup;

        CatName[dwSourceLen] = 0;
        StringCchCat(CatName, COUNTOF(CatName), cszCatExt);
        if((hSearch = FindFirstFile(CatName, &FindFileData)) != INVALID_HANDLE_VALUE)
        {
            CatName[dwSourceLen] = 0;
            pszCatFile = AllocAndCatStr(CatName, FindFileData.cFileName);
            FindClose(hSearch);
        }
    }

Cleanup:

    return (NULL != (m_pszCatalogFileName = pszCatFile));
}


LPTSTR
TDriverSigning::GetINFLang(
    IN LPTSTR pszINFName
)
/*

  Function: GetINFLang

  Returns: A localised string that can be used to differentiate different nt5prtx.cats when 
          installed into the cat root.

  Parameters: pszINFName - the fully qualified inf name to be loaded and searched for the localised string.

  Notes:  This is a real hack to ensure that the SetupSetAlternateFileQueue doesn't overwrite cat files 
          from different language installs.  This is only for backwards compat with Win2K.

*/
{
    INFCONTEXT context;
    DWORD      dwNeeded = 0;
    HINF       hINF     = INVALID_HANDLE_VALUE;
    LPTSTR     pszLang  = NULL;

    if(INVALID_HANDLE_VALUE != (hINF = SetupOpenInfFile(pszINFName, 
                                                        NULL,
                                                        INF_STYLE_WIN4,
                                                        NULL)))
    {
        if(SetupFindFirstLine(hINF, _T("printer_class_addreg"), NULL, &context))
        {
            if(!(SetupGetStringField(&context, 5, pszLang, 0, &dwNeeded)            &&
                 NULL != (pszLang = (LPTSTR) LocalAllocMem(dwNeeded*sizeof(TCHAR))) &&
                 SetupGetStringField(&context, 5, pszLang, dwNeeded, &dwNeeded)))
            {
                if(pszLang)
                {
                    LocalFreeMem(pszLang);
                    pszLang = NULL;
                }
            }
            else
            {
                //
                // If SetupGetStringField was true, but returned a NULL pszLang, allocate a NULL string.
                //
                if(!pszLang)
                {
                    pszLang = AllocStr(_T(""));
                }
            }
        }

        SetupCloseInfFile(hINF);
    }

    return pszLang;
}


DWORD
TDriverSigning::UnCompressCat( 
    IN LPTSTR pszINFName
)
/*

  Function: UnCompressCat 
  
  Purpose:  Takes cat name and determines whether it needs uncompressing or not.
            (Should only occur for nt5prtx.ca_)

  Returns: ERROR_SUCCESS on passing - successfully uncompressing the cat, or if the cat doesn't
           need compressing.

  Parameters:
           ppszCatName - the fully qualified cat name.  This is freed and replaced with the
                         new fully qualified cat name if the cat needs to be uncompressed.
           pbDeleteCat - If this returns as TRUE then the cat was expanded.  It needs to be deleted
                         when setup is finished with it.

  Notes:   This function takes the fully qualified cat path and determines if the cat file is compressed.
           If it is, then it uncompresses it into a unique directory under the TEMP directory.

*/
{
    PTCHAR pDot;
    DWORD  dwError         = ERROR_SUCCESS;
    LPTSTR pszRealFileName = NULL;
    LPTSTR pszPath         = NULL;
    LPTSTR pszLang         = NULL;
    DWORD  dwCompressSize,
           dwUncompressSize;
    UINT   uiCompressType;

    if(!m_pszCatalogFileName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_bDeleteTempCat = FALSE;

    pDot = _tcsrchr(m_pszCatalogFileName, _TEXT('.'));

    if(pDot)
    {
        if(lstrcmpi(pDot, cszExtCompressedCat) == 0)
        {
            //
            // We've got a compressed cat file.  
            // Get the temp dir to copy it to, get the language name to rename it with
            // and uncompress it for use.
            //

            if(NULL != (pszPath = GetMyTempDir())         &&
               NULL != (pszLang = GetINFLang(pszINFName)) &&
               NULL != (pszRealFileName = AllocAndCatStr2(pszPath, pszLang, FileNamePart(m_pszCatalogFileName))))
            {
                pszRealFileName[lstrlen(pszRealFileName)-1] = _TEXT('t');
                //
                // Decompress the file to the temp dir.
                //
                dwError = SetupDecompressOrCopyFile(m_pszCatalogFileName, pszRealFileName, NULL);

                LocalFreeMem(m_pszCatalogFileName);
                m_pszCatalogFileName = pszRealFileName;
                pszRealFileName      = NULL;
                m_bDeleteTempCat     = TRUE;
            }
            else
            {
                dwError = GetLastError();
            }

            if(pszRealFileName)
            {
                LocalFreeMem(pszRealFileName);
            }

            if(pszPath)
            {
                LocalFreeMem(pszPath);
            }

            if(pszLang)
            {
                LocalFreeMem(pszLang);
            }
        }
    }

    return dwError;
}

//
// ISSUE-2002/02/27-mikaelho 
// Setupapi may still have a handle open to the cat file, in which case the
// file deletion will fail and the uncompressed cat and directory will be left
// behind.
//
DWORD
TDriverSigning::RemoveTempCat( 
    VOID
    )
/*

  Function: RemoveTempCat

  Purpose:  To remove the uncompressed cat file and temp dir created due to UnCompressCat

  Parameters:
            pszCatName - the fully qualified file name to remove.

  Returns:  The last error of the function calls.

  Notes:    This removes the file and the directory that the file is in if the directory
            doesn't have any other files in it.
            The last error on entering the function is saved as we don't want to overwrite
            the one already defined inside InstallDriverFromCurrentInf.

*/
{
    DWORD  dwSaveLastError = GetLastError();
    DWORD  dwReturnError   = ERROR_SUCCESS;
    PTCHAR pFileName       = NULL;

    if(m_pszCatalogFileName)
    {

        DeleteFile(m_pszCatalogFileName);
    
        if(NULL != (pFileName = FileNamePart(m_pszCatalogFileName)))
        {
            *pFileName = _TEXT('\0');
            RemoveDirectory(m_pszCatalogFileName);
        }

        dwReturnError = GetLastError();

        SetLastError(dwSaveLastError);
    }

    return dwReturnError;
}

/*

  Function: QualifyCatFile

  Purpose: Turn the passed cat file into a fully qualified path to the cat file.

  Parameters:
           pszSource           - the source directory of the cat file.
           ppszCatalogFileName - hold the unqualified cat file initially and returns with the fully qualified one.

  Returns: TRUE on success, FALSE otherwise.

*/
BOOL
TDriverSigning::QualifyCatFile( 
    IN     LPCTSTR  pszSource
    )
{
    LPTSTR pszQualifiedCat = NULL;

    if(!m_pszCatalogFileName || !*m_pszCatalogFileName)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // No source to add.
    //
    if(!pszSource || !*pszSource)
    {
        return TRUE;
    }

    if(pszSource[lstrlen(pszSource)-1] == _TEXT('\\'))
    {
        pszQualifiedCat = AllocAndCatStr(pszSource, m_pszCatalogFileName);
    }
    else
    {
        pszQualifiedCat = AllocAndCatStr2(pszSource, _TEXT("\\"), m_pszCatalogFileName);
    }

    if(pszQualifiedCat)
    {
        LocalFreeMem(m_pszCatalogFileName);
        m_pszCatalogFileName = pszQualifiedCat;
    }

    return (pszQualifiedCat != NULL);
}

BOOL
TDriverSigning::SetMajorVersion(
    IN OSVERSIONINFO OSVerInfo
    )
{
    if(OSVerInfo.dwMajorVersion == 4)
    {
        m_DSMajorVersion = 2;
    }
    else
    {
        m_DSMajorVersion = dwThisMajorVersion;
    }

    return TRUE;
}

BOOL
TDriverSigning::SetPlatform(
    IN LPCTSTR pszServerName
    )
{
    BOOL bRet = FALSE;

    if(!pszServerName || !*pszServerName)
    {
        bRet = TRUE;
        m_DSPlatform = MyPlatform;
    }
    else
    {
        TCHAR pArch[MAX_PATH];
        DWORD cbNeeded;

        cbNeeded = COUNTOF(pArch);
        if(GetArchitecture(pszServerName, pArch, &cbNeeded))
        {
            DWORD_PTR dwPlatform = (DWORD_PTR)MIN_PLATFORM;

            bRet = TRUE;

            for(;
                dwPlatform <= (DWORD_PTR)MAX_PLATFORM && lstrcmpi(PlatformEnv[(PLATFORM)dwPlatform].pszName, pArch) != 0;
                dwPlatform++)
                ;
    
            if(dwPlatform > (DWORD_PTR)MAX_PLATFORM)
            {
                m_DSPlatform = MyPlatform;
            }
            else
            {
                m_DSPlatform = (PLATFORM)dwPlatform;
            }
        }
    }

    return bRet;
}

BOOL
TDriverSigning::InitDriverSigningInfo( 
    IN LPCTSTR  pszServerName,
    IN LPTSTR   pszInfName,
    IN LPCTSTR  pszSource,
    IN PLATFORM platform,
    IN DWORD    dwVersion,
    IN BOOL     bWeb
    )
{
    OSVERSIONINFO OSVerInfo = {0};
    BOOL          bRet      = FALSE;
    DWORD         dwMajorVersion,
                  dwMinorVersion;

    //
    // Make sure there is no allocation done.
    //
    if(m_pszCatalogFileName)
    {
        LocalFreeMem(m_pszCatalogFileName);
        m_pszCatalogFileName = NULL;
    }

    if (!::IsLocalAdmin(&m_bIsLocalAdmin))
    {
        goto Cleanup;
    }
    
    //
    // Reset the Alt platform info.
    //
    ZeroMemory(&m_AltPlat_Info, sizeof(SP_ALTPLATFORM_INFO));
    m_AltPlat_Info.cbSize = sizeof(SP_ALTPLATFORM_INFO);
    m_bSetAltPlatform = FALSE;

    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    //
    // If this fails we are not doing very well, just fail.
    //
    if(!GetOSVersion(pszServerName,&OSVerInfo))
    {
        goto Cleanup;
    }

    SetMajorVersion(OSVerInfo);
    SetPlatform(pszServerName);

    //
    // in case we have no inf yet, just take the first one in the directory and look for a CatalogFile
    // we're doing this for Win9x drivers, where I need to setup the alternate platform information
    // 
    if (!pszInfName && platform == PlatformWin95)
    {
        m_pszCatalogFileName = FindCatInDirectory(pszSource);
        m_bCatInInf = m_pszCatalogFileName ? TRUE : FALSE;
    }
    
    //
    // Get cat file name.  If it is in the inf, then let setupapi handle the situation.
    // Otherwise we need to find one for legacy cases - eg "have disking" to ntprint.inf on
    // released server CD.
    //
    else if(!(m_bCatInInf = CheckForCatalogFileInInf(pszInfName, &m_pszCatalogFileName)))
    {
        if(GetExternalCatFile(pszInfName, pszSource, dwVersion, bWeb))
        {
            if(ERROR_SUCCESS != UnCompressCat(pszInfName))
            {
                if(m_pszCatalogFileName)
                {
                    LocalFreeMem(m_pszCatalogFileName);
                    m_pszCatalogFileName = NULL;
                }
            }
        }
    }
    else
    {
        //
        // We need to fully qualify the cat file so we can determine what it is signed for.
        //
        if(pszSource)
        {
            QualifyCatFile(pszSource);
        }
        else
        {
            PTCHAR pFileName = NULL;

            pFileName = FileNamePart(pszInfName);
            if(pFileName)
            {
                TCHAR pChar = *pFileName;

                *pFileName = _TEXT('\0');
                QualifyCatFile(pszInfName);
                *pFileName = pChar;
            }
        }
    }

    //
    // If we have a catalog file then lets find out what it is signed for.
    // Don't check the return value as this may be a cat that is referenced in an inf and we may not find it.
    // Rather warn than fail.
    //
    if(m_pszCatalogFileName)
    {
        GetSigningInformation(platform, dwVersion, &dwMajorVersion, &dwMinorVersion);
    }
    else
    {
        dwMajorVersion = OSVerInfo.dwMajorVersion;
        dwMinorVersion = OSVerInfo.dwMinorVersion;
    }

    //
    // If this is to be installable and runable on this platform,
    // Verify that this in not signed only for an OS version > than this one.
    // If it is, we need to warn the user though driver signing that this has never
    // been signed for this OS - hence probably not tested for it.
    //
    if(platform  == m_DSPlatform && 
       dwVersion == m_DSMajorVersion)
    {
        if(dwMajorVersion > OSVerInfo.dwMajorVersion || 
           (dwMajorVersion == OSVerInfo.dwMajorVersion && dwMinorVersion > OSVerInfo.dwMinorVersion))
        {
            dwMajorVersion = OSVerInfo.dwMajorVersion;
            dwMinorVersion = OSVerInfo.dwMinorVersion;
        }
    }
    
    m_AltPlat_Info.MajorVersion               = dwMajorVersion;
    m_AltPlat_Info.MinorVersion               = dwMinorVersion;
    m_AltPlat_Info.Platform                   = PlatformArch[ platform ][OS_PLATFORM];
    m_AltPlat_Info.ProcessorArchitecture      = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];
    m_AltPlat_Info.Reserved                   = 0;
    m_AltPlat_Info.FirstValidatedMajorVersion = m_AltPlat_Info.MajorVersion;
    m_AltPlat_Info.FirstValidatedMinorVersion = m_AltPlat_Info.MinorVersion;


    //
    // We need an Alternate platform info struct if:
    //       1) We need to associate another Cat File with the queue.
    //       2) We need to change the version that we want to test the signing against.
    //       3) We need to change the platform that we want to test the signing against.
    //
    m_bSetAltPlatform = ((!CatInInf() && 
                           m_pszCatalogFileName                      ) || 
                           dwMajorVersion != OSVerInfo.dwMajorVersion  ||
                           platform != m_DSPlatform);

    bRet = TRUE;

Cleanup:

    return bRet;
}

BOOL
TDriverSigning::CatInInf(
    VOID
    )
{
    return m_bCatInInf;
}

BOOL
TDriverSigning::SetAltPlatformInfo(
    IN  HDEVINFO hDevInfo,
    IN  HSPFILEQ CopyQueue
    )
{
    if(m_bSetAltPlatform)
    {
        SP_DEVINSTALL_PARAMS DevInstallParams = {0}; 
        //
        // Set up Alternative platform searches so that when we set up the driver signing OS below 
        // it will be used throughout the alternate OS installation.
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if(SetupDiGetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams))
        {
            DevInstallParams.FlagsEx |= DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
            DevInstallParams.Flags   |= DI_NOVCP;

            if(DevInstallParams.FileQueue == NULL || DevInstallParams.FileQueue == INVALID_HANDLE_VALUE)
            {
                DevInstallParams.FileQueue = CopyQueue;
            }

            SetupDiSetDeviceInstallParams(hDevInfo, 
                                          NULL,
                                          &DevInstallParams);

        }

        return (SetupSetFileQueueAlternatePlatform(CopyQueue, 
                                                   &m_AltPlat_Info,
                                                   (m_bCatInInf ? NULL : m_pszCatalogFileName)));
    }

    return TRUE;
}

/*

  Function: FindCatInDirectory

  Purpose: In case we only have a directory but no INF selected, find the first CatalogFile= entry in all the
           INFs in the directory. This is done explicitly to fit the distribution of Win9x drivers on Server CDs

  Parameters:
           pszSource           - the source directory of the inf files.

  Returns: pszCatFile          - the fully qualified name of the first referenced CAT file

*/

LPTSTR TDriverSigning::FindCatInDirectory(IN LPCTSTR pszSource)
{
    TCHAR  InfName[MAX_PATH];
    LPTSTR pCatName = NULL, pTmp = NULL;
    DWORD  len;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData = {0};

    if (!pszSource)
    {
        goto Cleanup;
    }

    len = _tcslen(pszSource);
    if (len + _tcslen(cszInfExt) +1 > MAX_PATH)
    {
        goto Cleanup;
    }

    StringCchCopy(InfName, COUNTOF(InfName), pszSource);

    //
    // cszInfExt contains a backslash, so remove it from the source path if there
    //
    
    if (InfName[len-1] == _T('\\'))
    {
        InfName[len-1] = 0;
        len--;
    }

    StringCchCopy(&InfName[len], COUNTOF(InfName) - len, cszInfExt);

    
    if((hSearch = FindFirstFile( InfName, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        //
        // append a backslash - the length is already checked above.
        //
        InfName[len++]  = _T('\\');
        InfName[len]    = 0;

        do
        {
            if (len + _tcslen(FindFileData.cFileName) + 1 > MAX_PATH)
            {
                goto Cleanup;
            }

            StringCchCopy(&InfName[len], COUNTOF(InfName) - len, FindFileData.cFileName);

            if (CheckForCatalogFileInInf(InfName, &pCatName))
            {
                pTmp = pCatName;

                InfName[len] = 0;
                
                pCatName = AllocAndCatStr(InfName, pTmp);
                
                LocalFreeMem(pTmp);

                goto Cleanup;
            }

        } while (FindNextFile(hSearch, &FindFileData));

        //
        // no catalog file entry found - don't attempt anything funny
        //
    }


Cleanup:
    if (hSearch != INVALID_HANDLE_VALUE)
    {
        FindClose(hSearch);
    }
    return pCatName;
}

LPCTSTR
TDriverSigning::GetCatalogFile(
    VOID    
    )
{
    return m_pszCatalogFileName;
}

BOOL
TDriverSigning::IsLocalAdmin(
    VOID    
    )
{
    return m_bIsLocalAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\srvinst.cxx ===
/*++

  Copyright (c) 1995-97 Microsoft Corporation
  All rights reserved.

  Module Name:

        SrvInst.c

  Purpose:


        Server side install code.  This code will be called from a process created by the spooler to do a
        "server" side install of a printer driver.

  Author:

        Patrick Vine (pvine) - 22 March 2000

  Revision History:

--*/

#include "precomp.h"

#pragma hdrstop
#include "srvinst.hxx"

const TCHAR   gcszNTPrint[]  = _TEXT("inf\\ntprint.inf");

/*++

Routine Name:

    ServerInstall

Routine Description:

    Server side install code to be called by a process created by spooler.
    
    Installs the given printer driver - unless a newer driver with the same name
    is installed - from ntprint.inf in %WINDIR%\inf
    No UIs are popped up and the function will fail if UI would be required. Code
    is called by a process created by spooler. The driver name is passed as a command
    line argument to rundll32 in localspl.
    
    Localspl.dll spins a rundll32 process (using CreateProcess) which calls the ServerInstall
    entry point in ntprint.dll. Thus ServerInstall will be running in local system context.

Arguments:

    hwnd            - Window handle of stub window.
    hInstance,      - Rundll instance handle.
    pszCmdLine      - Pointer to command line.
    nCmdShow        - Show command value always TRUE.

Return Value:

    Returns the last error code.  This can be read by the spooler by getting the return code from the process.

--*/
DWORD
ServerInstallW(
    IN HWND        hwnd,
    IN HINSTANCE   hInstance,
    IN LPCTSTR     pszCmdLine,
    IN UINT        nCmdShow
    )
{
    CServerInstall Installer;

    if( Installer.ParseCommand((LPTSTR)pszCmdLine) )
    {
        Installer.InstallDriver();
    }

    //
    // If an error occurs we call ExitProcess. Then the spooler picks up the 
    // error code using GetExitCodeProcess. If no error occurs, then we
    // terminate normally
    //
    if (Installer.GetLastError() != ERROR_SUCCESS) 
    {
        ExitProcess(Installer.GetLastError());
    }

    return Installer.GetLastError();
}

////////////////////////////////////////////////////////////////////////////////
//
// Method definitions for CServerInstall Class.
//
////////////////////////////////////////////////////////////////////////////////

CServerInstall::
CServerInstall() : _dwLastError(ERROR_SUCCESS),
                   _tsDriverName(),
                   _tsNtprintInf()
{
}

CServerInstall::
~CServerInstall()
{
}

BOOL
CServerInstall::
InstallDriver()
{

    if(  SetInfToNTPRINTDir() &&
         DriverNotInstalled() )
    {
        _dwLastError = ::InstallDriverSilently(_tsNtprintInf, _tsDriverName, NULL);
    }

    return (_dwLastError == ERROR_SUCCESS);
}


/*++

    Parameter structure:

          1st word : Flags = default == 0 for now

          if flags = 0
             2nd word : Pipe name to open

--*/
BOOL
CServerInstall::
ParseCommand( LPTSTR pszCommandStr )
{
    TCHAR * pTemp;
    DWORD   dwCount = 0;

    //
    // If we don't have a valid command string
    //
    if( !pszCommandStr || !*pszCommandStr )
    {
        _dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Grap the driver name
    //
    if( !_tsDriverName.bUpdate( pszCommandStr ))
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

Cleanup:
    return (_dwLastError == ERROR_SUCCESS);
}



DWORD
CServerInstall::
GetLastError()
{
    SetLastError(_dwLastError);
    return _dwLastError;
}


//
//  Returns: TRUE if SUCCESS, FALSE otherwise
//
//  Sets the _stInf string to contain %windir%\inf\ntprint.inf
//
BOOL
CServerInstall::
SetInfToNTPRINTDir()
{
    UINT   uiSize        = 0;
    UINT   uiAllocSize   = 0;
    PTCHAR pData         = NULL;
    TCHAR  szNTPrintInf[MAX_PATH];
    DWORD  dwPos;

    _dwLastError = ERROR_INVALID_DATA;

    //
    //  Get %windir%
    //  If the return is 0 - the call failed.
    //  If the return is greater than MAX_PATH we want to fail as something has managed to change
    //  the system dir to longer than MAX_PATH which is invalid. If length is the same we also fail
    //  since we might add a '\' and gcszNTPrint is longer than 1 for sure!
    //
    uiSize = GetSystemWindowsDirectory( szNTPrintInf, COUNTOF(szNTPrintInf) );
    if( !uiSize || uiSize >= COUNTOF(szNTPrintInf) )
        goto Cleanup;

    //
    // If we don't end in a \ then add one.
    //
    dwPos = _tcslen(szNTPrintInf) - 1;
    pData = &szNTPrintInf[ dwPos++ ];
    if( *pData++ != _TEXT('\\') )
    {
        *(pData++) = _TEXT('\\');
        ++dwPos;
    }

    *(pData) = 0;
    uiSize = _tcslen( szNTPrintInf ) + _tcslen( gcszNTPrint ) + 1;

    //
    // If what we've got sums up to a longer string than the allowable length MAX_PATH - fail
    //
    if( uiSize > COUNTOF(szNTPrintInf) )
        goto Cleanup;

    //
    //  Copy the inf\ntprint.inf string onto the end of the %windir%\ string.
    //
    StringCchCopy( pData, COUNTOF(szNTPrintInf) - dwPos, gcszNTPrint);

    _dwLastError = ERROR_SUCCESS;

Cleanup:

    if( _dwLastError != ERROR_SUCCESS && szNTPrintInf )
    {
        //
        // Got here due to some error.  Get what the called function set the last error to.
        // If the function set a success, set some error code.
        //
        if( (_dwLastError = ::GetLastError()) == ERROR_SUCCESS )
            _dwLastError = ERROR_INVALID_DATA;

        szNTPrintInf[0] = 0;
    }

    if( !_tsNtprintInf.bUpdate( szNTPrintInf ) )
        _dwLastError = ::GetLastError();

    return (_dwLastError == ERROR_SUCCESS);
}




/*+

  This function enumerates the drivers and finds if there is one of the same name currently installed.
  If there is then open the inf to install with and verify that the inf's version date is newer than the
  already installed driver.

  Returns: TRUE  - if anything fails or the installed date isn't newer than the inf date.
           FALSE - only if the driver is installed AND it's date is newer than the inf's date.

-*/
BOOL
CServerInstall::
DriverNotInstalled()
{
    LPCTSTR             pszKey       = _TEXT("DriverVer");
    LPTSTR              pszEntry     = NULL;
    LPDRIVER_INFO_6     pDriverInfo6 = NULL;
    LPBYTE              pBuf         = NULL;
    PSP_INF_INFORMATION pInfo        = NULL;
    SYSTEMTIME          Time         = {0};
    BOOL                bRet         = TRUE;
    DWORD               dwLength,
                        dwRet,
                        dwIndex;
    TCHAR               *pTemp,
                        *pTemp2;

    if(!EnumPrinterDrivers( NULL, PlatformEnv[MyPlatform].pszName, 6, pBuf, 0, &dwLength, &dwRet ))
    {
        if( ::GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            return TRUE;

        if( (pBuf = (LPBYTE) AllocMem( dwLength )) == NULL ||
            !EnumPrinterDrivers( NULL, PlatformEnv[MyPlatform].pszName, 6, pBuf, dwLength, &dwLength, &dwRet ))
        {
            _dwLastError = ::GetLastError();
            goto Cleanup;
        }
    }
    else
    {
        //
        // Only way this could succeed is if no drivers installed.
        //
        return TRUE;
    }

    for( dwIndex = 0, pDriverInfo6 = (LPDRIVER_INFO_6)pBuf; dwIndex < dwRet; dwIndex++, pDriverInfo6++ )
    {
        if( _tcscmp( pDriverInfo6->pName, (LPCTSTR)_tsDriverName ) == 0 )
            break;
    }

    if(dwIndex >= dwRet)
    {
        //
        // Driver not found
        //
        goto Cleanup;
    }

    //
    // The driver has been found...  Open up inf and look at it's date.
    //

    //
    // Firstly get the size that will be needed for pInfo.
    //
    if( !SetupGetInfInformation( (LPCTSTR)_tsNtprintInf, INFINFO_INF_NAME_IS_ABSOLUTE, pInfo, 0, &dwLength ) )
    {
        _dwLastError = ::GetLastError();
        goto Cleanup;
    }

    //
    // Alloc pInfo and fill it.
    //
    if( (pInfo = (PSP_INF_INFORMATION) AllocMem( dwLength )) != NULL &&
        SetupGetInfInformation( (LPCTSTR)_tsNtprintInf, INFINFO_INF_NAME_IS_ABSOLUTE, pInfo, dwLength, &dwLength ) )
    {
        //
        //  Get the size of the date string
        //
        if( SetupQueryInfVersionInformation( pInfo, 0, pszKey, pszEntry, 0, &dwLength ))
        {
            //
            // Alloc pszEntry and fill it.
            //
            if( (pszEntry = (LPTSTR) AllocMem( dwLength*sizeof(TCHAR) )) != NULL &&
                SetupQueryInfVersionInformation( pInfo, 0, pszKey, pszEntry, dwLength, &dwLength ))
            {
                //
                // Now convert the date string into a SYSTEMTIME
                // Date is of the form 03/22/2000
                //
                // Get the month - 03 part
                //
                if( (pTemp = _tcschr( pszEntry, _TEXT('/'))) != NULL )
                {
                    *pTemp++ = 0;
                    Time.wMonth = (WORD)_ttoi( pszEntry );
                    pTemp2 = pTemp;

                    //
                    // Get the day - 22 part
                    //
                    if( (pTemp = _tcschr( pTemp2, _TEXT('/'))) != NULL )
                    {
                        *pTemp++ = 0;
                        Time.wDay = (WORD)_ttoi( pTemp2 );
                        pTemp2 = pTemp;

                        //
                        // Get the year - 2000 part
                        //
                        pTemp = _tcschr( pTemp2, _TEXT('/'));
                        if( pTemp )
                            *pTemp = 0;
                        Time.wYear = (WORD)_ttoi( pTemp2 );
                    }
                    else
                        _dwLastError = ERROR_INVALID_PARAMETER;
                }
                else
                    _dwLastError = ERROR_INVALID_PARAMETER;
            }
            else
                _dwLastError = ::GetLastError();
        }
        else
            _dwLastError = ::GetLastError();
    }
    else
        _dwLastError = ::GetLastError();


    //
    //  If we got all the way to filling in the year, we may have something useful...
    //
    if( Time.wYear )
    {
        FILETIME ftTime = {0};
        if(SystemTimeToFileTime( &Time, &ftTime ))
        {
            //
            // If the inf time is more recent than what is installed,
            // reinstall, otherwise don't
            //
            if( CompareFileTime(&ftTime, &pDriverInfo6->ftDriverDate) < 1 )
            {
                bRet = FALSE;
            }
        }
        //
        // Getting here and return TRUE or FALSE is still a successful call.
        //
        _dwLastError = ERROR_SUCCESS;
    }
    else
        _dwLastError = ERROR_INVALID_PARAMETER;

Cleanup:
    if( pBuf )
        FreeMem( pBuf );

    if( pInfo )
        FreeMem( pInfo );

    if( pszEntry )
        FreeMem( pszEntry );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\util.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Util.c

Abstract:

    Driver Setup UI Utility functions

Author:

    Muhunthan Sivapragasam (MuhuntS)  06-Sep-1995

Revision History:

--*/

#include "precomp.h"
#include "splcom.h"

#define MAX_DWORD_LENGTH          11

//
// Keys to search for in ntprint.inf
//
TCHAR   cszDataSection[]                = TEXT("DataSection");
TCHAR   cszDriverFile[]                 = TEXT("DriverFile");
TCHAR   cszConfigFile[]                 = TEXT("ConfigFile");
TCHAR   cszDataFile[]                   = TEXT("DataFile");
TCHAR   cszHelpFile[]                   = TEXT("HelpFile");
TCHAR   cszDefaultDataType[]            = TEXT("DefaultDataType");
TCHAR   cszLanguageMonitor[]            = TEXT("LanguageMonitor");
TCHAR   cszPrintProcessor[]             = TEXT("PrintProcessor");
TCHAR   cszCopyFiles[]                  = TEXT("CopyFiles");
TCHAR   cszVendorSetup[]                = TEXT("VendorSetup");
TCHAR   cszVendorInstaller[]            = TEXT("VendorInstaller");

TCHAR   cszPreviousNamesSection[]       = TEXT("Previous Names");
TCHAR   cszOEMUrlSection[]              = TEXT("OEM URLS");

TCHAR   cszWebNTPrintPkg[]              = TEXT("3FBF5B30-DEB4-11D1-AC97-00A0C903492B");

TCHAR   cszAllInfs[]                    = TEXT("*.inf");
TCHAR   cszInfExt[]                     = TEXT("\\*.inf");

TCHAR   sComma                          = TEXT(',');
TCHAR   sHash                           = TEXT('@');
TCHAR   sZero                           = TEXT('\0');

TCHAR   cszSystemSetupKey[]             = TEXT("System\\Setup");
TCHAR   cszSystemSetupInProgress[]      = TEXT("SystemSetupInProgress");

TCHAR   cszMonitorKey[]                 = TEXT("SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors\\");

//
// Native environment name used by spooler
//
SPLPLATFORMINFO PlatformEnv[] = {

    { TEXT("Windows NT Alpha_AXP") },
    { TEXT("Windows NT x86") },
    { TEXT("Windows NT R4000") },
    { TEXT("Windows NT PowerPC") },
    { TEXT("Windows 4.0") },
    { TEXT("Windows IA64") },
    { TEXT("Windows Alpha_AXP64") }
};

//
// Platform override strings to be used to upgrade non-native architecture
// printer drivers
//
SPLPLATFORMINFO PlatformOverride[] = {

    { TEXT("alpha") },
    { TEXT("i386") },
    { TEXT("mips") },
    { TEXT("ppc") },
    { NULL },       // Win95
    { TEXT("ia64") },
    { TEXT("axp64") }
};

DWORD                PlatformArch[][2] =
{
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_ALPHA },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_INTEL },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_MIPS },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_PPC },
   { VER_PLATFORM_WIN32_WINDOWS, PROCESSOR_ARCHITECTURE_INTEL },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_IA64 },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_ALPHA64 }
};

PLATFORM    MyPlatform =
#if defined(_ALPHA_)
        PlatformAlpha;
#elif defined(_MIPS_)
        PlatformMIPS;
#elif defined(_PPC_)
        PlatformPPC;
#elif defined(_X86_)
        PlatformX86;
#elif   defined(_IA64_)
        PlatformIA64;
#elif   defined(_AXP64_)
        PlatformAlpha64;
#elif   defined(_AMD64_)
        0;                              // ****** fixfix ****** amd64
#else
#error "No Target Architecture"
#endif

// Declare the CritSec for CDM
CRITICAL_SECTION CDMCritSect;

#define         SKIP_DIR                TEXT("\\__SKIP_")

CRITICAL_SECTION SkipCritSect;
LPTSTR           gpszSkipDir = NULL;


PVOID
LocalAllocMem(
    IN UINT cbSize
    )
{
    return LocalAlloc( LPTR, cbSize );
}

VOID
LocalFreeMem(
    IN PVOID p
    )
{
    LocalFree(p);
}

//
// For some reason these are needed by spllib when you use StrNCatBuf.
// This doesn't make any sense, but just implement them.
//
LPVOID
DllAllocSplMem(
    DWORD cbSize
)
{
    return LocalAllocMem(cbSize);
}

BOOL
DllFreeSplMem(
   LPVOID pMem
)
{
    LocalFreeMem(pMem);
    return TRUE;
}

VOID
PSetupFreeMem(
    IN PVOID p
    )
/*++

Routine Description:
    Just a call to LocalFree

Arguments:
    p : memory to be freed

Return Value:
    none

--*/

{
    LocalFreeMem(p);
}



LPTSTR
AllocStr(
    LPCTSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of a string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPTSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = LocalAllocMem((lstrlen(pszStr) + 1) * sizeof(*pszRet));
        if ( pszRet )
            StringCchCopy(pszRet, (lstrlen(pszStr) + 1), pszStr);
    }

    return pszRet;
}


LPTSTR
AllocAndCatStr(
    LPCTSTR  pszStr1,
    LPCTSTR  pszStr2
    )
/*++

Routine Description:
    Allocate memory and make a copy of two string fields, cancatenate the second to
    the first

Arguments:
    pszStr1   : String to copy
    pszStr2   : String to CAT

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
    {
    LPTSTR  pszRet = NULL;

    if ( pszStr1 && *pszStr1 &&
         pszStr2 && *pszStr2 ) {
        DWORD dwBufSize = (lstrlen(pszStr1) + lstrlen(pszStr2) + 1) * sizeof(*pszRet);

        pszRet = LocalAllocMem(dwBufSize);
        if ( pszRet ) {
            StringCbCopy( pszRet, dwBufSize, pszStr1 );
            StringCbCat(  pszRet, dwBufSize, pszStr2 );
        }
     }
    return pszRet;
}

LPTSTR
AllocAndCatStr2(
    LPCTSTR  pszStr1,
    LPCTSTR  pszStr2,
    LPCTSTR  pszStr3
    )
/*++

Routine Description:
    Allocate memory and make a copy of two string fields, cancatenate the second to
    the first

Arguments:
    pszStr1   : String to copy
    pszStr2   : String to CAT
    pszStr3   : Second string to CAT

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
    {
    LPTSTR    pszRet = NULL;
    DWORD     cSize  = 0;

    if ( pszStr1 &&
         pszStr2 &&
         pszStr3 ) {

        if(*pszStr1)
        {
            cSize += lstrlen(pszStr1);
        }

        if(*pszStr2)
        {
            cSize += lstrlen(pszStr2);
        }

        if(*pszStr3)
        {
            cSize += lstrlen(pszStr3);
        }

        pszRet = LocalAllocMem((cSize+1)*sizeof(*pszRet));

        if ( pszRet ) {

            if(*pszStr1)
            {
                StringCchCopy( pszRet, (cSize+1), pszStr1 );

                if(*pszStr2)
                {
                    StringCchCat( pszRet, (cSize+1), pszStr2 );
                }

                if(*pszStr3)
                {
                    StringCchCat( pszRet, (cSize+1), pszStr3 );
                }
            }
            else
            {
                if(*pszStr2)
                {
                    StringCchCopy( pszRet, (cSize+1), pszStr2 );

                    if(*pszStr3)
                    {
                        StringCchCat( pszRet, (cSize+1), pszStr3 );
                    }
                }
                else
                {
                    if(*pszStr3)
                    {
                        StringCchCopy( pszRet, (cSize+1), pszStr3 );
                    }
                }
            }
        }
    }
    return pszRet;
}




VOID
FreeStructurePointers(
    LPBYTE      pStruct,
    PULONG_PTR  pOffsets,
    BOOL        bFreeStruct
    )
/*++

Routine Description:
    Frees memory allocated to fields given by the pointers in a structure.
    Also optionally frees the memory allocated for the structure itself.

Arguments:
    pStruct     : Pointer to the structure
    pOffsets    : Array of DWORDS (terminated by -1) givings offsets
    bFreeStruct : If TRUE structure is also freed

Return Value:
    nothing

--*/
{
    INT i;

    if ( pStruct ) {

        for( i = 0 ; pOffsets[i] != -1; ++i )
        {
            LocalFreeMem(*(LPBYTE *) (pStruct+pOffsets[i]));
            (*(LPBYTE *) (pStruct+pOffsets[i])) = 0;
        }

        if ( bFreeStruct )
            LocalFreeMem(pStruct);
    }
}


VOID
DestroyLocalData(
    IN  PPSETUP_LOCAL_DATA   pLocalData
    )
{
    if ( pLocalData ) {

        if ( pLocalData->Flags & VALID_INF_INFO )
            FreeStructurePointers((LPBYTE)&pLocalData->InfInfo,
                                  InfInfoOffsets,
                                  FALSE);

        if ( pLocalData->Flags & VALID_PNP_INFO )
            FreeStructurePointers((LPBYTE)&pLocalData->PnPInfo,
                                  PnPInfoOffsets,
                                  FALSE);

        FreeStructurePointers((LPBYTE)pLocalData, LocalDataOffsets, TRUE);
    }
}


VOID
InfGetString(
    IN      PINFCONTEXT     pInfContext,
    IN      DWORD           dwFieldIndex,
    OUT     LPTSTR         *ppszField,
    IN OUT  LPDWORD         pcchCopied,
    IN OUT  LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a string field from an Inf file

Arguments:
    lpInfContext    : Inf context for the line
    dwFieldIndex    : Index of the field within the specified line
    ppszField       : Pointer to the field to allocate memory and copy
    pcchCopied      : On success number of charaters copied is added
    pbFail          : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    TCHAR   Buffer[MAX_PATH];
    DWORD   dwNeeded;

    if ( *pbFail )
        return;

    if ( SetupGetStringField(pInfContext,
                             dwFieldIndex,
                             Buffer,
                             SIZECHARS(Buffer),
                             &dwNeeded) ) {

        *ppszField      = AllocStr(Buffer);
        *pcchCopied    += dwNeeded;
        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
         !(*ppszField = LocalAllocMem(dwNeeded*sizeof(Buffer[0]))) ) {

        *pbFail = TRUE;
        return;
    }

    if ( !SetupGetStringField(pInfContext,
                              dwFieldIndex,
                              *ppszField,
                              dwNeeded,
                              &dwNeeded) ) {

        *pbFail = TRUE;
        return;
    }

    *pcchCopied += dwNeeded;
}


VOID
InfGetMultiSz(
    IN      PINFCONTEXT     pInfContext,
    IN      DWORD           dwFieldIndex,
    OUT     LPTSTR         *ppszField,
    IN OUT  LPDWORD         pcchCopied,
    IN OUT  LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a multi-sz field from an Inf file

Arguments:
    lpInfContext    : Inf context for the line
    dwFieldIndex    : Index of the field within the specified line
    ppszField       : Pointer to the field to allocate memory and copy
    pcchCopied      : On success number of charaters copied is added
    pbFail          : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    TCHAR   Buffer[MAX_PATH];
    DWORD   dwNeeded;

    if ( *pbFail )
        return;

    if ( SetupGetMultiSzField(pInfContext,
                              dwFieldIndex,
                              Buffer,
                              SIZECHARS(Buffer),
                              &dwNeeded) ) {

        if ( *ppszField = LocalAllocMem(dwNeeded*sizeof(Buffer[0])) ) {

            CopyMemory(*ppszField, Buffer, dwNeeded * sizeof(Buffer[0]));
            *pcchCopied    += dwNeeded;
        } else {

            *pbFail = TRUE;
        }
        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
         !(*ppszField = LocalAllocMem(dwNeeded * sizeof(Buffer[0]))) ) {

        *pbFail = TRUE;
        return;
    }

    if ( !SetupGetMultiSzField(pInfContext,
                               dwFieldIndex,
                               *ppszField,
                               dwNeeded,
                               &dwNeeded) ) {

        *pbFail = TRUE;
        return;
    }

    *pcchCopied += dwNeeded;
}


VOID
InfGetDriverInfoString(
    IN     HINF            hInf,
    IN     LPCTSTR         pszDriverSection,
    IN     LPCTSTR         pszDataSection, OPTIONAL
    IN     BOOL            bDataSection,
    IN     LPCTSTR         pszKey,
    OUT    LPTSTR         *ppszData,
    IN     LPCTSTR         pszDefaultData,
    IN OUT LPDWORD         pcchCopied,
    IN OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a driver info field from an inf file

Arguments:
    hInf             : Handle to the Inf file
    pszDriverSection : Section name for the driver
    pszDataSection   : Data section for the driver (optional)
    bDataSection     : Specifies if there is a data section
    pszKey           : Key value of the field to look for
   *ppszData         : Pointer to allocate memory and copy the data field
    pszDefaultData   : If key found this is the default value, coule be NULL
    pcchCopied       : On success number of charaters copied is added
   *pbFail           : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    INFCONTEXT  InfContext;

    if ( *pbFail )
        return;

    if ( SetupFindFirstLine(hInf, pszDriverSection,
                            pszKey, &InfContext) ||
         (bDataSection && SetupFindFirstLine(hInf,
                                             pszDataSection,
                                             pszKey,
                                             &InfContext)) ) {

        InfGetString(&InfContext, 1, ppszData, pcchCopied, pbFail);
    } else if ( pszDefaultData && *pszDefaultData ) {

        if ( !(*ppszData = AllocStr(pszDefaultData)) )
            *pbFail = TRUE;
        else
            *pcchCopied += lstrlen(pszDefaultData) + 1;
    } else
        *ppszData = NULL;
}


VOID
InfGet2PartString(
    IN     HINF            hInf,
    IN     LPCTSTR         pszDriverSection,
    IN     LPCTSTR         pszDataSection, OPTIONAL
    IN     BOOL            bDataSection,
    IN     LPCTSTR         pszKey,
    OUT    LPTSTR         *ppszData,
    IN OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a 2 part string field from an inf file

Arguments:
    hInf             : Handle to the Inf file
    pszDriverSection : Section name for the driver
    pszDataSection   : Data section for the driver (optional)
    bDataSection     : Specifies if there is a data section
    pszKey           : Key value of the field to look for
   *ppszData         : Pointer to allocate memory and copy the data field
   *pbFail           : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    INFCONTEXT  InfContext;
    LPTSTR      psz   = NULL,
                psz2  = NULL;
    DWORD       dwLen = 0;

    if ( *pbFail )
        return;

    if ( SetupFindFirstLine(hInf, pszDriverSection,
                            pszKey, &InfContext) ||
         (bDataSection && SetupFindFirstLine(hInf,
                                             pszDriverSection = pszDataSection,
                                             pszKey,
                                             &InfContext)) ) {

        InfGetString(&InfContext, 1, ppszData, &dwLen, pbFail);

        if ( *pbFail || !*ppszData )
            return; //Success, field is NULL

        //
        // Usual case : field is of the form "Description,DLL-Name"
        //
        if ( psz = lstrchr(*ppszData, sComma) ) {

            *psz = sZero;
            return; // Success, field is not NULL
        } else {

            //
            // This is for the case "Description", DLL-Name
            //
            InfGetString(&InfContext, 2, &psz, &dwLen, pbFail);
            if ( *pbFail || !psz )
                goto Fail;

            dwLen = lstrlen(*ppszData) + lstrlen(psz) + 2;
            if ( psz2 = LocalAllocMem(dwLen * sizeof(*psz2)) ) {
                DWORD dwPos;

                StringCchCopy(psz2, dwLen, *ppszData);
                LocalFreeMem(*ppszData);
                *ppszData = psz2;

                dwPos = lstrlen(psz2) + 1;
                psz2 += dwPos;
                StringCchCopy(psz2, dwLen - dwPos, psz);
                LocalFreeMem(psz);
            } else
                goto Fail;
        }
    } else
        *ppszData = NULL;

    return;

Fail:
    LocalFreeMem(*ppszData);
    LocalFreeMem(psz);
    LocalFreeMem(psz2);

    *ppszData = NULL;
    *pbFail = TRUE;
    SetLastError(STG_E_UNKNOWN);
}


VOID
PSetupDestroyDriverInfo3(
    IN  LPDRIVER_INFO_3 pDriverInfo3
    )
/*++

Routine Description:
    Frees memory allocated for a DRIVER_INFO_3 structure and all the string
    fields in it, provided the DRIVER_INFO_3 structure was allocated using
    PSetupGetDriverInfo3.

Arguments:
    pDriverInfo3    : Pointer to the DRIVER_INFO_3 structure to free memory

Return Value:
    None

--*/
{
    LocalFreeMem(pDriverInfo3);
}


LPTSTR
PackString(
    IN  LPTSTR  pszEnd,
    IN  LPTSTR  pszSource,
    IN  LPTSTR *ppszTarget
    )
/*++

Routine Description:
    After parsing the INF the DRIVER_INFO_6 is packed in a buffer where the
    strings are at the end.

Arguments:
    pszEnd      : Pointer to the end of the buffer
    pszSource   : String to copy to the end of the buffer
    ppszTarget  : After copying the source to end of buffer this will receive
                  addess of the packed string

Return Value:
    New end of buffer

--*/
{
    if ( pszSource && *pszSource ) {

        pszEnd -= lstrlen(pszSource) + 1;
        StringCchCopy(pszEnd, lstrlen(pszSource) + 1, pszSource);
        *ppszTarget   = pszEnd;
    }

    return pszEnd;
}


LPTSTR
PackMultiSz(
    IN  LPTSTR  pszEnd,
    IN  LPTSTR  pszzSource,
    IN  LPTSTR *ppszzTarget
    )
/*++

Routine Description:
    After parsing the INF the DRIVER_INFO_6 is packed in a buffer where the
    strings are at the end.

Arguments:
    pszEnd      : Pointer to the end of the buffer
    pszSource   : Multi-sz field to copy to the end of the buffer
    ppszTarget  : After copying the source to end of buffer this will receive
                  addess of the packed multi-sz field

Return Value:
    New end of buffer

--*/
{
    size_t      dwLen = 0;
    LPTSTR      psz1, psz2;

    if ( (psz1 = pszzSource) != NULL && *psz1 ) {

        while ( *psz1 )
            psz1 += lstrlen(psz1) + 1;

        dwLen = (size_t)((psz1 - pszzSource) + 1);
    }

    if ( dwLen == 0 ) {

        *ppszzTarget = NULL;
        return pszEnd;
    }

    pszEnd -= dwLen;
    *ppszzTarget = pszEnd;
    CopyMemory((LPBYTE)pszEnd, (LPBYTE)pszzSource, dwLen * sizeof(TCHAR));

    return pszEnd;
}


VOID
PackDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  LPDRIVER_INFO_6 pTargetDriverInfo6,
    IN  DWORD           cbDriverInfo6
    )
/*++

Routine Description:
    Make a copy of a DRIVER_INFO_6 in a buffer where the strings are packed at
    end of the buffer.

Arguments:
    pSourceDriverInfo6  : The DRIVER_INFO_6 to make a copy
    pTargetDriverInfo6  : Points to a buffer to copy the pSourceDriverInfo6
    cbDriverInfo6       : Size of the buffer cbDriverInfo6, which is the size
                          needed for DRIVER_INFO_6 and the strings

Return Value:
    None

--*/
{
    LPTSTR              pszStr, pszStr2, pszMonitorDll;
    DWORD               dwLen = 0;

    // Copy over he couple non-string fields
    pTargetDriverInfo6->cVersion = pSourceDriverInfo6->cVersion;
    pTargetDriverInfo6->ftDriverDate = pSourceDriverInfo6->ftDriverDate;
    pTargetDriverInfo6->dwlDriverVersion = pSourceDriverInfo6->dwlDriverVersion;

    pszStr    = (LPTSTR)(((LPBYTE)pTargetDriverInfo6) + cbDriverInfo6);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pName,
                        &pTargetDriverInfo6->pName);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pDriverPath,
                        &pTargetDriverInfo6->pDriverPath);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pDataFile,
                        &pTargetDriverInfo6->pDataFile);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pConfigFile,
                        &pTargetDriverInfo6->pConfigFile);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pHelpFile,
                        &pTargetDriverInfo6->pHelpFile);

    //
    // Monitor dll is put right after the name
    // (ex. PJL Language monitor\0pjlmon.dd\0)
    //
    if ( pSourceDriverInfo6->pMonitorName ) {

        pszMonitorDll = pSourceDriverInfo6->pMonitorName
                            + lstrlen(pSourceDriverInfo6->pMonitorName) + 1;

        pszStr = PackString(pszStr,
                            pszMonitorDll,
                            &pszStr2);  // Don't care

        pszStr = PackString(pszStr,
                            pSourceDriverInfo6->pMonitorName,
                            &pTargetDriverInfo6->pMonitorName);

    }

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pDefaultDataType,
                        &pTargetDriverInfo6->pDefaultDataType);

    pszStr = PackMultiSz(pszStr,
                         pSourceDriverInfo6->pDependentFiles,
                         &pTargetDriverInfo6->pDependentFiles);

    pszStr = PackMultiSz(pszStr,
                         pSourceDriverInfo6->pszzPreviousNames,
                         &pTargetDriverInfo6->pszzPreviousNames);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszMfgName,
                         &pTargetDriverInfo6->pszMfgName);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszOEMUrl,
                         &pTargetDriverInfo6->pszOEMUrl);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszHardwareID,
                         &pTargetDriverInfo6->pszHardwareID);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszProvider,
                         &pTargetDriverInfo6->pszProvider);

    if ( pTargetDriverInfo6->pszProvider )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszProvider
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszHardwareID )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszHardwareID
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszOEMUrl )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszOEMUrl
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszMfgName )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszMfgName
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszzPreviousNames )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszzPreviousNames
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pDependentFiles )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pDependentFiles
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
}


LPDRIVER_INFO_6
CloneDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  DWORD           cbDriverInfo6
    )
/*++

Routine Description:
    Make a copy of a DRIVER_INFO_6 in a buffer where the strings are packed at
    end of the buffer.

Arguments:
    pSourceDriverInfo6  : The DRIVER_INFO_6 to make a copy
    cbDriverInfo6       : Size of the buffer cbDriverInfo6, which is the size
                          needed for DRIVER_INFO_6 and the strings

Return Value:
    A pointer to a DRIVER_INFO_6 structure identical to the one we passed it.

--*/
{
    LPDRIVER_INFO_6     pTargetDriverInfo6;
    LPTSTR              pszStr, pszStr2;
    DWORD               dwLen = 0;

    pTargetDriverInfo6 = (LPDRIVER_INFO_6) LocalAllocMem(cbDriverInfo6);

    if ( pTargetDriverInfo6 )
        PackDriverInfo6(pSourceDriverInfo6,
                        pTargetDriverInfo6,
                        cbDriverInfo6);

    return pTargetDriverInfo6;
}


VOID
InfGetVendorSetup(
    IN OUT  PPARSEINF_INFO      pInfInfo,
    IN      HINF                hInf,
    IN      LPTSTR              pszDriverSection,
    IN      LPTSTR              pszDataSection,
    IN      BOOL                bDataSection,
    IN OUT  LPBOOL              pbFail
    )
/*++

Routine Description:
    Get the VendorSetup field, if specified, from the INF

Arguments:
    pInfInfo            : This is where the parsed info from the INF is stored
    hInf                : INF handle
    pszDriverSection    : Gives the driver installation section
    pszDataSection      : Data section specified (optional) in driver install section
    bDataSection        : Tells if a data section is specified
    pbFail              : Set on error

Return Value:
    New end of buffer

--*/
{
    LPTSTR      p;
    DWORD       dwSize;
    TCHAR       szBuf[MAX_PATH];
    INFCONTEXT  InfContext;

    if ( *pbFail )
        return;

    //
    // If VendorSetup key is not found return; the key is optional
    //
    if ( !SetupFindFirstLine(hInf, pszDriverSection,
                             cszVendorSetup, &InfContext)   &&
         ( !bDataSection    ||
           !SetupFindFirstLine(hInf, pszDataSection,
                               cszVendorSetup, &InfContext)) ) {

        return;
    }

    if ( SetupGetLineText(&InfContext, hInf, NULL, NULL,
                          szBuf, SIZECHARS(szBuf), &dwSize) ) {

        if ( dwSize == 0 || szBuf[0] == TEXT('\0') )
            return;

        if ( !(pInfInfo->pszVendorSetup = AllocStr(szBuf)) )
            *pbFail = TRUE;

        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

        *pbFail = TRUE;
        return;
    }

    pInfInfo->pszVendorSetup = (LPTSTR) LocalAllocMem(dwSize * sizeof(TCHAR));
    if ( pInfInfo->pszVendorSetup &&
         SetupGetLineText(&InfContext, hInf, NULL, NULL,
                          pInfInfo->pszVendorSetup, dwSize, &dwSize) ) {

        return;
    }

    LocalFreeMem(pInfInfo->pszVendorSetup);
    pInfInfo->pszVendorSetup = NULL;

    *pbFail = TRUE;
}


VOID
InfGetPreviousNames(
    IN      HINF                hInf,
    IN      PSELECTED_DRV_INFO  pDrvInfo,
    IN OUT  LPDWORD             pcchCopied,
    IN OUT  LPBOOL              pbFail
    )
/*++

Routine Description:
    Gets the pszzPreviousNames field for the selected driver. This field is
    optional, and if specified gives previous names under which the driver was
    known

Arguments:
    hInf        : INF handle
    pDrvInfo    : Pointer to selected driver info
    pcchCopied  : Number of characters copied
    pbFail      : Set on failure

Return Value:
    None. On failure *pbFail is set

--*/
{
    INFCONTEXT      Context;

    if ( *pbFail )
        return;

    //
    // Previous names is optional; if not found we are done
    //
    if ( SetupFindFirstLine(hInf,
                            cszPreviousNamesSection,
                            pDrvInfo->pszModelName,
                            &Context) ) {

        pDrvInfo->Flags     |= SDFLAG_PREVNAME_SECTION_FOUND;
        InfGetMultiSz(&Context, 1, &pDrvInfo->pszzPreviousNames,
                      pcchCopied, pbFail);
    } else if ( GetLastError() != ERROR_LINE_NOT_FOUND )
        pDrvInfo->Flags     |= SDFLAG_PREVNAME_SECTION_FOUND;
}


VOID
InfGetOEMUrl(
    IN      HINF                hInf,
    IN      PSELECTED_DRV_INFO  pDrvInfo,
    IN OUT  LPBOOL              pbFail
    )
/*++

Routine Description:
    Gets the OEM URL Info for the selected driver. This field is optional

Arguments:
    hInf        : INF handle
    pDrvInfo    : Pointer to selected driver info
    pbFail      : Set on failure

Return Value:
    None. On failure *pbFail is set

--*/
{
    INFCONTEXT      Context;
    DWORD           dwDontCare = 0;

    if ( *pbFail )
        return;

    //
    // OEM URL is optional; if not found we are done
    //
    if ( SetupFindFirstLine(hInf,
                            cszOEMUrlSection,
                            pDrvInfo->pszManufacturer,
                            &Context) ) {

        InfGetString(&Context, 1, &pDrvInfo->pszOEMUrl, &dwDontCare, pbFail);
    }
}

BOOL
AddAllIncludedInf(
                 IN  HINF         hInf,
                 IN  LPTSTR       pszInstallSection,
                 IN  PLATFORM     platform,
                 IN  BOOL         bCrossPlatformAllowed
                 )

{
    INFCONTEXT INFContext;
    PINFCONTEXT pINFContext = &INFContext;
    DWORD dwBufferNeeded;
    BOOL bRet = TRUE;

    if ( SetupFindFirstLine(  hInf, pszInstallSection, TEXT( "Include" ), pINFContext ) )
    {
        // Find each INF and load it & it's LAYOUT files
        DWORD dwINFs = SetupGetFieldCount( pINFContext );
        DWORD dwIndex;

        //
        // We cannot install a driver for a different platform than the current
        // machine if the inf file of the driver uses include/needs. This would
        // lead to problems with verifying the driver signature. The reason is that
        // we do not keeps infs and cat-files of different architectures on the local
        // machine.
        // Since driver signing is somewhat broken when installing a Win95 driver
        // we ignore this problem for these drivers.
        //
       if ((!bCrossPlatformAllowed) && (platform != MyPlatform) && (platform != PlatformWin95))
        {
            bRet = FALSE;
            SetLastError(ERROR_INSTALL_PLATFORM_UNSUPPORTED);
            goto Cleanup;
        }


        for ( dwIndex = 1; dwIndex <= dwINFs; dwIndex++ )
        {
            if ( SetupGetStringField(  pINFContext, dwIndex, NULL, 0, &dwBufferNeeded ) )
            {
                PTSTR pszINFName = (PTSTR) LocalAllocMem( dwBufferNeeded * sizeof(TCHAR) );
                if ( pszINFName )
                {
                    if ( SetupGetStringField(  pINFContext, dwIndex, pszINFName, dwBufferNeeded, &dwBufferNeeded ) )
                    {
                        //
                        // Open INF file and append layout.inf specified in Version section
                        // Layout inf is optional
                        //
                        SetupOpenAppendInfFile( pszINFName, hInf, NULL);
                        SetupOpenAppendInfFile( NULL, hInf, NULL);
                    }  // Got an INF Name

                    LocalFreeMem( pszINFName );
                    pszINFName = NULL;
                }  // Allocated pszINFName
            }  // Got the Field from the INF Line
        }  // Process all INFs in the Include Line
    }  // Found an Include= Line

    Cleanup:

    return bRet;

}

BOOL
InstallAllInfSections(
   IN  PPSETUP_LOCAL_DATA  pLocalData,
   IN  PLATFORM            platform,
   IN  LPCTSTR             pszServerName,
   IN  HSPFILEQ            CopyQueue,
   IN  LPCTSTR             pszSource,
   IN  DWORD               dwInstallFlags,
   IN  HINF                hInf,
   IN  LPCTSTR             pszInstallSection
   )

{
   BOOL         bRet = FALSE;
   HINF hIncludeInf;
   INFCONTEXT INFContext;
   PINFCONTEXT pINFContext = &INFContext;
   INFCONTEXT NeedsContext;
   PINFCONTEXT pNeedsContext = &NeedsContext;
   DWORD dwBufferNeeded;
   PTSTR pszINFName = NULL;
   PTSTR pszSectionName = NULL;

   if ( CopyQueue == INVALID_HANDLE_VALUE              ||
        !SetTargetDirectories( pLocalData,
                               platform,
                               pszServerName,
                               hInf,
                               dwInstallFlags ) ||
        !SetupInstallFilesFromInfSection(
                       hInf,
                       NULL,
                       CopyQueue,
                       pszInstallSection,
                       pszSource,
                       SP_COPY_LANGUAGEAWARE) )
       goto Cleanup;

   // To get the source directories correct, we need to load all included INFs
   //  separately. THen use their associated layout files.
   if ( SetupFindFirstLine(  hInf, pszInstallSection, TEXT( "Include" ), pINFContext ) )
   {
      // Find each INF and load it & it's LAYOUT files
      DWORD dwINFs = SetupGetFieldCount( pINFContext );
      DWORD dwIIndex;

      for ( dwIIndex = 1; dwIIndex <= dwINFs; dwIIndex++ )
      {
         if ( SetupGetStringField(  pINFContext, dwIIndex, NULL, 0, &dwBufferNeeded ) )
         {
            pszINFName = (PTSTR) LocalAllocMem( dwBufferNeeded * sizeof(TCHAR) );
            if ( pszINFName )
            {
               if ( SetupGetStringField(  pINFContext, dwIIndex, pszINFName, dwBufferNeeded, &dwBufferNeeded ) )
               {
                  //
                  // Open INF file and append layout.inf specified in Version section
                  // Layout inf is optional
                  //
                  // SetupOpenAppendInfFile( pszINFName, hPrinterInf, NULL);
                  hIncludeInf = SetupOpenInfFile(pszINFName,
                                                 NULL,
                                                 INF_STYLE_WIN4,
                                                 NULL);

                  if ( hIncludeInf == INVALID_HANDLE_VALUE )
                      goto Cleanup;
                  SetupOpenAppendInfFile( NULL, hIncludeInf, NULL);

                  // Now process all need sections for this INF
                  // Now find the Needs Line and install all called sections
                  if ( SetupFindFirstLine(  hInf, pszInstallSection, TEXT( "needs" ), pNeedsContext ) )
                  {
                     // Find each INF and load it & it's LAYOUT files
                     DWORD dwSections = SetupGetFieldCount( pNeedsContext );
                     DWORD dwNIndex;

                     for ( dwNIndex = 1; dwNIndex <= dwSections; dwNIndex++ )
                     {
                        if ( SetupGetStringField(  pNeedsContext, dwNIndex, NULL, 0, &dwBufferNeeded ) )
                        {
                           pszSectionName = (PTSTR) LocalAllocMem( dwBufferNeeded * sizeof(TCHAR) );
                           if ( pszSectionName )
                           {
                              if ( SetupGetStringField(  pNeedsContext, dwNIndex, pszSectionName, dwBufferNeeded, &dwBufferNeeded ) )
                              {
                                 if ( SetTargetDirectories(pLocalData,
                                                           platform,
                                                           pszServerName,
                                                           hIncludeInf,
                                                           dwInstallFlags) )
                                 {
                                    if ( !SetupInstallFilesFromInfSection(
                                                   hIncludeInf,
                                                   NULL,
                                                   CopyQueue,
                                                   pszSectionName,
                                                   NULL,
                                                   SP_COPY_LANGUAGEAWARE) )
                                       goto Cleanup;
                                 }  //  Able to setup Target Dirs
                                 else
                                    goto Cleanup;
                              }  // Got a Section Name

                              LocalFreeMem( pszSectionName );
                              pszSectionName = NULL;
                           }  // Allocated pszSectionName
                        }  // Got the Field from the Section Line
                     }  // Process all Sections in the Needs Line
                  }  // Found a Needs= Line

                  // Close included INF
                  if ( hIncludeInf != INVALID_HANDLE_VALUE )
                      SetupCloseInfFile(hIncludeInf);
               }  // Got an INF Name

               LocalFreeMem( pszINFName );
               pszINFName = NULL;
            }  // Allocated pszINFName
         }  // Got the Field from the INF Line
      }  // Process all INFs in the Include Line
   }  // Found an Include= Line

   bRet = TRUE;

Cleanup:
   if ( pszINFName )
      LocalFreeMem( pszINFName );

   if ( pszSectionName )
      LocalFreeMem( pszSectionName );

   return bRet;
}


BOOL
ParseInf(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags,
    IN      BOOL                bCrossPlatformAllowed
    )
/*++

Routine Description:
    Copies driver information from an Inf file to a DriverInfo3 structure.

    The following fields are filled on successful return
            pName
            pDriverPath
            pDataFile
            pConfigFile
            pHelpFile
            pMonitorName
            pDefaultDataType

Arguments:
    pLocalData      :
    platform        : Platform for which inf should be parsed

Return Value:
    TRUE    -- Succesfully parsed the inf and built info for the selected driver
    FALSE   -- On Error

--*/
{
    PPARSEINF_INFO      pInfInfo = &pLocalData->InfInfo;
    PDRIVER_INFO_6      pDriverInfo6 = &pLocalData->InfInfo.DriverInfo6;
    LPTSTR              pszDataSection, psz, pszInstallSection;
    BOOL                bWin95 = platform == PlatformWin95,
                        bFail = TRUE, bDataSection = FALSE;
    INFCONTEXT          Context;
    DWORD               cchDriverInfo6, dwNeeded, dwDontCare;
    HINF                hInf;

    //
    // Check if INF is already parsed, and if so for the right platform
    //
    if ( pLocalData->Flags & VALID_INF_INFO ) {

        if ( platform == pInfInfo->platform )
            return TRUE;

        FreeStructurePointers((LPBYTE)pInfInfo, InfInfoOffsets, FALSE);
        pLocalData->Flags   &= ~VALID_INF_INFO;
        ZeroMemory(pInfInfo, sizeof(*pInfInfo));
    }

    pszDataSection  = NULL;

    hInf = SetupOpenInfFile(pLocalData->DrvInfo.pszInfName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if ( hInf == INVALID_HANDLE_VALUE )
        goto Cleanup;

    if ( bWin95 ) {

        pszInstallSection = AllocStr(pLocalData->DrvInfo.pszDriverSection);
        if ( !pszInstallSection )
            goto Cleanup;
    } else {

        //
        //  Platform and ProcessorArchitecture only fields that are checked.
        //

        SP_ALTPLATFORM_INFO AltPlat_Info = {0};

        AltPlat_Info.cbSize                     = sizeof(SP_ALTPLATFORM_INFO);
        AltPlat_Info.Platform                   = PlatformArch[ platform ][OS_PLATFORM];
        AltPlat_Info.ProcessorArchitecture      = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];

        if ( !SetupDiGetActualSectionToInstallEx(
                            hInf,
                            pLocalData->DrvInfo.pszDriverSection,
                            &AltPlat_Info,
                            NULL,
                            0,
                            &dwNeeded,
                            NULL,
                            NULL)                                               ||
            !(pInfInfo->pszInstallSection
                        = (LPTSTR) LocalAllocMem(dwNeeded * sizeof(TCHAR)))          ||
            !SetupDiGetActualSectionToInstallEx(
                            hInf,
                            pLocalData->DrvInfo.pszDriverSection,
                            &AltPlat_Info,
                            pInfInfo->pszInstallSection,
                            dwNeeded,
                            NULL,
                            NULL,
                            NULL) ) {

            goto Cleanup;
        }
        
        pszInstallSection = pInfInfo->pszInstallSection;
    }

    //
    // Now load all other INFs referenced in the Install Section
    //
    if(!AddAllIncludedInf( hInf, pszInstallSection, platform, bCrossPlatformAllowed))
    {
        goto Cleanup;
    }

    if ( !(pDriverInfo6->pName = AllocStr(pLocalData->DrvInfo.pszModelName)) )
        goto Cleanup;

    bFail = FALSE;

    if(bFail)
    {
        goto Cleanup;
    }

    //
    // Does the driver section have a data section name specified?
    //
    if ( SetupFindFirstLine(hInf, pszInstallSection,
                            cszDataSection, &Context) ) {

        InfGetString(&Context, 1, &pszDataSection, &dwDontCare, &bFail);
        bDataSection = TRUE;
    }

    cchDriverInfo6 = lstrlen(pDriverInfo6->pName) + 1;

    //
    // If DataFile key is not found data file is same as driver section name
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszDataFile,
                           &pDriverInfo6->pDataFile,
                           pszInstallSection,
                           &cchDriverInfo6,
                           &bFail);

    //
    // If DriverFile key is not found driver file is the driver section name
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszDriverFile,
                           &pDriverInfo6->pDriverPath,
                           pszInstallSection,
                           &cchDriverInfo6,
                           &bFail);

    //
    // If ConfigFile key is not found config file is same as driver file
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszConfigFile,
                           &pDriverInfo6->pConfigFile,
                           pDriverInfo6->pDriverPath,
                           &cchDriverInfo6,
                           &bFail);

    //
    // Help file is optional, and by default NULL
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszHelpFile,
                           &pDriverInfo6->pHelpFile,
                           NULL,
                           &cchDriverInfo6,
                           &bFail);

    //
    // Monitor name is optional, and by default none
    //
    InfGet2PartString(hInf,
                      pszInstallSection,
                      pszDataSection,
                      bDataSection,
                      cszLanguageMonitor,
                      &pDriverInfo6->pMonitorName,
                      &bFail);

    if ( psz = pDriverInfo6->pMonitorName ) {

        psz += lstrlen(psz) + 1;
        cchDriverInfo6 += lstrlen(pDriverInfo6->pMonitorName) + lstrlen(psz) + 2;
    }

    //
    // Print processor is optional, and by default none
    //
    InfGet2PartString(hInf,
                      pszInstallSection,
                      pszDataSection,
                      bDataSection,
                      cszPrintProcessor,
                      &pLocalData->InfInfo.pszPrintProc,
                      &bFail);

    //
    // Default data type is optional, and by default none
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszDefaultDataType,
                           &pDriverInfo6->pDefaultDataType,
                           NULL,
                           &cchDriverInfo6,
                           &bFail);

    //
    // Vendor setup is optional, and by default none
    //
    InfGetVendorSetup(pInfInfo,
                      hInf,
                      pszInstallSection,
                      pszDataSection,
                      bDataSection,
                      &bFail);

    bFail =  bFail || !InfGetDependentFilesAndICMFiles(hDevInfo,
                                              hInf,
                                              bWin95,
                                              pLocalData,
                                              platform,
                                              pszServerName,
                                              dwInstallFlags,
                                              pszInstallSection,
                                              &cchDriverInfo6);
    if ( !bWin95 ) {

        InfGetPreviousNames(hInf,
                            &pLocalData->DrvInfo,
                            &cchDriverInfo6,
                            &bFail);

        InfGetOEMUrl(hInf,
                     &pLocalData->DrvInfo,
                     &bFail);
    }

Cleanup:

    //
    // Save the last error is we've failed.  SetupCloseInfFile can change the last error and we
    // don't care about it's last error in any way.
    //
    if( bFail ) {

        dwDontCare = GetLastError();
    }

    LocalFreeMem(pszDataSection);

    if ( hInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(hInf);

    //
    // On failure free all the fields filled by this routine
    //
    if ( bFail ) {

        FreeStructurePointers((LPBYTE)pInfInfo, InfInfoOffsets, FALSE);
        ZeroMemory(pInfInfo, sizeof(*pInfInfo));
        SetLastError( dwDontCare );

    } else {

        // Point members of DriverInfo6 to strings in pDrvInfo
        pInfInfo->DriverInfo6.pszzPreviousNames          = pLocalData->DrvInfo.pszzPreviousNames;

        pLocalData->InfInfo.DriverInfo6.pszMfgName       = pLocalData->DrvInfo.pszManufacturer;
        if ( pLocalData->InfInfo.DriverInfo6.pszMfgName )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszMfgName ) + 1 );

        pLocalData->InfInfo.DriverInfo6.pszOEMUrl        = pLocalData->DrvInfo.pszOEMUrl;
        if ( pLocalData->InfInfo.DriverInfo6.pszOEMUrl )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszOEMUrl ) + 1 );

        pLocalData->InfInfo.DriverInfo6.pszHardwareID    = pLocalData->DrvInfo.pszHardwareID;
        if ( pLocalData->InfInfo.DriverInfo6.pszHardwareID )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszHardwareID ) + 1 );

        pLocalData->InfInfo.DriverInfo6.pszProvider      = pLocalData->DrvInfo.pszProvider;
        if ( pLocalData->InfInfo.DriverInfo6.pszProvider )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszProvider ) + 1 );

        pLocalData->InfInfo.DriverInfo6.ftDriverDate     = pLocalData->DrvInfo.ftDriverDate;
        pLocalData->InfInfo.DriverInfo6.dwlDriverVersion = pLocalData->DrvInfo.dwlDriverVersion;

        pInfInfo->cbDriverInfo6 = sizeof(DRIVER_INFO_6) +
                                    cchDriverInfo6 * sizeof(TCHAR);

        pLocalData->Flags  |= VALID_INF_INFO;
        pInfInfo->platform  = platform;
    }

    return !bFail;
}


LPDRIVER_INFO_6
GetDriverInfo6(
    IN  PSELECTED_DRV_INFO  pSelectedDrvInfo
    )
/*++

Routine Description:
    Gets the selected drivers information in a DRIVER_INFO_6 structure.

Arguments:

Return Value:
    Pointer to the DRIVER_INFO_6 structure. Memory is allocated for it.

--*/
{
    HINF                 hInf;
    PPSETUP_LOCAL_DATA   LocalData    = NULL;
    LPDRIVER_INFO_6      pDriverInfo6 = NULL;
    HDEVINFO             hDevInfo     = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS DiParams     = {0};

    if ( !pSelectedDrvInfo                      ||
         !pSelectedDrvInfo->pszInfName          ||
         !*pSelectedDrvInfo->pszInfName         ||
         !pSelectedDrvInfo->pszModelName        ||
         !*pSelectedDrvInfo->pszModelName       ||
         !pSelectedDrvInfo->pszDriverSection    ||
         !*pSelectedDrvInfo->pszDriverSection ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if(INVALID_HANDLE_VALUE == (hDevInfo = CreatePrinterDeviceInfoList(NULL)))
    {
        goto Cleanup;
    }

    DiParams.cbSize = sizeof(DiParams);
    if (!SetupDiGetDeviceInstallParams(hDevInfo, NULL, &DiParams))
    {
        goto Cleanup;
    }

    StringCchCopy(DiParams.DriverPath, COUNTOF(DiParams.DriverPath), pSelectedDrvInfo->pszInfName);
    
    DiParams.Flags |= DI_ENUMSINGLEINF; 

    if (!SetupDiSetDeviceInstallParams(hDevInfo, NULL, &DiParams))
    {
        goto Cleanup;
    }

    LocalData = PSetupDriverInfoFromName(hDevInfo, pSelectedDrvInfo->pszModelName);
    if (!LocalData)
    {
        goto Cleanup;
    }

    if ( ParseInf(hDevInfo, LocalData, MyPlatform, NULL, 0, FALSE) ) {

        pDriverInfo6 = CloneDriverInfo6(&(LocalData->InfInfo.DriverInfo6),
                                        LocalData->InfInfo.cbDriverInfo6);
    }

Cleanup:
    DestroyOnlyPrinterDeviceInfoList(hDevInfo);
    DestroyLocalData( LocalData );

    return pDriverInfo6;
}


LPDRIVER_INFO_3
PSetupGetDriverInfo3(
    IN  PSELECTED_DRV_INFO  pSelectedDrvInfo
    )
/*++

Routine Description:
    Gets the selected drivers information in a DRIVER_INFO_3 structure.
    The memory is allocated with one call to LocalAlloc.

Arguments:

Return Value:
    Pointer to the DRIVER_INFO_3 structure. Memory is allocated for it.

--*/
{
    return (LPDRIVER_INFO_3) GetDriverInfo6(pSelectedDrvInfo);
}

LPTSTR
GetStringFromRcFile(
    UINT    uId
    )
/*++

Routine Description:
    Load a string from the .rc file and make a copy of it by doing AllocStr

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    TCHAR    buffer[MAX_SETUP_LEN];
    int      RetVal = 0;

    RetVal = LoadString(ghInst, uId, buffer, SIZECHARS(buffer));

    if ( RetVal )
    {
        return AllocStr(buffer);
    }
    else
    {
        return NULL;
    }
}

LPTSTR
GetLongStringFromRcFile(
    UINT    uId
    )
/*++

Routine Description:
    Load a long string from the .rc file, up to MAX_SETUP_ALLOC_STRING_LEN characters

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    LPTSTR   pBuf = NULL;
    int    Retry = 0, RetVal;

    //
    // I couldn't find a way to determine the length of a string the resource file, hence
    // I just try until the length returned by LoadString is smaller than the buffer I passed in
    //
    for (Retry = 1; Retry <= MAX_SETUP_ALLOC_STRING_LEN/MAX_SETUP_LEN; Retry++)
    {
        int CurrentSize = Retry * MAX_SETUP_LEN;

        pBuf = LocalAllocMem(CurrentSize * sizeof(TCHAR));
        if (!pBuf)
        {
            return NULL;
        }

        RetVal = LoadString(ghInst, uId, pBuf, CurrentSize);

        if (RetVal == 0)
        {
            LocalFreeMem(pBuf);
            return NULL;
        }

        if (RetVal < CurrentSize -1) // -1 because the LoadString ret value doesn't include the termination
        {
            return pBuf;
        }

        //
        // RetVal is CurrentSize - retry
        //
        LocalFreeMem(pBuf);
    }

    return NULL;
}

BOOL
PSetupGetPathToSearch(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszTitle,
    IN      LPCTSTR     pszDiskName,
    IN      LPCTSTR     pszFileName,
    IN      BOOL        bPromptForInf,
    IN OUT  TCHAR       szPath[MAX_PATH]
    )
/*++

Routine Description:
    Get path to search for some files by prompting the user

Arguments:
    hwnd            : Window handle of current top-level window
    pszTitle        : Title for the UI
    pszDiskName     : Diskname ot prompt the user
    pszFileName     : Name of the file we are looking for (NULL ok)
    pszPath         : Buffer to get the path entered by the user

Return Value:
    TRUE    on succesfully getting a path from user
    FALSE   else, Do GetLastError() to get the error

--*/
{
    DWORD   dwReturn, dwNeeded;

    dwReturn = SetupPromptForDisk(hwnd,
                                  pszTitle,
                                  pszDiskName,
                                  szPath[0] ? szPath : NULL,
                                  pszFileName,
                                  NULL,
                                  bPromptForInf ?
                                        (IDF_NOSKIP | IDF_NOBEEP | IDF_NOREMOVABLEMEDIAPROMPT | IDF_USEDISKNAMEASPROMPT) :
                                        (IDF_NOSKIP | IDF_NOBEEP),
                                  szPath,
                                  MAX_PATH,
                                  &dwNeeded);

    if ( dwReturn == DPROMPT_SUCCESS ) {

        //
        // Remove this from source list so that next time we are looking for
        // native drivers we do not end up picking from wrong source
        //
        SetupRemoveFromSourceList(SRCLIST_SYSIFADMIN, szPath);

        //
        // Terminate with a \ at the end
        //
        dwNeeded = lstrlen(szPath);
        if ( *(szPath + dwNeeded - 1) != TEXT('\\') &&
             dwNeeded < MAX_PATH - 2 ) {

            *(szPath + dwNeeded) = TEXT('\\');
            *(szPath + dwNeeded + 1) = sZero;
        }

        return TRUE;
    }

    if ( dwReturn == DPROMPT_OUTOFMEMORY ||
         dwReturn == DPROMPT_BUFFERTOOSMALL ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    } else {

        SetLastError(ERROR_CANCELLED);
    }

    return FALSE;
}



INT
IsDifferent(
    LPTSTR  p1,
    LPTSTR  p2,
    DWORD   (*pfn)(LPTSTR, LPTSTR)
    )
/*++

Routine Description:
    Extended version of strcmp/memcmp kind of function. Treats NULL pointer and
    the pointer to NULL as a match. For other cases call function passed in.

Arguments:
    p1      : First address to compare
    p2      : Second address to compare
    pfn     : Function to call if both p1 and p2 are non-NULL

Return Value:
    + means p1 > p2 (like how memcmp or strcmp defines), - means p1 < p2.
    0 if the values match

--*/
{
    //
    // We want to treat NULL ptr and ptr to NULL as the same thing
    //
    if ( p1 && !*p1 )
        p1 = NULL;

    if ( p2 && !*p2 )
        p2 = NULL;

    //
    // If both are NULL then they match
    //
    if ( !p1 && !p2 )
        return 0;

    //
    // Both are non NULL
    //
    if ( p1 && p2 )
        return pfn(p1, p2);

    //
    // One of them is NULL
    //
    if ( p1 )
        return 1;
    else
        return -1;
}


LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    )
/*++

Routine Description:
    Find the file name part of a fully qualified file name

Arguments:
    pszFullName : Fully qualified path to the file

Return Value:
    Pointer to the filename part in the fully qulaified string

--*/
{
    LPTSTR pszSlash, pszTemp;

    if ( !pszFullName )
        return NULL;

    //
    // First find the : for the drive
    //
    if ( pszTemp = lstrchr(pszFullName, TEXT(':')) )
        pszFullName = pszFullName + 1;

    for ( pszTemp = (LPTSTR)pszFullName ;
          pszSlash = lstrchr(pszTemp, TEXT('\\')) ;
          pszTemp = pszSlash + 1 )
    ;

    return *pszTemp ? pszTemp : NULL;

}

BOOL
IdenticalDriverInfo6(
    IN  LPDRIVER_INFO_6 p1,
    IN  LPDRIVER_INFO_6 p2
    )
/*++

Routine Description:
    Checks if DRIVER_INFO_6 are the same

Arguments:
    p1  : DRIVER_INFO_6 from the INF
    p2  : DRIVER_INFO_6 returned by the spooler

Return Value:
    TRUE if the DRIVER_INFO_6s are identical, FALSE else

--*/
{
    LPTSTR  psz;

    return (p1->dwlDriverVersion == (DWORDLONG)0    ||
            p2->dwlDriverVersion == (DWORDLONG)0    ||
            p1->dwlDriverVersion == p2->dwlDriverVersion)               &&
           !lstrcmpi(p1->pName, p2->pName)                              &&
            (psz = FileNamePart(p2->pDriverPath))                       &&
           !lstrcmpi(p1->pDriverPath, psz)                              &&
            (psz = FileNamePart(p2->pDataFile))                         &&
           !lstrcmpi(p1->pDataFile, psz)                                &&
            (psz = FileNamePart(p2->pConfigFile))                       &&
           !lstrcmpi(p1->pConfigFile, psz)                              &&
           !IsDifferent(p1->pHelpFile,
                        FileNamePart(p2->pHelpFile),
                        lstrcmpi)                                       &&
           !IsDifferent(p1->pMonitorName,
                        p2->pMonitorName,
                        lstrcmpi);

/*

    We changed the way we find dependent files from NT4 to NT5.
    So we do not want to look at them while deciding if a driver came from
    an INF.

           !IsDifferent(p1->pDefaultDataType,
                        p2->pDefaultDataType,
                        lstrcmpi);
           SameMultiSz(p1->pDependentFiles, p2->pDependentFiles, TRUE)  &&
           SameMultiSz(p1->pszzPreviousNames, p2->pszzPreviousNames, FALSE);
*/
}


BOOL
AllICMFilesInstalled(
    IN  LPCTSTR     pszServerName,
    IN  LPTSTR      pszzICMFiles
    )
/*++

Routine Description:
    Checks if all the icm files given are installed on the specified machine

Arguments:
    pszServerName   : Name of the server
    pszzICMFiles    : Multi-sz field giving all the ICM files

Return Value:
    TRUE if all the ICM profiles are installed on the server, FALSE else

--*/
{
    BOOL        bRet = FALSE;
    LPBYTE      buf = NULL;
    LPTSTR      p1, p2;
    DWORD       dwNeeded, dwReturned;
    ENUMTYPE    EnumType;

    if ( !pszzICMFiles || !*pszzICMFiles )
        return TRUE;

    //
    // ICM apis are not remotablr for now
    //
    if ( pszServerName )
        goto Cleanup;

    ZeroMemory(&EnumType, sizeof(EnumType));
    EnumType.dwSize     = sizeof(EnumType);
    EnumType.dwVersion  = ENUM_TYPE_VERSION;

    //
    // Get all the color profiles installed on the machine
    //
    dwNeeded = 0;
    if ( EnumColorProfiles((LPTSTR)pszServerName,
                           &EnumType,
                           NULL,
                           &dwNeeded,
                           &dwReturned) ||
         GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(buf = LocalAllocMem(dwNeeded))                    ||
         !EnumColorProfiles((LPTSTR)pszServerName,
                            &EnumType,
                            buf,
                            &dwNeeded,
                            &dwReturned) ) {

        goto Cleanup;
    }

    for ( p1 = pszzICMFiles ; *p1 ; p1 += lstrlen(p1) + 1 ) {

        for ( p2 = (LPTSTR)buf, dwNeeded = 0 ;
              dwNeeded < dwReturned && *p2 && lstrcmpi(p1, p2) ;
              ++dwNeeded, p2 += lstrlen(p2) + 1 )
        ;

        //
        // Did we find p1 in the enumerated color profiles?
        //
        if ( dwNeeded == dwReturned )
            goto Cleanup;
    }

    bRet = TRUE;

Cleanup:
    LocalFreeMem(buf);

    return bRet;
}


BOOL
CorrectVersionDriverFound(
    IN  LPDRIVER_INFO_2 pDriverInfo2,
    IN  DWORD           dwCount,
    IN  LPCTSTR         pszDriverName,
    IN  DWORD           dwMajorVersion
    )
/*++

Routine Description:
    Check if the correct version driver we are looking for is found in the list
    we got from spooler

Arguments:
    pDriverInfo2    : Points to the buffer of DRIVER_INFO_2 structs
    dwCount         : Number of DRIVER_INFO_2 elements in the buffer
    szDriverName    : Driver name
    dwMajorVersion  : Version no

Return Value:
    TRUE if driver is found in the lise, FALSE else

--*/
{
    DWORD   dwIndex;

    for ( dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex, ++pDriverInfo2 ) {

        //
        // Check if the driver is for the correct version
        //
        if ( dwMajorVersion != KERNEL_MODE_DRIVER_VERSION   &&
             dwMajorVersion != pDriverInfo2->cVersion )
            continue;

        if ( dwMajorVersion == KERNEL_MODE_DRIVER_VERSION   &&
             pDriverInfo2->cVersion < 2 )
            continue;

        if ( !lstrcmpi(pDriverInfo2->pName, pszDriverName) )
            return TRUE;
    }

    return FALSE;
}


BOOL
PSetupIsDriverInstalled(
    IN LPCTSTR      pszServerName,
    IN LPCTSTR      pszDriverName,
    IN PLATFORM     platform,
    IN DWORD        dwMajorVersion
    )
/*++

Routine Description:
    Finds out if a particular version of a printer driver is already installed
    in the system by querying spooler

Arguments:
    pszServerName   : Server name (NULL for local)
    pszDriverName    : Driver name
    platform        : platform for which we want to check the driver
    dwMajorVersion  : Version no

Return Value:
    TRUE if driver is installed,
    FALSE else (on error too)

--*/
{
    BOOL                bReturn = FALSE;
    DWORD               dwReturned, dwNeeded = 1024, dwReturned2;
    LPBYTE              p = NULL, p2 = NULL;
    LPTSTR              psz;
    LPDRIVER_INFO_6     pDriverInfo6;
    LPTSTR              pszServerArchitecture = NULL;

    if ( !(p = LocalAllocMem(dwNeeded)) )
        goto Cleanup;

    if ( !EnumPrinterDrivers((LPTSTR)pszServerName,
                             PlatformEnv[platform].pszName,
                             2,
                             p,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned) ) {

        LocalFreeMem(p);
        p = NULL;

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER        ||
             !(p = LocalAllocMem(dwNeeded))                          ||
             !EnumPrinterDrivers((LPTSTR)pszServerName,
                                 PlatformEnv[platform].pszName,
                                 2,
                                 p,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned) ) {

            goto Cleanup;
        }
    }

    bReturn = CorrectVersionDriverFound((LPDRIVER_INFO_2)p,
                                        dwReturned,
                                        pszDriverName,
                                        dwMajorVersion);

    //
    // Win95 drivers could have a different name than NT driver
    //
    if ( bReturn || platform != PlatformWin95 )
        goto Cleanup;

    dwNeeded = 1024;
    if ( !(p2 = LocalAllocMem(dwNeeded)) )
        goto Cleanup;

    pszServerArchitecture = GetArchitectureName( (LPTSTR)pszServerName );
    if (!pszServerArchitecture)
    {
        goto Cleanup;
    }

    if ( !EnumPrinterDrivers((LPTSTR)pszServerName,
                             pszServerArchitecture,
                             6,
                             p2,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned2) ) {

        LocalFreeMem(p2);
        p2 = NULL;

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER        ||
             !(p2 = LocalAllocMem(dwNeeded))                         ||
             !EnumPrinterDrivers((LPTSTR)pszServerName,
                                 pszServerArchitecture,
                                 6,
                                 p2,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned2) )
            goto Cleanup;
    }

    for ( dwNeeded = 0, pDriverInfo6 = (LPDRIVER_INFO_6)p2 ;
          dwNeeded < dwReturned2 ;
          ++pDriverInfo6, ++dwNeeded ) {

        if ( pDriverInfo6->cVersion < 2 )
            continue;

        if ( !lstrcmpi(pDriverInfo6->pName, pszDriverName) )
            break;
    }

    if ( dwNeeded < dwReturned2 && (psz = pDriverInfo6->pszzPreviousNames) )
        while ( *psz ) {

            if ( bReturn = CorrectVersionDriverFound((LPDRIVER_INFO_2)p,
                                                     dwReturned,
                                                     psz,
                                                     dwMajorVersion) )
                break;

            psz += lstrlen(psz) + 1;
        }

Cleanup:
    LocalFreeMem(p);
    LocalFreeMem(p2);
    LocalFreeMem( pszServerArchitecture );

    return bReturn;
}


INT
PSetupIsTheDriverFoundInInfInstalled(
    IN  LPCTSTR             pszServerName,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwMajorVersion
    )
/*++
Routine Description:
    Finds out if a particular version of a printer driver is already installed
    in the system by querying spooler; Additionally check if the installed
    driver is the same found in the INF (file name matches only)

Arguments:
    pszServerName   : Server name (NULL for local)
    szDriverName    : Driver name
    platform        : platform for which we want to check the driver
    dwMajorVersion  : Version no;
                      If KERNEL_MODE_DRIVER_VERSION check for a KM driver

Return Value:
    DRIVER_MODEL_INSTALLED_AND_IDENTICAL :
        if driver is installed and all files are identical
    DRIVER_MODEL_NOT_INSTALLED :
       if a driver with the given model name is not available
    DRIVER_MODEL_INSTALLED_BUT_DIFFERENT :
       a driver with the given model name is installed but not all files
       are identical

--*/
{
    INT             iRet           = DRIVER_MODEL_NOT_INSTALLED;
    DWORD           dwReturned,
                    dwNeeded,
                    dwLastError;
    LPBYTE          p              = NULL;
    LPDRIVER_INFO_6 p1DriverInfo6,
                    p2DriverInfo6;
    HDEVINFO        hDevInfo       = INVALID_HANDLE_VALUE;

    ASSERT(pLocalData && pLocalData->signature == PSETUP_SIGNATURE);

    if(INVALID_HANDLE_VALUE == (hDevInfo = CreatePrinterDeviceInfoList(NULL)))
    {
        goto Cleanup;
    }

    if ( !ParseInf(hDevInfo, pLocalData, platform, pszServerName, 0, TRUE) )
        goto Cleanup;

    p1DriverInfo6 = &pLocalData->InfInfo.DriverInfo6;

    if ( EnumPrinterDrivers((LPTSTR)pszServerName,
                             PlatformEnv[platform].pszName,
                             6,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned) ) {

        goto Cleanup;
    }

    if ( (dwLastError = GetLastError()) == ERROR_INVALID_LEVEL ) {

        iRet = PSetupIsDriverInstalled(pszServerName,
                                       p1DriverInfo6->pName,
                                       platform,
                                       dwMajorVersion)
                        ? DRIVER_MODEL_INSTALLED_BUT_DIFFERENT
                        : DRIVER_MODEL_NOT_INSTALLED;
        goto Cleanup;
    }

    if ( dwLastError != ERROR_INSUFFICIENT_BUFFER   ||
         !(p = LocalAllocMem(dwNeeded))                  ||
         !EnumPrinterDrivers((LPTSTR)pszServerName,
                             PlatformEnv[platform].pszName,
                             6,
                             p,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned) ) {

        goto Cleanup;
    }

    for ( dwNeeded = 0, p2DriverInfo6 = (LPDRIVER_INFO_6) p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, (LPBYTE) p2DriverInfo6 += sizeof(DRIVER_INFO_6) ) {

        //
        // Check if the driver is for the correct version
        //
        if ( dwMajorVersion != KERNEL_MODE_DRIVER_VERSION   &&
             dwMajorVersion != p2DriverInfo6->cVersion )
            continue;

        if ( dwMajorVersion == KERNEL_MODE_DRIVER_VERSION   &&
             p2DriverInfo6->cVersion < 2 )
            continue;

        if ( !lstrcmpi(p2DriverInfo6->pName, p1DriverInfo6->pName) ) {

            if ( IdenticalDriverInfo6(p1DriverInfo6,
                                      p2DriverInfo6) &&
                 AllICMFilesInstalled(pszServerName,
                                      pLocalData->InfInfo.pszzICMFiles) )
                iRet = DRIVER_MODEL_INSTALLED_AND_IDENTICAL;
            else
                iRet = DRIVER_MODEL_INSTALLED_BUT_DIFFERENT;

            goto Cleanup;
        }
    }

Cleanup:
    LocalFreeMem(p);

    DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    return iRet;
}


PLATFORM
PSetupThisPlatform(
    VOID
    )
/*++

Routine Description:
    Returns the platform of the local machine.

Arguments:

Return Value:
    Platform of local machine

--*/
{
    return MyPlatform;
}


BOOL
DeleteAllFilesInDirectory(
    LPCTSTR     pszDir,
    BOOL        bDeleteDirectory
    )
/*++

Routine Description:
    Delete all the files in a directory, and optionally the directory as well.

Arguments:
    pszDir              : Directory name to cleanup
    bDeleteDirectory    : If TRUE the directory gets deleted as well

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL                bRet = TRUE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               dwLen;
    TCHAR               *pszFile        = NULL;
    TCHAR               *pszBuf         = NULL;
    INT                 cchLength        = 0;
    INT                 cchBufLength     = 0;
    INT                 cchInitialLength = 4 * MAX_PATH;
    WIN32_FIND_DATA     FindData;


    if (!pszDir)
    {
        bRet = FALSE;
        goto Cleanup;
    }

    cchLength = max( cchInitialLength, lstrlen( pszDir ) + lstrlen( TEXT("\\*") ) + 1);
    pszFile  = LocalAllocMem( cchLength * sizeof( TCHAR ));
    if (!pszFile)
    {
        bRet = FALSE;
        goto Cleanup;
    }

    StringCchCopy(pszFile, cchLength, pszDir);
    dwLen = lstrlen(pszFile);
    StringCchCopy(pszFile + dwLen, cchLength - dwLen, TEXT("\\*"));

    hFile = FindFirstFile(pszFile, &FindData);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        bRet = FALSE;
        goto Cleanup;
    }

    *(pszFile + dwLen + 1) = TEXT('\0');
    pszBuf = AllocStr( pszFile );
    if (!pszBuf)
    {
        bRet = FALSE;
        goto Cleanup;
    }
    cchBufLength = lstrlen( pszBuf );

    do {

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            continue;

        cchLength = cchBufLength + lstrlen( FindData.cFileName ) + 1;
        if (cchLength > cchInitialLength)
        {
            LocalFreeMem( pszFile );
            pszFile = LocalAllocMem( cchLength * sizeof( TCHAR ));
            if (!pszFile)
            {
                bRet = FALSE;
                goto Cleanup;
            }
            cchInitialLength = cchLength;
        }
        StringCchCopy(pszFile, cchLength, pszBuf);
        StringCchCat( pszFile, cchLength, FindData.cFileName );

        //
        // Remove the FILE_ATTRIBUTE_READONLY file attribute if it has been set
        //
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY )
        {
            SetFileAttributes( pszFile,
                               FindData.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY );
        }

        if ( !DeleteFile(pszFile) )
            bRet = FALSE;
    } while ( FindNextFile(hFile, &FindData) );

    if ( bDeleteDirectory && !RemoveDirectory(pszDir) )
        bRet = FALSE;

Cleanup:

    if(hFile != INVALID_HANDLE_VALUE)
    {
        FindClose(hFile);
    }
    LocalFreeMem( pszFile );
    LocalFreeMem( pszBuf );
    return bRet;
}

//
// enum to store the NT-CD type
//
typedef enum _eCDType {
    CD_Unknown,
    CD_NT4,
    CD_W2K_SRV,
    CD_W2K_PRO,
    CD_WHISTLER_SRV,
    CD_WHISTLER_WKS
} CD_TYPE;

//
// structure that stores the tag file names of the NT CDs
//
typedef struct _CD_TAGFILE_MAP_ENTRY {
    CD_TYPE CdType;
    LPTSTR  pszTagFileName;
}CD_TAGFILE_MAP_ENTRY;

CD_TAGFILE_MAP_ENTRY TagEntries[] =
{
    //
    // the following entry for the Whistler CD is special in a couple of ways:
    // - it uses a wildcard because the tag filename changes from Beta1 to Beta2 and again to RTM
    // - it identifies the CD as W2k despite it being for Whistler. The reason is that the layout regarding
    //   printer drivers is identical to W2k, no need to distinguish (and duplicate entries)
    //
    { CD_W2K_SRV, _T("WIN51.*") },

    { CD_W2K_SRV, _T("CDROM_NT.5") },
    { CD_NT4, _T("CDROM_S.40") },
    { CD_NT4, _T("CDROM_W.40") },
    //
    // no need to identify NT3.x CDs - different codepath !
    //
    { CD_Unknown, NULL }
};


//
// structure to store the subpaths to printer INFs on the NT CDs
//
typedef struct _CD_SUBPATHS_FOR_PLATFORMS {
    CD_TYPE     CdType;
    PLATFORM    Platform;
    DWORD       Version;
    LPCTSTR     pszSubPath;
} CD_SUBPATHS_FOR_PLATFORMS;

//
// this list is used for lookup of pathes as well - must be sorted so that paths
// that contain other paths must come before them (e.g. xxx\zzz before \zzz)
//
CD_SUBPATHS_FOR_PLATFORMS SubPathInfo[] =
{
    { CD_W2K_SRV, PlatformX86, 2, _T("printers\\nt4\\i386\\") },
    { CD_W2K_SRV, PlatformWin95, 0, _T("printers\\win9x\\") },
    { CD_W2K_SRV, PlatformX86, 3, _T("i386\\") },
    { CD_W2K_SRV, PlatformIA64, 3, _T("ia64\\") },

    { CD_NT4, PlatformX86, 2, _T("i386\\") },
    { CD_NT4, PlatformAlpha, 2, _T("alpha\\") },
    { CD_NT4, PlatformMIPS, 2, _T("mips\\") },
    { CD_NT4, PlatformPPC, 2, _T("ppc\\") },

    //
    // path = NULL terminates the array
    //
    { CD_Unknown, PlatformX86, 0 , NULL }
};

CD_TYPE
DetermineCDType(LPTSTR pszInfPath, LPTSTR pszRootPath)
/*++

Routine Description:
    From a path to a printer INF, figure out what (if any) NT CD this is.
    It does so by figuring out the root path if it's one of the NT CDs and
    then checking the tag file that should be there.

Arguments:
    pszInfPath  : path to INF
    pszRootPath : caller-supplied buffer (MAX_PATH long) that receives the
                  path to the CD "root". This is nontrivial in case the CD
                  is on a network share. Ends with a backslash

Return Value:
    The type of CD detected, CD_Unknown if not one that we know of (i.e. an OEM CD)

--*/
{
    LPTSTR pszTemp;
    DWORD i;

    //
    // find the root path
    //
    DWORD_PTR MinPathLen = 0, SubPathLen, len;

    StringCchCopy(pszRootPath, MAX_PATH, pszInfPath);
    len = _tcslen(pszRootPath);

    //
    // make sure it ends with a backslash
    //
    if (pszRootPath[len-1] != _T('\\'))
    {
        pszRootPath[len++] = _T('\\');
        pszRootPath[len] = 0;
    }

    //
    // Is it a UNC path ?
    //

    if (!_tcsncmp(pszRootPath, _T("\\\\"), 2))
    {
        pszTemp = _tcschr(pszRootPath + 2, _T('\\'));
        if (pszTemp)
        {
            pszTemp = _tcschr(pszTemp+1, _T('\\'));
            if (pszTemp)
            {
                MinPathLen = pszTemp - pszRootPath;
            }
        }

        //
        // check for illegal path, shouldn't happen
        //
        if ((MinPathLen == 0) || (MinPathLen > len))
        {
            return CD_Unknown;
        }
    }
    else
    {
        MinPathLen = 2;
    }

    //
    // now check whether the final part of the path is one that I know of
    //
    for (i = 0; SubPathInfo[i].pszSubPath != NULL; ++i)
    {
        SubPathLen = _tcslen(SubPathInfo[i].pszSubPath);
        if (SubPathLen + MinPathLen <= len)
        {
            if (!_tcsnicmp(&(pszRootPath[len - SubPathLen]),
                           SubPathInfo[i].pszSubPath, SubPathLen))
            {
                pszRootPath[len-SubPathLen] = 0;
                len = _tcslen(pszRootPath);
                break;
            }
        }
    }

    //
    // if it's none of the paths I know of, it can still be the root itself.
    // now I know where the tag files should be if they're there
    //
    for (i = 0;TagEntries[i].pszTagFileName != NULL; ++i)
    {
        StringCchCopy(&(pszRootPath[len]), MAX_PATH - len, TagEntries[i].pszTagFileName);

        if (FileExists(pszRootPath))
        {
            pszRootPath[len] = 0; // cut off the tag file name
            return TagEntries[i].CdType;
        }
    }

    return CD_Unknown;
}

BOOL
CheckValidInfInPath(HWND hwnd, LPTSTR pszInfPath, DWORD dwVersion, PLATFORM Platform)
{
    TCHAR szInfFiles[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    DWORD PathLen;
    BOOL bRet = FALSE;

    //
    // first, find the INF in the path. There must be one else SetupPromptForPath would've complained
    //
    StringCchCopy(szInfFiles, COUNTOF(szInfFiles), pszInfPath);
    PathLen = _tcslen(szInfFiles);

    if (szInfFiles[PathLen-1] != _T('\\'))
    {
        szInfFiles[PathLen++] = _T('\\');
        szInfFiles[PathLen] = 0;
    }

    StringCchCat(szInfFiles, COUNTOF(szInfFiles), _T("*.inf"));

    hFind = FindFirstFile(szInfFiles, &FindData);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        DWORD InfStyle;
        HANDLE hInfFile;

        if ((dwVersion == 0) && (Platform != PlatformWin95))
        {
            InfStyle = INF_STYLE_OLDNT;
        }
        else
        {
            InfStyle = INF_STYLE_WIN4;
        }

        do
        {
            StringCchCopy(&(szInfFiles[PathLen]), COUNTOF(szInfFiles) - PathLen, FindData.cFileName);

            hInfFile = SetupOpenInfFile(szInfFiles, _T("Printer"), InfStyle, NULL);

            if (hInfFile != INVALID_HANDLE_VALUE)
            {
                SetupCloseInfFile(hInfFile);
                bRet = TRUE;
                break;
            }
        } while ( FindNextFile(hFind, &FindData) );

        FindClose(hFind);
    }

    if (!bRet)
    {
        LPTSTR pszFormat = NULL, pszPrompt = NULL, pszTitle = NULL;

        pszFormat   = GetStringFromRcFile(IDS_WARN_NO_ALT_PLATFORM_DRIVER);
        pszTitle    = GetStringFromRcFile(IDS_WARN_NO_DRIVER_FOUND);

        if ( pszFormat && pszTitle)
        {
            DWORD dwBufSize;

            dwBufSize = (lstrlen(pszFormat) + lstrlen(pszInfPath) + 2) * sizeof(TCHAR);
            pszPrompt = LocalAllocMem(dwBufSize);

            if ( pszPrompt )
            {
                StringCbPrintf(pszPrompt, dwBufSize, pszFormat, pszInfPath);

                MessageBox(hwnd, pszPrompt, pszTitle, MB_OK);

                LocalFreeMem(pszPrompt);
            }

        }
        LocalFreeMem(pszFormat);
        LocalFreeMem(pszTitle);
    }

    return bRet;
}


BOOL
CheckInfPath(HWND hwnd, LPTSTR pszInfPath, DWORD dwVersion, PLATFORM platform,
             LPTSTR *ppFileSrcPath)
/*++

Routine Description:
    Check whether the path that a user selected as a path to install a printer
    from points to one of our CDs and correct the path if necessary, i.e. if
    the luser selected the \i386 subdir for an NT4 driver.

Arguments:
    hwnd        : windows handle of the main window
    pszInfPath  : path to INF. This buffer must be at least
                  MAX_PATH in length.
    dwVersion   : driver version that the new driver is installed for
    platform    : the platform that the new driver is installed for
    ppFileSrcPath: if not NULL, receives the path to the printer files. This
                  is used for installation from the NT4 CD that contains a
                  compressed INF that I have to uncompress  and install from
                  without copying all the files possibly referenced in it.
                  Needs to be freed by the caller.

Return Value:
    TRUE: path contains a valid print inf
    FALSE: path doesn't contain a print inf, prompt user again

--*/
{
    CD_TYPE CDType;
    TCHAR   szRootPath[MAX_PATH];
    DWORD   i;

    //
    // determine the type of CD
    //
    CDType = DetermineCDType(pszInfPath, szRootPath);

    if (CDType == CD_Unknown)
    {
        return CheckValidInfInPath(hwnd, pszInfPath, dwVersion, platform);
    }

    //
    // NT 4 drivers are compressed -> uncompress into temp dir
    //
    if ((dwVersion == 2) && (CDType == CD_NT4))
    {
        //
        // Make sure the file is actually the compressed one
        //
        DWORD rc, CompressedFileSize, UncompressedFileSize;
        UINT  CompType;
        LPTSTR pszUncompFilePath = NULL, pszInfFileName = _T("ntprint.in_");
        TCHAR szInf[MAX_PATH];

        StringCchCopy(szInf, COUNTOF(szInf), szRootPath);

        //
        // append the correct subpath
        //
        for (i = 0; SubPathInfo[i].pszSubPath != NULL; ++i)
        {
            if ((SubPathInfo[i].CdType == CD_NT4) &&
                (platform == SubPathInfo[i].Platform) &&
                (dwVersion == SubPathInfo[i].Version))
            {
                StringCchCat(szInf, COUNTOF(szInf), SubPathInfo[i].pszSubPath);
                break;
            }
        }
        StringCchCat(szInf, COUNTOF(szInf), pszInfFileName);

        rc = SetupGetFileCompressionInfo(szInf,
                                         &pszUncompFilePath,
                                         &CompressedFileSize,
                                         &UncompressedFileSize,
                                         &CompType);

        if (rc == NO_ERROR)
        {
            LocalFree(pszUncompFilePath); // don't need that

            if (CompType != FILE_COMPRESSION_NONE)
            {
                TCHAR UncompFilePath[MAX_PATH], *pTmp;

                //
                // decompress into temp directory
                //
                if (GetTempPath(MAX_PATH, UncompFilePath) &&
                    (SUCCEEDED(StringCchCat(UncompFilePath, COUNTOF(UncompFilePath), _T("ntprint.inf")))) &&
                    (SetupDecompressOrCopyFile(szInf, UncompFilePath, NULL) == NO_ERROR))
                {
                    if (ppFileSrcPath)
                    {
                        //
                        // delete the inf name from the path
                        //
                        pTmp = _tcsrchr(szInf, _T('\\'));
                        if (pTmp)
                        {
                            *(pTmp+1) = 0;
                        }
                        *ppFileSrcPath = AllocStr(szInf);
                    }

                    StringCchCopy(pszInfPath, MAX_PATH, UncompFilePath);

                    //
                    // delete the inf name from the path
                    //
                    pTmp = _tcsrchr(pszInfPath, _T('\\'));
                    if (pTmp)
                    {
                        *(pTmp+1) = 0;
                    }

                    return TRUE;
                }
            }
        }
    }

    //
    // correct the path if it's the one for a different platform
    //
    for (i = 0; SubPathInfo[i].pszSubPath != NULL; ++i)
    {
        if ((CDType == SubPathInfo[i].CdType) &&
            (platform == SubPathInfo[i].Platform) &&
            (dwVersion == SubPathInfo[i].Version))
        {
            StringCchCopy(pszInfPath, MAX_PATH, szRootPath);
            StringCchCat( pszInfPath, MAX_PATH, SubPathInfo[i].pszSubPath);

            break;
        }
    }

    return CheckValidInfInPath(hwnd, pszInfPath, dwVersion, platform);
}


HDEVINFO
GetInfAndBuildDrivers(
    IN  HWND                hwnd,
    IN  DWORD               dwTitleId,
    IN  DWORD               dwDiskId,
    IN  TCHAR               szInfPath[MAX_PATH],
    IN  DWORD               dwInstallFlags,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszDriverName,              OPTIONAL
    OUT PPSETUP_LOCAL_DATA *ppLocalData,                OPTIONAL
    OUT LPTSTR             *ppFileSrcPath               OPTIONAL

    )
/*++

Routine Description:
    Prompt for an INF and build the list of printer drivers from INFs found
    in the directory. If pszDriverName is passed in then the INF should have
    a model with matching name (i.e. alternate driver installation case)

Arguments:
    hwnd            : Parent window handle for UI
    dwTitleId       : Gives the identifier to be used to load the title string
                      from the rc file
    dwDiskId        : Gives the identifier to be used to load the disk identifier
                      from the rc file
    szInfPath       : Directory name where inf was found
    pszDriverName   : Name of the driver needed in the INF
    ppLocalData     : If a driver nam is given on return this will give
                      the local data for that
    dwInstallFlags  : Flags to control installation operation

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL        bDoRetry = TRUE;
    DWORD       dwLen, dwLastError;
    LPTSTR      pszTitle = NULL, pszDisk = NULL;
    HDEVINFO    hDevInfo = INVALID_HANDLE_VALUE;

    dwLen = lstrlen(szInfPath);
    szInfPath[dwLen]    = TEXT('\\');

    if ( dwLen + lstrlen(cszAllInfs) + 1 > MAX_PATH )
        goto Cleanup;

    StringCchCopy(szInfPath+dwLen + 1, MAX_PATH - (dwLen + 1), cszAllInfs);

Retry:
    if ( bDoRetry && FileExists(szInfPath) ) {

        szInfPath[dwLen] = TEXT('\0');
    } else {

        //
        // if the file doesn't exist in the first place, prompt only once !
        //
        bDoRetry = FALSE;

        //
        // Always just prompt with the CD-ROM path
        //
        GetCDRomDrive(szInfPath);

        if ( dwInstallFlags & DRVINST_PROMPTLESS ) {

            SetLastError(ERROR_FILE_NOT_FOUND);
            goto Cleanup;
        }

        if ( dwTitleId && !(pszTitle = GetStringFromRcFile(dwTitleId)) )
            goto Cleanup;

        if ( dwDiskId && !(pszDisk = GetStringFromRcFile(dwDiskId)) )
            goto Cleanup;

        do
        {
            if ( !PSetupGetPathToSearch(hwnd, pszTitle, pszDisk,
                                        cszAllInfs, TRUE, szInfPath) )
                goto Cleanup;

        } while (!CheckInfPath(hwnd, szInfPath, dwVersion, platform, ppFileSrcPath));
    }

    hDevInfo = CreatePrinterDeviceInfoList(hwnd);

    if ( hDevInfo == INVALID_HANDLE_VALUE                       ||
         !SetDevInstallParams(hDevInfo, NULL, szInfPath)        ||
         !BuildClassDriverList(hDevInfo)                        ||
         (pszDriverName && ppLocalData &&
          !(*ppLocalData = PSetupDriverInfoFromName(hDevInfo,
                                                    pszDriverName))) ) {

        dwLastError = GetLastError();
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);
        hDevInfo = INVALID_HANDLE_VALUE;
        SetLastError(dwLastError);
        if ( bDoRetry ) {

            bDoRetry = FALSE;
            goto Retry;
        }
        goto Cleanup;
    }

Cleanup:
    LocalFreeMem(pszTitle);
    LocalFreeMem(pszDisk);

    return hDevInfo;
}


BOOL
MyName(
    IN  LPCTSTR     pszServerName
    )
/*++

Routine Description:
    Tells if the string passed in identifies the local machine. Currently
    it checks for NULL and computer name only

Arguments:
    pszServerName   : Name of the server passed in

Return Value:
    TRUE if the name is recognized as that for local machine, FALSE else

--*/
{
    TCHAR   szBuf[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   dwNeeded;

    if ( !pszServerName || !*pszServerName )
        return TRUE;

    return FALSE;
/*
    dwNeeded = SIZECHARS(szBuf);

    if ( *pszServerName == TEXT('\\')       &&
         *(pszServerName+1) == TEXT('\\')   &&
         GetComputerName(szBuf, &dwNeeded)  &&
         !lstrcmpi(pszServerName+2, szBuf) ) {

        return TRUE;
    }
*/

}


BOOL
PSetupGetLocalDataField(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  PDRIVER_FIELD       pDrvField
    )
/*++

Routine Description:
    Returns a driver installation field found from inf parsing.
    Printui uses this routine for all the queries.
    Since INF could have different sections for different platforms
    (notably for Win95 and NT but architecture specific install sections
     are possible too)

Arguments:
    pLocalData  : Pointer to local data
    platform    : Which platform the field is for
    pDrvField   : Points to DRIVER_FIELD where field is copied to

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL     bRet     = FALSE;
    DWORD    cbSize;
    LPTSTR   psz;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;

    ASSERT(pLocalData   &&
           pDrvField    &&
           pLocalData->signature == PSETUP_SIGNATURE);

    if(INVALID_HANDLE_VALUE == (hDevInfo = CreatePrinterDeviceInfoList(NULL)))
    {
        return bRet;
    }

    switch ( pDrvField->Index ) {

        case    DRIVER_NAME:
            if ( pDrvField->pszDriverName = AllocStr(pLocalData->DrvInfo.pszModelName) )
                bRet = TRUE;
            break;

        case    INF_NAME:
            if ( pDrvField->pszInfName = AllocStr(pLocalData->DrvInfo.pszInfName) )
                bRet = TRUE;
            break;

        case    DRV_INFO_4:
            if ( ParseInf(hDevInfo, pLocalData, platform, NULL, 0, TRUE)     &&
                 (pDrvField->pDriverInfo4
                        = (LPDRIVER_INFO_4) CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                           pLocalData->InfInfo.cbDriverInfo6)) )
                bRet = TRUE;
            break;

        case    DRV_INFO_6:
            if ( ParseInf(hDevInfo, pLocalData, platform, NULL, 0, TRUE)     &&
                 (pDrvField->pDriverInfo6
                        = CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                           pLocalData->InfInfo.cbDriverInfo6)) )
                bRet = TRUE;
            break;

        case    PRINT_PROCESSOR_NAME:
            pDrvField->pszPrintProc = NULL;

            if ( ParseInf(hDevInfo, pLocalData, platform, NULL, 0, TRUE) ) {

                if ( !pLocalData->InfInfo.pszPrintProc  ||
                     (pDrvField->pszPrintProc = AllocStr(pLocalData->InfInfo.pszPrintProc)) )
                    bRet = TRUE;
            }
            break;

        case    ICM_FILES:
            pDrvField->pszzICMFiles = NULL;
            if ( ParseInf(hDevInfo, pLocalData, platform, NULL ,0, TRUE) ) {

                for ( cbSize = 0, psz = pLocalData->InfInfo.pszzICMFiles ;
                      psz && *psz ;
                      cbSize += lstrlen(psz) + 1, psz += lstrlen(psz) + 1 )
                ;

                if ( cbSize == 0 ) {

                    bRet = TRUE;
                    break;
                }

                //
                // One more char for the last \0 in the multi-sz
                //
                cbSize = (cbSize + 1 ) * sizeof(TCHAR);

                if ( pDrvField->pszzICMFiles = LocalAllocMem(cbSize) ) {

                    CopyMemory((LPBYTE)pDrvField->pszzICMFiles,
                               (LPBYTE)pLocalData->InfInfo.pszzICMFiles,
                               cbSize);
                    bRet = TRUE;
                }
            }

            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;

    }

    DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    return bRet;
}


VOID
PSetupFreeDrvField(
    IN  PDRIVER_FIELD   pDrvField
    )
/*++

Routine Description:
    Frees the memory allocated for a driver installation field in a previous
    call

Arguments:
    pDrvField   : Points to DRIVER_FIELD where field is copied to

Return Value:
    None

--*/
{
    LocalFreeMem(pDrvField->pszPrintProc);
    pDrvField->pszPrintProc = NULL;
}

BOOL
FileExists(
    IN  LPCTSTR  pszFileName
    )
/*++

Routine Description:
    Checks if the given file exists setting correct error modes not to bring
    up any pop-ups.
    call

Arguments:
    pszFileName : File name (fully qualified)

Return Value:
    TRUE if file exists, FALSE else.

--*/
{
    UINT                OldMode;
    HANDLE              hFile;
    WIN32_FIND_DATA     FindData;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hFile = FindFirstFile(pszFileName, &FindData);

    if ( hFile != INVALID_HANDLE_VALUE )
        FindClose(hFile);

    SetErrorMode(OldMode);

    return hFile != INVALID_HANDLE_VALUE;
}

BOOL
IsLanguageMonitorInstalled(PCTSTR pszMonitorName)
/*++

Routine Description:
    Checks for whether a language monitor is installed. The function above only checks for
    port monitors, because EnumMonitors doesn't enumerate language monitors. Since there is 
    no API to do that, we sneak a peek at the registry.

Arguments:
    pszMonitorName   : Monitor name to check

Return Value:
    TRUE if installed

--*/
{
    PTSTR pKeyName = NULL;
    BOOL  IsInstalled = FALSE;

    StrCatAlloc(&pKeyName, cszMonitorKey, pszMonitorName, NULL);
    if (pKeyName)
    {
        HKEY hKey;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pKeyName, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            IsInstalled = TRUE;
            RegCloseKey(hKey);
        }
        FreeSplMem(pKeyName);
    }

    return IsInstalled;
}

BOOL
CleanupUniqueScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
)
{
    BOOL        bRet;
    TCHAR       szDir[MAX_PATH];
    DWORD       dwNeeded;

    bRet = GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                      PlatformEnv[platform].pszName,
                                      1,
                                      (LPBYTE)szDir,
                                      sizeof(szDir),
                                      &dwNeeded);

    if (bRet)
    {
        bRet = AddDirectoryTag(szDir, MAX_PATH);
    }
    
    if (bRet)
    { 
        bRet = DeleteAllFilesInDirectory(szDir, TRUE);
    }

    return bRet;
}


BOOL
CleanupScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
    )
{
    TCHAR       szDir[MAX_PATH];
    DWORD       dwNeeded;

    return  GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                      PlatformEnv[platform].pszName,
                                      1,
                                      (LPBYTE)szDir,
                                      sizeof(szDir),
                                      &dwNeeded)                        &&
            DeleteAllFilesInDirectory(szDir, FALSE);
}

LPTSTR
GetSystemInstallPath(
    VOID
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwSize, dwType, dwLastPos;
    HKEY    hKey;
    TCHAR   szSetupKey[] = TEXT( "Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
    TCHAR   szSourceValue[] = TEXT("SourcePath");
    LPTSTR  pszSourcePath = NULL;

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       szSetupKey,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKey) ) {

        if ( ERROR_SUCCESS == RegQueryValueEx(hKey,
                                              szSourceValue,
                                              NULL,
                                              &dwType,
                                              NULL,
                                              &dwSize) )
        {
           dwLastPos = (dwSize/sizeof(TCHAR)) - 1;
           if (pszSourcePath = (LPTSTR) LocalAllocMem(dwSize))
           {
              if ( ERROR_SUCCESS != RegQueryValueEx(hKey,
                                                    szSourceValue,
                                                    NULL,
                                                    &dwType,
                                                    (LPBYTE)pszSourcePath,
                                                    &dwSize) )
              {
                 LocalFreeMem(pszSourcePath);
                 pszSourcePath = NULL;
              }
              else
              {
                 pszSourcePath[dwLastPos] = TEXT('\0');
              }
           }
        }

        RegCloseKey(hKey);
    }

    return pszSourcePath;
}

PPSETUP_LOCAL_DATA
RebuildDeviceInfo(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszSource
    )
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData, TempDriverInfoData;
    PPSETUP_LOCAL_DATA  pNewLocalData = NULL;
    DWORD Err;

    //
    // Retrieve the current device install parameters, in preparation for modifying them to
    // target driver search at a particular INF.
    //
    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(hDevInfo, pLocalData->DrvInfo.pDevInfoData, &DeviceInstallParams)) {
        return NULL;
    }

    SetupDiDestroyDriverInfoList(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER);

    // Set the path of the INF
    StringCchCopy( DeviceInstallParams.DriverPath, COUNTOF(DeviceInstallParams.DriverPath), pszSource );

    //
    // set the flag that indicates DriverPath represents a single INF to be searched (and
    // not a directory path).  Then store the parameters back to the device information element.
    //
    // DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pLocalData->DrvInfo.pDevInfoData, &DeviceInstallParams))
    {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Now build a class driver list from this INF.
    //
    if(!SetupDiBuildDriverInfoList(hDevInfo, pLocalData->DrvInfo.pDevInfoData, SPDIT_CLASSDRIVER))
    {
        Err = GetLastError();
        goto clean0;
    }

    //
    // OK, now select the driver node from that INF that was used to install this device.
    // The three parameters that uniquely identify a driver node are INF Provider,
    // Device Manufacturer, and Device Description.  Retrieve these three pieces of information
    // in preparation for selecting the proper driver node in the class list we just built.
    //
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
    DriverInfoData.Reserved = 0;  // Search for the driver matching the specified criteria and
                                  // select it if found.
    // Fill in the Model & Mfg from original INF
    StringCchCopy( DriverInfoData.Description, COUNTOF(DriverInfoData.Description), pLocalData->DrvInfo.pszModelName );
    StringCchCopy( DriverInfoData.MfgName, COUNTOF(DriverInfoData.MfgName), pLocalData->DrvInfo.pszManufacturer );

    // Enum One driver entry to get the INF provider
    ZeroMemory(&TempDriverInfoData, sizeof(TempDriverInfoData));
    TempDriverInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
    if (!SetupDiEnumDriverInfo (hDevInfo, NULL, SPDIT_CLASSDRIVER, 0, &TempDriverInfoData))
    {
        Err = GetLastError();
        goto clean0;
    }
    StringCchCopy( DriverInfoData.ProviderName, COUNTOF(DriverInfoData.ProviderName), TempDriverInfoData.ProviderName );


    if(!SetupDiSetSelectedDriver(hDevInfo, pLocalData->DrvInfo.pDevInfoData, &DriverInfoData))
    {
        Err = GetLastError();
        goto clean0;
    }

    //
    // At this point, we've successfully selected the currently installed driver for the specified
    // device information element.
    //
    // Now build the new LocalData
    //
    pNewLocalData = BuildInternalData(hDevInfo, NULL);
    if ( pNewLocalData )
    {
        if ( !ParseInf(hDevInfo, pNewLocalData, MyPlatform, NULL, 0, FALSE) )
        {
            Err = GetLastError();
            DestroyLocalData( pNewLocalData );
            pNewLocalData = NULL;
        }
        else
        {
           SELECTED_DRV_INFO TempDrvInfo;

           TempDrvInfo.pszInfName        = AllocStr( pNewLocalData->DrvInfo.pszInfName );
           TempDrvInfo.pszDriverSection  = AllocStr( pNewLocalData->DrvInfo.pszDriverSection );
           TempDrvInfo.pszModelName      = AllocStr( pNewLocalData->DrvInfo.pszModelName );
           TempDrvInfo.pszManufacturer   = AllocStr( pNewLocalData->DrvInfo.pszManufacturer );
           TempDrvInfo.pszHardwareID     = AllocStr( pNewLocalData->DrvInfo.pszHardwareID );
           TempDrvInfo.pszOEMUrl         = AllocStr( pNewLocalData->DrvInfo.pszOEMUrl );

           // Check that all strings were allocated
           if ( !TempDrvInfo.pszInfName       ||
                !TempDrvInfo.pszDriverSection ||
                !TempDrvInfo.pszModelName     ||
                !TempDrvInfo.pszManufacturer  ||
                !TempDrvInfo.pszHardwareID    ||
                !TempDrvInfo.pszOEMUrl      )
           {
              // Free up all that worked
              LocalFreeMem( TempDrvInfo.pszInfName );
              LocalFreeMem( TempDrvInfo.pszDriverSection );
              LocalFreeMem( TempDrvInfo.pszModelName );
              LocalFreeMem( TempDrvInfo.pszManufacturer );
              LocalFreeMem( TempDrvInfo.pszHardwareID );
              LocalFreeMem( TempDrvInfo.pszOEMUrl );

           }
           else
           {
              // Free the DrvInfo pointers & refill from new local data
              LocalFreeMem( pLocalData->DrvInfo.pszInfName );
              LocalFreeMem( pLocalData->DrvInfo.pszDriverSection );
              LocalFreeMem( pLocalData->DrvInfo.pszModelName );
              LocalFreeMem( pLocalData->DrvInfo.pszManufacturer );
              LocalFreeMem( pLocalData->DrvInfo.pszHardwareID );
              LocalFreeMem( pLocalData->DrvInfo.pszOEMUrl );


              pLocalData->DrvInfo.pszInfName        = TempDrvInfo.pszInfName;
              pLocalData->DrvInfo.pszDriverSection  = TempDrvInfo.pszDriverSection;
              pLocalData->DrvInfo.pszModelName      = TempDrvInfo.pszModelName;
              pLocalData->DrvInfo.pszManufacturer   = TempDrvInfo.pszManufacturer;
              pLocalData->DrvInfo.pszHardwareID     = TempDrvInfo.pszHardwareID;
              pLocalData->DrvInfo.pszOEMUrl         = TempDrvInfo.pszOEMUrl;
           }

           Err = NO_ERROR;
        }
    }
    else
        Err = GetLastError();


clean0:

    SetLastError(Err);
    return pNewLocalData;

}

BOOL
SetupSkipDir(
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName
    )
{
   BOOL       bRet      = FALSE;
   //
   //   Temp directory length + SKIP_Dir length + ProcID length 
   //
   TCHAR      szDir[MAX_PATH + COUNTOF (SKIP_DIR) + 30 ];
   TCHAR      szProcId[30];
   SYSTEMTIME SysTime;
   DWORD      dwNeeded = MAX_PATH;

   EnterCriticalSection(&SkipCritSect);

   // We already have a skip dir created
   if ( !gpszSkipDir )
   {
      // Get a location for a Temp Path
      //    Since the files in skip dir will be deleted  after
      //    setup is complete, so we just use a local directory
      //    to store the skip files
      //
      dwNeeded = GetTempPath (MAX_PATH, szDir);

      if (dwNeeded == 0 || dwNeeded > MAX_PATH)
      {
          goto Cleanup;
      }

      // Add on the Skip Prefix
      StringCchCat( szDir, COUNTOF(szDir), SKIP_DIR );

      // Get Process Id:
      StringCchPrintf( szProcId, COUNTOF(szProcId), TEXT("%lX"), GetCurrentProcessId() );

      StringCchCat( szDir, COUNTOF(szDir), szProcId );
      gpszSkipDir = AllocStr( szDir );
      if (!gpszSkipDir )
         goto Cleanup;

      if (!CreateDirectory( gpszSkipDir, NULL ) )
      {
          if (GetLastError() != ERROR_ALREADY_EXISTS) 
          {
              goto Cleanup;
          }
      }
   }

   bRet = TRUE;

Cleanup:

   if (!bRet)
   {
      if (gpszSkipDir)
      {
         LocalFreeMem( gpszSkipDir );
         gpszSkipDir = NULL;
      }
   }

   LeaveCriticalSection(&SkipCritSect);
   return bRet;
}


void
CleanupSkipDir(
    VOID
    )
{

   // We already have a skip dir created
   if ( gpszSkipDir )
   {
      RemoveDirectory( gpszSkipDir );
      LocalFreeMem( gpszSkipDir );
      gpszSkipDir = NULL;
   }

   DeleteCriticalSection(&SkipCritSect);
}

BOOL
IsLocalAdmin(BOOL *pbAdmin)
/*++

Routine Description:
    This Routine determines if the user is a local admin.

Parameters:
    pbAdmin - Return Value, TRUE for local admin.

Return Value:
    TRUE             - Function succeded (return value is valid).

--*/ {
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL    bRet      = FALSE;
    PSID    pSIDAdmin = NULL;

    ASSERT( pbAdmin != NULL );  // Called locally

    *pbAdmin = FALSE;

    if (!AllocateAndInitializeSid( &SIDAuth, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &pSIDAdmin) )
        goto Cleanup;

    if (!CheckTokenMembership( NULL,
                               pSIDAdmin,
                               pbAdmin ) )
        goto Cleanup;

    bRet = TRUE;

Cleanup:

    if (pSIDAdmin != NULL) {
        FreeSid( pSIDAdmin );
    }

    return bRet;
}


BOOL
PruneInvalidFilesIfNotAdmin(
    IN     HWND                hWnd,
    IN OUT HSPFILEQ            CopyQueue
    )
/*++

Routine Description:
    This routine checks whether you have administrator privileges, if you do, then
    it does nothing and returns. If you do not, it scans the file queue for files
    that are already present and signed and prunes them from the queue. The commit
    will not allow mixing signed and unsigned files.
    Note: We do this because if you are a power-user the call to MoveFileEx fails inside
    SetupCommitFileQueue, this happens if the existing file cannot be overwritten. We
    could improve this routine by checking if a file is actually in use before pruning
    it.

Parameters:
    CopyQueue        - The copy queue to scan.

Return Value:
    TRUE             - Either you were an administrator and no action was taken, or
                       you were not and the FileQueue was successfully pruned.
    FALSE            - The operation failed.

--*/ {
    BOOL  bLocalAdmin;
    BOOL  bRet = FALSE;
    DWORD dwScanQueueResult;

    if (!IsLocalAdmin( &bLocalAdmin) )
        goto Cleanup;

    if (bLocalAdmin) {
        bRet = TRUE;
        goto Cleanup;
    }

    if (!SetupScanFileQueue( CopyQueue,
                             SPQ_SCAN_FILE_PRESENCE | SPQ_SCAN_PRUNE_COPY_QUEUE,
                             hWnd ,
                             NULL ,
                             NULL ,
                             &dwScanQueueResult ) )

        goto Cleanup;

   bRet = TRUE;

Cleanup:

    return bRet;
}

BOOL
AddDriverCatalogIfNotAdmin(
    IN     PCWSTR    pszServer,
    IN     HANDLE    hDriverSigningInfo,
    IN     PCWSTR    pszInfPath,
    IN     PCWSTR    pszSrcLoc,
    IN     DWORD     dwMediaType,
    IN     DWORD     dwCopyStyle
    )
/*++

Routine Description:

    This routine calls AddDriverCatalog for non-admin, aka power user.

Parameters:

    pszServer           - Name of the server
    hDriverSigningInfo  - Handle to driver signing info

Return Value:

    TRUE             - Either you are an administrator and no action was taken,
                       or you are not and the catalog was successfully added
    FALSE            - The operation failed. Call GetLastError() to get
                       detailed error information

--*/ {
    BOOL                 bRet            = FALSE;
    BOOL                 bLocalAdmin     = TRUE;
    HANDLE               hPrinter        = NULL;
    PRINTER_DEFAULTS     PrinterDefaults = {0};
    DRIVER_INFCAT_INFO_1 DrvInfCatInfo1  = {0};
    DRIVER_INFCAT_INFO_2 DrvInfCatInfo2  = {0};
    PCWSTR               pszCatPath      = NULL;

    if (!hDriverSigningInfo ||
        !DrvSigningIsLocalAdmin(hDriverSigningInfo, &bLocalAdmin) ||
        !GetCatalogFile(hDriverSigningInfo, &pszCatPath))
    {
        goto Cleanup;
    }

    //
    // If there is no Cat file or we are local admin, there is nothing to do
    // because for local admin, we use setup api to install the catalog file
    //
    if (!pszCatPath || bLocalAdmin)
    {
        bRet = TRUE;
        goto Cleanup;
    }

    PrinterDefaults.DesiredAccess = SERVER_ALL_ACCESS;

    if (!OpenPrinterW((PWSTR) pszServer, &hPrinter, &PrinterDefaults))
    {
        goto Cleanup;
    }

    //
    // If there is a catalogfile entry in the inf file, we should call private
    // spooler API AddDriverCatalog with level 2 to install the catalog which
    // will install the inf and cat file by calling SetupCopyOEMInf. For inf
    // files that do not have catalogfile entry we shall call AddDriverCatalog
    // with level 1 which will install the catalog by using CryptoAPI
    //
    if (!IsCatInInf(hDriverSigningInfo))
    {
        DrvInfCatInfo1.pszCatPath = pszCatPath;

        if (!AddDriverCatalog(hPrinter, 1, &DrvInfCatInfo1, APDC_USE_ORIGINAL_CAT_NAME))
        {
            goto Cleanup;
        }
    }
    else
    {
        DrvInfCatInfo2.pszCatPath  = pszCatPath;
        DrvInfCatInfo2.pszInfPath  = pszInfPath;
        DrvInfCatInfo2.pszSrcLoc   = pszSrcLoc;
        DrvInfCatInfo2.dwMediaType = dwMediaType;
        DrvInfCatInfo2.dwCopyStyle = dwCopyStyle;

        if (!AddDriverCatalog(hPrinter, 2, &DrvInfCatInfo2, APDC_NONE))
        {
            goto Cleanup;
        }
    }

    bRet = TRUE;

Cleanup:

    if (hPrinter)
    {
        ClosePrinter(hPrinter);
    }

    return bRet;
}

/*

Function: AddDirectoryTag

  pszDir - TCHAR string to add the two tags to.
  dwSize - size in CHARACTERs of the allocated string buffer.

Purpose - Takes the string pszDir and tags on "\dwPIDdwTID" on the end of it.
          This is used in the creation of a unique directory to copy the driver
          files for a specific install to.

*/
BOOL
AddDirectoryTag(
    IN LPTSTR pszDir,
    IN DWORD  dwSize )
{
    DWORD  dwDirSize,
           dwPID,
           dwTID;
    PTCHAR pEnd;

    if( !pszDir || !dwSize || !(dwDirSize = lstrlen( pszDir )) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    dwPID = GetCurrentProcessId();
    dwTID = GetCurrentThreadId();

    if( (pszDir[dwDirSize-1] != _TEXT('\\'))    &&
        (dwDirSize + 1 < dwSize) )
    {
        pszDir[dwDirSize++] = _TEXT('\\');
        pszDir[dwDirSize]   = 0;
    }

    pEnd = &pszDir[dwDirSize];

    return SUCCEEDED(StringCchPrintf( pEnd,
                    (dwSize-dwDirSize),
                    _TEXT("%d%d"),
                    dwPID,
                    dwTID ));

}

/*

Function: AddPnpDirTag

  pszDir - TCHAR string to add the tag to.
  dwSize - size in CHARACTERs of the allocated string buffer.

Purpose - Takes the string pszDir and tags on the pnp-ID on to it.
          This is used in the creation of a unique directory to copy the driver
          files for a specific install to.

*/
BOOL
AddPnpDirTag(
    IN LPTSTR     pszHardwareId,
    IN OUT LPTSTR pszDir,
    IN DWORD      dwSize )
{
    DWORD  dwDirSize;
    PTCHAR pEnd, pPnpId;

    if( !pszHardwareId  || 
        !pszDir         || 
        !dwSize         || 
        !(dwDirSize = lstrlen( pszDir )) ||
        dwSize < dwDirSize + 3 ) // need at least space for backslash, one char + 0 terminator
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( (pszDir[dwDirSize-1] != _TEXT('\\')))
    {
        pszDir[dwDirSize++] = _TEXT('\\');
        pszDir[dwDirSize]   = 0;
    }

    pEnd = &pszDir[dwDirSize];

    //
    // Try to strip off the port enumerator, if applicable. The printer driver
    // should be independent of it.
    //
    if ((pPnpId = _tcsrchr(pszHardwareId, _TEXT('\\'))) == NULL)
    {
        // 
        // it doesn't have a port enumerator, so the whole thing is the pnp ID
        //
        pPnpId = pszHardwareId;
    }
    else
    {
        //
        // found one: advance one beyond it if it's not the last character
        // to illustrate LPTENUM\abcd would become \abcd instead of abcd
        //
        if (*(pPnpId+1))
        {
            pPnpId++;
        }
    }
    StringCchCopy(pEnd, dwSize - dwDirSize, pPnpId);
    
    //
    // change all suspicious characters to underscores to avoid problems with / & \ etc.
    // all the distinguishing information should be in the alphanumerical characters
    //
    while (*pEnd)
    {
        if (!_istalnum(*pEnd))
        {
            *pEnd = _TEXT('_');
        }
        pEnd++;
    }

    return TRUE;
}

/*

Function:  AddDirToDriverInfo

  pszDir       - Directory to append to driver info structure.
  pDriverInfo6 - Pointer to the driver info structure to update.

Purpose: This function will ensure that there is no directory structure specified in the
         driver info structure yet (so as not to add it multiple times).
         If there isn't then it will update the driver file entries with the full path
         passed in in pszDir.

*/
BOOL
AddDirToDriverInfo(
    IN LPTSTR          pszDir,
    IN LPDRIVER_INFO_6 pDriverInfo6
    )
{
    PTCHAR pOldString,
           pCurrentString,
           pNewString;
    DWORD  dwLength,
           dwDirLength,
           dwNeeded = 0;

    if( !pszDir || !pDriverInfo6 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  If the path is zero length, nothing to do.
    //
    if( !(dwDirLength = lstrlen( pszDir )) )
        return TRUE;

    if( pDriverInfo6->pDriverPath &&
        FileNamePart( pDriverInfo6->pDriverPath ) == pDriverInfo6->pDriverPath )
    {
        pOldString = pDriverInfo6->pDriverPath;

        pDriverInfo6->pDriverPath = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
        pOldString = NULL;
    }

    if( pDriverInfo6->pDataFile &&
        FileNamePart( pDriverInfo6->pDataFile ) == pDriverInfo6->pDataFile )
    {
        pOldString = pDriverInfo6->pDataFile;

        pDriverInfo6->pDataFile = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
        pOldString = NULL;
    }

    if( pDriverInfo6->pConfigFile &&
        FileNamePart( pDriverInfo6->pConfigFile ) == pDriverInfo6->pConfigFile )
    {
        pOldString = pDriverInfo6->pConfigFile;

        pDriverInfo6->pConfigFile = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
        pOldString = NULL;
    }

    if( pDriverInfo6->pHelpFile &&
        FileNamePart( pDriverInfo6->pHelpFile ) == pDriverInfo6->pHelpFile )
    {
        pOldString = pDriverInfo6->pHelpFile;

        pDriverInfo6->pHelpFile = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
        pOldString = NULL;
    }

    if( pDriverInfo6->pDependentFiles )
    {
        pCurrentString = pDriverInfo6->pDependentFiles;

        while( *pCurrentString )
        {
            dwLength = lstrlen( pCurrentString );
            if( pCurrentString == FileNamePart( pCurrentString ) )
            {
                //
                // Amount needed - the two lengths + \ + 0
                //
                dwNeeded += dwLength + dwDirLength + 1 + 1;
            }
            else
            {
                //
                // Amount needed - the existing + 0
                //
                dwNeeded += dwLength + 1;
            }

            pCurrentString += dwLength + 1;
        }

        //
        // Increment for the final 0
        //
        dwNeeded++;

        if(pNewString = LocalAllocMem( dwNeeded*sizeof(TCHAR) ))
        {
            pCurrentString = pNewString;

            pOldString = pDriverInfo6->pDependentFiles;

            while( *pOldString )
            {
                if( pOldString == FileNamePart( pOldString ) )
                {
                    //
                    //  Add the directory info.
                    //
                    StringCchCopy( pCurrentString, dwNeeded - (pCurrentString - pNewString), pszDir );
                    pCurrentString += dwDirLength;
                    *pCurrentString++ = _TEXT('\\');
                }

                //
                // Add the existing file info.
                //
                StringCchCopy( pCurrentString, dwNeeded - (pCurrentString - pNewString), pOldString);

                pCurrentString += lstrlen( pOldString );
                *pCurrentString++ = 0;
                pOldString += lstrlen( pOldString ) + 1;
            }
            *pCurrentString = 0;

            LocalFreeMem( pDriverInfo6->pDependentFiles );

            pDriverInfo6->pDependentFiles = pNewString;

        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsSystemSetupInProgress(
        VOID
        )
/*++

Routine Description:
    Tells if we are in the middle of system setup (GUI mode)

Arguments:
    None

Return Value:
    TRUE if system setup in progress, FALSE else

--*/
{
    HKEY    hKey = NULL;
    DWORD   dwValue = 0, dwSize;

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       cszSystemSetupKey,
                                       0,
                                       KEY_READ,
                                       &hKey) ) {

        dwSize = sizeof(dwValue);
        if( ERROR_SUCCESS != RegQueryValueEx(hKey, cszSystemSetupInProgress, NULL, NULL,
                                             (LPBYTE)&dwValue, &dwSize) ) {
            dwValue = 0;
        }
        RegCloseKey(hKey);
    }

    return dwValue == 1;
}

/*

Function: GetMyTempDir

Purpose:  Creates a unique temporary directory off the TEMP directory.
          This gets called by UnCompressCat to create a unique directory to store the cat
          file that is to be expanded in.

Returns:  NULL if failed.  The full qualified path to the new directory otherwise.

Note:     The returned string does contain the ending '\'.

*/
LPTSTR
GetMyTempDir()
{
    LPTSTR pszPath      = NULL;
    PTCHAR pEnd;
    DWORD  dwSize       = 0;
    DWORD  dwActualSize = 0;
    DWORD  dwThreadID   = GetCurrentThreadId();
    DWORD  dwProcessID  = GetCurrentProcessId();
    DWORD  dwIDCounter  = dwThreadID;
    BOOL   bContinue    = TRUE;

    dwSize = GetTempPath( 0, pszPath );
    //
    // dwSize + size of the two DWORDs + \ + 0
    //
    dwActualSize = dwSize+MAX_DWORD_LENGTH*2+2;

    if( dwSize &&
        NULL != (pszPath = (LPTSTR)LocalAllocMem(dwActualSize*sizeof(TCHAR))))
    {
        //
        // If this fails, then we assume that someone is playing with the temp path at the instant that
        // we are requesting it - unlikely so just fail (worst effect = probably leads to driver signing warning)
        //
        if( dwSize >= GetTempPath( dwSize, pszPath ))
        {
            dwSize = lstrlen(pszPath);

            pEnd = &pszPath[lstrlen(pszPath)];

            do
            {
                StringCchPrintf( pEnd, dwActualSize-dwSize, _TEXT("%d%d%s"),
                            dwProcessID, dwIDCounter, _TEXT("\\") );

                if(CreateDirectory( pszPath, NULL ) || GetLastError() == ERROR_FILE_EXISTS)
                {
                    //
                    // We've got a directory, so drop out of loop.
                    //
                    bContinue = FALSE;
                }
                dwIDCounter++;

            //
            // Will stop loop when we have an unused directory or we loop round on the dwIDCounter
            //
            } while (bContinue && dwIDCounter != dwThreadID);

            if(bContinue)
            {
                LocalFreeMem( pszPath );
                pszPath = NULL;
            }
        }
        else
        {
            LocalFreeMem( pszPath );
            pszPath = NULL;
        }
    }

    return pszPath;
}

BOOL
GetOSVersion(
    IN     LPCTSTR        pszServerName,
    OUT    POSVERSIONINFO pOSVer
    )
{
    BOOL bRet = FALSE;

    if(pOSVer)
    {
        ZeroMemory(pOSVer,sizeof(OSVERSIONINFO));
        pOSVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if(!pszServerName || !*pszServerName)
        {
            bRet = GetVersionEx(pOSVer);
        }
        else
        {
            HANDLE hServer      = NULL;
            DWORD dwNeeded      = 0;
            DWORD dwType        = REG_BINARY;
            PRINTER_DEFAULTS Defaults = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            if( OpenPrinter( (LPTSTR) pszServerName, &hServer, &Defaults ) )
            {
                //
                // Get the os version from the remote spooler.
                //
                if( ERROR_SUCCESS == ( GetPrinterData( hServer,
                                                       SPLREG_OS_VERSION,
                                                       &dwType,
                                                       (PBYTE)pOSVer,
                                                       sizeof( OSVERSIONINFO ),
                                                       &dwNeeded ) ) )
                {
                    bRet = TRUE;
                }
                else
                {
                    //
                    // Assume that we're on NT4 as it doesn't support SPLREG_OS_VERSION
                    // at it's the only OS that doesn't that could land up in this remote code path.
                    //
                    ZeroMemory(pOSVer, sizeof(OSVERSIONINFO));

                    pOSVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                    pOSVer->dwMajorVersion      = 4;
                    pOSVer->dwMinorVersion      = 0;

                    bRet = TRUE;
                }

                ClosePrinter( hServer );
            }
        }
    }

    return bRet;
}

BOOL
GetArchitecture(
    IN     LPCTSTR   pszServerName,
    OUT    LPTSTR    pszArch,
    IN OUT LPDWORD   pcArchSize
    )
/*++

Routine Description:
    Obtains the local or remote server's architecture.

Arguments:
    pszServerName - NULL = local machine.
    pszArch       - will hold the machine's architecture.
    cArchSize     - IN  - size of pszArch in characters.
                    OUT - character count that was filled.
                          If failure is ERROR_MORE_DATA it will hold the needed character count.

Return Value:
    TRUE on success.

--*/
{
    BOOL  bRet        = FALSE;
    DWORD dwByteCount = 0;
    DWORD cLen        = 0;

    if( !pszArch )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }
    else
    {
        *pszArch = 0;

        if( !pszServerName || !*pszServerName )
        {
            cLen = _tcslen(PlatformEnv[MyPlatform].pszName);

            if( cLen <= *pcArchSize )
            {
                StringCchCopy( pszArch, *pcArchSize, PlatformEnv[MyPlatform].pszName );

                bRet = TRUE;
            }

            *pcArchSize = cLen;
        }
        else
        {
            HANDLE hServer  = NULL;
            DWORD dwNeeded  = 0;
            DWORD dwType    = REG_SZ;
            PRINTER_DEFAULTS Defaults = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            if( OpenPrinter( (LPTSTR) pszServerName, &hServer, &Defaults ) ) 
            {
                dwByteCount = *pcArchSize * sizeof( TCHAR );

                //
                // Get the os version from the remote spooler.
                //
                if((ERROR_SUCCESS == GetPrinterData(hServer,
                                                   SPLREG_ARCHITECTURE,
                                                   &dwType,
                                                   (PBYTE)pszArch,
                                                   dwByteCount,
                                                   &dwNeeded)) && (dwType == REG_SZ))
                {
                    bRet = TRUE;
                }
                else
                {
                    *pszArch = 0;
                }

                *pcArchSize = dwNeeded / sizeof(TCHAR);

                ClosePrinter( hServer );
            }
        }
    }

    return bRet;
}

BOOL IsInWow64()
//
// find out whether we're running in WOW64
//
{
    BOOL      bRet = FALSE;
    ULONG_PTR ul;
    NTSTATUS  st;


    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &ul,
                                   sizeof(ul),
                                   NULL);
    if (NT_SUCCESS(st))
    {
        //
        // If this call succeeds, we're on Win2000 or newer machines.
        //
        if (0 != ul)
        {
            //
            // 32-bit code running on Win64
            //
            bRet = TRUE;
        }
    }

    return bRet;
}


BOOL
IsWhistlerOrAbove(
    IN LPCTSTR pszServerName
    )
/*++

Routine Description:
    Determines whether the machine identified by ServerName is at least OS version 5.1

Arguments:
    pszServerName - the name of the remote server.  NULL means local machine.

Return Value:
    TRUE if the remote server is whistler or more recent server or local
    FALSE else

--*/

{
    OSVERSIONINFO OsVer = {0};
    BOOL bRet = FALSE;

    if (!pszServerName)
    {
        bRet = TRUE;
    }
    else if (GetOSVersion(pszServerName,&OsVer))
    {
        if( (OsVer.dwMajorVersion > 5) ||
            (OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion > 0) )
        {
            bRet = TRUE;
        }
    }

    return bRet;
}


HRESULT
IsProductType(
    IN BYTE ProductType,
    IN BYTE Comparison
    )
/*++

Routine Description:
    Determines whether the version of the OS is personal, professional or server
    depending on the given ProductType and Comparison

Arguments:
    ProductType - VER_NT_WORKSTATION or VER_NT_SERVER
    Comaprison  - VER_EQUAL, VER_GREATER, VER_GREATER_EQUAL, VER_LESS, VER_LESS_EQUAL

Return Value:
    S_OK if the OS version if the OS satisfies the given conditions
    S_FALSE else

--*/
{
    HRESULT             hRetval          = S_FALSE;
    OSVERSIONINFOEX     OsVerEx          = {0};
    ULONGLONG           dwlConditionMask = 0;

    OsVerEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVerEx.wProductType = ProductType;

    VER_SET_CONDITION( dwlConditionMask, VER_PRODUCT_TYPE, Comparison );

    if (VerifyVersionInfo(&OsVerEx, VER_PRODUCT_TYPE, dwlConditionMask))
    {
        hRetval = S_OK;
    }

    return hRetval;
}


HMODULE LoadLibraryUsingFullPath(
    LPCTSTR lpFileName
    )
{
    TCHAR szSystemPath[MAX_PATH];
    INT   cLength         = 0;
    INT   cFileNameLength = 0;


    if (!lpFileName || ((cFileNameLength = lstrlen(lpFileName)) == 0))
    {
        return NULL;
    }
    if (GetSystemDirectory(szSystemPath, SIZECHARS(szSystemPath) ) == 0)
    {
        return NULL;
    }
    cLength = lstrlen(szSystemPath);
    if (szSystemPath[cLength-1] != TEXT('\\'))
    {
        if ((cLength + 1) >= COUNTOF(szSystemPath))
        {
            return NULL;
        }
        szSystemPath[cLength]     = TEXT('\\');
        szSystemPath[cLength + 1] = TEXT('\0');
        cLength++;
    }
    if ((cLength + cFileNameLength) >= MAX_PATH)
    {
        return NULL;
    }
    StringCchCat(szSystemPath, COUNTOF(szSystemPath), lpFileName);

    return LoadLibrary( szSystemPath );
}

BOOL
IsSpoolerRunning(
    VOID
    )
{
    HANDLE ph;
    BOOL IsRunning = FALSE;

    if (OpenPrinter(NULL, &ph, NULL))
    {
        IsRunning = TRUE;
        ClosePrinter(ph);
    }

    return IsRunning;
}

BOOL
CheckAndKeepPreviousNames(
    IN  LPCTSTR          pszServer,
    IN  PDRIVER_INFO_6   pDriverInfo6,
    IN  PLATFORM         platform
)
{
    DWORD            dwNeeded         = 0;
    DWORD            dwReturned       = 0;
    DWORD            dwIndex          = 0;
    LPDRIVER_INFO_4  pCurDriverInfo   = NULL;
    BOOL             bRet             = FALSE;
    INT              cPrevNamesLength = 0;

    PLATFORM         Platform2Enumerate = pszServer ? platform : MyPlatform;

    if (pDriverInfo6 && pDriverInfo6->pName && 
        (*(pDriverInfo6->pName) == TEXT('\0')) )
    {
        goto Cleanup;
    }
    if ( !EnumPrinterDrivers((LPTSTR)pszServer,
                             PlatformEnv[Platform2Enumerate].pszName,
                             4,
                             (LPBYTE)pCurDriverInfo,
                             0,
                             &dwNeeded,
                             &dwReturned) ) 
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER        ||
             !(pCurDriverInfo = LocalAllocMem(dwNeeded))        ||
             !EnumPrinterDrivers((LPTSTR)pszServer,
                                 PlatformEnv[Platform2Enumerate].pszName,
                                 4,
                                 (LPBYTE)pCurDriverInfo,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned)                   ||
             (dwReturned <= 0)) 
        {
            goto Cleanup;
        }
    }
    if (!pCurDriverInfo) 
    {
        goto Cleanup;
    }
    for (dwIndex = 0; dwIndex < dwReturned; dwIndex++) 
    {
        if ((pCurDriverInfo+dwIndex)->pName &&
            (*(pCurDriverInfo+dwIndex)->pName != TEXT('\0')) &&
            !lstrcmp(pDriverInfo6->pName,(pCurDriverInfo+dwIndex)->pName) )
        {
            if ((pCurDriverInfo+dwIndex)->pszzPreviousNames &&
                (*(pCurDriverInfo+dwIndex)->pszzPreviousNames != TEXT('\0')))
            {
                cPrevNamesLength = lstrlen((pCurDriverInfo+dwIndex)->pszzPreviousNames);
                pDriverInfo6->pszzPreviousNames = (LPTSTR)LocalAllocMem( (cPrevNamesLength + 2) * sizeof(TCHAR) );
                if (pDriverInfo6->pszzPreviousNames) 
                {
                    bRet = TRUE;
                    CopyMemory( pDriverInfo6->pszzPreviousNames, (pCurDriverInfo+dwIndex)->pszzPreviousNames, cPrevNamesLength * sizeof(TCHAR) );
                    *(pDriverInfo6->pszzPreviousNames + cPrevNamesLength)     = TEXT('\0');
                    *(pDriverInfo6->pszzPreviousNames + cPrevNamesLength + 1) = TEXT('\0');
                }
                else
                {
                    bRet = FALSE;
                }
                goto Cleanup;
            }
        }
    }

Cleanup:

    if (pCurDriverInfo) 
    {
        LocalFreeMem(pCurDriverInfo);
    }
    return bRet;
}

BOOL
IsTheSamePlatform(
    IN LPCTSTR           pszServer,
    IN PLATFORM          platform

)
{
    BOOL  bRet                    = FALSE;
    DWORD dwServerArchSize        = 0;
    DWORD dwServerArchSizeInChars = 0;
    TCHAR *pszServerArchitecture  = NULL;

    if (!pszServer) 
    {
        bRet = TRUE;
        goto Cleanup;
    }
    dwServerArchSizeInChars = lstrlen( PlatformEnv[platform].pszName ) + 1;
    dwServerArchSize        = dwServerArchSizeInChars * sizeof(TCHAR);
    pszServerArchitecture   = LocalAllocMem(dwServerArchSize);
    if (!pszServerArchitecture ||
        !GetArchitecture(pszServer, pszServerArchitecture, &dwServerArchSizeInChars )) 
    {
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = !lstrcmp( pszServerArchitecture, PlatformEnv[platform].pszName );

Cleanup:

    if (pszServerArchitecture) 
    {
        LocalFreeMem( pszServerArchitecture );
    }
    return bRet;
}


LPTSTR 
GetArchitectureName(
    IN     LPCTSTR   pszServerName
)
{
    LPTSTR   pszArch    = NULL;
    DWORD    dwArchSize = 80;

    if (pszServerName && (*pszServerName == TEXT('\0')))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    if (!pszServerName) 
    {
        return AllocStr( PlatformEnv[MyPlatform].pszName );
    }
    pszArch = LocalAllocMem( dwArchSize * sizeof(TCHAR));
    if (!pszArch) 
    {
        return NULL;
    }

    if (!GetArchitecture( pszServerName, pszArch, &dwArchSize))
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            LocalFreeMem( pszArch );
            dwArchSize += 1;
            pszArch = LocalAllocMem( dwArchSize * sizeof(TCHAR) );
            if (!pszArch ||
                !GetArchitecture( pszServerName, pszArch, &dwArchSize)) 
            {
                return NULL;
            }
        }
    }
    return pszArch;
}

/************************************************************************************
** End of File (util.c)
************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win95.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Win95.c

Abstract:

    Routines for installing win95 driver files

Author:

    Muhunthan Sivapragasam (MuhuntS) 30-Nov-1995

Revision History:

--*/

#include "precomp.h"

const TCHAR cszPrtupg9x[]               = TEXT("prtupg9x.inf");
const TCHAR cszPrinterDriverMapping[]   = TEXT("Printer Driver Mapping");
const TCHAR cszPrinterDriverMappingNT[] = TEXT("Printer Driver Mapping WINNT");

void
CutLastDirFromPath(LPTSTR pszPath)
/*++

Routine Description:
    Cuts of the last directory from a path, e.g. c:\a\b\c\f.x -> c:\a\b\f.x

Arguments:
    pszPath  : the path to operate on

Return Value:
    none

--*/
{
    LPTSTR pLastWhack, pSecondButLastWhack;

    pLastWhack = _tcsrchr(pszPath, _T('\\'));
    if (!pLastWhack)
    {
       return;
    }

    *pLastWhack = 0;
    pSecondButLastWhack = _tcsrchr(pszPath, _T('\\'));
    if (!pSecondButLastWhack)
    {
       return;
    }

    StringCchCopy(pSecondButLastWhack+1, lstrlen(pLastWhack+1)+1, pLastWhack+1);
}

BOOL
CopyDriverFileAndModPath(LPTSTR pszPath)

/*++

Routine Description:
    Copies a driver file from the original location one dir up and modifies the
    path name accordingly

Arguments:
    pszPath  : the path of the file to copy and to operate on

Return Value:
    TRUE if OK, FALSE on error

--*/
{
    BOOL  bRes    = TRUE;
    TCHAR *pszTmp = NULL;

    if (!pszPath)
    {
        goto Cleanup; // nothing to copy
    }

    pszTmp = AllocStr( pszPath );
    if (!pszTmp) 
    {
        bRes = FALSE;
        goto Cleanup;
    }

    CutLastDirFromPath(pszPath);
    bRes = CopyFile(pszTmp, pszPath, FALSE);

Cleanup:
   
    LocalFreeMem( pszTmp );
    return bRes;
}

BOOL
CopyDependentFiles(LPTSTR pszzDepFiles)
/*++

Routine Description:
    Copies the dependent files one directory up and modifies the name buffers.

Arguments:
    pszzDepFiles  : the multi-sz string containing the pathes of the files to
                    copy and to operate on

Return Value:
    TRUE if OK, FALSE on error

--*/
{
    LPTSTR pCur = pszzDepFiles, pBuf = NULL, pCurCopy;
    DWORD  ccBufLen;
    BOOL   bRet = FALSE;

    if (pszzDepFiles == NULL)
    {
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // count the total length of the buffer
    //
    for (ccBufLen = 0;
         *(pszzDepFiles + ccBufLen) != 0;
         ccBufLen += _tcslen(pszzDepFiles + ccBufLen) + 1)
             ;

    ccBufLen +=2; // for the two terminating zeros

    pBuf = LocalAllocMem(ccBufLen * sizeof(TCHAR));
    if (!pBuf)
    {
         goto Cleanup;
    }


    //
    // go through the source buffer file by file, modify names and copy files
    //
    for (pCur = pszzDepFiles, pCurCopy = pBuf;
         *pCur != 0;
         pCur += _tcslen(pCur) +1, pCurCopy += _tcslen(pCurCopy) +1)
    {
        StringCchCopy(pCurCopy, ccBufLen - (pCurCopy - pBuf), pCur);
        CutLastDirFromPath(pCurCopy);
        if (!CopyFile(pCur, pCurCopy, FALSE))
        {
            goto Cleanup;
        }
    }

    if((DWORD)(pCurCopy - pBuf + 2) > ccBufLen)
    {
        goto Cleanup;
    }

    //
    // 00-terminate the new buffer
    //
    *pCurCopy = 0;
    *(++pCurCopy) = 0;

    //
    // copy it back - the new version is always shorter than the original
    //
    CopyMemory(pszzDepFiles, pBuf, (pCurCopy - pBuf + 1) * sizeof(TCHAR));

    bRet = TRUE;

Cleanup:
    if (pBuf)
    {
        LocalFreeMem(pBuf);
    }

    return bRet;
}

BOOL
SetPreviousNamesSection(LPCTSTR pszServer, LPCTSTR pszModelName,
                        LPCTSTR pszAddPrevName)

/*++

Routine Description:
    Adds a printer name to the list of previous names of a W2k/NT4 driver.
    This makes the driver usable under that name for point-and-print.
    To change the previous name section, do another call to AddPrinterDriver
    with all the files in place

Arguments:
    pszServer       : the machine we're operating on.
    pszModelName    : the model name of the native driver
    pszAddPrevName  : the name of the Win9x driver to be added to the previous
                      names entry.

Return Value:
    TRUE if OK, FALSE on error.

--*/
{
    PBYTE         pBuf = NULL;
    DRIVER_INFO_6 *pDrvInfo6 = NULL;
    DWORD         cbNeeded, cReceived, i, dwBufSize;
    BOOL          bRet = FALSE;
    LPTSTR        pTmp;
    TCHAR         pArch[MAX_PATH];

    //
    // previous names section only supported from Whistler upwards
    //
    if (!IsWhistlerOrAbove(pszServer))
    {
        bRet = TRUE;
        goto Cleanup;
    }

    cbNeeded = COUNTOF(pArch);

    if(!GetArchitecture( pszServer, pArch, &cbNeeded ))
    {
        StringCchCopy( pArch, COUNTOF(pArch), PlatformEnv[MyPlatform].pszName );
    }

    //
    // Check whether the name is different in the first place
    //
    if (!_tcscmp(pszModelName, pszAddPrevName))
    {
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // Get the DRIVER_INFO_6 of the W2k driver
    //
    EnumPrinterDrivers((LPTSTR) pszServer, pArch, 6, pBuf,
                        0, &cbNeeded, &cReceived);

    pBuf = LocalAllocMem(cbNeeded);
    if (!pBuf)
    {
        goto Cleanup;
    }

    if (!EnumPrinterDrivers((LPTSTR) pszServer, pArch, 6, pBuf,
                        cbNeeded, &cbNeeded, &cReceived))
    {
        goto Cleanup;
    }

    for (i = 0; i < cReceived ; i++)
    {
        pDrvInfo6 = (DRIVER_INFO_6 *) (pBuf + i*sizeof(DRIVER_INFO_6));
        if (!_tcscmp(pszModelName, pDrvInfo6->pName))
        {
            break;
        }
    }

    //
    // was the corresponding W2k driver found ?
    //
    if (i == cReceived)
    {
        //
        // Couldn't find the W2k driver to set the previous names section on.
        // This must be the AddPrinterDriver wizard, else there would be one. 
        // Just let the user install this driver.
        //
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // check whether the name to add is already in the list
    //
    if (pDrvInfo6->pszzPreviousNames)
    {
        for (pTmp = pDrvInfo6->pszzPreviousNames; *pTmp; pTmp += _tcslen(pTmp) +1)
        {
            if (!_tcscmp(pTmp, pszAddPrevName))
            {
                bRet = TRUE;
                goto Cleanup;
            }
        }
    }

    //
    // Copy all the files into the driver dir
    //
    if (!CopyDriverFileAndModPath(pDrvInfo6->pDriverPath) ||
        !CopyDriverFileAndModPath(pDrvInfo6->pConfigFile) ||
        !CopyDriverFileAndModPath(pDrvInfo6->pDataFile) ||
        !CopyDriverFileAndModPath(pDrvInfo6->pHelpFile) ||
        !CopyDependentFiles(pDrvInfo6->pDependentFiles))
    {
        goto Cleanup;
    }

    //
    // Modify the PreviousNames section.
    // No reallocation since string lives in the same buffer as the DrvInfo6 !
    // +2 for the psz terminating zero and the second zero for the whole
    //
    dwBufSize = (_tcslen(pszAddPrevName) + 2) * sizeof(TCHAR);
    pDrvInfo6->pszzPreviousNames = LocalAllocMem(dwBufSize);

    if (!pDrvInfo6->pszzPreviousNames)
    {
        goto Cleanup;
    }

    StringCbCopy(pDrvInfo6->pszzPreviousNames, dwBufSize, pszAddPrevName);

    //
    // write the driver info 6 back
    //
    bRet = AddPrinterDriver((LPTSTR) pszServer, 6, (LPBYTE) pDrvInfo6);

    LocalFreeMem (pDrvInfo6->pszzPreviousNames);
    pDrvInfo6->pszzPreviousNames = NULL;

Cleanup:
    if (pBuf)
    {
        LocalFreeMem (pBuf);
    }

    return bRet;
}

DWORD
InstallWin95Driver(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszModel,
    IN      LPCTSTR     pszzPreviousNames,
    IN      BOOL        bPreviousNamesSection,
    IN      LPCTSTR     pszServerName,
    IN  OUT LPTSTR      pszInfPath,
    IN      LPCTSTR     pszDiskName,
    IN      DWORD       dwInstallFlags,
    IN      DWORD       dwAddDrvFlags
    )
/*++

Routine Description:
    List all the printer drivers from Win95 INF files and install the
    printer driver selected by the user

Arguments:
    hwnd                    : Window handle that owns the UI
    pszModel                : Printer driver model
    pszzPreviousNames       : Multi-sz string giving other names for the driver
    bPreviousNamesSection   : If TRUE the NT inf had a Previous Names section
    pszServerName           : Server for which driver is to be installed
                                (NULL : local)
    pszInfPath              : Default path for inf. Prompt will have this name
                              for user
    pszDiskName             : Name of the disk to prompt for and use in title
    dwInstallFlags          : Installation flags given by caller
    dwAddDrvFlags           : Flags for AddPrinterDriverEx

Return Value:
    On succesfully installing files ERROR_SUCCESS, else the error code

--*/
{
    BOOL                bFreeDriverName=FALSE, bFirstTime=TRUE;
    DWORD               dwNeeded, dwRet = ERROR_CANCELLED;
    TCHAR               szTargetPath[MAX_PATH];
    LPDRIVER_INFO_6     pDriverInfo6 = NULL;
    PPSETUP_LOCAL_DATA  pLocalData = NULL;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;

Retry:
    //
    // If we get here second time that means default path has INFs but not the
    // model we are looking for. Ex. an OEM driver in the previous names section
    // that is not on Win2K CD. So make sure we prompt
    //
    if ( !bFirstTime )
    {
        dwInstallFlags |= DRVINST_ALT_PLATFORM_INSTALL;
        if (pszInfPath)
        {
            *pszInfPath = 0;
        }
    }

    hDevInfo = GetInfAndBuildDrivers(hwnd,
                                     IDS_DRIVERS_FOR_WIN95,
                                     IDS_PROMPT_ALT_PLATFORM_DRIVER,
                                     pszInfPath,
                                     dwInstallFlags, PlatformWin95, 0,
                                     NULL, NULL, NULL);

    if ( hDevInfo == INVALID_HANDLE_VALUE                       ||
         !SetSelectDevParams(hDevInfo, NULL, TRUE, pszModel) ) {

        goto Cleanup;
    }

    //
    // First look for an exact model match.
    //
    // If previous name is found then we will allow one retry since now we
    // have some previous names with no driver on CD (since it is an OEM driver)
    // If previous name is not found ask user to select a model
    //
    if ( !(pDriverInfo6 = Win95DriverInfo6FromName(hDevInfo,
                                                   &pLocalData,
                                                   pszModel,
                                                   pszzPreviousNames)) ) {

        if ( bPreviousNamesSection ) {

            if ( bFirstTime == TRUE ) {

                ASSERT(pLocalData == NULL);
                DestroyOnlyPrinterDeviceInfoList(hDevInfo);
                hDevInfo = INVALID_HANDLE_VALUE;
                bFirstTime = FALSE;
                goto Retry;
            }
        } 
        
        if ( (dwInstallFlags & DRVINST_PROMPTLESS) == 0)
        {
            PVOID       pDSInfo = NULL;   // Holds pointer to the driver signing class that C can't understand.
            HSPFILEQ    CopyQueue;
            SP_DEVINSTALL_PARAMS    DevInstallParams = {0};

            DevInstallParams.cbSize = sizeof(DevInstallParams);
            
            DestroyOnlyPrinterDeviceInfoList(hDevInfo);
            
            hDevInfo = CreatePrinterDeviceInfoList(hwnd);
            
            if ( hDevInfo == INVALID_HANDLE_VALUE                       ||
                 !SetDevInstallParams(hDevInfo, NULL, pszInfPath))
            {
                DWORD dwLastError;
                dwLastError = GetLastError();
                DestroyOnlyPrinterDeviceInfoList(hDevInfo);
                hDevInfo = INVALID_HANDLE_VALUE;
                SetLastError(dwLastError);
                goto Cleanup;
            }
            
            CopyQueue = SetupOpenFileQueue();
            if ( CopyQueue == INVALID_HANDLE_VALUE )
            {
                goto Cleanup;
            }

            //
            // associate the queue with the HDEVINFO
            //
            
            if ( SetupDiGetDeviceInstallParams(hDevInfo,
                                               NULL,
                                               &DevInstallParams) ) 
            {
                DevInstallParams.Flags |= DI_NOVCP;
                DevInstallParams.FileQueue = CopyQueue;

                SetupDiSetDeviceInstallParams(hDevInfo, NULL, &DevInstallParams);
            }
            
            if (NULL == (pDSInfo = SetupDriverSigning(hDevInfo, pszServerName, NULL,
                                         pszInfPath, PlatformWin95, 0, CopyQueue, FALSE)))
            {
                SetupCloseFileQueue(CopyQueue);
                goto Cleanup;
            }

            if ( BuildClassDriverList(hDevInfo)                          &&
                 PSetupSelectDriver(hDevInfo)                            &&                 
                 (pLocalData = BuildInternalData(hDevInfo, NULL))        &&
                 ParseInf(hDevInfo, pLocalData, PlatformWin95,
                            pszServerName, dwInstallFlags, FALSE) ) 
            {

                LPCTSTR pDriverName;

                pDriverInfo6 = CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                               pLocalData->InfInfo.cbDriverInfo6);
    
                //
                // if setup selected a "compatible" driver: 
                // pre-Whistler: rename the compatible driver to the requested model name
                // on Whistler: set the driver name to the compatible one and set the previous names section accordingly
                //
                if (IsWhistlerOrAbove(pszServerName))
                {
                    pDriverName = pLocalData->DrvInfo.pszModelName;
                }
                else
                {
                    pDriverName = pszModel;
                }
                
                if ( pDriverInfo6 && (pDriverInfo6->pName = AllocStr(pDriverName)) )
                {
                    bFreeDriverName = TRUE;
                }

            }
            //
            // disassociate the queue before deleting it
            //
            
            DevInstallParams.Flags    &= ~DI_NOVCP;
            DevInstallParams.FlagsEx  &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
            DevInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(hDevInfo, NULL, &DevInstallParams);

            SetupCloseFileQueue(CopyQueue);
            
            CleanupDriverSigning(pDSInfo);
        }
    }
    else if (lstrcmp(pDriverInfo6->pName, pszModel))
    {
        //
        // if the driver was selected because of an entry in the previous names section
        // then on anything before Whistler we need to rename the driver to the queue driver's name
        //
        if (!IsWhistlerOrAbove(pszServerName))
        {
            if (pDriverInfo6->pName = AllocStr(pszModel) )
            {
                bFreeDriverName = TRUE;
            }
        }
    }


    if ( !pDriverInfo6 || !pDriverInfo6->pName )
        goto Cleanup;

    pDriverInfo6->pEnvironment = PlatformEnv[PlatformWin95].pszName;


    //
    // For Win95 driver pszzPreviousNames does not make sense
    //
    ASSERT(pDriverInfo6->pszzPreviousNames == NULL);

    if ( GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                   pDriverInfo6->pEnvironment,
                                   1,
                                   (LPBYTE)szTargetPath,
                                   sizeof(szTargetPath),
                                   &dwNeeded)               &&
         CopyPrinterDriverFiles(pDriverInfo6,
                                pLocalData->DrvInfo.pszInfName,
                                pszInfPath,
                                pszDiskName,
                                szTargetPath,
                                hwnd,
                                dwInstallFlags,
                                TRUE)                       &&
         SetPreviousNamesSection(pszServerName, pszModel,
                                 (LPCTSTR) pLocalData->DrvInfo.pszModelName) &&
         AddPrinterDriverUsingCorrectLevel(pszServerName,
                                           pDriverInfo6,
                                           dwAddDrvFlags)
        )

    {
        dwRet = ERROR_SUCCESS;
    }


Cleanup:

    if (pLocalData)
    {
        DestroyLocalData(pLocalData);
        pLocalData = NULL;
    }

    if ( dwRet != ERROR_SUCCESS )
        dwRet = GetLastError();

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    if ( pDriverInfo6 ) {

        if ( bFreeDriverName )
        {
            LocalFreeMem(pDriverInfo6->pName);
            pDriverInfo6->pName = NULL;
        }

        PSetupDestroyDriverInfo3((LPDRIVER_INFO_3)pDriverInfo6);
    }

    CleanupScratchDirectory(pszServerName, PlatformWin95);
    CleanupScratchDirectory(pszServerName, PlatformX86);

    return dwRet;
}

/*++

Routine Name:

    PSetupFindMappedDriver
    
Routine Description:

    Find the remapped NT printer driver name for the given driver name. If the
    function does not find a remapped driver, it simply returns the name that was
    passed in. This looks in the [Printer Driver Mapping] and 
    [Printer Driver Mapping WINNT] sections of prtupg9x.inf.

Arguments:

    bWinNT                  -   If TRUE, find this from the WINNT section.
    pszDriverName           -   The driver name to be remapped.
    ppszRemappedDriverName  -   The remapped driver name, allocated and returned
                                to the caller. (Free with PSetupFreeMem).
    pbDriverFound           -   If TRUE, the driver was remapped. Otherwise, the
                                output is simpy a copy of the input.

Return Value:

    If there is an unexpected error, FALSE, otherwise TRUE. Last Error has the
    error code.

--*/
BOOL
PSetupFindMappedDriver(
    IN      BOOL        bWinNT,
    IN      LPCTSTR     pszDriverName,
        OUT LPTSTR      *ppszRemappedDriverName,
        OUT BOOL        *pbDriverFound
    )
{
    HINF        hInf                    = INVALID_HANDLE_VALUE;
    BOOL        bRet                    = FALSE;
    BOOL        bFound                  = FALSE;
    LPTSTR      pszRemappedDriverName   = NULL;
    INFCONTEXT  InfContext;
    TCHAR       szNtName[LINE_LEN];
    
    bRet = pszDriverName && ppszRemappedDriverName && pbDriverFound;

    if (ppszRemappedDriverName)
    {
        *ppszRemappedDriverName = NULL;
    }

    if (pbDriverFound)
    {
        *pbDriverFound = FALSE;
    }

    if (!bRet)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    //
    // Open PRTUPG9X.INF, it should be in the %windir%\inf directory.
    //
    if (bRet)
    {
        hInf = SetupOpenInfFile(cszPrtupg9x, NULL, INF_STYLE_WIN4, NULL);

        bRet = hInf != INVALID_HANDLE_VALUE;
    }

    //
    // Find the driver in the appropriate Printer Driver Mapping section of the
    // inf.
    //
    if (bRet)
    {
        bFound = SetupFindFirstLine(hInf, bWinNT ? cszPrinterDriverMappingNT : cszPrinterDriverMapping, pszDriverName, &InfContext);

        //
        // Get the name of the in-box driver.
        // 
        if (bFound)
        {
            bRet = SetupGetStringField(&InfContext, 1, szNtName, COUNTOF(szNtName), NULL);        
        }
        else if (ERROR_LINE_NOT_FOUND != GetLastError())
        {
            bRet = FALSE;
        }
    }

    //
    // If we found the driver, return it. Otherwise, just allocate and return the
    // string that was passed in.
    //
    if (bRet)
    {
        if (bFound)
        {
             pszRemappedDriverName = AllocStr(szNtName);

             *pbDriverFound = pszRemappedDriverName != NULL;
        }
        else
        {
            //
            // The remapped driver is not in the inf. Return the one we were passed in.
            //
            pszRemappedDriverName = AllocStr(pszDriverName);
        }

        bRet = pszRemappedDriverName != NULL;
    }

    if (bRet)
    {
        *ppszRemappedDriverName = pszRemappedDriverName;
        pszRemappedDriverName = NULL;
    }

    if (hInf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(hInf);
    }

    if (pszRemappedDriverName)
    {
        LocalFreeMem(pszRemappedDriverName);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\web.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    web.h

Abstract:

    Code download API definitions.

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-1995

Revision History:

--*/

#ifndef _WEB_H
#define _WEB_H

// Include the CDM defines & declares

typedef struct _CODEDOWNLOADINFO    {

    HMODULE     hModule;
    HANDLE      hConnection;
    cdecl HANDLE  (*pfnOpen)(HWND hwnd);
    cdecl BOOL    (*pfnDownload)(HANDLE         hConnection,
                                 HWND           hwnd,
                                 PDOWNLOADINFO  pDownloadInfo,
                                 LPTSTR         pszDownloadPath,
                                 UINT           uSize,
                                 PUINT          puNeeded);
    cdecl VOID    (*pfnClose)(HANDLE  hConnection);
} CODEDOWNLOADINFO, *PCODEDOWNLOADINFO;


#endif  // #ifndef _WEB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\upgrade.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Upgrade.c

Abstract:

    Code to upgrade printer drivers during system upgrade

Author:

    Muhunthan Sivapragasam (MuhuntS) 20-Dec-1995

Revision History:

--*/

#include "precomp.h"
#include <syssetup.h>
#include <regstr.h>

//
// Strings used  in PrintUpg.inf
//
TCHAR   cszUpgradeInf[]                 = TEXT("printupg.inf");
TCHAR   cszPrintDriverMapping[]         = TEXT("Printer Driver Mapping");
TCHAR   cszVersion[]                    = TEXT("Version");
TCHAR   cszExcludeSection[]             = TEXT("Excluded Driver Files");

TCHAR   cszSyssetupInf[]                = TEXT("layout.inf");
TCHAR   cszMappingSection[]             = TEXT("Printer Driver Mapping");
TCHAR   cszSystemServers[]              = TEXT("System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers\\");
TCHAR   cszSystemConnections[]          = TEXT("System\\CurrentControlSet\\Control\\Print\\Connections\\");
TCHAR   cszSoftwareServers[]            = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Providers\\LanMan Print Services\\Servers\\");
TCHAR   cszSoftwarePrint[]              = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print");
TCHAR   cszBadConnections[]             = TEXT("Bad Connections");
TCHAR   cszPrinters[]                   = TEXT("\\Printers\\");
TCHAR   cszDriver[]                     = TEXT("Printer Driver");
TCHAR   cszShareName[]                  = TEXT("Share Name");
TCHAR   cszConnections[]                = TEXT("\\Printers\\Connections");
TCHAR   cszSetupKey[]                   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
TCHAR   cszSourcePath[]                 = TEXT("SourcePath");

//
// What level info we wanted logged in setup log
//
LogSeverity    gLogSeverityLevel           = LogSevInformation;

//
// Define structure used to track printer drivers
// that need to be added via AddPrinterDriver().
//
typedef struct _DRIVER_TO_ADD {

    struct _DRIVER_TO_ADD  *pNext;
    PPSETUP_LOCAL_DATA      pLocalData;
    PLATFORM                platform;
} DRIVER_TO_ADD, *PDRIVER_TO_ADD;

typedef struct _DRIVER_TO_DELETE {

    struct _DRIVER_TO_DELETE   *pNext;
    LPTSTR                      pszDriverName;
    LPTSTR                      pszNewDriverName; // In box driver to replace
    LPTSTR                      pszEnvironment;
    DWORD                       dwVersion;
} DRIVER_TO_DELETE, *PDRIVER_TO_DELETE;

typedef struct _CONNECTION_TO_DELETE {

    struct _CONNECTION_TO_DELETE   *pNext;
    LPTSTR                          pszConnectionName;
} CONNECTION_TO_DELETE, *PCONNECTION_TO_DELETE;


//
// gpDriversToAdd list will have all the drivers we are trying to upgrade
//
PDRIVER_TO_ADD          gpDriversToAdd = NULL;
PDRIVER_TO_DELETE       gpBadDrvList = NULL;

// Forward Reference for recursive call

BOOL
PruneBadConnections(
    IN  PDRIVER_TO_DELETE  pBadDrivers
    );

VOID
DeleteRegKey(
    IN  HKEY      hRegKey,
    IN  LPTSTR    pszSubKey
    );

DWORD
DeleteCache(
    VOID
    );

VOID
LogError(
    IN  LogSeverity     Severity,
    IN  UINT            uMessageId,
    ...
    )
/*++

Routine Description:
    Logs an error in driver upgrade. We will do driver level error logging
    and not file level (ie. Faile to upgrade "HP Laser Jet 4" for Alpha
    instead of failure on RASDDUI.DLL for Alpha)

Arguments:

Return Value:
    None.

--*/
{
    LPTSTR      pszFormat;
    TCHAR       szMsg[1024];
    va_list     vargs;

    if ( Severity < gLogSeverityLevel )
        return;

    if ( pszFormat = GetStringFromRcFile(uMessageId) ) 
    {
        va_start(vargs, uMessageId);
        StringCchVPrintf(szMsg, SIZECHARS(szMsg), pszFormat, vargs);
        SetupLogError(szMsg, Severity);
        LocalFreeMem(pszFormat);
    }
    return;
}


VOID
AddEntryToDriversToAddList(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  LPBOOL              pbFail
    )
{
    PDRIVER_TO_ADD  pDriverToAdd;

    if ( *pbFail )
        return;

    pDriverToAdd = (PDRIVER_TO_ADD) LocalAllocMem(sizeof(DRIVER_TO_ADD));
    if ( !pDriverToAdd ) {

        *pbFail = TRUE;
        return;
    }

    pDriverToAdd->pLocalData    = pLocalData;
    pDriverToAdd->platform      = platform;
    pDriverToAdd->pNext         = gpDriversToAdd;
    gpDriversToAdd              = pDriverToAdd;
}


VOID
FreeDriversToAddList(
    )
/*++

Routine Description:
    Free drivers to add list

Arguments:
    None

Return Value:
    None.

--*/
{
    PDRIVER_TO_ADD  pCur, pNext;

    for ( pCur = gpDriversToAdd ; pCur ; pCur = pNext ) {

        pNext = pCur->pNext;
        DestroyLocalData(pCur->pLocalData);
        LocalFreeMem((PVOID)pCur);
    }

    gpDriversToAdd  = NULL;
}


VOID
AddEntryToDriversToDeleteList(
    IN      LPTSTR          pszDriverName,
    IN      LPTSTR          pszNewDriverName,
    IN      LPTSTR          pszEnvironment,
    IN      DWORD           dwVersion
    )
{
    PDRIVER_TO_DELETE   pDrvEntry;

    if ( pDrvEntry = (PDRIVER_TO_DELETE) LocalAllocMem(sizeof(DRIVER_TO_DELETE)) ) {

        pDrvEntry->pszDriverName        = pszDriverName;
        pDrvEntry->pszNewDriverName     = pszNewDriverName;
        pDrvEntry->pszEnvironment       = pszEnvironment;
        pDrvEntry->dwVersion            = dwVersion;
        pDrvEntry->pNext                = gpBadDrvList;
        gpBadDrvList                    = pDrvEntry;
    }
}


LPTSTR
ReadDigit(
    LPTSTR  ptr,
    LPWORD  pW
    )
{
    TCHAR   c;
    //
    // Skip spaces
    //
    while ( !iswdigit(c = *ptr) && c != TEXT('\0') )
        ++ptr;

    if ( c == TEXT('\0') )
        return NULL;

    //
    // Read field
    //
    for ( *pW = 0 ; iswdigit(c = *ptr) ; ++ptr )
        *pW = *pW * 10 + c - TEXT('0');

    return ptr;
}


HRESULT
StringToDate(
    LPTSTR          pszDate,
    SYSTEMTIME     *pInfTime
    )
{
    BOOL    bRet = FALSE;

    ZeroMemory(pInfTime, sizeof(*pInfTime));

    bRet = (pszDate = ReadDigit(pszDate, &(pInfTime->wMonth)))      &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wDay)))        &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wYear)));

    //
    // Y2K compatible check
    //
    if ( bRet && pInfTime->wYear < 100 ) {

        ASSERT(pInfTime->wYear >= 100);

        if ( pInfTime->wYear < 10 )
            pInfTime->wYear += 2000;
        else
            pInfTime->wYear += 1900;
    }

    if(!bRet)
    {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bRet? S_OK : GetLastErrorAsHResult();
}

BOOL
FindPathOnSource(
    IN      LPCTSTR     pszFileName,
    IN      HINF        MasterInf,
    IN OUT  LPTSTR      pszPathOnSource,
    IN      DWORD       dwLen,
    OUT     LPTSTR     *ppszMediaDescription,       OPTIONAL
    OUT     LPTSTR     *ppszTagFile                 OPTIONAL
    )
/*++

Routine Description:
    Find the path of a driver file for a specific platform in the installation
    directory

Arguments:
    pszFileName             : Name of the file to find source location
    MasterInf               : Handle to the master inf
    pszPathOnSource         : Pointer to string to build source path
    dwLen                   : Length of pszSourcePath
    ppszMediaDescription    : Optionally function will return media description
                                (caller should free memory)
    ppszTagFile             : Optionally function will return tagfile name
                                (caller should free memory)

Return Value:
    TRUE on succes, FALSE on error.

--*/
{
    UINT        DiskId;
    TCHAR       szRelativePath[MAX_PATH];
    DWORD       dwNeeded;

    if ( !SetupGetSourceFileLocation(
                        MasterInf,
                        NULL,
                        pszFileName,
                        &DiskId,
                        szRelativePath,
                        SIZECHARS(szRelativePath),
                        &dwNeeded)                                          ||
         !SetupGetSourceInfo(MasterInf,
                             DiskId,
                             SRCINFO_PATH,
                             pszPathOnSource,
                             dwLen,
                             &dwNeeded)                                     ||

         (DWORD)(lstrlen(szRelativePath) + lstrlen(pszPathOnSource) + 1) > dwLen ) {

        return FALSE;
    }

    StringCchCat(pszPathOnSource, dwLen, szRelativePath);

    if ( ppszMediaDescription ) {

        *ppszMediaDescription = NULL;

        if ( !SetupGetSourceInfo(MasterInf,
                                 DiskId,
                                 SRCINFO_DESCRIPTION,
                                 NULL,
                                 0,
                                 &dwNeeded)                                 ||
             !(*ppszMediaDescription = LocalAllocMem(dwNeeded * sizeof(TCHAR)))  ||
             !SetupGetSourceInfo(MasterInf,
                                DiskId,
                                SRCINFO_DESCRIPTION,
                                *ppszMediaDescription,
                                dwNeeded,
                                &dwNeeded) ) {

            LocalFreeMem(*ppszMediaDescription);
            *ppszMediaDescription = NULL;
            return FALSE;
        }
    }

    if ( ppszTagFile ) {

        *ppszTagFile = NULL;

        if ( !SetupGetSourceInfo(MasterInf,
                                 DiskId,
                                 SRCINFO_TAGFILE,
                                 NULL,
                                 0,
                                 &dwNeeded)                         ||
             !(*ppszTagFile = LocalAllocMem(dwNeeded * sizeof(TCHAR)))   ||
             !SetupGetSourceInfo(MasterInf,
                                DiskId,
                                SRCINFO_TAGFILE,
                                *ppszTagFile,
                                dwNeeded,
                                &dwNeeded) ) {

            if ( ppszMediaDescription )
            {
                LocalFreeMem(*ppszMediaDescription);
                *ppszMediaDescription = NULL;
            }
            LocalFreeMem(*ppszTagFile);
            *ppszTagFile = NULL;
            return FALSE;
        }
    }

    return TRUE;
}

VOID
BuildUpgradeInfoForDriver(
    IN      LPDRIVER_INFO_2 pDriverInfo2,
    IN      HDEVINFO        hDevInfo,
    IN      PLATFORM        platform,
    IN      HINF            PrinterInf,
    IN      HINF            UpgradeInf,
    IN OUT  HSPFILEQ        CopyQueue
    )
/*++

Routine Description:
    Given a printer driver name and a platform add a DRIVER_TO_ADD entry
    in the global list of drivers to add.

    The routine
        -- parses printer inf file to findout the DriverInfo3 info
           Note: driver files may change between versions
        -- finds out location of driver files from the master inf

Arguments:
    pDriverInfo2            - DriverInfo2 for the existing driver
    hDevInfo                - Printer class device information list
    platform                - Platform for which driver needs to be installed
    PrinterInf              - Printer inf file giving driver information
    UpgradeInf              - Upgrade inf file handle
    CopyQueue               - Setup CopyQueue to queue the files to be copied

Return Value:
    None. Errors will be logged

--*/
{
    BOOL                bFail                = FALSE;
    PPSETUP_LOCAL_DATA  pLocalData           = NULL;
    DWORD               BlockingStatus       = BSP_PRINTER_DRIVER_OK;
    LPTSTR              pszNewDriverName     = NULL;
    LPTSTR              pszDriverNameSaved   = NULL;
    LPTSTR              pszNewDriverNameSaved= NULL;
    LPTSTR              pszEnvironment       = NULL; 
    DWORD               dwVersion        = 0;

    
    if (!InfIsCompatibleDriver(pDriverInfo2->pName,
                               pDriverInfo2->pDriverPath,  // full path for main rendering driver dll
                               pDriverInfo2->pEnvironment,
                               UpgradeInf,       
                               &BlockingStatus,
                               &pszNewDriverName))
    {
        goto Cleanup;
    }
         
    if (BSP_PRINTER_DRIVER_BLOCKED == (BlockingStatus & BSP_BLOCKING_LEVEL_MASK)) {
        
        if(FAILED(GetPrinterDriverVersion(pDriverInfo2->pDriverPath, &dwVersion, NULL)))
        {
            goto Cleanup;
        }

        pszDriverNameSaved = AllocStr(pDriverInfo2->pName);
        if (!pszDriverNameSaved) 
        {
            goto Cleanup;
        }
        
        pszEnvironment     = AllocStr(pDriverInfo2->pEnvironment);
        if (!pszEnvironment) 
        {
            LocalFreeMem(pszDriverNameSaved);
            pszDriverNameSaved = NULL;
            goto Cleanup;
        }
       
        //
        // no replacement driver -> just delete the old one, do nothing else
        //
        if (!pszNewDriverName) 
        {
            AddEntryToDriversToDeleteList(pszDriverNameSaved, NULL, pszEnvironment, dwVersion);
            goto Cleanup;
        }

        pszNewDriverNameSaved = AllocStr(pszNewDriverName);           
        if (!pszNewDriverNameSaved) {
            LocalFreeMem(pszDriverNameSaved);
            LocalFreeMem(pszEnvironment);
            pszDriverNameSaved = NULL;
            pszEnvironment = NULL;
            goto Cleanup;
        }
        
        AddEntryToDriversToDeleteList(pszDriverNameSaved, pszNewDriverNameSaved, pszEnvironment, dwVersion);
        pLocalData = PSetupDriverInfoFromName(hDevInfo, pszNewDriverNameSaved);
    } 
       
    if ( pLocalData == NULL )
        pLocalData = PSetupDriverInfoFromName(hDevInfo, pDriverInfo2->pName);


    if ( !pLocalData || !ParseInf(hDevInfo, pLocalData, platform, NULL, 0, FALSE) ) {

        bFail = TRUE;
        goto Cleanup;
    }

    if ( SetTargetDirectories(pLocalData,
                              platform,
                              NULL,
                              PrinterInf,
                              0)                                &&
         SetupInstallFilesFromInfSection(PrinterInf,
                                         NULL,
                                         CopyQueue,
                                         pLocalData->InfInfo.pszInstallSection,
                                         NULL,
                                         0) ) {

        AddEntryToDriversToAddList(pLocalData, platform, &bFail);
    } else
        bFail = TRUE;

Cleanup:
    
    if (pszNewDriverName) {
        LocalFreeMem(pszNewDriverName);
    }

    if ( bFail ) {

        DestroyLocalData(pLocalData);
        //
        // Driver could be OEM so it is ok not to upgrade it
        //
        LogError(LogSevInformation, IDS_DRIVER_UPGRADE_FAILED, pDriverInfo2->pName);
    }
}


VOID
BuildUpgradeInfoForPlatform(
    IN      PLATFORM     platform,
    IN      HDEVINFO     hDevInfo,
    IN      HINF         MasterInf,
    IN      HINF         PrinterInf,
    IN      HINF         UpgradeInf,
    IN OUT  HSPFILEQ     CopyQueue
    )
/*++

Routine Description:
    Build the printer driver upgrade information for the platform

Arguments:
    platform                - Platform id
    hDevInfo                - Printer class device information list
    MasterInf               - Handle to master layout.inf
    PrinterInf              - Handle to printer inf (ntprint.inf)
    UpgradeInf              - Handle to upgrade inf (printupg.inf)
    CopyQueue               - Setup CopyQueue to queue the files to be copied

Return Value:
    None. Errors will be logged

--*/
{
    DWORD               dwLastError, dwNeeded, dwReturned;
    LPBYTE              p = NULL;
    LPDRIVER_INFO_2     pDriverInfo2;

    if ( EnumPrinterDrivers(NULL,
                            PlatformEnv[platform].pszName,
                            2,
                            NULL,
                            0,
                            &dwNeeded,
                            &dwReturned) ) {

        //
        // Success no installed printer drivers for this platform
        //
        goto Cleanup;
    }

    dwLastError = GetLastError();
    if ( dwLastError != ERROR_INSUFFICIENT_BUFFER ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("EnumPrinterDrivers"), dwLastError);
        goto Cleanup;
    }

    p = LocalAllocMem(dwNeeded);
    if ( !p ||
         !EnumPrinterDrivers(NULL,
                             PlatformEnv[platform].pszName,
                             2,
                             p,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("EnumPrinterDrivers"), dwLastError);
        goto Cleanup;
    }

    if ( !SetupSetPlatformPathOverride(PlatformOverride[platform].pszName) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("SetupSetPlatformPathOverride"), dwLastError);
        goto Cleanup;
    }

    for ( dwNeeded = 0, pDriverInfo2 = (LPDRIVER_INFO_2) p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pDriverInfo2 ) {

        //
        // ICM files need to be copied once only, for native architecture ..
        //
        BuildUpgradeInfoForDriver(pDriverInfo2,
                                  hDevInfo,
                                  platform,
                                  PrinterInf,
                                  UpgradeInf,
                                  CopyQueue);
    }

Cleanup:

    if ( p )
        LocalFreeMem(p);
}


VOID
InstallInternetPrintProvider(
    VOID
    )
/*++

Routine Description:
    Installs internet print provider on upgrade

Arguments:
    None

Return Value:
    None. Errors will be logged

--*/
{
    PROVIDOR_INFO_1     ProviderInfo1;


    ProviderInfo1.pName         = TEXT("Internet Print Provider");
    ProviderInfo1.pEnvironment  = NULL;
    ProviderInfo1.pDLLName      = TEXT("inetpp.dll");

    if ( !AddPrintProvidor(NULL, 1, (LPBYTE)(&ProviderInfo1)) )
        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("AddPrintProvidor"), GetLastError());

    return;
}

BOOL
KeepPreviousName(
    IN      PDRIVER_INFO_4 pEnumDrvInfo, 
    IN      DWORD          dwCount,
    IN OUT  PDRIVER_INFO_6 pCurDrvInfo
)
/*++

Routine Description:
    Modifies the DRIVER_INFO_6 of a driver to upgrade to keep the previous names setting
    of the old driver.

Arguments:
    PDRIVER_INFO_4  the array of DRIVER_INFO_4s of the installed drivers
    DWORD           number of entries in the array
    PDRIVER_INFO_6  the DRIVER_INFO_6 structure of the driver that is going to be upgraded

Return Value:
    TRUE if the previous names section was changed, FALSE if not

--*/
{
    PDRIVER_INFO_4  pCur;
    DWORD           dwIndex;
    BOOL            Changed = FALSE;

    //
    // search the current driver in the enumerated ones
    //
    for (dwIndex = 0; dwIndex < dwCount ; dwIndex++)
    {
        pCur = pEnumDrvInfo + dwIndex;

        if (!lstrcmp(pCur->pName, pCurDrvInfo->pName))
        {
            //
            // if the previous PreviousNames is not NULL/empty: set the new one to
            // the old one. I can do without additional buffers because I keep the
            // enumerated buffer around till I'm done.
            //
            if (pCur->pszzPreviousNames && *pCur->pszzPreviousNames)
            {
                pCurDrvInfo->pszzPreviousNames = pCur->pszzPreviousNames;
                Changed = TRUE;
            }
            break;
        }
    }

    return Changed;
}
    
VOID
ProcessPrinterDrivers(
    )
/*++

Routine Description:
    Process printer drivers for upgrade

Arguments:
    None

Return Value:
    None. Errors will be logged

--*/
{
    PDRIVER_TO_ADD      pCur, pNext;
    DWORD               dwNeeded, dwReturned;
    PDRIVER_INFO_4      pEnumDrv = NULL;

    //
    // Enumerate all the installed drivers. We need that later on to check for whether a 
    // previous names entry was set.
    //
    if ( !EnumPrinterDrivers(NULL,
                         PlatformEnv[MyPlatform].pszName,
                         4,
                         NULL,
                         0,
                         &dwNeeded,
                         &dwReturned) ) 
    {


        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER            ||
             !(pEnumDrv = (PDRIVER_INFO_4) LocalAllocMem(dwNeeded)) ||
             !EnumPrinterDrivers(NULL,
                                 PlatformEnv[MyPlatform].pszName,
                                 4,
                                 (LPBYTE) pEnumDrv,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned) ) 
        {
            //
            // I do not want to stop the upgrade of printer drivers just because I can't 
            // keep the previous names
            //
            if (pEnumDrv)
            {
                LocalFreeMem(pEnumDrv);
                pEnumDrv   = NULL;
                dwReturned = 0;
            }
        }
    }
    

    for ( pCur = gpDriversToAdd ; pCur ; pCur = pNext ) {

        pNext = pCur->pNext;
        pCur->pLocalData->InfInfo.DriverInfo6.pEnvironment
                    = PlatformEnv[pCur->platform].pszName;
        
        //
        // keep previous names if set
        //
        if (pEnumDrv)
        {
            KeepPreviousName(pEnumDrv, dwReturned, &pCur->pLocalData->InfInfo.DriverInfo6);
        }

        if ( !AddPrinterDriver(NULL,
                               6,
                               (LPBYTE)&pCur->pLocalData->InfInfo.DriverInfo6)  ||
             !PSetupInstallICMProfiles(NULL,
                                       pCur->pLocalData->InfInfo.pszzICMFiles) ) {

            LogError(LogSevWarning, IDS_DRIVER_UPGRADE_FAILED,
                     pCur->pLocalData->InfInfo.DriverInfo6.pName);
        }
    }

    LocalFreeMem((PVOID) pEnumDrv);
}


VOID
ProcessBadOEMDrivers(
    )
/*++

Routine Description:
    Kill the bad OEM drivers so that they do not cause problems after upgrade

Arguments:

Return Value:
    None. Errors will be logged

--*/
{
    PDRIVER_TO_DELETE   pCur, pNext;

    PruneBadConnections( gpBadDrvList );

    for ( pCur = gpBadDrvList ; pCur ; pCur = pNext ) {

        pNext = pCur->pNext;

        DeletePrinterDriverEx(NULL,
                              pCur->pszEnvironment,
                              pCur->pszDriverName,
                              DPD_DELETE_SPECIFIC_VERSION
                                    | DPD_DELETE_UNUSED_FILES,
                              pCur->dwVersion);

        LocalFreeMem(pCur->pszDriverName);
        LocalFreeMem(pCur->pszNewDriverName);
        LocalFreeMem(pCur->pszEnvironment);
        LocalFreeMem(pCur);
    }
}


PPSETUP_LOCAL_DATA
FindLocalDataForDriver(
    IN  LPTSTR  pszDriverName
    )
/*++

Routine Description:
    Given a driver name find the local data for local platform for that driver

Arguments:
    pszDriverName   : Name of the printer driver we are looking for

Return Value:
    NULL if one is not found, otherwise pointer to PSETUP_LOCAL_DATA

--*/
{
    PDRIVER_TO_ADD  pCur;

    for ( pCur = gpDriversToAdd ; pCur ; pCur = pCur->pNext ) {

        if ( pCur->platform == MyPlatform   &&
             !lstrcmpi(pCur->pLocalData->InfInfo.DriverInfo6.pName,
                       pszDriverName) )
            return pCur->pLocalData;
    }

    return NULL;
}


VOID
ProcessPrintQueues(
    IN  HDEVINFO    hDevInfo,
    IN  HINF        PrinterInf,
    IN  HINF        MasterInf
    )
/*++

Routine Description:
    Process per printer upgrade for each print queue

Arguments:
    hDevInfo    - Printer class device information list
    MasterInf   - Handle to master layout.inf
    PrinterInf  - Handle to printer inf (ntprint.info)

Return Value:
    None. Errors will be logged

--*/
{
    LPBYTE              pBuf=NULL;
    DWORD               dwNeeded, dwReturned, dwRet, dwDontCare;
    HANDLE              hPrinter;
    LPTSTR              pszDriverName;
    LPPRINTER_INFO_2    pPrinterInfo2;
    PPSETUP_LOCAL_DATA  pLocalData;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    PDRIVER_TO_DELETE   pDrv;


    //
    // If no printers installed return
    //
    if ( EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      2,
                      NULL,
                      0,
                      &dwNeeded,
                      &dwReturned) ) {

        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = LocalAllocMem(dwNeeded))                   ||
         !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       &dwReturned) ) {

        LocalFreeMem(pBuf);
        LogError(LogSevError, IDS_UPGRADE_FAILED, TEXT("EnumPrinters"),
                 GetLastError());
        return;
    }

    for ( pPrinterInfo2 = (LPPRINTER_INFO_2)pBuf, dwNeeded = 0 ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pPrinterInfo2 ) {

        if ( !OpenPrinter(pPrinterInfo2->pPrinterName, &hPrinter, &PrinterDefault) ) {

            LogError(LogSevError, IDS_PRINTER_UPGRADE_FAILED,
                     pPrinterInfo2->pPrinterName, TEXT("OpenPrinter"),
                     GetLastError());
            continue;
        }

        pszDriverName = pPrinterInfo2->pDriverName;

        //
        // ISSUE-2002/03/22-mikaelho
        // We never check if the driver has the same environment as
        // the printer queue - that is LOCAL_ENVIRONMENT. This means
        // that we might delete the printer queue based on a bad additional
        // driver, rather than just deleting the additional driver.
        // Right now however we only enumerate drivers of local environment
        // so no big deal. Check NTRAID marker 2002/03/14 in this file for
        // more info.
        //

        //
        // See if this is in the bad driver list
        //
        for ( pDrv = gpBadDrvList ; pDrv ; pDrv = pDrv->pNext )
            if ( !lstrcmpi(pPrinterInfo2->pDriverName, pDrv->pszDriverName) )
                break;

        //
        // If this printer is using a bad OEM driver need to fix it
        //
        if ( pDrv ) {

            if ( pDrv->pszNewDriverName && *pDrv->pszNewDriverName ) {

                pszDriverName = pDrv->pszNewDriverName;
                pPrinterInfo2->pDriverName = pszDriverName;

                if ( SetPrinter(hPrinter, 2, (LPBYTE)pPrinterInfo2, 0) ) {

                    LogError(LogSevWarning, IDS_DRIVER_CHANGED,
                             pPrinterInfo2->pPrinterName);
                }
            } else {

                if ( DeletePrinter(hPrinter) ) {

                    LogError(LogSevError,
                             IDS_PRINTER_DELETED,
                             pPrinterInfo2->pPrinterName,
                             pPrinterInfo2->pDriverName);
                }
                ClosePrinter(hPrinter);
                continue; // to next printer
            }
        }

        pLocalData = FindLocalDataForDriver(pszDriverName);

        dwRet =  EnumPrinterDataEx(hPrinter,
                                   TEXT("CopyFiles\\ICM"),
                                   NULL,
                                   0,
                                   &dwDontCare,
                                   &dwDontCare);

        if ( pLocalData )
        {
            (VOID)SetPnPInfoForPrinter(hPrinter,
                                       NULL, // Don't set PnP id during upgrade
                                       NULL,
                                       pLocalData->DrvInfo.pszManufacturer,
                                       pLocalData->DrvInfo.pszOEMUrl);
        }

        ClosePrinter(hPrinter);

        //
        // If the CopyFiles\ICM key is already found then ICM has already
        // been used with this printer (i.e. we are upgrading a post NT4
        // machine). Then we want to leave the settings the user has chosen
        //
        if ( dwRet != ERROR_FILE_NOT_FOUND )
            continue;

        if ( pLocalData && pLocalData->InfInfo.pszzICMFiles ) {

            (VOID)PSetupAssociateICMProfiles(pLocalData->InfInfo.pszzICMFiles,
                                             pPrinterInfo2->pPrinterName);
        }
    }
    LocalFreeMem(pBuf);
}

VOID
ClearPnpReinstallFlag(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData)
{
    DWORD dwReturn, dwConfigFlags, cbRequiredSize, dwDataType = REG_DWORD;

    //
    // get the config flags
    //
    dwReturn = SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                pDevInfoData,
                                                SPDRP_CONFIGFLAGS,
                                                &dwDataType,
                                                (PBYTE) &dwConfigFlags,
                                                sizeof(dwConfigFlags),
                                                &cbRequiredSize) ? 
                                                    (REG_DWORD == dwDataType ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER) 
                                                    : GetLastError();                   

    if ((ERROR_SUCCESS == dwReturn) && (dwConfigFlags & CONFIGFLAG_REINSTALL)) 
    {
        //
        // clear to flag to make setupapi not install this device on first boot
        //
        dwConfigFlags &= ~CONFIGFLAG_REINSTALL;

        dwReturn = SetupDiSetDeviceRegistryProperty(hDevInfo,
                                                    pDevInfoData,
                                                    SPDRP_CONFIGFLAGS,
                                                    (PBYTE) &dwConfigFlags,
                                                    sizeof(dwConfigFlags)) ? 
                                                        ERROR_SUCCESS : GetLastError();
    }
}

BOOL
IsInboxInstallationRequested(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData)
{
    SP_DEVINFO_DATA DevData   = {0};
    DWORD           IsInbox   = 0;
    DWORD           dwBufSize = sizeof(IsInbox);
    DWORD           dwType    = REG_DWORD;
    HKEY            hKey;

    //
    // open the dev reg key and get the rank
    //
    hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);
    if (hKey != INVALID_HANDLE_VALUE)
    {
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, cszBestDriverInbox, NULL, &dwType, (LPBYTE) &IsInbox, &dwBufSize))
        {
            IsInbox = 0;
        }
    
        RegCloseKey(hKey);
    }

    return IsInbox ? TRUE : FALSE;
}

VOID    
ProcessPnpReinstallFlags(HDEVINFO hDevInfo)
{
    LPBYTE              pBuf = NULL;
    DWORD               dwNeeded, dwReturned, dwDontCare;
    HANDLE              hPrinter;
    LPPRINTER_INFO_2    pPrinterInfo2;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    TCHAR               szDeviceInstanceId[MAX_PATH];
    DWORD               dwType = REG_DWORD;
    SP_DEVINFO_DATA     DevData = {0};

    
    //
    // If no printers installed return
    //
    if ( EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      2,
                      NULL,
                      0,
                      &dwNeeded,
                      &dwReturned) ) {

        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = LocalAllocMem(dwNeeded))                   ||
         !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       &dwReturned) ) {

        LocalFreeMem(pBuf);
        pBuf = NULL;
        LogError(LogSevError, IDS_UPGRADE_FAILED, TEXT("EnumPrinters"),
                 GetLastError());
        return;
    }
   
    for ( pPrinterInfo2 = (LPPRINTER_INFO_2)pBuf, dwNeeded = 0 ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pPrinterInfo2 ) {

        if ( !OpenPrinter(pPrinterInfo2->pPrinterName, &hPrinter, &PrinterDefault) ) {

            LogError(LogSevError, IDS_PRINTER_UPGRADE_FAILED,
                     pPrinterInfo2->pPrinterName, TEXT("OpenPrinter"),
                     GetLastError());
            continue;
        }

        //
        // Get the device instance ID
        //
        if ((GetPrinterDataEx( hPrinter,
                               cszPnPKey,
                               cszDeviceInstanceId,
                               &dwType,
                               (LPBYTE) szDeviceInstanceId,
                               sizeof(szDeviceInstanceId),
                               &dwDontCare
                               ) == ERROR_SUCCESS) && (dwType == REG_SZ))
        {
            DevData.cbSize = sizeof(DevData);

            //
            // get the devnode
            //
            if (SetupDiOpenDeviceInfo(hDevInfo, szDeviceInstanceId, INVALID_HANDLE_VALUE, 0, &DevData))
            {
                //
                // if the driver that pnp wanted to install in the first place is an IHV driver, delete the
                // CONFIGFLAG_REINSTALL. That information was stored during the DIF_ALLOW_INSTALL
                // that we fail during the first phase of GUI mode setup. We want a reinstallation
                // happening in case of inbox so we replace the unsigned driver with an inbox driver and
                // and Pnp is happy because we don't switch out drivers behind their backs.
                // Side effect is that drivers that require user interaction (vendor setup or 
                // multiple Pnp matches) will require that once more after the upgrade.
                //
                if (!IsInboxInstallationRequested(hDevInfo, &DevData))
                {
                    ClearPnpReinstallFlag( hDevInfo, &DevData);
                }
            }
        }

        ClosePrinter(hPrinter);
    }
    
    LocalFreeMem(pBuf);
}

BOOL
OpenServerKey(
    OUT PHKEY  phKey
    )
{
   // Open the Servers Key
   if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSoftwareServers, 0,
                                      KEY_READ, phKey) )
   {
      return TRUE;
   }
   else if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSystemServers, 0,
                                      KEY_READ, phKey) )
   {
      return TRUE;
   }
   else
      return FALSE;
}

BOOL
OpenPrintersKey(
    IN  DWORD     dwIndex,
    IN  HKEY      hInKey,
    OUT LPTSTR*   ppszServerName,
    OUT PHKEY     phOutKey
    )
{
   BOOL  bRC = TRUE;
   DWORD dwSrvSize, dwSrvRC, dwPrnLen, dwPrnRC;
   LPTSTR pszSrvPrnKey = NULL;
   TCHAR szServerName[MAX_PATH+1];

   // If we have a current ServerName free it
   if ( *ppszServerName )
   {
      LocalFreeMem( *ppszServerName );
      *ppszServerName = NULL;
   }
   if ( *phOutKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey(*phOutKey);
      *phOutKey = INVALID_HANDLE_VALUE;
   }

   dwSrvSize = COUNTOF(szServerName);
   dwSrvRC = RegEnumKey( hInKey,
                         dwIndex,
                         szServerName,
                         dwSrvSize );
   if ( dwSrvRC == ERROR_SUCCESS )
   {
      // Save the ServerName to return
      *ppszServerName = AllocStr( szServerName );
      if (!*ppszServerName)
         return FALSE;

      // Now Open the Printers key under ServerName
      dwPrnLen = lstrlen( szServerName ) + lstrlen( cszPrinters ) + 2;
      pszSrvPrnKey = (LPTSTR) LocalAllocMem( dwPrnLen * sizeof(TCHAR) );
      if ( pszSrvPrnKey )
      {
         // Build the next key name
         StringCchCopy( pszSrvPrnKey, dwPrnLen, szServerName );
         StringCchCat(  pszSrvPrnKey, dwPrnLen, cszPrinters );
      }
      else
         return FALSE;

      dwPrnRC = RegOpenKeyEx( hInKey, pszSrvPrnKey, 0,
                              KEY_READ, phOutKey );
      bRC = ( dwPrnRC == ERROR_SUCCESS );
   }
   else if ( dwSrvRC != ERROR_NO_MORE_ITEMS )
      bRC = FALSE;

   if ( pszSrvPrnKey )
      LocalFreeMem( pszSrvPrnKey );

   return bRC;
}

BOOL
GetConnectionInfo(
   IN  DWORD      dwIndex,
   IN  HKEY       hKey,
   OUT LPTSTR*    ppszConnectionName,
   OUT LPTSTR*    ppszDriverName,
   OUT LPTSTR*    ppszShareName
   )
{
   // Now enum the Connection Names
   BOOL bRC = FALSE;
   TCHAR   szConnectionName[MAX_PATH+1];
   DWORD   dwConnSize, dwConnRC, dwPrinterIndex;

   if ( *ppszConnectionName )
   {
      LocalFreeMem( *ppszConnectionName );
      *ppszConnectionName = NULL;
   }
   if ( *ppszDriverName )
   {
      LocalFreeMem( *ppszDriverName );
      *ppszDriverName = NULL;
   }

   if ( *ppszShareName )
   {
      LocalFreeMem( *ppszShareName );
      *ppszShareName = NULL;
   }

   dwConnSize = COUNTOF( szConnectionName );
   dwConnRC = RegEnumKey( hKey,
                          dwIndex,
                          szConnectionName,
                          dwConnSize );
   if ( dwConnRC == ERROR_SUCCESS )
   {
      // Now Get the Driver Model
      HKEY   hConnectionKey = INVALID_HANDLE_VALUE;

      // Save the COnnection Name
      *ppszConnectionName = AllocStr( szConnectionName );

      if (*ppszConnectionName && ( ERROR_SUCCESS == RegOpenKeyEx( hKey, szConnectionName, 0,
                                                                  KEY_READ, &hConnectionKey) ))
      {
         DWORD dwSize, dwType, dwLastPos;
         // Get the buffer size for the Driver Name
         if ( ERROR_SUCCESS == RegQueryValueEx(hConnectionKey, cszDriver, NULL,
                                               &dwType, NULL, &dwSize) )
         {
            *ppszDriverName = (LPTSTR) LocalAllocMem( dwSize );
            if (*ppszDriverName) 
            {
                dwLastPos = (dwSize/sizeof(TCHAR)) - 1;
                if ( ( ERROR_SUCCESS == RegQueryValueEx(hConnectionKey, cszDriver, NULL,
                                                        &dwType, (LPBYTE) *ppszDriverName,
                                                        &dwSize) ) )
                {
                    bRC = TRUE;
                }
                (*ppszDriverName)[dwLastPos] = TEXT('\0');
            }
         }

         // Get the buffer size for the Share Name
         if ( bRC && ( ERROR_SUCCESS == RegQueryValueEx( hConnectionKey, cszShareName, NULL,
                                                         &dwType, NULL, &dwSize) ) )
         {
            *ppszShareName = (LPTSTR) LocalAllocMem( dwSize );
            if (*ppszShareName) 
            {
                dwLastPos = (dwSize/sizeof(TCHAR)) - 1;
                if ( ( ERROR_SUCCESS != RegQueryValueEx(hConnectionKey, cszShareName, NULL,
                                                        &dwType, (LPBYTE) *ppszShareName,
                                                        &dwSize) ) )
                {
                    bRC = FALSE;
                }
                (*ppszShareName)[dwLastPos] = TEXT('\0');
            }
            else
            {
                bRC = FALSE;
            }
         }
         else
         {
             bRC = FALSE;
         }
         RegCloseKey( hConnectionKey );
      }
   }
   else if ( dwConnRC == ERROR_NO_MORE_ITEMS )
   {
       bRC = TRUE;
   }

   return bRC;
}

BOOL
IsDriverBad(
    IN  LPTSTR             pszDriverName,
    IN  PDRIVER_TO_DELETE  pCurBadDriver
    )
{
   BOOL bFound = FALSE;

   while ( !bFound && pCurBadDriver )
   {
      //
      // The function is called to determine if a printer connection is using a
      // bad driver and since the client side only has printer driver for the
      // local environment we only have to check this.  
      //
      if ( !lstrcmpi( pszDriverName,     pCurBadDriver->pszDriverName ) &&
           !lstrcmpi( LOCAL_ENVIRONMENT, pCurBadDriver->pszEnvironment) )
         bFound = TRUE;
      else
         pCurBadDriver = pCurBadDriver->pNext;
   }

   return bFound;
}

VOID
AddToBadConnList(
    IN  LPTSTR             pszServerName,
    IN  LPTSTR             pszConnectionName,
    OUT PCONNECTION_TO_DELETE *ppBadConnections
    )
{
   // Allocate space for the Struct & String
   DWORD dwAllocSize, dwStrLen;
   LPTSTR pszSrvConn;
   PCONNECTION_TO_DELETE pBadConn;

   dwStrLen = lstrlen(pszServerName) + lstrlen(pszConnectionName) + 4;
   dwAllocSize = sizeof(CONNECTION_TO_DELETE) + ( dwStrLen * sizeof(TCHAR) );
   pBadConn = (PCONNECTION_TO_DELETE) LocalAllocMem( dwAllocSize );
   if ( pBadConn )
   {
      pszSrvConn = (LPTSTR) (pBadConn+1);
      StringCbCopy( pszSrvConn, dwAllocSize-sizeof(CONNECTION_TO_DELETE), TEXT(",,") );
      StringCbCat(  pszSrvConn, dwAllocSize-sizeof(CONNECTION_TO_DELETE), pszServerName );
      StringCbCat(  pszSrvConn, dwAllocSize-sizeof(CONNECTION_TO_DELETE), TEXT(",") );
      StringCbCat(  pszSrvConn, dwAllocSize-sizeof(CONNECTION_TO_DELETE), pszConnectionName );

      pBadConn->pszConnectionName = pszSrvConn;
      pBadConn->pNext = *ppBadConnections;
      *ppBadConnections = pBadConn;
   }
}

VOID
DeleteSubKeys(
    IN  HKEY      hRegKey
    )
{
   BOOL  bContinue = TRUE;
   DWORD dwIndex, dwSize, dwRC;
   TCHAR szSubKeyName[MAX_PATH];
   dwIndex = 0;
   do
   {
      dwSize = COUNTOF(szSubKeyName);
      dwRC = RegEnumKey( hRegKey,
                         dwIndex,
                         szSubKeyName,
                         dwSize );
      if ( dwRC == ERROR_SUCCESS )
         DeleteRegKey( hRegKey, szSubKeyName );
      else if ( dwRC != ERROR_NO_MORE_ITEMS )
         bContinue = FALSE;
   }
   while ( bContinue && ( dwRC != ERROR_NO_MORE_ITEMS ) );
}

VOID
DeleteRegKey(
    IN  HKEY      hRegKey,
    IN  LPTSTR    pszSubKey
    )
{
   HKEY hSubKey;
   // First Open the SubKey
   if ( ERROR_SUCCESS == RegOpenKeyEx(hRegKey,
                                      pszSubKey,
                                      0,
                                      KEY_READ,
                                      &hSubKey) )
   {
       DeleteSubKeys( hSubKey );
       RegCloseKey( hSubKey );
   }

   RegDeleteKey( hRegKey, pszSubKey );
}

VOID
WriteBadConnsToReg(
    IN PCONNECTION_TO_DELETE pBadConnections
    )
{
   // First Figure out how big a buffer is neeeded to hold all Connections
   PCONNECTION_TO_DELETE pCurConnection = pBadConnections;
   DWORD dwSize = 0, dwError;
   LPTSTR pszAllConnections = NULL,
          pszCurBuf = NULL,
          pszEndBuf = NULL;
   HKEY   hKey = INVALID_HANDLE_VALUE;

   if ( !pBadConnections )
      return;

   while ( pCurConnection )
   {
      dwSize += lstrlen( pCurConnection->pszConnectionName ) + 1;
      pCurConnection = pCurConnection->pNext;
   }

   dwSize++;  // Add one for the Last NULL
   pszAllConnections = LocalAllocMem( dwSize * sizeof(TCHAR) );
   if ( pszAllConnections)
   {
      pszCurBuf = pszAllConnections;
      *pszCurBuf = 0x00;
      pszEndBuf = pszAllConnections + dwSize;
      pCurConnection = pBadConnections;
      while ( pCurConnection && ( pszCurBuf < pszEndBuf ) )
      {
         // Copy the Current Connection Name
         StringCchCopy( pszCurBuf, dwSize - (pszCurBuf - pszAllConnections), pCurConnection->pszConnectionName );
         pszCurBuf += lstrlen( pCurConnection->pszConnectionName );
         pszCurBuf++;
         pCurConnection = pCurConnection->pNext;
      }
      *pszCurBuf = 0x00;

      // Open the Registry Software\Print Key
      dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSoftwarePrint, 0,
                             KEY_SET_VALUE, &hKey);
      if ( dwError == ERROR_SUCCESS )
      {
         RegSetValueEx( hKey, cszBadConnections, 0, REG_MULTI_SZ,
                        (LPBYTE) pszAllConnections,  ( dwSize * sizeof(TCHAR) ) );
      }
   }

   if ( pszAllConnections )
      LocalFreeMem( pszAllConnections );

   if ( hKey != INVALID_HANDLE_VALUE )
      RegCloseKey( hKey );
}


BOOL
FindAndPruneBadConnections(
    IN  PDRIVER_TO_DELETE  pBadDrivers,
    OUT PCONNECTION_TO_DELETE *ppBadConnections
    )
{
   BOOL    bRC = FALSE;
   HKEY    hServerKey = INVALID_HANDLE_VALUE,
           hPrinterKey = INVALID_HANDLE_VALUE;
   DWORD   dwServerIndex, dwPrinterIndex;
   LPTSTR  pszServerName = NULL,
           pszConnectionName = NULL,
           pszDriverName = NULL,
           pszShareName = NULL;

   // Open the Server Key
   if ( !OpenServerKey( &hServerKey ) )
      goto Cleanup;

   dwServerIndex = 0;
   do
   {
      // Open Printers Key for the new Server and get Server Name
      if ( !OpenPrintersKey( dwServerIndex++, hServerKey, &pszServerName, &hPrinterKey ) )
         goto Cleanup;

      if ( !pszServerName )
         break;

      dwPrinterIndex = 0;
      do
      {
         if ( !GetConnectionInfo( dwPrinterIndex++, hPrinterKey,
                                  &pszConnectionName, &pszDriverName, &pszShareName ) )
            goto Cleanup;

         if ( !pszConnectionName )
            break;

         if( !pszDriverName || !pszShareName)
         {
             continue;
         }

         // Check if this is a bad driver
         if ( IsDriverBad( pszDriverName, pBadDrivers ) )
         {
            AddToBadConnList( pszServerName, pszConnectionName, ppBadConnections );
            AddToBadConnList( pszServerName, pszShareName, ppBadConnections );
            DeleteRegKey( hPrinterKey, pszConnectionName );
            dwPrinterIndex--;
            LogError( LogSevError, IDS_CONNECTION_DELETED, pszConnectionName,
                      pszServerName, pszDriverName );
         }
      }
      while ( pszConnectionName );

   }
   while ( pszServerName );

   // Write all the bad connections to the Registry
   WriteBadConnsToReg( *ppBadConnections );

   bRC = TRUE;

Cleanup:
   if ( hServerKey != INVALID_HANDLE_VALUE )
      RegCloseKey(hServerKey);
   if ( hPrinterKey != INVALID_HANDLE_VALUE )
      RegCloseKey(hPrinterKey);

   if ( pszServerName )
      LocalFreeMem( pszServerName );
   if ( pszConnectionName )
      LocalFreeMem( pszConnectionName );
   if ( pszDriverName )
      LocalFreeMem( pszDriverName );
   if ( pszShareName )
      LocalFreeMem( pszShareName );

   return bRC;
}

BOOL
GetUserConnectionKey(
    IN  DWORD     dwIndex,
    OUT PHKEY     phKey
    )
{
   DWORD dwSize, dwRC, dwConnRC;
   TCHAR szUserKey[MAX_PATH];
   DWORD  dwConnLen;
   LPTSTR pszConnKey;

   if ( *phKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey(*phKey);
      *phKey = INVALID_HANDLE_VALUE;
   }

   dwSize = COUNTOF(szUserKey);
   dwRC = RegEnumKey( HKEY_USERS,
                      dwIndex,
                      szUserKey,
                      dwSize );
   if ( dwRC == ERROR_SUCCESS )
   {
      // Open Connections Key for this user
      dwConnLen = lstrlen( szUserKey ) + lstrlen( cszConnections ) + 3;
      pszConnKey = (LPTSTR) LocalAllocMem( dwConnLen * sizeof(TCHAR) );
      if ( pszConnKey )
      {
         // Build the next key name
         StringCchCopy( pszConnKey, dwConnLen, szUserKey );
         StringCchCat(  pszConnKey, dwConnLen, cszConnections );
      }
      else
         return FALSE;

      dwConnRC = RegOpenKeyEx( HKEY_USERS, pszConnKey, 0, KEY_READ, phKey );
      if (dwConnRC != ERROR_SUCCESS)
         *phKey = INVALID_HANDLE_VALUE;
   }
   else
      return FALSE;

   if ( pszConnKey )
      LocalFreeMem( pszConnKey );

   return TRUE;
}

VOID
GetMachineConnectionKey(
    OUT PHKEY     phKey
    )
{
   *phKey = INVALID_HANDLE_VALUE;

   //
   // Open the Machine Connections Key. These can only be added by
   // AddPerMachineConnection. 
   //
   if( ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSystemConnections, 0,
                                     KEY_READ, phKey))
   {
       *phKey = INVALID_HANDLE_VALUE;
   }
}

BOOL
GetNextConnection(
    IN  DWORD     dwIndex,
    IN  HKEY      hKey,
    OUT LPTSTR*   ppszConnectionName
    )
{
   // Enum Connection Names
   TCHAR   szConnectionName[MAX_PATH];
   DWORD   dwConnSize, dwConnRC;

   if ( *ppszConnectionName )
   {
      LocalFreeMem( *ppszConnectionName );
      *ppszConnectionName = NULL;
   }

   dwConnSize = COUNTOF( szConnectionName );
   dwConnRC = RegEnumKey( hKey,
                          dwIndex++,
                          szConnectionName,
                          dwConnSize );
   if ( dwConnRC == ERROR_SUCCESS )
   {
      // Save the Connection Name
      *ppszConnectionName = AllocStr( szConnectionName );
      if ( !*ppszConnectionName )
         return FALSE;
   }
   else if ( dwConnRC != ERROR_NO_MORE_ITEMS )
      return FALSE;

   return TRUE;
}

BOOL
IsConnectionBad(
    IN  LPTSTR                 pszConnectionName,
    IN  PCONNECTION_TO_DELETE  pCurBadConn
    )
{
   BOOL bFound = FALSE;

   while ( !bFound && pCurBadConn )
   {
      if ( !lstrcmpi( pszConnectionName, pCurBadConn->pszConnectionName ) )
         bFound = TRUE;
      else
         pCurBadConn = pCurBadConn->pNext;
   }

   return bFound;
}

BOOL
PruneUserOrMachineEntries(
    IN  PCONNECTION_TO_DELETE pBadConnections,
    IN  BOOL                  bPruneUsers
    )
{
   BOOL    bRC = FALSE, bMoreUsers;
   DWORD   dwUserIndex = 0;
   HKEY    hConnectionKey = INVALID_HANDLE_VALUE;
   LPTSTR  pszConnectionName = NULL;
   DWORD   dwConnectionIndex;

   do
   {
      if ( bPruneUsers)
         bMoreUsers = GetUserConnectionKey( dwUserIndex++, &hConnectionKey );
      else
      {
         GetMachineConnectionKey( &hConnectionKey );
         bMoreUsers = FALSE;
      }

      if ( hConnectionKey == INVALID_HANDLE_VALUE )
         continue;

      dwConnectionIndex = 0;
      do
      {
         if ( !GetNextConnection( dwConnectionIndex++, hConnectionKey, &pszConnectionName ) )
            goto Cleanup;

         if ( pszConnectionName && IsConnectionBad( pszConnectionName, pBadConnections ) )
         {
            DeleteRegKey( hConnectionKey, pszConnectionName );
            dwConnectionIndex--;
         }
      }
      while ( pszConnectionName );
   }
   while ( bMoreUsers );

   bRC = TRUE;

Cleanup:
   if ( hConnectionKey != INVALID_HANDLE_VALUE )
      RegCloseKey( hConnectionKey );

   if ( pszConnectionName )
      LocalFreeMem( pszConnectionName );

   return bRC;
}

VOID
ClearConnList(
    IN  PCONNECTION_TO_DELETE pCurBadConn
    )
{
   PCONNECTION_TO_DELETE pNextBadConn;
   while (pCurBadConn)
   {
      pNextBadConn = pCurBadConn->pNext;
      LocalFreeMem( pCurBadConn );
      pCurBadConn = pNextBadConn;
   }
}

BOOL
PruneBadConnections(
    IN  PDRIVER_TO_DELETE  pBadDrivers
    )
{
   BOOL bRC;
   PCONNECTION_TO_DELETE pBadConnections = NULL;

   bRC = FindAndPruneBadConnections( pBadDrivers, &pBadConnections );

   //
   // ISSUE-2002/03/15-mikaelho
   // The first call is useless since we won't be able to access
   // data from HKEY_USERS at this point!
   //
   if ( bRC )
      bRC = PruneUserOrMachineEntries( pBadConnections, TRUE );

   if ( bRC )
      bRC = PruneUserOrMachineEntries( pBadConnections, FALSE );

   ClearConnList( pBadConnections );
   return( bRC );
}


DWORD
NtPrintUpgradePrinters(
    IN  HWND                    WindowToDisable,
    IN  PCINTERNAL_SETUP_DATA   pSetupData
    )
/*++

Routine Description:
    Routine called by setup to upgrade printer drivers.

    Setup calls this routine after putting up a billboard saying something like
    "Upgrading printer drivers" ...
    
    The function kills all the bad OEM drivers so that they do not cause problems
    after upgrade as well as removing bad point and print connections. The function
    first enumerates all bad drivers on a machine. Then it sets a registry key
    HKLM\Software\\Microsoft\Windows NT\CurrentVersion\Print\Bad Connections that
    is used e.g. by PSetupKillBadUserConnections so that all bad point-and-print
    connections are removed. Finally it removes all the bad printer drivers.

Arguments:
    WindowToDisable     : supplies window handle of current top-level window
    pSetupData          : Pointer to INTERNAL_SETUP_DATA

Return Value:
    ERROR_SUCCESS on success, else Win32 error code
    None.

--*/
{
    HINF                MasterInf = INVALID_HANDLE_VALUE,
                        PrinterInf = INVALID_HANDLE_VALUE,
                        UpgradeInf = INVALID_HANDLE_VALUE;
    PVOID               QueueContext = NULL;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    DWORD               dwLastError = ERROR_SUCCESS, dwNeeded;
    HSPFILEQ            CopyQueue;
    BOOL                bRet = FALSE, bColor = FALSE;
    LPCTSTR             pszInstallationSource;
    TCHAR               szColorDir[MAX_PATH];

    if ( !pSetupData )
        return ERROR_INVALID_PARAMETER;

    InstallInternetPrintProvider();

    pszInstallationSource = (LPCTSTR)pSetupData->SourcePath; //ANSI wont work

    //
    // Create a setup file copy queue.
    //
    CopyQueue = SetupOpenFileQueue();
    if ( CopyQueue == INVALID_HANDLE_VALUE ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("SetupOpenFileQueue"), GetLastError());
        goto Cleanup;
    }

    //
    // Open ntprint.inf -- all the printer drivers shipped with NT should
    // be in ntprint.inf
    //
    PrinterInf  = SetupOpenInfFile(cszNtprintInf, NULL, INF_STYLE_WIN4, NULL);
    MasterInf   = SetupOpenInfFile(cszSyssetupInf, NULL, INF_STYLE_WIN4, NULL);
    UpgradeInf  = SetupOpenInfFile(cszUpgradeInf, NULL, INF_STYLE_WIN4, NULL);

    if ( PrinterInf == INVALID_HANDLE_VALUE ||
         MasterInf == INVALID_HANDLE_VALUE  ||
         UpgradeInf == INVALID_HANDLE_VALUE ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("SetupOpenInfFile"), GetLastError());
        goto Cleanup;
    }

    //
    // Build printer driver class list
    //
    hDevInfo = CreatePrinterDeviceInfoList(WindowToDisable);

    if ( hDevInfo == INVALID_HANDLE_VALUE   ||
         !PSetupBuildDriversFromPath(hDevInfo, cszNtprintInf, TRUE) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("Building driver list"), GetLastError());
        goto Cleanup;
    }

    ProcessPnpReinstallFlags(hDevInfo);

    dwNeeded = sizeof(szColorDir);
    bColor = GetColorDirectory(NULL, szColorDir, &dwNeeded);
    
    //
    // NTRAID#NTBUG9-577488-2002/03/14-mikaelho
    // MyPlatform is hard coded so we will e.g. not delete a bad x86 driver on
    // an IA64 machine during upgrades!
    // All calls to EnumPrinterDrivers must be modified.
    //
    BuildUpgradeInfoForPlatform(MyPlatform,
                                hDevInfo,
                                MasterInf,
                                PrinterInf,
                                UpgradeInf,
                                CopyQueue);

    //
    // If no printer drivers to upgrade we are done
    //
    if ( !gpDriversToAdd && !gpBadDrvList ) {

        bRet = TRUE;
        goto Cleanup;
    }

    //
    // Copy the printer driver files over
    //
    if ( gpDriversToAdd )
    {
        QueueContext = SetupInitDefaultQueueCallbackEx( WindowToDisable, INVALID_HANDLE_VALUE, 0, 0, NULL );
        if ( !QueueContext ) {

            LogError(LogSevError, IDS_UPGRADE_FAILED,
                     TEXT("SetupInitDefaultQueue"), GetLastError());
            goto Cleanup;
        }

        if ( !SetupCommitFileQueue(WindowToDisable,
                                   CopyQueue,
                                   SetupDefaultQueueCallback,
                                   QueueContext) ) {

            LogError(LogSevError, IDS_UPGRADE_FAILED,
                     TEXT("SetupCommitFileQueue"), GetLastError());
            goto Cleanup;
        }

        ProcessPrinterDrivers();
    }

    ProcessPrintQueues(hDevInfo, PrinterInf, MasterInf);
    FreeDriversToAddList();
    ProcessBadOEMDrivers();

    bRet            = TRUE;

Cleanup:

    if ( !bRet )
        dwLastError = GetLastError();

    if ( QueueContext )
        SetupTermDefaultQueueCallback(QueueContext);

    if ( CopyQueue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue(CopyQueue);

    if ( PrinterInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(PrinterInf);

    if ( MasterInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(MasterInf);

    if ( UpgradeInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(UpgradeInf);
    if ( hDevInfo != INVALID_HANDLE_VALUE )
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    CleanupScratchDirectory(NULL, PlatformAlpha);
    CleanupScratchDirectory(NULL, PlatformX86);
    CleanupScratchDirectory(NULL, PlatformMIPS);
    CleanupScratchDirectory(NULL, PlatformPPC);
    CleanupScratchDirectory(NULL, PlatformWin95);
    CleanupScratchDirectory(NULL, PlatformIA64);
    CleanupScratchDirectory(NULL, PlatformAlpha64);

    // Cleanup the Connection Cache
    DeleteCache();

    (VOID) SetupSetPlatformPathOverride(NULL);

    return dwLastError;
}

/*++

Routine Name

    DeleteSubkeys

Routine Description:

    Deletes the subtree of a key in registry.
    The key and ites values remeain, only subkeys are deleted

Arguments:

    hKey - handle to the key

Return Value:

    Error code of the operation

--*/

DWORD
DeleteSubkeys(
    HKEY hKey
    )
{
    DWORD    cchData;
    TCHAR    SubkeyName[MAX_PATH];
    HKEY     hSubkey;
    LONG     Status;
    FILETIME ft;

    cchData = SIZECHARS(SubkeyName);

    while ( ( Status = RegEnumKeyEx( hKey, 0, SubkeyName, &cchData,
                                   NULL, NULL, NULL, &ft ) ) == ERROR_SUCCESS )
    {
        Status = RegCreateKeyEx(hKey, SubkeyName, 0, NULL, 0,
                                KEY_READ, NULL, &hSubkey, NULL );

        if (Status == ERROR_SUCCESS)
        {
            Status = DeleteSubkeys(hSubkey);
            RegCloseKey(hSubkey);
            if (Status == ERROR_SUCCESS)
                RegDeleteKey(hKey, SubkeyName);
        }

        //
        // N.B. Don't increment since we've deleted the zeroth item.
        //
        cchData = SIZECHARS(SubkeyName);
    }

    if( Status == ERROR_NO_MORE_ITEMS)
        Status = ERROR_SUCCESS;

    return Status;
}


/*++

Routine Name

    RemoveRegKey

Routine Description:

    Deletes the subtree of a key in registry.
    The key and ites values remeain, only subkeys are deleted

Arguments:

    pszKey - location of the key in registry
    Ex: "\\Software\\Microsoft"

Return Value:

    Error code of the operation

--*/

DWORD
RemoveRegKey(
    IN LPTSTR pszKey
    )
{
    DWORD LastError;
    HKEY  hRootKey;

    LastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0,
                             KEY_READ, &hRootKey);

    if (LastError != ERROR_SUCCESS)
    {
        DBGMSG( DBG_TRACE, ("RemoveRegKey RegOpenKeyEx Error %d\n", LastError));
    }
    else
    {
        LastError = DeleteSubkeys(hRootKey);
        
        RegCloseKey(hRootKey);
    }

    return LastError;
}


/*++

Routine Name

    DeleteCache

Routine Description:

    Deletes the printer connection cache, including the old location in Registry

Arguments:

    None

Return Value:

    Error code of the operation

--*/

DWORD
DeleteCache(
    VOID
    )
{
    DWORD  LastError;
    LPTSTR pszRegWin32Root = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Providers\\LanMan Print Services\\Servers");
    LPTSTR pszPrevWin32CacheLocation = TEXT("System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers");

    LastError = RemoveRegKey(pszPrevWin32CacheLocation);

    LastError = RemoveRegKey(pszRegWin32Root);

    return LastError;
}


VOID
GetBadConnsFromReg(
    IN PCONNECTION_TO_DELETE *ppBadConnections
    )
{
   // Open the Key in the User Space
   // First Figure out how big a buffer is neeeded to hold all Connections
   PCONNECTION_TO_DELETE pCurConnection;
   DWORD dwSize, dwError, dwType, dwLastPos;
   LPTSTR pszAllConnections = NULL,
          pszCurBuf = NULL,
          pszEndBuf = NULL;
   HKEY   hKey = INVALID_HANDLE_VALUE;

   // Open the Registry Software\Print Key
   dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSoftwarePrint, 0,
                          KEY_READ, &hKey);

   if ( dwError != ERROR_SUCCESS )
      return;

   // Get the buffer size for the Share Name
   if ( ERROR_SUCCESS == RegQueryValueEx( hKey, cszBadConnections, NULL,
                                          &dwType, NULL, &dwSize) )
   {
      pszAllConnections = (LPTSTR) LocalAllocMem( dwSize );
      dwLastPos = (dwSize/sizeof(TCHAR)) - 1;
      if ( pszAllConnections &&
           (dwLastPos > 0)   &&
           ( ERROR_SUCCESS == RegQueryValueEx(hKey, cszBadConnections, NULL,
                                              &dwType, (LPBYTE) pszAllConnections,
                                              &dwSize) ) )
      {
         // Build all the Bad Connection structures
         DWORD dwAllocSize, dwStrLen;
         PCONNECTION_TO_DELETE pBadConn;

         pszAllConnections[dwLastPos-1] = TEXT('\0');
         pszAllConnections[dwLastPos]   = TEXT('\0');

         pszCurBuf = pszAllConnections;

         while ( ( dwStrLen = lstrlen(pszCurBuf) ) > 0 )
         {
            dwAllocSize = sizeof(CONNECTION_TO_DELETE) + ( (dwStrLen+1) * sizeof(TCHAR) );
            pBadConn = (PCONNECTION_TO_DELETE) LocalAllocMem( dwAllocSize );
            if ( pBadConn )
            {
               pBadConn->pszConnectionName = (LPTSTR) (pBadConn+1);
               StringCbCopy( pBadConn->pszConnectionName, dwAllocSize-sizeof(CONNECTION_TO_DELETE), pszCurBuf );
               pBadConn->pNext = *ppBadConnections;
               *ppBadConnections = pBadConn;
            }
            else
               break;

            pszCurBuf +=  dwStrLen + 1;
         }
      }
   }

   // Free up the Allocated Mem
   if ( pszAllConnections )
      LocalFreeMem( pszAllConnections );

   if ( hKey != INVALID_HANDLE_VALUE )
      RegCloseKey( hKey );

}

VOID
PSetupKillBadUserConnections(
    VOID
    )
/*++

Routine Description:
    Removes a user's bad Point-and-Print connections. The function is called
    as each user logs on after setup completes.  It read the registry value
    HKLM\Software\Microsoft\Windows NT\CurrentVersion\Print\Bad Connections
    to find the bad connection. This registry value is set by the function
    NtPrintUpgradePrinters and can be read to, written to and modified by
    Power Users and Administrators. PSetupKillBadUserConnections is called
    for each user when he/she first logs in after upgrade is complete and it
    will execute in this user's context. Only executed if the old build number
    is less than 2022. 

Arguments:
    none

Return Value:
    none

--*/
{
   BOOL bRC;
   PCONNECTION_TO_DELETE pBadConnections = NULL;

   GetBadConnsFromReg( &pBadConnections );

   PruneUserOrMachineEntries( pBadConnections, TRUE );

   ClearConnList( pBadConnections );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\prntupgwarn\prntupgwarn.cxx ===
/*++

  Copyright (C) 1998 - 2002 Microsoft Corporation
  All rights reserved.

  Module Name:

    PrntWrn

  Abstract:

    Code checks if any of the installed printers will fail during
    upgrade to Londhorn


  Author:

    Mikael Horal 15-March-2002

--*/
#include "precomp.h"
#pragma hdrstop
#include "string.hxx"

enum EPrintUpgConstants
{
    kReplacementDriver = 1,
    kWarnLevelWks      = 2,
    kWarnLevelSrv      = 3,
    kFileTime          = 4,
    kUnidrv54          = 5,
};

enum EPrintUpgLevels
{
    kBlocked = 1,
    kWarned  = 2,
};

TCHAR   cszPrintDriverMapping[]         = TEXT("Printer Driver Mapping");
TCHAR   cszVersion[]                    = TEXT("Version");
TCHAR   cszExcludeSection[]             = TEXT("Excluded Driver Files");

EXTERN_C
BOOL
WINAPI
DllMain(
    IN HINSTANCE    hInst,
    IN DWORD        dwReason,
    IN LPVOID       lpRes
    )
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}

HRESULT
GetLastErrorAsHResult(
                     VOID
                     )
{
    return HRESULT_FROM_WIN32(GetLastError());
}

LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    )
/*++

Routine Description:
    Find the file name part of a fully qualified file name

Arguments:
    pszFullName : Fully qualified path to the file

Return Value:
    Pointer to the filename part in the fully qulaified string

--*/
{
    LPTSTR pszSlash, pszTemp;

    if ( !pszFullName )
        return NULL;

    //
    // First find the : for the drive
    //
    if ( pszTemp = wcschr(pszFullName, TEXT(':')) )
        pszFullName = pszFullName + 1;

    for ( pszTemp = (LPTSTR)pszFullName ;
          pszSlash = wcschr(pszTemp, TEXT('\\')) ;
          pszTemp = pszSlash + 1 )
    ;

    return *pszTemp ? pszTemp : NULL;

}

/*++

Routine Name

    GetFileTimeByName

Routine Description:

    Get the file time of the file given a full path.

Arguments:

    pszPath               - Full path of the driver
    pFileTime             - Points to the file time

Return Value:

    An HRESULT

--*/
HRESULT
GetFileTimeByName(
    IN      LPCTSTR         pszPath,
       OUT  FILETIME        *pFileTime
    )
{
    HRESULT     hRetval     = E_FAIL;
    HANDLE      hFile       = INVALID_HANDLE_VALUE;

    hRetval = pszPath && *pszPath && pFileTime ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hFile = CreateFile(pszPath,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        hRetval = (INVALID_HANDLE_VALUE != hFile) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileTime(hFile, NULL, NULL, pFileTime) ? S_OK : GetLastErrorAsHResult();
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return hRetval;
}

/*++

Routine Name

    GetSectionName

Routine Description:

    Get the Section name in terms of environment and driver version.

Arguments:

    pszEnvironment         - The environment of the server, such as
    uVersion               - The major version of the driver
    pstrSection            - Points the name of section of driver mapping

Return Value:

    An HRESULT

--*/
HRESULT
GetSectionName(
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion,
       OUT TString        *pstrSection
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pszEnvironment && pstrSection ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = pstrSection->Format(_T("%s_%s_%s %d"), cszPrintDriverMapping, pszEnvironment, cszVersion, uVersion);
    }

    return hRetval;
}

/*++

Routine Name

    InfGetString

Routine Description:

    This routine is a wrapper to SetupGetStringField using TString.

Arguments:

    pInfContext            - The context of the inf
    uFieldIndex            - The field index of the string to retrieve
    pstrField              - Points to the string field as TString

Return Value:

    An HRESULT

--*/
HRESULT
InfGetString(
    IN     INFCONTEXT     *pInfContext,
    IN     UINT           uFieldIndex,
       OUT TString        *pstrField
    )
{
    HRESULT hRetval           = E_FAIL;
    TCHAR   szField[MAX_PATH] = {0};
    DWORD   dwNeeded          = 0;
    TCHAR   *pszField         = NULL;

    hRetval = pInfContext && pstrField ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = SetupGetStringField(pInfContext,
                                      uFieldIndex,
                                      szField,
                                      COUNTOF(szField),
                                      &dwNeeded) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hRetval = pstrField->Update(szField);
        }
        else if (FAILED(hRetval) && (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval)))
        {
            pszField = new TCHAR[dwNeeded];
            hRetval = pszField ? S_OK : E_OUTOFMEMORY;

            if (SUCCEEDED(hRetval))
            {
                hRetval = SetupGetStringField(pInfContext,
                                              uFieldIndex,
                                              pszField,
                                              dwNeeded,
                                              &dwNeeded) ? S_OK : GetLastErrorAsHResult();
            }

            if (SUCCEEDED(hRetval))
            {
                hRetval = pstrField->Update(pszField);
            }
        }
    }

    delete [] pszField;
    return hRetval;
}


LPTSTR
ReadDigit(
    LPTSTR  ptr,
    LPWORD  pW
    )
{
    TCHAR   c;
    //
    // Skip spaces
    //
    while ( !iswdigit(c = *ptr) && c != TEXT('\0') )
        ++ptr;

    if ( c == TEXT('\0') )
        return NULL;

    //
    // Read field
    //
    for ( *pW = 0 ; iswdigit(c = *ptr) ; ++ptr )
        *pW = *pW * 10 + c - TEXT('0');

    return ptr;
}

HRESULT
StringToDate(
    LPTSTR          pszDate,
    SYSTEMTIME     *pInfTime
    )
{
    BOOL    bRet = FALSE;

    ZeroMemory(pInfTime, sizeof(*pInfTime));

    bRet = (pszDate = ReadDigit(pszDate, &(pInfTime->wMonth)))      &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wDay)))        &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wYear)));

    //
    // Y2K compatible check
    //
    if ( bRet && pInfTime->wYear < 100 ) {

        ASSERT(pInfTime->wYear >= 100);

        if ( pInfTime->wYear < 10 )
            pInfTime->wYear += 2000;
        else
            pInfTime->wYear += 1900;
    }

    if(!bRet)
    {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bRet? S_OK : GetLastErrorAsHResult();
}

/*++

Routine Name

    StringTimeToFileTime

Routine Description:

    Converts a string of time in the form of "11/27/1999" to FILETIME.

Arguments:

    pszFileTime            - The file time as string such as "11/27/1999"
    pFileTime              - Points to the converted FILETIME

Return Value:

    An HRESULT

--*/
HRESULT
StringTimeToFileTime(
    IN     LPCTSTR        pszFileTime,
       OUT FILETIME       *pFileTime
    )
{
    HRESULT    hRetval = E_FAIL;
    SYSTEMTIME SystemTime;

    hRetval = pszFileTime && pFileTime ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        //
        // StringToDate should take pszFileTime as const.
        //
        hRetval = StringToDate(const_cast<LPTSTR>(pszFileTime), &SystemTime) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = SystemTimeToFileTime(&SystemTime, pFileTime) ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}


/*++

Routine Name

    InfGetStringAsFileTime

Routine Description:

    This routine get the time of driver in printupg and converts it to FILETIME.

Arguments:

    pInfContext            - The context of the inf
    uFieldIndex            - The field index of the string to retrieve
    pFielTime              - Points to the FILETIME structure

Return Value:

    An HRESULT

--*/
HRESULT
InfGetStringAsFileTime(
    IN     INFCONTEXT     *pInfContext,
    IN     UINT           uFieldIndex,
       OUT FILETIME       *pFileTime
    )
{
    HRESULT hRetval = E_FAIL;
    TString strDate;

    hRetval = pInfContext && pFileTime ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = InfGetString(pInfContext, uFieldIndex, &strDate);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = StringTimeToFileTime(strDate, pFileTime);
    }

    return hRetval;
}


/*++

Routine Name

    IsDateInLineNoOlderThanDriverDate

Routine Description:

    This routines process the current line of inf and determinate whether the
    date in the line is not older than that of driver.

Arguments:

    pInfContext            - Points to the current context of an INF
    pDriverFileTime        - File time of the actual driver
    pdwWarnLevelSrv        - Points to the warning level for server SKU
    pdwWarnLevelWks        - Points to the warning level for wks SKU
    pstrReplacementDriver  - The replacement driver.
    pbHasUnidrv54          - Points to BOOL variable indicating if the driver has
                             a Unidrv5.4 if function returns S_OK.

Return Value:

    An HRESULT            - S_OK means the date in the current line is no older
                            than that of the driver
--*/
HRESULT
IsDateInLineNoOlderThanDriverDate(
    IN     INFCONTEXT       *pInfContext,
    IN     FILETIME         *pDriverFileTime,
       OUT UINT             *puWarnLevelSrv,
       OUT UINT             *puWarnLevelWks,
       OUT TString          *pstrReplacementDriver,
       OUT BOOL             *pbHasUnidrv54
    )
{
    HRESULT  hRetval     = E_FAIL;
    INT      iWarnLevel = 0;
    FILETIME FileTimeInInf = {0};
    DWORD    dwFieldCount;

    hRetval = pInfContext && pDriverFileTime && puWarnLevelSrv && puWarnLevelWks && pstrReplacementDriver && pbHasUnidrv54 ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        dwFieldCount  = SetupGetFieldCount(pInfContext);

        hRetval = SetupGetIntField(pInfContext, kWarnLevelSrv, &iWarnLevel) ? S_OK: GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            *puWarnLevelSrv = iWarnLevel;
            hRetval = SetupGetIntField(pInfContext, kWarnLevelWks, &iWarnLevel) ? S_OK: GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            *puWarnLevelWks = iWarnLevel;
            hRetval = InfGetString(pInfContext, kReplacementDriver, pstrReplacementDriver);
        }

        if (SUCCEEDED(hRetval) && (dwFieldCount >= kUnidrv54))
        {
            INT      iUniDrv54 = 0;
            //
            // Unidrv5.4 field is optional
            //
            if(FAILED(SetupGetIntField(pInfContext, kUnidrv54, &iUniDrv54) ? S_OK: GetLastErrorAsHResult()))
            {
                *pbHasUnidrv54 = FALSE;
            }
            else
            {
                *pbHasUnidrv54 = iUniDrv54 ? TRUE : FALSE;
            }
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval = InfGetStringAsFileTime(pInfContext, kFileTime, &FileTimeInInf);

            //
            //  Date field is optional.
            //
            if (FAILED(hRetval) && (ERROR_INVALID_PARAMETER == HRESULT_CODE(hRetval)))
            {
                hRetval = S_OK;
            }
            else if (SUCCEEDED(hRetval))
            {
                hRetval = CompareFileTime(pDriverFileTime, &FileTimeInInf) <= 0 ? S_OK : S_FALSE ;
            }
        }
    }

    return hRetval;
}

/*++

Routine Name

    GetBlockingStatusByWksType

Routine Description:

    Fill out the status of blocking according to the type of SKU that runs the
    service.

Arguments:

    uWarnLevelSrv          - The warn level for server SKU
    uWarnLevelSrv          - The warn level for wks SKU
    bIsServer              - Whether the SKU running printing service is server
    puBlockingStatus       - Points to the result as status of blocking

Return Value:

    An HRESULT

--*/
HRESULT
GetBlockingStatusByWksType(
    IN     UINT           uWarnLevelSrv,
    IN     UINT           uWarnLevelWks,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus
    )
{
    HRESULT hRetval    = E_FAIL;
    UINT    uWarnLevel = 0;

    hRetval = puBlockingStatus ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *puBlockingStatus &= ~BSP_BLOCKING_LEVEL_MASK;
        *puBlockingStatus |= BSP_PRINTER_DRIVER_OK;

        uWarnLevel = bIsServer ? uWarnLevelSrv : uWarnLevelWks;

        switch (uWarnLevel)
        {
        case kBlocked:
            *puBlockingStatus |= BSP_PRINTER_DRIVER_BLOCKED;
            break;
        case kWarned:
            *puBlockingStatus |= BSP_PRINTER_DRIVER_WARNED;
            break;

        default:
            hRetval = E_FAIL;
            break;
        }
    }

    return hRetval;
}

/*++

Routine Name

    IsDriverDllInExcludedSection

Routine Description:

    Determine Whether the driver dll name is in the excluded section of printupg.

Arguments:

     pszDriverPath       - The path of the driver and this can be a full path or
                           the file name
     hPrintUpgInf        - The handle to printupg INF file

Return Value:

    An HRESULT           - S_OK means the driver dll is in the excluded section,
                           S_FALSE means it is not.

--*/
HRESULT
IsDriverDllInExcludedSection(
    IN     LPCTSTR        pszDriverPath,
    IN     HINF           hPrintUpgInf
    )
{
    HRESULT    hRetval = E_FAIL;
    TString    strDriverFileName;
    INFCONTEXT InfContext;

    hRetval = pszDriverPath && (INVALID_HANDLE_VALUE != hPrintUpgInf) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = strDriverFileName.Update(FileNamePart(pszDriverPath));
    }

    if (SUCCEEDED(hRetval) && !strDriverFileName.bEmpty())
    {
        hRetval = SetupFindFirstLine(hPrintUpgInf,
                                     cszExcludeSection,
                                     strDriverFileName,
                                     &InfContext) ? S_OK : GetLastErrorAsHResult();

        //
        // ERROR_LINE_NOT_FOUND is an HRESULT!
        //
        if (FAILED(hRetval) && (HRESULT_CODE(ERROR_LINE_NOT_FOUND) == HRESULT_CODE(hRetval)))
        {
            hRetval = S_FALSE;
        }

    }

    return hRetval;
}

/*++

Routine Name

    IsDriverInMappingSection

Routine Description:

    Check whether the driver is mapped, aka a bad driver.

Arguments:

    pszDriverModel         - The name of the driver to check
    pszEnvironment         - The environment of the server, such as
    uVersion               - The major version of the driver
    hPrintUpgInf           - The handle to the PrintUpg Inf file
    pFileTimeDriver        - Points to the file time of the driver
    pdwWarnLevelSrv        - Points to the warning level for server SKU
    pdwWarnLevelWks        - Points to the warning level for wks SKU
    pstrReplacementDriver  - The replacement driver
    pbHasUnidrv54          - Points to BOOL variable indicating if the driver has
                             a Unidrv5.4 if function returns S_OK.

Return Value:

    An HRESULT            - S_OK means the driver is a bad driver and is mapped to
                            some inbox driver, S_FALSE means the driver is not.

--*/
HRESULT
IsDriverInMappingSection(
    IN     LPCTSTR        pszModelName,
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion,
    IN     HINF           hPrintUpgInf,
    IN     FILETIME       *pFileTimeDriver,
       OUT UINT           *puWarnLevelSrv,
       OUT UINT           *puWarnLevelWks,
       OUT TString        *pstrReplacementDriver,
       OUT BOOL           *pbHasUnidrv54
    )
{
    HRESULT       hRetval        = E_FAIL;
    UINT          uWarnLevelSrv  = 0;
    UINT          uWarnLevelWks  = 0;
    INFCONTEXT    InfContext;
    TString       strMappingSection;
    TString       strReplacementDriver;

    hRetval = pszModelName && pszEnvironment && (INVALID_HANDLE_VALUE != hPrintUpgInf) && pFileTimeDriver && puWarnLevelSrv && puWarnLevelWks && pstrReplacementDriver && pbHasUnidrv54 ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *puWarnLevelSrv = 0;
        *puWarnLevelWks = 0;
        hRetval = GetSectionName(pszEnvironment, uVersion, &strMappingSection);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = SetupFindFirstLine(hPrintUpgInf, strMappingSection, pszModelName, &InfContext) ? S_FALSE : GetLastErrorAsHResult();
    }

    //
    // This code assumes that:
    //
    //  There can be multiple lines for the same printer driver, but they
    //  are sorted in non-descreasing order by date, the last field of the
    //  line. The fist line that has the date no older than the driver's
    //  date is used.
    //
    //  An interesting case would be like (since date is optional)
    //
    // "HP LaserJet 4"         = "HP LaserJet 4",       1, 2, "11/28/1999"
    // "HP LaserJet 4"         = "HP LaserJet 4",       2, 1
    //
    //  If a date is empty then the driver of all dates are blocked, hence
    //  an empty date means close to a very late date in the future.
    //
    for (;S_FALSE == hRetval;)
    {
        hRetval = IsDateInLineNoOlderThanDriverDate(&InfContext, pFileTimeDriver, &uWarnLevelSrv, &uWarnLevelWks, &strReplacementDriver, pbHasUnidrv54);

        if (S_FALSE == hRetval)
        {
            hRetval = SetupFindNextMatchLine(&InfContext, pszModelName, &InfContext) ? S_FALSE : GetLastErrorAsHResult();
        }
    }

    //
    // ERROR_LINE_NOT_FOUND is an HRESULT!
    //
    if (FAILED(hRetval) && (HRESULT_CODE(ERROR_LINE_NOT_FOUND) == HRESULT_CODE(hRetval)))
    {
        hRetval = S_FALSE;
    }

    if (S_OK == hRetval)
    {
        *puWarnLevelSrv = uWarnLevelSrv;
        *puWarnLevelWks = uWarnLevelWks;
        hRetval = pstrReplacementDriver->Update(strReplacementDriver);
    }

    return hRetval;
}

/*++
Routine Name

    bFoundSwitch

Routine Description:

    Checks if the switch pszFlag is given at the command prompt. If it is
    it tries to find (the compressed) printupg at this location and
    decompress it into pszTempFileName.

Arguments:

    pszFlag             - Flag
    pszTempFileName     - The name of the temporary file to which the compressed
                        printupg.inf is decompressed.

Return Value:

    A BOOL              - TRUE if path was found and file successfully decompressed
                          FALSE otherwise

--*/
BOOL bFoundSwitch(IN TCHAR *pszFlag, IN TCHAR *pszTempFileName)
{
    BOOL  bRet      = FALSE;
    TCHAR szInstallPath[MAX_PATH];
    HRESULT hRet;

    int nr_args;
    LPTSTR *ppszCommandLine = CommandLineToArgvW(GetCommandLine(), &nr_args);

    if (ppszCommandLine == NULL)
    {
        //
        // Note GlobalFree does NOT take NULL argument!
        // (generates an access violation!)
        //
        return FALSE;
    }


    for (int i = 0; i < nr_args; i++)
    {
        if (!_tcsncicmp(ppszCommandLine[i], pszFlag, _tcslen(pszFlag)))
        {
            TCHAR *pszPath = ppszCommandLine[i] + _tcslen(pszFlag);

            //
            // Only check if a non-zero length path was specified
            //
            if (_tcslen(pszPath))
            {
                //
                // Add "\" if it is not already the last charachter in the path.
                // Append printupg.inf to path
                //
                hRet = StringCchCopy(szInstallPath, COUNTOF(szInstallPath), pszPath);
                if (SUCCEEDED(hRet) && (szInstallPath[_tcslen(szInstallPath)-1] != _T('\\')))
                {
                    hRet = StringCchCat(szInstallPath, COUNTOF(szInstallPath), _T("\\"));
                }

                if(SUCCEEDED(hRet))
                {
                    hRet = StringCchCat(szInstallPath, COUNTOF(szInstallPath), _T("printupg.inf"));
                }

                if (SUCCEEDED(hRet))
                {
                    hRet = HRESULT_FROM_WIN32(SetupDecompressOrCopyFile(szInstallPath, pszTempFileName, NULL));
                }

                if(SUCCEEDED(hRet))
                {
                    bRet = TRUE;
                }
                else
                {
                    SetLastError(HRESULT_CODE(hRet));
                }
            }

            break;
        }
    }

    GlobalFree(ppszCommandLine);

    return bRet;

}


/*++
Routine Name

    CreateInfHandle

Routine Description:

    Creates a handle to printupg.inf. The function first tries to find the
    directory where printupg.inf resides. First it checks is the flag /m:
    was found at the command prompt. If it is it looks in the specified
    directory. If it does not find it there - or if no /s: flag was given -
    it checks the directory specified after /m: and if it is not found there
    it checks the directory in which winnt32.exe was started up from.

Arguments:

    pszTempFileName     - The name of the temporary file to which the compressed
                        printupg.inf is decompressed.
    hInfFile            - Pointer to a the printupg.inf file's handle

Return Value:

    A BOOL              - TRUE if success; FALSE otherwise

--*/
BOOL CreateInfHandle(IN TCHAR *pszTempFileName, OUT HINF *hInfFile){

    BOOL bRet      = FALSE;

    BOOL bFoundInf = bFoundSwitch(_T("/m:"), pszTempFileName);

    if (!bFoundInf)
    {
        bFoundInf = bFoundSwitch(_T("/s:"), pszTempFileName);
    }

    if (!bFoundInf)
    {
        TCHAR szInstallPath[MAX_PATH];

        //
        // szInstallPath will contain the full path for winnt32.exe
        //
        if (!GetModuleFileName(NULL, szInstallPath, COUNTOF(szInstallPath)))
        {
            goto Cleanup;
        }

        szInstallPath[COUNTOF(szInstallPath) - 1] = TEXT('\0');

        //
        // Keep the directory, but exchange winnt32.exe for printupg.inf
        //
        TCHAR *pszTemp = (TCHAR *) _tcsrchr(szInstallPath, _T('\\'));
        HRESULT hRet;

        if(!pszTemp)
        {
            goto Cleanup;
        }

        pszTemp++;
        *pszTemp = _T('\0');
        if(FAILED(hRet = StringCchCat(szInstallPath, COUNTOF(szInstallPath), _T("printupg.inf"))))
        {
            SetLastError(HRESULT_CODE(hRet));
            goto Cleanup;
        }


        //
        //  Did we find printupg.inf in the local directory?
        //
        if (SetupDecompressOrCopyFile(szInstallPath, pszTempFileName, NULL) != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

    }


    *hInfFile = SetupOpenInfFile(pszTempFileName,
                                 _T("PrinterUpgrade"),
                                 INF_STYLE_WIN4,
                                 NULL);


    if ((*hInfFile) != INVALID_HANDLE_VALUE)
    {
        bRet = TRUE;
    }

    Cleanup:

    return bRet;

}


/*++
Routine Name

    GetTempInfFile

Routine Description:

    Creates a temporary file and returns its name (and full path) in pszTempFileName

Arguments:

    pszTempFileName     - The full path and name of the temporary file
                          Must have length MAX_PATH

Return Value:

    A BOOL              - TRUE if success; FALSE otherwise

--*/
BOOL GetTempInfFile(OUT TCHAR *pszTempFileName){
    TCHAR szTempPath[MAX_PATH];
    BOOL bRet = FALSE;

    if (!GetTempPath(COUNTOF(szTempPath), szTempPath))
    {
        goto Cleanup;
    }

    if (!GetTempFileName(szTempPath, _T("upg"), 0, pszTempFileName))
    {
        pszTempFileName[0] = _T('\0');
        goto Cleanup;
    }

    bRet = TRUE;

    Cleanup:

    return bRet;}

/*++
Routine Name

    GetProductType

Routine Description:

    Check whether the product type of  the running version is Workstation.

Arguments:

    bIsWrk                - Boolean indicating if the product type of
                            the running version is Workstation (i.e. not Server)


Return Value:

    A BOOL               - TRUE if success; FALSE otherwise

--*/
BOOL GetProductType(OUT BOOL *bIsWrk)
{

    OSVERSIONINFOEX osvi;

    //
    // Try calling GetVersionEx using the OSVERSIONINFOEX structure.
    // If that fails, check registry instead
    //

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx ((OSVERSIONINFO *) &osvi) )
    {
        if ( osvi.wProductType == VER_NT_WORKSTATION )
        {
            *bIsWrk = TRUE;
        }
        else
        {
            *bIsWrk = FALSE;
        }
    }
    else
    {
        HKEY hKey;
        TCHAR szProductType[MAX_PATH];
        DWORD dwBufLen;

        if (RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                        0,
                        KEY_QUERY_VALUE,
                        &hKey) != ERROR_SUCCESS)
        {
            return FALSE;
        }

        dwBufLen = sizeof(szProductType);

        if (RegQueryValueEx(hKey,
                            _T("ProductType"),
                            NULL,
                            NULL,
                            (LPBYTE) szProductType,
                            &dwBufLen) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey( hKey );

        szProductType[COUNTOF(szProductType)-1] = _T('\0');

        if ( lstrcmpi( _T("WINNT"), szProductType) == 0 )
        {
            *bIsWrk = TRUE;
        }
        else
        {
            *bIsWrk = FALSE;
        }

    }

    return TRUE;

}



/*++
Routine Name

    SetupCallback

Routine Description:

    Calls the callback function after setting up the parameters.

Arguments:

    BlockingStatus          - The blocking status of the driver
    bHasInBox               - Boolean indicating if there exists a replacement driver
                              for the driver
    bHasUnidrv54            - Boolean indicating if there exists a Unidrv5.4 for the driver
    pszDriverName           - The name of the driver
    CompatibilityCallback   - The Callback funtcion
    Context                 - Argument for the callback function


Return Value:

    A BOOL               - TRUE if callback called successfull or if the driver is not blocked
                           FALSE otherwise

--*/
BOOL SetupCallback(IN  INT    BlockingStatus,
                   IN  BOOL   bHasInBox,
                   IN  BOOL   bHasUnidrv54,
                   IN  PCTSTR pszDriverName,
                   IN  PCOMPAIBILITYCALLBACK CompatibilityCallback,
                   IN  LPVOID Context){
    COMPATIBILITY_ENTRY CompEntry = {0};

    CompEntry.Description   = (TCHAR *) pszDriverName;
    CompEntry.RegKeyName    = NULL;
    CompEntry.RegValName    = NULL;
    CompEntry.RegValDataSize= 0;
    CompEntry.RegValData    = NULL;
    CompEntry.SaveValue     = NULL;
    CompEntry.Flags         = 0;

    /*++

    case 0: Driver not blocked  - will not happen here!

    case 1: Driver Blocked

    case 2: Driver Warned

    case n: Illegal blocking status - ignore

    --*/

    switch (BlockingStatus)
    {

    case kBlocked:

        if (bHasInBox && bHasUnidrv54)
        {
            CompEntry.HtmlName    = _T("CompData\\upgbyy.htm");
            CompEntry.TextName    = _T("CompData\\upgbyy.txt");
        }
        else if (bHasInBox)
        {

            CompEntry.HtmlName    = _T("CompData\\upgbyn.htm");
            CompEntry.TextName    = _T("CompData\\upgbyn.txt");
        }
        else
        {
            CompEntry.HtmlName    = _T("CompData\\upgbnn.htm");
            CompEntry.TextName    = _T("CompData\\upgbnn.txt");
        }

        break;

    case kWarned:

        if (bHasInBox)
        {
            CompEntry.HtmlName    = _T("CompData\\upgwy.htm");
            CompEntry.TextName    = _T("CompData\\upgwy.txt");
        }
        else
        {
            CompEntry.HtmlName    = _T("CompData\\upgwn.htm");
            CompEntry.TextName    = _T("CompData\\upgwn.txt");
        }

        break;

    default:

        return TRUE;

    }

    return CompatibilityCallback(&CompEntry,Context);
}


/*++

Entry point for prntwrn.dll

Return Value:

    A BOOL               - FALSE if something failed
                           TRUE  in all other cases

--*/
BOOL
PrntWrn(
       PCOMPAIBILITYCALLBACK CompatibilityCallback,
       LPVOID Context
       )
{
    BOOL            bRet    = FALSE;
    HRESULT         hRetval = S_OK;
    PDRIVER_INFO_3  pInstalledDrivers = NULL;
    DWORD           dwMemoryNeeded = 0, cInstalledDrivers = 0;
    HINF            hInfFile = INVALID_HANDLE_VALUE;
    TCHAR           szTempFileName[MAX_PATH+1] = _T("\0");




    BOOL bIsWrk;
    if (!GetProductType(&bIsWrk))
    {
        goto Cleanup;
    }


    if (!GetTempInfFile(szTempFileName))
    {
        goto Cleanup;
    }


    if (!CreateInfHandle(szTempFileName, &hInfFile))
    {
        goto Cleanup;
    }

    //
    // ISSUE-2002/03/14-mikaelho
    // We will only warn for printer drivers of the same platform.
    //

    //
    // Note - EnumPrinterDrivers  succeedes if there are no drivers!!
    //
    if (!EnumPrinterDrivers(NULL, LOCAL_ENVIRONMENT, 3, NULL, 0, &dwMemoryNeeded, &cInstalledDrivers))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pInstalledDrivers = (PDRIVER_INFO_3) LocalAlloc(LPTR, dwMemoryNeeded);

            if (pInstalledDrivers == NULL)
            {
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    }

    //
    // No drivers installed!
    //
    if (!pInstalledDrivers)
    {
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // Copy all the installed drivers into pInstalledDrivers array
    //
    if (!EnumPrinterDrivers(NULL, LOCAL_ENVIRONMENT, 3, (LPBYTE) pInstalledDrivers, dwMemoryNeeded, &dwMemoryNeeded, &cInstalledDrivers))
    {
        goto Cleanup;
    }

    //
    // Check all installed drivers
    //
    for (DWORD cDrivers = 0; SUCCEEDED(hRetval) && (cDrivers < cInstalledDrivers); cDrivers++)
    {
        FILETIME DriverFileTime;
        BOOL     bHasUnidrv54 = FALSE;
        TString  strReplacementDriver;
        UINT     uBlockingStatus   = 0;
        UINT     uWarnLevelSrv     = 0;
        UINT     uWarnLevelWks     = 0;



        if (SUCCEEDED(GetFileTimeByName(pInstalledDrivers[cDrivers].pDriverPath, &DriverFileTime)))
        {
            hRetval = IsDriverDllInExcludedSection(pInstalledDrivers[cDrivers].pDriverPath, hInfFile);

            //
            // S_FALSE means that the driver is not in excluded driverfiles secion.
            //
            if (S_FALSE == hRetval)
            {

                hRetval = IsDriverInMappingSection(pInstalledDrivers[cDrivers].pName,
                                                   LOCAL_ENVIRONMENT,
                                                   pInstalledDrivers[cDrivers].cVersion,
                                                   hInfFile,
                                                   &DriverFileTime,
                                                   &uWarnLevelSrv,
                                                   &uWarnLevelWks,
                                                   &strReplacementDriver,
                                                   &bHasUnidrv54);


                //
                // S_OK means that driver is blocked or warned
                //
                if (S_OK == hRetval)
                {
                    if (SUCCEEDED(GetBlockingStatusByWksType(uWarnLevelSrv, uWarnLevelWks, !bIsWrk, &uBlockingStatus)))
                    {
                        if (!SetupCallback(uBlockingStatus,
                                           !strReplacementDriver.bEmpty(),
                                           bHasUnidrv54,
                                           pInstalledDrivers[cDrivers].pName,
                                           CompatibilityCallback,
                                           Context))
                        {
                            goto Cleanup;
                        }
                    }
                }
            }
        }
    }

    if(SUCCEEDED(hRetval))
    {
        bRet = TRUE;
    }

Cleanup:

    LocalFree(pInstalledDrivers);

    if (hInfFile != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(hInfFile);
    }

    if (_tcslen(szTempFileName))
    {
        DeleteFile(szTempFileName);
    }

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\prntupgwarn\precomp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Mikael Horal  17-Oct-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <objbase.h>
#define USE_SP_ALTPLATFORM_INFO_V1 0
#include <setupapi.h>
#include <shellapi.h>
#include <winspool.h>
#include "splsetup.h"
#include <stdio.h>
#include "tchar.h"
#include "strsafe.h"
#include <comp.h>

#define COUNTOF(x) sizeof(x)/sizeof(*x)

#if defined(_MIPS_)
#define LOCAL_ENVIRONMENT L"Windows NT R4000"
#elif defined(_ALPHA_)
#define LOCAL_ENVIRONMENT L"Windows NT Alpha_AXP"
#elif defined(_PPC_)
#define LOCAL_ENVIRONMENT L"Windows NT PowerPC"
#elif defined(_IA64_)
#define LOCAL_ENVIRONMENT L"Windows IA64"
#elif defined(_AXP64_)
#define LOCAL_ENVIRONMENT L"Windows Alpha_AXP64"
#else
#define LOCAL_ENVIRONMENT L"Windows NT x86"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\utildi.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Utildi.c

Abstract:

    Driver Setup DeviceInstaller Utility functions

Author:

    Muhunthan Sivapragasam (MuhuntS) 06-Sep-1995

Revision History:

--*/

#include "precomp.h"

static  const   GUID    GUID_DEVCLASS_PRINTER   =
    { 0x4d36e979L, 0xe325, 0x11ce,
        { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };

BOOL
SetSelectDevParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  BOOL                bWin95,
    IN  LPCTSTR             pszModel    OPTIONAL
    )
/*++

Routine Description:
    Sets the select device parameters by calling setup apis

Arguments:
    hDevInfo    : Handle to the printer class device information list
    bWin95      : TRUE if selecting Win95 driver, else WinNT driver
    pszModel    : Printer model we are looking for -- only for Win95 case

Return Value:
    TRUE on success
    FALSE else

--*/
{
    SP_SELECTDEVICE_PARAMS  SelectDevParams = {0};
    LPTSTR                  pszWin95Instn;

    SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);
    SelectDevParams.ClassInstallHeader.InstallFunction
                                 = DIF_SELECTDEVICE;

    //
    // Get current SelectDevice parameters, and then set the fields
    // we want to be different from default
    //
    if ( !SetupDiGetClassInstallParams(
                        hDevInfo,
                        pDevInfoData,
                        &SelectDevParams.ClassInstallHeader,
                        sizeof(SelectDevParams),
                        NULL) ) {

        if ( GetLastError() != ERROR_NO_CLASSINSTALL_PARAMS )
            return FALSE;

        ZeroMemory(&SelectDevParams, sizeof(SelectDevParams));  // NEEDED 10/11 ?
        SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);
        SelectDevParams.ClassInstallHeader.InstallFunction
                                 = DIF_SELECTDEVICE;
    }

    //
    // Set the strings to use on the select driver page ..
    //
    if(!LoadString(ghInst,
                  IDS_PRINTERWIZARD,
                  SelectDevParams.Title,
                  SIZECHARS(SelectDevParams.Title)))
    {
        return FALSE;
    }

    //
    // For Win95 drivers instructions are different than NT drivers
    //
    if ( bWin95 ) {

        pszWin95Instn = GetStringFromRcFile(IDS_WIN95DEV_INSTRUCT);
        if ( !pszWin95Instn )
            return FALSE;

        if ( lstrlen(pszWin95Instn) + lstrlen(pszModel) + 1
                            > sizeof(SelectDevParams.Instructions) ) {

            LocalFreeMem(pszWin95Instn);
            return FALSE;
        }

        StringCchPrintf(SelectDevParams.Instructions, COUNTOF(SelectDevParams.Instructions), pszWin95Instn, pszModel);
        LocalFreeMem(pszWin95Instn);
        pszWin95Instn = NULL;
    } else {

        if(!LoadString(ghInst,
                      IDS_WINNTDEV_INSTRUCT,
                      SelectDevParams.Instructions,
                      SIZECHARS(SelectDevParams.Instructions)))
        {
            return FALSE;
        }
    }

    if(!LoadString(ghInst,
                  IDS_SELECTDEV_LABEL,
                  SelectDevParams.ListLabel,
                  SIZECHARS(SelectDevParams.ListLabel)))
    {
        return FALSE;
    }

    return SetupDiSetClassInstallParams(
                                hDevInfo,
                                pDevInfoData,
                                &SelectDevParams.ClassInstallHeader,
                                sizeof(SelectDevParams));

}


BOOL
PSetupSetSelectDevTitleAndInstructions(
    HDEVINFO    hDevInfo,
    LPCTSTR     pszTitle,
    LPCTSTR     pszSubTitle,
    LPCTSTR     pszInstn
    )
/*++

Routine Description:
    Sets title, subtitle and instructions for the Add Printer/Add Printer Driver dialogs.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszTitle        : Title
    pszSubTitle     : Subtitle
    pszInstn        : Instructions

Return Value:
    TRUE on success, FALSE on error

--*/
{
    SP_SELECTDEVICE_PARAMS  SelectDevParams;

    if ( pszTitle && lstrlen(pszTitle) + 1 > MAX_TITLE_LEN ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszSubTitle && lstrlen(pszSubTitle) + 1 > MAX_SUBTITLE_LEN ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszInstn && lstrlen(pszInstn) + 1 > MAX_INSTRUCTION_LEN ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);
    SelectDevParams.ClassInstallHeader.InstallFunction
                                 = DIF_SELECTDEVICE;

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       NULL,
                                       &SelectDevParams.ClassInstallHeader,
                                       sizeof(SelectDevParams),
                                       NULL) )
        return FALSE;

    if ( pszTitle )
        StringCchCopy(SelectDevParams.Title, COUNTOF(SelectDevParams.Title), pszTitle);

    if ( pszSubTitle )
        StringCchCopy(SelectDevParams.SubTitle, COUNTOF(SelectDevParams.SubTitle), pszSubTitle);

    if ( pszInstn )
        StringCchCopy(SelectDevParams.Instructions, COUNTOF(SelectDevParams.Instructions), pszInstn);

    return SetupDiSetClassInstallParams(
                                hDevInfo,
                                NULL,
                                &SelectDevParams.ClassInstallHeader,
                                sizeof(SelectDevParams));

}

BOOL
PSetupSelectDeviceButtons(
   HDEVINFO hDevInfo,
   DWORD dwFlagsSet,
   DWORD dwFlagsClear
   )
/*++

Routine Description:
    Determines if the "Have Disk" and "Windows Update" buttons are to be displayed
    on the Select Device page.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    dwFlagsSet      : Flags to set
    dwFlagsClear    : Flags to clean

Return Value:
    TRUE on success, FALSE otherwise

--*/
{
    PSP_DEVINFO_DATA       pDevInfoData = NULL;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    // Check that no flags are both set & cleared
    if (dwFlagsSet & dwFlagsClear)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    //
    // Get current SelectDevice parameters, and then set the fields
    // we wanted changed from default
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        &DevInstallParams) ) {

        return FALSE;
    }

    //
    // Set Flag based on Argument for Web Button
    if ( dwFlagsSet & SELECT_DEVICE_FROMWEB )
       DevInstallParams.FlagsEx   |= DI_FLAGSEX_SHOWWINDOWSUPDATE;

    if ( dwFlagsClear & SELECT_DEVICE_FROMWEB )
       DevInstallParams.FlagsEx   &= ~DI_FLAGSEX_SHOWWINDOWSUPDATE;

    if ( dwFlagsSet & SELECT_DEVICE_HAVEDISK )
       DevInstallParams.Flags     |= DI_SHOWOEM;

    if ( dwFlagsClear & SELECT_DEVICE_HAVEDISK )
       DevInstallParams.Flags     &= ~DI_SHOWOEM;

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         pDevInfoData,
                                         &DevInstallParams);
}

BOOL
SetDevInstallParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  LPCTSTR             pszDriverPath   OPTIONAL
    )
/*++

Routine Description:
    Sets the device installation parameters by calling setup apis

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszDriverPath   : Path where INF file should be searched

Return Value:
    TRUE on success
    FALSE else

--*/
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Get current SelectDevice parameters, and then set the fields
    // we wanted changed from default
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        &DevInstallParams) ) {

        return FALSE;
    }

    //
    // Drivers are class drivers,
    // ntprint.inf is sorted do not waste time sorting,
    // show Have Disk button,
    // use our strings on the select driver page
    //
    DevInstallParams.Flags     |= DI_SHOWCLASS | DI_INF_IS_SORTED
                                               | DI_SHOWOEM
                                               | DI_USECI_SELECTSTRINGS;

    if ( pszDriverPath && *pszDriverPath )
        StringCchCopy(DevInstallParams.DriverPath, COUNTOF(DevInstallParams.DriverPath), pszDriverPath);

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         pDevInfoData,
                                         &DevInstallParams);
}


BOOL
PSetupBuildDriversFromPath(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszDriverPath,
    IN  BOOL        bEnumSingleInf
    )
/*++

Routine Description:
    Builds the list of printer drivers from infs from a specified path.
    Path could specify a directory or a single inf.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszDriverPath   : Path where INF file should be searched
    bEnumSingleInf  : If TRUE pszDriverPath is a filename instead of path

Return Value:
    TRUE on success
    FALSE else

--*/
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Get current SelectDevice parameters, and then set the fields
    // we wanted changed from default
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        NULL,
                                        &DevInstallParams) ) {

        return FALSE;
    }

    DevInstallParams.Flags  |= DI_INF_IS_SORTED;

    if ( bEnumSingleInf )
        DevInstallParams.Flags  |= DI_ENUMSINGLEINF;

    StringCchCopy(DevInstallParams.DriverPath, COUNTOF(DevInstallParams.DriverPath), pszDriverPath);

    SetupDiDestroyDriverInfoList(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER);

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams) &&
           SetupDiBuildDriverInfoList(hDevInfo, NULL, SPDIT_CLASSDRIVER);
}


BOOL
DestroyOnlyPrinterDeviceInfoList(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    This routine should be called at the end to destroy the printer device
    info list

Arguments:
    hDevInfo        : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{

    return hDevInfo == INVALID_HANDLE_VALUE
                        ? TRUE : SetupDiDestroyDeviceInfoList(hDevInfo);
}


BOOL
PSetupDestroyPrinterDeviceInfoList(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    This routine should be called at the end to destroy the printer device
    info list

Arguments:
    hDevInfo        : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{
    // Cleanup and CDM Context  created by windows update.
    DestroyCodedownload( gpCodeDownLoadInfo );
    gpCodeDownLoadInfo = NULL;

    return DestroyOnlyPrinterDeviceInfoList(hDevInfo);
}


HDEVINFO
CreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    )
{
    return SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_PRINTER, hwnd);
}


HDEVINFO
PSetupCreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    )
/*++

Routine Description:
    This routine should be called at the beginning to do the initialization
    It returns a handle which will be used on any subsequent calls to the
    driver setup routines.

Arguments:
    None

Return Value:
    On success a handle to an empty printer device information set.

    If the function fails INVALID_HANDLE_VALUE is returned

--*/
{
    HDEVINFO    hDevInfo;

    hDevInfo = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_PRINTER, hwnd);

    if ( hDevInfo != INVALID_HANDLE_VALUE ) {

        if ( !SetSelectDevParams(hDevInfo, NULL, FALSE, NULL) ||
             !SetDevInstallParams(hDevInfo, NULL, NULL) ) {

            DestroyOnlyPrinterDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }
    }

    return hDevInfo;
}


HPROPSHEETPAGE
PSetupCreateDrvSetupPage(
    IN  HDEVINFO    hDevInfo,
    IN  HWND        hwnd
    )
/*++

Routine Description:
    Returns the print driver selection property page

Arguments:
    hDevInfo    : Handle to the printer class device information list
    hwnd        : Window handle that owns the UI

Return Value:
    Handle to the property page, NULL on failure -- use GetLastError()

--*/
{
    SP_INSTALLWIZARD_DATA   InstallWizardData;

    ZeroMemory(&InstallWizardData, sizeof(InstallWizardData));
    InstallWizardData.ClassInstallHeader.cbSize
                            = sizeof(InstallWizardData.ClassInstallHeader);
    InstallWizardData.ClassInstallHeader.InstallFunction
                            = DIF_INSTALLWIZARD;

    InstallWizardData.DynamicPageFlags  = DYNAWIZ_FLAG_PAGESADDED;
    InstallWizardData.hwndWizardDlg     = hwnd;

    return SetupDiGetWizardPage(hDevInfo,
                                NULL,
                                &InstallWizardData,
                                SPWPT_SELECTDEVICE,
                                0);
}
PPSETUP_LOCAL_DATA
BuildInternalData(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pSpDevInfoData
    )
/*++

Routine Description:
    Fills out the selected driver info in the SELECTED_DRV_INFO structure

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pSpDevInfoData  : Gives the selected device info element.

Return Value:
    On success a non-NULL pointer to PSETUP_LOCAL_DATA struct
    NULL on error

--*/
{
    PSP_DRVINFO_DETAIL_DATA     pDrvInfoDetailData;
    PSP_DRVINSTALL_PARAMS       pDrvInstallParams;
    PPSETUP_LOCAL_DATA          pLocalData;
    PSELECTED_DRV_INFO          pDrvInfo;
    SP_DRVINFO_DATA             DrvInfoData;
    DWORD                       dwNeeded;
    BOOL                        bRet = FALSE;

    pLocalData          = (PPSETUP_LOCAL_DATA) LocalAllocMem(sizeof(*pLocalData));

    //
    // If we don't do this the call to DestroyLocalData in the cleanup code
    // might cause an AV.
    //
    if(pLocalData)
    {
        ZeroMemory(pLocalData, sizeof(*pLocalData));
    }

    pDrvInfoDetailData  = (PSP_DRVINFO_DETAIL_DATA)
                                LocalAllocMem(sizeof(*pDrvInfoDetailData));
    pDrvInstallParams   = (PSP_DRVINSTALL_PARAMS) LocalAllocMem(sizeof(*pDrvInstallParams));

    if ( !pLocalData || !pDrvInstallParams || !pDrvInfoDetailData )
        goto Cleanup;

    pDrvInfo                            = &pLocalData->DrvInfo;
    pLocalData->DrvInfo.pDevInfoData    = pSpDevInfoData;
    pLocalData->signature               = PSETUP_SIGNATURE;

    DrvInfoData.cbSize = sizeof(DrvInfoData);
    if ( !SetupDiGetSelectedDriver(hDevInfo, pSpDevInfoData, &DrvInfoData) )
        goto Cleanup;

    // Need to Check the flag in the DrvInstallParms
    pDrvInstallParams->cbSize     = sizeof(*pDrvInstallParams);
    if ( !SetupDiGetDriverInstallParams(hDevInfo,
                                        pSpDevInfoData,
                                        &DrvInfoData,
                                        pDrvInstallParams) ) {

        goto Cleanup;
    }

    //
    // Did the user press the "Web" button
    //
    if ( pDrvInstallParams->Flags & DNF_INET_DRIVER )
        pDrvInfo->Flags     |= SDFLAG_CDM_DRIVER;

    LocalFreeMem(pDrvInstallParams);
    pDrvInstallParams = NULL;

    dwNeeded                    = sizeof(*pDrvInfoDetailData);
    pDrvInfoDetailData->cbSize  = dwNeeded;

    if ( !SetupDiGetDriverInfoDetail(hDevInfo,
                                     pSpDevInfoData,
                                     &DrvInfoData,
                                     pDrvInfoDetailData,
                                     dwNeeded,
                                     &dwNeeded) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

            goto Cleanup;
        }

        LocalFreeMem(pDrvInfoDetailData);
        pDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA) LocalAllocMem(dwNeeded);

        if ( !pDrvInfoDetailData )
            goto Cleanup;

        pDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        if ( !SetupDiGetDriverInfoDetail(hDevInfo,
                                         pSpDevInfoData,
                                         &DrvInfoData,
                                         pDrvInfoDetailData,
                                         dwNeeded,
                                         NULL) ) {

            goto Cleanup;
        }
    }

    pDrvInfo->pszInfName        = AllocStr(pDrvInfoDetailData->InfFileName);
    pDrvInfo->pszDriverSection  = AllocStr(pDrvInfoDetailData->SectionName);
    pDrvInfo->pszModelName      = AllocStr(DrvInfoData.Description);
    pDrvInfo->pszManufacturer   = AllocStr(DrvInfoData.MfgName);
    pDrvInfo->pszProvider       = AllocStr(DrvInfoData.ProviderName);
    pDrvInfo->ftDriverDate = DrvInfoData.DriverDate;
    pDrvInfo->dwlDriverVersion = DrvInfoData.DriverVersion;

    if ( pDrvInfoDetailData->HardwareID && *pDrvInfoDetailData->HardwareID ) {

        pDrvInfo->pszHardwareID = AllocStr(pDrvInfoDetailData->HardwareID);
        if(!pDrvInfo->pszHardwareID)
            goto Cleanup;
    }

    bRet = pDrvInfo->pszInfName         &&
           pDrvInfo->pszDriverSection   &&
           pDrvInfo->pszModelName       &&
           pDrvInfo->pszProvider        &&
           pDrvInfo->pszManufacturer;

Cleanup:
    LocalFreeMem(pDrvInfoDetailData);
    LocalFreeMem(pDrvInstallParams);

    if ( bRet ) {
       return pLocalData;
    } else {

        //
        // On failure we will leave the old private local data around
        //
        DestroyLocalData(pLocalData);
        return NULL;
    }
}


PPSETUP_LOCAL_DATA
PSetupGetSelectedDriverInfo(
    IN  HDEVINFO    hDevInfo
    )
/**++
Routine Description:
    Fills out the selected driver info in the SELECTED_DRV_INFO structure
    (inside the PPSETUP_LOCAL_DATA structure)
    
Arguments:
    hDevInfo    - Handle to the printer class device information list

Return Value:
    Pointer to PSETUP_LOCAL_DATA containing information about the selected
    driver.    

--*/
{
    return BuildInternalData(hDevInfo, NULL);
}

BOOL
PSetupSelectDriver(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    Builds the class driver list and selects a driver for the class printer driver list.
    Selected driver is remembered and PSetupGetSelectedDriver
    call will give the selected driver.

Arguments:
    hDevInfo    - Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{

    return BuildClassDriverList(hDevInfo) &&
           SetupDiSelectDevice(hDevInfo, NULL);
}


VOID
GetDriverPath(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    OUT TCHAR               szDriverPath[MAX_PATH]
    )
/*++

Routine Description:
    Gets the path where driver files should be searched first to copy from

Arguments:
    pszDriverPath   : Pointer to a buffer of MAX_PATH size. Gives path where
                      system was installed from

Return Value:
    Nothing

--*/
{
    BOOL        bOemDriver = FALSE;
    LPTSTR     *List, psz;
    DWORD       dwCount;
    LPTSTR      pszTempPath = NULL;

    //
    // For OEM drivers look at the place where the inf came from, else
    // look at the place we installed NT from
    //
    if ( pLocalData && 
         !(IsSystemNTPrintInf(pLocalData->DrvInfo.pszInfName) || (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER ))) {

        StringCchCopy(szDriverPath, MAX_PATH, pLocalData->DrvInfo.pszInfName);
        if ( psz = FileNamePart(szDriverPath) ) {

            *psz = TEXT('\0');
            return;
        }
    }

    pszTempPath = GetSystemInstallPath();
    if ( pszTempPath != NULL )
    {
        StringCchCopy(szDriverPath, MAX_PATH, pszTempPath);
        LocalFreeMem(pszTempPath);
    }
    else
        // Default put A:\ since we have to give something to setup
        StringCchCopy(szDriverPath, MAX_PATH, TEXT("A:\\"));
}


BOOL
BuildClassDriverList(
    IN HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    Build the class driver list.

    Note: If driver list is already built this comes back immediately

Arguments:
    hDevInfo    : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{
    DWORD               dwLastError;
    SP_DRVINFO_DATA     DrvInfoData;
    //
    // Build the class driver list and also make sure there is atleast one driver
    //
    if ( !SetupDiBuildDriverInfoList(hDevInfo, NULL, SPDIT_CLASSDRIVER) )
        return FALSE;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    if ( !SetupDiEnumDriverInfo(hDevInfo,
                                NULL,
                                SPDIT_CLASSDRIVER,
                                0,
                                &DrvInfoData)           &&
         GetLastError() == ERROR_NO_MORE_ITEMS ) {

        SetLastError(SPAPI_E_DI_BAD_PATH);
        return FALSE;
    }

    return TRUE;
}

BOOL
IsNTPrintInf(
    IN LPCTSTR pszInfName
    )
/*

  Function: IsNTPrintInf

  Purpose:  Verifies is the inf file being copied is a system inf - ntprint.inf.

  Parameters:
            pszInfName - the fully qualified inf name that is being installed.

  Notes:    This is needed to make the decision of whether to zero or even copy the inf
            with SetupCopyOEMInf.
            Should we be doing a deeper comparison than this to decide?

*/
{
    BOOL   bRet      = FALSE;
    PTCHAR pFileName = FileNamePart( pszInfName );

    if( pFileName )
    {
        bRet = ( 0 == lstrcmpi( pFileName, cszNtprintInf ) );
    }

    return bRet;
}

BOOL
IsSystemNTPrintInf(
    IN PCTSTR pszInfName
    )
/*

  Function: IsSystemNTPrintInf

  Purpose:  Verifies if the inf file the one system printer inf : %windir\inf\ntprint.inf.

  Parameters:
            pszInfName - the fully qualified inf name that is being verified.

  Notes:    Needed to decide whether to downrank our inbox drivers
  
*/
{
    BOOL   bRet      = FALSE;
    TCHAR  szSysInf[MAX_PATH] = {0};
    UINT   Len;
    PCTSTR pRelInfPath = _T("inf\\ntprint.inf");

    Len = GetSystemWindowsDirectory(szSysInf, MAX_PATH);
    
    if (
            (Len != 0)       && 
            (Len + _tcslen(pRelInfPath) + 2 < MAX_PATH)
       )
    {
        if (szSysInf[Len-1] != _T('\\'))
        {
            szSysInf[Len++] = _T('\\');
            szSysInf[Len]   = _T('\0');
        }
        StringCchCat(szSysInf, COUNTOF(szSysInf), pRelInfPath);
        if (!_tcsicmp(szSysInf, pszInfName))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL
PSetupPreSelectDriver(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszManufacturer,
    IN  LPCTSTR     pszModel
    )
/*++

Routine Description:
    Preselect a manufacturer and model for the driver dialog

    If same model is found select it, else if a manufacturer is given and
    a match in manufacturer is found select first driver for the manufacturer.
    
    If no manufacturer or model is given select the first driver.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszManufacturer : Manufacterer name to preselect
    pszModel        : Model name to preselect

Return Value:
    TRUE on a model or manufacturer match
    FALSE else

--*/
{
    SP_DRVINFO_DATA     DrvInfoData;
    DWORD               dwIndex, dwManf, dwMod;

    if ( !BuildClassDriverList(hDevInfo) ) {

        return FALSE;
    }

    dwIndex = 0;

    //
    // To do only one check later
    //
    if ( pszManufacturer && !*pszManufacturer )
        pszManufacturer = NULL;

    if ( pszModel && !*pszModel )
        pszModel = NULL;

    //
    // If no model/manf given select first driver
    //
    if ( pszManufacturer || pszModel ) {

        dwManf = dwMod = MAX_DWORD;
        DrvInfoData.cbSize = sizeof(DrvInfoData);

        while ( SetupDiEnumDriverInfo(hDevInfo, NULL, SPDIT_CLASSDRIVER,
                                      dwIndex, &DrvInfoData) ) {

            if ( pszManufacturer        &&
                 dwManf == MAX_DWORD    &&
                 !lstrcmpi(pszManufacturer, DrvInfoData.MfgName) ) {

                dwManf = dwIndex;
            }

            if ( pszModel &&
                 !lstrcmpi(pszModel, DrvInfoData.Description) ) {

                dwMod = dwIndex;
                break; // the for loop
            }

            DrvInfoData.cbSize = sizeof(DrvInfoData);
            ++dwIndex;
        }

        if ( dwMod != MAX_DWORD ) {

            dwIndex = dwMod;
        } else if ( dwManf != MAX_DWORD ) {

            dwIndex = dwManf;
        } else {

            SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
            return FALSE;
        }
    }

    DrvInfoData.cbSize = sizeof(DrvInfoData);
    if ( SetupDiEnumDriverInfo(hDevInfo, NULL, SPDIT_CLASSDRIVER,
                               dwIndex, &DrvInfoData)   &&
         SetupDiSetSelectedDriver(hDevInfo, NULL, &DrvInfoData) ) {

        return TRUE;
    }

    return FALSE;
}


PPSETUP_LOCAL_DATA
PSetupDriverInfoFromName(
    IN HDEVINFO     hDevInfo,
    IN LPCTSTR      pszModel
    )
/*++

Routine Description:
    Fills out the selected driver info in the SELECTED_DRV_INFO structure
    (inside the PPSETUP_LOCAL_DATA structure) for the model passed into
    the function.

Arguments:
    hDevInfo    - Handle to the printer class device information list
    pszModel    - Printer Driver name

Return Value:
    Pointer to PSETUP_LOCAL_DATA containing information about pszModel   

--*/
{
    return PSetupPreSelectDriver(hDevInfo, NULL, pszModel)  ?
                BuildInternalData(hDevInfo, NULL)  :
                NULL;
}


LPDRIVER_INFO_6
Win95DriverInfo6FromName(
    IN  HDEVINFO    hDevInfo,
    IN  PPSETUP_LOCAL_DATA*  ppLocalData,
    IN  LPCTSTR     pszModel,
    IN  LPCTSTR     pszzPreviousNames
    )
{
    LPDRIVER_INFO_6     pDriverInfo6=NULL;
    PPSETUP_LOCAL_DATA  pLocalData;
    BOOL                bFound;
    LPCTSTR             pszName;

    if(!ppLocalData)
    {
        return FALSE;
    }

    bFound = PSetupPreSelectDriver(hDevInfo, NULL, pszModel);
    for ( pszName = pszzPreviousNames ;
          !bFound && pszName && *pszName ;
          pszName += lstrlen(pszName) + 1 ) {

        bFound = PSetupPreSelectDriver(hDevInfo, NULL, pszName);
    }

    if ( !bFound )
        return NULL;

    if ( (pLocalData = BuildInternalData(hDevInfo, NULL))           &&
         ParseInf(hDevInfo, pLocalData, PlatformWin95, NULL, 0, FALSE) ) {

        pDriverInfo6 = CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                        pLocalData->InfInfo.cbDriverInfo6);
        *ppLocalData = pLocalData;
    }

    if (!pDriverInfo6 && pLocalData)
    {
        DestroyLocalData(pLocalData);
        *ppLocalData = NULL;
    }

    return pDriverInfo6;
}


BOOL
PSetupDestroySelectedDriverInfo(
    IN  PPSETUP_LOCAL_DATA  pLocalData
    )
/**++
Routine Description:
    Frees memory allocated to fields given by the pointers in the
    PPSETUP_LOCAL_DATA structure. Also frees the memory allocated
    for the structure itself.
    
Arguments:
    pLocalData    - Handle to the printer class device information list

Return Value:
    Always returns TRUE    

--*/
{
    ASSERT(pLocalData && pLocalData->signature == PSETUP_SIGNATURE);
    DestroyLocalData(pLocalData);
    return TRUE;
}

BOOL
PSetupGetDriverInfForPrinter(
    IN      HDEVINFO    hDevInfo,
    IN      LPCTSTR     pszPrinterName,
    IN OUT  LPTSTR      pszInfName,
    IN OUT  LPDWORD     pcbInfNameSize
    )
/*++

Routine Description:
    Checks if there is an INF in %WINDIR%\inf that is identical (same driver name,
    same driver filename, same data file, same configuration file, same help file
    and same monitor name) to the driver of the printer that is passed in
    by comparing their DRIVER_INFO_6 structures. If such an INF is found the name
    of it is returned.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszPrinterName  : Name of printer.
    pszInfName      : Buffer to hold name of inf file - if found
    pcbInfNameSize  : Size of buffer pointed to by pszInfName in BYTES! Returns required size.

Return Value:
    TRUE if INF is found
    FALSE else

--*/
{
    BOOL                        bRet = FALSE;
    DWORD                       dwSize, dwIndex;
    HANDLE                      hPrinter = NULL;
    LPTSTR                      pszInf;
    PPSETUP_LOCAL_DATA          pLocalData = NULL;
    LPDRIVER_INFO_6             pDriverInfo6 = NULL;
    SP_DRVINFO_DATA             DrvInfoData;

    if(!pszInfName || !pcbInfNameSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if ( !OpenPrinter((LPTSTR)pszPrinterName, &hPrinter, NULL) )
        return FALSE;

    if ( !BuildClassDriverList(hDevInfo) )
        goto Cleanup;

    GetPrinterDriver(hPrinter,
                     NULL,
                     6,
                     NULL,
                     0,
                     &dwSize);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Cleanup;

    if ( !((LPBYTE)pDriverInfo6 = LocalAllocMem(dwSize))   ||
         !GetPrinterDriver(hPrinter,
                           NULL,
                           6,
                           (LPBYTE)pDriverInfo6,
                           dwSize,
                           &dwSize) ) {

        goto Cleanup;
    }

    dwIndex = 0;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    while ( SetupDiEnumDriverInfo(hDevInfo, NULL, SPDIT_CLASSDRIVER,
                                      dwIndex, &DrvInfoData) ) {

        //
        // Is the driver name same?
        //
        if ( !lstrcmpi(pDriverInfo6->pName, DrvInfoData.Description) ) {

            if ( !SetupDiSetSelectedDriver(hDevInfo, NULL, &DrvInfoData)    ||
                 !(pLocalData = BuildInternalData(hDevInfo, NULL))          ||
                 !ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0, FALSE) ) {

                if ( pLocalData ) {

                    DestroyLocalData(pLocalData);
                    pLocalData = NULL;
                }
                break;
            }

            //
            // Are the DRIVER_INFO_6's identical?
            //
            if ( IdenticalDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                      pDriverInfo6) )
                break;

            DestroyLocalData(pLocalData);
            pLocalData = NULL;
        }

        DrvInfoData.cbSize = sizeof(DrvInfoData);
        ++dwIndex;
    }

    if ( pLocalData == NULL ) {

        SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
        goto Cleanup;
    }

    pszInf= pLocalData->DrvInfo.pszInfName;
    dwSize = *pcbInfNameSize;
    *pcbInfNameSize = (lstrlen(pszInf) + 1) * sizeof(TCHAR);

    if ( dwSize < *pcbInfNameSize ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    StringCbCopy(pszInfName, dwSize, pszInf);
    bRet = TRUE;

Cleanup:
    ClosePrinter(hPrinter);
    LocalFreeMem(pDriverInfo6);
    DestroyLocalData(pLocalData);

    return  bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\prntupgwarn\string.cxx ===
/*++

Copyright (C) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    string.cxx

Abstract:

    String class

Author:

    Steve Kiraly (SteveKi)  03-Mar-2000

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "string.hxx"


//
// Class specific NULL state.
//
TCHAR TString::gszNullState[2] = {0,0};

/*++

Routine Name:

    Default constructor

Routine Description:

    Initialize the string class to a valid state.

Arguments:

    None

Return Value:

    None, Use IsValid to determine success or failure.

--*/
TString::
TString(
    VOID
    ) : m_pszString(&TString::gszNullState[kValid])
{
}

/*++

Routine Name:

    Non trivial constructor

Routine Description:

    Construction using an existing LPCTSTR string.

Arguments:

    psz - pointer to string

Return Value:

    None, Use IsValid to determine success or failure.

--*/
TString::
TString(
    IN LPCTSTR psz
    ) : m_pszString(&TString::gszNullState[kValid])
{
    if (FAILED(Update(psz)))
    {
        m_pszString = &TString::gszNullState[kInValid];
    }
}

/*++

Routine Name:

    Copy constructor.

Routine Description:

    Creates a copy of a string from another string object

Arguments:

    String - refrence to existing string

Return Value:

    None, Use IsValid to determine success or failure.

--*/
TString::
TString(
    IN const TString &String
    ) : m_pszString(&TString::gszNullState[kValid])
{
    if (FAILED(Update(String.m_pszString)))
    {
        m_pszString = &TString::gszNullState[kInValid];
    }
}

/*++

Routine Name:

    Destructor

Routine Description:

    Destruction, ensure we don't free our NULL state.

Arguments:

    None.

Return Value:

    None.

--*/
TString::
~TString(
    VOID
    )
{
    vFree(m_pszString);
}

/*++

Routine Name:

    bEmpty

Routine Description:

    Indicates if a string has any usable data.

Arguments:

    None.

Return Value:

    TRUE string has data, FALSE string has no data.

--*/
BOOL
TString::
bEmpty(
    VOID
    ) const
{
    return m_pszString[0] == 0;
}

/*++

Routine Name:

    IsValid

Routine Description:

    Indicates if a string object is valid.

Arguments:

    None.

Return Value:

    An HRESULT

--*/
HRESULT
TString::
IsValid(
    VOID
    ) const
{
    return m_pszString != &TString::gszNullState[kInValid] ? S_OK : E_OUTOFMEMORY;
}

/*++

Routine Name:

    uLen

Routine Description:

    Return the length of the string in characters not including
    the NULL terminator.

Arguments:

    None.

Return Value:

    Length of the string in characters not including the NULL terminator.

--*/
UINT
TString::
uLen(
    VOID
    ) const
{
    return _tcslen(m_pszString);
}

/*++

Routine Name:

    Cat

Routine Description:

    Safe concatenation of the specified string to the string
    object. If the allocation fails this routine will return a
    failure and the orginal string will be un touched. If the
    passed in string pointer is null or the passed in string
    points to the null string the function succeeds and does
    not update the string.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    An HRESULT

--*/
HRESULT
TString::
Cat(
    IN LPCTSTR psz
    )
{
    HRESULT hStatus         = S_OK;
    size_t  cchSize         = 0;
    LPTSTR  pszDst          = NULL;
    LPTSTR  pszTmp          = NULL;
    size_t  cchRemaining    = 0;

    //
    // Silently ignore a null string pointer or the empty string.
    //
    if (psz && *psz)
    {
        //
        // Calculate new buffer size consisting of the size of the orginal
        // string plus the sizeof of the new string plus the null terminator.
        //
        cchSize = _tcslen(m_pszString) + _tcslen(psz) + 1;

        //
        // Allocate the new buffer.
        //
        pszTmp = new TCHAR[cchSize];

        //
        // If memory was not available.
        //
        hStatus = pszTmp ? S_OK : E_OUTOFMEMORY;

        //
        // Copy the current string to the temp buffer.
        //
        if (SUCCEEDED(hStatus))
        {
            hStatus = StringCchCopyEx(pszTmp, cchSize, m_pszString, &pszDst, &cchRemaining, 0);
        }

        //
        // Concatenate the new string on the end of the temp buffer.
        //
        if (SUCCEEDED(hStatus))
        {
            hStatus = StringCchCopy(pszDst, cchRemaining, psz);
        }

        //
        // Release the current string buffer and assign the new concatenated
        // string to the internal string pointer.
        //
        if (SUCCEEDED(hStatus))
        {
            vFree(m_pszString);
            m_pszString = pszTmp;
            pszTmp      = NULL;
        }

        vFree(pszTmp);
    }

    return hStatus;
}

/*++

Routine Name:

    Update

Routine Description:

    Safe updating of string.  If the allocation fails, return FALSE
    and it leaves the original string untouched.  If the new string is
    NULL the current string is released and the class is put into a
    valid state.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    An HRESULT

--*/
HRESULT
TString::
Update(
    IN LPCTSTR psz
    )
{
    HRESULT hRetval = S_OK;
    LPTSTR  pszTmp  = NULL;
    size_t  cchSize = 0;

    //
    // Validate the passed in pointer.
    //
    if (psz)
    {
        //
        // Calculate the new string size including the null terminator.
        //
        cchSize = _tcslen(psz) + 1;

        //
        // Create temp pointer and allocate the new string.
        //
        pszTmp = new TCHAR [cchSize];

        hRetval = pszTmp ? S_OK : E_OUTOFMEMORY;

        //
        // Copy the string
        //
        if (SUCCEEDED(hRetval))
        {
            hRetval = StringCchCopy(pszTmp, cchSize, psz);
        }

        //
        // Release the old string and save the new string in the class pointer.
        //
        if (SUCCEEDED(hRetval))
        {
            vFree(m_pszString);
            m_pszString = pszTmp;
            pszTmp      = NULL;
        }

        vFree(pszTmp);
    }
    else
    {
        //
        // Release the current string.
        //
        vFree(m_pszString);

        //
        // Mark the object as valid.
        //
        m_pszString = &TString::gszNullState[kValid];
    }

    return hRetval;
}

/*++

Routine Name:

    LoadStringFromRC

Routine Description:

    Safe load of a string from a resources file.

Arguments:

    hInst   - Instance handle of resource file.
    uId     - Resource id to load.

Return Value:

    An HRESULT

--*/
HRESULT
TString::
LoadStringFromRC(
    IN HINSTANCE    hInst,
    IN UINT         uID
    )
{
    LPTSTR  pszString   = NULL;
    INT     iSize       = 0;
    INT     iLen        = 0;
    HRESULT hResult     = E_FAIL;

    //
    // Continue increasing the buffer until
    // the buffer is big enough to hold the entire string.
    //
    for (iSize = kStrMax; ; iSize += kStrMax)
    {
        //
        // Allocate string buffer.
        //
        pszString = new TCHAR [iSize];

        if (pszString)
        {
            iLen = ::LoadString(hInst, uID, pszString, iSize);

            if(iLen == 0)
            {
                delete [] pszString;
                hResult = E_FAIL;
                break;
            }

            //
            // Since LoadString does not indicate if the string was truncated or it
            // just happened to fit.  When we detect this ambiguous case we will
            // try one more time just to be sure.
            //
            else if (iSize - iLen <= 1)
            {
                delete [] pszString;
            }

            //
            // LoadString was successful release original string buffer
            // and update new buffer pointer.
            //
            else
            {
                vFree(m_pszString);
                m_pszString = pszString;
                hResult = S_OK;
                break;
            }
        }
        else
        {
            hResult = E_OUTOFMEMORY;
            break;
        }
    }

    return hResult;
}

/*++

Routine Name:

    vFree

Routine Description:

    Safe free, frees the string memory.  Ensures
    we do not try an free our global memory block.

Arguments:

    pszString - pointer to string meory to free.

Return Value:

    Nothing.

--*/
VOID
TString::
vFree(
    IN LPTSTR pszString
    )
{
    //
    // If this memory was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    if (pszString != &TString::gszNullState[kValid] &&
        pszString != &TString::gszNullState[kInValid])
    {
        delete [] pszString;
    }
}

/*++

Routine Name:

    Format

Routine Description:

    Format the string opbject similar to sprintf.

Arguments:

    pszFmt  - pointer format string.
    ..      - variable number of arguments similar to sprintf.

Return Value:

    An HRESULT S_OK if string was format successfully. E_XXX if error
    occurred creating the format string.

--*/
HRESULT
WINAPIV
TString::
Format(
    IN LPCTSTR pszFmt,
    IN ...
    )
{
    HRESULT hStatus = E_FAIL;

    va_list pArgs;

    va_start(pArgs, pszFmt);

    hStatus = vFormat(pszFmt, pArgs);

    va_end(pArgs);

    return hStatus;

}

/*++

Routine Name:

    vFormat

Routine Description:

    Format the string opbject similar to vsprintf.

Arguments:

    pszFmt pointer format string.
    pointer to variable number of arguments similar to vsprintf.

Return Value:

    An HRESULT - S_OK if string was format successfully. E_XXX if error
    occurred creating the format string.

--*/
HRESULT
TString::
vFormat(
    IN LPCTSTR pszFmt,
    IN va_list avlist
    )
{
    //
    // Format the string.
    //
    LPTSTR pszTemp = vsntprintf(pszFmt, avlist);

    //
    // If format succeeded, release the old string and save the
    // new formated string.
    //
    HRESULT hStatus = pszTemp ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hStatus))
    {
        //
        // Release the old string.
        //
        vFree(m_pszString);

        //
        // Save pointer to new string.
        //
        m_pszString = pszTemp;
    }

    return hStatus;
}

/*++

Routine Name:

    vsntprintf

Routine Description:

    //
    // Formats a string and returns a heap allocated string with the
    // formated data.  This routine can be used to for extremely
    // long format strings.  Note:  If a valid pointer is returned
    // the callng functions must release the data with a call to delete.
    // Example:
    //
    //  LPCTSTR p = vsntprintf("Test %s", pString );
    //
    //  SetTitle( p );
    //
    //  delete [] p;
    //

Arguments:

    pszString pointer format string.
    pointer to a variable number of arguments.

Return Value:

    Pointer to format string.  NULL if error.

--*/
LPTSTR
TString::
vsntprintf(
    IN LPCTSTR      szFmt,
    IN va_list      pArgs
    )
{
    LPTSTR  pszBuff = NULL;
    INT     iSize   = kStrIncrement;

    for( ; ; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = new TCHAR [iSize];

        if (!pszBuff)
        {
            break;
        }

        //
        // If the string was formatted then exit.
        //
        if (SUCCEEDED(StringCchVPrintf(pszBuff, iSize, szFmt, pArgs)))
        {
            break;
        }

        //
        // String did not fit release the current buffer.
        //
        if (pszBuff)
        {
            delete [] pszBuff;
        }

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if (iSize > kStrMaxFormatSize)
        {
            pszBuff = NULL;
            break;
        }

    }

    return pszBuff;
}

/*++

Routine Name:

    FormatMsg

Routine Description:

    This function formats a message string using the windows
    api FormatMessage, hence it will deal with the %1 %2 insertion
    specifiers.

Arguments:

    pszFmt - Pointer to format string, see the SDK under FormatMessage for
             all possible format specifiers.
    ..     - variable number of arguments

Return Value:

    An HRESULT

--*/
HRESULT
WINAPIV
TString::
FormatMsg(
    IN LPCTSTR pszFmt,
    IN ...
    )
{
    LPTSTR      pszRet  = NULL;
    DWORD       dwBytes = 0;
    HRESULT     hRetval = E_FAIL;
    va_list     pArgs;

    //
    // Point to the first un-named argument.
    //
    va_start(pArgs, pszFmt);

    //
    // Format the message.
    //
    dwBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                            pszFmt,
                            0,
                            0,
                            reinterpret_cast<LPWSTR>(&pszRet),
                            0,
                            &pArgs);
    va_end(pArgs);

    //
    // If the number of bytes is non zero the API formatted the
    // string.
    //
    if (dwBytes)
    {
        //
        // Update the return string object.
        //
        hRetval = Update(pszRet);

        //
        // Release the formated string.
        //
        if (pszRet)
        {
            LocalFree(pszRet);
        }
    }
    else
    {
        hRetval = HRESULT_FROM_WIN32(GetLastError());
    }

    return hRetval;
}

/*++

Routine Name:

    ToUpper

Routine Description:

    modifies the current string to be all uppercase

Arguments:

    none

Return Value:

    none

--*/
VOID
TString::
ToUpper(
    VOID
    )
{
    if (m_pszString != &TString::gszNullState[kValid] &&
        m_pszString != &TString::gszNullState[kInValid])
    {
        UINT Len = _tcslen(m_pszString);

        for (UINT i = 0; i < Len; i++)
        {
            m_pszString[i] = towupper(m_pszString[i]);
        }
    }
}

/*++

Routine Name:

    ToLower

Routine Description:

    modifies the current string to be all lowercase

Arguments:

    none

Return Value:

    none

--*/
VOID
TString::
ToLower(
    VOID
    )
{
    if (m_pszString != &TString::gszNullState[kValid] &&
        m_pszString != &TString::gszNullState[kInValid])
    {
        UINT Len = _tcslen(m_pszString);

        for (UINT i = 0; i < Len; i++)
        {
            m_pszString[i] = towlower(m_pszString[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\makefile.inc ===
$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
        copy $(BASE_INC_PATH)\vendinfo.mc $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\network.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Network.c

Abstract:

    Routines to migrate Win95 network printers to NT via using RunOnce entries

Author:

    Muhunthan Sivapragasam (MuhuntS) 18-Aug-1997

Revision History:

--*/


#include "precomp.h"

BOOL            bDoNetPrnUpgrade        = FALSE;
LPSTR           pszNetPrnEntry          = NULL;
CHAR            szSpool[]               = "\\spool\\";
CHAR            szMigDll[]              = "migrate.dll";
CHAR            szRunOnceCount[]        = "RunOnceCount";
CHAR            szRunOnceCountPath[]    = "System\\CurrentControlSet\\control\\Print";
CHAR            szRunOnceRegistryPath[] = "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
//
//  This is stored in the registry so when network printer upgrade using
//  RunOnce key is tries enough times without success we can delete files
//
#define         MIN_NETWORK_PRN_RETRIES         5
DWORD           dwRunOnceCount          = 0;


LPSTR
GetRunOnceValueToSet(
    )
/*++
--*/
{
    CHAR    szPath[MAX_PATH];
    DWORD   dwLen, dwSize;
    LPSTR   pszRet = NULL;

    dwSize  = sizeof(szPath)/sizeof(szPath[0]);

    if ( !(dwLen = GetFileNameInSpoolDir(szPath, dwSize, szMigDll)) )
        goto Done;

    //
    // Now build up the RunOnce key which will be set for each user
    //
    dwSize = strlen("rundll32.exe") + dwLen +
                                    + strlen("ProcessWin9xNetworkPrinters") + 4;

    if ( pszRet = AllocMem(dwSize * sizeof(CHAR)) )
        StringCchPrintfA(pszRet, dwSize,
                "rundll32.exe %s,ProcessWin9xNetworkPrinters",
                szPath);
Done:
    return pszRet;
}


VOID
SetupNetworkPrinterUpgrade(
    IN  LPCSTR pszWorkingDir
    )
/*++

Routine Description:
    This is called during InitializeSystemNT to setup the upgrade of network
    printers

Arguments:
    pszWorkingDir   : Gives the working directory assigned for printing

Return Value:
    None

    If everything was setup right bDoNetPrnUpgrade is TRUE, and pszNetPrnEntry
    is the value to set in per user registry for RunOnce

--*/
{
    CHAR    szSource[MAX_PATH], szTarget[MAX_PATH];
    DWORD   dwSize, dwLen;

    //
    // First check if the source paths is ok
    //
    dwLen   = strlen(szNetprnFile);

    dwSize  = sizeof(szTarget)/sizeof(szTarget[0]);

    if ( strlen(pszWorkingDir) + dwLen + 2 > dwSize )
        return;

    //
    // Need to make a copy of migrate.dll and netwkprn.txt to
    // the %windir%\system32\spool directory
    //
    StringCchPrintfA(szSource, SIZECHARS(szSource), "%s\\%s", pszWorkingDir, szNetprnFile);
    if ( !GetFileNameInSpoolDir(szTarget, dwSize, szNetprnFile)         ||
         !CopyFileA(szSource, szTarget, FALSE) )
        return;

    if (!MakeACopyOfMigrateDll( pszWorkingDir ))
    {
        return;
    }
    
    bDoNetPrnUpgrade = (pszNetPrnEntry = GetRunOnceValueToSet()) != NULL;
}


VOID
WriteRunOnceCount(
    )
/*++

Routine Description:
    This routine is called to write the number of times we need to try the
    network printer upgrade

Arguments:
    None

Return Value:
    None

--*/
{
    HKEY    hKey;
    DWORD   dwSize;

    if ( dwRunOnceCount == 0 )
        return;

    //
    // We will try number of user + MIN_NETWORK_PRN_RETRIES till we succeed
    //
    dwRunOnceCount += MIN_NETWORK_PRN_RETRIES;

    if ( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szRunOnceCountPath,
                                        0,
                                        KEY_WRITE,
                                        &hKey) )
        return;

    dwSize = sizeof(dwRunOnceCount);
    RegSetValueExA(hKey,
                   szRunOnceCount,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwRunOnceCount,
                   dwSize);

    RegCloseKey(hKey);

}


BOOL
ProcessNetPrnUpgradeForUser(
    HKEY    hKeyUser
    )
/*++

Routine Description:
    This is called during MigrateUserNT to handle network printer upgrade
    for the user

Arguments:
    hKeyUser    : Handle to the user registry key

Return Value:
    Return TRUE on success, and FALSE else

--*/
{
    HKEY    hKey = NULL;
    DWORD   dwLastError;

    dwLastError = RegCreateKeyExA(hKeyUser,
                                  szRunOnceRegistryPath,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey,
                                  NULL);

    if ( dwLastError == ERROR_SUCCESS ) {

        dwLastError = RegSetValueExA(hKey,
                                     "Printing Migration",
                                     0,
                                     REG_SZ,
                                     pszNetPrnEntry,
                                     ( strlen(pszNetPrnEntry) + 1 )
                                        * sizeof(CHAR));

#ifdef VERBOSE
    if ( dwLastError == ERROR_SUCCESS )
        DebugMsg("Wrote %s to %s", pszNetPrnEntry, szRunOnceRegistryPath);
#endif
    }

    if ( hKey )
        RegCloseKey(hKey);

    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    }

    return TRUE;
}


VOID
DecrementRunOnceCount(
    IN  DWORD   dwDiff,
    IN  BOOL    bResetRunOnceForUser
    )
/*++

Routine Description:
    Called after once network printer upgrade is called when user logged in,
    so we can decrement the retry count

    When ref count reaches 0 we then we can delete the files
Arguments:
    dwDiff                  : Value by which ref count should be decremented
    bResetRunOnceForUser    : We need to set RunOnce key again for the user

Return Value:
    None

--*/
{
    HKEY    hKey;
    DWORD   dwSize, dwCount, dwType;
    CHAR    szPath[MAX_PATH];

    if ( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szRunOnceCountPath,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey) )
        return;

    dwSize = sizeof(dwCount);
    if ( ERROR_SUCCESS == RegQueryValueExA(hKey, szRunOnceCount, 0, &dwType,
                                           (LPBYTE)&dwCount, &dwSize) ) {

        dwCount -= dwDiff;
        if ( dwCount ) {

            RegSetValueExA(hKey,
                           szRunOnceCount,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwCount,
                           dwSize);

            if ( bResetRunOnceForUser   &&
                 (pszNetPrnEntry = GetRunOnceValueToSet()) ) {

                ProcessNetPrnUpgradeForUser(HKEY_CURRENT_USER);
                FreeMem(pszNetPrnEntry);
                pszNetPrnEntry = NULL;

#ifdef  VERBOSE
            DebugMsg("Processing network/shared printers failed. Will try next time user logs in.");
#endif
            }
            
        } else {

            dwSize = sizeof(szPath)/sizeof(szPath[0]);
            RegDeleteValueA(hKey, szRunOnceCount);

            if ( GetFileNameInSpoolDir(szPath, dwSize, szMigDll) )
                DeleteFileA(szPath);

            if ( GetFileNameInSpoolDir(szPath, dwSize, szNetprnFile) )
                DeleteFileA(szPath);

            DebugMsg("Giving up on setting network/shared printers");
        }
    }

    RegCloseKey(hKey);
}


BOOL
AddNetworkPrinter(
    IN  LPPRINTER_INFO_2A   pPrinterInfo2
    )
/*++

Routine Description:
    This is called to add a windows 9x network printer. We will first try to
    make a conenction and if that fails we will add a masq. printer

Arguments:
    pPrinterInfo2   : Pointer to printer info 2 of the printer

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL    bRet = FALSE;
    LPSTR   pszName, psz;
    HANDLE  hPrinter = NULL;

    pszName = pPrinterInfo2->pPortName;

    if ( !OpenPrinterA(pszName, &hPrinter, NULL) ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("OpenPrinter failed for %s. %s", pszName, psz);
            FreeMem(psz);
            psz = NULL;
        }
        goto Done;
    }

    //
    // Try to make a printer connection. If that fails with some error
    // other than unknown driver create a masq printer
    //
    if (  AddPrinterConnectionA(pszName) ) {

        if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_DEFAULT )
            SetDefaultPrinterA(pszName);
        bRet = TRUE;
        goto Done;
    }

    if ( GetLastError() == ERROR_UNKNOWN_PRINTER_DRIVER ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("AddPrinterConnection failed for %s. %s", pszName, psz);
            FreeMem(psz);
            psz = NULL;
        }
        goto Done;
    }

    ClosePrinter(hPrinter);

    //
    // Masc. printers should have port name, printer name both saying
    // \\server\share. Otherwise printui gets confused and does not refresh
    // server status correctly (this is since printui has to poll for masc.
    // printers)
    //
    // So we need to fixup PrinterInfo2 temporarily
    //
    psz = pPrinterInfo2->pPrinterName;
    pPrinterInfo2->pPrinterName = pPrinterInfo2->pPortName;

    if ( hPrinter  = AddPrinterA(NULL, 2, (LPBYTE)pPrinterInfo2) ) {

        if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_DEFAULT )
            SetDefaultPrinterA(pPrinterInfo2->pPrinterName);

        pPrinterInfo2->pPrinterName = psz;
        bRet = TRUE;
        goto Done;
    }

    pPrinterInfo2->pPrinterName = psz;

    if ( psz = ErrorMsg() ) {

        DebugMsg("AddPrinterA failed for %s. %s", pszName, psz);
        FreeMem(psz);
        psz = NULL;
    }

Done:
    if ( hPrinter )
        ClosePrinter(hPrinter);

    return bRet;
}


BOOL
SharePrinter(
    IN  LPSTR   pszPrinterName
    )
/*++

Routine Description:
    This is called to share a printer when the user logs in for the first time
    to NT. Printers can not be shared during GUI setup because we are not on
    the network yet.

Arguments:
    pszPrinterName  : Printer name

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL                bRet = FALSE;
    DWORD               dwNeeded;
    HANDLE              hPrinter = NULL;
    LPBYTE              pBuf = NULL;
    LPSTR               psz;
    PRINTER_DEFAULTS    PrinterDflts = { NULL, NULL, PRINTER_ALL_ACCESS };

    if ( !OpenPrinterA(pszPrinterName, &hPrinter, &PrinterDflts) ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("OpenPrinterA failed for %s. %s", pszPrinterName, psz);
            FreeMem(psz);
            psz = NULL;
        }

        goto Cleanup;
    }

    GetPrinterA(hPrinter, 2, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER            ||
         !(pBuf = AllocMem(dwNeeded))                           ||
         !GetPrinterA(hPrinter, 2, pBuf, dwNeeded, &dwNeeded) ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("GetPrinterA failed for %s. %s", pszPrinterName, psz);
            FreeMem(psz);
            psz = NULL;
        }

        goto Cleanup;
    }

    ((LPPRINTER_INFO_2A)pBuf)->Attributes |= PRINTER_ATTRIBUTE_SHARED;

    bRet = SetPrinterA(hPrinter, 2, pBuf, 0);

    if ( !bRet && (psz = ErrorMsg()) ) {

        DebugMsg("OpenPrinterA failed for %s. %s", pszPrinterName, psz);
        FreeMem(psz);
        psz = NULL;
    }

Cleanup:
    if ( hPrinter )
        ClosePrinter(hPrinter);
    FreeMem(pBuf);

    return bRet;
}


VOID
ProcessWin9xNetworkPrinters(
    )
/*++

Routine Description:
    This is called the first time the user logs in to create network printer
    connections/masq printers.
    Reads the Win9x printing configuration we stored in the text file
    so that printing components can be upgraded

Arguments:
    ppPrinterNode           : Gives the list of netowrk printers on Win9x

Return Value:
    TRUE on succesfully reading the config information, FALSE else

--*/
{
    BOOL                bFail = FALSE, bSuccess = TRUE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    CHAR                c, szFile[MAX_PATH], szLine[2*MAX_PATH];
    DWORD               dwSize, dwLen;
    PRINTER_INFO_2A     PrinterInfo2;

#ifdef VERBOSE
    DebugMsg("ProcessWin9xNetworkPrinters called");
#endif
    //
    // If file is not found quit
    //
    dwSize = sizeof(szFile)/sizeof(szFile[0]);
    if ( !GetFileNameInSpoolDir(szFile, dwSize, szNetprnFile) ) {

        DebugMsg("ProcessWin9xNetworkPrinters: GetFileNameInSpoolDir failed\n");
        goto Cleanup;
    }

    hFile = CreateFileA(szFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                            FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE ) {

        DebugMsg("ProcessWin9xNetworkPrinters: CreateFile failed with %d for %s",
                 GetLastError(), szLine);
        goto Cleanup;
    }

    //
    // Read the printer info
    //
    if ( My_fgets(szLine, dwSize, hFile) == NULL                    ||    
         strncmp(szLine, "[Printers]", strlen("[Printers]")) )
        goto Cleanup;

    do {

        c = (CHAR) My_fgetc(hFile);

        if ( c == EOF || c == '\n' )
            break;  // Normal exit

        if ( c != 'S' || !My_ungetc(hFile) )
            goto Cleanup;

        ZeroMemory(&PrinterInfo2, sizeof(PrinterInfo2));

        ReadPrinterInfo2(hFile, &PrinterInfo2, &bFail);

        if ( bFail )
            goto Cleanup;

        //
        // If this was a network printer on Win9x it needs to be added as a
        // connection or as a masc printer
        //
        if ( PrinterInfo2.Attributes & PRINTER_ATTRIBUTE_NETWORK ) {

            if ( !AddNetworkPrinter(&PrinterInfo2) && bSuccess )
                bSuccess = FALSE;
        } else if ( PrinterInfo2.Attributes & PRINTER_ATTRIBUTE_SHARED ) {

            if ( !SharePrinter(PrinterInfo2.pPrinterName) && bSuccess )
                bSuccess = FALSE;
        }

    } while ( !bFail );


Cleanup:

    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle(hFile);

    if ( bSuccess && !bFail )
        DecrementRunOnceCount(MIN_NETWORK_PRN_RETRIES, FALSE);
    else
        DecrementRunOnceCount(1, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\fileq.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    FileQ.c

Abstract:

    File queue routines for upgrade

Author:

    Muhunthan Sivapragasam (MuhuntS) 22-Jan-1996

Revision History:

--*/


#include "precomp.h"

typedef struct _FILE_QUEUE_CONTEXT {

    PVOID   QueueContext;
} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;


UINT
MyQueueCallback(
    IN  PVOID   QueueContext,
    IN  UINT    Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:
    File queue callback routine for the upgrade. We will not prompt the user
    for missing file. But we will retry few times before failing

Arguments:
    QueueContext    : Points to FILE_QUEUE_CONTEXT
    Notification    : The event which is being notified
    Param1          : Depends on the notification
    Param2          : Depends on the notification

Return Value:
    None

--*/
{
    PFILE_QUEUE_CONTEXT     pFileQContext=(PFILE_QUEUE_CONTEXT)QueueContext;
    PSOURCE_MEDIA_W         pSource;
    PFILEPATHS_W            pFilePaths;

    switch (Notification) {

        case SPFILENOTIFY_COPYERROR:
            //
            // We know atleast pjlmon will be missing since it is copied
            // during textmode setup
            //
            pFilePaths = (PFILEPATHS_W) Param1;

            DebugMsg("Error %d copying %ws to %ws.",
                     pFilePaths->Win32Error, pFilePaths->Source,
                     pFilePaths->Target);

            return FILEOP_SKIP;

        case SPFILENOTIFY_NEEDMEDIA:
            pSource = (PSOURCE_MEDIA_W)Param1;

            //
            // Setup is going to add \i386 to the end. Tell it to look
            // right in the directory we give. Particularly needed for the
            // upgrade over the network case
            //
            if ( wcscmp(pSource->SourcePath, UpgradeData.pszSourceW) ) {

                if(SUCCEEDED(StringCchCopyW((LPWSTR)Param2, MAX_PATH, UpgradeData.pszSourceW)))
                {
                    return FILEOP_NEWPATH;
                }

            }

            DebugMsg("Error copying %ws from %ws.",
                     pSource->SourceFile, pSource->SourcePath);

            return FILEOP_SKIP;
    }

    return SetupDefaultQueueCallbackW(pFileQContext->QueueContext,
                                      Notification,
                                      Param1,
                                      Param2);
}


BOOL
InitFileCopyOnNT(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    On NT we will call ntprint.dll via SetupDiCallClassInstaller api with the
    DI_NOVCP flag so that all the necessary printer driver files are queued
    and copied at the end.

    This sets the necessary queue etc before calling the class installer

Arguments:
    hDevInfo    : Handle to printer device info list.

Return Value:
    TRUE on success. FALSE on error

--*/
{
    BOOL                        bRet = FALSE;
    HSPFILEQ                    CopyQueue;
    PFILE_QUEUE_CONTEXT         pFileQContext;
    SP_DEVINSTALL_PARAMS_W      DevInstallParams;

    //
    // Call the current device installation parameters
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);

    if ( !SetupDiGetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) )
        return FALSE;

    //
    // Set the parameters so that ntprint will just queue files and not commit
    // the file copy operations
    //
    if ( !(pFileQContext = AllocMem(sizeof(FILE_QUEUE_CONTEXT))) )
        goto Cleanup;

    pFileQContext->QueueContext = SetupInitDefaultQueueCallbackEx(
                                            INVALID_HANDLE_VALUE,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);

    DevInstallParams.FileQueue                  = SetupOpenFileQueue();
    DevInstallParams.InstallMsgHandlerContext   = pFileQContext;
    DevInstallParams.InstallMsgHandler          = MyQueueCallback;
    DevInstallParams.Flags                     |= DI_NOVCP;
    DevInstallParams.hwndParent                 = INVALID_HANDLE_VALUE;

    //
    // The files should be from the source dir
    //
    StringCchCopyW(DevInstallParams.DriverPath, SIZECHARS(DevInstallParams.DriverPath), UpgradeData.pszSourceW);

    if ( DevInstallParams.FileQueue == INVALID_HANDLE_VALUE     ||
         pFileQContext->QueueContext == NULL                    ||
         !SetupDiSetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) ) {

        if ( DevInstallParams.FileQueue != INVALID_HANDLE_VALUE )
            SetupCloseFileQueue(DevInstallParams.FileQueue);

        if ( pFileQContext->QueueContext )
            SetupTermDefaultQueueCallback(pFileQContext->QueueContext);
    } else {

        bRet = TRUE;
    }

Cleanup:

    if ( !bRet )
        FreeMem(pFileQContext);

    return bRet;
}


BOOL
CommitFileQueueToCopyFiles(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    After calling ntprint for each printer driver to queue up the files this
    routine is called to commit the file queue and do the actual file copy
    operations

Arguments:
    hDevInfo    : Handle to printer device info list.

Return Value:
    TRUE on success. FALSE on error

--*/
{
    BOOL                        bRet = FALSE;
    SP_DEVINSTALL_PARAMS_W      DevInstallParams;
    PFILE_QUEUE_CONTEXT         pFileQContext;

    DevInstallParams.cbSize = sizeof(DevInstallParams);

    if ( !SetupDiGetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) )
        return FALSE;

    pFileQContext = DevInstallParams.InstallMsgHandlerContext;

    bRet = SetupCommitFileQueueW(DevInstallParams.hwndParent,
                                 DevInstallParams.FileQueue,
                                 DevInstallParams.InstallMsgHandler,
                                 pFileQContext);

    SetupCloseFileQueue(DevInstallParams.FileQueue);
    SetupTermDefaultQueueCallback(pFileQContext->QueueContext);
    FreeMem(pFileQContext);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\fileio.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    FileIo.c

Abstract:

    Routines to do File IO for the migration of Win95 printing to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 24-Aug-1998

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop


CHAR
My_fgetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a character from the file

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   cbRead;

    if ( ReadFile(hFile, (LPBYTE)&c, sizeof(c), &cbRead, NULL)  &&
         cbRead == sizeof(c) )
        return c;
    else
        return (CHAR) EOF;
}


LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a line, or at most dwSize-1 characters from the file. Always NULL terminates if
    dwSize is greater than 0.

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   dwRead;
    LPSTR   ptr;

    if(dwSize == 0)
    {
        return NULL;
    }

    ptr = pszBuf;
    while ( --dwSize > 0 && (c = My_fgetc(hFile)) != EOF )
        if ( (*ptr++ = c) == '\n' )
            break;

    *ptr = '\0';
    return ( c == EOF && ptr == pszBuf ) ? NULL : pszBuf;
}


DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    )
/*++

Routine Description:
    Read at most dwSize bytes to buffer

Arguments:

Return Value:
    Number of bytes read

--*/
{
    DWORD   cbRead;

    return  ReadFile(hFile, pBuf, dwSize, &cbRead, NULL) ? cbRead : 0;
}


BOOL
My_ungetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Unread one character

Arguments:

Return Value:

--*/
{
    return SetFilePointer(hFile, -1, NULL, FILE_CURRENT) != INVALID_SET_FILE_POINTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\local.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    local.h

Abstract:

    Utility functions for Win95 upgrade of printing

Author:

    Muhunthan Sivapragasam (MuhuntS)  15-Jan-1997

Revision History:

--*/

//
// Type definitions
//
typedef struct  _UPGRADE_DATA {

    HINSTANCE   hInst;
    LPSTR       pszDir;
    LPSTR       pszProductId;
    LPSTR       pszSourceA;
    LPWSTR      pszSourceW;
} UPGRADE_DATA, *PUPGRADE_DATA;

typedef struct  _OEM_UPGRADE_INFO {

    LPSTR               pszModuleName;
    HMODULE             hModule;
} OEM_UPGRADE_INFO, *POEM_UPGRADE_INFO;

typedef struct  _UPGRADABLE_LIST {

    LPSTR   pszName;
} UPGRADABLE_LIST, *PUPGRADABLE_LIST;

typedef struct _SELECTED_DRV_INFO {

    LPTSTR              pszInfName;
    LPTSTR              pszModelName;
    LPTSTR              pszDriverSection;
    PSP_DEVINFO_DATA    pDevInfoData;
    LPTSTR              pszHardwareID;
    LPTSTR              pszManufacturer;
    LPTSTR              pszOEMUrl;
    LPTSTR              pszProvider;
    FILETIME            ftDriverDate;
    DWORDLONG           dwlDriverVersion;
    DWORD               Flags;
    LPTSTR              pszzPreviousNames;
} SELECTED_DRV_INFO, *PSELECTED_DRV_INFO;

typedef struct  _PARSEINF_INFO {

    PLATFORM            platform;
    LPTSTR              pszInstallSection;  // Can be platform dependent
    LPTSTR              pszzICMFiles;
    LPTSTR              pszPrintProc;
    LPTSTR              pszVendorSetup;
    DWORD               cbDriverInfo6;
    DRIVER_INFO_6       DriverInfo6;
} PARSEINF_INFO, *PPARSEINF_INFO;

typedef struct _PNP_INFO {

    LPTSTR              pszPortName;
    LPTSTR              pszDeviceInstanceId;
} PNP_INFO, *PPNP_INFO;

typedef struct  _PSETUP_LOCAL_DATA {

    SELECTED_DRV_INFO   DrvInfo;
    DWORD               signature;
    DWORD               Flags;
    PARSEINF_INFO       InfInfo;
    PNP_INFO            PnPInfo;
} PSETUP_LOCAL_DATA;

typedef BOOL (WINAPI* AllOCANDINITSID)(
    PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD,
    DWORD, DWORD, PSID 
    );

typedef BOOL (WINAPI* CHECKTOKENMEMBERSHIP)(
    HANDLE, PSID, PBOOL
    );

typedef PVOID (WINAPI* FREESID)(
    PSID
    );


extern  CHAR                szNetprnFile[];
extern  const   GUID        GUID_DEVCLASS_PRINTER;
extern  UPGRADE_DATA        UpgradeData;
extern  OEM_UPGRADE_INFO    OEMUpgradeInfo[];
extern  LPSTR               pszNetPrnEntry;
extern  BOOL                bDoNetPrnUpgrade;
extern  DWORD               dwRunOnceCount;


#define     MAX_STRING_LEN               MAX_PATH


#define     IDS_PRODUCTID                   1001
#define     IDS_TITLE                       1002

#define     IDS_DRIVERS_UPGRADE_FAILED      2001
#define     IDS_DRIVER_UPGRADE_FAILED       2002
#define     IDS_ADDDRIVER_FAILED            2003
#define     IDS_ICM_FAILED                  2004
#define     IDS_DEFAULT_PRINTER_FAILED      2005
#define     IDS_ADDPRINTER_FAILED           2006
#define     IDS_ADDMONITOR_FAILED           2007

#define     IDS_PRINTER_CANT_MIGRATE        3001

#define SIZECHARS(x)        (sizeof((x))/sizeof(*x))

#if DBG
#define ASSERT(expr)    if ( !(expr) ) DebugBreak();
#else
#define ASSERT(expr)    ;
#endif



//
// Debug functions
//
VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    );

//
// Heap management
//

PVOID
AllocMem(
    IN UINT cbSize
    );

VOID
FreeMem(
    IN PVOID pMem
    );

LPSTR
AllocStrA(
    IN LPCSTR  pszStr
    );

LPWSTR
AllocStrW(
    IN LPCWSTR  pszStr
    );

LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    );

LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    );

VOID
FreePrinterInfo2Strings(
    PPRINTER_INFO_2A   pPrinterInfo2
    );

//
// Functions to write print config to the text file
//
VOID
WriteToFile(
    HANDLE  hFile,
    LPBOOL  pbFail,
    LPCSTR  pszFormat,
    ...
    );

VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    );

VOID
WritePrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN      LPSTR               pszDriver,
    IN  OUT LPBOOL              pbFail
    );

//
// Functions to parse the text file having printing config info
//
LPSTR
GetLine(
    IN      HANDLE  hFile,
    IN  OUT LPBOOL  pbFail
    );

VOID
ReadString(
    IN      HANDLE  hFile,
    IN      LPSTR   pszPrefix,
    OUT     LPSTR  *pszStr,
    IN      BOOL    bOptional,
    IN  OUT LPBOOL  pbFail
    );

VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    );


VOID
ReadPrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN  OUT LPBOOL              pbFail
    );

//
// Misc stuff
//
VOID
CopyFilesToWorkingDir(
    IN  OUT LPBOOL  pbFail
    );

VOID
CleanupDriverMapping(
    IN  OUT HDEVINFO   *phDevInfo,
    IN  OUT HINF       *phNtInf,
    IN  OUT HINF       *phUpgInf
    );

VOID
InitDriverMapping(
    OUT     HDEVINFO   *phDevInfo,
    OUT     HINF       *phNtInf,
    OUT     HINF       *phUpgInf,
    IN  OUT LPBOOL      pbFail
    );

BOOL
InitFileCopyOnNT(
    IN  HDEVINFO    hDevInfo
    );

BOOL
CommitFileQueueToCopyFiles(
    IN  HDEVINFO    hDevInfo
    );

LPSTR
ErrorMsg(
    VOID
    );

VOID
LogError(
    IN  LogSeverity Severity,
    IN  UINT        MessageId,
    ...
    );

LPSTR
GetStringFromRcFileA(
    IN  UINT    uId
    );

VOID
SetupNetworkPrinterUpgrade(
    IN  LPCSTR pszWorkingDir
    );

BOOL
ProcessNetPrnUpgradeForUser(
    HKEY    hKeyUser
    );

DWORD
MySetDefaultPrinter(
    IN  HKEY    hUserRegKey,
    IN  LPSTR   pszDefaultPrinterString
    );

VOID
WriteRunOnceCount(
    );

LPSTR
GetDefPrnString(
    IN  LPCSTR  pszPrinterName
    );

CHAR
My_fgetc(
    HANDLE  hFile
    );

LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    );

DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    );

BOOL
My_ungetc(
    HANDLE  hFile
    );

DWORD
GetFileNameInSpoolDir(
    IN  LPSTR   szBuf,
    IN  DWORD   cchBuf,
    IN  LPSTR   pszFileName
    );

LPSTR
GetVendorSetupRunOnceValueToSet(
    VOID
    );

LONG
WriteVendorSetupInfoInRegistry(
    IN CHAR *pszVendorSetup,
    IN CHAR *pszPrinterName
    );

LONG
RemoveVendorSetupInfoFromRegistry(
    VOID
    );

VOID
CallVendorSetupDlls(
    VOID
    );

BOOL
IsLocalAdmin(
    BOOL *pbAdmin
    );

LONG
DecrementVendorSetupEnumerator(
    VOID
    );

BOOL 
MakeACopyOfMigrateDll( 
    IN  LPCSTR pszWorkingDir 
    );

HMODULE LoadLibraryUsingFullPathW(
    LPCTSTR lpFileName
    );

HMODULE LoadLibraryUsingFullPathA(
    LPCTSTR lpFileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\migmain.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Migmain.c

Abstract:

    Routines to migrate Win95 to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop
#include    <devguid.h>
#include    "msg.h"


VENDORINFO      VendorInfo;
UPGRADE_DATA    UpgradeData;
CHAR            szNetprnFile[] = "netwkprn.txt";

BOOL 
DllMain(
    IN HINSTANCE  hInst,
    IN DWORD      dwReason,
    IN LPVOID     lpRes   
    )
/*++

Routine Description:
    Dll entry point.

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

        case DLL_PROCESS_ATTACH:
            UpgradeData.hInst = hInst;
            UpgradeData.pszProductId = NULL;
            UpgradeData.pszSourceA   = NULL;
            UpgradeData.pszSourceW   = NULL;
            UpgradeData.pszDir       = NULL;
            break;

        case DLL_PROCESS_DETACH:
            FreeMem(UpgradeData.pszProductId);
            FreeMem(UpgradeData.pszSourceA);
            FreeMem(UpgradeData.pszSourceW);
            FreeMem(UpgradeData.pszDir);
            FreeMem(pszNetPrnEntry);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

LONG
QueryVersion(
    OUT     LPCSTR         *pszProductID,
    OUT     LPUINT          plDllVersion,
    OUT     LPINT          *pCodePageArray    OPTIONAL,
    OUT     LPCSTR         *ExeNamesBuf       OPTIONAL,
    OUT     PVENDORINFO    *pVendorInfo
    )
{
    BOOL    bFail = TRUE;
    DWORD   dwRet, dwNeeded, dwReturned, dwLangId;

    if(!pszProductID || !plDllVersion || !pVendorInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    if ( !(UpgradeData.pszProductId = GetStringFromRcFileA(IDS_PRODUCTID)) )
        goto Done;

    ZeroMemory(&VendorInfo, sizeof(VendorInfo));
    dwLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_COMPANY_NAME,
                   dwLangId,
                   VendorInfo.CompanyName,
                   sizeof(VendorInfo.CompanyName),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_SUPPORT_NUMBER,
                   dwLangId,
                   VendorInfo.SupportNumber,
                   sizeof(VendorInfo.SupportNumber),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_SUPPORT_URL,
                   dwLangId,
                   VendorInfo.SupportUrl,
                   sizeof(VendorInfo.SupportUrl),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_INSTRUCTIONS,
                   dwLangId,
                   VendorInfo.InstructionsToUser,
                   sizeof(VendorInfo.InstructionsToUser),
                   0);


    //
    // Since we are not checking the return value from FormatMessage we null-terminate the strings
    // to make sure they are NULL-terminated.
    //
    VendorInfo.CompanyName[sizeof(VendorInfo.CompanyName)-1] = 0;
    VendorInfo.SupportNumber[sizeof(VendorInfo.SupportNumber)-1] = 0;
    VendorInfo.SupportUrl[sizeof(VendorInfo.SupportUrl)-1] = 0;
    VendorInfo.InstructionsToUser[sizeof(VendorInfo.InstructionsToUser)-1] = 0;


    *pszProductID   = UpgradeData.pszProductId;
    *plDllVersion   = 1;
    if(pCodePageArray)
    {
        *pCodePageArray = NULL;
    }
    if(ExeNamesBuf)
    {
        *ExeNamesBuf    = NULL;
    }
    *pVendorInfo    = &VendorInfo;

    //
    // Call this DLL only if there are some printers or printer drivers
    // installed
    //
    if ( EnumPrinterDriversA(NULL,
                             NULL,
                             3,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned)   &&
          EnumPrintersA(PRINTER_ENUM_LOCAL,
                        NULL,
                        2,
                        NULL,
                        0,
                        &dwNeeded,
                        &dwReturned) ) {

        return ERROR_NOT_INSTALLED;
    }

    bFail = FALSE;

Done:
    if ( bFail ) {

        if ( dwRet = GetLastError() )
            return dwRet;

        return STG_E_UNKNOWN;
    }

    return ERROR_SUCCESS;
}


P_QUERY_VERSION     pQueryVersion   = QueryVersion;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\nt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Nt.c

Abstract:

    Routines to migrate Win95 printing components to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"


//
// Data structures to gather info from the text files created on Win95 to
// store the printing configuration
//
typedef struct _DRIVER_NODE {

    struct _DRIVER_NODE    *pNext;
    DRIVER_INFO_1A          DrvInfo1;
    PPSETUP_LOCAL_DATA      pLocalData;
    BOOL                    bCantAdd;
} DRIVER_NODE, *PDRIVER_NODE;

typedef struct _PRINTER_NODE {

    struct _PRINTER_NODE   *pNext;
    PRINTER_INFO_2A         PrinterInfo2;
} PRINTER_NODE, *PPRINTER_NODE;

typedef struct _PORT_NODE {

    struct _PORT_NODE   *pNext;
    LPSTR                pPortName;
} PORT_NODE, *PPORT_NODE;

LPSTR           pszDefaultPrinterString = NULL;
PPRINTER_NODE   pDefPrinter = NULL;

//
// They kill the migration dll if it does not finish in 3 minutes.
// To prevent that I need to set this handle atleast every 3 mins
//
HANDLE          hAlive = NULL;

//
// We want to lazy load ntprint.dll and mscms.dll.
//      Note : If we link to them our DLL will not run on Win9x
//
struct {

    HMODULE                     hNtPrint;

    pfPSetupCreatePrinterDeviceInfoList         pfnCreatePrinterDeviceInfoList;
    pfPSetupDestroyPrinterDeviceInfoList        pfnDestroyPrinterDeviceInfoList;
    pfPSetupBuildDriversFromPath                pfnBuildDriversFromPath;
    pfPSetupDriverInfoFromName                  pfnDriverInfoFromName;
    pfPSetupDestroySelectedDriverInfo           pfnDestroySelectedDriverInfo;
    pfPSetupGetLocalDataField                   pfnGetLocalDataField;
    pfPSetupFreeDrvField                        pfnFreeDrvField;
    pfPSetupProcessPrinterAdded                 pfnProcessPrinterAdded;
    pfPSetupInstallICMProfiles                  pfnInstallICMProfiles;
    pfPSetupAssociateICMProfiles                pfnAssociateICMProfiles;
} LAZYLOAD_INFO;


VOID
FreePrinterNode(
    IN  PPRINTER_NODE    pPrinterNode
    )
/*++

Routine Description:
    Free the memory allocated for a PRINTER_NODE element and strings in it

Arguments:
    pPrinterNode    : Points to the structure to free memory

Return Value:
    None

--*/
{

    FreePrinterInfo2Strings(&pPrinterNode->PrinterInfo2);
    FreeMem(pPrinterNode);
}


VOID
FreePrinterNodeList(
    IN  PPRINTER_NODE   pPrinterNode
    )
/*++

Routine Description:
    Free the memory allocated for elements in the PRINTER_NODE linked list

Arguments:
    pPrinterNode    : Points to the head of linked list to free memory

Return Value:
    None

--*/
{
    PPRINTER_NODE   pNext;

    while ( pPrinterNode ) {

        pNext = pPrinterNode->pNext;
        FreePrinterNode(pPrinterNode);
        pPrinterNode = pNext;
    }
}


VOID
FreeDriverNode(
    IN  PDRIVER_NODE    pDriverNode
    )
/*++

Routine Description:
    Free the memory allocated for a DRIVER_NODE element and fields in it

Arguments:
    pDriverNode : Points to the structure to free memory

Return Value:
    None

--*/
{
    if ( pDriverNode->pLocalData )
        LAZYLOAD_INFO.pfnDestroySelectedDriverInfo(pDriverNode->pLocalData);
    FreeMem(pDriverNode->DrvInfo1.pName);
    FreeMem(pDriverNode);
}


VOID
FreeDriverNodeList(
    IN  PDRIVER_NODE   pDriverNode
    )
/*++

Routine Description:
    Free the memory allocated for elements in the PDRIVER_NODE linked list

Arguments:
    pDriverNode    : Points to the head of linked list to free memory

Return Value:
    None

--*/
{
    PDRIVER_NODE   pNext;

    while ( pDriverNode ) {

        pNext = pDriverNode->pNext;
        FreeDriverNode(pDriverNode);
        pDriverNode = pNext;
    }
}

VOID
FreePortNode(
    IN  PPORT_NODE   pPortNode
    )
/*++

Routine Description:
    Free the memory allocated for a PORT_NODE element and fields in it

Arguments:
    PPORT_NODE : Points to the structure to free memory

Return Value:
    None

--*/
{
    if (pPortNode->pPortName)
    {
        FreeMem(pPortNode->pPortName);
    }

    FreeMem(pPortNode);
}

VOID
FreePortNodeList(
    IN  PPORT_NODE   pPortNode
    )
/*++

Routine Description:
    Free the memory allocated for elements in the PORT_NODE linked list

Arguments:
    pPortNode    : Points to the head of linked list to free memory

Return Value:
    None

--*/
{
    PPORT_NODE   pNext;

    while ( pPortNode ) {

        pNext = pPortNode->pNext;
        FreePortNode(pPortNode);
        pPortNode = pNext;
    }
}

PPSETUP_LOCAL_DATA
FindLocalDataForDriver(
    IN  PDRIVER_NODE    pDriverList,
    IN  LPSTR           pszDriverName
    )
/*++

Routine Description:
    Find the local data for a given driver name from the list

Arguments:

Return Value:
    Valid PPSETUP_LOCAL_DATA on success, else NULL

--*/
{

    while ( pDriverList ) {

        if ( !_strcmpi(pszDriverName, pDriverList->DrvInfo1.pName) )
            return pDriverList->pLocalData;

        pDriverList = pDriverList->pNext;
    }

    return NULL;

}


BOOL
InitLazyLoadInfo(
    VOID
    )
/*++

Routine Description:
    Initializes the LAZYLOAD_INFO structure with LoadLibrary & GetProcAddress

Arguments:
    None

Return Value:
    TRUE on success, FALSE else

--*/
{
    if ( LAZYLOAD_INFO.hNtPrint = LoadLibraryUsingFullPathA("ntprint.dll") ) {

        (FARPROC)LAZYLOAD_INFO.pfnCreatePrinterDeviceInfoList
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupCreatePrinterDeviceInfoList");

        (FARPROC)LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupDestroyPrinterDeviceInfoList");

        (FARPROC)LAZYLOAD_INFO.pfnBuildDriversFromPath
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupBuildDriversFromPath");

        (FARPROC)LAZYLOAD_INFO.pfnDriverInfoFromName
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupDriverInfoFromName");

        (FARPROC)LAZYLOAD_INFO.pfnDestroySelectedDriverInfo
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupDestroySelectedDriverInfo");

        (FARPROC)LAZYLOAD_INFO.pfnGetLocalDataField
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupGetLocalDataField");

        (FARPROC)LAZYLOAD_INFO.pfnFreeDrvField
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupFreeDrvField");

        (FARPROC)LAZYLOAD_INFO.pfnProcessPrinterAdded
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupProcessPrinterAdded");

        (FARPROC)LAZYLOAD_INFO.pfnInstallICMProfiles
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupInstallICMProfiles");

        (FARPROC)LAZYLOAD_INFO.pfnAssociateICMProfiles
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupAssociateICMProfiles");

        if ( LAZYLOAD_INFO.pfnCreatePrinterDeviceInfoList   &&
             LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList  &&
             LAZYLOAD_INFO.pfnBuildDriversFromPath          &&
             LAZYLOAD_INFO.pfnDriverInfoFromName            &&
             LAZYLOAD_INFO.pfnDestroySelectedDriverInfo     &&
             LAZYLOAD_INFO.pfnGetLocalDataField             &&
             LAZYLOAD_INFO.pfnFreeDrvField                  &&
             LAZYLOAD_INFO.pfnProcessPrinterAdded           &&
             LAZYLOAD_INFO.pfnInstallICMProfiles            &&
             LAZYLOAD_INFO.pfnAssociateICMProfiles ) {

#ifdef VERBOSE
    DebugMsg("Succesfully loaded Ntprint.dll");
#endif
            return TRUE;
    }

    }

    if ( LAZYLOAD_INFO.hNtPrint )
    {
        FreeLibrary(LAZYLOAD_INFO.hNtPrint);
        LAZYLOAD_INFO.hNtPrint = NULL;
    }

    return FALSE;
}


VOID
DeleteWin95Files(
    )
/*++

Routine Description:
    Read the migrate.inf and delete the files which are not needed on NT.

Arguments:
    None

Return Value:
    None

--*/
{
    HINF            hInf;
    CHAR            szPath[MAX_PATH];
    LONG            Count, Index;
    INFCONTEXT      InfContext;

    StringCchPrintfA(szPath, SIZECHARS(szPath), "%s\\%s", UpgradeData.pszDir, "migrate.inf");

    hInf = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);

    if ( hInf == INVALID_HANDLE_VALUE )
        return;

    //
    // We will only do the deleting part here. Files which are handled by
    // the core migration dll do not have a destination directory since we
    // are recreating the printing environment from scratch
    //
    if ( (Count = SetupGetLineCountA(hInf, "Moved")) != -1 ) {

        for ( Index = 0 ; Index < Count ; ++Index ) {

            if ( SetupGetLineByIndexA(hInf, "Moved", Index, &InfContext)    &&
                 SetupGetStringFieldA(&InfContext, 0, szPath,
                                      SIZECHARS(szPath), NULL) )
                DeleteFileA(szPath);
        }
    }

    SetupCloseInfFile(hInf);
}


BOOL
ReadWin9xPrintConfig(
    IN  OUT PDRIVER_NODE   *ppDriverNode,
    IN  OUT PPRINTER_NODE  *ppPrinterNode,
    IN  OUT PPORT_NODE  *ppPortNode
    )
/*++

Routine Description:
    Reads the Win9x printing configuration we stored in the text file
    so that printing components can be upgraded

Arguments:
    ppDriverNode            : Gives the list of drivers on Win9x
    ppPrinterNode           : Gives the list of printers on Win9x

Return Value:
    TRUE on successfully reading the config information, FALSE else

--*/
{
    BOOL                bFail = FALSE, bRet = FALSE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    CHAR                c, szLine[2*MAX_PATH];
    DWORD               dwCount, dwIndex, dwSize;
    PDRIVER_NODE        pDrv = NULL;
    PPRINTER_NODE       pPrn;
    PPORT_NODE          pPort;

    if(!SUCCEEDED(StringCchPrintfA(szLine, SIZECHARS(szLine), "%s\\%s", UpgradeData.pszDir, "print95.txt")))
    {
        goto Cleanup;
    }

    hFile = CreateFileA(szLine,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
        goto Cleanup;

    dwSize = sizeof(szLine)/sizeof(szLine[0]);

    //
    // First we have the drivers
    //
    if ( My_fgets(szLine, dwSize, hFile) == NULL    ||
         strncmp(szLine, "[PrinterDrivers]", strlen("[PrinterDrivers]")) )
        goto Cleanup;

    do {

        //
        // Skip blanks
        //
        do {
            c = (CHAR) My_fgetc(hFile);
        } while ( c == ' ');

        //
        // If we hit EOF it is an error. Configuration was not written properly
        // If we hit a new-line then we are at the end of the section
        //
        if ( c == EOF )
            goto Cleanup;
        else if ( c == '\n' )
            break;  // This is the normal exit from the do loop

        if ( isdigit(c) ) {

            //
            // Put the string lengh digit back
            //
            if ( !My_ungetc(hFile) )
                goto Cleanup;
        }

        if ( !(pDrv = AllocMem(sizeof(DRIVER_NODE))) )
            goto Cleanup;

        ReadString(hFile, "", &pDrv->DrvInfo1.pName, FALSE, &bFail);

        if ( bFail ) {

            FreeDriverNode(pDrv);
            goto Cleanup;
        }

        pDrv->pNext     = *ppDriverNode;
        *ppDriverNode   = pDrv;
    } while ( !bFail );


    //
    // Now we have port info
    //

    if ( My_fgets(szLine, dwSize, hFile) == NULL    ||
         strncmp(szLine, "[Ports]", strlen("[Ports]")) )
        goto Cleanup;

    do {

        //
        // Skip blanks
        //
        do {
            c = (CHAR) My_fgetc(hFile);
        } while ( isspace(c)  && c != '\n' );

        //
        // EOF can happen if no ports and no printers, else it's an error
        //
        if ( c == EOF)
        {
            if (!pDrv)
            {
                bRet = TRUE;
            }
            goto Cleanup;
        }

        //
        // a blank line means the end of the port info section
        //
        if (c == '\n')
            break;

        if ( c != 'P' || !My_ungetc(hFile) )
            goto Cleanup;

        //
        // Create port node
        //
        if ( !(pPort = AllocMem(sizeof(PORT_NODE))) )
        {
            goto Cleanup;
        }

        ReadString(hFile, "PortName:", &pPort->pPortName, FALSE, &bFail);

        if (bFail)
        {
            FreePortNode(pPort);
            goto Cleanup;
        }

        pPort->pNext = *ppPortNode;
        *ppPortNode = pPort;

    } while ( !bFail );

    //
    // Now we have printer info
    //
    if ( My_fgets(szLine, dwSize, hFile) == NULL    ||
         strncmp(szLine, "[Printers]", strlen("[Printers]")) )
        goto Cleanup;

    do {

        c = (CHAR) My_fgetc(hFile);

        if ( c == EOF || c == '\n' )
            break;  // Normal exit

        if ( c != 'S' || !My_ungetc(hFile) )
            goto Cleanup;

        if ( !(pPrn = AllocMem(sizeof(PRINTER_NODE))) )
            goto Cleanup;

        ReadPrinterInfo2(hFile, &pPrn->PrinterInfo2, &bFail);

        if ( bFail ) {

            FreePrinterNode(pPrn);
            goto Cleanup;
        }

        pPrn->pNext = *ppPrinterNode;
        *ppPrinterNode = pPrn;
    } while ( !bFail );

    bRet = TRUE;

Cleanup:

    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle(hFile);

    return bRet && !bFail;
}


BOOL
CheckAndAddMonitor(
    IN  LPDRIVER_INFO_6W    pDrvInfo6
    )
/*++

Routine Description:
    Check if there is a language monitor associated with the given driver
    and add it.

Arguments:

Return Value:
    TRUE on success, FALSE on failure
    None

--*/
{
    MONITOR_INFO_2W MonitorInfo2;
    LPWSTR          psz = pDrvInfo6->pMonitorName;
    LPSTR           pszStr;

    if ( psz && *psz ) {

        MonitorInfo2.pName          = psz;
        MonitorInfo2.pEnvironment   = NULL;
        MonitorInfo2.pDLLName       = (LPWSTR) (psz+wcslen(psz)+1);

        //
        // Add is succesful, or monitor is already installed?
        //
        if ( AddMonitorW(NULL, 2, (LPBYTE) &MonitorInfo2) ||
            GetLastError() == ERROR_PRINT_MONITOR_ALREADY_INSTALLED ) {

            return TRUE;
        } else {

            if ( pszStr = ErrorMsg() ) {

                LogError(LogSevError, IDS_ADDMONITOR_FAILED,
                         psz, pszStr);
                FreeMem(pszStr);
            }
            return FALSE;
        }
    }

    return TRUE;
}


VOID
KeepAliveThread(
    HANDLE  hRunning
    )
/*++

Routine Description:
    Printing migration may take a long time depending on number of printers and
    how long spooler takes to return. To inform setup that we are still alive
    I need to set a named event atleast once every 3 minutes

Arguments:
    hRunning    : When this gets closed we know processing is done

Return Value:
    None

--*/
{
    //
    // Every 30 seconds set the global event telling we are still alive
    //
    do {

        SetEvent(hAlive);
    } while ( WAIT_TIMEOUT == WaitForSingleObject(hRunning, 1000*30) );

    CloseHandle(hAlive);
    hAlive = NULL;
}


VOID
UpgradePrinterDrivers(
    IN      PDRIVER_NODE    pDriverNode,
    IN      HDEVINFO        hDevInfo,
    IN  OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Upgrades printer drivers by doing the file copy operations and calling
    AddPrinterDriver on spooler

Arguments:
    pUpgradableDrvNode      : List of drivers to upgrade
    pbFail                  : Set on an error -- no more processing needed

Return Value:
    None

--*/
{
    BOOL            bDriverToUpgrade = FALSE;
    LPWSTR          pszDriverW, pszICMW;
    LPSTR           pszDriverA, pszStr;
    PDRIVER_NODE    pCur;
    DRIVER_FIELD    DrvField;

    //
    // Set device install parameters so ntprint.dll will just queue up the
    // driver files and return without doing the copy. We will commit the
    // file queue at the end
    //
    if ( !InitFileCopyOnNT(hDevInfo) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    //
    // Now for each printer driver call ntprint.dll to queue up the driver files
    // If it fails log an error
    //
    for ( pCur = pDriverNode ; pCur ; pCur = pCur->pNext ) {

        pszDriverA = pCur->DrvInfo1.pName;

        if ( (pszDriverW = AllocStrWFromStrA(pszDriverA))                   &&
             (pCur->pLocalData = LAZYLOAD_INFO.pfnDriverInfoFromName(
                                            hDevInfo, (LPSTR)pszDriverW))   &&
             SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                       hDevInfo,
                                       NULL) ) {

            bDriverToUpgrade = TRUE;
        } else {

            pCur->bCantAdd = TRUE;
        }

        FreeMem(pszDriverW);
        pszDriverW = NULL;
    }

    if ( !bDriverToUpgrade )
        goto Cleanup;


#ifdef  VERBOSE
    DebugMsg("Starting file copy ...");
#endif

    //
    // Now commit the file queue to copy the files
    //
    if ( !CommitFileQueueToCopyFiles(hDevInfo) ) {

        *pbFail = TRUE;
        if ( pszStr = ErrorMsg() ) {

            LogError(LogSevError, IDS_DRIVERS_UPGRADE_FAILED, pszStr);
            FreeMem(pszStr);
            pszStr = NULL;
        }
        goto Cleanup;
    }

#ifdef  VERBOSE
    DebugMsg("... files copied successfully");
#endif

    //
    // Now call spooler to install the printer driver. Also install the
    // ICM profiles associated with the printer driver
    //
    for ( pCur = pDriverNode ; pCur ; pCur = pCur->pNext ) {

        //
        // We already logged an error if bCantAdd is TRUE
        //
        if ( pCur->bCantAdd )
            continue;

        DrvField.Index          = DRV_INFO_6;
        DrvField.pDriverInfo6   = NULL;

        if ( !LAZYLOAD_INFO.pfnGetLocalDataField(pCur->pLocalData,
                                                 PlatformX86,
                                                 &DrvField)                 ||
             !CheckAndAddMonitor((LPDRIVER_INFO_6W) DrvField.pDriverInfo6)  ||
             !AddPrinterDriverW(NULL,
                                6,
                                (LPBYTE)DrvField.pDriverInfo6) ) {

            if ( pszStr = ErrorMsg() ) {

                LogError(LogSevError, IDS_ADDDRIVER_FAILED, pCur->DrvInfo1.pName, pszStr);
                FreeMem(pszStr);
                pszStr = NULL;
            }
        }

        LAZYLOAD_INFO.pfnFreeDrvField(&DrvField);

        DrvField.Index          = ICM_FILES;
        DrvField.pszzICMFiles   = NULL;

        if ( !LAZYLOAD_INFO.pfnGetLocalDataField(pCur->pLocalData,
                                                 PlatformX86,
                                                 &DrvField) ) {

            continue;
        }

        if ( DrvField.pszzICMFiles )
            LAZYLOAD_INFO.pfnInstallICMProfiles(NULL,
                                                DrvField.pszzICMFiles);

        LAZYLOAD_INFO.pfnFreeDrvField(&DrvField);

    }

Cleanup:
    return;
}

typedef BOOL (WINAPI *P_XCV_DATA_W)(
                                    IN HANDLE  hXcv,
                                    IN PCWSTR  pszDataName,
                                    IN PBYTE   pInputData,
                                    IN DWORD   cbInputData,
                                    OUT PBYTE   pOutputData,
                                    IN DWORD   cbOutputData,
                                    OUT PDWORD  pcbOutputNeeded,
                                    OUT PDWORD  pdwStatus
                                );

BOOL
AddLocalPort(
    IN  LPSTR           pPortName
)
/*++

Routine Description:
    Adds a local port

Arguments:
    pPortName    : Name of the local port to add

Return Value:
    FALSE if a port can't be added.

--*/

{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE  hXcvMon = NULL;
    BOOL  bReturn = FALSE;

    if (OpenPrinterA(",XcvMonitor Local Port", &hXcvMon, &PrinterDefault))
    {
        DWORD cbOutputNeeded = 0;
        DWORD Status         = NO_ERROR;
        WCHAR *pUnicodePortName = NULL;
        P_XCV_DATA_W pXcvData = NULL;
        HMODULE hWinSpool = NULL;

        //
        // if I implib-link to XcvData, loading the migrate.dll on Win9x will fail !
        //
        hWinSpool = LoadLibraryUsingFullPathA("winspool.drv");

        if (!hWinSpool)
        {
            DebugMsg("LoadLibrary on winspool.drv failed");
            goto Done;
        }

        pXcvData = (P_XCV_DATA_W) GetProcAddress(hWinSpool, "XcvDataW");

        if (!pXcvData)
        {
            DebugMsg("GetProcAddress on winspool.drv failed");
            goto Done;
        }

        pUnicodePortName = AllocStrWFromStrA(pPortName);
        if (pUnicodePortName)
        {
            bReturn = (*pXcvData)(hXcvMon,
                              L"AddPort",
                              (LPBYTE) pUnicodePortName,
                              (wcslen(pUnicodePortName) +1) * sizeof(WCHAR),
                              NULL,
                              0,
                              &cbOutputNeeded,
                              &Status
                              );

            FreeMem(pUnicodePortName);
            pUnicodePortName = NULL;
        }

    Done:
        if (hWinSpool)
        {
            FreeLibrary(hWinSpool);
        }
        ClosePrinter(hXcvMon);
   }

   return bReturn;
}

VOID
UpgradePrinters(
    IN  PPRINTER_NODE   pPrinterNode,
    IN  PDRIVER_NODE    pDriverNode,
    IN  PPORT_NODE     *ppPortNode,
    IN  HDEVINFO        hDevInfo
    )
/*++

Routine Description:
    Upgrade printers on NT

Arguments:
    pPrinterNode    : Gives the list giving information about the printers
                      which existed on Win9x

Return Value:
    None

--*/
{
    DWORD               dwLen, dwLastError;
    LPSTR               pszStr, pszPrinterNameA;
    LPWSTR              pszPrinterNameW;
    HANDLE              hPrinter;
    DRIVER_FIELD        DrvField;
    PPSETUP_LOCAL_DATA  pLocalData;
    PPORT_NODE          pCurPort, pPrevPort = NULL;
    DWORD               dwSize;
    LPSTR               pszVendorSetupA = NULL;


    for ( ; pPrinterNode ; pPrinterNode = pPrinterNode->pNext ) {

        pszPrinterNameA = pPrinterNode->PrinterInfo2.pPrinterName;

        //
        // check whether this printer uses a non-standard local file port
        //
        for (pCurPort = *ppPortNode; pCurPort != NULL; pPrevPort = pCurPort, pCurPort = pCurPort->pNext)
        {
            if (lstrcmpi(pPrinterNode->PrinterInfo2.pPortName, pCurPort->pPortName) == 0)
            {
                //
                // Create the port
                //
                AddLocalPort(pCurPort->pPortName);

                //
                // remove it from the list
                //
                if (pCurPort == *ppPortNode)
                {
                    *ppPortNode = pCurPort->pNext;
                }
                else
                {
                    pPrevPort->pNext = pCurPort->pNext;
                }

                FreePortNode(pCurPort);

                break;
            }
        }

        hPrinter = AddPrinterA(NULL,
                               2,
                               (LPBYTE)&pPrinterNode->PrinterInfo2);

        if ( !hPrinter ) {

            dwLastError = GetLastError();

            //
            // If driver is unknown we already logged warned the user
            // If printer already exists it is ok (for Fax printer this is true)
            //
            if ( dwLastError != ERROR_UNKNOWN_PRINTER_DRIVER        &&
                 dwLastError != ERROR_INVALID_PRINTER_NAME          &&
                 dwLastError != ERROR_PRINTER_ALREADY_EXISTS        &&
                 (pszStr = ErrorMsg()) ) {

                LogError(LogSevError,
                         IDS_ADDPRINTER_FAILED,
                         pszPrinterNameA,
                         pszStr);
                FreeMem(pszStr);
                pszStr = NULL;
            }
            continue;
        }

        pLocalData = FindLocalDataForDriver(pDriverNode,
                                            pPrinterNode->PrinterInfo2.pDriverName);
        pszPrinterNameW = AllocStrWFromStrA(pszPrinterNameA);

        if ( pLocalData && pszPrinterNameW ) {

            DrvField.Index          = ICM_FILES;
            DrvField.pszzICMFiles   = NULL;

            if ( LAZYLOAD_INFO.pfnGetLocalDataField(pLocalData,
                                                    PlatformX86,
                                                    &DrvField) ) {

                if ( DrvField.pszzICMFiles )
                    LAZYLOAD_INFO.pfnAssociateICMProfiles(
                                            (LPTSTR)pszPrinterNameW,
                                            DrvField.pszzICMFiles);

                LAZYLOAD_INFO.pfnFreeDrvField(&DrvField);
            }

            LAZYLOAD_INFO.pfnProcessPrinterAdded(hDevInfo,
                                                 pLocalData,
                                                 (LPTSTR)pszPrinterNameW,
                                                 INVALID_HANDLE_VALUE);

            dwSize = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)(pLocalData->InfInfo.pszVendorSetup), 
                                         -1, NULL, 0, NULL, NULL);
            if (dwSize > 0)
            {
                pszVendorSetupA = (LPSTR)AllocMem( dwSize );
                if (pszVendorSetupA)
                {
                    if (WideCharToMultiByte (CP_ACP, 0, (LPCWSTR)(pLocalData->InfInfo.pszVendorSetup),
                                             -1, pszVendorSetupA, dwSize, NULL, NULL))
                    {
                        WriteVendorSetupInfoInRegistry( pszVendorSetupA, pszPrinterNameA );

                    }
                    FreeMem( pszVendorSetupA );
                    pszVendorSetupA = NULL;
                }
            }
        }

        //
        // Default printer will be the one with PRINTER_ATTRIBUTE_DEFAULT attribute
        // If the Win95 default printer could not be added to NT we will set the
        // first printer as the default printer
        //
        if ( (pPrinterNode->PrinterInfo2.Attributes
                                    & PRINTER_ATTRIBUTE_DEFAULT) ||
             !pDefPrinter )
            pDefPrinter = pPrinterNode;


        FreeMem(pszPrinterNameW);
        ClosePrinter(hPrinter);
    }

    if ( pDefPrinter )
        pszDefaultPrinterString = GetDefPrnString(
                                    pDefPrinter->PrinterInfo2.pPrinterName);
}


HDEVINFO
PrinterDevInfo(
    IN OUT  LPBOOL  pbFail
    )
/*++

--*/
{
    HDEVINFO                hDevInfo = INVALID_HANDLE_VALUE;

    if ( *pbFail || !InitLazyLoadInfo() ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    hDevInfo = LAZYLOAD_INFO.pfnCreatePrinterDeviceInfoList(INVALID_HANDLE_VALUE);
    if ( hDevInfo == INVALID_HANDLE_VALUE   ||
         !LAZYLOAD_INFO.pfnBuildDriversFromPath(hDevInfo,
                                                (LPSTR)L"ntprint.inf",
                                                TRUE) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

#ifdef  VERBOSE
    DebugMsg("Built the list of printer drivers from ntprint.inf");
#endif

    if ( *pbFail && hDevInfo != INVALID_HANDLE_VALUE ) {

        LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList(hDevInfo);
        hDevInfo = INVALID_HANDLE_VALUE;
    }

Cleanup:
    return hDevInfo;
}


LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR pszWorkingDir,
    IN  LPCWSTR pszSourceDir,
    LPVOID      Reserved
    )
/*++

Routine Description:
    Setup calls this to intialize us on NT side

Arguments:
    pszWorkingDir   : Gives the working directory assigned for printing
    pszSourceDir    : Source location for NT distribution files
    Reserved        : Leave it alone

Return Value:
    Win32 error code

--*/
{
    BOOL                    bFail = FALSE;
    DWORD                   dwReturn, ThreadId;
    HANDLE                  hRunning = NULL, hThread;
    HDSKSPC                 DiskSpace;
    LPSTR                   pszStr;
    HDEVINFO                hDevInfo = INVALID_HANDLE_VALUE;
    PDRIVER_NODE            pDriverNode = NULL;
    PPRINTER_NODE           pPrinterNode = NULL;
    PPORT_NODE              pPortNode = NULL;


#ifdef VERBOSE
    DebugMsg("InitializeNT : %ws, %ws", pszSourceDir, pszWorkingDir);
#endif

    UpgradeData.pszDir      = AllocStrAFromStrW(pszWorkingDir);
    UpgradeData.pszSourceW  = AllocStrW(pszSourceDir);
    UpgradeData.pszSourceA  = AllocStrAFromStrW(pszSourceDir);

    if ( !UpgradeData.pszDir        ||
         !UpgradeData.pszSourceW    ||
         !UpgradeData.pszSourceA ) {

        return GetLastError();
    }

    if ( (hAlive = OpenEventA(EVENT_MODIFY_STATE, FALSE, "MigDllAlive"))    &&
         (hRunning = CreateEventA(NULL, FALSE, FALSE, NULL))                &&
         (hThread = CreateThread(NULL, 0,
                                 (LPTHREAD_START_ROUTINE)KeepAliveThread,
                                 hRunning,
                                 0, &ThreadId)) )
        CloseHandle(hThread);

    SetupOpenLog(FALSE);

    DeleteWin95Files();

    if ( !ReadWin9xPrintConfig(&pDriverNode, &pPrinterNode, &pPortNode) ) {

        bFail = TRUE;
        DebugMsg("Unable to read Windows 9x printing configuration");
        goto Cleanup;
    }

#ifdef  VERBOSE
    DebugMsg("Succesfully read Windows 9x printing configuration");
#endif

    //
    // If no printers or drivers found nothing to do
    //
    if ( !pDriverNode && !pPrinterNode )
        goto Cleanup;

    if ( (hDevInfo = PrinterDevInfo(&bFail)) == INVALID_HANDLE_VALUE )
        goto Cleanup;

    UpgradePrinterDrivers(pDriverNode, hDevInfo, &bFail);

    UpgradePrinters(pPrinterNode, pDriverNode, &pPortNode, hDevInfo);

    MakeACopyOfMigrateDll( UpgradeData.pszDir );

Cleanup:

    SetupCloseLog();

    if ( bFail && (pszStr = ErrorMsg()) ) {

        DebugMsg("Printing migration failed. %s", pszStr);
        FreeMem(pszStr);
        pszStr = NULL;
    }

    FreePrinterNodeList(pPrinterNode);
    FreeDriverNodeList(pDriverNode);
    FreePortNodeList(pPortNode);
    pPrinterNode = NULL;
    pDriverNode  = NULL;
    pPortNode    = NULL;

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList(hDevInfo);

    if ( LAZYLOAD_INFO.hNtPrint )
        FreeLibrary(LAZYLOAD_INFO.hNtPrint);

    if ( bFail ) {

        if ( (dwReturn = GetLastError()) == ERROR_SUCCESS ) {

            ASSERT(dwReturn != ERROR_SUCCESS);
            dwReturn = STG_E_UNKNOWN;
        }
    } else {

        SetupNetworkPrinterUpgrade(UpgradeData.pszDir);
        dwReturn = ERROR_SUCCESS;

#ifdef VERBOSE
        DebugMsg("InitializeNT returning success");
#endif

    }

    if ( hRunning )
        CloseHandle(hRunning);

    while (hAlive)
        Sleep(100); // Check after 0.1 second for the main thread to die

    return  dwReturn;
}


DWORD
MySetDefaultPrinter(
    IN  HKEY    hUserRegKey,
    IN  LPSTR   pszDefaultPrinterString
    )
/*++

Routine Description:
    Sets the default printer for the user by writing it to the registry

Arguments:

Return Value:

--*/
{
    DWORD   dwReturn;
    HKEY    hKey = NULL;

    //
    // Create the printers key in the user hive and write DeviceOld value
    //
    dwReturn = RegCreateKeyExA(hUserRegKey,
                               "Printers",
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               NULL);

    if ( dwReturn == ERROR_SUCCESS ) {

        dwReturn = RegSetValueExA(hKey,
                                  "DeviceOld",
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszDefaultPrinterString,
                                  (strlen(pszDefaultPrinterString) + 1)
                                            * sizeof(CHAR));

        RegCloseKey(hKey);
    }

    return dwReturn;
}


LONG
CALLBACK
MigrateUserNT(
    IN  HINF        hUnattendInf,
    IN  HKEY        hUserRegKey,
    IN  LPCWSTR     pszUserName,
        LPVOID      Reserved
    )
/*++

Routine Description:
    Migrate user settings

Arguments:

Return Value:

--*/
{
    LPSTR   pszStr;
    DWORD   dwReturn = ERROR_SUCCESS;

#ifdef  VERBOSE
        DebugMsg("Migrating settings for %ws", pszUserName);
#endif

    if ( pszDefaultPrinterString ) {

         dwReturn = MySetDefaultPrinter(hUserRegKey,
                                        pszDefaultPrinterString);

        if ( dwReturn )
            DebugMsg("MySetDefaultPrinter failed with %d", dwReturn);
    }

    if ( bDoNetPrnUpgrade ) {

        if ( ProcessNetPrnUpgradeForUser(hUserRegKey) )
            ++dwRunOnceCount;
        else {

            if ( dwReturn == ERROR_SUCCESS )
                dwReturn = GetLastError();
            DebugMsg("ProcessNetPrnUpgradeForUser failed with %d", dwReturn);
        }
    }

#ifdef  VERBOSE
    if ( dwReturn )
        DebugMsg("MigrateUserNT failed with %d", dwReturn);
    else
        DebugMsg("MigrateUserNT succesful");
#endif

    return  dwReturn;
}


LONG
CALLBACK
MigrateSystemNT(
    IN  HINF    hUnattendInf,
        LPVOID  Reserved
    )
/*++

Routine Description:
    Process system setttings for printing. All the printing setting are
    migrated in InitializeNT since we need to know the default printer for
    each user in the MigrateSystemNT call

Arguments:
    hUnattendInf    : Handle to the unattended INF

Return Value:
    Win32 error code

--*/
{
    WriteRunOnceCount();
    return ERROR_SUCCESS;
}


//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//
P_INITIALIZE_NT     pfnInitializeNT         = InitializeNT;
P_MIGRATE_USER_NT   pfnMigrateUserNt        = MigrateUserNT;
P_MIGRATE_SYSTEM_NT pfnMigrateSystemNT      = MigrateSystemNT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Muhunthan Sivapragasam (MuhuntS)  17-Oct-1995

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <objbase.h>
#include <shellapi.h>
#include <setupapi.h>
#include <initguid.h>
#include <cfgmgr32.h>
#include "splsetup.h"
#include "local.h"
#include <plugin.h>
#include "strsafe.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\test\win9x.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Win9x.c

Abstract:

    Test pre-migration of Win95 to NT

Author:
    MuhuntS


Revision History:
    01-17-97


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#include <plugin.h>

P_QUERY_VERSION         QueryVersion;
P_INITIALIZE_9X         Initialize9x;
P_MIGRATE_SYSTEM_9X     MigrateSystem9x;

P_INITIALIZE_NT         InitializeNT;
P_MIGRATE_SYSTEM_NT     MigrateSystemNT;

WCHAR   szSrcDir[MAX_PATH], szWrkDir[MAX_PATH];

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    PVENDORINFO     pVI;
    HMODULE         hModule;
    HANDLE          hAlive = NULL;
    DWORD           dwLastError;
    LPSTR           p1, p2, p3, p4, p5;
    LONG            x;
    UINT            v;
    INT             c;
    LONG            lLastErr;
    char            error_buffer[300];

    p1 = p2 = p3 = p4 = p5 = NULL;

    if ( argc < 3 ) {

        printf("Usage: %s <working-dir> <source-dir>\n", argv[0]);
        return 0;
    }

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        lLastErr = GetLastError();

        FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, NULL, lLastErr, 0L, error_buffer,
            sizeof(error_buffer), NULL );

        printf("%s: LoadLibrary failed with %d - %s\n", argv[0], lLastErr, error_buffer);
        goto Cleanup;
    }

    //
    // Nt only?
    //
    if ( argc == 4 && argv[3][0] == '+' )
        goto DoNT;

    (FARPROC) QueryVersion      = GetProcAddress(hModule, "QueryVersion");
    (FARPROC) Initialize9x      = GetProcAddress(hModule, "Initialize9x");
    (FARPROC) MigrateSystem9x   = GetProcAddress(hModule, "MigrateSystem9x");

    if ( !QueryVersion || !Initialize9x || !MigrateSystem9x )
        goto Cleanup;

    x = QueryVersion(&p1, (LPUINT)&p2, (LPINT*)&p3, &p4, (PVENDORINFO*)&pVI);

    printf("QueryVersion returned %d\n", x);

    x = Initialize9x(argv[1], argv[2], 0);

    printf("Initialize9x returned %d\n", x);

    x = MigrateSystem9x(0, NULL, 0);

    printf("MigrateSystem9x returned %d\n", x);

    FreeLibrary(hModule);

    //
    // Win95 only?
    //
    if ( argc == 4 && argv[3][0] == '-' )
        goto Cleanup;

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        lLastErr = GetLastError();

        FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, NULL, lLastErr, 0L, error_buffer,
            sizeof(error_buffer), NULL );

        printf("%s: LoadLibrary II failed with %d - %s\n", argv[0], lLastErr, error_buffer);
        goto Cleanup;
    }

DoNT:
    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[1],
                        -1,
                        szWrkDir,
                        MAX_PATH);

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[2],
                        -1,
                        szSrcDir,
                        MAX_PATH);

    InitializeNT     = (P_INITIALIZE_NT)GetProcAddress(hModule, "InitializeNT");
    MigrateSystemNT  = (P_MIGRATE_SYSTEM_NT)GetProcAddress(hModule, "MigrateSystemNT");

    if ( !InitializeNT || !MigrateSystemNT )
        goto Cleanup;

    hAlive = CreateEventA(NULL, FALSE, FALSE, "MigDllAlive");

    if ( ERROR_SUCCESS == InitializeNT(szWrkDir, szSrcDir, 0) )
        MigrateSystemNT(INVALID_HANDLE_VALUE, 0);

    FreeLibrary(hModule);
Cleanup:
    if ( hModule )
        FreeLibrary(hModule);

    if ( hAlive )
        CloseHandle(hAlive);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\enum.cpp ===
/*****************************************************************************\
* MODULE:       enum.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiRequestContainerEnum::TBidiRequestContainerEnum (
    TBidiRequestContainer & refContainer,
    TReqInterfaceList & refReqList):
    m_refReqList (refReqList),
    m_refContainer (refContainer),
    m_cRef (1)
{
    m_refContainer.AddRef ();
    
    TAutoCriticalSection CritSec (m_refReqList);
    
    if (CritSec.bValid ())  {
        m_pHead = m_refReqList.GetHead();
        m_pCurrent = m_pHead;
        
        m_bValid = TRUE;
    }
    else 
        m_bValid = FALSE;

    
}

TBidiRequestContainerEnum::TBidiRequestContainerEnum (
    TBidiRequestContainerEnum & refEnum):
    m_refReqList (refEnum.m_refReqList),
    m_refContainer (refEnum.m_refContainer),
    m_cRef (1)
{
    m_refContainer.AddRef ();
    
    TAutoCriticalSection CritSec (m_refReqList);
    
    if (CritSec.bValid ())  {
        m_pHead = refEnum.m_pHead;
        m_pCurrent = refEnum.m_pCurrent;
        
        m_bValid = TRUE;
    }
    else 
        m_bValid = FALSE;
}


TBidiRequestContainerEnum::~TBidiRequestContainerEnum ()
{
    DBGMSG(DBG_TRACE,("TBidiRequestContainerEnum Destory Self\n"));
    m_refContainer.Release ();
}


STDMETHODIMP 
TBidiRequestContainerEnum::QueryInterface (
    REFIID iid,
    void** ppv)
{
    HRESULT hr = S_OK;
                
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IUnknown*>(this) ; 
	}
    else if (iid == IID_IEnumUnknown) {
    
		*ppv = static_cast<IEnumUnknown*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}
    
    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }
    
    DBGMSG(DBG_TRACE,("Leave TBidiRequestContainerEnum QI hr=%x\n", hr));
	return hr ;
    
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainerEnum::AddRef () 
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::AddRef ref= %d\n", m_cRef));
    
    // We add a reference to the container so that the container won't
    // delete the list where there is an outstadning enummeration 
    //
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainerEnum::Release () 
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}


STDMETHODIMP 
TBidiRequestContainerEnum::Next ( 
    IN  ULONG celt,          
    OUT IUnknown ** rgelt,   
    OUT ULONG * pceltFetched) 
{
    HRESULT hr;
    DWORD dwCount = 0;
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Next\n"));

    if (m_bValid) {

        if (rgelt && pceltFetched) {
    
            TAutoCriticalSection CritSec (m_refReqList);
            
            if (CritSec.bValid ())  {
        
                while (m_pCurrent && dwCount < celt) {
                    TBidiRequestInterfaceData * pData = m_pCurrent->GetData ();
                    
                    *rgelt =  (IUnknown *) pData->GetInterface();
                    (*rgelt++)->AddRef ();
                    m_pCurrent = m_pCurrent->GetNext ();
                    dwCount++;
                }
            
                *pceltFetched = dwCount;
            
                hr =  S_OK;
            }
            else
                hr = LastError2HRESULT ();
        }
        else
            hr = E_POINTER;
    }
    else
        hr = E_HANDLE;
    
    return hr;        
}

STDMETHODIMP 
TBidiRequestContainerEnum::Skip (
    IN  ULONG celt)
{
    HRESULT hr;

    DWORD dwCount = 0;
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Skip\n"));
    
    if (m_bValid) {
        TAutoCriticalSection CritSec (m_refReqList);
        
        if (CritSec.bValid ())  {
        
            while (m_pCurrent && dwCount < celt) {
                m_pCurrent = m_pCurrent->GetNext ();
                dwCount++;
            }
            
            hr =  S_OK;
    
        }
        else
            hr = LastError2HRESULT ();
    }
    else
        hr = E_HANDLE;

    return hr;        
}

STDMETHODIMP 
TBidiRequestContainerEnum::Reset(void)
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Reset\n"));
    
    if (m_bValid) {
        m_pCurrent = m_pHead;
        return S_OK;
    }
    else
        return E_HANDLE;
    
}

STDMETHODIMP 
TBidiRequestContainerEnum::Clone(
    OUT IEnumUnknown ** ppenum)
{
    HRESULT hr;
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Clone\n"));
    
    if (m_bValid) {
        hr = PrivCreateComponent <TBidiRequestContainerEnum> (
                        new TBidiRequestContainerEnum (*this),
                        IID_IEnumUnknown, (void **)ppenum);
    }
    else 
        hr = E_HANDLE;

    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\win9x.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Win9x.c

Abstract:

    Routines to pre-migrate Win9x to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"

//
// This data structure is used to keep track of printer drivers installed on
// Win9x and their NT names
//
typedef struct  _DRIVER_INFO_9X {

    struct  _DRIVER_INFO_9X *pNext;
    LPSTR                    pszWin95Name;
    LPSTR                    pszNtName;
} DRIVER_INFO_9X, *PDRIVER_INFO_9X;


UPGRADABLE_LIST UpgradableMonitors[]    = { {"Local Port"}, { NULL } };


DWORD   dwNetPrinters       = 0;
DWORD   dwSharedPrinters    = 0;

CHAR    szRegPrefix[]     = "HKLM\\System\\CurrentControlSet\\Control\\Print\\";
CHAR    szRegPrefixOnly[] = "System\\CurrentControlSet\\control\\Print\\Printers";
CHAR    cszPrinterID[]    = "PrinterID";
CHAR    cszWinPrint[]     = "winprint";
CHAR    cszRaw[]          = "RAW";

//
// the following drivers need not be warned or upgraded, they're handled by 
// the fax folks. The names are not localized.
//
CHAR    *pcszIgnoredDrivers[] = {
    "Microsoft Shared Fax Driver",
    "Microsoft Fax Client",
    NULL
};

BOOL
IsIgnoredDriver(LPCSTR pszDriverName)
{
    DWORD i;

    for (i=0; pcszIgnoredDrivers[i] != NULL; i++)
    {
        if (!strcmp(pcszIgnoredDrivers[i], pszDriverName))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
SearchRegTreeForPrinterId(
    IN  DWORD   dwPrinterId,
    IN  LPCSTR  pszRegRoot,
    IN  LPSTR   pszBuf,
    IN  DWORD   cchBufLen
    )
/*++

Routine Description:
    This routine searchs a given registry tree of DevNodes for a given
    printer id.

Arguments:
    dwPrinterId     : Unique printer id we are searching for
    pszRegRoot      : Registry path relative to HKLM
    pszBuf          : Buffer to fill the registry key path on success
    cchBufLen       : size of key buffer in characters

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL        bFound = FALSE;
    DWORD       dwLen, dwIndex, dwDontCare, dwId, dwSize;
    HKEY        hKey, hSubKey;
    LPSTR       pszCur;
    DWORD       dwLastError;

    //
    // Copy the registry path
    //
    dwLen = strlen(pszRegRoot) + 1;
    if ( dwLen + 1 > cchBufLen )
        return FALSE;

    if ( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        pszRegRoot,
                                        0,
                                        KEY_READ,
                                        &hKey) )
        return FALSE;

    StringCchCopyA(pszBuf, cchBufLen, pszRegRoot);
    pszCur = pszBuf + dwLen;
    *(pszCur-1) = '\\';
    *pszCur = 0;

    //
    // Walk thru each devnode looking for a matching PrinterId
    //
    for ( dwIndex = 0, dwSize = cchBufLen - dwLen ;
          !bFound                                                   &&
          !RegEnumKeyExA(hKey, dwIndex, pszCur, &dwSize,
                         NULL, NULL, NULL, NULL)                    &&
          !RegOpenKeyExA(hKey, pszCur, 0, KEY_READ, &hSubKey) ;
          ++dwIndex, dwSize = cchBufLen - dwLen ) {

            dwSize = sizeof(dwId);
            if ( ERROR_SUCCESS == RegQueryValueExA(hSubKey,
                                                   cszPrinterID,
                                                   0,
                                                   &dwDontCare,
                                                   (LPBYTE)&dwId,
                                                   &dwSize) ) {
                if ( dwId == dwPrinterId ) {

                    dwLen  = strlen(pszBuf);
                    bFound = SUCCEEDED(StringCchCopyA(pszBuf + dwLen, cchBufLen - dwLen, "\""));
                }
            } else {

                bFound = SearchRegTreeForPrinterId(dwPrinterId,
                                                   pszBuf,
                                                   pszBuf,
                                                   cchBufLen);

                if ( !bFound ) {

                    StringCchCopyA(pszBuf, cchBufLen, pszRegRoot);
                    pszCur = pszBuf + dwLen;
                    *(pszCur-1) = '\\';
                    *pszCur = 0;
                }
            }

            RegCloseKey(hSubKey);
    }

    RegCloseKey(hKey);

    return bFound;
}


DWORD
GetPrinterId(
    LPSTR   pszPrinterName
    )
/*++

Routine Description:
    Given a printer id finds the printer id from PrinterDriverData.
    Call to GetPrinterData screws up migration dll local data for unknown
    reasons. So now we access the registry directly

Arguments:
    pszPrinterName  : Printer name to get id for

Return Value:
    0 on failure else PrinterID from registry is returned

--*/
{
    CHAR    szKey[MAX_PATH];
    HKEY    hKey;
    DWORD   dwId = 0, dwType, dwSize;

    if ( strlen(szRegPrefixOnly) + strlen(pszPrinterName)
                                 + strlen("PrinterDriverData")
                                 + 3 > MAX_PATH )
        return dwId;

    StringCchPrintfA(szKey, SIZECHARS(szKey), "%s\\%s\\PrinterDriverData", szRegPrefixOnly, pszPrinterName);

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szKey,
                                        0,
                                        KEY_READ,
                                        &hKey) ) {

        dwSize = sizeof(dwId);
        if ( ERROR_SUCCESS != RegQueryValueExA(hKey,
                                               cszPrinterID,
                                               0,
                                               &dwType,
                                               (LPBYTE)&dwId,
                                               &dwSize) )
            dwId = 0;

        RegCloseKey(hKey);
    }

    return dwId;
}


BOOL
RegPathFromPrinter(
    IN  LPSTR   pszPrinterName,
    OUT LPSTR   szKeyBuffer,
    IN  DWORD   cchKeyBufLen
    )
/*++

Routine Description:
    This routine returns the registry path of the DevNode for a printer.
    This should be marked as Handled or as Incompatible in the migrate.inf
    to report to the user

Arguments:
    pszPrinterName  : Printer name
    szKeyBuffer     : Buffer to fill in the registry path
    cchKeyBufLen    : Length of key buffer in characters

Return Value:
    TRUE on success, FALSE else

--*/
{
    DWORD       dwPrinterId, dwLen;
    CHAR        szHeader[] = "\"HKLM\\";
    CHAR        szRegPrinterPrefix[] = "Printers\\";

    //
    // Add "HKLM\ at the beginning and "\" at the end
    //
    dwLen = strlen(szHeader);

    if ( dwLen + 1 > cchKeyBufLen )
        return FALSE;

    StringCchCopyA(szKeyBuffer, cchKeyBufLen, szHeader);

    //
    // If a printer id is found then there is a DevNode list that
    // registry path, otherwise return spooler registry path
    //
    if ( dwPrinterId = GetPrinterId(pszPrinterName) ) {

        return SearchRegTreeForPrinterId(dwPrinterId,
                                         "Enum\\Root\\printer",
                                         szKeyBuffer + dwLen,
                                         cchKeyBufLen - dwLen)      ||
               SearchRegTreeForPrinterId(dwPrinterId,
                                         "Enum\\LPTENUM",
                                         szKeyBuffer + dwLen,
                                         cchKeyBufLen - dwLen)      ||
               SearchRegTreeForPrinterId(dwPrinterId,
                                         "Enum\\IRDA",
                                         szKeyBuffer + dwLen,
                                         cchKeyBufLen - dwLen);

    } else {

        dwLen = strlen(szRegPrefix) + strlen(szRegPrinterPrefix)
                                    + strlen(pszPrinterName) + 3;

        if ( dwLen >= cchKeyBufLen )
            return FALSE;

        szKeyBuffer[0] = '"';
        StringCchCopyA(szKeyBuffer + 1, cchKeyBufLen - 1, szRegPrefix);
        StringCchCatA(szKeyBuffer, cchKeyBufLen, szRegPrinterPrefix);
        StringCchCatA(szKeyBuffer, cchKeyBufLen, pszPrinterName);
        StringCchCatA(szKeyBuffer, cchKeyBufLen, "\"");

        return TRUE;
    }

    return FALSE;

}


LONG
CALLBACK
Initialize9x(
    IN  LPCSTR      pszWorkingDir,
    IN  LPCSTR      pszSourceDir,
        LPVOID      Reserved
    )
/*++

Routine Description:
    This is an export for setup to call during the report phase.
    This is the first function called on the migration DLL.

Arguments:
    pszWorkingDir   : Gives the working directory assigned for printing
    pszSourceDir    : Source location for NT distribution files
    Reserved        : Leave it alone

Return Value:
    Win32 error code

--*/
{
    POEM_UPGRADE_INFO   pOemUpgradeInfo;
    BOOL                bFail = TRUE;

    UpgradeData.pszDir          = AllocStrA(pszWorkingDir);
    UpgradeData.pszSourceA      = AllocStrA(pszSourceDir);
    UpgradeData.pszSourceW      = NULL;

    bFail = UpgradeData.pszDir      == NULL     ||
            UpgradeData.pszSourceA  == NULL;

    return bFail ? GetLastError() : ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x(
    IN  HWND        hwndParent,
    IN  LPCSTR      pszUnattendFile,
    IN  HKEY        hUserRegKey,
    IN  LPCSTR      pszUserName,
        LPVOID      Reserved
    )
/*++

Routine Description:
    Process per user settings

Arguments:

Return Value:
    None

--*/
{
    //
    // Nothing to do
    //

    return  ERROR_SUCCESS;
}


VOID
DestroyDriverInfo9xList(
    IN  PDRIVER_INFO_9X pDriverInfo9x
    )
/*++

Routine Description:
    Free memory for the driver entries in DRIVER_INFO_9X linked list

Arguments:
    pDriverInfo9x   : Beginning of the linked list

Return Value:
    None

--*/
{
    PDRIVER_INFO_9X pNext;

    while ( pDriverInfo9x ) {

        pNext = pDriverInfo9x->pNext;
        FreeMem(pDriverInfo9x);
        pDriverInfo9x = pNext;
    }
}


PDRIVER_INFO_9X
AllocateDriverInfo9x(
    IN      LPSTR   pszNtName,
    IN      LPSTR   pszWin95Name,
    IN  OUT LPBOOL  pbFail
    )
/*++

Routine Description:
    Allocate memory and create a DRIVER_INFO_9X structure

Arguments:
    pszNtName       : NT printer driver model name. This could be NULL if no
                      matching entry is found on ntprint.inf
    pszWin95Name    : Win95 printer driver name
    pbFail          : Set on an error -- no more processing needed

Return Value:
    Returns pointer to the allocated DRIVER_INFO_9X structure. Memory is also
    allocated for the strings

--*/
{
    PDRIVER_INFO_9X     pInfo;
    DWORD               cbSize;
    LPSTR               pszEnd;

    if ( *pbFail )
        return NULL;

    cbSize = strlen(pszWin95Name) + 1;
    if ( pszNtName )
        cbSize += strlen(pszNtName) + 1;

    cbSize *= sizeof(CHAR);
    cbSize += sizeof(DRIVER_INFO_9X);

    if ( pInfo = AllocMem(cbSize) ) {
        DWORD dwBufSize;

        pszEnd = (LPBYTE) pInfo + cbSize;

        if ( pszNtName ) {

            dwBufSize = strlen(pszNtName) + 1;
            pszEnd -= dwBufSize;
            StringCchCopyA(pszEnd, dwBufSize, pszNtName);
            pInfo->pszNtName = pszEnd;
        }
        dwBufSize = strlen(pszWin95Name) + 1;
        pszEnd -= dwBufSize;
        StringCchCopyA(pszEnd, dwBufSize, pszWin95Name);
        pInfo->pszWin95Name = pszEnd;

    } else {

        *pbFail = TRUE;
    }

    return pInfo;
}


LPSTR
FindNtModelNameFromWin95Name(
    IN  OUT HDEVINFO    hDevInfo,
    IN      HINF        hNtInf,
    IN      HINF        hUpgInf,
    IN      LPCSTR      pszWin95Name,
    IN  OUT LPBOOL      pbFail
    )
/*++

Routine Description:
    This routine finds the NT printer driver model name from the Win9x name
    Rules followed:
        1. If a name mapping is used in prtupg9x.inf use it
        2. Else just use the Win95 as it is

Arguments:

    hDevInfo        : Printer device class list. Has all drivers from NT built
    hNtInf          : Handle to the NT ntprint.inf
    hUpgInfo        : Handle to prtupg9x.inf
    DiskSpaceList   : Handle to disk space list. Add driver files to this
    pszWin95Name    : Windows 95 printer driver name
    pbFail          : Set on an error -- no more processing needed

Return Value:
    Pointer to the NT printer driver name. Memory is allocated and caller has
    to free it

--*/
{
    BOOL                        bFound = FALSE;
    DWORD                       dwIndex, dwNeeded;
    CHAR                        szNtName[LINE_LEN];
    INFCONTEXT                  InfContext;
    SP_DRVINFO_DATA_A           DrvInfoData;

    if ( *pbFail )
        return NULL;

    //
    // See in prtupg9x.inf to see if the driver has a different name on NT
    //
    if ( SetupFindFirstLineA(hUpgInf,
                             "Printer Driver Mapping",
                             pszWin95Name,
                             &InfContext) ) {

        //
        // If for some reason we could not get NT name we will still continue
        // with other driver models
        //
        if ( !SetupGetStringField(&InfContext,
                                  1,
                                  szNtName,
                                  sizeof(szNtName)/sizeof(szNtName[0]),
                                  NULL) )
            return NULL;
    } else {

        //
        // If there is no mapping in the upgrade inf then look for Win95 name
        // in ntprint.inf
        //
        if ( strlen(pszWin95Name) > LINE_LEN - 1 )
            return NULL;

        StringCchCopyA(szNtName, SIZECHARS(szNtName), pszWin95Name);
    }

    //
    // NOTE only for beta2
    // DrvInfoData.cbSize = sizeof(DrvInfoData);

    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA_V1);
    for ( dwIndex = 0 ;
          SetupDiEnumDriverInfoA(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER,
                                 dwIndex,
                                 &DrvInfoData);
          ++dwIndex ) {

        if ( !_strcmpi(DrvInfoData.Description, szNtName) ) {

            bFound = TRUE;
            break;
        }
    }

    if ( !bFound )
        return NULL;

    return AllocStrA(szNtName);
}


VOID
WriteFileToBeDeletedInInf(
    IN  LPCSTR  pszInfName,
    IN  LPCSTR  pszFileName
    )
/*++

Routine Description:
    Writes a file which is to be deleted on migration to NT in the migrate.inf

Arguments:
    pszInfName      : Full path to the migrate.inf
    pszFileName     : Fully qualified filename to be deleted

Return Value:
    None

--*/
{
    CHAR    szString[MAX_PATH+2];

    szString[0] = '"';
    if ( GetSystemDirectoryA(szString + 1, SIZECHARS(szString)-2) ) {

        StringCchCatA(szString, SIZECHARS(szString), "\\");
        StringCchCatA(szString, SIZECHARS(szString), pszFileName);
        StringCchCatA(szString, SIZECHARS(szString), "\"");
        WritePrivateProfileStringA("Moved", szString, "", pszInfName);
    }
}


VOID
WriteRegistryEntryHandled(
    IN  LPCSTR  pszInfName,
    IN  LPCSTR  pszRegEntry
    )
/*++

Routine Description:
    Writes a registry entry which is being handled by printer upgrade code in
    migrate.inf. Setup looks at these entries across all mig dlls to see what
    componnets can't be upgraded.

Arguments:
    pszInfName      : Full path to the migrate.inf
    pszRegEntry     : Fully qualified registry entry which is handled

Return Value:
    None

--*/
{
    WritePrivateProfileStringA("Handled", pszRegEntry, "\"Registry\"", pszInfName);
}


BOOL
IsAnICMFile(
    IN  LPCSTR  pszFileName
    )
{
    DWORD   dwLen = strlen(pszFileName);
    LPCSTR  psz = pszFileName + dwLen - 4;

    if ( dwLen > 3 && (!_strcmpi(psz, ".ICM") || !_strcmpi(psz, ".ICC")) )
        return TRUE;

    return FALSE;
}


VOID
LogDriverEntry(
    IN      LPCSTR              pszInfName,
    IN      LPDRIVER_INFO_3A    pDriverInfo3,
    IN      BOOL                bUpgradable
    )
/*++

Routine Description:
    Log information about a printer driver in the migrate.inf.
    Write all printer driver files to be deleted. Also if a matching NT
    driver is found write the driver as handled.

Arguments:
    pszInfName      : Full path to the migrate.inf
    pDriverInfo3    : Pointer to DRIVER_INFO_3A of the driver
    bUpgradable     : If TRUE a matching NT driver is found

Return Value:
    None

--*/
{
    CHAR    szRegDrvPrefix[] = "Environments\\Windows 4.0\\Drivers\\";
    LPSTR   psz;
    DWORD   dwLen;

    //
    // Write each driver file as to be deleted
    //
    for ( psz = pDriverInfo3->pDependentFiles ;
          psz && *psz ;
          psz += strlen(psz) + 1) {

        //
        // ICM migration dll will handle color profiles
        //
        if ( IsAnICMFile(psz) )
            continue;

        WriteFileToBeDeletedInInf(pszInfName, psz);
    }

    //
    // If a matching NT driver entry is found make an entry to indicate the
    // driver will be upgraded against the registry entry name'
    //
    if ( !bUpgradable )
        return;

    dwLen = strlen(szRegPrefix) + strlen(szRegDrvPrefix)
                                + strlen(pDriverInfo3->pName) + 3;
    if ( !(psz = AllocMem(dwLen * sizeof(CHAR))) )
        return;

    *psz = '"';
    StringCchCopyA(psz + 1, dwLen - 1, szRegPrefix);
    StringCchCatA(psz, dwLen, szRegDrvPrefix);
    StringCchCatA(psz, dwLen, pDriverInfo3->pName);
    StringCchCatA(psz, dwLen, "\"");

    WriteRegistryEntryHandled(pszInfName, psz);

    FreeMem(psz);
}


VOID
LogMonitorEntry(
    IN      LPCSTR              pszInfName,
    IN      LPMONITOR_INFO_1A   pMonitorInfo1,
    IN      BOOL                bUpgradable
    )
/*++

Routine Description:
    Log information about a print monitor in the migrate.inf. Write the
    monitor.dll to be deleted. Also if the monitor will be upgraded write
    it in the handled section

Arguments:
    pszInfName      : Full path to the migrate.inf
    pMonitorInfo1   : Pointer to MONITOR_INFO_1A of the monitor
    bUpgradable     : If TRUE a matching NT driver is found

Return Value:
    None

--*/
{
    CHAR    szRegMonPrefix[] = "Monitors\\";
    LPSTR   psz;
    DWORD   dwLen;

    //
    // If a matching NT driver entry is found make an entry to indicate the
    // driver will be upgraded against the registry entry name'
    //
    if ( !bUpgradable )
        return;

    dwLen = strlen(szRegPrefix) + strlen(szRegMonPrefix)
                                + strlen(pMonitorInfo1->pName) + 3;

    if ( !(psz = AllocMem(dwLen * sizeof(CHAR))) )
        return;

    *psz = '"';
    StringCchCopyA(psz + 1, dwLen - 1, szRegPrefix);
    StringCchCatA( psz, dwLen, szRegMonPrefix);
    StringCchCatA( psz, dwLen, pMonitorInfo1->pName);
    StringCchCatA( psz, dwLen, "\"");

    WriteRegistryEntryHandled(pszInfName, psz);

    FreeMem(psz);
}


VOID
LogPrinterEntry(
    IN  LPCSTR              pszInfName,
    IN  LPPRINTER_INFO_2A   pPrinterInfo2,
    IN  BOOL                bUpgradable
    )
/*++

Routine Description:
    Log information about a printer in the migrate.inf.
    If the printer will be upgraded write it in the handled section.
    Otherwise we will write a incompatibility message.

Arguments:
    pszInfName      : Full path to the migrate.inf
    pPrinterInfo2   : Pointer to PRINTER_INFO_2A of the printer
    bUpgradable     : If TRUE printer will be migrated, else not

Return Value:
    None

--*/
{
    CHAR    szRegPath[MAX_PATH], szPrefix[] = "\\Hardware\\";
    LPSTR   psz, psz2, psz3;
    DWORD   dwLen;

    if ( !RegPathFromPrinter(pPrinterInfo2->pPrinterName,
                             szRegPath,
                             MAX_PATH) ) {

        return;
    }

    if ( bUpgradable ) {

        WriteRegistryEntryHandled(pszInfName, szRegPath);
    } else {

        dwLen   = strlen(pPrinterInfo2->pPrinterName) + strlen(szPrefix) + 3;
        psz2    = AllocMem(dwLen * sizeof(CHAR));

        if ( psz2 ) {

            StringCchPrintfA(psz2, dwLen, "%s%s", szPrefix, pPrinterInfo2->pPrinterName);

            WritePrivateProfileStringA(psz2,
                                       szRegPath,
                                       "\"Registry\"",
                                       pszInfName);

            if ( psz = GetStringFromRcFileA(IDS_PRINTER_CANT_MIGRATE) ) {

                dwLen = strlen(psz) + strlen(psz2);
                if ( psz3 = AllocMem(dwLen * sizeof(CHAR)) ) {

                    StringCchPrintfA(psz3, dwLen, psz, pPrinterInfo2->pPrinterName);

                    WritePrivateProfileStringA("Incompatible Messages",
                                               psz2,
                                               psz3,
                                               pszInfName);

                    FreeMem(psz3);
                }
                FreeMem(psz);
            }
            FreeMem(psz2);
        }
    }
}


VOID
ProcessPrinterDrivers(
    IN      HANDLE              hFile,
    IN      LPCSTR              pszInfName,
    IN      HWND                hwnd,
    OUT     PDRIVER_INFO_9X    *ppDriverInfo9x,
    IN  OUT LPBOOL              pbFail
    )
/*++

Routine Description:
    Process printer drivers for upgrade

Arguments:
    hFile           : Handle to print9x.txt. Printing configuration
                      info is written here for use on NT side
    pszInfName      : Inf name to log upgrade info
    hwnd            : Parent window handle for any UI
    DiskSpaceList   : Handle to disk space list to queue up file operations
    ppDriverInfo9x  : On return gives the list of printer drivers and
                      their Nt names
    pbFail          : Set on an error -- no more processing needed


Return Value:
    None

--*/
{
    LPBYTE              pBuf = NULL;
    DWORD               dwNeeded, dwReturned;
    LPSTR               psz, pszNtModelName;
    HDEVINFO            hDevInfo;
    HINF                hUpgInf, hNtInf;
    LPDRIVER_INFO_3A    pDriverInfo3;
    PDRIVER_INFO_9X     pCur;

    hDevInfo = hUpgInf = hNtInf = INVALID_HANDLE_VALUE;

    //
    // Get the list of drivers installed from spooler
    if ( *pbFail                                    ||
         EnumPrinterDriversA(NULL,
                             NULL,
                             3,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned) ) {

        if ( !*pbFail )
            WriteToFile(hFile, pbFail, "[PrinterDrivers]\n");
        goto Cleanup;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = AllocMem(dwNeeded))                   ||
         !EnumPrinterDriversA(NULL,
                              NULL,
                              3,
                              pBuf,
                              dwNeeded,
                              &dwNeeded,
                              &dwReturned) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    InitDriverMapping(&hDevInfo, &hNtInf, &hUpgInf, pbFail);

    //
    // For each driver ...
    //      If we find a suitable NT driver name write it to file
    //      else write Win95 name with a * at the beginning of the line
    //      to tell this can't be upgraded (but log error on NT)
    //
    WriteToFile(hFile, pbFail, "[PrinterDrivers]\n");

    for ( dwNeeded = 0, pDriverInfo3 = (LPDRIVER_INFO_3A)pBuf ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pDriverInfo3 ) {

        if (IsIgnoredDriver(pDriverInfo3->pName))
        {
            continue;
        }

        pszNtModelName = FindNtModelNameFromWin95Name(hDevInfo,
                                                      hNtInf,
                                                      hUpgInf,
                                                      pDriverInfo3->pName,
                                                      pbFail);

        if ( !(pCur = AllocateDriverInfo9x(pszNtModelName,
                                           pDriverInfo3->pName,
                                           pbFail)) ) {

            FreeMem(pszNtModelName);
            pszNtModelName = NULL;
            goto Cleanup;
        }

        //
        // Add the info in the linked lise
        //
        if ( *ppDriverInfo9x )
            pCur->pNext = *ppDriverInfo9x;

        *ppDriverInfo9x = pCur;

        //
        // If pszNtModelName is NULL we could not decide which driver to
        // install
        //
        if ( pszNtModelName ) {

            LogDriverEntry(pszInfName, pDriverInfo3, TRUE);
            WriteString(hFile, pbFail, pszNtModelName);
        } else {

            LogDriverEntry(pszInfName, pDriverInfo3, FALSE);
            WriteString(hFile, pbFail, pDriverInfo3->pName);
        }

        FreeMem(pszNtModelName);
        pszNtModelName = NULL;
    }

Cleanup:
    WriteToFile(hFile, pbFail, "\n");

    //
    // Close all the inf since we do not need them
    //
    CleanupDriverMapping(&hDevInfo, &hNtInf, &hUpgInf);

    FreeMem(pBuf);
}


VOID
FixupPrinterInfo2(
    LPPRINTER_INFO_2A   pPrinterInfo2
    )
/*++

Routine Description:
    Fixup the PRINTER_INFO_2 we got from Win95 spooler before writing to the
    text file so that AddPrinter will be ok on NT side

Arguments:
    pPrinterInfo2   : Points to the PRINTER_INFO_2

Return Value:
    None

--*/
{
    //
    // Default datatype is always RAW
    //
    pPrinterInfo2->pDatatype = cszRaw;

    //
    // Only print processor for in-box drivers is winprint
    //
    pPrinterInfo2->pPrintProcessor  = cszWinPrint;

    //
    // Remove the enable bidi bit. NT driver may or may not have a LM
    // If it does AddPrinter on NT automatically enables bidi
    //
    pPrinterInfo2->Attributes   &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

    //
    // Remove the work-offline bit. It makes no sense to carry it over.
    // With network printers this is a big problem because Win2K does not set
    // work offline, and UI does not allow user to disable it if set.
    //
    pPrinterInfo2->Attributes   &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;

    //
    // Ignore Win9x separator page
    //
    pPrinterInfo2->pSepFile = NULL;

    //
    // We will ignore PRINTER_STATUS_PENDING_DELETION and still add it on NT
    //
}


VOID
ProcessPrinters(
    IN      HANDLE          hFile,
    IN      HANDLE          hFile2,
    IN      LPCSTR          pszInfName,
    IN      PDRIVER_INFO_9X pDriverInfo9x,
    IN  OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Process printers for upgrade

Arguments:
    hFile           : Handle to print9x.txt. Printing configuration
                      info is written here for use on NT side
    hFile2          : Handle to netwkprn.txt
    pDriverInfo9x   : Gives the list of drivers and corresponding NT drivers
    pbFail          : Set on an error -- no more processing needed

Return Value:
    None

--*/
{
    LPBYTE              pBuf1 = NULL;
    BOOL                bFirst = TRUE, bFound;
    DWORD               dwLevel, dwNeeded, dwPrinters, dwSize, dwIndex;
    LPPRINTER_INFO_2A   pPrinterInfo2;
    PDRIVER_INFO_9X     pCur;
    PUPGRADABLE_LIST    pUpg;
    LPSTR               pWinIniPorts = NULL, psz;

    //
    // Get the list of printers installed from spooler
    //
    if ( *pbFail                                    ||
         EnumPrintersA(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       NULL,
                       0,
                       &dwNeeded,
                       &dwPrinters) ) {

        if ( !*pbFail )
            WriteToFile(hFile, pbFail, "[Ports]\n\n[Printers]\n");
        goto Cleanup;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf1 = AllocMem(dwNeeded))                  ||
         !EnumPrintersA(PRINTER_ENUM_LOCAL,
                        NULL,
                        2,
                        pBuf1,
                        dwNeeded,
                        &dwNeeded,
                        &dwPrinters) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    //
    // Extract all the used local ports
    //
    WriteToFile(hFile, pbFail, "[Ports]\n");

    for ( dwNeeded = 0, pPrinterInfo2 = (LPPRINTER_INFO_2A)pBuf1 ;
          dwNeeded < dwPrinters ;
          ++dwNeeded, ++pPrinterInfo2 )
    {
        DWORD i;

        //
        // check for ignored drivers
        //
        if (IsIgnoredDriver(pPrinterInfo2->pDriverName))
        {
            continue;
        }
        
        //
        // Point-and-print printers are processed through netwkprn.txt
        //

        if (pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK)
        {
            continue;
        }

        //
        // check whether portname has been processed already
        //

        for (i = 0; i < dwNeeded; i++ )
        {
            if (strcmp(pPrinterInfo2->pPortName, (((LPPRINTER_INFO_2A)pBuf1)+i)->pPortName) == 0)
            {
                break;
            }
        }
        if (i < dwNeeded)
        {
            DebugMsg("Port with multiple attached printers skipped");
            continue;
        }

        //
        // if the printers is a FILE, LPT*: or COM*: port do nothing
        //

        if (_strnicmp(pPrinterInfo2->pPortName, "FILE:", 5) == 0)

        {
            DebugMsg("FILE: port skipped");
            continue;
        }

        if ((_strnicmp(pPrinterInfo2->pPortName, "COM", 3) == 0) ||
            (_strnicmp(pPrinterInfo2->pPortName, "LPT", 3) == 0) )
        {
            LPSTR psz = pPrinterInfo2->pPortName + 3;

            if (isdigit(*psz))
            {
                do
                {
                    psz++;
                } while ( isdigit(*psz) );

                if (*psz == ':')
                {
                    DebugMsg("Local port COMx:/LPTx skipped");
                    continue;
                }
            }
        }

        //
        // check whether the port is listed in win.ini - if so, it's a local port that needs to be migrated
        // if not, it's a third-party port that won't be migrated - warn !
        //

        //
        // retrieve the win.ini section on ports only once
        //
        if (!pWinIniPorts)
        {
            DWORD dwBufSize = 32767; // this is the max. size acc. to MSDN

            pWinIniPorts = AllocMem(dwBufSize);
            if (!pWinIniPorts)
            {
                *pbFail = TRUE;
                goto Cleanup;
            }

            GetProfileSection("Ports", pWinIniPorts, dwBufSize);
        }

        //
        // search for the current port within the section, note that the entry is in the form
        // <portname>=
        // so I need to skip the = at the end
        //

        for (psz = pWinIniPorts; *psz ; psz += strlen(psz) + 1)
        {
            if (_strnicmp(pPrinterInfo2->pPortName, psz, strlen(pPrinterInfo2->pPortName)) == 0)
            {
                break;
            }
        }

        if (!*psz)
        {
            //
            // not found - this printer queue will not be migrated !
            //

            LogPrinterEntry(pszInfName, pPrinterInfo2, FALSE);
        }
        else
        {
            //
            // found - write the entry for it to allow creation of the port on the NT side
            //
            WriteToFile(hFile, pbFail, "PortName:        ");
            WriteString(hFile, pbFail, pPrinterInfo2->pPortName);
        }
    }

    //
    // Write the PRINTER_INFO_2 in the print95.txt file
    //
    WriteToFile(hFile, pbFail, "\n[Printers]\n");
    WriteToFile(hFile2, pbFail, "[Printers]\n");

    for ( dwNeeded = 0, pPrinterInfo2 = (LPPRINTER_INFO_2A)pBuf1 ;
          dwNeeded < dwPrinters ;
          ++dwNeeded, ++pPrinterInfo2 ) {

        //
        // check for ignored drivers
        //
        if (IsIgnoredDriver(pPrinterInfo2->pDriverName))
        {
            continue;
        }
        
        FixupPrinterInfo2(pPrinterInfo2);

        //
        // Find the driver name from the installed drivers on Win9x and get
        // the NT driver name
        //
        for ( pCur = pDriverInfo9x ;
              pCur && _strcmpi(pCur->pszWin95Name, pPrinterInfo2->pDriverName) ;
              pCur = pCur->pNext )
        ;

        if ( !pCur ) {

            ASSERT(pCur != NULL);
            *pbFail = TRUE;
            goto Cleanup;
        }

        //
        // Pass the NT driver name here. If it is not NULL that gets written
        // to the file, we won't need Win9x driver name on NT. If can't find
        // an NT driver we will just write the Win9x driver name. It will be
        // useful for error loggging
        //
        if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK ) {

            ++dwNetPrinters;

            WritePrinterInfo2(hFile2, pPrinterInfo2, pCur->pszNtName, pbFail);
        } else {

            //
            // If the printer is shared write it to network printer file too
            // since it needs to be shared when user logs in for the first time
            //
            if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                ++dwSharedPrinters;
                WritePrinterInfo2(hFile2, pPrinterInfo2, pCur->pszNtName, pbFail);
                pPrinterInfo2->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            }

            WritePrinterInfo2(hFile, pPrinterInfo2, pCur->pszNtName, pbFail);
        }

        //
        // Now see if this printer is going to disappear on NT:
        //      Check if an NT driver is found
        //
        LogPrinterEntry(pszInfName, pPrinterInfo2, pCur->pszNtName != NULL);
    }

Cleanup:
    if (pWinIniPorts)
    {
        FreeMem(pWinIniPorts);
    }

    WriteToFile(hFile, pbFail, "\n");

    FreeMem(pBuf1);
}


VOID
ProcessPrintMonitors(
    IN  LPCSTR  pszInfName
    )
/*++

Routine Description:
    Process print monitors for upgrade.

    We just look for monitors which are not in the list of upgradable monitors
    and add to the unupgradable list so that we can warn the user

Arguments:
    pszInfName  : Inf name to log upgrade info

Return Value:
    None
--*/
{
    LPBYTE              pBuf = NULL;
    DWORD               dwCount, dwNeeded, dwReturned;
    LPSTR               psz;
    LPMONITOR_INFO_1A   pMonitorInfo1;
    PUPGRADABLE_LIST    pUpg;
    BOOL                bFound;

    if ( EnumMonitorsA(NULL,
                       1,
                       NULL,
                       0,
                       &dwNeeded,
                       &dwReturned)                     ||
         GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = AllocMem(dwNeeded))                   ||
         !EnumMonitorsA(NULL,
                        1,
                        pBuf,
                        dwNeeded,
                        &dwNeeded,
                        &dwReturned) ) {

        goto Cleanup;
    }

    for ( dwNeeded = dwCount = 0, pMonitorInfo1 = (LPMONITOR_INFO_1A)pBuf ;
          dwCount < dwReturned ;
          ++dwCount, ++pMonitorInfo1 ) {

        for ( pUpg = UpgradableMonitors, bFound = FALSE ;
              pUpg->pszName ; ++pUpg ) {

            if ( !strcmp(pMonitorInfo1->pName, pUpg->pszName) ) {

                bFound = TRUE;
                break;
            }
        }

        LogMonitorEntry(pszInfName, pMonitorInfo1, bFound);
    }

Cleanup:
    FreeMem(pBuf);
}


LONG
CALLBACK
MigrateSystem9x(
    IN      HWND        hwndParent,
    IN      LPCSTR      pszUnattendFile,
            LPVOID      Reserved
    )
/*++

Routine Description:
    Process system setttings for printing. This does all the work for printing
    upgrade

Arguments:
    hwndParent      : Parent window for any UI
    pszUnattendFile : Pointer to unattend file
    pqwDiskSpace    : On return gives the additional disk space needed on NT

Return Value:
    Win32 error code

--*/
{
    BOOL                    bFail = FALSE;
    DWORD                   dwRet;
    HANDLE                  hFile, hFile2;
    CHAR                    szFile[MAX_PATH], szInfName[MAX_PATH];
    PDRIVER_INFO_9X         pDriverInfo9x = NULL;
#if DBG
    CHAR                    szFile2[MAX_PATH];
    DWORD                   dwLocalRet = 0;
#endif

    StringCchPrintfA(szFile, SIZECHARS(szFile), "%s\\%s", UpgradeData.pszDir, "print95.txt");
    StringCchPrintfA(szInfName, SIZECHARS(szInfName), "%s\\%s", UpgradeData.pszDir, "migrate.inf");


    hFile = CreateFileA(szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    StringCchPrintfA(szFile, SIZECHARS(szFile), "%s\\%s", UpgradeData.pszDir, szNetprnFile);
    hFile2 = CreateFileA(szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE || hFile2 == INVALID_HANDLE_VALUE ) {

        bFail = TRUE;
        goto Cleanup;
    }

    ProcessPrinterDrivers(hFile,
                          szInfName,
                          hwndParent,
                          &pDriverInfo9x,
                          &bFail);

    ProcessPrintMonitors(szInfName);

    ProcessPrinters(hFile,
                    hFile2,
                    szInfName,
                    pDriverInfo9x,
                    &bFail);

    //
    // If no network, shared printers found remove netwkprn.txt since it will be
    // empty
    //
    if ( dwNetPrinters == 0 && dwSharedPrinters == 0 ) {

        CloseHandle(hFile2);
        hFile2 = INVALID_HANDLE_VALUE;
        DeleteFileA(szFile);
    }

Cleanup:

    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle(hFile);

    if ( hFile2 != INVALID_HANDLE_VALUE )
        CloseHandle(hFile2);

    DestroyDriverInfo9xList(pDriverInfo9x);

#if DBG
    //
    // Make a copy in temp dir on debug builds so that if we messed up the
    // upgrade we can figure out what went wrong.
    // Setup deletes the working directory.
    //
    dwLocalRet = GetTempPathA(SIZECHARS(szFile2), szFile2);

    if ( dwLocalRet && (dwLocalRet <= SIZECHARS(szFile2)))
    {
        StringCchPrintfA(szFile, SIZECHARS(szFile), "%s\\%s", UpgradeData.pszDir, "print95.txt");
        StringCchCatA(szFile2, SIZECHARS(szFile2), "print95.txt");
        CopyFileA(szFile, szFile2, FALSE);
    }
#endif

    dwRet = bFail ? GetLastError() : ERROR_SUCCESS;
    if ( bFail && dwRet == ERROR_SUCCESS )
        dwRet = STG_E_UNKNOWN;

    if ( bFail )
        DebugMsg("MigrateSystem9x failed with %d", dwRet);

    return  dwRet;
}


//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//
P_INITIALIZE_9X     pfnInitialize9x         = Initialize9x;
P_MIGRATE_USER_9X   pfnMigrateUser9x        = MigrateUser9x;
P_MIGRATE_SYSTEM_9X pfnMigrateSystem9x      = MigrateSystem9x;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\win9xupg\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Util.c

Abstract:

    Uitility routines for printer migration from Win9x to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"

extern CHAR szRunOnceRegistryPath[];
extern CHAR szSpool[];
extern CHAR szMigDll[];

//
// These are used in the process of creating registry keys where the
// data necessary the vendor setup to be started will be stored
//
CHAR *pszVendorSetupInfoPath         = "Software\\Microsoft\\Windows NT\\CurrentVersion\\Print";
CHAR *pszVendorSetupInfo             = "VendorSetupInfo";
CHAR *pszVendorSetupID               = "VendorSetup";
CHAR *pszVendorSetupEnumerator       = "VendorInfoEnumerator";
CHAR *pszPrinterNameKey              = "PrinterName";
CHAR *pszMigrationVendorSetupCaller  = "MigrationVendorSetupCaller";
CHAR  szVendorSetupRunRegistryPath[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
const CHAR *pszVendorSetupCaller     = "CallVendorSetupDlls";

const LONG  dwMaxVendorSetupIDLength  = 12;
const DWORD dwFourMinutes             = 240000;
BOOL  bMigrateDllCopyed               = FALSE;


VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    On debug builds brings up a message box on severe errors

Arguments:
    pszFormat   : Format string

Return Value:
    None

--*/
{
#if DBG
    LPSTR       psz;
    CHAR        szMsg[1024];
    va_list     vargs;

    va_start(vargs, pszFormat);
    StringCchVPrintfA(szMsg, SIZECHARS(szMsg), pszFormat, vargs);
    va_end(vargs);

#ifdef  MYDEBUG
    if ( psz = GetStringFromRcFileA(IDS_TITLE) ) {

        MessageBoxA(NULL, szMsg, psz, MB_OK);
        FreeMem(psz);
        psz = NULL;
    }
#else
    OutputDebugStringA("Printing Migration : ");
    OutputDebugStringA(szMsg);
    OutputDebugStringA("\n");
#endif


#endif
}



VOID
LogError(
    IN  LogSeverity     Severity,
    IN  UINT            uMessageId,
    ...
    )
/*++

Routine Description:
    Logs an error in the setup error log on NT side when something can not be
    upgraded

Arguments:
    uMessageId  : Id to string in .rc file

Return Value:
    None

--*/
{
    LPSTR      pszFormat;
    CHAR       szMsg[1024];

    va_list     vargs;

    va_start(vargs, uMessageId);

    pszFormat = GetStringFromRcFileA(uMessageId);

    if ( pszFormat ) {

        StringCchVPrintfA(szMsg, SIZECHARS(szMsg), pszFormat, vargs);
        DebugMsg("%s", szMsg);
        SetupLogErrorA(szMsg, Severity);
    }

    FreeMem(pszFormat);

    va_end(vargs);
}


LPSTR
ErrorMsg(
    VOID
    )
/*++

Routine Description:
    Returns the error message string from a Win32 error

Arguments:
    None

Return Value:
    Pointer to a message string. Caller should free the string

--*/
{
    DWORD   dwLastError;
    LPSTR   pszStr = NULL;

    if ( !(dwLastError = GetLastError()) )
        dwLastError = STG_E_UNKNOWN;

    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER    |
                     FORMAT_MESSAGE_IGNORE_INSERTS   |
                     FORMAT_MESSAGE_FROM_SYSTEM      |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK,
                   NULL,
                   dwLastError,
                   0,
                   (LPSTR)&pszStr,
                   0,
                   NULL);



    return pszStr;
}


PVOID
AllocMem(
    IN UINT cbSize
    )
/*++

Routine Description:
    Allocate memory from the heap

Arguments:
    cbSize  : Byte count

Return Value:
    Pointer to the allocated memory

--*/
{
    return LocalAlloc(LPTR, cbSize);
}


VOID
FreeMem(
    IN PVOID    p
    )
/*++

Routine Description:
    Free memory allocated on the heap

Arguments:
    p   : Pointer to the memory to be freed

Return Value:
    None

--*/
{
    LocalFree(p);
}


LPSTR
AllocStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of an ansi string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {
        DWORD dwBufSize = (strlen(pszStr) + 1) * sizeof(CHAR);

        pszRet = AllocMem(dwBufSize);
        if ( pszRet )
            StringCbCopyA(pszRet, dwBufSize, pszStr);
    }

    return pszRet;
}


LPWSTR
AllocStrW(
    LPCWSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of a unicode string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPWSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {
        DWORD dwBufSize = (wcslen(pszStr) + 1) * sizeof(WCHAR);
        pszRet = AllocMem(dwBufSize);
        if ( pszRet )
            StringCbCopyW(pszRet, dwBufSize, pszStr);
    }

    return pszRet;
}


LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Returns the unicode string for a give ansi string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPWSTR  pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = strlen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1) * sizeof(WCHAR))) ) {

        if ( MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 pszStr,
                                 dwLen,
                                 pszRet,
                                 dwLen) ) {

            pszRet[dwLen] = 0;
        } else {

            FreeMem(pszRet);
            pszRet = NULL;
        }

    }

    return pszRet;
}


LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    )
/*++

Routine Description:
    Returns the ansi string for a give unicode string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied ansi string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPSTR   pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = wcslen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1 ) * sizeof(CHAR))) ) {

        WideCharToMultiByte(CP_ACP,
                            0,
                            pszStr,
                            dwLen,
                            pszRet,
                            dwLen,
                            NULL,
                            NULL );
    }

    return pszRet;
}


VOID
WriteToFile(
    HANDLE  hFile,
    LPBOOL  pbFail,
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    Format and write a string to the text file. This is used to write the
    printing configuration on Win9x

Arguments:
    hFile       : File handle
    pbFail      : Set on error -- no more processing needed
    pszFormat   : Format string for the message

Return Value:
    None

--*/
{
    CHAR        szMsg[1024];
    va_list     vargs;
    DWORD       dwSize, dwWritten;
    HRESULT     hRet;

    if ( *pbFail )
        return;

    va_start(vargs, pszFormat);
    hRet = StringCchVPrintfA(szMsg, SIZECHARS(szMsg), pszFormat, vargs);  
    va_end(vargs);

    if(SUCCEEDED(hRet))
    {
        dwSize = strlen(szMsg) * sizeof(CHAR);
    
        if ( !WriteFile(hFile, (LPCVOID)szMsg, dwSize, &dwWritten, NULL)    ||
             dwSize != dwWritten ) {
    
            *pbFail = TRUE;
        }
    }
    else
    {
        *pbFail = TRUE;
    }
}


VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    )
/*++

Routine Description:
    Writes a string to the upgrade file on Win9x side. Since spooler strings
    (ex. printer name, driver name) can have space in them we would write
    all strings with []\n. So we can read strings with space on NT.

Arguments:
    hFile       : File handle
    pszFormat   : Format string for the message
    pszStr      : String to write

Return Value:
    None

--*/
{
    DWORD   dwLen;

    if ( pszStr ) {

        dwLen = strlen(pszStr);
        WriteToFile(hFile, pbFail, "%3d [%s]\n", dwLen, pszStr);
    }
    else
        WriteToFile(hFile, pbFail, "  0 []\n");

}


VOID
WriteDevMode(
    IN      HANDLE      hFile,
    IN OUT  LPBOOL      pbFail,
    IN      LPDEVMODEA  pDevMode
    )
/*++

Routine Description:
    Writes a devmode to the upgrade file on Win9x side. We write the size of
    devmode and write this as a binary field

Arguments:
    hFile       : File handle
    pbFail      : On error set to TRUE
    pDevMode    : Pointer to devmode

Return Value:
    None

--*/
{
    DWORD   cbSize, cbWritten;

    if ( *pbFail )
        return;

    cbSize = pDevMode ? pDevMode->dmSize + pDevMode->dmDriverExtra : 0;

    if ( cbSize ) {

        WriteToFile(hFile, pbFail, "DevMode:         %d [", cbSize);

        if ( !WriteFile(hFile, (LPCVOID)pDevMode, cbSize, &cbWritten, NULL) ||
             cbWritten != cbSize )
            *pbFail = TRUE;

        WriteToFile(hFile, pbFail, "]\n");
    } else {

        WriteToFile(hFile, pbFail, "DevMode: 0\n");
    }
}


LPSTR
GetStringFromRcFileA(
    UINT    uId
    )
/*++

Routine Description:
    Load a string from the .rc file and make a copy of it by doing AllocStr

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    CHAR    buf[MAX_STRING_LEN];

    if ( LoadStringA(UpgradeData.hInst, uId, buf, SIZECHARS(buf)) )
        return AllocStrA(buf);
    else
        return NULL;
}


VOID
CleanupDriverMapping(
    IN  OUT HDEVINFO   *phDevInfo,
    IN  OUT HINF       *phNtInf,
    IN  OUT HINF       *phUpgInf
    )
/*++

Routine Description:
    Close INF handles and delete the printer device info list

Arguments:
    phDevInfo   : Points to printer device info list
    phNtInf     : Points to INF handle for ntprint.inf
    phUpgInfo   : Points to the handle to upgrade inf

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    if ( phUpgInf && *phUpgInf != INVALID_HANDLE_VALUE ) {

        SetupCloseInfFile(*phUpgInf);
        *phUpgInf = INVALID_HANDLE_VALUE;
    }

    if ( phNtInf && *phNtInf != INVALID_HANDLE_VALUE ) {

        SetupCloseInfFile(*phNtInf);
        *phNtInf = INVALID_HANDLE_VALUE;
    }

    if ( phDevInfo && *phDevInfo != INVALID_HANDLE_VALUE ) {

        SetupDiDestroyDeviceInfoList(*phDevInfo);
        *phDevInfo = INVALID_HANDLE_VALUE;
    }
}


VOID
InitDriverMapping(
    OUT     HDEVINFO   *phDevInfo,
    OUT     HINF       *phNtInf,
    OUT     HINF       *phUpgInf,
    IN  OUT LPBOOL      pbFail
    )
/*++

Routine Description:
    Opens necessary inf files and create the printer device info list for
    driver upgrade

Arguments:
    phDevInfo   : Points to printer device info list
    phNtInf     : Points to INF handle for ntprint.inf
    phUpgInfo   : Points to the handle to upgrade inf
    pbFail      : Set on error -- no more processing needed

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    DWORD                   dwLen;
    CHAR                    szPath[MAX_PATH];
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    if ( *pbFail )
    {
        return;
    }

    *phDevInfo = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_PRINTER,
                                             NULL);
    
    StringCchCopyA(szPath, SIZECHARS(szPath), UpgradeData.pszDir);
    dwLen = strlen(szPath);
    szPath[dwLen++] = '\\';
    StringCchCopyA(szPath+dwLen, SIZECHARS(szPath) - dwLen, "prtupg9x.inf");
    *phUpgInf   = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);
    
    StringCchCopyA(szPath, SIZECHARS(szPath), UpgradeData.pszSourceA);
    dwLen = strlen(szPath);
    szPath[dwLen++] = '\\';

    StringCchCopyA(szPath+dwLen, SIZECHARS(szPath) - dwLen, "ntprint.inf");
    *phNtInf    = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);

    StringCchCopyA(szPath+dwLen, SIZECHARS(szPath) - dwLen, "layout.inf");

    if ( *phDevInfo == INVALID_HANDLE_VALUE                 ||
         (phUpgInf && *phUpgInf == INVALID_HANDLE_VALUE)    ||
         *phNtInf == INVALID_HANDLE_VALUE                   ||
         !SetupOpenAppendInfFileA(szPath, *phNtInf, NULL) ) 
    {
        *pbFail = TRUE;
        goto Cleanup;
    }

    //
    // Build the list of drivers from ntprint.inf in the working directory
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParamsA(*phDevInfo,
                                         NULL,
                                         &DevInstallParams) ) 
    {
        *pbFail = TRUE;
        goto Cleanup;
    }

    DevInstallParams.Flags  |= DI_INF_IS_SORTED | DI_ENUMSINGLEINF;

    StringCchCopyA(szPath+dwLen, SIZECHARS(szPath) - dwLen, "ntprint.inf");
    StringCchCopyA(DevInstallParams.DriverPath, SIZECHARS(DevInstallParams.DriverPath), szPath);

    if ( !SetupDiSetDeviceInstallParamsA(*phDevInfo, NULL, &DevInstallParams) ||
         !SetupDiBuildDriverInfoList(*phDevInfo, NULL, SPDIT_CLASSDRIVER) ) 
    {
        *pbFail = TRUE;
    }

Cleanup:
    if ( *pbFail )
        CleanupDriverMapping(phDevInfo, phNtInf, phUpgInf);
}


VOID
WritePrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN      LPSTR               pszDriver,
    IN  OUT LPBOOL              pbFail
    )
{
    DWORD       dwSize;
    LPINT       ptr;

    if ( *pbFail )
        return;

    WriteToFile(hFile, pbFail, "ServerName:      ");
    WriteString(hFile, pbFail, pPrinterInfo2->pServerName);

    WriteToFile(hFile, pbFail, "PrinterName:     ");
    WriteString(hFile, pbFail, pPrinterInfo2->pPrinterName);

    WriteToFile(hFile, pbFail, "ShareName:       ");
    WriteString(hFile, pbFail, pPrinterInfo2->pShareName);

    WriteToFile(hFile, pbFail, "PortName:        ");
    WriteString(hFile, pbFail, pPrinterInfo2->pPortName);

    //  
    // On the Win9x side we could have found a different driver name on NT side
    // if so write it instead of the one returned by spooler
    //
    WriteToFile(hFile, pbFail, "DriverName:      ");
    WriteString(hFile, pbFail, 
                pszDriver ? pszDriver : pPrinterInfo2->pDriverName);

    WriteToFile(hFile, pbFail, "Comment:         ");
    WriteString(hFile, pbFail, pPrinterInfo2->pComment);

    WriteToFile(hFile, pbFail, "Location:        ");
    WriteString(hFile, pbFail, pPrinterInfo2->pLocation);

    WriteDevMode(hFile, pbFail, pPrinterInfo2->pDevMode);

    WriteToFile(hFile, pbFail, "SepFile:         ");
    WriteString(hFile, pbFail, pPrinterInfo2->pSepFile);

    WriteToFile(hFile, pbFail, "PrintProcessor:  ");
    WriteString(hFile, pbFail, pPrinterInfo2->pPrintProcessor);

    WriteToFile(hFile, pbFail, "Datatype:        ");
    WriteString(hFile, pbFail, pPrinterInfo2->pDatatype);

    WriteToFile(hFile, pbFail, "Parameters:      ");
    WriteString(hFile, pbFail, pPrinterInfo2->pParameters);

    // Security descriptor ???

    WriteToFile(hFile, pbFail, "Attributes:      %3d\n", pPrinterInfo2->Attributes);

    WriteToFile(hFile, pbFail, "Priority:        %3d\n", pPrinterInfo2->Priority);

    WriteToFile(hFile, pbFail, "DefaultPriority: %3d\n", pPrinterInfo2->DefaultPriority);

    WriteToFile(hFile, pbFail, "StartTime:       %3d\n", pPrinterInfo2->StartTime);

    WriteToFile(hFile, pbFail, "UntilTime:       %3d\n", pPrinterInfo2->UntilTime);

    WriteToFile(hFile, pbFail, "Status:          %3d\n", pPrinterInfo2->Status);

    // cJobs not needed
    // AveragePPM not needed
    WriteToFile(hFile, pbFail, "\n");
}


VOID
ReadString(
    IN      HANDLE  hFile,
    IN      LPSTR   pszPrefix,
    OUT     LPSTR  *ppszStr,
    IN      BOOL    bOptional,
    IN  OUT LPBOOL  pbFail
    )
{
    CHAR    c;
    LPSTR   psz;
    DWORD   dwLen;

    if ( *pbFail )
        return;

    //
    // First skip the prefix
    //
    while ( *pszPrefix && (c = (CHAR) My_fgetc(hFile)) == *pszPrefix++ )
    ;

    if ( *pszPrefix )
        goto Fail;

    //
    // Skip spaces
    //
    while ( (c = (CHAR) My_fgetc(hFile)) == ' ' )
    ;

    //
    // Now is the string length
    //
    if ( !isdigit(c) )
        goto Fail;

    dwLen = c - '0';
    while ( isdigit(c = (CHAR) My_fgetc(hFile)) )
        dwLen = dwLen * 10 + c - '0';

    if ( c != ' ' )
        goto Fail;

    //
    // Now the string is there between []
    //
    if ( *ppszStr = (LPSTR) AllocMem((dwLen + 1) * sizeof(CHAR)) ) {

        if ( (c = (CHAR) My_fgetc(hFile)) != '[' )
            goto Fail;

        for ( psz = *ppszStr ;
              dwLen && (*psz = (CHAR) My_fgetc(hFile)) != (CHAR) EOF ;
              ++psz, --dwLen )
        ;

        if ( dwLen )
            goto Fail;

        *psz = '\0';

        //
        // Make sure line ends with "]\n"
        //
        if ( (CHAR) My_fgetc(hFile) != ']' || (CHAR) My_fgetc(hFile) != '\n' )
            goto Fail;

        return;
    }

Fail:
    *pbFail = TRUE;
     FreeMem(*ppszStr);
    *ppszStr = NULL;
}


VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    )
{
    LPSTR   psz;

    if ( *pbFail || My_fgets(pszLine, dwLineSize, hFile) == NULL ) {

        *pbFail = TRUE;
        return;
    }

    //
    // First check the prefix matches to make sure we are in the right line
    //
    for ( psz = (LPSTR)pszLine ;
          *pszPrefix && *psz == *pszPrefix ;
          ++psz, ++pszPrefix )
    ;

    if ( *pszPrefix ) {

        *pbFail = TRUE;
        return;
    }

    //
    // Skip spaces
    //
    while ( *psz && *psz == ' ' )
        ++psz;

    *pdwValue = atoi(psz);
}


VOID
ReadDevMode(
    IN      HANDLE  hFile,
    OUT     LPDEVMODEA *ppDevMode,
    IN  OUT LPBOOL      pbFail
    )
{
    LPSTR   pszPrefix = "DevMode:";
    CHAR    c;
    DWORD   dwLen;
    LPINT   ptr;

    if ( *pbFail )
        return;

    // First skip the prefix
    //
    while ( *pszPrefix && (c = (CHAR) My_fgetc(hFile)) == *pszPrefix++ )
    ;

    if ( *pszPrefix )
        goto Fail;

    //
    // Skip spaces
    //
    while ( (c = (CHAR) My_fgetc(hFile)) == ' ' )
    ;

    //
    // Now is the devmode size
    //
    if ( !isdigit(c) )
        goto Fail;

    dwLen = c - '0';
    while ( isdigit(c = (CHAR) My_fgetc(hFile)) )
        dwLen = dwLen * 10 + c - '0';

    if ( dwLen == 0 )
        return;

    if ( c != ' ' )
        goto Fail;

    //
    // Now the devmode is there between []
    //
    if ( *ppDevMode = (LPDEVMODEA) AllocMem(dwLen) ) {

        if ( (c = (CHAR) My_fgetc(hFile)) != '[' )
            goto Fail;

        if ( dwLen != My_fread((LPVOID)*ppDevMode, dwLen, hFile) )
            goto Fail;

        //
        // Make sure now we have "]\n" to End
        //
        if ( (CHAR) My_fgetc(hFile) != ']' || (CHAR) My_fgetc(hFile) != '\n' ) {

            DebugMsg("Char check fails");
            goto Fail;
        }

        return; // Succesful exit
    }

Fail:
    *pbFail = TRUE;
}


VOID
FreePrinterInfo2Strings(
    PPRINTER_INFO_2A   pPrinterInfo2
    )
{
    if ( pPrinterInfo2 ) {

        FreeMem(pPrinterInfo2->pServerName);
        FreeMem(pPrinterInfo2->pPrinterName);
        FreeMem(pPrinterInfo2->pShareName);
        FreeMem(pPrinterInfo2->pPortName);
        FreeMem(pPrinterInfo2->pDriverName);
        FreeMem(pPrinterInfo2->pComment);
        FreeMem(pPrinterInfo2->pLocation);
        FreeMem(pPrinterInfo2->pDevMode);
        FreeMem(pPrinterInfo2->pSepFile);
        FreeMem(pPrinterInfo2->pPrintProcessor);
        FreeMem(pPrinterInfo2->pDatatype);
    }
}


VOID
ReadPrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN  OUT LPBOOL              pbFail
    )
{
    CHAR                szLine[2*MAX_PATH];
    DWORD               dwSize;

    dwSize = sizeof(szLine)/sizeof(szLine[0]);

    ReadString(hFile, "ServerName:",
               &pPrinterInfo2->pServerName, TRUE, pbFail);

    ReadString(hFile, "PrinterName:",
               &pPrinterInfo2->pPrinterName, FALSE, pbFail);

    ReadString(hFile, "ShareName:",
               &pPrinterInfo2->pShareName, TRUE, pbFail);

    ReadString(hFile, "PortName:",
               &pPrinterInfo2->pPortName, FALSE, pbFail);

    ReadString(hFile, "DriverName:",
               &pPrinterInfo2->pDriverName, FALSE, pbFail);

    ReadString(hFile, "Comment:",
               &pPrinterInfo2->pComment, TRUE, pbFail);

    ReadString(hFile, "Location:",
               &pPrinterInfo2->pLocation, TRUE, pbFail);

    ReadDevMode(hFile, &pPrinterInfo2->pDevMode, pbFail);

    ReadString(hFile, "SepFile:",
               &pPrinterInfo2->pSepFile, TRUE, pbFail);

    ReadString(hFile, "PrintProcessor:",
               &pPrinterInfo2->pPrintProcessor, FALSE, pbFail);

    ReadString(hFile, "Datatype:",
               &pPrinterInfo2->pDatatype, TRUE, pbFail);

    ReadString(hFile, "Parameters:",
               &pPrinterInfo2->pParameters, TRUE, pbFail);

    ReadDword(hFile, szLine, dwSize, "Attributes:",
               &pPrinterInfo2->Attributes, pbFail);

    ReadDword(hFile, szLine, dwSize, "Priority:",
              &pPrinterInfo2->Priority, pbFail);

    ReadDword(hFile, szLine, dwSize, "DefaultPriority:",
              &pPrinterInfo2->DefaultPriority, pbFail);

    ReadDword(hFile, szLine, dwSize, "StartTime:",
              &pPrinterInfo2->StartTime, pbFail);

    ReadDword(hFile, szLine, dwSize, "UntilTime:",
              &pPrinterInfo2->UntilTime, pbFail);

    ReadDword(hFile, szLine, dwSize, "Status:",
              &pPrinterInfo2->Status, pbFail);

    //
    // Skip the blank line
    //
    My_fgets(szLine, dwSize, hFile);

    if ( *pbFail ) {

        FreePrinterInfo2Strings(pPrinterInfo2);
        ZeroMemory(pPrinterInfo2, sizeof(*pPrinterInfo2));
    }
}


LPSTR
GetDefPrnString(
    IN  LPCSTR  pszPrinterName
    )
{
    DWORD   dwLen;
    LPSTR   pszRet;

    dwLen = strlen(pszPrinterName) + 1 + strlen("winspool") + 1;
    if ( pszRet = (LPSTR) AllocMem(dwLen * sizeof(CHAR)) ) {

        StringCchPrintfA(pszRet, dwLen, "%s,%s", pszPrinterName, "winspool");
    }

    return pszRet;
}


DWORD
GetFileNameInSpoolDir(
    IN  LPSTR   szBuf,
    IN  DWORD   cchBuf,
    IN  LPSTR   pszFileName
    )
/*++

Routine Description:
    Function returns fully qualified path of the given file name in the spool
    directory

Arguments:
    szPath      : Buffer to put the file name in
    cchBuf      : Buffer size in characters
    pszFileName : File name part

Return Value:
    Number of chars copied without \0 on success, 0 on failure

--*/
{
    DWORD   dwLen, dwLen1;

    dwLen   = GetSystemDirectoryA(szBuf, cchBuf);

    if ( !dwLen )
        return 0;

    dwLen += strlen(szSpool) + strlen(pszFileName);

    if ( dwLen + 1 > cchBuf )
        return 0;

    StringCchCatA(szBuf, cchBuf, szSpool);
    StringCchCatA(szBuf, cchBuf, pszFileName);

    return dwLen;
}


LPSTR
GetVendorSetupRunOnceValueToSet(
    VOID
    )
/*++
--*/
{
    CHAR    szPath[MAX_PATH];
    DWORD   dwLen, dwSize;
    LPSTR   pszRet = NULL;

    dwSize  = sizeof(szPath)/sizeof(szPath[0]);

    if ( !(dwLen = GetFileNameInSpoolDir(szPath, dwSize, szMigDll)) )
        goto Done;

    //
    // Now build up the RunOnce key which will be set for each user
    //
    dwSize = strlen("rundll32.exe") + dwLen +
                                    + strlen(pszVendorSetupCaller) + 4;

    if ( pszRet = AllocMem(dwSize * sizeof(CHAR)) )
        StringCchPrintfA(pszRet, dwSize,
                "rundll32.exe %s,%s",
                szPath, pszVendorSetupCaller);
Done:
    return pszRet;
}


LONG
WriteVendorSetupInfoInRegistry(
    IN CHAR *pszVendorSetup,
    IN CHAR *pszPrinterName
    )
/*++

Routine Description:
    This routine is called to write the name of the vendor's installer DLL,
    the entry point of that DLL, and the name of the printer
    
    The vendor setup information is stored as described below:
    
    HKLM
     \Software
       \Microsoft
         \Windows NT
           \CurrentVersion
             \Print
               \VendorSetupInfo
                 \VendorInfoEnumerator   N
                 \VendorSetup1           Vendor1Dll,EntryPoint "Printer1 Name"
                 \VendorSetup2           Vendor2Dll,EntryPoint "Printer2 Name"
                 .............................................................
                 \VendorSetupN           VendorNDll,EntryPoint "PrinterN Name"
               
    The value N of VendorInfoEnumerator is equal to the number of the printers
    for which vendor setup is provided. That value will be used to enumerate
    the Dll's provided by vendors in the process of calling the entry points
    of those Dlls.
    
    The type of VendorInfoEnumerator is REG_DWORD. 
    The value of each VendorSetupX key (where 1<= X <= N) is a string containing
    the name of the VendorSetup DLL, the entry point of that DLL and the
    corresponding printer name. WrireVendorSetupInfoInRegistry function 
    concatenates its input parameters to produce that value and to write in into
    the registry. The type of every VendorSetupX value is REG_SZ.
    
    The information about the function in migrate.dll which to be called after
    the first administrator's logon is stored into the registry as it is shown
    below:
    
    HKLM
     \Software
       \Microsoft
         \Windows
           \CurrentVersion
             \Run
               \MigrationVendorSetupCaller  

    The value of MigrationVendorSetupCaller is:                     
                     
        rundll32.exe %WinRoot%\system32\spool\migrate.dll,CallVendorSetupDlls
        
    The type of the value is REG_SZ.
    

Arguments:
    pszVendorSetup - null terminated string containing both the name of the
    vendor's DLL and the entry point of that DLL
    pszPrinterName - null terminated string containing the name of the printer
                                                                           
Return Value:
    ERROR_SUCCES in the case of success.
    error code in the other case.
    
--*/
{
    LONG   lRet                               = ERROR_BADKEY; 
    HKEY   hKeyVendorInfo                     = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoPath                 = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoInstaller            = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoEnumerator           = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorRunOnceValuePath         = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorRunOnceCallerValue       = INVALID_HANDLE_VALUE;
    CHAR  *pszBuffer                          = NULL;
    CHAR  *pszBuffer1                         = NULL;
    DWORD  dwType                             = 0;
    DWORD  dwSize                             = 0;
    LONG   lEnumerator                        = 0;
    DWORD  dwDisposition                      = 0;
    UINT   cbBufferSize                       = 0;
    UINT   cbBuffer1Size                      = 0;
    CHAR  *pszVendorSetupIDAsStr              = NULL;
    CHAR  *pszVendorSetupRunOnceValue         = NULL;

    
    if (!pszVendorSetup || (strlen(pszVendorSetup) == 0) ||
        !pszPrinterName || (strlen(pszPrinterName) == 0)) 
    {
        goto Cleanup;
    }

    //
    // We have to open the HKLM\Software\Microsoft\Windows NT\CurrentVersion\Print\VendorSetupInfo
    // key first.
    // 
    lRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0,
                           NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorInfoPath, NULL );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    //
    // Now we will try to create the VendorSetupInfo key
    //
    lRet = RegCreateKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0,
                           NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorInfo, NULL );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    //
    // Here we can create/open the VendorInfoEnumerator key.
    //
    lRet = RegCreateKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0,
                           NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorInfoEnumerator, &dwDisposition );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    else
    {
        if (dwDisposition == REG_OPENED_EXISTING_KEY) 
        {
            //
            // The VendorInfoEnumerator alredy exists. We opened and existing
            // key. So we have to increment its value with 1 because we intend
            // to create another VendorSetup key and to store there the
            // corresponding information.
            //
            dwType = REG_DWORD;
            dwSize = sizeof( lEnumerator );
            if (ERROR_SUCCESS != RegQueryValueEx(hKeyVendorInfoEnumerator, 
                                                 pszVendorSetupEnumerator, 0, 
                                                 &dwType, (LPBYTE)(&lEnumerator), 
                                                 &dwSize ) )
            {
                goto Cleanup;
            }
            lEnumerator++;
        }
        else
        {
            //
            // The VendorInfoEnumerator has been created. So this is the first
            // printer for which we have VendorSetup provided.
            //
            lEnumerator = 1;
        }
    }

    //
    // Below we will convert the value of VendorInfoEnumerator to a string and
    // will concatenate that string to "VendorSetup" to produce the names of
    // the Registry key and value where the data about the vendor provided DLL,
    // its entry point and the printer will be stored.
    //
    pszVendorSetupIDAsStr = AllocMem( dwMaxVendorSetupIDLength * sizeof(CHAR) );
    if (!pszVendorSetupIDAsStr) 
    {
        lRet = GetLastError();
        goto Cleanup;
    }

    _itoa( lEnumerator, pszVendorSetupIDAsStr, 10 );

    //
    // Below the memory necessary to build the vendor setup data and the
    // registry key name from the input data and from the value of 
    // the VendorInfoEnumerator will be allocated.
    //
    cbBufferSize  = (strlen(pszVendorSetup) + strlen(pszPrinterName) + strlen(TEXT(" \"\"")) + 2) * sizeof(CHAR);
    cbBuffer1Size = (strlen(pszVendorSetupID) + strlen(pszVendorSetupIDAsStr) + 2) * sizeof(CHAR);
    pszBuffer1    = AllocMem( cbBuffer1Size );
    pszBuffer     = AllocMem( cbBufferSize );
    if (!pszBuffer || !pszBuffer1) 
    {
        lRet = GetLastError();
        goto Cleanup;
    }
    else
    {
        StringCbCopyA( pszBuffer1, cbBuffer1Size, pszVendorSetupID);
        StringCbCatA(  pszBuffer1, cbBuffer1Size, pszVendorSetupIDAsStr );

        //
        // At this point pszBuffer1 points to the following string:
        // VendorSetupK where K is an integer - the value of VendorInfoEnumerator
        //
        lRet = RegCreateKeyEx( hKeyVendorInfo, pszBuffer1, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                               &hKeyVendorInfoInstaller, NULL );
        if (ERROR_SUCCESS != lRet)
        {
            goto Cleanup;
        }
        else
        {
            //
            // The Registry Key where to store the vendor setup data was
            // created successfully.
            //

            StringCbCopyA( pszBuffer, cbBufferSize, pszVendorSetup);
            StringCbCatA(  pszBuffer, cbBufferSize, " \"");
            StringCbCatA(  pszBuffer, cbBufferSize, pszPrinterName );
            StringCbCatA(  pszBuffer, cbBufferSize, "\"");

            //
            // At this point pszBuffer points to the following string:
            // VendorSetup.DLL,EntryPoint "PrinterName". We will store
            // that string in the Registry Key which we just created.
            //
            lRet = RegSetValueEx(hKeyVendorInfoInstaller, pszBuffer1, 0,
                                  REG_SZ, (BYTE *)pszBuffer, cbBufferSize );
            if (lRet != ERROR_SUCCESS) 
            {
                goto Cleanup;
            }
        }
    }

    // 
    // Here we will store the value of VendorInfoEnumerator.
    //
    dwSize = sizeof( lEnumerator );
    lRet = RegSetValueEx(hKeyVendorInfoEnumerator, pszVendorSetupEnumerator,
                         0, REG_DWORD, (BYTE*)(&lEnumerator), dwSize );
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }

    //
    // Now we can try to store into the registry the information how to invoke 
    // the migrate.dll after the first log on of an administrator.
    //
    pszVendorSetupRunOnceValue = GetVendorSetupRunOnceValueToSet();
    if (!pszVendorSetupRunOnceValue) 
    {
        lRet = GetLastError();
        goto Cleanup;
    }

    //
    // We will try to open the 
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Run
    //
    lRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
                           szVendorSetupRunRegistryPath, 0, NULL,
                           REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorRunOnceValuePath, NULL );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    else
    {
        //
        // We will try to create the 
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Run\MigrationVendorSetupCaller
        //
        lRet = RegCreateKeyEx( hKeyVendorRunOnceValuePath, pszMigrationVendorSetupCaller, 0,
                               NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                               &hKeyVendorRunOnceCallerValue, &dwDisposition );
        if (ERROR_SUCCESS != lRet)
        {
            goto Cleanup;
        }
        if (dwDisposition == REG_OPENED_EXISTING_KEY) 
        {
            goto Cleanup;
        }

        //
        // Here we will store the "rundll.exe %WinRoot%\System32\spool\migrate.dll,CallVendorSetupDlls"
        // string into the registry
        //
        lRet = RegSetValueEx(hKeyVendorRunOnceCallerValue, pszMigrationVendorSetupCaller,
                             0, REG_SZ, (BYTE *)pszVendorSetupRunOnceValue, 
                             strlen(pszVendorSetupRunOnceValue) * sizeof(CHAR) );
    }

Cleanup:
    
    if (pszVendorSetupRunOnceValue)
    {
        FreeMem(pszVendorSetupRunOnceValue);
    }
    if (pszVendorSetupIDAsStr)
    {
        FreeMem(pszVendorSetupIDAsStr);
    }
    if (pszBuffer) 
    {
        FreeMem(pszBuffer);
    }
    if (pszBuffer1) 
    {
        FreeMem(pszBuffer1);
    }
    if (hKeyVendorRunOnceValuePath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceValuePath );
    }
    if (hKeyVendorRunOnceCallerValue != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceCallerValue );
    }
    if (hKeyVendorInfoInstaller != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoInstaller );
    }
    if (hKeyVendorInfoEnumerator != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoEnumerator );
    }
    if (hKeyVendorInfo != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfo );
    }
    if (hKeyVendorInfoPath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoPath );
    }
   
    return lRet;
}


LONG
RemoveVendorSetupInfoFromRegistry(
    VOID
    )
/*++

Routine Description:
    This routine is called to remove the vendor setup information from the
    registry
    
Arguments:
                                                                           
Return Value:
    ERROR_SUCCESS in the case of success
    error code in any other case
    
--*/
{
    LONG  lRet                       = ERROR_SUCCESS;
    HKEY  hKeyVendorInfoPath         = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfo             = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfoEnumerator   = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorRunOnceValuePath = INVALID_HANDLE_VALUE;
    LONG  lVendorSetupKeysNum        = 0;
    DWORD dwMaxSubKeyLen             = 0;
    DWORD dwMaxClassLen              = 0;
    DWORD dwValues                   = 0;
    DWORD dwMaxValueNameLen          = 0;
    DWORD dwMaxValueLen              = 0;
    LONG  lIndex                     = 0;
    DWORD dwSize                     = 0;
    DWORD dwType                     = 0;
    DWORD dwKeyNameBufferLen         = 0;
    CHAR  *pszKeyNameBuffer          = NULL;


    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szVendorSetupRunRegistryPath, 0,
                         KEY_ALL_ACCESS, &hKeyVendorRunOnceValuePath );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    //
    // Delete the registry keys used to store the location and the entry point
    // of migrate.dll
    //
    lRet = RegDeleteKey( hKeyVendorRunOnceValuePath, pszMigrationVendorSetupCaller);
    if (lRet != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Below we have to delete the registry keys used to store the descriptions
    // of the vendor provided setup DLLs.
    //
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfoPath );
    if (lRet != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    
    lRet = RegOpenKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfo );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    
    //
    // Here we have to open the VendorInfoEnumerator and to read the
    // number of vendor provided setup DLLs.
    //
    lRet = RegOpenKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfoEnumerator );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    dwType = REG_DWORD;
    dwSize = sizeof( lVendorSetupKeysNum );
    lRet  = RegQueryValueEx(hKeyVendorInfoEnumerator, pszVendorSetupEnumerator, 0, 
                            &dwType, (LPBYTE)(&lVendorSetupKeysNum), &dwSize );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    RegCloseKey( hKeyVendorInfoEnumerator );
    hKeyVendorInfoEnumerator = INVALID_HANDLE_VALUE;
    lRet = RegDeleteKey( hKeyVendorInfo, pszVendorSetupEnumerator);
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }
    
    if (lVendorSetupKeysNum <= 0) 
    {
        goto Cleanup;
    }

    //
    // We have to add 1 for the the enumerator key itself to calculate the
    // number of registry keys where the vendor setup descriptions are
    // stored.
    //
    lVendorSetupKeysNum += 1;

    //
    // Below we will find the longest string used in the registry keys where
    // the vendor setup information is stored. 
    //
    lRet = RegQueryInfoKey( hKeyVendorInfo, NULL, NULL, NULL, &lVendorSetupKeysNum,
                            &dwMaxSubKeyLen, &dwMaxClassLen, &dwValues, &dwMaxValueNameLen,
                            &dwMaxValueLen, NULL, NULL );
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }
    dwKeyNameBufferLen = __max( __max( dwMaxClassLen, dwMaxSubKeyLen), 
                                __max( dwMaxValueNameLen, dwMaxValueLen ));
    dwKeyNameBufferLen += 1;

    //
    // Now we have data enough to allocate a buffer long enough to store
    // the longest string describing a key to delete.
    //
    pszKeyNameBuffer = AllocMem( dwKeyNameBufferLen * sizeof( CHAR ) );
    if (!pszKeyNameBuffer) 
    {
        goto Cleanup;
    }

    //
    // Enumerate and delete the keys used to store the VendorSetup
    // descriptions
    //
    lIndex = lVendorSetupKeysNum;
    while (lIndex >= 0)
    {
        if (ERROR_SUCCESS != (lRet = RegEnumKey( hKeyVendorInfo, lIndex, pszKeyNameBuffer, dwKeyNameBufferLen))) 
        {
            goto Cleanup;
        }

        if (ERROR_SUCCESS != (lRet = RegDeleteKey( hKeyVendorInfo, pszKeyNameBuffer))) 
        {
            goto Cleanup;
        }
        lIndex--;
    }

Cleanup:

    if (pszKeyNameBuffer) 
    {
        FreeMem( pszKeyNameBuffer );
    }
    if (hKeyVendorInfoEnumerator != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoEnumerator );
    }
    if (hKeyVendorInfo != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfo );
    }
    if (hKeyVendorInfoPath != INVALID_HANDLE_VALUE) 
    {
        RegDeleteKey( hKeyVendorInfoPath, pszVendorSetupInfo );
        RegCloseKey( hKeyVendorInfoPath );
    }
    if (hKeyVendorRunOnceValuePath != INVALID_HANDLE_VALUE)
    {
        RegCloseKey( hKeyVendorRunOnceValuePath );
    }

    return lRet;
}


VOID
CallVendorSetupDlls(
    VOID
    )
/*++

Routine Description:
    This is called after the first log on of an administrator. It calls
    vendor setup DLLs using the information we stored in the registry
    
Arguments:

Return Value:

--*/
{
    LONG  lRet                         = ERROR_SUCCESS;
    HKEY  hKeyVendorInfoPath           = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfo               = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfoEnumerator     = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorSetup              = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorRunOnceValuePath   = INVALID_HANDLE_VALUE;
    HWND  hwnd                         = INVALID_HANDLE_VALUE;
    LONG  lVendorSetupKeysNum          = 0;
    DWORD dwMaxSubKeyLen               = 0;
    DWORD dwMaxClassLen                = 0;
    DWORD dwValues                     = 0;
    DWORD dwMaxValueNameLen            = 0;
    DWORD dwMaxValueLen                = 0;
    LONG  lIndex                       = 0;
    DWORD dwSize                       = 0;
    DWORD dwType                       = 0;
    DWORD dwKeyNameBufferLen           = 0;
    DWORD dwLastPos                    = 0;
    CHAR  *pszKeyNameBuffer            = NULL;
    CHAR  *pszVendorSetupRunOnceValue  = NULL;
    BYTE  *pszVendorSetupPtr           = NULL;
    BOOL  bLocalAdmin                  = FALSE;

    CHAR             szParams[2*MAX_PATH+1];
    CHAR             szCmd[] = "rundll32.exe";
    SHELLEXECUTEINFO  ShellExecInfo;


    if (!IsLocalAdmin(&bLocalAdmin))
    {
        lRet = GetLastError();
        goto Cleanup;
    }
    if (!bLocalAdmin) 
    {
        goto Cleanup;
    }

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfoPath );
    if (lRet != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    
    lRet = RegOpenKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfo );
    if (ERROR_SUCCESS != lRet)
    {
        //
        // The vendor setup registry keys are missing. 
        // So there is nothing to do and we can remove from the registry 
        // all the keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }
    
    lRet = RegOpenKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfoEnumerator );
    if (ERROR_SUCCESS != lRet)
    {
        //
        // The vendor setup registry enumerator is missing. 
        // So the registry is damaged and the best is to remove from  
        // it the other keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }
    
    dwType = REG_DWORD;
    dwSize = sizeof( lVendorSetupKeysNum );
    lRet  = RegQueryValueEx(hKeyVendorInfoEnumerator, pszVendorSetupEnumerator, 0, 
                            &dwType, (LPBYTE)(&lVendorSetupKeysNum), &dwSize );
    if (ERROR_SUCCESS != lRet)
    {
        //
        // We cannot read the vendor setup registry enumerator. 
        // So the registry is damaged and the best is to remove from
        // it the other keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }

    RegCloseKey( hKeyVendorInfoEnumerator );
    hKeyVendorInfoEnumerator = INVALID_HANDLE_VALUE;

    if (lVendorSetupKeysNum <= 0) 
    {
        //
        // We have only the enumerator and no any vendor setup info key.
        // So there is nothing to do and we can remove from the registry 
        // all the keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }

    //
    // We have to add 1 for the enumerator key itself
    //
    lVendorSetupKeysNum += 1;

    lRet = RegQueryInfoKey( hKeyVendorInfo, NULL, NULL, NULL, &lVendorSetupKeysNum,
                            &dwMaxSubKeyLen, &dwMaxClassLen, &dwValues, &dwMaxValueNameLen,
                            &dwMaxValueLen, NULL, NULL );
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }

    dwKeyNameBufferLen = __max( __max( dwMaxClassLen, dwMaxSubKeyLen), 
                                __max( dwMaxValueNameLen, dwMaxValueLen ));
    dwKeyNameBufferLen += 2;
    if ( dwKeyNameBufferLen  > SIZECHARS(szParams) ) 
    {
        goto Cleanup;
    }
    pszKeyNameBuffer = AllocMem( dwKeyNameBufferLen * sizeof( CHAR ) );
    if (!pszKeyNameBuffer) 
    {
        goto Cleanup;
    }

    dwSize = dwKeyNameBufferLen * sizeof( CHAR );
    dwLastPos = dwKeyNameBufferLen - 1;
    pszVendorSetupPtr = AllocMem( dwSize );
    if (!pszVendorSetupPtr) 
    {
        goto Cleanup;
    }

    hwnd = GetDesktopWindow();
    for (lIndex = lVendorSetupKeysNum - 1; lIndex >= 0; lIndex--)
    {
        lRet = RegEnumKeyA( hKeyVendorInfo, lIndex, pszKeyNameBuffer, dwKeyNameBufferLen);
        if (ERROR_SUCCESS != lRet) 
        {
            continue;
        }
        if (strcmp( pszKeyNameBuffer, pszVendorSetupEnumerator)) 
        {
            lRet = RegOpenKeyEx( hKeyVendorInfo, pszKeyNameBuffer, 0,
                                 KEY_ALL_ACCESS, &hKeyVendorSetup );
            if (ERROR_SUCCESS != lRet)
            {
                goto Cleanup;
            }
            
            dwType = REG_SZ;
            lRet  = RegQueryValueExA(hKeyVendorSetup, pszKeyNameBuffer, 0, 
                                     &dwType, pszVendorSetupPtr, &dwSize );
            if (ERROR_SUCCESS != lRet) 
            {
                if (ERROR_MORE_DATA == lRet) 
                {
                    FreeMem( pszVendorSetupPtr );
                    pszVendorSetupPtr = AllocMem( dwSize );
                    dwLastPos = (dwSize/sizeof(CHAR)) - 1;
                    if (!pszVendorSetupPtr) 
                    {
                        goto Cleanup;
                    }
                    lRet  = RegQueryValueExA(hKeyVendorSetup, pszKeyNameBuffer, 0, 
                                             &dwType, pszVendorSetupPtr, &dwSize );
                    if (ERROR_SUCCESS != lRet) 
                    {
                        goto Cleanup;
                    }
                }
                else
                {
                    goto Cleanup;
                }
            }

            pszVendorSetupPtr[dwLastPos] = '\0';

            RegCloseKey( hKeyVendorSetup );
            hKeyVendorSetup = INVALID_HANDLE_VALUE;

            ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
            ShellExecInfo.cbSize        = sizeof(ShellExecInfo);
            ShellExecInfo.hwnd          = hwnd;
            ShellExecInfo.lpFile        = szCmd;
            ShellExecInfo.nShow         = SW_SHOWNORMAL;
            ShellExecInfo.fMask         = SEE_MASK_NOCLOSEPROCESS;
            ShellExecInfo.lpParameters  = pszVendorSetupPtr;

            //
            // Call run32dll and wait for the vendor dll to return before proceeding
            //
            if ( ShellExecuteEx(&ShellExecInfo) && ShellExecInfo.hProcess ) 
            {
                WaitForSingleObject(ShellExecInfo.hProcess, dwFourMinutes);
                CloseHandle(ShellExecInfo.hProcess);
            }
            RegDeleteKey( hKeyVendorInfo, pszKeyNameBuffer);

            //
            // One of the registry keys describing a vendor provided setup DLL
            // was removed. So the value of VendorInfoEnumerator must be
            // decremented by 1.
            //
            DecrementVendorSetupEnumerator();
        }
    }

    RemoveVendorSetupInfoFromRegistry();

Cleanup:

    if (pszVendorSetupPtr) 
    {
        FreeMem(pszVendorSetupPtr);
        pszVendorSetupPtr = NULL;
    }
    if (pszVendorSetupRunOnceValue) 
    {
        FreeMem(pszVendorSetupRunOnceValue);
    }
    if (pszKeyNameBuffer) 
    {
        FreeMem( pszKeyNameBuffer );
    }

    if (hKeyVendorRunOnceValuePath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceValuePath );
    }
    if (hKeyVendorSetup != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorSetup );
    }
    if (hKeyVendorInfoEnumerator != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoEnumerator );
    }
    if (hKeyVendorInfo != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfo );
    }
    if (hKeyVendorInfoPath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoPath );
    }

    return;
}


BOOL
IsLocalAdmin(
    BOOL *pbAdmin
    )
/*++

Routine Description:
    This Routine determines if the user is a local admin.

Parameters:
    pbAdmin - Return Value, TRUE for local admin.

Return Value:
    TRUE             - Function succeded (return value is valid).

--*/ 
{
    HMODULE AdvApi32Dll;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL    bRet      = FALSE;
    PSID    pSIDAdmin = NULL;

    AllOCANDINITSID      pAllocAndInitID    = NULL;
    CHECKTOKENMEMBERSHIP pCheckTokenMemship = NULL;
    FREESID              pFreeSid           = NULL;


    ASSERT( pbAdmin != NULL );  // Called locally

    *pbAdmin = FALSE;

    AdvApi32Dll = LoadLibraryUsingFullPathA( "advapi32.dll" );
    if (AdvApi32Dll == NULL)
    {
        goto Cleanup;
    }
    pAllocAndInitID    = (AllOCANDINITSID)GetProcAddress( AdvApi32Dll, "AllocateAndInitializeSid");
    pCheckTokenMemship = (CHECKTOKENMEMBERSHIP)GetProcAddress( AdvApi32Dll, "CheckTokenMembership");
    pFreeSid           = (FREESID)GetProcAddress( AdvApi32Dll, "FreeSid");

    if (!pAllocAndInitID || !pCheckTokenMemship || !pFreeSid) 
    {
        goto Cleanup;
    }

    if (!((*pAllocAndInitID)( &SIDAuth, 2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ADMINS,
                              0, 0, 0, 0, 0, 0,
                              &pSIDAdmin))) 
    {
        goto Cleanup;
    }
    if (!((*pCheckTokenMemship)( NULL,
                                 pSIDAdmin,
                                 pbAdmin ))) 
    {
        goto Cleanup;
    }
    bRet = TRUE;

Cleanup:

    if (pSIDAdmin != NULL) 
    {
        (*pFreeSid)( pSIDAdmin );
    }
    if (AdvApi32Dll)
    {
        FreeLibrary( AdvApi32Dll );
    }

    return bRet;
}


LONG
DecrementVendorSetupEnumerator(
    VOID
    )
/*++

Routine Description:
    This routine is called to decrement the value of the VendorInfoEnumerator.
    It is called after removing of one of the registry keys containing a description 
    of a vendor provided DLL.
    
Arguments:
   
                                                                           
Return Value:
    ERROR_SUCCESS in the case of success
    error code in any other case.
    
--*/
{
    LONG   lRet                     = ERROR_BADKEY;
    HKEY   hKeyVendorInfo           = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoPath       = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorEnumerator     = INVALID_HANDLE_VALUE;
    LONG   lEnumerator              = 0;
    DWORD  dwDisposition            = 0;
    DWORD  dwSize                   = 0;
    DWORD  dwType                   = 0;


    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfoPath );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    lRet = RegOpenKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0,
                         KEY_ALL_ACCESS, &hKeyVendorInfo );
    if (ERROR_SUCCESS != lRet)
    {
        RegCloseKey( hKeyVendorInfoPath );
        goto Cleanup;
    }

    lRet = RegOpenKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0,
                         KEY_ALL_ACCESS, &hKeyVendorEnumerator );
    if (ERROR_SUCCESS != lRet)
    {
        RegCloseKey( hKeyVendorInfo );
        RegCloseKey( hKeyVendorInfoPath );
        goto Cleanup;
    }
    else
    {
        dwType = REG_DWORD;
        dwSize = sizeof( lEnumerator );
        lRet  = RegQueryValueEx(hKeyVendorEnumerator, pszVendorSetupEnumerator, 0, 
                                 &dwType, (LPBYTE)(&lEnumerator), &dwSize );
        if (ERROR_SUCCESS == lRet)
        {
            lEnumerator--;
            lRet = RegSetValueEx(hKeyVendorEnumerator, pszVendorSetupEnumerator,
                                  0, REG_DWORD, (BYTE*)(&lEnumerator), dwSize );
        }
    }
    RegCloseKey( hKeyVendorEnumerator );
    RegCloseKey( hKeyVendorInfo );
    RegCloseKey( hKeyVendorInfoPath );

Cleanup:

    return lRet;
}

BOOL 
MakeACopyOfMigrateDll( 
    IN  LPCSTR pszWorkingDir 
    )
/*++

Routine Description:
    This routine is called to copy the Migrate.Dll into the given 
    directory.
    
Arguments:
    pszWorkingDir - the path where the Migrate.Dll to be copied.

Return Value:
    FALSE - in the case of error 
    TRUE  - in the case of success
    The bMigrateDllCopyed global variable is set to the corresponding value
    
--*/
{
    CHAR  szSource[MAX_PATH];
    CHAR  szTarget[MAX_PATH];
    DWORD dwSize;
    DWORD dwLen;

    if (bMigrateDllCopyed || !pszWorkingDir || !strlen(pszWorkingDir)) 
    {
        goto Cleanup;
    }
    //
    // First check if the source paths are ok
    //
    dwLen  = strlen(szMigDll);

    dwSize = sizeof(szTarget)/sizeof(szTarget[0]);

    if ( strlen(pszWorkingDir) + dwLen + 2 > dwSize )
    {
        goto Cleanup;
    }

    //
    // Need to make a copy of migrate.dll to the %windir%\system32\spool 
    // directory
    //
    StringCchPrintfA(szSource, SIZECHARS(szSource), "%s\\%s", pszWorkingDir, szMigDll);
    if ( !(dwLen = GetFileNameInSpoolDir(szTarget, dwSize, szMigDll))   ||
         !CopyFileA(szSource, szTarget, FALSE) )
    {
        goto Cleanup;
    }
    
    bMigrateDllCopyed = TRUE;

Cleanup:
    return bMigrateDllCopyed;
}


HMODULE LoadLibraryUsingFullPathA(
    LPCSTR lpFileName
    )
{
    CHAR szSystemPath[MAX_PATH];
    INT  cLength         = 0;
    INT  cFileNameLength = 0;


    if (!lpFileName || ((cFileNameLength = strlen(lpFileName)) == 0)) 
    {
        return NULL;
    }
    if (GetSystemDirectoryA(szSystemPath, sizeof(szSystemPath)/sizeof(CHAR) ) == 0)
    {
        return NULL;
    }
    cLength = strlen(szSystemPath);
    if (szSystemPath[cLength-1] != '\\')
    {
        if ((cLength + 1) >= MAX_PATH)
        {
            return NULL;
        }
        szSystemPath[cLength]     = '\\';
        szSystemPath[cLength + 1] = '\0';
        cLength++;
    }
    if ((cLength + cFileNameLength) >= MAX_PATH)
    {
        return NULL;
    }
    StringCchCatA(szSystemPath, SIZECHARS(szSystemPath), lpFileName);

    return LoadLibraryA( szSystemPath );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\dllmain.cpp ===
/*****************************************************************************\
* MODULE:       dllmain.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

extern "C" {

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR , DBG_ERROR );

#endif

}


///////////////////////////////////////////////////////////
//
// Global variables
//
static HMODULE g_hModule = NULL ;   // DLL module handle

const TCHAR g_szFriendlyName[] = _T ("Bidi Spooler APIs") ;
const TCHAR g_szRequestVerIndProgID[] = _T ("bidispl.bidirequest") ;
const TCHAR g_szRequestProgID[] = _T ("bidispl.bidirequest.1") ;

const TCHAR g_szContainerVerIndProgID[] = _T ("bidispl.bidirequestcontainer") ;
const TCHAR g_szContainerProgID[] = _T ("bidispl.bidirequestcontainer.1") ;

const TCHAR g_szSplVerIndProgID[] = _T ("bidispl.bidispl") ;
const TCHAR g_szSplProgID[] = _T ("bidispl.bidispl.1") ;

///////////////////////////////////////////////////////////
//
// Exported functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(REFCLSID clsid,
                         REFIID iid,
                         PVOID * ppv)
{

    DBGMSG(DBG_TRACE,("Enter DllGetClassObject\n"));

    // Can we create this component?
    if (clsid != CLSID_BidiRequest &&
        clsid != CLSID_BidiRequestContainer &&
        clsid != CLSID_BidiSpl) {

        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    TFactory* pFactory = new TFactory (clsid) ;  // Reference count set to 1
                                                 // in constructor
    if (pFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFactory->QueryInterface(iid, ppv) ;
    pFactory->Release() ;

    return hr ;

}

//
// Server registration
//
STDAPI DllRegisterServer()
{
    BOOL bRet;
    TComRegistry ComReg;

    bRet = ComReg.RegisterServer(g_hModule,
                                 CLSID_BidiRequest,
                                 g_szFriendlyName,
                                 g_szRequestVerIndProgID,
                                 g_szRequestProgID) &&

           ComReg.RegisterServer (g_hModule,
                                  CLSID_BidiRequestContainer,
                                  g_szFriendlyName,
                                  g_szContainerVerIndProgID,
                                  g_szContainerProgID) &&

           ComReg.RegisterServer(g_hModule,
                                 CLSID_BidiSpl,
                                 g_szFriendlyName,
                                 g_szSplVerIndProgID,
                                 g_szSplProgID);
    return bRet;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    TComRegistry ComReg;

    return ComReg.UnregisterServer(CLSID_BidiRequest,
                            g_szRequestVerIndProgID,
                            g_szRequestProgID) &&

           ComReg.UnregisterServer(CLSID_BidiRequestContainer,
                            g_szContainerVerIndProgID,
                            g_szContainerProgID) &&

           ComReg.UnregisterServer(CLSID_BidiSpl,
                            g_szSplVerIndProgID,
                            g_szSplProgID);


}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = hModule ;

        //if( !bSplLibInit( NULL )){
        //
        //    DBGMSG( DBG_WARN,
        //            ( "DllEntryPoint: Failed to init SplLib %d\n", GetLastError()));
        //}

    }
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\factory.h ===
/*****************************************************************************\
* MODULE:       TFactory.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TFACTORY
#define _TFACTORY

///////////////////////////////////////////////////////////
//
// Class factory
//
class TFactory : public IClassFactory
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(
        REFIID iid,
        void** ppv) ;

	STDMETHOD_ (ULONG, AddRef) () ;

	STDMETHOD_ (ULONG, Release)() ;

	// Interface IClassFactory
	STDMETHOD (CreateInstance) (
        IN  IUnknown* pUnknownOuter,
        IN  REFIID iid,
        OUT void** ppv) ;

	STDMETHOD (LockServer) (
        IN  BOOL bLock) ;

	TFactory(
        IN  REFGUID ClassId);

	~TFactory();

private:

	long m_cRef ;
    GUID m_ClassId;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\enum.h ===
#ifndef _TBIDIREQUESTCONTAINERENUM
#define _TBIDIREQUESTCONTAINERENUM

class TBidiRequestContainer;

class TBidiRequestContainerEnum: 
    public IEnumUnknown
{
public:

	// IUnknown
	STDMETHOD(QueryInterface)(
        REFIID iid,
        void** ppv) ;         
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release)() ;

    STDMETHOD (Next)(
        IN  ULONG celt,          
        OUT  IUnknown ** rgelt,   
        OUT  ULONG * pceltFetched);
 
    STDMETHOD (Skip) (
        IN  ULONG celt);
 
    STDMETHOD (Reset)(void);
 
    STDMETHOD (Clone)(
        OUT IEnumUnknown ** ppenum);
        
    TBidiRequestContainerEnum (
        TBidiRequestContainer &refContainer,
        TReqInterfaceList &refReqList);

    TBidiRequestContainerEnum (
        TBidiRequestContainerEnum & refEnum);

    ~TBidiRequestContainerEnum ();

    inline BOOL 
    bValid () CONST {return m_bValid;};
    
private:    
    BOOL                    m_bValid;
	LONG                    m_cRef ;
    TReqInterfaceList &     m_refReqList;
    TReqInterfaceNode *     m_pHead;
    TReqInterfaceNode *     m_pCurrent;
    TBidiRequestContainer & m_refContainer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\factory.cpp ===
/*****************************************************************************\
* MODULE:       Factory.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

// Class factory IUnknown implementation
//
STDMETHODIMP
TFactory::QueryInterface(
    REFIID iid,
    void** ppv)
{
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this) ;
	}
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
	return S_OK ;
}

STDMETHODIMP_ (ULONG)
TFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TFactory::Release()
{
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}

//
// IClassFactory implementation
//
STDMETHODIMP
TFactory::CreateInstance(
    IN  IUnknown* pUnknownOuter,
    IN  REFIID iid,
    OUT void** ppv)
{

    HRESULT hr = E_NOINTERFACE;

    DBGMSG(DBG_TRACE,("Class Factory:: CreateInstance\n"));

    // Cannot aggregate.
	if (pUnknownOuter != NULL) {
		return CLASS_E_NOAGGREGATION ;
	}

    if (IsEqualCLSID (CLSID_BidiRequestContainer, m_ClassId))
    {
        if (IsEqualIID (iid, IID_IBidiRequestContainer) || IsEqualIID (iid, IID_IUnknown)) {

            hr = PrivCreateComponent<TBidiRequestContainer> (new TBidiRequestContainer, iid, ppv);
        }
    }
    else if(IsEqualCLSID (CLSID_BidiRequest, m_ClassId))
    {
        if (IsEqualIID (iid, IID_IBidiRequest) || IsEqualIID (iid, IID_IUnknown) || IsEqualIID (iid, IID_IBidiRequestSpl)) {

            hr = PrivCreateComponent<TBidiRequest> (new TBidiRequest, iid, ppv);
        }
    }
    else if(IsEqualCLSID (CLSID_BidiSpl, m_ClassId))
    {
        if (IsEqualIID (iid, IID_IBidiSpl) || IsEqualIID (iid, IID_IUnknown)) {
            hr = PrivCreateComponent<TBidiSpl> (new TBidiSpl, iid, ppv);
        }
    }

    return hr;
}

// LockServer
STDMETHODIMP
TFactory::LockServer(
    BOOL bLock)
{
	if (bLock) {
		InterlockedIncrement(&g_cServerLocks) ;
	}
	else {
		InterlockedDecrement(&g_cServerLocks) ;
	}

    DBGMSG(DBG_TRACE,("Class Factory:: Lock Count = %d\n", g_cServerLocks));

	return S_OK ;
}


TFactory::TFactory(
    IN  REFGUID ClassId) :
    m_cRef(1),
    m_ClassId (ClassId)
{
    DBGMSG(DBG_TRACE,("Class Factory:: Created\n"));
}

TFactory::~TFactory()
{
    DBGMSG(DBG_TRACE,("Class Factory:: Destroy Itself\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\globals.cpp ===
/*****************************************************************************\
* MODULE: globals.c
*
* This is the common global variable module.  Any globals used throughout the
* executable should be placed in here and the cooresponding declaration
* should be in "globals.h".
*
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   Weihai Chen (weihaic) 07-Mar-200
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

LONG g_cComponents = 0 ;
LONG g_cServerLocks = 0;



HRESULT STDMETHODCALLTYPE 
LastError2HRESULT (VOID) 
{
    return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError ());
}


HRESULT STDMETHODCALLTYPE 
WinError2HRESULT (DWORD dwError) 
{
    return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>

#include <wininet.h>
#include <tchar.h>
#include <mdcommsg.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>

#include <strsafe.h>

#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\priv.h ===
#include "bidispl.h"
#include "bidisplp.h"
#include "globals.h"
#include "factory.h"
#include "request.h"
#include "registry.h"
#include "respdata.h"
#include "reqcont.h"
#include "splapi.h"
#include "reqdata.h"
#include "enum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\globals.h ===
/*****************************************************************************\
* MODULE:       globals.h
*
* PURPOSE:      Any globals used throughout the executable should be placed
*               in globals.c and the cooresponding declaration should
*               be in "globals.h".
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _GLOBALS_H
#define _GLOBALS_H

template <class T> 
HRESULT PrivCreateComponent (
    T * pIuk,
    REFIID iid, 
    void** ppv)
{
    HRESULT hr = E_FAIL;
    
    // Create component.
    if (pIuk) {
    
        if (pIuk->bValid ()) {
        
            // Get the requested interface.
            hr = pIuk->QueryInterface(iid, ppv) ;
        
        }
        else {
            hr = LastError2HRESULT ();
        }
        
        // Release the IUnknown pointer.
        pIuk->Release() ;

    }
    else {
        hr =  E_OUTOFMEMORY ;
    }
    return hr;
}



extern LONG g_cComponents;
extern LONG g_cServerLocks;

extern HRESULT STDMETHODCALLTYPE 
LastError2HRESULT (VOID);

extern HRESULT STDMETHODCALLTYPE 
WinError2HRESULT (
    DWORD dwError);

#define BIDI_NULL_SIZE 0
#define BIDI_INT_SIZE (sizeof (ULONG))
#define BIDI_FLOAT_SIZE (sizeof (FLOAT))
#define BIDI_BOOL_SIZE (sizeof (BOOL))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\registry.cpp ===
/*****************************************************************************\
* MODULE:       registry.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string

CONST DWORD TComRegistry::m_cdwClsidStringSize              = 39;
CONST TCHAR TComRegistry::m_cszCLSID[]                      = _T ("CLSID\\");
CONST TCHAR TComRegistry::m_cszCLSID2[]                     = _T ("CLSID");
CONST TCHAR TComRegistry::m_cszInprocServer32[]             = _T ("InprocServer32");
CONST TCHAR TComRegistry::m_cszProgID[]                     = _T ("ProgID");
CONST TCHAR TComRegistry::m_cszVersionIndependentProgID[]   = _T ("VersionIndependentProgID");
CONST TCHAR TComRegistry::m_cszCurVer[]                     = _T ("CurVer");
CONST TCHAR TComRegistry::m_cszThreadingModel[]             = _T ("ThreadingModel");
CONST TCHAR TComRegistry::m_cszBoth[]                       = _T ("Both");


/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
BOOL
TComRegistry::RegisterServer(
    IN  HMODULE hModule,            // DLL module handle
    IN  REFCLSID clsid,             // Class ID
    IN  LPCTSTR pszFriendlyName,    // Friendly Name
    IN  LPCTSTR pszVerIndProgID,    // Programmatic
    IN  LPCTSTR pszProgID)          //   IDs
{
    BOOL bRet = FALSE;
    // Get server location.
    TCHAR szModule [MAX_PATH];

    DWORD dwResult;
    TCHAR szCLSID[m_cdwClsidStringSize] ;

    DBGMSG(DBG_TRACE,("Enter RegisterServer"));


    if (GetModuleFileName(hModule, szModule,MAX_PATH) > 0) {

        // Convert the CLSID into a string.
        if (CLSIDtoString(clsid, szCLSID, sizeof(szCLSID))) {

            // Build the key CLSID\\{...}

            TCHAR szKey[64] ;
            StringCchCopy(szKey, COUNTOF(szKey), m_cszCLSID) ;
            StringCchCat(szKey, COUNTOF(szKey), szCLSID) ;

            // Add the CLSID to the registry.
            if (SetKeyAndValue(szKey, NULL, pszFriendlyName) &&

                // Add the server filename subkey under the CLSID key.
                SetKeyAndValue(szKey, m_cszInprocServer32, szModule) &&

                SetKeyAndNameValue(szKey, m_cszInprocServer32, m_cszThreadingModel, m_cszBoth) &&

                // Add the ProgID subkey under the CLSID key.
                SetKeyAndValue(szKey, m_cszProgID, pszProgID) &&

                // Add the version-independent ProgID subkey under CLSID key.
                SetKeyAndValue(szKey, m_cszVersionIndependentProgID, pszVerIndProgID) &&

                // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
                SetKeyAndValue(pszVerIndProgID, NULL, pszFriendlyName) &&
                SetKeyAndValue(pszVerIndProgID, m_cszCLSID2, szCLSID) &&
                SetKeyAndValue(pszVerIndProgID, m_cszCurVer, pszProgID) &&

                // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
                SetKeyAndValue(pszProgID, NULL, pszFriendlyName) &&
                SetKeyAndValue(pszProgID, m_cszCLSID2, szCLSID) ) {

                bRet = TRUE;
            }
        }
    }

    DBGMSG(DBG_TRACE,("Leave RegisterServer (Ret = %d)\n", bRet));

    return bRet;
}

//
// Remove the component from the registry.
//
BOOL
TComRegistry::UnregisterServer(
    IN  REFCLSID clsid,             // Class ID
    IN  LPCTSTR pszVerIndProgID,    // Programmatic
    IN  LPCTSTR pszProgID)          //   IDs
{
    BOOL bRet = FALSE;
    // Convert the CLSID into a char.
    TCHAR szCLSID[m_cdwClsidStringSize] ;

    DBGMSG(DBG_TRACE,("Enter UnregisterServer\n", bRet));

    if (CLSIDtoString(clsid, szCLSID, sizeof(szCLSID))) {

        TCHAR szKey[64] ;
        StringCchCopy(szKey, COUNTOF(szKey), m_cszCLSID) ;
        StringCchCat(szKey, COUNTOF(szKey), szCLSID) ;

        if (RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) &&
            RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszVerIndProgID) &&
            RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszProgID)) {

            bRet = TRUE;

        }
    }

    DBGMSG(DBG_TRACE,("Leave UnregisterServer (Ret = %d)\n", bRet));

    return bRet;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a string.
BOOL
TComRegistry::CLSIDtoString(
    IN      REFCLSID    clsid,
    IN OUT  LPTSTR      pszCLSID,
    IN      DWORD       dwLength)

{
    BOOL bRet = FALSE;
    HRESULT hr = E_FAIL;
    LPWSTR pwszCLSID = NULL ;

    if (dwLength >= m_cdwClsidStringSize ) {
        // Get CLSID

        hr = StringFromCLSID(clsid, &pwszCLSID);

        if (SUCCEEDED (hr))
        {
            hr = StringCbCopy( pszCLSID, dwLength, pwszCLSID);
            if (SUCCEEDED(hr))
               bRet = TRUE;
            else
               SetLastError (HRESULTTOWIN32 (hr));

            // Free memory.
            CoTaskMemFree(pwszCLSID) ;

        }
        else
            SetLastError (HRESULTTOWIN32 (hr));
    }

    return bRet;
}

//
// Delete a key and all of its descendents.
//
BOOL
TComRegistry::RecursiveDeleteKey(
    IN  HKEY hKeyParent,            // Parent of key to delete
    IN  LPCTSTR lpszKeyChild)       // Key to delete
{
    BOOL bRet = FALSE;
    // Open the child.
    HKEY hKeyChild = NULL;
    LONG lResult = 0;
    FILETIME time ;
    TCHAR szBuffer[MAX_PATH] ;
    DWORD dwSize;

    lResult = RegOpenKeyEx (hKeyParent, lpszKeyChild, 0, KEY_ALL_ACCESS, &hKeyChild) ;

    if (lResult == ERROR_SUCCESS)
    {

        // Enumerate all of the decendents of this child.

        for (;;) {

            dwSize = MAX_PATH ;

            lResult = RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time);
            if (lResult == ERROR_NO_MORE_ITEMS) {
                break;
            }
            else if (lResult == ERROR_SUCCESS) {
                // Delete the decendents of this child.
                if (!RecursiveDeleteKey (hKeyChild, szBuffer)) {
                    goto Cleanup;
                }
            }
            else {
                goto Cleanup;
            }
        }

        // Close the child.
        RegCloseKey(hKeyChild) ;
        hKeyChild = NULL;

        // Delete this child.
        if (ERROR_SUCCESS == RegDeleteKey(hKeyParent, lpszKeyChild)) {
            bRet = TRUE;
        }

    }

Cleanup:
    // Cleanup before exiting.
    if (hKeyChild)
        RegCloseKey(hKeyChild) ;

    if (!bRet && lResult)
        SetLastError (lResult);

    return bRet;

}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL
TComRegistry::SetKeyAndValue(
    IN  LPCTSTR pszKey,
    IN  LPCTSTR pszSubkey,
    IN  LPCTSTR pszValue)
{
    return SetKeyAndNameValue  (pszKey, pszSubkey, NULL, pszValue);
}

BOOL
TComRegistry::SetKeyAndNameValue(
    IN  LPCTSTR pszKey,
    IN  LPCTSTR pszSubkey,
    IN  LPCTSTR pszName,
    IN  LPCTSTR pszValue)
{
    BOOL bRet = FALSE;
    HKEY hKey = NULL;
    LPTSTR pszKeyBuf = NULL;
    long lResult;
    DWORD dwLen = lstrlen (pszKey) + 1;

    if (pszSubkey)
    {
        dwLen += lstrlen (pszSubkey) + 1;
    }

    pszKeyBuf = new TCHAR [dwLen];

    if (pszKeyBuf)
    {
        // Copy keyname into buffer.
        StringCchCopy(pszKeyBuf, dwLen, pszKey) ;

        // Add subkey name to buffer.
        if (pszSubkey != NULL)
        {
            StringCchCat(pszKeyBuf, dwLen, _T ("\\")) ;
            StringCchCat(pszKeyBuf, dwLen, pszSubkey ) ;
        }

        // Create and open key and subkey.
        lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                 pszKeyBuf, 0, NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS, NULL, &hKey, NULL);

        if (ERROR_SUCCESS == lResult ) {

            // Set the Value.
            if (pszValue != NULL) {

                lResult = RegSetValueEx (hKey, pszName, 0, REG_SZ,
                            (PBYTE) pszValue, sizeof (TCHAR) * lstrlen(pszValue));

                if (ERROR_SUCCESS == lResult ) {

                    bRet = TRUE;
                }
            }
            else
                bRet = TRUE;
        }


        if (hKey) {
            RegCloseKey(hKey) ;
        }

        delete [] pszKeyBuf;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\reqdata.h ===
#ifndef _TBIDIREQUESTINTERFACEDATA
#define _TBIDIREQUESTINTERFACEDATA


class TBidiRequestInterfaceData
{
public:           

    TBidiRequestInterfaceData (
        IBidiRequest *pRequest): 
        m_pRequest (pRequest),
        m_bValid (FALSE) {m_pRequest->AddRef ();};
        
    virtual ~TBidiRequestInterfaceData () {m_pRequest->Release ();};
    
    inline BOOL 
    bValid () CONST {return m_bValid;};
    
    inline IBidiRequest * 
    GetInterface (VOID) CONST {return m_pRequest;};
    
    
private:

    IBidiRequest *m_pRequest;
    BOOL m_bValid;                    
};

typedef TDoubleNode<TBidiRequestInterfaceData *, DWORD> TReqInterfaceNode;
typedef TDoubleListLock<TBidiRequestInterfaceData *, DWORD> TReqInterfaceList;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\reqdata.cpp ===
/*****************************************************************************\
* MODULE:       respdata.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/08/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiRequestInterfaceData::TBidiRequestInterfaceData (
    IBidiRequest *pRequest):
    m_pRequest (pRequest),
    m_bValid (TRUE)
{
    pRequest->AddRef ();
}

TBidiRequestInterfaceData::~TBidiRequestInterfaceData ()
{
    pRequest->Release ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\reqcont.cpp ===
/*****************************************************************************\
* MODULE:       reqcont.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiRequestContainer::TBidiRequestContainer():
    m_cRef(1)
{
	InterlockedIncrement(&g_cComponents) ; 
    
    m_bValid = m_ReqInterfaceList.bValid ();
    
    DBGMSG(DBG_TRACE,("TBidiRequestContainer Created\n"));
}

TBidiRequestContainer::~TBidiRequestContainer()
{
    InterlockedDecrement(&g_cComponents) ; 
    
    DBGMSG(DBG_TRACE,("TBidiRequestContainer Dstroy self\n"));
}


STDMETHODIMP 
TBidiRequestContainer::QueryInterface (
    REFIID iid, 
    void** ppv)
{
    HRESULT hr = S_OK;
                
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IBidiRequestContainer*>(this) ; 
	}
    else if (iid == IID_IBidiRequestContainer) {
    
		*ppv = static_cast<IBidiRequestContainer*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}
    
    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }
    
    DBGMSG(DBG_TRACE,("Leave TBidiRequestContainer QI hr=%x\n", hr));
	return hr ;
    
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainer::AddRef ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer::AddRef ref= %d\n", m_cRef));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainer::Release ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;

}
   
STDMETHODIMP 
TBidiRequestContainer::AddRequest (
    IN IBidiRequest *pRequest)
{
    HRESULT hr (E_FAIL);
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer::AddRequest\n"));

    if (m_bValid) {
    
        TBidiRequestInterfaceData * pData = NULL;
        
        pData = new TBidiRequestInterfaceData (pRequest);
        
        if (pData) {
        
            if (m_ReqInterfaceList.AppendItem (pData)) {
                hr = S_OK;
            }
            else 
                delete pData;
        }
       
        if (hr != S_OK) {
            hr = LastError2HRESULT ();
        }
    }
    else
        hr = E_HANDLE;
                      
    return hr;
}
 
    
STDMETHODIMP 
TBidiRequestContainer::GetEnumObject (
    OUT IEnumUnknown **ppenum)
{
    HRESULT hr;
    
    if (m_bValid) {
        hr = PrivCreateComponent <TBidiRequestContainerEnum> (
                        new TBidiRequestContainerEnum (*this, m_ReqInterfaceList),
                        IID_IEnumUnknown, (void **)ppenum);
    }
    else
        hr = E_HANDLE;
    
    return hr;
}
        

STDMETHODIMP 
TBidiRequestContainer::GetRequestCount(
    OUT ULONG *puCount)
{
    HRESULT hr;
    
    if (m_bValid) {
        if (m_ReqInterfaceList.GetTotalNode (puCount)) {
            hr = S_OK;
        }
        else
            hr = LastError2HRESULT ();
    }
    else
        hr = E_HANDLE;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\reqcont.h ===
/*****************************************************************************\
* MODULE:       request.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TBIDIREQUESTCONTAINER
#define _TBIDIREQUESTCONTAINER


#include "priv.h"
     
class TBidiRequestContainer : public IBidiRequestContainer
{
public:
	// IUnknown
	STDMETHOD (QueryInterface) (
        REFIID iid, 
        void** ppv) ;
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release) () ;
    
    STDMETHOD (AddRequest) (
        IN      IBidiRequest *pRequest);
    
    STDMETHOD (GetEnumObject) (
        OUT     IEnumUnknown **ppenum);

    STDMETHOD (GetRequestCount)(
        OUT     ULONG *puCount);
    
    // Constructor
	TBidiRequestContainer() ;

	// Destructor
	~TBidiRequestContainer();
    
    inline BOOL 
    bValid() CONST {return m_bValid;};

private:
    BOOL                m_bValid;
    LONG                m_cRef ;
    TReqInterfaceList   m_ReqInterfaceList;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\request.h ===
/*****************************************************************************\
* MODULE:       request.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TBIDIREQUEST
#define _TBIDIREQUEST

#include "priv.h"

class TBidiRequest : public IBidiRequestSpl
{
public:
	// IUnknown
	STDMETHOD (QueryInterface) (
        REFIID  iid,
        void**  ppv) ;
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release)() ;
    
    STDMETHOD (SetSchema) ( 
        IN  CONST   LPCWSTR pszSchema);
        
    STDMETHOD (SetInputData) ( 
        IN  CONST   DWORD   dwType,
        IN  CONST   BYTE    *pData,
        IN  CONST   UINT    uSize);
        
    STDMETHOD (GetResult) ( 
        OUT         HRESULT *phr);
        
    STDMETHOD (GetOutputData) ( 
        IN  CONST   DWORD   dwIndex,
        OUT         LPWSTR  *ppszSchema,
        OUT         PDWORD  pdwType,
        OUT         PBYTE   *ppData,
        OUT         PULONG  uSize);
        
    STDMETHOD (GetEnumCount)(
        OUT         PDWORD  pdwTotal);
    
    STDMETHOD (GetSchema) (
        OUT         LPWSTR  *ppszSchema);

    STDMETHOD (GetInputData)  (
        OUT         PDWORD  pdwType,
        OUT         PBYTE   *ppData,
        OUT         PULONG  puSize);
                
    STDMETHOD (SetResult) (
        IN  CONST   HRESULT hr);

    STDMETHOD (AppendOutputData) (
        IN  CONST   LPCWSTR pszSchema,
        IN  CONST   DWORD   dwType, 
        IN  CONST   BYTE    *pData,
        IN  CONST   ULONG   uSize);
    
    // Constructor
	TBidiRequest() ;

    // Destructor
    ~TBidiRequest() ;
    
    inline BOOL 
    bValid() CONST {return m_bValid;};

private:
	// Reference count
    BOOL                m_bValid;
    LONG                m_cRef ;
    LPWSTR              m_pSchema;
    BIDI_TYPE           m_kDataType;
    DWORD               m_dwDataSize;
    PBYTE               m_pbData;
    DWORD               m_dwResponseCount;
    HRESULT             m_hr;
    TCriticalSection    m_CritSec;
    TResponseDataList   m_ResponseDataList;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\request.cpp ===
/*****************************************************************************\
* MODULE:       request.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


//
// Constructor
//
TBidiRequest::TBidiRequest() :
    m_cRef(1),
    m_kDataType (BIDI_NULL),
    m_dwDataSize (0),
    m_pbData (NULL),
    m_pSchema (NULL),
    m_bValid (FALSE)
{
    InterlockedIncrement(&g_cComponents) ;

    m_bValid = m_CritSec.bValid () && m_ResponseDataList.bValid ();

    DBGMSG(DBG_TRACE,("TBidiRequest Created\n"));
}

//
// Destructor
//
TBidiRequest::~TBidiRequest()
{

    InterlockedDecrement(&g_cComponents) ;

    if (m_pSchema)
        delete [] m_pSchema;

    DBGMSG(DBG_TRACE,("TBidiRequest Dstroy self\n"));
}

//
// IUnknown implementation
//
STDMETHODIMP
TBidiRequest::QueryInterface(
    REFIID iid,
    PVOID* ppv)
{

    HRESULT hr = S_OK;

    DBGMSG(DBG_TRACE,("Enter TBidiRequest QI\n"));

    if (iid == IID_IUnknown) {
        *ppv = static_cast<IBidiRequest*>(this) ;
    }
    else if (iid == IID_IBidiRequest) {

        *ppv = static_cast<IBidiRequest*>(this) ;
    }
    else if (iid == IID_IBidiRequestSpl) {

        *ppv = static_cast<IBidiRequestSpl*>(this) ;
    }
    else {
        *ppv = NULL ;
        hr = E_NOINTERFACE ;
    }

    if (*ppv) {
        reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }

    DBGMSG(DBG_TRACE,("Leave TBidiRequest QI hr=%x\n", hr));
    return hr ;
}

STDMETHODIMP_ (ULONG)
TBidiRequest::AddRef()
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequest::AddRef ref= %d\n", m_cRef));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiRequest::Release()
{

    DBGMSG(DBG_TRACE,("Enter TBidiRequest::Release ref= %d\n", m_cRef));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}


STDMETHODIMP
TBidiRequest::SetSchema(
    LPCWSTR pszSchema)
{
    HRESULT hr (E_FAIL);

    DBGMSG(DBG_TRACE,("Enter SetSchema %ws\n", pszSchema));

    if (m_bValid) {

        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ()) {

            if (m_pSchema) {
                delete[] m_pSchema;
                m_pSchema = NULL;
            }

            if (pszSchema) {
                DWORD dwLen = lstrlen (pszSchema) + 1;
                m_pSchema = new WCHAR [dwLen];

                if (m_pSchema) {
                    hr = StringCchCopy (m_pSchema, dwLen, pszSchema);
                }
            }
            else
                SetLastError (ERROR_INVALID_PARAMETER);
        }

        if (FAILED (hr)) {

            hr = LastError2HRESULT();
        }
    }
    else
        hr = E_HANDLE;

    return hr;
}

STDMETHODIMP
TBidiRequest::SetInputData(
    IN CONST    DWORD   dwType,
    IN CONST    BYTE    *pData,
    IN CONST    UINT    uSize)
{
    HRESULT hr (S_OK);

    DBGMSG(DBG_TRACE,("Enter SetInputData dwType=%d\n", dwType));

    if (m_bValid) {

        // Verify data type and its size
        switch (dwType) {
        case BIDI_NULL:
            if (uSize)
                hr = E_INVALIDARG;
            break;
        case BIDI_INT:
            if (uSize != sizeof (ULONG)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_FLOAT:
            if (uSize != sizeof (FLOAT)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_BOOL:
            if (uSize != sizeof (BOOL)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_ENUM:
        case BIDI_STRING:
        case BIDI_TEXT:
            if (uSize != sizeof (WCHAR) * (lstrlen (reinterpret_cast<LPCWSTR> (pData)) + 1)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_BLOB:
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
        }

        if (hr == S_OK) {

            TAutoCriticalSection CritSec (m_CritSec);

            if (CritSec.bValid ()) {

                if (m_pbData) {
                    delete [] m_pbData;
                    m_pbData = NULL;
                }

                m_kDataType = (BIDI_TYPE) dwType;
                m_dwDataSize = uSize;

                if (uSize > 0) {
                    m_pbData = new BYTE [uSize];

                    if (m_pbData) {
                        CopyMemory (m_pbData, pData, uSize);
                        hr = S_OK;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else
                    hr = S_OK;

            }
            else {
                hr = LastError2HRESULT();
            }
        }
    }
    else
        hr = E_HANDLE;

    return hr;
}


STDMETHODIMP
TBidiRequest::GetResult(
    HRESULT  *phr)
{
    HRESULT hr;

    DBGMSG(DBG_TRACE,("Enter GetResult\n"));

    if (m_bValid) {

        if (phr) {
            TAutoCriticalSection CritSec (m_CritSec);

            if (CritSec.bValid ()) {
                *phr = m_hr;
                hr = S_OK;
            }
            else
                hr = LastError2HRESULT();

        }
        else {
            hr = E_POINTER;
        }
    }
    else
        hr = E_HANDLE;

    return hr;
}



STDMETHODIMP
TBidiRequest::GetOutputData(
    DWORD   dwIndex,
    LPWSTR  *ppszSchema,
    PDWORD  pdwType,
    PBYTE   *ppData,
    PULONG  puSize)
{
    HRESULT hr (E_FAIL);

    DBGMSG(DBG_TRACE,("Enter GetOutputData\n"));

    if (m_bValid) {

        if (ppszSchema && ppData && pdwType && puSize) {

            TAutoCriticalSection CritSec (m_CritSec);
            PBYTE   pData       = NULL;
            LPWSTR  pszSchema   = NULL;
            DWORD   dwType      = 0;
            DWORD   dwSize      = 0;

            if (CritSec.bValid ()) {
                TResponseData * pRespData = m_ResponseDataList.GetItemFromIndex (dwIndex);

                if (pRespData) {

                    LPCTSTR pszRespSchema = pRespData->GetSchema ();

                    if (pszRespSchema) {
                        DWORD dwLen = ( 1 + lstrlen (pszRespSchema)) * sizeof (TCHAR);
                        pszSchema = (LPWSTR) CoTaskMemAlloc (dwLen);

                        if (pszSchema) {
                            StringCbCopy (pszSchema, dwLen, pszRespSchema);
                        }
                        else
                            goto Cleanup;
                    }
                    else
                        pszSchema = NULL;

                    dwType = pRespData->GetType ();
                    dwSize = pRespData->GetSize ();

                    if (dwSize == 0) {
                        hr = S_OK;
                    }
                    else {
                        pData = (PBYTE) CoTaskMemAlloc (dwSize);

                        if (pData) {
                            CopyMemory (pData, pRespData->GetData (), dwSize);
                            hr = S_OK;
                        }
                    }
                }
                else {
                    SetLastError (ERROR_INVALID_DATA);
                }
            }
    Cleanup:
            if (FAILED (hr)) {
                hr = LastError2HRESULT ();

                if (pszSchema) {
                    CoTaskMemFree (pszSchema);
                    pszSchema = NULL;
                }
                if (pData) {
                    CoTaskMemFree (pData);
                    pData = NULL;
                }
            }
            else {
                *ppszSchema = pszSchema;
                *ppData = pData;
                *pdwType = dwType;
                *puSize = dwSize;
            }

        }
        else
            hr = E_POINTER;
    }
    else
        hr = E_HANDLE;

    return hr;

}

STDMETHODIMP
TBidiRequest::GetEnumCount(
    OUT PDWORD pdwTotal)
{
    HRESULT hr;

    DBGMSG(DBG_TRACE,("Enter GetOutputData\n"));

    if (m_bValid) {

        if (pdwTotal) {
            TAutoCriticalSection CritSec (m_CritSec);

            if (CritSec.bValid ()) {
                BOOL bRet;

                bRet = m_ResponseDataList.GetTotalNode (pdwTotal);

                if (bRet) {
                    hr = S_OK;
                }
                else
                    hr = LastError2HRESULT();
            }
            else
                hr = LastError2HRESULT();
        }
        else {
            hr = E_POINTER;
        }
    }
    else
        hr = E_HANDLE;

    return hr;
}


STDMETHODIMP
TBidiRequest::GetSchema  (
    OUT LPWSTR *ppszSchema)
{
    HRESULT hr;
    LPWSTR pStr;

    DBGMSG(DBG_TRACE,("Enter GetSchema\n"));

    if (m_bValid) {

        if (ppszSchema) {

            TAutoCriticalSection CritSec (m_CritSec);

            if (CritSec.bValid ()) {

                if (m_pSchema) {

                    DWORD dwLen = ( 1 + lstrlen (m_pSchema)) * sizeof (WCHAR);
                    pStr = (LPWSTR) CoTaskMemAlloc (dwLen);

                    if (pStr) {

                        hr = StringCbCopy (pStr, dwLen, m_pSchema);

                        if (SUCCEEDED(hr))
                            *ppszSchema = pStr;
                        else
                        {
                            *ppszSchema = NULL;
                            CoTaskMemFree (pStr);
                        }

                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else {
                    *ppszSchema = NULL;
                    hr = S_OK;
                }
            }
            else
                hr = LastError2HRESULT();
        }
        else {
            hr = E_POINTER;
        }
    }
    else
        hr = E_HANDLE;

    return hr;
}

STDMETHODIMP
TBidiRequest::GetInputData  (
    OUT PDWORD   pdwType,
    OUT PBYTE   *ppData,
    OUT PULONG  puSize)
{
    HRESULT hr;

    DBGMSG(DBG_TRACE,("Enter GetInputData\n"));

    if (m_bValid) {

        if (pdwType && ppData && puSize) {

            TAutoCriticalSection CritSec (m_CritSec);

            if (CritSec.bValid ()) {

                *pdwType = m_kDataType;

                if (m_pbData) {

                    *ppData = (PBYTE) CoTaskMemAlloc (m_dwDataSize);

                    if (*ppData) {
                        CopyMemory (*ppData, m_pbData, m_dwDataSize);
                        *puSize = m_dwDataSize;

                        hr = S_OK;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else {
                    *ppData = NULL;
                    *puSize = 0;
                    hr = S_OK;
                }
            }
            else
                hr = LastError2HRESULT();
        }
        else
            hr = E_POINTER;
    }
    else
        hr = E_HANDLE;

    return hr;
}

STDMETHODIMP
TBidiRequest::SetResult (
    IN CONST HRESULT hrReq)
{
    HRESULT hr;

    DBGMSG(DBG_TRACE,("Enter SetResult\n"));

    if (m_bValid) {

        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ()) {
            m_hr = hrReq;
            hr = S_OK;
        }
        else
            hr = LastError2HRESULT();
    }
    else
        hr = E_HANDLE;

    return hr;
}

STDMETHODIMP
TBidiRequest::AppendOutputData (
    IN  CONST   LPCWSTR pszSchema,
    IN  CONST   DWORD   dwType,
    IN  CONST   BYTE    *pData,
    IN  CONST   ULONG   uSize)
{
    HRESULT hr (E_FAIL);
    BOOL bRet;

    DBGMSG(DBG_TRACE,("Enter AppendOutputData\n"));

    if (m_bValid) {

        TResponseData *pRespData = NULL;

        pRespData = new TResponseData (pszSchema, dwType, pData, uSize);

        bRet = pRespData && pRespData->bValid ();

        if (bRet) {

            TAutoCriticalSection CritSec (m_CritSec);

            if (CritSec.bValid ()) {

                bRet = m_ResponseDataList.AppendItem (pRespData);

                if (bRet) {
                    hr = S_OK;

                }
            }
        }

        if (FAILED (hr)) {
            hr = LastError2HRESULT();
            if (pRespData) {
                delete (pRespData);
            }
        }
    }
    else
        hr = E_HANDLE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\registry.h ===
#ifndef __Registry_H__
#define __Registry_H__
/*****************************************************************************\
* MODULE:       bidireq.cpp
*
* PURPOSE:      Helper functions registering and unregistering a component.
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

class TComRegistry {
public:

    TComRegistry (){};
    ~TComRegistry () {};

    static BOOL
    RegisterServer(
        IN      HMODULE     hModule, 
        IN      REFCLSID    clsid,  
        IN      LPCTSTR     pszFriendlyName,
        IN      LPCTSTR     pszVerIndProgID,
        IN      LPCTSTR     pszProgID);     
                           
    
    static BOOL 
    UnregisterServer(
        IN      REFCLSID    clsid, 
        IN      LPCTSTR     pszVerIndProgID,
        IN      LPCTSTR     pszProgID);     
private:
    static BOOL 
    SetKeyAndValue(
        IN      LPCTSTR     pszKey,
        IN      LPCTSTR     pszSubkey,
        IN      LPCTSTR     pszValue);
    
               
    static BOOL 
    SetKeyAndNameValue(
        IN      LPCTSTR     pszKey,
        IN      LPCTSTR     pszSubkey,
        IN      LPCTSTR     pszName,
        IN      LPCTSTR     pszValue);
                            
    // Convert a CLSID into a char string.
    static BOOL  
    CLSIDtoString(
        IN      REFCLSID    clsid,
        IN OUT  LPTSTR      pszCLSID, 
        IN      DWORD       dwLength);
    
    // Delete szKeyChild and all of its descendents.
    static BOOL 
    RecursiveDeleteKey(
        IN      HKEY        hKeyParent,            // Parent of key to delete
        IN      LPCTSTR     lpszKeyChild);      // Key to delete

    // Size of a CLSID as a string
    static CONST DWORD m_cdwClsidStringSize;
    static CONST TCHAR m_cszCLSID[];
    static CONST TCHAR m_cszCLSID2[];
    static CONST TCHAR m_cszInprocServer32[];
    static CONST TCHAR m_cszProgID[];
    static CONST TCHAR m_cszVersionIndependentProgID[];
    static CONST TCHAR m_cszCurVer[];
    static CONST TCHAR m_cszThreadingModel[];
    static CONST TCHAR m_cszBoth[];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\clients\bidiutil\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>
#include "wingdip.h"

#include <wininet.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\splapi.h ===
/*****************************************************************************\
* MODULE:       splapi.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TBIDISPL
#define _TBIDISPL

#include "priv.h"

class TBidiSpl : public IBidiSpl
{
public:
	// IUnknown
	STDMETHOD (QueryInterface) (
        REFIID iid, 
        void** ppv) ;
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release) () ;
    
    STDMETHOD (BindDevice) (
        IN  CONST   LPCWSTR pszDeviceName,
        IN  CONST   DWORD dwAccess);
    
    STDMETHOD (UnbindDevice) ();
    
    STDMETHOD (SendRecv) (
        IN  CONST   LPCWSTR pszAction,
        IN          IBidiRequest * pRequest);
    
    STDMETHOD (MultiSendRecv) (
        IN  CONST   LPCWSTR pszAction,
        IN          IBidiRequestContainer * pRequestContainer);


    // Constructor
	TBidiSpl() ;

	// Destructor
	~TBidiSpl();
    
    inline BOOL bValid() CONST {return m_bValid;} ;

private:
    
    class TRequestContainer {
    public:
        TRequestContainer (
            CONST DWORD dwCount);

        ~TRequestContainer ();

        BOOL    
        AddRequest (
            IN  CONST   DWORD       dwIndex,
            IN  CONST   LPCWSTR     pszSchema,
            IN  CONST   BIDI_TYPE   dwDataType,
            IN          PBYTE       pData,
            IN  CONST   DWORD       dwSize);

        inline PBIDI_REQUEST_CONTAINER
        GetContainerPointer () CONST {return m_pContainer;};

        inline BOOL
        bValid () CONST {return m_bValid;};

    private:
        PBIDI_REQUEST_CONTAINER     m_pContainer;
        BOOL                        m_bValid;
    };

    typedef DWORD (*PFN_ROUTERFREEBIDIRESPONSECONTAINER) (
                    PBIDI_RESPONSE_CONTAINER pData);

    typedef DWORD (*PFN_SENDRECVBIDIDATA) (
                    IN  HANDLE                    hPrinter,
                    IN  LPCTSTR                   pAction,
                    IN  PBIDI_REQUEST_CONTAINER   pReqData,
                    OUT PBIDI_RESPONSE_CONTAINER* ppResData);

    HRESULT 
    ValidateContext ();
    
    HRESULT
    ComposeRequestData (
        IN  IBidiRequestContainer *pIReqContainer,
        OUT TRequestContainer **ppReqContainer);

    HRESULT
    SetData (
        IN  IBidiRequestSpl *pISpl,
        IN  PBIDI_RESPONSE_DATA pResponseData);

    HRESULT
    ComposeReponseData (
        IN  IBidiRequestContainer *pIReqContainerSpl,
        IN  PBIDI_RESPONSE_CONTAINER pResponse);


    BOOL                m_bValid;
    LONG                m_cRef;
    TCriticalSection    m_CritSec;
    HANDLE              m_hPrinter;
    
    PFN_SENDRECVBIDIDATA m_pfnSendRecvBidiData;
    PFN_ROUTERFREEBIDIRESPONSECONTAINER m_pfnRouterFreeBidiResponseContainer;
    

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\respdata.cpp ===
/*****************************************************************************\
* MODULE:       respdata.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/08/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TResponseData::TResponseData (
    IN  CONST LPCWSTR   pszSchema,
    IN  CONST DWORD     dwType,
    IN  CONST BYTE      *pData,
    IN  CONST ULONG     uSize):
    m_dwType (dwType),
    m_pData (NULL),
    m_uSize (uSize),
    m_pSchema (NULL),
    m_bValid (FALSE)
{
    BOOL bValid = FALSE;

    //
    // In the response, the schema string can be NULL for GET operation
    //

    if (pszSchema) {

        DWORD dwLen = lstrlen (pszSchema) + 1;
        m_pSchema = new WCHAR [dwLen];

        if (m_pSchema) {
            if (SUCCEEDED(StringCchCopy (m_pSchema, dwLen, pszSchema)))
                bValid = TRUE;
        }
    }
    else
        bValid = TRUE;

    if (bValid) {

        // Validate the type and size
        BOOL bRet;

        switch (dwType) {
        case BIDI_NULL:
            bRet = uSize == BIDI_NULL_SIZE;
            break;
        case BIDI_INT:
            bRet = uSize == BIDI_INT_SIZE;
            break;
        case BIDI_FLOAT:
            bRet = uSize == BIDI_FLOAT_SIZE;
            break;
        case BIDI_BOOL:
            bRet = uSize == BIDI_BOOL_SIZE;
            break;
        case BIDI_ENUM:
            bRet = (uSize > 0);
            break;

        case BIDI_STRING:
        case BIDI_TEXT:
        case BIDI_BLOB:
            bRet = TRUE;
            break;

        default:
            bRet = FALSE;
        }

        if (bRet) {

            if (uSize) {

                m_pData = new BYTE [uSize];
                if (m_pData) {
                    CopyMemory (m_pData, pData, uSize);
                    m_bValid = TRUE;
                }
            }
            else
                m_bValid = TRUE;
        }
    }
}

TResponseData::~TResponseData ()
{
    if (m_pData) {
        delete [] m_pData;
        m_pData = NULL;
    }

    if (m_pSchema) {
        delete [] m_pSchema;
        m_pSchema = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\valid.h ===
/*****************************************************************************\
* Class  CValid - Header file
*
* Copyright (C) 1998 Microsoft Corporation
*
* Author:
*   Weihai Chen (weihaic) May 24, 1999
*
\*****************************************************************************/

#ifndef _VALID_H
#define _VALID_H

class TValid
{
public:
    TValid (BOOL bValid = TRUE):m_bValid(bValid) {};

    virtual ~TValid (void) {};

    const BOOL bValid () const {return m_bValid;};

protected:
    BOOL m_bValid;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\clients\bidiutil\bidiutil.cpp ===
//
// Client.cpp - client implementation
//
#include "precomp.h"
#include "tchar.h"
#include "bidispl.h"

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#ifndef MODULE

#define MODULE "BIDIUTIL:"

#endif

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE, DBG_ERROR );

#endif

VOID DbgBreakPoint (VOID)
{
}

void DumpData (DWORD dwType, PBYTE pData, DWORD dwSize)
{

    DBGMSG (DBG_INFO, ("dwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize)) ;

    DWORD col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    for (DWORD i = 0; i < dwSize; i++) {

        sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
        if ((col ++) % 16 == 15) {
            DBGMSG (DBG_INFO, ("%s\n", szBuf));
            szBuf[0] = 0;
        }
    }
    DBGMSG (DBG_INFO, ("%s\n", szBuf));
}

void DumpOutputData (DWORD dwType, PBYTE pData, DWORD dwSize)
{
    DWORD i, col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    printf ("\tdwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize);

    switch (dwType) {
    case BIDI_NULL:
        printf("\tBIDI_NULL\n");
        break;
    case BIDI_INT:
        printf 	("\tBIDI_INT = %d\n", *(INT*)pData);
        break;
    case BIDI_FLOAT:
        printf 	("\tBIDI_FLOAT = %f\n", *(FLOAT*)pData);
        break;
    case BIDI_BOOL:
        printf 	("\tBIDI_BOOL = %s\n", (*(BOOL*)pData)?"TRUE":"FALSE");
        break;
    case BIDI_ENUM:
    case BIDI_TEXT:
    case BIDI_STRING:
        printf 	("\tBIDI_STRING = |%ws|\n", pData);
        break;
    case BIDI_BLOB:
        printf 	("\tBIDI_BLOB\n", pData);

        for (i = 0; i < dwSize; i++) {

            sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
            if ((col ++) % 16 == 15) {
                printf ("%s\n", szBuf);
                szBuf[0] = 0;
            }
        }
        printf ("%s\n", szBuf);
    default:
        printf 	("\tunsupported\n", pData);
    }


}


void DumpRequest (IBidiRequest * pIRequest)
{
    DWORD dwTotoal, i;
    HRESULT hr, hResult;
    LPWSTR pszSchema = NULL;
    BYTE *pData;
    DWORD uSize;
    DWORD dwType;
    DWORD dwTotal;

    hr = pIRequest->GetResult (&hResult);
    SPLASSERT (SUCCEEDED (hr));

    hr = pIRequest->GetEnumCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    printf("hr = %x; total response = %d\n", hResult, dwTotal);

    for (i = 0; i < dwTotal; i++) {
        hr =  pIRequest->GetOutputData  (i, &pszSchema, &dwType, &pData, &uSize);
        printf("%d: %ws\n", i, (pszSchema)?pszSchema:L"");
        DumpOutputData (dwType, pData, uSize);
    }

}

void DumpContainer (IBidiRequestContainer * pIReqContainer)
{
    IBidiRequest * pRequest = NULL;
    DWORD dwRef, i;
    DWORD dwTotal;
    HRESULT hr;

    hr = pIReqContainer->GetRequestCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    IEnumUnknown *pEnumIunk;
    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    SPLASSERT (SUCCEEDED (hr));

    for (i = 0; i < dwTotal; i++){
        IUnknown *pIunk;
        DWORD dwFetched;
        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        SPLASSERT (SUCCEEDED (hr));
        SPLASSERT (dwFetched == 1);

        IBidiRequest *pIRequest = NULL;
        hr = pIunk->QueryInterface (IID_IBidiRequest, (void **) & pIRequest);
        SPLASSERT (SUCCEEDED (hr));

        printf("Request No.%d\n", i);

        DumpRequest (pIRequest);

        dwRef = pIunk->Release();
        dwRef = pIRequest->Release();
    }

    pEnumIunk->Release ();
}


IBidiRequest *  GenRequest (LPWSTR pSchema)
{
    HRESULT hr;
	
    IUnknown * pIUnk = NULL ;

	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IUnknown,
                            (void**)&pIUnk) ;

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoCreateInstance\n"));
        exit (0);
    }

    hr = pIUnk->QueryInterface (IID_IBidiRequest, (void **)&pIReq);

    pIUnk->Release();

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("QueryInterface\n"));
        exit (0);
    }

    if (pSchema) {
        hr = pIReq->SetSchema (pSchema);
        if (FAILED (hr)) {
            DBGMSG (DBG_WARNING, ("SetSchema\n"));
            exit (0);
        }
    }
    return pIReq;
}


IBidiRequestContainer *CreateContainer ()
{
    HRESULT hr;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoCreateInstance\n"));
        exit (0);
    }

    return pIReqContainer;
}

void AddRequest (
    IBidiRequestContainer * pIReqContainer,
    LPWSTR pSchema)
{
    IBidiRequest * pRequest = NULL;
    HRESULT hr;
    DWORD dwRef;

    pRequest = GenRequest (pSchema);
    if (!pRequest) {
        DBGMSG (DBG_WARNING, ("GenRequest\n"));
        exit (0);
    }

    hr = pIReqContainer->AddRequest (pRequest);
    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("AddRequest\n"));
        exit (0);
    }

    dwRef = pRequest->Release ();

}

void usage()
{
    printf("\n"
           "usage: bidiutil [-p pname] [-t] [-d] [-a action] [-s schema1 schema2 schema3 ... ] \n"
           "\n"
           "where:   -p printer name\n"
           "         -t SendRecv (default: MultiSendRecv)\n"
           "         -d admin (default: User) \n"
           "         -a action e.g. Enum, Get, GetAll) \n"
           "         -s schema e.g. /printer/installalableoption/duplexunit\n");
    exit (0);
}

extern "C"
INT
_cdecl
_tmain(
    int argc,
    TCHAR **argv)
{


    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    IBidiRequestContainer *pIReqContainer;
    IBidiRequest * pRequest = NULL;
    LPTSTR pPrinter = NULL;
    LPTSTR pAction = NULL;;
    BOOL bLoop = TRUE;
    BOOL bSingle = FALSE;
    BOOL dwAccess = BIDI_ACCESS_USER;

    for (--argc, ++argv; argc && bLoop; --argc, ++argv) {

        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case L'?':
                usage();
                break;

            case L'p':
                ++argv;
                --argc;
                pPrinter = *argv;
                break;

            case L's':
                bLoop = FALSE;
                break;

            case L'a':
                ++argv;
                --argc;
                pAction = *argv;
                break;

            case L't':
                bSingle = TRUE;
                break;

            case L'd':
                dwAccess = BIDI_ACCESS_ADMINISTRATOR;
                break;

            default:
                usage();
                break;
            }
        }
        else {
            printf("Invalid Argument %s\n", *argv);
            exit (1);
        }
    }
    if (!pAction || !pPrinter) {
        usage ();
    }


    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;
    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoInitilaizeEx\n"));
        exit (0);
    }

    hr = CoCreateInstance(CLSID_BidiSpl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiSpl,
                            (void**)&pIBidiSpl) ;

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoCreateInstance\n"));
        exit (0);
    }

    hr = pIBidiSpl->BindDevice (pPrinter, dwAccess);
    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("BindDevice\n"));
        exit (0);
    }

    if (bSingle) {

        if (argc > 0)
            pRequest = GenRequest (*argv);
        else
            pRequest = GenRequest (NULL);

        hr = pIBidiSpl->SendRecv (pAction, pRequest);
        if (FAILED (hr)) {
            printf  ("SendRecv failed (0x%x)\n", hr);
            exit (0);
        }

        DumpRequest (pRequest);
        dwRef =  pRequest->Release ();

    }
    else {
        pIReqContainer = CreateContainer ();

        if (argc > 0) {
            while (argc-- > 0)
                AddRequest (pIReqContainer, *argv++);
        }
        else
            AddRequest (pIReqContainer, NULL);


        hr = pIBidiSpl->MultiSendRecv (pAction, pIReqContainer);
        if (FAILED (hr)) {
            printf  ("MultiSendRecv failed (0x%x)\n", hr);
            exit (0);
        }

        DumpContainer (pIReqContainer);

        dwRef = pIReqContainer->Release ();
    }

    dwRef = pIBidiSpl->Release ();

    DBGMSG (DBG_TRACE, ("IBidiSpl released.\n")) ;

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\splapi.cpp ===
/*****************************************************************************\
* MODULE:       splapi.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiSpl::TBidiSpl():
    m_bValid (FALSE),
    m_cRef (1),
    m_CritSec (),
    m_hPrinter (NULL),
    m_pfnSendRecvBidiData (NULL),
    m_pfnRouterFreeBidiResponseContainer (NULL)


{
    HMODULE hModule = NULL;

    InterlockedIncrement(&g_cComponents) ;

    if (m_CritSec.bValid ()) {

        hModule = GetModuleHandle (_T ("winspool.drv"));

        if (hModule) {

            m_pfnSendRecvBidiData = (PFN_SENDRECVBIDIDATA) GetProcAddress (
                hModule, MAKEINTRESOURCEA (222));

            m_pfnRouterFreeBidiResponseContainer = (PFN_ROUTERFREEBIDIRESPONSECONTAINER) GetProcAddress (
                hModule, MAKEINTRESOURCEA (223));

            if (m_pfnSendRecvBidiData && m_pfnRouterFreeBidiResponseContainer) {
                m_bValid = TRUE;
            }
        }
    }

    DBGMSG(DBG_TRACE,("TBidiSpl Created\n"));
}

TBidiSpl::~TBidiSpl()
{
    UnbindDevice ();
    InterlockedDecrement(&g_cComponents) ;

    DBGMSG(DBG_TRACE,("TBidiSpl Dstroy self\n"));
}


STDMETHODIMP
TBidiSpl::QueryInterface (
    REFIID iid,
    void** ppv)
{
    HRESULT hr = S_OK;

    DBGMSG(DBG_TRACE,("Enter TBidiSpl QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IBidiSpl*>(this) ;
	}
    else if (iid == IID_IBidiSpl) {

		*ppv = static_cast<IBidiSpl*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}

    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }

    DBGMSG(DBG_TRACE,("Leave TBidiSpl QI hr=%x\n", hr));
	return hr ;

}

STDMETHODIMP_ (ULONG)
TBidiSpl::AddRef ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiSpl::AddRef ref= %d\n", m_cRef));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiSpl::Release ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiSpl::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;

}


STDMETHODIMP
TBidiSpl::BindDevice (
    IN  CONST   LPCWSTR pszDeviceName,
    IN  CONST   DWORD dwAccess)
{
    HRESULT hr (E_FAIL);

    HANDLE hPrinter = NULL;
    HANDLE hOldPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefault = {NULL, NULL, 0};

    BOOL bRet;

    if (m_bValid) {

        if (pszDeviceName) {

            if (dwAccess == BIDI_ACCESS_ADMINISTRATOR ) {
                PrinterDefault.DesiredAccess = PRINTER_ALL_ACCESS;
            }
            else if (dwAccess == BIDI_ACCESS_USER) {
                PrinterDefault.DesiredAccess = PRINTER_ACCESS_USE;
            }
            else {
                hr = E_INVALIDARG;
            }

            if (hr != E_INVALIDARG) {

                bRet = OpenPrinter ((LPWSTR)pszDeviceName, &hPrinter, &PrinterDefault);

                if (bRet) {

                    TAutoCriticalSection CritSec (m_CritSec);

                    bRet = CritSec.bValid ();
                    if (bRet) {
                        if (m_hPrinter != NULL) {
                            // Opened before

                            // Do not cache the handle, since the calling thread may
                            // impersonate different user credentials
                            //

                            hOldPrinter = m_hPrinter;
                        }

                        m_hPrinter = hPrinter;
                        hPrinter = NULL;
                        hr = S_OK;
                    }
                }

                if (hOldPrinter) {
                    ClosePrinter (hOldPrinter);
                }

                if (hPrinter) {
                    ClosePrinter (hPrinter);
                }

                if (FAILED (hr)) {
                    hr = LastError2HRESULT ();
                }
            }
        }
        else
            hr = E_INVALIDARG;
    }
    else
        hr = E_HANDLE;

    return hr;
}

STDMETHODIMP
TBidiSpl::UnbindDevice ()
{
    HRESULT hr;
    BOOL bRet;
    HANDLE hPrinter = NULL;

    if (m_bValid) {

        {
            TAutoCriticalSection CritSec (m_CritSec);

            bRet = CritSec.bValid ();

            if (bRet) {

                if (hPrinter = m_hPrinter) {
                    m_hPrinter = NULL;
                }
                else {
                    // Nothing to unbind
                    bRet = FALSE;
                    SetLastError (ERROR_INVALID_HANDLE_STATE);
                }
            }
        }
        // Leave Critical Section

        if (hPrinter) {
            bRet = ClosePrinter (hPrinter);
        }

        if (bRet) {
            hr = S_OK;
        }
        else {
            hr = LastError2HRESULT();
        }
    }
    else
        hr = E_HANDLE;

    return hr;

}

STDMETHODIMP
TBidiSpl::SendRecv (
    IN CONST    LPCWSTR pszAction,
    IN          IBidiRequest * pRequest)
{
    IBidiRequestContainer * pIReqContainer = NULL ;
    HRESULT hr;

    hr = ValidateContext();
    if (FAILED (hr)) goto Failed;

    if (!pRequest) {
        hr = E_POINTER;
        goto Failed;
    }

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IBidiRequestContainer,
                                   (void**)&pIReqContainer) ;
    if (FAILED (hr))  goto Failed;

    hr = pIReqContainer->AddRequest (pRequest);
    if (FAILED (hr))  goto Failed;

    hr = MultiSendRecv (pszAction, pIReqContainer);
    if (FAILED (hr))  goto Failed;

Failed:

    if (pIReqContainer) {
        pIReqContainer->Release ();
    }

    return hr;

}

STDMETHODIMP
TBidiSpl::MultiSendRecv (
    IN CONST    LPCWSTR pszAction,
    IN          IBidiRequestContainer * pRequestContainer)
{

    DWORD                           dwTotal;
    DWORD                           dwRet;
    IBidiRequestContainer *         pIReqContainer = NULL;
    PBIDI_RESPONSE_CONTAINER        pResponse = NULL;
    TRequestContainer *             pReqContainer = NULL;

    HRESULT hr;


    hr = ValidateContext();
    if (FAILED (hr)) goto Failed;

    if (!pRequestContainer) {
        hr = E_POINTER;
        goto Failed;
    }


    hr = pRequestContainer->QueryInterface (
                    IID_IBidiRequestContainer,
                    (void **) & pIReqContainer);
    if (FAILED (hr)) goto Failed;

    hr = pIReqContainer->GetRequestCount (&dwTotal);
    if (FAILED (hr)) goto Failed;

    if (dwTotal == 0 && lstrcmpi (BIDI_ACTION_ENUM_SCHEMA, pszAction)) {
        // There is no request in the container
        //
        hr = E_INVALIDARG;
        DBGMSG (DBG_INFO, ("No request in an action"));
        goto Failed;
    }

    hr = ComposeRequestData (pRequestContainer, &pReqContainer);
    if (FAILED (hr)) goto Failed;

    dwRet = (*m_pfnSendRecvBidiData) (m_hPrinter,
                                      pszAction,
                                      pReqContainer->GetContainerPointer (),
                                      &pResponse);

    if (!dwRet && pResponse) {
        hr = ComposeReponseData (
                        pIReqContainer,
                        (PBIDI_RESPONSE_CONTAINER) pResponse);

        (*m_pfnRouterFreeBidiResponseContainer) (pResponse);
    }
    else
        hr = WinError2HRESULT (dwRet);

Failed:

    if (pReqContainer)
        delete pReqContainer;

    if (pIReqContainer)
        pIReqContainer ->Release ();

    return hr;
}


HRESULT
TBidiSpl::ValidateContext ()
{
    BOOL bRet;
    HRESULT hr;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        bRet = CritSec.bValid ();
        if (bRet) {
            if (m_hPrinter == NULL) {
                // The application has not called BindDevice yet.
                hr =  E_HANDLE;
            }
            else
                hr = S_OK;
        }
        else
            hr = LastError2HRESULT ();
    }
    else
        hr = E_HANDLE;

    return hr;
}

HRESULT
TBidiSpl::ComposeRequestData (
    IN  IBidiRequestContainer *pIReqContainer,
    IN  TRequestContainer **ppReqContainer)
{


    DWORD   dwFetched;
    DWORD   dwSize;
    DWORD   dwTotal;
    DWORD   dwType;
    DWORD   i;
    LPWSTR  pszSchema;
    PBYTE   pData = NULL;

    IBidiRequestSpl   *     pISpl = NULL;
    IEnumUnknown      *     pEnumIunk = NULL;
    IUnknown          *     pIunk = NULL;
    TRequestContainer *     pReqContainer = NULL;

    BOOL bRet;
    HRESULT hr;

    *ppReqContainer = NULL;

    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;
    if (FAILED (hr)) goto Failed;

    hr = pIReqContainer->GetRequestCount (&dwTotal) ;
    if (FAILED (hr)) goto Failed;

    pReqContainer = new TRequestContainer (dwTotal);
    *ppReqContainer = pReqContainer;

    if (! (pReqContainer && pReqContainer->bValid ())) {
        hr = LastError2HRESULT();
        goto Failed;
    }

    for (i = 0; i < dwTotal; i++){

        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        if (FAILED (hr)) goto Failed;

        if (dwFetched != 1) {
            hr = E_INVALIDARG;
            goto Failed;
        }

        hr = pIunk->QueryInterface (IID_IBidiRequestSpl, (void **) & pISpl);
        if (FAILED (hr)) goto Failed;

        pIunk->Release ();
        pIunk = NULL;

        // Create the request
        hr = pISpl->GetSchema (&pszSchema);
        if (FAILED (hr)) goto Failed;

        hr = pISpl->GetInputData (&dwType, &pData, &dwSize);
        if (FAILED (hr)) goto Failed;

        bRet = pReqContainer->AddRequest (i, pszSchema, (BIDI_TYPE) dwType, pData, dwSize);

        if (!bRet) {
            hr = LastError2HRESULT();
            goto Failed;
        }

        pISpl->Release ();
        pISpl = NULL;

    }
    hr = S_OK;

Failed:

    if (pISpl)
        pISpl->Release ();

    if (pEnumIunk)
        pEnumIunk->Release ();

    if (pIunk)
        pIunk->Release();

    return hr;
}

HRESULT
TBidiSpl::SetData (
    IN  IBidiRequestSpl *pISpl,
    IN  PBIDI_RESPONSE_DATA pResponseData)
{
    HRESULT hr;

    hr = pISpl->SetResult (pResponseData->dwResult);

    if (!SUCCEEDED (hr)) {
        return hr;
    }

    PBIDI_DATA pData = & (pResponseData->data);

    switch (pData->dwBidiType) {
    case BIDI_NULL:
        break;
    case BIDI_INT:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      (PBYTE) & pData->u.iData,
                                      sizeof (ULONG));
        break;
    case BIDI_BOOL:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      (PBYTE) & pData->u.bData,
                                      sizeof (BOOL));
        break;
    case BIDI_FLOAT:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      (PBYTE) & pData->u.fData,
                                      sizeof (FLOAT));
        break;
    case BIDI_TEXT:
    case BIDI_ENUM:
    case BIDI_STRING:

        if (pData->u.sData)
        {
            hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                          pData->dwBidiType,
                                          (PBYTE) pData->u.sData,
                                          sizeof (WCHAR) * (lstrlen (pData->u.sData) + 1));
        }
        else
        {
            hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                          pData->dwBidiType,
                                          NULL, 
                                          0);
        }

        break;
    case BIDI_BLOB:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      pData->u.biData.pData,
                                      pData->u.biData.cbBuf);
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;

}



HRESULT
TBidiSpl::ComposeReponseData (
    IN  IBidiRequestContainer *pIReqContainer,
    IN  PBIDI_RESPONSE_CONTAINER pResponse)
{

    HRESULT hr;
    IEnumUnknown* pEnumIunk = NULL;

    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    if (SUCCEEDED (hr)) {

        hr = pEnumIunk->Reset ();

        if (SUCCEEDED (hr)) {

            DWORD dwReqIndex = 0;
            BOOL bGotInterface = FALSE;;


            for (DWORD i = 0; i < pResponse->Count; i++) {

                PBIDI_RESPONSE_DATA pResponseData = & (pResponse->aData[i]);

                // Locate the request
                if (dwReqIndex <= pResponse->aData[i].dwReqNumber) {
                    hr = pEnumIunk->Skip (pResponse->aData[i].dwReqNumber - dwReqIndex);
                    dwReqIndex = pResponse->aData[i].dwReqNumber;

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    bGotInterface = FALSE;

                }
                else if (dwReqIndex > pResponse->aData[i].dwReqNumber) {
                    hr = pEnumIunk->Reset ();

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    hr = pEnumIunk->Skip (pResponse->aData[i].dwReqNumber);
                    dwReqIndex = pResponse->aData[i].dwReqNumber;

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    bGotInterface = FALSE;
                }

                IUnknown *pIunk = NULL;

                if (!bGotInterface) {
                    DWORD dwFetched;

                    hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);
                    dwReqIndex++;

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    if (dwFetched != 1) {
                        hr = E_INVALIDARG;
                        goto Failed;
                    }

                    bGotInterface = TRUE;
                }

                IBidiRequestSpl *pISpl;

                hr = pIunk->QueryInterface (IID_IBidiRequestSpl,
                                                   (void **) & pISpl);
                pIunk->Release();

                if (SUCCEEDED (hr)) {
                    hr = SetData (pISpl, pResponseData);
                    pISpl->Release ();
                }
            }
        }
    }

Failed:

    if (pEnumIunk)
        pEnumIunk->Release ();

    return hr;
}

TBidiSpl::TRequestContainer::TRequestContainer (
    DWORD dwCount):
    m_bValid (FALSE)
{
    DWORD dwSize = sizeof (BIDI_REQUEST_CONTAINER) + (dwCount - 1) * sizeof (BIDI_REQUEST_DATA);
    m_pContainer = (PBIDI_REQUEST_CONTAINER) new BYTE [dwSize];

    if (m_pContainer) {

        ZeroMemory (m_pContainer, dwSize);

        m_pContainer->Version = 1;
        m_pContainer->Count = dwCount;
        m_bValid = TRUE;
    }
}

TBidiSpl::TRequestContainer::~TRequestContainer ()
{
    if (m_pContainer) {
        PBIDI_DATA pBidiData;


        for (DWORD i = 0; i < m_pContainer->Count; i++) {

            pBidiData = & (m_pContainer->aData[i].data);

            switch (pBidiData->dwBidiType) {
            case BIDI_STRING:
            case BIDI_TEXT:
            case BIDI_ENUM:
                if (pBidiData->u.sData)
                    CoTaskMemFree (pBidiData->u.sData);
                break;
            case BIDI_BLOB:
                if (pBidiData->u.biData.pData) {
                    CoTaskMemFree (pBidiData->u.biData.pData);
                }
                break;
            default:
                break;
            }
        }

        delete [] m_pContainer;
    }
}

BOOL
TBidiSpl::TRequestContainer::AddRequest (
    IN  CONST   DWORD       dwIndex,
    IN  CONST   LPCWSTR     pszSchema,
    IN  CONST   BIDI_TYPE   dwDataType,
    IN          PBYTE       pData,
    IN  CONST   DWORD       dwSize)
{
    BOOL bRet (FALSE);
    BOOL bFreeData;

    if (m_pContainer) {
        PBIDI_DATA pBidiData;
        bFreeData = TRUE;

        m_pContainer->aData[dwIndex].dwReqNumber = dwIndex;
        m_pContainer->aData[dwIndex].pSchema = (LPWSTR) pszSchema;
        m_pContainer->aData[dwIndex].data.dwBidiType = dwDataType;
        pBidiData = & (m_pContainer->aData[dwIndex].data);

        switch (pBidiData->dwBidiType) {
        case BIDI_NULL:
            bRet = TRUE;
            break;

        case BIDI_BOOL:
            bRet = dwSize == BIDI_BOOL_SIZE;

            if(bRet) {
                pBidiData->u.iData = *(PBOOL)pData;
            }

            break;

        case BIDI_INT:
            bRet = dwSize == BIDI_INT_SIZE;

            if (bRet) {
                pBidiData->u.iData = *(PINT)pData;
               bRet = TRUE;
            }
            break;

        case BIDI_FLOAT:

            bRet = dwSize == BIDI_FLOAT_SIZE;

            if (bRet) {
                pBidiData->u.iData = *(PINT)pData;
            }
            break;

        case BIDI_STRING:
        case BIDI_TEXT:
        case BIDI_ENUM:
            pBidiData->u.sData =  (LPWSTR) pData;
            bFreeData = FALSE;
            bRet = TRUE;
            break;

        case BIDI_BLOB:
            pBidiData->u.biData.pData = pData;
            pBidiData->u.biData.cbBuf = dwSize;
            bFreeData = FALSE;
            bRet = TRUE;
            break;

        default:
            bRet = FALSE;
        }

        if (pData && bFreeData) {
            CoTaskMemFree (pData);
        }
    }

    if (!bRet) {
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\respdata.h ===
#ifndef _TRESPONSEDATA
#define _TRESPONSEDATA

class TResponseData
{
public:

    TResponseData (
        IN  CONST LPCWSTR   pszSchema,
        IN  CONST DWORD     dwType,
        IN  CONST BYTE      *pData,
        IN  CONST ULONG     uSize);

    virtual ~TResponseData ();

    inline BOOL 
    bValid () CONST {return m_bValid;};

    inline LPCWSTR 
    GetSchema (VOID) CONST {return m_pSchema;};

    inline PBYTE 
    GetData (VOID) CONST {return m_pData;};

    inline DWORD 
    GetType (VOID) CONST {return m_dwType;};

    inline ULONG 
    GetSize (VOID) CONST {return m_uSize;};


private:

    BOOL m_bValid;
    LPWSTR m_pSchema;
    DWORD m_dwType;
    PBYTE m_pData;
    ULONG m_uSize;

};

typedef TDoubleList<TResponseData *, DWORD> TResponseDataList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\clients\stress\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>
#include "wingdip.h"

#include <wininet.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\clients\stress\biditest.cpp ===
//
// Client.cpp - client implementation
//
#include "precomp.h"
#include "bidispl.h"

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#ifndef MODULE

#define MODULE "BIDITEST:"

#endif

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

#endif

VOID DbgBreakPoint (VOID)
{
}


DWORD gdwCount;
IBidiRequest ** gpIRequestArray;
DWORD gdwContainerCount;
IBidiRequestContainer ** gpIRequestContainerArray;
DWORD gdwSplCount;
IBidiSpl ** gpIBidiSplArray;
DWORD gdwMainLoopCount;
DWORD gdwLoopCount;
LPWSTR gpPrinterName;
LONG gdwRef;
HANDLE ghEvent;

VOID
CreateRequest (DWORD dwCount)
{
    HRESULT hr;

	IBidiRequest * pIReq = NULL ;
    typedef IBidiRequest * PIBidiRequest;

    gdwCount = dwCount;
    gpIRequestArray = new PIBidiRequest[gdwCount];
	
    for (DWORD i  = 0; i < gdwCount; i++) {
        hr = ::CoCreateInstance(CLSID_BidiRequest,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IBidiRequest,
                                (void**)&pIReq) ;
       gpIRequestArray [i] = pIReq;
    }
}


VOID
ReleaseRequest ()
{
    for (DWORD i  = 0; i < gdwCount; i++) {
       DWORD dwRef = gpIRequestArray [i]->Release ();

       SPLASSERT (dwRef == 0);
       if (dwRef != 0) {
           printf("ReleaseRequest: Ref count not zero!\n");
       }
    }

}

VOID
CreateContainer (DWORD dwContainerCount)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
    typedef IBidiRequestContainer * PIBidiRequestContainer;

    gdwContainerCount = dwContainerCount;
    gpIRequestContainerArray = new PIBidiRequestContainer[dwContainerCount];
	
    for (DWORD i  = 0; i < dwContainerCount; i++) {

        hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IBidiRequestContainer,
                                (void**)&pIReqContainer) ;

        gpIRequestContainerArray [i] = pIReqContainer;
    }
}

VOID
ReleaseContainer ()
{
    for (DWORD i = 0; i < gdwContainerCount; i++) {
       DWORD dwRef = gpIRequestContainerArray [i]->Release ();

       SPLASSERT (dwRef == 0);
       if (dwRef != 0) {
           printf("ReleaseRequest: Ref count not zero!\n");
       }
    }

}


VOID
CreateSpl (DWORD dwCount)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    typedef IBidiSpl * PIBidiSpl;

    gdwSplCount = dwCount;
    gpIBidiSplArray = new PIBidiSpl[dwCount];
	
    for (DWORD i  = 0; i < dwCount; i++) {

        hr = ::CoCreateInstance(CLSID_BidiSpl,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IBidiSpl,
                                (void**)&pIBidiSpl) ;
        gpIBidiSplArray[i] = pIBidiSpl;
    }
}

VOID
ReleaseSpl ()
{
    for (DWORD i  = 0; i < gdwSplCount; i++) {

       DWORD dwRef = gpIBidiSplArray [i]->Release ();

       SPLASSERT (dwRef == 0);
       if (dwRef != 0) {
           printf("ReleaseRequest: Ref count not zero!\n");
       }
    }
}




VOID
FillInRequest (DWORD dwIndex)
{
  	IBidiRequest * pIReq = gpIRequestArray[dwIndex];
    DWORD dwValidSize;
    HRESULT hr;
    BIDI_TYPE dwBidiType;

#define BIDI_SCHEMA_DUPLEX          L"/Printer/Installableoption/Duplexunit"
#define BIDI_SCHEMA_MULTICHANNEL    L"/Capability/MultiChannel"
#define BIDI_SCHEMA_VERSION         L"/Communication/Version"
#define BIDI_SCHEMA_BIDIPROTOCOL    L"/Communication/BidiProtocol"
#define BIDI_SCHEMA_INK_LEVEL       L"/Printer/BlackInk1/Level"
#define BIDI_SCHEMA_ALERTS          L"/Printer/Alerts"

    static PWSTR pSchemaArray[] = {
         BIDI_SCHEMA_DUPLEX,
         BIDI_SCHEMA_MULTICHANNEL,
         BIDI_SCHEMA_VERSION,
         BIDI_SCHEMA_BIDIPROTOCOL,
         BIDI_SCHEMA_INK_LEVEL,
         BIDI_SCHEMA_ALERTS
    };

    if (pIReq) {

        hr = pIReq->SetSchema (pSchemaArray[rand() %( sizeof (pSchemaArray) / sizeof (pSchemaArray[0]))]);

        dwBidiType = (BIDI_TYPE) (rand() % 7);
        switch (dwBidiType) {
        case BIDI_NULL:
            dwValidSize = 0;
            break;
        case BIDI_INT:
            dwValidSize = sizeof (INT);
            break;
        case BIDI_FLOAT:
            dwValidSize = sizeof (FLOAT);
            break;
        case BIDI_BOOL:
            dwValidSize = sizeof (BOOL);
            break;
        default:
            dwValidSize = rand () %(1024*1024);
            break;
        }

        PBYTE pByte = new BYTE [dwValidSize];

        hr = pIReq->SetInputData (dwBidiType, pByte, dwValidSize);
	}
}

VOID
FillInContainer (DWORD dwIndex)
{
    IBidiRequestContainer * pIReqContainer = gpIRequestContainerArray[dwIndex];

    if (pIReqContainer) {

        DWORD dwRequestCount = rand () % gdwCount;
        for (DWORD i = 0; i < dwRequestCount; i++) {
            HRESULT hr = pIReqContainer->AddRequest (gpIRequestArray[i]);
        }
    }
}



VOID
AccessRequest (IBidiRequest *pIRequest)
{
    DWORD dwTotoal, i;
    HRESULT hr, hResult;
    LPWSTR pszSchema = NULL;
    BYTE *pData = NULL;
    DWORD uSize;
    DWORD dwType;
    DWORD dwTotal;

    if (pIRequest) {
        hr = pIRequest->GetResult (&hResult);
        hr = pIRequest->GetEnumCount (&dwTotal);

        for (i = 0; i < dwTotal; i++) {
            hr =  pIRequest->GetOutputData  (i, &pszSchema, &dwType, &pData, &uSize);

            if (pszSchema) {
                CoTaskMemFree (pszSchema);
            }

            if (pData) {
                CoTaskMemFree (pData);
            }
        }
    }
}

VOID
AccessRequest (DWORD dwIndex)
{
    IBidiRequest *pIRequest =  gpIRequestArray[dwIndex];

    AccessRequest (pIRequest);

}

VOID
AccessContainer (IBidiRequestContainer * pIReqContainer)
{
    DWORD dwTotal;

    DBGMSG (DBG_TRACE, ("Enter AccessContainer\n"));

    if (pIReqContainer) {

        HRESULT hr = pIReqContainer->GetRequestCount (&dwTotal);

        if (dwTotal > 0) {
            IEnumUnknown *pEnumIunk;
            IEnumUnknown *pEnumIunk2;
            hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

            if (pEnumIunk) {

                IUnknown ** pIunkArray;

                if ((rand()%2) == 1) {
                    hr = pEnumIunk->Reset ();
                }
                else {
                    hr = pEnumIunk->Clone (&pEnumIunk2);
                    pEnumIunk->Release ();
                    pEnumIunk = pEnumIunk2;
                }

                DWORD dwEnumIndex = 0;
                pIunkArray = new IUnknown* [dwTotal];

                while (dwEnumIndex < dwTotal + 2) {

                    IUnknown *pIunk;
                    DWORD dwFetched;

                    DWORD dwEnumCount = rand() % (dwTotal + 1);

                    hr = pEnumIunk->Next (dwEnumCount, pIunkArray, &dwFetched);

                    if (SUCCEEDED (hr)) {

                        for (DWORD i = 0; i < dwFetched; i++) {
                            IBidiRequest *pIRequest = NULL;

                            hr = pIunkArray[i]->QueryInterface (IID_IBidiRequest, (void **) & pIRequest);
                            pIunkArray[i]->Release ();
                            AccessRequest (pIRequest);
                            pIRequest->Release ();

                        }
                        dwEnumIndex +=dwEnumCount;
                    }
                    else
                        break;
                }
                pEnumIunk->Release ();
                delete [] pIunkArray;
            }
        }
    }
    DBGMSG (DBG_TRACE, ("Leave AccessContainer\n"));
}

VOID
AccessContainer (DWORD dwIndex)
{
    IBidiRequestContainer * pIReqContainer = gpIRequestContainerArray[dwIndex];

    AccessContainer (pIReqContainer);

}

VOID
AccessBidiSpl (IBidiSpl * pIBidiSpl, PWSTR pPrinterName, DWORD dwCount)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer *pIReqContainer;

    // Test Open/Close
    //hr = pIBidiSpl->BindDevice (L"No such Printer", 0);

    hr = pIBidiSpl->BindDevice (pPrinterName, BIDI_ACCESS_USER);

    for (DWORD i = 0; i < dwCount; i++) {
        DWORD dwContainerIndex = rand() % gdwContainerCount;

        DBGMSG (DBG_INFO, ("Before MultiSendRecv ... "));
        hr = pIBidiSpl->MultiSendRecv (BIDI_ACTION_GET, gpIRequestContainerArray[dwContainerIndex]);
        DBGMSG (DBG_INFO, ("MultiSendRecv hr=0x%x\n", hr))
        AccessContainer (dwContainerIndex);

    }

    hr = pIBidiSpl->UnbindDevice ();

}


VOID StartTestThread (void)
{
    DWORD i;

    printf("New Thrread ..\n");

    for (DWORD i = 0; i < gdwMainLoopCount; i++) {
        DWORD dwSplIndex = rand () % (gdwSplCount - 1);
        AccessBidiSpl (gpIBidiSplArray[dwSplIndex], gpPrinterName, rand()%gdwLoopCount);
    }

    DWORD dwRef = InterlockedDecrement (&gdwRef);
    if (dwRef == 0) {
        SetEvent (ghEvent);
    }

    printf("Quit Thrread (dwRef = %d)\n", dwRef);
}

VOID
StartTest (DWORD dwThreadCount)
{
    for (DWORD i = 0; i < dwThreadCount; i++) {
        CreateThread (NULL, 16*4096, (LPTHREAD_START_ROUTINE ) StartTestThread, NULL,NULL, NULL);
    }
}

void usage()
{
    printf("\n"
           "usage: biditest [-p pname] [-t n] [-m n] [-l n] [-r n] [-c n] [-s n]\n"
           "\n"
           "where:   -p printer name\n"
           "         -t Thread Number (default = 1) \n"
           "         -m Main loop count (default = 10)\n"
           "         -l Loop count (default = 10)\n"
           "         -r Request count (default = 100)\n"
           "         -c Container count (default = 100)\n"
           "         -s Spooler Bidi  count (default = 10)\n"
           );
    exit (0);
}

extern "C"
INT
_cdecl
_tmain(
    int argc,
    TCHAR **argv)
{
    DWORD dwReqCount = 100;
    DWORD dwContainerCount = 100;
    DWORD dwSplCount = 20;
    DWORD dwMainLoopCount = 10;
    DWORD dwLoopCount = 10;
    WCHAR szName [] = L"Test";
    PWSTR pPrinterName = szName;
    DWORD dwThreadCount = 1;

    HRESULT hr;

    for (--argc, ++argv; argc; --argc, ++argv) {

        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case L'?':
                usage();
                break;

            case L'p':
                ++argv;
                --argc;
                pPrinterName = *argv;
                break;

            case L't':
                ++argv;
                --argc;
                dwThreadCount = _ttol (*argv);
                break;

            case L'm':
                ++argv;
                --argc;
                dwMainLoopCount = _ttol (*argv);
                break;

            case L'l':
                ++argv;
                --argc;
                dwLoopCount = _ttol (*argv);
                break;

            case L'r':
                ++argv;
                --argc;
                dwReqCount = _ttol (*argv);
                break;

            case L'c':
                ++argv;
                --argc;
                dwContainerCount = _ttol (*argv);
                break;

            case L's':
                ++argv;
                --argc;
                dwSplCount = _ttol (*argv);
                break;

            default:
                usage();
                break;
            }
        }
        else {
            printf("Invalid Argument %s\n", *argv);
            exit (1);
        }
    }

    printf("Start Test ..\n");
    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;

    gdwMainLoopCount = dwMainLoopCount;
    gdwLoopCount =  dwLoopCount;
    gpPrinterName =  pPrinterName;
    ghEvent = CreateEvent (NULL, NULL, FALSE, NULL);

    for (;;) {
        printf("Create Components ..\n");
        CreateRequest (dwReqCount);
        CreateContainer ( dwContainerCount);
        CreateSpl (dwSplCount);

        printf("Fill in data ..\n");

        for (DWORD i = 0; i < dwReqCount; i++) {
            FillInRequest (i);
        }

        for (i = 0; i < dwContainerCount; i++) {
            FillInContainer (i);
        }

        printf("Test ..\n");


        gdwRef = dwThreadCount;

        StartTest (dwThreadCount);

        WaitForSingleObject (ghEvent, INFINITE);
        ResetEvent (ghEvent);

        printf("Cleanup ..\n");


        ReleaseSpl();
        ReleaseContainer();
        ReleaseRequest();
    }
	
    CoUninitialize() ;
    printf("Test successfully finished!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\client.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Client.h

Abstract:

    Holds common winspool.drv header info

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <splcom.h>

#ifdef __cplusplus
extern "C" {
#endif

extern HINSTANCE hInst;
extern BOOL bLoadedBySpooler;
extern CRITICAL_SECTION ClientSection;
extern CRITICAL_SECTION  ListAccessSem;
extern LPWSTR InterfaceAddress;
extern LPWSTR szEnvironment;
extern CRITICAL_SECTION ProcessHndlCS;
extern HANDLE hSurrogateProcess;

extern DWORD (*fpYReadPrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
extern DWORD (*fpYSplReadPrinter)(HANDLE, LPBYTE *, DWORD, BOOL);
extern DWORD (*fpYWritePrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
extern DWORD (*fpYSeekPrinter)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD, BOOL, BOOL);
extern DWORD (*fpYGetPrinterDriver2)(HANDLE, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, DWORD, DWORD, PDWORD, PDWORD, BOOL);
extern DWORD (*fpYGetPrinterDriverDirectory)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, BOOL);
extern VOID  (*fpYDriverUnloadComplete)(LPWSTR);
extern DWORD (*fpYFlushPrinter)(HANDLE,LPVOID,DWORD,LPDWORD,DWORD,BOOL);
extern DWORD (*fpYEndDocPrinter)(HANDLE,BOOL);
extern DWORD (*fpYSetPort)(LPWSTR, LPWSTR, LPPORT_CONTAINER, BOOL);
extern DWORD (*fpYSetJob)(HANDLE, DWORD, LPJOB_CONTAINER, DWORD, BOOL);

#define vEnterSem() EnterCriticalSection(&ClientSection)
#define vLeaveSem() LeaveCriticalSection(&ClientSection)

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;

typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
    BOOL     bHandleInvalid;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    HANDLE      hFile;
    DWORD       JobId;
    LPBYTE      pBuffer;
    DWORD       cbBuffer;
    DWORD       Status;
    DWORD       fdwFlags;
    DWORD       cCacheWrite;
    DWORD       cWritePrinters;
    DWORD       cFlushBuffers;
    DWORD       dwTickCount;
    DWORD       dwCheckJobInterval;
    PNOTIFY     pNotify;
    LPTSTR      pszPrinter;
    PRINTER_DEFAULTS Default;
    HANDLE      hSplPrinter;
    DWORD       cActive;
    HANDLE      hSpoolFile;
    DWORD       dwSpoolFileAttributes;
    DWORD       cbFlushPending;
    DWORD       cOKFlushBuffers;
    DWORD       Flushed;
    PDOCEVENT_FILTER    pDoceventFilter;
#ifdef DBG_TRACE_HANDLE
    PSPOOL      pNext;
    PVOID       apvBackTrace[32];
#endif
} SPOOL;

#define WIN2000_SPOOLER_VERSION 3

// cActive: There is a non-close call currently active on the handle.
//     Any ClosePrinter call should just mark SPOOL_STATUS_PENDING_DELETION
//     so that the handle will be closed when the other thread is one.


#define BUFFER_SIZE 0x10000
#define SP_SIGNATURE    0x6767

#define SPOOL_STATUS_STARTDOC              0x00000001
#define SPOOL_STATUS_ADDJOB                0x00000002
#define SPOOL_STATUS_ANSI                  0x00000004
#define SPOOL_STATUS_DOCUMENTEVENT_ENABLED 0x00000008
#define SPOOL_STATUS_TRAYICON_NOTIFIED     0x00000010
#define SPOOL_STATUS_NO_COLORPROFILE_HOOK  0x00000020

//
// CLOSE: There is a close call occuring.  Everything else should fail.
// PENDING_DELETION: The handle should be closed as soon as any call completes.
//    This occurs when ClosePrinter is called but another thread is executing
//    a non-close call.  In this case, the ClosePrinter doesn't do anything;
//    it just marks PENDING_DELETION and returns.
//
#define SPOOL_STATUS_CLOSE                 0x00000040
#define SPOOL_STATUS_PENDING_DELETION      0x00000080

#define SPOOL_STATUS_DONT_RECYCLE_HANDLE   0x00000100

#define MAX_STATIC_ALLOC     1024

#define SPOOL_FLAG_FFPCN_FAILED     0x1
#define SPOOL_FLAG_LAZY_CLOSE       0x2

#define NULL_TERMINATED 0


//
// This is the resource id that is used to locate the activation context
// for an image that has funsion version information.
//
#define ACTIVATION_CONTEXT_RESOURCE_ID  123

//
// SPOOL_FILE_INFO_1 trades handles in what amount to a 32 bit interface. The
// central assumption here is that kernel mode handles are 32 bit values (i.e.
// an offset into a table.) This isn't great, but since a 64 bit spooler will
// communicate with a 32 bit client GDI, this assumption is implicite anyway.
//
#define SPOOL_INVALID_HANDLE_VALUE_32BIT        ((HANDLE)(ULONG_PTR)0xffffffff)

// Struct for storing loaded driver config file handles
typedef  struct _DRVLIBNODE {
    struct _DRVLIBNODE   *pNext;
    LPWSTR    pConfigFile;
    DWORD     dwNumHandles;
    HANDLE    hLib;
    DWORD     dwVersion;
    BOOL      bArtificialIncrement;
} DRVLIBNODE, *PDRVLIBNODE;

//
// Struct for DocumentProperties UI monitoring
//
typedef struct _PUMPTHRDDATA
{
    ULONG_PTR  hWnd;
    LPWSTR     PrinterName;
    PDWORD     TouchedDevModeSize;
    PDWORD     ClonedDevModeOutSize;
    byte**     ClonedDevModeOut;
    DWORD      DevModeInSize;
    byte*      pDevModeInput;
    DWORD      fMode;
    DWORD      fExclusionFlags;
    PDWORD     dwRet;
    PLONG      Result;
    BOOL       ClonedDevModeFill;
} PumpThrdData;

typedef struct _PRTPROPSDATA
{
     ULONG_PTR  hWnd;
     PDWORD     dwRet;
     LPWSTR     PrinterName;
     DWORD      Flag;
} PrtPropsData;

typedef struct _PRINTERSETUPDATA
{
    ULONG_PTR hWnd;
    UINT      uAction;
    UINT      cchPrinterName;
    UINT      PrinterNameSize;
    LPWSTR    pszPrinterName;
    UINT      *pcchPrinterName;
    LPCWSTR   pszServerName;
}PrinterSetupData;

typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;

typedef enum {
    kProtectHandleSuccess = 0,
    kProtectHandleInvalid = 1,
    kProtectHandlePendingDeletion = 2
} EProtectResult;

typedef enum{
    RUN32BINVER = 4,
    RUN64BINVER = 8
}ClientVersion;

typedef enum{
    NATIVEVERSION = 0,
    THUNKVERSION  = 1
}ServerVersion;

struct SJOBCANCELINFO 
{ 
    PSPOOL pSpool;
    LPBYTE pInitialBuf;
    PDWORD pcbWritten;
    PDWORD pcTotalWritten;
    DWORD  NumOfCmpltWrts;
    DWORD  cbFlushed;
    DWORD  ReqTotalDataSize;
    DWORD  FlushPendingDataSize;
    DWORD  ReqToWriteDataSize;
    BOOL   ReturnValue;
};
typedef struct SJOBCANCELINFO SJobCancelInfo, *PSJobCancelInfo;

//
// The list used to maintain created windows waiting on
// end messages from the surrogate process
//
struct WNDHNDLNODE
{
    struct WNDHNDLNODE *PrevNode;
    struct WNDHNDLNODE *NextNode;
    HWND   hWnd;
};
typedef struct WNDHNDLNODE WndHndlNode,*LPWndHndlNode;

struct WNDHNDLLIST
{
    struct WNDHNDLNODE *Head;
    struct WNDHNDLNODE *Tail;
    DWORD  NumOfHndls;
};
typedef struct WNDHNDLLIST WndHndlList,*LPWndHndlList;

struct MONITORINGTHRDDATA
{
    HANDLE* hProcess;
    HANDLE  hEvent;
};
typedef struct MONITORINGTHRDDATA MonitorThrdData,*LPMonitorThrdData;

typedef struct _MONITORUIDATA
{
    HINSTANCE   hLibrary;
    HANDLE      hActCtx;
    ULONG_PTR   lActCtx;
    PWSTR       pszMonitorName;
    BOOL        bDidActivate;
} MONITORUIDATA, *PMONITORUIDATA;

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
    );

BOOL
WPCInit(
    VOID
    );

VOID
WPCDone(
    VOID
    );

PNOTIFY
WPCWaitFind(
    HANDLE hFind
    );

BOOL
FlushBuffer(
    PSPOOL  pSpool,
    PDWORD pcbWritten
    );

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
    );

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
    );

LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    );

LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
    );

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
    );

LPWSTR
StartDocDlgW(
    HANDLE hPrinter,
    DOCINFO *pDocInfo
    );

LPSTR
StartDocDlgA(
    HANDLE hPrinter,
    DOCINFOA *pDocInfo
    );

HANDLE
LoadPrinterDriver(
    HANDLE  hPrinter
    );

HANDLE
RefCntLoadDriver(
    LPTSTR  pConfigFile,
    DWORD   dwFlags,
    DWORD   dwVersion,
    BOOL    bUseVersion
    );

BOOL
RefCntUnloadDriver(
    HANDLE  hLib,
    BOOL    bNotifySpooler
    );

BOOL
ForceUnloadDriver(
    LPTSTR  pConfigFile
    );

BOOL
WriteCurDevModeToRegistry(
    LPWSTR      pPrinterName,
    LPDEVMODEW  pDevMode
    );

BOOL
DeleteCurDevModeFromRegistry(
    PWSTR pPrinterName
);

BOOL
bValidDevModeW(
    const DEVMODEW *pDevModeW
    );

BOOL
bValidDevModeA(
    const DEVMODEA *pDevModeA
    );

DWORD
FindClosePrinterChangeNotificationWorker(
    IN  PNOTIFY     pNotify,
    IN  HANDLE      hPrinterRPC,
    IN  BOOL        bRevalidate
    );

BOOL
ScheduleJobWorker(
    PSPOOL pSpool,
    DWORD  JobId
    );

PSPOOL
AllocSpool(
    VOID
    );

VOID
FreeSpool(
    PSPOOL pSpool
    );

VOID
CloseSpoolFileHandles(
    PSPOOL pSpool
    );

EProtectResult
eProtectHandle(
    IN HANDLE hPrinter,
    IN BOOL bClose
    );

VOID
vUnprotectHandle(
    IN HANDLE hPrinter
    );

BOOL
UpdatePrinterDefaults(
    IN OUT PSPOOL pSpool,
    IN     LPCTSTR pszPrinter,  OPTIONAL
    IN     PPRINTER_DEFAULTS pDefault OPTIONAL
    );

BOOL
RevalidateHandle(
    PSPOOL pSpool
    );

BOOL
UpdateString(
    IN     LPCTSTR pszString,  OPTIONAL
       OUT LPTSTR* ppszOut
    );

INT
Message(
    HWND    hwnd,
    DWORD   Type,
    INT     CaptionID,
    INT     TextID,
    ...
    );

DWORD
ReportFailure(
    HWND  hwndParent,
    DWORD idTitle,
    DWORD idDefaultError
    );

BOOL
InCSRProcess(
    VOID
    );

INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR  pAnsi,
    DWORD  StringLength
    );

BOOL
RunInWOW64(
    VOID
    );

DWORD
AddHandleToList(
    HWND hWnd
    );

BOOL
DelHandleFromList(
    HWND hWnd
    );

HRESULT
GetCurrentThreadLastPopup(
    OUT HWND    *phwnd
    );

LPCWSTR
FindFileName(
    IN      LPCWSTR pPathName
    );

VOID
ReleaseAndCleanupWndList(
    VOID
    );

LONG_PTR
DocumentPropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    );

LONG_PTR
DevicePropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    );

VOID
vUpdateTrayIcon(
    IN HANDLE hPrinter,
    IN DWORD JobId
    );

HRESULT
SelectFormNameFromDevMode(
    HANDLE      hPrinter,
    PDEVMODEW   pDevModeW,
    LPWSTR      pFormName,
    ULONG       cchBuffer
    );

LPWSTR
IsaFileName(
    LPWSTR pOutputFile,
    LPWSTR FullPathName,
    DWORD  cchFullPathName
    );

PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
    );

DWORD
GetMonitorUI(
    IN PCWSTR           pszMachineName,
    IN PCWSTR           pszObjectName,
    IN PCWSTR           pszObjectType,
    OUT PMONITORUI      *ppMonitorUI,
    OUT PMONITORUIDATA  *ppMonitorUIData
    );

HRESULT
CreateMonitorUIData(
    OUT MONITORUIDATA **ppMonitorUIData
    );

VOID
FreeMonitorUI(
    IN PMONITORUIDATA   pMonitorUIData
    );

HRESULT
GetMonitorUIActivationContext(
    IN PCWSTR           pszMonitorName,
    IN PMONITORUIDATA   pMonitorUIData
    );

HRESULT
GetMonitorUIFullName(
    IN PCWSTR   pszMonitorName,
    IN PWSTR    *ppszMonitorName
    );

DWORD
ConnectToLd64In32ServerWorker(
    HANDLE *hProcess,
    BOOL   bThread
    );

DWORD
ConnectToLd64In32Server(
    HANDLE *hProcess,
    BOOL   bThread
    );

DWORD
ExternalConnectToLd64In32Server(
    HANDLE *hProcess
    );

DWORD
GetMonitorUIDll(
    PCWSTR      pszMachineName,
    PCWSTR      pszObjectName,
    PCWSTR      pszObjectType,
    PWSTR       *pMonitorUIDll
    );

HWND
GetForeGroundWindow(
    VOID
    );

BOOL
JobCanceled(
    PSJobCancelInfo
    );

BOOL
BuildSpoolerObjectPath(
    IN  PCWSTR  pszPath,
    IN  PCWSTR  pszName,
    IN  PCWSTR  pszEnvironment, 
    IN  DWORD   Level, 
    IN  PBYTE   pDriverDirectory, 
    IN  DWORD   cbBuf, 
    IN  PDWORD  pcbNeeded
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\clients\test\client.cpp ===
//
// Client.cpp - client implementation
//
#include "precomp.h"

#include "bidispl.h"
#include "bidisplp.h"

#ifndef MODULE

#define MODULE "BIDITST:"

#endif

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE, DBG_ERROR );

#endif

VOID DbgBreakPoint (VOID)
{
}

void DumpData (DWORD dwType, PBYTE pData, DWORD dwSize)
{

    DBGMSG (DBG_INFO, ("dwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize)) ;

    DWORD col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    for (DWORD i = 0; i < dwSize; i++) {

        sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
        if ((col ++) % 16 == 15) {
            DBGMSG (DBG_INFO, ("%s\n", szBuf));
            szBuf[0] = 0;
        }
    }
    DBGMSG (DBG_INFO, ("%s\n", szBuf));
}

void DumpOutputData (DWORD dwType, PBYTE pData, DWORD dwSize)
{
    DWORD i, col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    printf ("\tdwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize);

    switch (dwType) {
    case BIDI_NULL:
        printf("\tBIDI_NULL\n");
        break;
    case BIDI_INT:
        printf 	("\tBIDI_INT = %d\n", *(INT*)pData);
        break;
    case BIDI_FLOAT:
        printf 	("\tBIDI_FLOAT = %f\n", *(FLOAT*)pData);
        break;
    case BIDI_BOOL:
        printf 	("\tBIDI_BOOL = %d\n", *(BOOL*)pData);
        break;
    case BIDI_ENUM:
    case BIDI_TEXT:
    case BIDI_STRING:
        printf 	("\tBIDI_STRING = |%ws|\n", pData);
        break;
    case BIDI_BLOB:
        printf 	("\tBIDI_BLOB\n", pData);

        for (i = 0; i < dwSize; i++) {

            sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
            if ((col ++) % 16 == 15) {
                printf ("%s\n", szBuf);
                szBuf[0] = 0;
            }
        }
        printf ("%s\n", szBuf);
    default:
        printf 	("\tunsupported\n", pData);
    }


}


void DumpRequest (IBidiRequest * pIRequest)
{
    DWORD dwTotoal, i;
    HRESULT hr, hResult;
    LPWSTR pszSchema = NULL;
    BYTE *pData;
    DWORD uSize;
    DWORD dwType;
    DWORD dwTotal;

    hr = pIRequest->GetResult (&hResult);
    SPLASSERT (SUCCEEDED (hr));

    hr = pIRequest->GetEnumCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    printf("hr = %x; total = %d\n", hResult, dwTotal);

    for (i = 0; i < dwTotal; i++) {
        hr =  pIRequest->GetOutputData  (i, &pszSchema, &dwType, &pData, &uSize);
        printf("%d: %ws\n", i, (pszSchema)?pszSchema:L"");
        DumpOutputData (dwType, pData, uSize);
    }

}

void DumpContainer (IBidiRequestContainer * pIReqContainer)
{
    IBidiRequest * pRequest = NULL;
    DWORD dwRef, i;
    DWORD dwTotal;
    HRESULT hr;

    hr = pIReqContainer->GetRequestCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    IEnumUnknown *pEnumIunk;
    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    SPLASSERT (SUCCEEDED (hr));

    for (i = 0; i < dwTotal; i++){
        IUnknown *pIunk;
        DWORD dwFetched;
        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        SPLASSERT (SUCCEEDED (hr));
        SPLASSERT (dwFetched == 1);

        IBidiRequest *pIRequest = NULL;
        hr = pIunk->QueryInterface (IID_IBidiRequest, (void **) & pIRequest);
        SPLASSERT (SUCCEEDED (hr));

        DumpRequest (pIRequest);

        dwRef = pIunk->Release();
        dwRef = pIRequest->Release();
    }

    pEnumIunk->Release ();
}

void TestBidiRequest ()
{
    HRESULT hr;
	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequest,
                            (void**)&pIReq) ;
	if (SUCCEEDED(hr))
	{

        hr = pIReq->SetSchema (L"/printer/duplex");
        DBGMSG (DBG_TRACE, ("SetSchema hr = %x\n", hr));

        DWORD dwData = 30;
        DumpData (1, (PBYTE) &dwData, sizeof (DWORD));
        hr = pIReq->SetInputData (1, (LPBYTE) &dwData, sizeof (DWORD));
        DBGMSG (DBG_TRACE, ("SetInputData hr = 0x%x\n", hr));


        IBidiRequestSpl *pISpl = NULL;
        hr = pIReq->QueryInterface (IID_IBidiRequestSpl, (void **) & pISpl);
    	if (SUCCEEDED(hr))
	    {
            LPWSTR pSchema;

            DBGMSG (DBG_TRACE, ("Calling GetSchema\n"));
            hr = pISpl->GetSchema ( & pSchema);
            DBGMSG (DBG_TRACE, ("GetSchema hr=%x, %ws\n", hr, pSchema));


            hr = pISpl->SetResult (0x30);
            DBGMSG (DBG_TRACE, ("SetResult hr=%x\n", hr, pSchema));

            DWORD dwTotal = 2;
            for (DWORD i = 0; i <dwTotal; i++ ) {
                WCHAR szSchema[512];
                DWORD dwType;
                BYTE pData[512];
                ULONG uSize;

                for (int j = 0; j < rand() % 512 - 1; j++) {
                    szSchema[j] = L'0';
                }

                dwType = BIDI_BLOB;
                uSize = rand () % 512;
                for (j = 0; j < (int) uSize; j++) {
                    pData[j] = (BYTE) (j+i) ;
                }

                hr = pISpl->AppendOutputData (szSchema, dwType, pData, uSize);
                DumpData (dwType, pData, uSize);

                DBGMSG (DBG_TRACE, ("AppendOutputData hr = 0x%x\n", hr));
            }

        }

        HRESULT hrResult;
        hr = pIReq->GetResult (&hrResult);
        DBGMSG (DBG_TRACE, ("GetResult hr = 0x%x, Result=0x%x\n", hr, hrResult));
		
        DWORD dwTotal;
        hr = pIReq->GetEnumCount (&dwTotal);
        DBGMSG (DBG_TRACE, ("GetEnumCount hr = 0x%x, Result=%d\n", hr, dwTotal));

        for (DWORD i = 0; i <dwTotal; i++ ) {
            LPWSTR pSchema;
            DWORD dwType;
            LPBYTE pData;
            ULONG uSize;

            hr = pIReq->GetOutputData (i, &pSchema, &dwType, &pData, &uSize);
            DBGMSG (DBG_TRACE, ("GetOutputData hr = 0x%x, dwType=%d, dwSize=%d\n", hr, dwType, uSize));

            DumpData (dwType, pData, uSize);
        }


        DBGMSG (DBG_TRACE, ("Release IBididRequestSpl interface.\n")) ;
		pIReq->Release() ;

		DBGMSG (DBG_TRACE, ("Release IBididRequest interface.\n")) ;
		pISpl->Release() ;
	}
	else
	{
		DBGMSG (DBG_TRACE, ("Client: \t\tCould not create component. hr = %x\n ", hr));
	}
}



IBidiRequest *  GenRequest ()
{
    HRESULT hr;

	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequest,
                            (void**)&pIReq) ;
	if (SUCCEEDED(hr))
	{

        hr = pIReq->SetSchema (L"/printer/duplex");
        DBGMSG (DBG_TRACE, ("SetSchema hr = %x\n", hr));

        DWORD dwData = rand() % 1000;
        DumpData (1, (PBYTE) &dwData, sizeof (DWORD));
        hr = pIReq->SetInputData (BIDI_INT, (LPBYTE) &dwData, sizeof (DWORD));
        DBGMSG (DBG_TRACE, ("SetInputData hr = 0x%x\n", hr));

        DBGMSG (DBG_TRACE, ("Release IBididRequestSpl interface.\n")) ;
		return pIReq;

	}
	else
	{
		DBGMSG (DBG_TRACE, ("Client: \t\tCould not create component. hr = %x\n ", hr));
        return NULL;
	}


}

IBidiRequestContainer *  GenRequestContainer (DWORD dwTotal)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    IBidiRequest * pRequest = NULL;

    for (DWORD i = 0; i < dwTotal; i++) {
        pRequest = GenRequest ();
        SPLASSERT (pRequest != NULL);

        hr = pIReqContainer->AddRequest (pRequest);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pRequest->Release ();
        SPLASSERT (dwRef == 1);
    }
    return pIReqContainer;
}

void TestContainer ()
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    IBidiRequest * pRequest = NULL;
    DWORD dwTotal = 3;

    for (DWORD i = 0; i < dwTotal; i++) {
        pRequest = GenRequest ();
        SPLASSERT (pRequest != NULL);

        hr = pIReqContainer->AddRequest (pRequest);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pRequest->Release ();
        SPLASSERT (dwRef == 1);
    }


    DWORD dwTotal2;
    hr = pIReqContainer->GetRequestCount (&dwTotal2);
    SPLASSERT (SUCCEEDED (hr));
    SPLASSERT (dwTotal == dwTotal2);

    IEnumUnknown *pEnumIunk;
    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    SPLASSERT (SUCCEEDED (hr));

    for (i = 0; i < dwTotal2; i++){
        IUnknown *pIunk;
        DWORD dwFetched;
        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        SPLASSERT (SUCCEEDED (hr));
        SPLASSERT (dwFetched == 1);

        IBidiRequestSpl *pISpl = NULL;
        hr = pIunk->QueryInterface (IID_IBidiRequestSpl, (void **) & pISpl);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pIunk->Release();
        dwRef = pISpl->Release();

    }

    dwRef = pEnumIunk->Release ();

    DBGMSG (DBG_TRACE, ("Release IBididRequestContainer interface.\n")) ;
    dwRef = pIReqContainer->Release() ;
    SPLASSERT (dwRef == 0);
}

void TestBidiAPI ()
{
    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    IBidiRequestContainer *pIReqContainer;

    hr = ::CoCreateInstance(CLSID_BidiSpl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiSpl,
                            (void**)&pIBidiSpl) ;

    SPLASSERT (SUCCEEDED (hr));
    DBGMSG (DBG_TRACE, ("IBidiSpl created.\n")) ;

    pIReqContainer = GenRequestContainer (3);

    // Test Open/Close
    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (hr == E_HANDLE);

    hr = pIBidiSpl->BindDevice (L"No such Printer", 0);
    SPLASSERT (!SUCCEEDED (hr));

    hr = pIBidiSpl->BindDevice (L"Test", BIDI_ACCESS_USER);
    SPLASSERT (SUCCEEDED (hr));

    hr = pIBidiSpl->UnbindDevice ();
    SPLASSERT (SUCCEEDED (hr));

    hr = pIBidiSpl->UnbindDevice ();
    SPLASSERT (!SUCCEEDED (hr));

    hr = pIBidiSpl->BindDevice (L"Test", BIDI_ACCESS_USER);
    SPLASSERT (SUCCEEDED (hr));

    pIReqContainer = GenRequestContainer (3);
    hr = pIBidiSpl->MultiSendRecv (L"Get", NULL);
    SPLASSERT (!SUCCEEDED (hr));;

    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);

    dwRef = pIBidiSpl->Release ();
    SPLASSERT (dwRef == 0);
    DBGMSG (DBG_TRACE, ("IBidiSpl released.\n")) ;

}

IBidiRequest *  GenRequest (LPWSTR pSchema)
{
    HRESULT hr;

	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequest,
                            (void**)&pIReq) ;
	SPLASSERT (SUCCEEDED(hr));

    hr = pIReq->SetSchema (pSchema);
	SPLASSERT (SUCCEEDED(hr));
    return pIReq;
}

IBidiRequestContainer *  GenRequestContainer2 (DWORD dwTotal, LPWSTR pSchema)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    IBidiRequest * pRequest = NULL;

    for (DWORD i = 0; i < dwTotal; i++) {
        pRequest = GenRequest (pSchema);
        SPLASSERT (pRequest != NULL);

        hr = pIReqContainer->AddRequest (pRequest);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pRequest->Release ();
        SPLASSERT (dwRef == 1);
    }
    return pIReqContainer;
}

IBidiRequestContainer *CreateContainer ()
{
    HRESULT hr;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    return pIReqContainer;
}

void AddRequest (
    IBidiRequestContainer * pIReqContainer,
    LPWSTR pSchema)
{
    IBidiRequest * pRequest = NULL;
    HRESULT hr;
    DWORD dwRef;

    pRequest = GenRequest (pSchema);
    SPLASSERT (pRequest != NULL);

    hr = pIReqContainer->AddRequest (pRequest);
    SPLASSERT (SUCCEEDED (hr));

    dwRef = pRequest->Release ();
    SPLASSERT (dwRef == 1);

}


void TestBidiAPI2 ()
{
    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    IBidiRequestContainer *pIReqContainer;
    IBidiRequest * pRequest = NULL;

    hr = ::CoCreateInstance(CLSID_BidiSpl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiSpl,
                            (void**)&pIBidiSpl) ;

    SPLASSERT (SUCCEEDED (hr));
    DBGMSG (DBG_TRACE, ("IBidiSpl created.\n")) ;

    hr = pIBidiSpl->BindDevice (L"Test", BIDI_ACCESS_USER);
    SPLASSERT (SUCCEEDED (hr));
#if 0
    pIReqContainer = GenRequestContainer2 (10, L"/Printer/Installableoption/DuplexUnit");

    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    DumpContainer (pIReqContainer);

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);
#endif

    // Case 2

    pIReqContainer = CreateContainer ();

    //AddRequest (pIReqContainer, L"/Printer/Installableoption/DuplexUnit");
    //AddRequest (pIReqContainer, L"/Communication/Version");
    AddRequest (pIReqContainer, L"/Communication/BidiProtocol");
    AddRequest (pIReqContainer, L"/Printer/BlackInk1/Level");

    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    DumpContainer (pIReqContainer);

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);


    // Case 3
    pIReqContainer = CreateContainer ();

    AddRequest (pIReqContainer, L"/Printers/Alerts");

    hr = pIBidiSpl->MultiSendRecv (L"GetAll", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    DumpContainer (pIReqContainer);

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);

    dwRef = pIBidiSpl->Release ();
    SPLASSERT (dwRef == 0);
    DBGMSG (DBG_TRACE, ("IBidiSpl released.\n")) ;

}

void StartTest ()
{
    //TestContainer ();
    //TestBidiRequest ();
    //TestBidiAPI ();
    TestBidiAPI2 ();

}

int __cdecl main(int argc, char **argv)
{
    HRESULT hr;

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;
    SPLASSERT (SUCCEEDED (hr))
    StartTest ();
    // Uninitialize COM Library
	CoUninitialize() ;

#if 0
    hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED ) ;
    SPLASSERT (SUCCEEDED (hr))
    StartTest ();
    // Uninitialize COM Library
	CoUninitialize() ;


    hr = CoInitialize (NULL);
    SPLASSERT (SUCCEEDED (hr))
    StartTest ();
    // Uninitialize COM Library
	CoUninitialize() ;
#endif

    printf("Test successfully finished!\n");

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\bidispl\clients\test\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
//#include "winspl.h"
//#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>

#include <wininet.h>
#include <tchar.h>
#include <mdcommsg.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\clusspl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    cluster.c

Abstract:

    Cluster support.

    Note: there is no handle revalidation support in the module because
    the cluster software should be informed when a group goes offline.

Author:

    Albert Ting (AlbertT)  1-Oct-96

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )

/*++

Routine Description:

    Client side stub for opening a cluster resource.

Arguments:

    pszServer - Server to open--currently must be NULL (local).

    pszResource - Spooler resource.

    phSpooler - Receives handle on success; recevies NULL otherwise.

    pszName - Comma delimited alternate netbios/computer names.

    pszAddress - Comma delimited tcpip address names.

Return Value:

    TRUE - Success, phHandle must be closed with ClusterSplClose.

    FALSE - Failed--use GetLastError.  *phSpooler is NULL.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    BOOL bReturnValue = TRUE;
    PSPOOL pSpool = NULL;

    //
    // Preinitialize the spooler handle return to NULL.
    //
    __try {
        *phSpooler = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ){
        SetLastError( ERROR_INVALID_PARAMETER );
        phSpooler = NULL;
    }

    if( !phSpooler ){
        goto Fail;
    }

    //
    // Disallow remote servers in this release.
    //
    if( pszServer ){
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Fail;
    }


    //
    // Preallocate the handle.
    //
    pSpool = AllocSpool();

    if (pSpool) 
    {
        RpcTryExcept {

            Status = RpcClusterSplOpen( (LPTSTR)pszServer,
                                        (LPTSTR)pszResource,
                                        &pSpool->hPrinter,
                                        (LPTSTR)pszName,
                                        (LPTSTR)pszAddress );
            if( Status ){
                SetLastError( Status );
                bReturnValue = FALSE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())){

            SetLastError( TranslateExceptionCode( RpcExceptionCode() ));
            bReturnValue = FALSE;

        } RpcEndExcept
    }
    else
    {
        SetLastError( ERROR_OUTOFMEMORY );
        bReturnValue = FALSE;
    }

    if( bReturnValue ){

        //
        // pSpool is orphaned to *phSpooler.
        //
        *phSpooler = (HANDLE)pSpool;
        pSpool = NULL;
    }

Fail:

    FreeSpool( pSpool );

    return bReturnValue;
}

BOOL
ClusterSplClose(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Close the spooler.

Arguments:

    hSpooler - Spooler to close.

Return Value:

    Note: this function always returns TRUE, although it's spec'd out
    to return FALSE if the call fails.

--*/

{
    PSPOOL pSpool = (PSPOOL)hSpooler;
    HANDLE hSpoolerRPC;
    DWORD Status;

    switch( eProtectHandle( hSpooler, TRUE )){
    case kProtectHandlePendingDeletion:
        return TRUE;
    case kProtectHandleInvalid:
        return FALSE;
    default:
        break;
    }

    hSpoolerRPC = pSpool->hPrinter;

    RpcTryExcept {

        Status = RpcClusterSplClose( &hSpoolerRPC );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        Status = TranslateExceptionCode( RpcExceptionCode() );

    } RpcEndExcept

    if( hSpoolerRPC ){
        RpcSmDestroyClientContext(&hSpoolerRPC);
    }

    FreeSpool( pSpool );

    return TRUE;
}

BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Determines whether a spooler is still alive.

Arguments:

    hSpooler - Spooler to check.

Return Value:

    TRUE - Success
    FALSE - Fail; LastError set.

--*/

{
    PSPOOL pSpool = (PSPOOL)hSpooler;
    BOOL bReturnValue = TRUE;

    if( eProtectHandle( hSpooler, FALSE )){
        return FALSE;
    }

    RpcTryExcept {

        DWORD Status;

        Status = RpcClusterSplIsAlive( pSpool->hPrinter );

        if( Status ){
            SetLastError( Status );
            bReturnValue = FALSE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError( TranslateExceptionCode( RpcExceptionCode() ));
        bReturnValue = FALSE;

    } RpcEndExcept

    vUnprotectHandle( hSpooler );

    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\cstrings.h ===
#ifndef _CSTRINGS_H
#define _CSTRINGS_H

EXTERN_C const WCHAR szWindows[];
EXTERN_C const WCHAR szDevices[];
EXTERN_C const WCHAR szDevice[];
EXTERN_C const WCHAR szPrinterPorts[];
EXTERN_C const WCHAR szPrinters[];
EXTERN_C const WCHAR szDeviceOld[];
EXTERN_C const WCHAR szNULL[];
EXTERN_C const WCHAR szComma[];
EXTERN_C const WCHAR szSlash[];
EXTERN_C const WCHAR szFilePort[];
EXTERN_C const WCHAR szHelpFile[];
EXTERN_C const WCHAR szNetMsgDll[];
EXTERN_C const WCHAR szPrintUIDll[];
EXTERN_C const WCHAR cszWin95Environment[];
EXTERN_C const WCHAR szManifestExtension[];
EXTERN_C const WCHAR gszShell32[];
EXTERN_C const WCHAR cszTrayListenerClassName[];
EXTERN_C const WCHAR gszCSRDll[];
EXTERN_C const WCHAR gszUserProfileRegPath[];
EXTERN_C const WCHAR gszRegEnvironments[];
EXTERN_C const WCHAR gszSystem32Spool[];
EXTERN_C const WCHAR gszPrintProcessorsPath[];
EXTERN_C const WCHAR gszPrinterDriversPath[];
EXTERN_C const WCHAR gszEnivronmentDirectory[];

EXTERN_C const CHAR szCompstuiDll[];
EXTERN_C const CHAR szCommonPropertySheetUIW[];
EXTERN_C const CHAR szDrvDevPropSheets[];
EXTERN_C const CHAR szDrvDocPropSheets[];
EXTERN_C const CHAR szConstructPrinterFriendlyName[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\cstrings.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    cstrings.c

Abstract:

    Constant strings

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

const WCHAR szWindows[]                 = L"Windows";
const WCHAR szDevices[]                 = L"Devices";
const WCHAR szDevice[]                  = L"Device";
const WCHAR szPrinterPorts[]            = L"PrinterPorts";
const WCHAR szPrinters[]                = L"Printers";
const WCHAR szDeviceOld[]               = L"DeviceOld";
const WCHAR szNULL[]                    = L"";
const WCHAR szComma[]                   = L",";
const WCHAR szSlash[]                   = L"\\";
const WCHAR szFilePort[]                = L"FILE:";
const WCHAR szHelpFile[]                = L"WINDOWS.HLP";
const WCHAR szNetMsgDll[]               = L"NETMSG.DLL";
const WCHAR szPrintUIDll[]              = L"PRINTUI.DLL";
const WCHAR cszWin95Environment[]       = L"Windows 4.0";
const WCHAR szManifestExtension[]       = L"manifest";
const WCHAR gszShell32[]                = L"shell32.dll";
const WCHAR cszTrayListenerClassName[]  = L"PrintTray_Notify_WndClass";
const WCHAR gszCSRDll[]                 = L"csrsrv.dll";
const WCHAR gszUserProfileRegPath[]     = L"Software\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR gszRegEnvironments[]        = L"System\\CurrentControlSet\\Control\\Print\\Environments";
const WCHAR gszSystem32Spool[]          = L"system32\\spool";
const WCHAR gszPrintProcessorsPath[]    = L"PRTPROCS";
const WCHAR gszPrinterDriversPath[]     = L"DRIVERS";
const WCHAR gszEnivronmentDirectory[]   = L"Directory";

const CHAR szCompstuiDll[]                      = "compstui.dll";
const CHAR szCommonPropertySheetUIW[]           = "CommonPropertySheetUIW";
const CHAR szDrvDevPropSheets[]                 = "DrvDevicePropertySheets";
const CHAR szDrvDocPropSheets[]                 = "DrvDocumentPropertySheets";
const CHAR szConstructPrinterFriendlyName[]     = "ConstructPrinterFriendlyName";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines

Author:

    Dave Snipp (davesn)     01-Jun-1991

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

LPWSTR InterfaceAddress = L"\\pipe\\spoolss";

/* Security=[Impersonation | Identification | Anonymous] [Dynamic | Static] [True | False]
 * (where True | False corresponds to EffectiveOnly)
 */
LPWSTR StringBindingOptions = L"Security=Impersonation Dynamic False";
handle_t GlobalBindHandle;


handle_t
STRING_HANDLE_bind (
    STRING_HANDLE  lpStr)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle = NULL;
    WCHAR*   pszServerPrincName = NULL;

    if( (RpcStatus = RpcStringBindingComposeW(0, 
                                              L"ncalrpc", 
                                              0, 
                                              L"spoolss",
                                              StringBindingOptions, 
                                              &StringBinding)) == RPC_S_OK)
    {
        if( (RpcStatus = RpcBindingFromStringBindingW(StringBinding, 
                                                      &BindingHandle)) == RPC_S_OK)
        {
            RPC_SECURITY_QOS RpcSecQos;

            RpcSecQos.Version           = RPC_C_SECURITY_QOS_VERSION_1;
            RpcSecQos.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
            RpcSecQos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
            RpcSecQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
            
            RpcStatus = RpcBindingSetAuthInfoEx(BindingHandle,
                                                L"NT Authority\\SYSTEM",
                                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                                RPC_C_AUTHN_WINNT,
                                                NULL,
                                                RPC_C_AUTHZ_NONE,
                                                &RpcSecQos);
        }

        if(RpcStatus != RPC_S_OK)
        {
            BindingHandle = NULL;
        }

        RpcStringFreeW(&StringBinding);
    }

    return(BindingHandle);
}



void
STRING_HANDLE_unbind (
    STRING_HANDLE  lpStr,
    handle_t    BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles the wait for printer change new code.

    FindFirstPrinterChangeNotification
    FindNextPrinterChangeNotification
    FindClosePrinterChangeNotification

Author:

    Albert Ting (AlbertT) 20-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include <change.h>
#include <ntfytab.h>

//
// Globals
//
PNOTIFY pNotifyHead;
extern  DWORD   ClientHandleCount;

INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength);

VOID
CopyAnsiDevModeFromUnicodeDevMode(
    LPDEVMODEA  pANSIDevMode,
    LPDEVMODEW  pUnicodeDevMode);


//
// Prototypes:
//

PNOTIFY
WPCWaitAdd(
    PSPOOL pSpool);

VOID
WPCWaitDelete(
    PNOTIFY pNotify);


DWORD
WPCSimulateThreadProc(PVOID pvParm);


HANDLE
FindFirstPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD  fdwFilter,
    DWORD  fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions
    )

/*++

Routine Description:

    The FindFirstChangeNotification function creates a change notification
    handle and sets up initial change notification filter conditions. A
    wait on a notification handle succeeds when a change matching
    the filter conditions occurs in the specified directory or subtree.

Arguments:

    hPrinter - Handle to a printer the user wishes to watch.

    fdwFlags - Specifies the filter conditions that satisfy a change
        notification wait. This parameter can be one or more of the
        following values:

        Value   Meaning

        PRINTER_CHANGE_PRINTER      Notify changes to a printer.
        PRINTER_CHANGE_JOB          Notify changes to a job.
        PRINTER_CHANGE_FORM         Notify changes to a form.
        PRINTER_CHANGE_PORT         Notify changes to a port.
        PRINTER_CHANGE_PRINT_PROCESSOR  Notify changes to a print processor.
        PRINTER_CHANGE_PRINTER_DRIVER   Notify changes to a printer driver.

    fdwOptions - Specifies options to FFPCN.

        PRINTER_NOTIFY_OPTION_SIM_FFPCN         Trying to simulate a FFPCN using a WPC
        PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE  Simulation of FFPCN active
        PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE   Waiting thread must close pSpool
        PRINTER_NOTIFY_OPTION_SIM_WPC           Trying to simulate a WPC using a FFPCN

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    -1 - The operation failed. Extended error status is available
         using GetLastError.

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    DWORD dwError;
    PNOTIFY pNotify;

    HANDLE hEvent = INVALID_HANDLE_VALUE;

    //
    // Nothing to watch.
    //
    if (!fdwFilter && !pPrinterNotifyOptions) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    vEnterSem();

    if (eProtectHandle( hPrinter, FALSE )) {
        vLeaveSem();
        return INVALID_HANDLE_VALUE;
    }

    //
    // First check if we are already waiting.
    //
    // This is broken if we are daytona client->528 server and
    // the app does a FFPCN, FCPCN, FFPCN on the same printer,
    // and the WPC hasn't returned yet.  We really can't fix this
    // because there's no way to interrupt the WPC.
    //
    // The only thing we can do is check if it's simulating and waiting
    // to close.  If so, then we can reuse it.
    //
    if (pSpool->pNotify) {

        if ((pSpool->pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE) &&
            (fdwFilter == pSpool->pNotify->fdwFlags)) {

            //
            // No longer closing, since we are using it.
            //
            pSpool->pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE;
            hEvent = pSpool->pNotify->hEvent;
            goto Done;
        }

        SetLastError(ERROR_ALREADY_WAITING);
        goto Done;
    }

    //
    // Create and add our pSpool to the linked list of wait requests.
    //
    pNotify = WPCWaitAdd(pSpool);

    if (!pNotify) {

        goto Done;
    }

    vLeaveSem();

    pNotify->fdwOptions = fdwOptions;
    pNotify->fdwFlags = fdwFilter;

    RpcTryExcept {

        if (dwError = RpcClientFindFirstPrinterChangeNotification(
                          pSpool->hPrinter,
                          fdwFilter,
                          fdwOptions,
                          GetCurrentProcessId(),
                          (PRPC_V2_NOTIFY_OPTIONS)pPrinterNotifyOptions,
                          (LPDWORD)&pNotify->hEvent)) {

            hEvent = INVALID_HANDLE_VALUE;

        } else {

            hEvent = pNotify->hEvent;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        hEvent = INVALID_HANDLE_VALUE;

    } RpcEndExcept

    vEnterSem();

    //
    // If we encounter a 528 server, then we need to simulate the
    // FFPCN using a WPC.  If the client originally wanted a WPC anyway,
    // then fail out and let the client thread do the blocking.
    //
    if (dwError == RPC_S_PROCNUM_OUT_OF_RANGE &&
        !(fdwOptions & PRINTER_NOTIFY_OPTION_SIM_WPC)) {

        DWORD dwIDThread;
        HANDLE hThread;

        //
        // If pPrinterNotifyOptions is set, we can't handle it.
        // just fail.
        //
        if (pPrinterNotifyOptions) {

            WPCWaitDelete(pNotify);
            SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
            hEvent = INVALID_HANDLE_VALUE;
            goto Done;
        }

        hEvent = pNotify->hEvent = CreateEvent(NULL,
                                               TRUE,
                                               FALSE,
                                               NULL);

        if( !hEvent ){

            hEvent = INVALID_HANDLE_VALUE;

        } else {

            //
            // We're simulating a FFPCN using WPC now.
            //
            pNotify->fdwOptions |= PRINTER_NOTIFY_OPTION_SIM_FFPCN |
                                   PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

            //
            // Also mark that we failed trying to use FFPCN so we never
            // try again on this handle.
            //
            pSpool->fdwFlags |= SPOOL_FLAG_FFPCN_FAILED;


            hThread = CreateThread(NULL,
                                   INITIAL_STACK_COMMIT,
                                   WPCSimulateThreadProc,
                                   pNotify,
                                   0,
                                   &dwIDThread);

            if (hThread) {

                CloseHandle(hThread);

            } else {

                CloseHandle(hEvent);

                hEvent = INVALID_HANDLE_VALUE;
                dwError = GetLastError();

                pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;
            }
        }
    }

    //
    // On error case, remove us from the list of waiting handles
    //
    if( hEvent == INVALID_HANDLE_VALUE ){

        WPCWaitDelete(pNotify);
        SetLastError(dwError);
    }

Done:

    vUnprotectHandle( hPrinter );
    vLeaveSem();

    return hEvent;
}


HANDLE WINAPI
FindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  fdwFilter,
    DWORD  fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions)
{
    if (fdwOptions) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    return FindFirstPrinterChangeNotificationWorker(hPrinter,
                                                    fdwFilter,
                                                    fdwOptions,
                                                    pPrinterNotifyOptions);
}

BOOL WINAPI
FindNextPrinterChangeNotification(
    HANDLE hChange,
    LPDWORD pdwChange,
    LPVOID pPrinterNotifyOptions,
    LPVOID* ppInfo)
{
    BOOL bReturnValue;
    DWORD dwError;
    HANDLE hPrinter;
    PSPOOL pSpool;
    PNOTIFY pNotify;
    PVOID pvIgnore;
    DWORD dwIgnore;

    DWORD fdwFlags;

    if (!pdwChange) {

        pdwChange = &dwIgnore;
    }

    if (ppInfo) {

        *ppInfo = NULL;
        fdwFlags = PRINTER_NOTIFY_NEXT_INFO;

    } else {

        ppInfo = &pvIgnore;
        fdwFlags = 0;
    }

    vEnterSem();

    pNotify = WPCWaitFind(hChange);

    //
    // Either the handle is bad, or it doesn't have a wait or we have 
    // 
    if (!pNotify || !pNotify->pSpool || pNotify->bHandleInvalid) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto FailExitWaitList;
    }

    pSpool = pNotify->pSpool;
    hPrinter = pSpool->hPrinter;

    //
    // If we are simulating FFPCN using WPC, we must use the thread.
    //
    if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN) {

        HANDLE hThread;
        DWORD dwIDThread;

        ResetEvent(pNotify->hEvent);

        //
        // Get the last return status.  Client should not call FNCPN
        // until the WPC sets the event, so this value should be
        // initialized.
        //
        *pdwChange = pNotify->dwReturn;

        //
        // If the thread is active anyway, then don't try to create another
        // Best we can do at this point.
        //
        if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE) {

            vLeaveSem();
            return TRUE;
        }

        //
        // We're simulating a FFPCN using WPC now.
        //
        pNotify->fdwOptions |= PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

        hThread = CreateThread(NULL,
                               INITIAL_STACK_COMMIT,
                               WPCSimulateThreadProc,
                               pNotify,
                               0,
                               &dwIDThread);

        if (hThread) {

            CloseHandle(hThread);

            vLeaveSem();
            return TRUE;

        }

        pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

        goto FailExitWaitList;
    }

    vLeaveSem();

    RpcTryExcept {

        if (dwError = RpcFindNextPrinterChangeNotification(
                          hPrinter,
                          fdwFlags,
                          pdwChange,
                          (PRPC_V2_NOTIFY_OPTIONS)pPrinterNotifyOptions,
                          (PRPC_V2_NOTIFY_INFO*)ppInfo)) {

            SetLastError(dwError);
            bReturnValue = FALSE;

        } else {

            bReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        bReturnValue = FALSE;

    } RpcEndExcept

    //
    // Thunk from W to A if necessary.
    //
    if (pSpool->Status & SPOOL_STATUS_ANSI    &&
        bReturnValue                          &&
        fdwFlags & PRINTER_NOTIFY_NEXT_INFO   &&
        *ppInfo) {

        DWORD i;
        PPRINTER_NOTIFY_INFO_DATA pData;

        for(pData = (*(PPRINTER_NOTIFY_INFO*)ppInfo)->aData,
                i=(*(PPRINTER_NOTIFY_INFO*)ppInfo)->Count;
            i;
            pData++, i--) {

            switch ((BYTE)pData->Reserved) {
            case TABLE_STRING:

                UnicodeToAnsiString(
                    pData->NotifyData.Data.pBuf,
                    pData->NotifyData.Data.pBuf,
                    (pData->NotifyData.Data.cbBuf/sizeof(WCHAR)) -1);

                break;

            case TABLE_DEVMODE:

                if (pData->NotifyData.Data.cbBuf) {

                    CopyAnsiDevModeFromUnicodeDevMode(
                        pData->NotifyData.Data.pBuf,
                        pData->NotifyData.Data.pBuf);
                }

                break;
            }
        }
    }

    return bReturnValue;

FailExitWaitList:

    vLeaveSem();
    return FALSE;
}


BOOL WINAPI
FindClosePrinterChangeNotification(
    HANDLE hChange)
{
    PNOTIFY pNotify;
    HANDLE hPrinterRPC = NULL;
    DWORD dwError;

    vEnterSem();

    pNotify = WPCWaitFind(hChange);

    if (!pNotify) {

        SetLastError(ERROR_INVALID_HANDLE);

        vLeaveSem();
        return FALSE;
    }

    if (pNotify->pSpool)
        hPrinterRPC = pNotify->pSpool->hPrinter;

    dwError = FindClosePrinterChangeNotificationWorker(pNotify,
                                                       hPrinterRPC,
                                                       FALSE);

    vLeaveSem();

    if (dwError) {

        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}


DWORD
FindClosePrinterChangeNotificationWorker(
    IN  PNOTIFY     pNotify,
    IN  HANDLE      hPrinterRPC,
    IN  BOOL        bRevalidate
    )

/*++

Routine Description:

    Does the actual FindClose work.

Arguments:

    pNotify     - notification to close
    hPrinterRPC - handle to printer to close
    bRevalidate - If this is TRUE, we were called to revalidate the handle 
                  rather than close it.

Return Value:

    TRUE - success
    FALSE - fail

    Note: assume in critical section

--*/

{
    DWORD dwError;
    PSPOOL pSpool;

    if (!pNotify) {

        return ERROR_INVALID_HANDLE;
    }

    //
    // Detach the pNotify and pSpool objects completely. Only if we are not 
    // revalidating.
    //
    pSpool = pNotify->pSpool;

    if (!bRevalidate) {

        if (pSpool) {
            pSpool->pNotify = NULL;
            pSpool->fdwFlags = 0;
        }

        pNotify->pSpool = NULL;
    }

    //
    // If we are simulating a FFPCN with a WPC, then let the WPC thread
    // free up the data structure or clean it up if the thread is done.
    //
    if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN) {

        if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE) {

            pNotify->fdwOptions |= PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE;

        } else {

            //
            // The thread has exited, so we need to do the cleanup.
            // Set the event to release any waiting threads. Since the caller
            // does not necessarily know how to handle the failure on 
            // WaitForMultipleObjects, 
            //
            SetEvent(pNotify->hEvent);

            if (!bRevalidate) {

                CloseHandle(pNotify->hEvent);
                WPCWaitDelete(pNotify);

            } else {

                pNotify->bHandleInvalid = TRUE;
            }
        }

        return ERROR_SUCCESS;
    }

    SetEvent(pNotify->hEvent);

    //
    // If we are not revalidating, we can close the handle for real, otherwise
    // we just want to set the handle to invalid.
    // 
    if (!bRevalidate) {

        CloseHandle(pNotify->hEvent);
        WPCWaitDelete(pNotify);

    } else {

        pNotify->bHandleInvalid = TRUE;
    }

    if (!hPrinterRPC)
        return ERROR_SUCCESS;

    vLeaveSem();

    RpcTryExcept {

        dwError = RpcFindClosePrinterChangeNotification(hPrinterRPC);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    vEnterSem();

    return dwError;
}

//
// WPC Wait structures
// Currently implemented as a linked list
//

PNOTIFY
WPCWaitAdd(
    PSPOOL pSpool)

/*++

Routine Description:

    Allocates a wait structure on the client side, which allows the
    user program to refer to events only.

Arguments:

    pSpool - object to add to list

Return Value:

    NOTE: Asssumes already in critical section

--*/

{
    PNOTIFY pNotify;

    pNotify = AllocSplMem(sizeof(NOTIFY));

    if (!pNotify)
        return NULL;

    pNotify->pSpool = pSpool;
    pSpool->pNotify = pNotify;

    pNotify->pNext = pNotifyHead;
    pNotifyHead = pNotify;

    return pNotify;
}

VOID
WPCWaitDelete(
    PNOTIFY pNotify)

/*++

Routine Description:

    Find wait structure based on hEvent.

Arguments:

    pNotify - delete it

Return Value:

    VOID

    NOTE: Asssumes already in critical section

--*/

{
    PNOTIFY pNotifyTmp;

    if (!pNotify)
        return;

    //
    // Check head case first
    //
    if (pNotifyHead == pNotify) {

        pNotifyHead = pNotify->pNext;

    } else {

        //
        // Scan list to delete
        //
        for(pNotifyTmp = pNotifyHead;
            pNotifyTmp;
            pNotifyTmp = pNotifyTmp->pNext) {

            if (pNotify == pNotifyTmp->pNext) {

                pNotifyTmp->pNext = pNotify->pNext;
                break;
            }
        }

        //
        // If not found, return without freeing
        //
        if (!pNotifyTmp)
            return;
    }

    //
    // Remove link from pSpool to us... but only if we've found
    // ourselves on the linked list (could have been removed by
    // ClosePrinter in a different thread).
    //
    if (pNotify->pSpool) {
        pNotify->pSpool->pNotify = NULL;
    }

    FreeSplMem(pNotify);
    return;
}


PNOTIFY
WPCWaitFind(
    HANDLE hFind)

/*++

Routine Description:

    Find wait structure based on hEvent.

Arguments:

    hFind - Handle to event returned from FindFirstPrinterChangeNotification
            or hPrinter

Return Value:

    pWait pointer, or NULL if not found

    NOTE: assumes already in critical section

--*/

{
    PNOTIFY pNotify;

    for(pNotify = pNotifyHead; pNotify; pNotify=pNotify->pNext) {

        if (hFind == pNotify->hEvent) {

            return pNotify;
        }
    }

    return NULL;
}



DWORD
WPCSimulateThreadProc(
    PVOID pvParm)

/*++

Routine Description:

    This thread simulates the FFPCN when daytona apps run on daytona
    clients connected to 528 servers.

Arguments:

    pvParm - pSpool

Return Value:

    VOID

    Note:

--*/

{
    PNOTIFY pNotify = (PNOTIFY)pvParm;

    pNotify->dwReturn = WaitForPrinterChange(pNotify->pSpool,
                                             pNotify->fdwFlags);

    vEnterSem();

    pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

    //
    // !! POLICY !!
    //
    // How do we handle timeouts?
    //
    SetEvent(pNotify->hEvent);

    if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE) {

        CloseHandle(pNotify->hEvent);
        WPCWaitDelete(pNotify);
    }

    vLeaveSem();

    //
    // We are no longer active; the FindClose must clean up for us.
    //
    return 0;
}

DWORD
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
)
{
    DWORD   ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    HANDLE  hEvent;
    DWORD   rc;

    if( eProtectHandle( hPrinter, FALSE )){
        return(FALSE);
    }


    //
    // Try using FFPCN first, if we haven't failed on this printer before.
    //

    if (!(pSpool->fdwFlags & SPOOL_FLAG_FFPCN_FAILED)) {

        if (pSpool->fdwFlags & SPOOL_FLAG_LAZY_CLOSE) {

            vEnterSem();

            if (pSpool->pNotify)
                hEvent = pSpool->pNotify->hEvent;

            vLeaveSem();

        } else {

            hEvent = FindFirstPrinterChangeNotificationWorker(
                         hPrinter,
                         Flags,
                         PRINTER_NOTIFY_OPTION_SIM_WPC,
                         NULL);
        }

        if (hEvent != INVALID_HANDLE_VALUE) {

            //
            // Found notification, now wait for it.
            //
            rc = WaitForSingleObject(hEvent, PRINTER_CHANGE_TIMEOUT_VALUE);

            switch (rc) {
            case WAIT_TIMEOUT:

                ReturnValue = PRINTER_CHANGE_TIMEOUT;
                break;

            case WAIT_OBJECT_0:

                if (!FindNextPrinterChangeNotification(
                    hEvent,
                    &ReturnValue,
                    0,
                    NULL)) {

                    ReturnValue = 0;

                    DBGMSG(DBG_WARNING,
                           ("QueryPrinterChange failed %d\n",
                           GetLastError()));
                }
                break;

            default:

                ReturnValue = 0;
                break;
            }

            //
            // !! Policy !!
            //
            // Do we want to close it?  The app might just reopen it.
            // If we leave it open, it will get cleaned-up at ClosePrinter
            // time.  We would need an api to clear out pending events.
            //
            pSpool->fdwFlags |= SPOOL_FLAG_LAZY_CLOSE;
            goto Done;
        }

        //
        // FFPCN failed.  Only if entry not found (511 client) do
        // we try old WPC.  Otherwise return here.
        //
        if (GetLastError() != RPC_S_PROCNUM_OUT_OF_RANGE) {
            ReturnValue = 0;
            goto Done;
        }

        pSpool->fdwFlags |= SPOOL_FLAG_FFPCN_FAILED;
    }

    RpcTryExcept {

        if (ReturnValue = RpcWaitForPrinterChange(
                              pSpool->hPrinter,
                              Flags,
                              &Flags)) {

            SetLastError(ReturnValue);
            ReturnValue = 0;

        } else

            ReturnValue = Flags;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = 0;

    } RpcEndExcept
Done:

    vUnprotectHandle( pSpool );
    return ReturnValue;
}


BOOL WINAPI
FreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo)
{
    DWORD i;
    PPRINTER_NOTIFY_INFO_DATA pData;

    if (!pInfo) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for(pData = pInfo->aData, i=pInfo->Count;
        i;
        pData++, i--) {

        if ((BYTE)pData->Reserved != TABLE_DWORD &&
            pData->NotifyData.Data.pBuf) {

            midl_user_free(pData->NotifyData.Data.pBuf);
        }
    }

    midl_user_free(pInfo);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\data.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

#define PRINTER_STRINGS
#define PRINTER_OFFSETS

#define JOB_STRINGS
#define JOB_OFFSETS

#define DRIVER_STRINGS
#define DRIVER_OFFSETS

#define ADDJOB_STRINGS
#define ADDJOB_OFFSETS

#define FORM_STRINGS
#define FORM_OFFSETS

#define PORT_STRINGS
#define PORT_OFFSETS

#define PRINTPROCESSOR_STRINGS
#define PRINTPROCESSOR_OFFSETS

#define MONITOR_STRINGS
#define MONITOR_OFFSETS

#define DOCINFO_STRINGS
#define DOCINFO_OFFSETS

#define DATATYPE_OFFSETS
#define DATATYPE_STRINGS

#define PROVIDOR_STRINGS

#define PRINTER_ENUM_VALUES_OFFSETS

#include <data.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\defprn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    defprn.cxx

Abstract:

    Default printer header.

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#ifndef _DEFPRN_H
#define _DEFPRN_H


BOOL
IsPrinterDefaultW(
    IN LPCWSTR  pszPrinter
    );

BOOL
GetDefaultPrinterA(
    IN LPSTR    pszBuffer,
    IN LPDWORD  pcchBuffer
    );

BOOL
GetDefaultPrinterW(
    IN LPWSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
    );

BOOL
SetDefaultPrinterA(
    IN LPCSTR pszPrinter
    );

BOOL
SetDefaultPrinterW(
    IN LPCWSTR pszPrinter
    );

BOOL
bGetActualPrinterName(
    IN      LPCTSTR  pszPrinter,
    IN      LPTSTR   pszBuffer,
    IN OUT  UINT     *pcchBuffer
    );

BOOL
DefPrnGetProfileString(
    IN PCWSTR   pAppName,
    IN PCWSTR   pKeyName,
    IN PWSTR    pReturnedString,
    IN DWORD    nSize
    );

BOOL
DefPrnWriteProfileString(
    IN PCWSTR lpAppName,
    IN PCWSTR lpKeyName,
    IN PCWSTR lpString
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\drvsetup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    drvsetup.c

Abstract:

    This file implements the interface between winspool.drv and ntprint.dll.

Author:

    Mark Lawrence   (mlawrenc).

Environment:

    User Mode -Win32

Revision History:

    Larry Zhu       (LZhu)  Feb 10 -- Added ShowPrintUpgUI
    
--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "drvsetup.h"

/*++
                                                       
                                                       
Routine Name:

    InitializeSetupInterface

Routine Description:

    This routine initializes the setup interfaces. This setup interface could be
    expanded over time to support more advance driver options.

Arguments:

    pSetupInterface -   The setup interface to load and initialize.

Return Value:

    Status Return.

--*/
DWORD 
InitializeSetupInterface(
    IN  OUT TSetupInterface      *pSetupInterface
    )
{
    DWORD   Status = ERROR_SUCCESS;

    pSetupInterface->hLibrary                       = NULL;
    pSetupInterface->pfnSetupShowBlockedDriverUI    = NULL;

    pSetupInterface->hLibrary = LoadLibrary(L"ntprint.dll");

    Status = pSetupInterface->hLibrary != NULL ? ERROR_SUCCESS : GetLastError();

    if (Status == ERROR_SUCCESS)
    {
        pSetupInterface->pfnSetupShowBlockedDriverUI= (pfPSetupShowBlockedDriverUI)
                                                      GetProcAddress(pSetupInterface->hLibrary,
                                                                     "PSetupShowBlockedDriverUI");
        
        Status = pSetupInterface->pfnSetupShowBlockedDriverUI ? ERROR_SUCCESS : ERROR_INVALID_FUNCTION;
    }

    return Status;
}

/*++

Routine Name:

    FreeSetupInterface

Routine Description:

    This routine frees the Setup Interface.

Arguments:

    pSetupInterface -   The setup interface to unload.

Return Value:

    Status Return.

--*/
DWORD
FreeSetupInterface(
    IN  OUT TSetupInterface     *pSetupInterface
    )
{
    DWORD   Status = ERROR_SUCCESS;

    if (pSetupInterface->hLibrary)
    {
        Status = FreeLibrary(pSetupInterface->hLibrary) ? ERROR_SUCCESS : GetLastError();
    }

    return Status;
}

/*++

Routine Name:

    ShowPrintUpgUI

Routine Description:

    This routine asks ntprint.dll to popup a message box either indicates
    the driver is blocked and installation will abort or at the case of
    warned driver, whether to preceed the driver installation.

Arguments:

    dwBlockingStatus   - ErrorCode for blocked or Warned driver   
     
Return Value:

    DWORD   -   If ERROR_SUCCESS, the driver may be installed, otherwise an error
                code indicating the failure.                    

--*/
DWORD
ShowPrintUpgUI(
    IN      DWORD               dwBlockingErrorCode
    )
{
    DWORD            dwStatus             = ERROR_SUCCESS;
    HWND             hWndParent           = NULL;
    DWORD            dwBlockingStatus     = BSP_PRINTER_DRIVER_OK;
    TSetupInterface  SetupInterface;
    
    if (ERROR_PRINTER_DRIVER_BLOCKED == dwBlockingErrorCode)
    {
        dwBlockingStatus = BSP_PRINTER_DRIVER_BLOCKED;
    } 
    else if (ERROR_PRINTER_DRIVER_WARNED == dwBlockingErrorCode)
    {
        dwBlockingStatus = BSP_PRINTER_DRIVER_WARNED;
    } 
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }   
    
    if (ERROR_SUCCESS == dwStatus)
    {
        dwStatus = InitializeSetupInterface(&SetupInterface);
            
        if ((dwStatus == ERROR_SUCCESS))
        {                        
            hWndParent = SUCCEEDED(GetCurrentThreadLastPopup(&hWndParent)) ? hWndParent : NULL;
    
            //
            // Ask the user what they want to do. If they don't want to proceed, 
            // then the error is what the would get from the localspl call.
            // 
            dwStatus = (SetupInterface.pfnSetupShowBlockedDriverUI(hWndParent, dwBlockingStatus) & BSP_PRINTER_DRIVER_PROCEEDED) ? ERROR_SUCCESS : dwBlockingErrorCode;
        }
    
        (VOID)FreeSetupInterface(&SetupInterface);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\drvsetup.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    drvsetup.h

Abstract:

    This file provides an interface between winspool.drv and ntprint.dll.     

Author:

    Mark Lawrence   (mlawrenc).

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _DRVSETUP_H_
#define _DRVSETUP_H_
 
typedef struct
{
    HANDLE                      hLibrary;
    pfPSetupShowBlockedDriverUI pfnSetupShowBlockedDriverUI;    

} TSetupInterface;

DWORD
InitializeSetupInterface(
    IN  OUT TSetupInterface      *pSetupInterface
    );

DWORD
FreeSetupInterface(
    IN  OUT TSetupInterface     *pSetupInterface
    );

DWORD
ShowPrintUpgUI(
    IN      DWORD               dwBlockingErrorCode
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\dsutil.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Abstract:

    This module provides utilities useful for Directory Service interactions

Author:

    Steve Wilson (NT) November 1997

Revision History:

--*/

#define INC_OLE2

#include "precomp.h"
#pragma hdrstop

#include "client.h"

#include "pubprn.hxx"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"
#include "winsprlp.h"
#include "dnsapi.h"


#define DN_SPECIAL_CHARS L",=\r\n+<>#;\"\\"
#define DN_SPECIAL_FILTER_CHARS L"\\*()"


PWSTR
GetUNCName(
    HANDLE hPrinter
)
{
    PPRINTER_INFO_2    pInfo2 = NULL;
    DWORD            cbNeeded;
    PWSTR            pszUNCName = NULL;


    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, 0, &cbNeeded)) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            goto error;
    }

    if (!(pInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded)))
        goto error;

    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, cbNeeded, &cbNeeded))
        goto error;


    // pPrinterName is already in correct UNC format since we
    // opened handle with UNC name: just copy it

    cbNeeded = wcslen(pInfo2->pPrinterName) + 1;
    cbNeeded *= sizeof(WCHAR);

    if (!(pszUNCName = (PWSTR) AllocSplMem(cbNeeded)))
        goto error;

    StringCbCopy(pszUNCName, cbNeeded, pInfo2->pPrinterName);


error:

    if (pInfo2)
        FreeSplMem(pInfo2);

    return pszUNCName;
}

HRESULT
CreateEscapedDN(
    PCWSTR pszIn,
    PWSTR  *ppEscapedString
)
{
    PWSTR   pszOut = NULL;
    PWSTR   psz;
    DWORD   cch;
    HRESULT hRet = S_OK;

    //
    // Count special characters
    //
    for (cch = 0, psz = (PWSTR) pszIn ; psz = wcspbrk(psz, DN_SPECIAL_FILTER_CHARS) ; ++cch, ++psz)
    {
        //
        // Empty body
        //
    }
        
    //
    // Add in length of input string
    // 2 = (\5c) - '\'
    //
    cch = (wcslen(pszIn) + cch*2 + 1);    

    //
    // Allocate output buffer and replace special chars with \HexEquivalent
    // Ex: replace \ with \5c , ( with \28
    //
    if (pszOut = (PWSTR) AllocSplMem(cch * sizeof(WCHAR))) 
    {
        size_t cchRemaining = cch;
        PWSTR  pszO;

        for(psz = (PWSTR) pszIn, pszO = pszOut ; *psz ; ++psz) 
        {
            if (wcschr(DN_SPECIAL_FILTER_CHARS, *psz)) 
            {
                if (FAILED(hRet = StringCchPrintfEx(pszO, 
                                                    cchRemaining, 
                                                    &pszO, 
                                                    &cchRemaining, 
                                                    STRSAFE_NULL_ON_FAILURE,
                                                    L"\\%x", 
                                                    *psz)))
                {
                    break;
                }
            } 
            else 
            {
                *pszO++ = *psz;

                cchRemaining--;
            }
        }
        
        *pszO = L'\0';
    }
    else
    {
        hRet = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRet))
    {
        *ppEscapedString = pszOut;
    }
    else
    {
        *ppEscapedString = NULL;

        FreeSplMem(pszOut);
    }

    return hRet;
}

DWORD
PrintQueueExists(
    HWND    hwnd,
    HANDLE  hPrinter,
    PWSTR   pszUNCName,
    DWORD   dwAction,
    PWSTR   pszTargetDN,
    PWSTR   *ppszObjectDN
)
{
    HRESULT                             hr = S_OK;
    DWORD                               dwRet = ERROR_SUCCESS;
    WCHAR                               szSearchPattern[MAX_UNC_PRINTER_NAME + 50];
    WCHAR                               szFullUNCName[MAX_UNC_PRINTER_NAME];
    PWSTR                               pNames[2];
    WCHAR                               szName[MAX_PATH + 1];
    PWSTR                               pszSearchRoot = NULL;
    PWSTR                               pszUNCNameSearch = NULL;
    IDirectorySearch                    *pDSSearch = NULL;
    DS_NAME_RESULT                      *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO              *pDCI = NULL;
    HANDLE                              hDS = NULL;
    ADS_SEARCH_HANDLE                   hSearchHandle = NULL;
    ADS_SEARCH_COLUMN                   ADsPath;
    ADS_SEARCH_COLUMN                   UNCName;
    PWSTR                               pszAttributes[] = {L"ADsPath", L"UNCName"};
    DWORD                               nSize;
    BOOL                                bRet = FALSE;
    BOOL                                bDeleteDuplicate = FALSE;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;

    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);

    if (dwRet != ERROR_SUCCESS)
        goto error;

    StringCchPrintf(szName, COUNTOF(szName), L"%ws\\", pDsRole->DomainNameFlat);

    pNames[0] = szName;
    pNames[1] = NULL;

    dwRet = Bind2DS(&hDS, &pDCI, DS_GC_SERVER_REQUIRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;

    if (!(DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_UNKNOWN_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    } 

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
            dwRet = ERROR_PATH_NOT_FOUND;
        else
            dwRet = pDNR->rItems[0].status;

        goto error;
    }

    // GC:// + pDCName + 1
    nSize = (wcslen(pDNR->rItems[0].pName) + 6)*sizeof(WCHAR);

    if (!(pszSearchRoot = (PWSTR) AllocSplMem(nSize))) {
        dwRet = GetLastError();
        goto error;
    }

    StringCbPrintf(pszSearchRoot, nSize, L"GC://%ws", pDNR->rItems[0].pName);


    hr = ADsGetObject(  pszSearchRoot,
                        IID_IDirectorySearch,
                        (void **)&pDSSearch);
    BAIL_ON_FAILURE(hr);

    if (FAILED(hr = CreateEscapedDN(pszUNCName, &pszUNCNameSearch))) {
        dwRet = SCODE_CODE(hr);
        goto error;
    }

    StringCchPrintf(szSearchPattern, COUNTOF(szSearchPattern), L"(&(objectClass=printQueue)(uNCName=%ws))", pszUNCNameSearch);

    hr = pDSSearch->ExecuteSearch(
         szSearchPattern,
         pszAttributes,
         sizeof(pszAttributes)/sizeof *pszAttributes,
         &hSearchHandle);
    BAIL_ON_FAILURE(hr);


    hr = pDSSearch->GetNextRow(hSearchHandle);
    BAIL_ON_FAILURE(hr);


    while (hr != S_ADS_NOMORE_ROWS) {

        hr = pDSSearch->GetColumn(
                 hSearchHandle,
                 L"ADsPath",
                 &ADsPath
                 );

        if (hr == S_OK) {

            hr = pDSSearch->GetColumn(
                     hSearchHandle,
                     L"UNCName",
                     &UNCName
                     );

            if (hr == S_OK) {

                switch (dwAction) {
                    case PUBLISHPRINTER_QUERY:
                    {
                        WCHAR szDuplicateFormat[MAX_PATH];
                        WCHAR szBoxTitle[MAX_PATH];
                        
                        if (LoadString(hInst, IDS_DUPLICATE_PRINTQUEUE,       szDuplicateFormat, COUNTOF(szDuplicateFormat)) &&
                            LoadString(hInst, IDS_DUPLICATE_PRINTQUEUE_TITLE, szBoxTitle,        COUNTOF(szDuplicateFormat)))
                        {
                            PWSTR pszCanonicalSource = NULL;
                            PWSTR pszCanonicalTarget = NULL;
                            PWSTR pszDuplicate       = NULL;

                            FQDN2Canonical(ADsPath.pADsValues->DNString, &pszCanonicalSource);
                            FQDN2Canonical(pszTargetDN, &pszCanonicalTarget);

                            PWSTR pszOne = ADsPath.pADsValues->DNString;
                            PWSTR pszTwo = pszTargetDN;
                            
                            if (pszCanonicalSource && pszCanonicalTarget) 
                            {
                                pszOne = pszCanonicalSource;
                                pszTwo = pszCanonicalTarget;
                            } 
                            
                            nSize = 1 + wcslen(szDuplicateFormat) + wcslen(pszOne) + wcslen(pszTwo);
                            
                            if (pszDuplicate = (PWSTR) AllocSplMem(nSize * sizeof(WCHAR))) 
                            {
                                StringCchPrintf(pszDuplicate, nSize, szDuplicateFormat, pszOne, pszTwo);

                                dwRet = ERROR_SUCCESS;
                            }
                            else
                            {
                                dwRet = GetLastError();                                                                        
                            }
    
                            FreeSplStr(pszCanonicalSource);
                            FreeSplStr(pszCanonicalTarget);

                            if (dwRet == ERROR_SUCCESS)
                            {
                                dwRet = MessageBox(hwnd, pszDuplicate, szBoxTitle, MB_YESNO);

                                bDeleteDuplicate = (dwRet == IDYES);
                                dwRet = (dwRet == IDYES) ? ERROR_SUCCESS : ERROR_CANCELLED;
                            }

                            FreeSplMem(pszDuplicate);
                        }
                        else
                        {
                            dwRet = GetLastError();                            
                        }

                        break;
                    }

                    case PUBLISHPRINTER_DELETE_DUPLICATES:
                    {
                        bDeleteDuplicate = TRUE;
                        break;
                    }

                    case PUBLISHPRINTER_FAIL_ON_DUPLICATE:
                    {
                        bDeleteDuplicate = FALSE;

                        if (ppszObjectDN) {
                            if (!(*ppszObjectDN = AllocGlobalStr(ADsPath.pADsValues->DNString))) {
                                dwRet = GetLastError();
                                goto error;
                            }
                        }

                        dwRet = ERROR_FILE_EXISTS;
                        break;
                    }

                    case PUBLISHPRINTER_IGNORE_DUPLICATES:
                    {
                        bDeleteDuplicate = FALSE;
                        break;
                    }
                
                    default:
                    {
                        bDeleteDuplicate = FALSE;
                        dwRet = ERROR_INVALID_PARAMETER;
                        break;
                    }
                }

                if (bDeleteDuplicate) {
                    hr = DeleteDSObject(ADsPath.pADsValues->DNString);                    

                    if ( hr == ERROR_DS_NO_SUCH_OBJECT ) {
                        hr = S_OK;
                    }
                }

                pDSSearch->FreeColumn(&UNCName);
            }

            pDSSearch->FreeColumn(&ADsPath);
        }

        if (dwRet != ERROR_SUCCESS || hr != S_OK)
                goto error;

        hr = pDSSearch->GetNextRow(hSearchHandle);
        BAIL_ON_FAILURE(hr);
    }


    hr = S_OK;


error:

    if (hr != S_OK)
        dwRet = ERROR_DS_UNAVAILABLE;

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    if (pszUNCNameSearch)
        FreeSplMem(pszUNCNameSearch);

    if (pDSSearch)
        pDSSearch->Release();

    if (pszSearchRoot)
        FreeSplMem(pszSearchRoot);    

    return dwRet;
}



DWORD
MovePrintQueue(
    PCWSTR    pszObjectGUID,
    PCWSTR    pszNewContainer,    // Container path
    PCWSTR    pszNewCN            // Object CN
)
{
    PWSTR            pszCurrentContainer = NULL;
    PWSTR            pszCurrentCN = NULL;
    HRESULT            hr;
    IADsContainer    *pADsContainer = NULL;
    IDispatch        *pNewObject = NULL;


    // Get PublishPoint from GUID
    hr = GetPublishPointFromGUID(pszObjectGUID, &pszCurrentContainer, &pszCurrentCN);
    BAIL_ON_FAILURE(hr);

    if (pszCurrentContainer) {
        // Get container
        hr = ADsGetObject( pszCurrentContainer, IID_IADsContainer,    (void **) &pADsContainer);
        BAIL_ON_FAILURE(hr);


        // Move PrintQueue
        if (wcscmp(pszCurrentContainer, pszNewContainer)) {
            hr = pADsContainer->MoveHere((PWSTR) pszNewContainer, (PWSTR) pszNewCN, &pNewObject);
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    if (pszCurrentContainer)
        FreeSplMem(pszCurrentContainer);

    if (pszCurrentCN)
        FreeSplMem(pszCurrentCN);

    if (pADsContainer)
        pADsContainer->Release();

    if (pNewObject)
        pNewObject->Release();

    return hr;
}


HRESULT
GetPublishPointFromGUID(
    PCWSTR   pszObjectGUID,
    PWSTR   *ppszDN,
    PWSTR   *ppszCN
)
{
    DWORD dwRet, nBytes, nChars;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    HANDLE hDS = NULL;
    PWSTR psz;
    HRESULT hr = S_OK;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;


    // Get Publish Point

    if (ppszDN) {

        pNames[0] = (PWSTR) pszObjectGUID;
        pNames[1] = NULL;

        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
                dwRet = ERROR_PATH_NOT_FOUND;
            else
                dwRet = pDNR->rItems[0].status;

            goto error;
        }


        // Separate DN into CN & PublishPoint
        // pDNR has form: CN=CommonName,DN...

        hr = FQDN2CNDN(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszCN, ppszDN);
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

    if (FAILED(hr)) {
        FreeSplMem(*ppszCN);
        FreeSplMem(*ppszDN);
        *ppszCN = *ppszDN = NULL;
    }

    return hr;
}


DWORD
Bind2DS(
    HANDLE                  *phDS,
    DOMAIN_CONTROLLER_INFO  **ppDCI,
    ULONG                   Flags
)
{
    DWORD dwRet;

    dwRet = DsGetDcName(NULL, NULL, NULL, NULL, Flags, ppDCI);
    if (dwRet == ERROR_SUCCESS) {

        if ((*ppDCI)->Flags & DS_DS_FLAG) {

            dwRet = DsBind (NULL, (*ppDCI)->DomainName, phDS);
            if (dwRet != ERROR_SUCCESS) {

                NetApiBufferFree(*ppDCI);
                *ppDCI = NULL;

                if (!(Flags & DS_FORCE_REDISCOVERY)) {
                    dwRet = Bind2DS(phDS, ppDCI, DS_FORCE_REDISCOVERY | Flags);
                }
            }
        } else {
            NetApiBufferFree(*ppDCI);
            *ppDCI = NULL;
            dwRet = ERROR_CANT_ACCESS_DOMAIN_INFO;
        }
    }

    return dwRet;
}



HRESULT
FQDN2CNDN(
    PWSTR   pszDCName,
    PWSTR   pszFQDN,
    PWSTR   *ppszCN,
    PWSTR   *ppszDN
)
{
    IADs    *pADs = NULL;
    PWSTR   pszCN = NULL;
    PWSTR   pszDN = NULL;
    PWSTR   pszLDAPPath = NULL;
    HRESULT hr;

    // Get LDAP path to object
    hr = BuildLDAPPath(pszDCName, pszFQDN, &pszLDAPPath);
    BAIL_ON_FAILURE(hr);

    // Get DN
    hr = ADsGetObject(pszLDAPPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->get_Parent(&pszDN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszDN = AllocSplStr(pszDN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    // Get CN
    hr = pADs->get_Name(&pszCN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszCN = AllocSplStr(pszCN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs)
        pADs->Release();

    if (pszCN)
        SysFreeString(pszCN);

    if (pszDN)
        SysFreeString(pszDN);

    FreeSplStr(pszLDAPPath);

    if (FAILED(hr)) {
        FreeSplStr(*ppszCN);
        FreeSplStr(*ppszDN);
    }

    return hr;
}


HRESULT
BuildLDAPPath(
    PWSTR   pszDC,
    PWSTR   pszFQDN,
    PWSTR   *ppszLDAPPath
)
{
    DWORD   nBytes;
    HRESULT hr;

    // LDAP:// + pDCName + / + pName + 1
    nBytes = (wcslen(pszDC) + wcslen(pszFQDN) + 9)*sizeof(WCHAR);

    if (!(*ppszLDAPPath = (PWSTR) AllocSplMem(nBytes))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = StringCbPrintf(*ppszLDAPPath, nBytes, L"LDAP://%ws/%ws", pszDC,pszFQDN);

error:

    return hr;
}    

DWORD
UNC2Printer(
    PCWSTR pszUNC,
    PWSTR *ppszPrinter
)
{
    PWSTR psz;
    
    if (!pszUNC || pszUNC[0] != L'\\' || pszUNC[1] != L'\\')
        return ERROR_INVALID_PARAMETER;

    if(!(psz = wcsrchr(pszUNC + 2, L'\\')))
        return ERROR_INVALID_PARAMETER;

    if (!(*ppszPrinter = (PWSTR) AllocSplStr(psz + 1)))
        return GetLastError();

    return ERROR_SUCCESS;
}

DWORD
UNC2Server(
    PCWSTR pszUNC,
    PWSTR *ppszServer
)
{
    PWSTR psz;
    DWORD cb;
    DWORD nChars;

    if (!pszUNC || pszUNC[0] != L'\\' || pszUNC[1] != L'\\')
        return ERROR_INVALID_PARAMETER;

    if(!(psz = wcschr(pszUNC + 2, L'\\')))
        return ERROR_INVALID_PARAMETER;

    cb = (DWORD) ((ULONG_PTR) psz - (ULONG_PTR) pszUNC + sizeof *psz);

    if (!(*ppszServer = (PWSTR) AllocSplMem(cb)))
        return GetLastError();


    nChars = (DWORD) (psz - pszUNC);
    wcsncpy(*ppszServer, pszUNC, nChars);
    (*ppszServer)[nChars] = L'\0';

    return ERROR_SUCCESS;
}


//  Utility routine to report if a printer is color or monochrome

BOOL
ThisIsAColorPrinter(
    LPCTSTR lpstrName
)
{
    HANDLE      hPrinter = NULL;
    LPTSTR      lpstrMe = const_cast <LPTSTR> (lpstrName);
    BOOL        bReturn = FALSE;
    LPDEVMODE   lpdm = NULL;
    long        lcbNeeded;

    if  (!OpenPrinter(lpstrMe, &hPrinter, NULL)) {
        goto error;
    }


    //  First, use DocumentProperties to find the correct DEVMODE size- we
    //  must use the DEVMODE to force color on, in case the user's defaults
    //  have turned it off...

    lcbNeeded = DocumentProperties(NULL, hPrinter, lpstrMe, NULL, NULL, 0);
    if  (lcbNeeded <= 0) {
        goto error;
    }

    lpdm = (LPDEVMODE) AllocSplMem(lcbNeeded);
    if (lpdm) {

        lpdm->dmSize = sizeof(DEVMODE);
        lpdm->dmFields = DM_COLOR;
        lpdm->dmColor = DMCOLOR_COLOR;

        if (IDOK == DocumentProperties(NULL, hPrinter, lpstrMe, lpdm, lpdm,
            DM_IN_BUFFER | DM_OUT_BUFFER)) {

            //  Finally, we can create the DC!
            HDC hdcThis = CreateDC(NULL, lpstrName, NULL, lpdm);

            if  (hdcThis) {
                bReturn =  2 < (unsigned) GetDeviceCaps(hdcThis, NUMCOLORS);
                DeleteDC(hdcThis);
            }
        }
    }


error:

    FreeSplMem(lpdm);

    if (hPrinter)
        ClosePrinter(hPrinter);

    return  bReturn;
}




HRESULT
DeleteDSObject(
    PWSTR    pszADsPath
)
{
    BSTR             bstrCommonName = NULL;
    PWSTR            pszParent = NULL;
    PWSTR            pszCN = NULL;
    PWSTR            pszLDAPPath = NULL;
    IADs             *pADs = NULL;
    IADsContainer    *pContainer = NULL;
    DWORD            cch;
    HRESULT          hr;
    DWORD            nSize;

    if(pszADsPath && !_wcsnicmp(pszADsPath , L"GC://" , 5)){

        //
        // Build LDAP://..... path from GC://.... path
        // 3 comes from len(LDAP) - len(GC) + len(string_terminator)
        //
        nSize = (wcslen(pszADsPath) + 3)* sizeof(WCHAR);                        
        if (!(pszLDAPPath = (PWSTR) AllocSplMem(nSize))) {
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                goto error;
        }
        
        if (FAILED(hr = StringCbPrintf(pszLDAPPath, nSize, L"LDAP%ws", pszADsPath + 2)))
        {
            goto error;
        }
    
    }

    // Get PrintQueue object
    hr = ADsGetObject(pszLDAPPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);


    // Get the CommonName & don't forget the "CN="
    hr = get_BSTR_Property(pADs, L"cn", &bstrCommonName);
    BAIL_ON_FAILURE(hr);

    cch = (SysStringLen(bstrCommonName) + 4);

    if (!(pszCN = (PWSTR) AllocSplMem(cch * sizeof(WCHAR)))) {
        hr = dw2hr(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    StrNCatBuff(pszCN, cch, L"CN=", bstrCommonName, NULL);


    // Get the Parent ADsPath
    hr = pADs->get_Parent(&pszParent);
    BAIL_ON_FAILURE(hr);


    // Get the Parent object
    hr = ADsGetObject(  pszParent,
                        IID_IADsContainer,
                        (void **) &pContainer);
    BAIL_ON_FAILURE(hr);

    // Delete the printqueue
    hr = pContainer->Delete(SPLDS_PRINTER_CLASS, pszCN);


error:

    if (pADs)
        pADs->Release();

    if (pContainer)
        pContainer->Release();

    if (bstrCommonName)
        SysFreeString(bstrCommonName);

    if (pszParent)
        SysFreeString(pszParent);

    if (pszCN)
        FreeSplMem(pszCN);

    if(pszLDAPPath)
        FreeSplMem(pszLDAPPath);

    return hr;
}

DWORD
GetCommonName(
    HANDLE hPrinter,
    PWSTR *ppszCommonName
)
{
    DWORD           nBytes;
    PWSTR           psz;
    PPRINTER_INFO_2 pInfo2 = NULL;
    DWORD           cbNeeded;
    DWORD           dwRet;
    PWSTR           pszServerName, pszPrinterName;


    // Get Server & Share names
    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, 0, &cbNeeded)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                dwRet = GetLastError();
                goto error;
        }

        if (!(pInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded))) {
                dwRet = GetLastError();
                goto error;
        }

        if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, cbNeeded, &cbNeeded)) {
                dwRet = GetLastError();
                goto error;
        }
        pszServerName = pInfo2->pServerName;
        if (!pszServerName) {
            DBGMSG(DBG_ERROR,("GetPrinter returned NULL ServerName"));
            dwRet = ERROR_INVALID_DATA;
            goto error;
        }

        pszPrinterName = pInfo2->pShareName ? pInfo2->pShareName : pInfo2->pPrinterName;

    } else {
        // We should never get here.  If we do, something is wrong
        // with the server and we have no meaningful error to report,
        // so just claim invalid data.
        DBGMSG(DBG_ERROR,("INVALID GetPrinter return"));
        dwRet = ERROR_INVALID_DATA;
        goto error;
    }

    // "CN=Server-Printer"
    nBytes = (wcslen(pszPrinterName) + wcslen(pszServerName) + 5)*sizeof(WCHAR);
    if (!(*ppszCommonName = psz = (PWSTR) AllocSplMem(nBytes))) {
        dwRet = GetLastError();
        goto error;
    }

    // CN=
    StringCbCopy(psz, nBytes, L"CN=");

    // Server
    for(psz += 3, pszServerName += 2 ; *pszServerName    ; ++psz, ++pszServerName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszServerName) ? TEXT('_') : *pszServerName;
    }
    *psz = L'-';

    // Printer
    for(++psz; *pszPrinterName ; ++psz, ++pszPrinterName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszPrinterName) ? TEXT('_') : *pszPrinterName;
    }

    // NULL
    *psz = *pszPrinterName;

    // DS only allows 64 characters in CN attribute, so shorten this if needed
    if (wcslen(pszPrinterName) > 62)
        pszPrinterName[63] = NULL;


error:

    FreeSplMem(pInfo2);

    return ERROR_SUCCESS;
}


PWSTR
AllocGlobalStr(
    PWSTR pszIn
)
{
    DWORD cb;
    PWSTR pszOut = NULL;

    if (!pszIn)
        return NULL;

    cb = (wcslen(pszIn) + 1)*sizeof *pszIn;

    if (pszOut = (PWSTR) GlobalAlloc(GMEM_FIXED, cb))
    {
        StringCbCopy(pszOut, cb, pszIn);
    }

    return pszOut;
}

VOID
FreeGlobalStr(
    PWSTR pszIn
)
{
    if (pszIn)
        GlobalFree(pszIn);
}




DWORD
GetADsPathFromGUID(
    PCWSTR   pszObjectGUID,
    PWSTR   *ppszDN
)
{
    DWORD dwRet, nBytes, nChars;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    HANDLE hDS = NULL;
    PWSTR psz;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;


    // Get Publish Point

    if (ppszDN) {

        pNames[0] = (PWSTR) pszObjectGUID;
        pNames[1] = NULL;

        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
                dwRet = ERROR_PATH_NOT_FOUND;
            else
                dwRet = pDNR->rItems[0].status;

            goto error;
        }

        // LDAP:// + pDCName + / + pName + 1
        nBytes = (wcslen(pDCI->DomainControllerName + 2) + 
                  wcslen(pDNR->rItems[0].pName) + 9)*sizeof(WCHAR);

        if (!(*ppszDN = (PWSTR) AllocSplMem(nBytes))) {
            dwRet = GetLastError();
            goto error;
        }

        StringCbPrintf(*ppszDN, nBytes, L"LDAP://%ws/%ws", pDCI->DomainControllerName + 2,pDNR->rItems[0].pName);
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (dwRet != ERROR_SUCCESS) {
        FreeSplMem(*ppszDN);
        *ppszDN = NULL;
    }

    return dwRet;
}



PWSTR
GetDNWithServer(
    PCWSTR  pszDNIn
)
{
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    DWORD                   nBytes;
    PWSTR                   pszDNOut = NULL;
    DWORD                   dwRet;

    // Convert pszDNIn into a DN with the DC name, if it isn't already there

    // Check for existing DC name or badly formed name
    if (wcsncmp(pszDNIn, L"LDAP://", 7) || wcschr(pszDNIn + 7, L'/'))
        goto error;

    // Get DC name
    dwRet = DsGetDcName(NULL, NULL, NULL, NULL, 0, &pDCI);
    if (dwRet != ERROR_SUCCESS) {
        goto error;
    }


    // Build name
    // LDAP:// + pDCName + / + pName + 1
    nBytes = (wcslen(pDCI->DomainControllerName + 2) + 
              wcslen(pszDNIn + 7) + 9)*sizeof(WCHAR);

    if (!(pszDNOut = (PWSTR) AllocSplMem(nBytes)))
        goto error;

    StringCbPrintf(pszDNOut, nBytes, L"LDAP://%ws/%ws", pDCI->DomainControllerName + 2, pszDNIn + 7);


error:

    if (pDCI)
        NetApiBufferFree(pDCI);

    return pszDNOut;
}


DWORD
hr2dw(
    HRESULT hr
)
{
    if (SUCCEEDED(hr))
        return ERROR_SUCCESS;

    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        return HRESULT_CODE(hr);

    if (hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        return ERROR_DS_UNAVAILABLE;

    return hr;
}



PWSTR
DelimString2MultiSz(
    PWSTR pszIn,
    WCHAR wcDelim
)
{
    DWORD cb;
    PWSTR pszOut = NULL;

    // pszIn looks like L"xxx,xxxx,xxx,xxx"
    // the output looks like L"xxx0xxxx0xxx0xxx00"
    // Replace all wcDelim characters with NULLs & add a NULL

    if (!pszIn || !*pszIn)
        return NULL;

    cb = (wcslen(pszIn) + 2)*sizeof *pszIn;

    pszOut = (PWSTR) AllocSplMem(cb);

    if (pszOut) {

        DWORD i;

        for (i = 0 ; pszIn[i] ; ++i) {
            pszOut[i] = (pszIn[i] == wcDelim) ? L'\0' : pszIn[i];
        }
        pszOut[i] = pszOut[i + 1] = L'\0';
    }

    return pszOut;
}


HRESULT
GetPrinterInfo2(
    HANDLE          hPrinter,
    PPRINTER_INFO_2 *ppInfo2
)
{
    HRESULT hr = S_OK;
    DWORD   cbNeeded;

    // Get PRINTER_INFO_2 properties
    if (!GetPrinter(hPrinter, 2, (PBYTE) *ppInfo2, 0, &cbNeeded)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            hr = dw2hr(GetLastError());
            goto error;
        }

        if (!(*ppInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded))) {
            hr = dw2hr(GetLastError());
            goto error;
        }
    
        if (!GetPrinter(hPrinter, 2, (PBYTE) *ppInfo2, cbNeeded, &cbNeeded)) {
            hr = dw2hr(GetLastError());
            goto error;
        }
    }

error:
    
    return hr;
}



DWORD
FQDN2Canonical(
    PWSTR pszIn,
    PWSTR *ppszOut
)
{
    DWORD                               dwRet = ERROR_SUCCESS;
    DS_NAME_RESULT                      *pDNR = NULL;
    PWSTR                               pNames[2];
    
    *ppszOut = NULL;

    if (wcslen(pszIn) < 8) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    pNames[0] = pszIn + 7;  // Input string is LDAP://CN=...  Strip off the LDAP:// portion
    pNames[1] = NULL;

    if (!(DsCrackNames(
                    INVALID_HANDLE_VALUE,
                    DS_NAME_FLAG_SYNTACTICAL_ONLY,
                    DS_FQDN_1779_NAME,
                    DS_CANONICAL_NAME,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    }

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
            dwRet = ERROR_PATH_NOT_FOUND;
        else
            dwRet = pDNR->rItems[0].status;

        goto error;
    }

    if (!(*ppszOut = AllocSplStr(pDNR->rItems[0].pName)))
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
    
error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    return dwRet;
}


BOOL
DevCapMultiSz(
    PWSTR   pszUNCName,
    IADs    *pPrintQueue,
    WORD    fwCapability,
    DWORD   dwElementBytes,
    PWSTR   pszAttributeName
)
{
    DWORD dwResult, cbBytes;
    PWSTR pszDevCapBuffer = NULL;
    PWSTR pszRegData = NULL;
    HRESULT hr;


    _try {
        dwResult = DeviceCapabilities(  pszUNCName,
                                        NULL,
                                        fwCapability,
                                        NULL,
                                        NULL);

        if (dwResult != GDI_ERROR) {
            pszDevCapBuffer = (PWSTR) AllocSplMem(dwResult*dwElementBytes*sizeof(WCHAR));

            if (pszDevCapBuffer) {
                dwResult = DeviceCapabilities(  pszUNCName,
                                                NULL,
                                                fwCapability,
                                                pszDevCapBuffer,
                                                NULL);

                if (dwResult != GDI_ERROR) {
                    if (!(pszRegData = DevCapStrings2MultiSz(pszDevCapBuffer, dwResult, dwElementBytes, &cbBytes))) {
                        dwResult = GDI_ERROR;
                    }
                }
            } else {
                dwResult = GDI_ERROR;
            }
        }
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }

    if (dwResult != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            pszAttributeName,
                            REG_MULTI_SZ,
                            (PBYTE) pszRegData);

        if (FAILED(hr)) {
            SetLastError(HRESULT_CODE(hr));
            dwResult = GDI_ERROR;
        }
    }

    FreeSplStr(pszDevCapBuffer);
    FreeSplStr(pszRegData);
    
    return dwResult != GDI_ERROR;
}


PWSTR
DevCapStrings2MultiSz(
    PWSTR   pszDevCapString,
    DWORD   nDevCapStrings,
    DWORD   dwDevCapStringLength,
    DWORD   *pcbBytes
)
{
    DWORD   i, cbBytes, cbSize;
    PWSTR   pszMultiSz = NULL;
    PWSTR   pStr;


    if (!pszDevCapString || !pcbBytes)
        return NULL;

    *pcbBytes = 0;

    //
    // Devcap buffers may not be NULL terminated
    //
    cbBytes = (nDevCapStrings*(dwDevCapStringLength + 1) + 1)*sizeof(WCHAR);


    //
    // Allocate and copy
    //
    if (pszMultiSz = (PWSTR) AllocSplMem(cbBytes)) {
        for(i = 0, pStr = pszMultiSz, cbBytes = 0 ; i < nDevCapStrings ; ++i, pStr += cbSize, cbBytes +=cbSize ) {
            wcsncpy(pStr, pszDevCapString + i*dwDevCapStringLength, dwDevCapStringLength);
            cbSize = *pStr ? wcslen(pStr) + 1 : 0;
        }
        *pStr = L'\0';
        *pcbBytes = (cbBytes + 1) * sizeof(WCHAR);
    }

    return pszMultiSz;
}


HRESULT
MachineIsInMyForest(
    PWSTR   pszMachineName
)
{
    DWORD                               dwRet;
    HRESULT                             hr;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pMachineRole = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pMyRole = NULL;

    dwRet = DsRoleGetPrimaryDomainInformation(  pszMachineName,
                                                DsRolePrimaryDomainInfoBasic, 
                                                (PBYTE *) &pMachineRole);
    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        goto error;
    }

    dwRet = DsRoleGetPrimaryDomainInformation(  NULL,
                                                DsRolePrimaryDomainInfoBasic, 
                                                (PBYTE *) &pMyRole);
    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        goto error;
    }

    dwRet = DnsNameCompare_W(pMachineRole->DomainForestName, pMyRole->DomainForestName);
    hr = MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIN32, dwRet);


error:

    if (pMachineRole)
        DsRoleFreeMemory((PVOID) pMachineRole);

    if (pMyRole)
        DsRoleFreeMemory((PVOID) pMyRole);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\defprn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    defprn.c

Abstract:

    Default printer.

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "defprn.h"

//
// The buffer size needed to hold the maximum printer name.
//
enum { kPrinterBufMax_  = MAX_UNC_PRINTER_NAME + 1 };

/*++

Name:

    IsPrinterDefault

Description:

    The IsPrinterDefault function checks if the specified
    printer is the default printer.  If the printer name
    specified is NULL or the NULL string then it returns
    success if there is a default printer.

Arguments:

    pszPrinter - Pointer a zero terminated string that
                 contains the printer name or NULL or the
                 NULL string.

Return Value:

    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero. To get
    extended error information, call GetLastError.

Remarks:

    If a NULL is passed as the printer name this function
    will indicate if there is any default printer set.

--*/
BOOL
IsPrinterDefaultW(
    IN LPCTSTR  pszPrinter
    )
{
    BOOL    bRetval         = FALSE;
    DWORD   dwDefaultSize   = kPrinterBufMax_;
    PTSTR   pszDefault      = NULL;

    pszDefault = AllocMem(dwDefaultSize * sizeof(TCHAR));

    if (pszDefault)
    {
        //
        // Get the default printer.
        //
        bRetval = GetDefaultPrinterW( pszDefault, &dwDefaultSize );

        if( bRetval )
        {
            if( pszPrinter && *pszPrinter )
            {
                //
                // Check for a match.
                //
                bRetval =  !_tcsicmp( pszDefault, pszPrinter ) ? TRUE : FALSE;
            }
            else
            {
                bRetval = TRUE;
            }
        }
    }
    else
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    FreeMem(pszDefault);

    return bRetval;
}


/*++

Name:

    GetDefaultPrinter

Description:

    The GetDefaultPrinter function retrieves the printer
    name of the current default printer.

Arguments:

    pBuffer     - Points to a buffer to receive the null-terminated
                  character string containing the default printer name.
                  This parameter may be null if the caller want the size of
                  default printer name.

    pcchBuffer   - Points to a variable that specifies the maximum size,
                  in characters, of the buffer. This value should be
                  large enough to contain 2 + INTERNET_MAX_HOST_NAME_LENGTH
                  + 1 MAX_PATH + 1 characters.

Return Value:

    If the function succeeds, the return value is nonzero and
    the variable pointed to by the pnSize parameter contains the
    number of characters copied to the destination buffer,
    including the terminating null character.

    If the function fails, the return value is zero. To get extended
    error information, call GetLastError.

Notes:

    If this function fails with a last error of ERROR_INSUFFICIENT_BUFFER
    the variable pointed to by pcchBuffer is returned with the number of
    characters needed to hold the printer name including the
    terminating null character.

--*/
BOOL
GetDefaultPrinterW(
    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
    )
{
    BOOL    bRetval     = FALSE;
    LPTSTR  psz         = NULL;
    UINT    uLen        = 0;
    PTSTR   pszDefault  = NULL;
    UINT    cchDefault  = kPrinterBufMax_+MAX_PATH;

    //
    // Validate the size parameter.
    //
    if( !pcchBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return bRetval;
    }

    //
    // Allocate the temp default printer buffer from the heap.
    //
    pszDefault = AllocMem(cchDefault * sizeof(TCHAR));

    if (!pszDefault)
    {
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: Not enough memory to allocate default printer buffer.\n" ) );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return bRetval;
    }

    //
    // Get the devices key, which is the default device or printer.
    //
    if( DefPrnGetProfileString( szWindows, szDevice, pszDefault, cchDefault ) )
    {
        //
        // The string is returned in the form.
        // "printer_name,winspool,Ne00:" now convert it to
        // printer_name
        //
        psz = _tcschr( pszDefault, TEXT( ',' ));

        //
        // Set the comma to a null.
        //
        if( psz )
        {
            *psz = 0;

            //
            // Check if the return buffer has enough room for the printer name.
            //
            uLen = _tcslen( pszDefault );

            if( uLen < *pcchBuffer && pszBuffer )
            {
                //
                // Copy the default printer name to the prvided buffer.
                //
                StringCchCopy(pszBuffer, *pcchBuffer, pszDefault);

                bRetval = TRUE;

                DBGMSG( DBG_TRACE,( "GetDefaultPrinter: Success " TSTR "\n", pszBuffer ) );
            }
            else
            {
                DBGMSG( DBG_WARN,( "GetDefaultPrinter: buffer too small.\n" ) );
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }

            //
            // Return back the size of the default printer name.
            //
            *pcchBuffer = uLen + 1;
        }
        else
        {
            DBGMSG( DBG_WARN,( "GetDefaultPrinter: comma not found in printer name in devices section.\n" ) );
            SetLastError( ERROR_INVALID_NAME );
        }
    }
    else
    {
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: failed with %d Last error %d.\n", bRetval, GetLastError() ) );
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: No default printer.\n" ) );
        SetLastError( ERROR_FILE_NOT_FOUND );
    }

    //
    // Release any allocated memory, note FreeMem deals with a NULL pointer.
    //
    FreeMem(pszDefault);

    return bRetval;
}

/*++

Name:

    SetDefaultPrinter

Description:

    The SetDefaultPrinter function set the printer name to
    be used as the default printer.

Arguments:

    pPrinter    - Points to a null-terminated character string
                  that specifies the name of the default printer.
                  This parameter may be NULL or the NULL string in
                  which case this function will set the first printer
                  enumerated from the print sub system as the default
                  printer, if a default printer does not already exists.

Return Value:

    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero. To get extended
    error information, call GetLastError.

--*/
BOOL
SetDefaultPrinterW(
    IN LPCTSTR pszPrinter
    )
{
    PTSTR pszDefault    = NULL;
    PTSTR pszAnyPrinter = NULL;
    PTSTR pszBuffer     = NULL;
    UINT  cchDefault    = kPrinterBufMax_;
    UINT  cchAnyPrinter = kPrinterBufMax_;
    BOOL  bRetval       = FALSE;

    //
    // This calculation is large to accomodate the max printer name
    // plus the comma plus the processor name and port name.
    //
    UINT  cchBuffer     = kPrinterBufMax_+kPrinterBufMax_+1;

    //
    // Avoid broadcasts as much as possible.  See if the printer
    // is already the default, and don't do anything if it is.
    //
    if( IsPrinterDefaultW( pszPrinter ) )
    {
        DBGMSG( DBG_TRACE, ( "SetDefaultPrinter: " TSTR " already the default printer.\n", pszPrinter ));
        bRetval = TRUE;
        goto Cleanup;
    }

    //
    // Allocate the temp default printer buffer from the heap.
    //
    pszDefault      = AllocMem(cchDefault * sizeof(TCHAR));
    pszAnyPrinter   = AllocMem(cchAnyPrinter * sizeof(TCHAR));
    pszBuffer       = AllocMem(cchBuffer * sizeof(TCHAR));

    if (!pszDefault || !pszAnyPrinter || !pszBuffer)
    {
        DBGMSG( DBG_TRACE,( "SetDefaultPrinter: Not enough memory for temp buffers.\n" ) );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto Cleanup;
    }

    //
    // If the printer name was not specified, get any printer from the devices section.
    //
    if( !pszPrinter || !*pszPrinter )
    {
        //
        // A printer name was not specified i.e. a NULL name or NULL string was passed then fetch
        // the first printer from the devices section and make this the default printer.
        //
        if( !DefPrnGetProfileString( szDevices, NULL, pszAnyPrinter, cchAnyPrinter ) )
        {
            DBGMSG( DBG_WARN, ( "SetDefaultPrinter: DefPrnGetProfileString failed, last error %d any printer not available.\n", GetLastError() ) );
            SetLastError( ERROR_INVALID_PRINTER_NAME );
            goto Cleanup;
        }
        else
        {
            pszPrinter = pszAnyPrinter;
        }
    }
    else
    {
        //
        // If the given name is not in the devices list then this function may have been passed
        // either a local share name a fully qualified local printer name a fully qualified
        // printer share name
        //
        if( !DefPrnGetProfileString( szDevices, pszPrinter, pszDefault, cchDefault ) )
        {
            //
            // Get the actual printer name, see bGetActualPrinterName for details.
            //
            if( bGetActualPrinterName( pszPrinter, pszAnyPrinter, &cchAnyPrinter ))
            {
                //
                // Point to the actual printer name.
                //
                pszPrinter = pszAnyPrinter;

                //
                // Avoid broadcasts as much as possible.  See if the printer
                // is already the default, and don't do anything if it is.
                //
                if( IsPrinterDefaultW( pszPrinter ) )
                {
                    DBGMSG( DBG_TRACE, ( "SetDefaultPrinter: " TSTR " already the default printer.\n", pszPrinter ));
                    bRetval = TRUE;
                    goto Cleanup;
                }
            }
            else
            {
                DBGMSG( DBG_WARN, ( "SetDefaultPrinter: bGetActualPrinterName failed, last error %d " TSTR "\n", GetLastError(), pszPrinter ) );

                //
                // bGetActualPrinterName sets the last error on failure.
                //
                goto Cleanup;
            }
        }
    }

    //
    // Get the default string and check if the provided printer name is valid.
    //
    if( !DefPrnGetProfileString( szDevices, pszPrinter, pszDefault, cchDefault ) )
    {
        DBGMSG( DBG_WARN, ( "SetDefaultPrinter: DefPrnGetProfileString failed, last error %d " TSTR " not in devices section.\n", GetLastError(), pszPrinter ) );
        SetLastError( ERROR_INVALID_PRINTER_NAME );
        goto Cleanup;
    }

    //
    // Build the default printer string.  This call should not fail since we have allocated
    // pszBuffer to a size that should contain the printer name plus the comma plus the port name.
    //
    if (StrNCatBuff( pszBuffer,
                     cchBuffer,
                     pszPrinter,
                     szComma,
                     pszDefault,
                     NULL ) != ERROR_SUCCESS)
    {
        //
        // Set the last error to some error value, however, it cannot be set to ERROR_INSUFFICIENT_BUFFER
        // this error code implies the caller provided buffer is too small.  StrNCatBuff would only fail because
        // because of some internal error or the registry was hacked with a really large printer name.
        //
        DBGMSG( DBG_ERROR, ( "SetDefaultPrinter: Buffer size too small, this should not fail.\n" ) );
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }

    //
    // Set the default printer string in the registry.
    //
    if( !DefPrnWriteProfileString( szWindows, szDevice, pszBuffer ) )
    {
        DBGMSG( DBG_WARN, ( "SetDefaultPrinter: WriteProfileString failed, last error %d.\n", GetLastError() ) );
        SetLastError( ERROR_CANTWRITE );
        goto Cleanup;
    }

    //
    // Tell the world and make everyone flash.
    //
    SendNotifyMessage( HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM)szWindows );

    bRetval = TRUE;

    DBGMSG( DBG_TRACE, ( "SetDefaultPrinter: Success " TSTR "\n", pszBuffer ) );

Cleanup:

    //
    // Release any allocated memory, note FreeMem deals with a NULL pointer.
    //
    FreeMem(pszDefault);
    FreeMem(pszAnyPrinter);
    FreeMem(pszBuffer);

    return bRetval;
}

/*++

Name:

    bGetActualPrinterName

Description:

    This routine converts the given printer name or printer name alias to
    the actual printer name.

Arguments:

    pszPrinter  - Points to a null-terminated character string
                  that specifies the name of printer.

    pszBuffer   - pointer to a buffer that recieves the actual
                  printer name on return if this function is successful.

    pcchBuffer  - Points to a variable that specifies the maximum size,
                  in characters of pszBuffer on input, on output this
                  argument contains the number of characters copied into
                  pszBuffer, not including the NULL terminator.

Return Value:

    If the function succeeds, the return value TRUE
    If the function fails, the return value is FALSE. Use GetLastError to
    get extended error information.

--*/
BOOL
bGetActualPrinterName(
    IN      LPCTSTR  pszPrinter,
    IN      LPTSTR   pszBuffer,
    IN OUT  UINT     *pcchBuffer
    )
{
    HANDLE  hPrinter    = NULL;
    BOOL    bStatus     = FALSE;

    SPLASSERT( pszPrinter );
    SPLASSERT( pszBuffer );
    SPLASSERT( pcchBuffer );

    //
    // Open the printer for default access, all we need is read.
    //
    bStatus = OpenPrinter( (LPTSTR)pszPrinter, &hPrinter, NULL );

    if (bStatus)
    {
        DWORD           cbNeeded        = 0;
        DWORD           cbReturned      = 0;
        PRINTER_INFO_4  *pInfo          = NULL;

        //
        // Get the printer info 4 size.
        //
        bStatus = GetPrinter( hPrinter, 4, NULL, 0, &cbNeeded );

        if (!bStatus && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Allocate the printer info 4 buffer.
            //
            pInfo = (PRINTER_INFO_4 *)LocalAlloc( LMEM_FIXED, cbNeeded );

            if (pInfo)
            {
                //
                // Get the printer name and attributes to determine if this printer is a local
                // or a remote printer connection.
                //
                bStatus = GetPrinter( hPrinter, 4, (LPBYTE)pInfo, cbNeeded, &cbReturned );

                if (bStatus)
                {
                    DBGMSG( DBG_TRACE, ( "bGetActualPrinterName: Name: " TSTR " Actual: " TSTR "\n", pszPrinter, pInfo->pPrinterName ) );

                    //
                    // Get the printer name, the spooler will strip the local-server
                    // name off the full printer name.
                    //
                    // Given:                       Result:
                    // printer                      printer
                    // sharename                    printer
                    // \\local-server\printer       printer
                    // \\local-server\sharename     printer
                    // \\remote-server\printer      \\remote-server\printer
                    // \\remote-server\sharename    \\remote-server\printer
                    //
                    pszPrinter = pInfo->pPrinterName;

                    //
                    // If we have a valid printer name and the provided buffer is
                    // large enought to hold the printer name then copy the
                    // actual printer name to the provided buffer.
                    //
                    bStatus = !!pszPrinter;

                    if (bStatus)
                    {
                        UINT uLength = _tcslen( pszPrinter );

                        //
                        // Verify there is enough room in the buffer.
                        //
                        if (uLength < *pcchBuffer)
                        {
                            //
                            // Copy the printer name to the provided buffer.
                            //
                            StringCchCopy(pszBuffer, *pcchBuffer, pszPrinter);
                        }
                        else
                        {
                            bStatus = FALSE;
                            SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        }

                        //
                        // Return the real length of the printer name
                        // not including the null terminator.
                        //
                        *pcchBuffer = uLength;
                    }
                }

                LocalFree( pInfo );
            }
        }

        ClosePrinter( hPrinter );
    }

    return bStatus;
}

/*++

Name:

    DefPrnGetProfileString

Description:

    Get the specified string from the users profile.  The uses profile is located
    in the current users hive in the following registry path.

    HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion

Arguments:

    pKey            - pointer to key name to open.
    pValue          - pointer to value to open, may be NULL
    pReturnedString - pointer to buffer where to store string
    nSize           - size of the buffer in characters

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE. Use GetLastError to
    get extended error information.

--*/
BOOL
DefPrnGetProfileString(
    IN PCWSTR   pKey,
    IN PCWSTR   pValue,
    IN PWSTR    pReturnedString,
    IN DWORD    nSize
    )
{
    DWORD   Retval  = ERROR_SUCCESS;
    HKEY    hUser   = NULL;
    HKEY    hKey    = NULL;
    PCWSTR  pPath   = NULL;
    DWORD   cbSize  = 0;

    //
    // Do some basic parameter validation.
    //
    Retval = pKey && pReturnedString ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Build the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        cbSize = nSize * sizeof(*pReturnedString);

        Retval = StrCatAlloc(&pPath, gszUserProfileRegPath, szSlash, pKey, NULL);
    }

    //
    // Open the current user key, handle the case we are running in an inpersonating thread.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegOpenCurrentUser(KEY_READ, &hUser);
    }

    //
    // Open the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegOpenKeyEx(hUser, pPath, 0, KEY_READ, &hKey);
    }

    //
    // Read the value, in the case the value name is null we get the name of the
    // first named value.  Note if there is no named values the RegEnumValue api
    // will return success because it is returning the name if the unnamed value.
    // In this case we fail the call since no data was returned.
    //
    if (Retval == ERROR_SUCCESS)
    {
        if (!pValue)
        {
            Retval = RegEnumValue(hKey, 0, pReturnedString, &nSize, NULL, NULL, NULL, NULL);

            if (Retval == ERROR_SUCCESS && !*pReturnedString)
            {
                Retval = ERROR_NO_DATA;
            }
        }
        else
        {
            Retval = RegQueryValueEx(hKey, pValue, NULL, NULL, (PBYTE)pReturnedString, &cbSize);
        }
    }

    //
    // Clean up all allocated resources.
    //
    FreeSplMem((PWSTR)pPath);

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    if (hUser)
    {
        RegCloseKey(hUser);
    }

    if (Retval != ERROR_SUCCESS)
    {
        SetLastError(Retval);
    }

    return Retval == ERROR_SUCCESS;
}

/*++

Name:

    DefPrnWriteProfileString

Description:

    Writes the specified string to the users profile.

Arguments:

    pKey    - pointer to key name to open.
    pValue  - pointer to value to write to, may be NULL
    pString - pointer to string to write

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE. Use GetLastError to
    get extended error information.

--*/
BOOL
DefPrnWriteProfileString(
    IN PCWSTR pKey,
    IN PCWSTR pValue,
    IN PCWSTR pString
    )
{
    DWORD   Retval  = ERROR_SUCCESS;
    DWORD   nSize   = 0;
    HKEY    hUser   = NULL;
    HKEY    hKey    = NULL;
    PCWSTR  pPath   = NULL;

    //
    // Do some basic parameter validation.
    //
    Retval = pKey && pString ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Build the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        nSize = (wcslen(pString) + 1) * sizeof(*pString);

        Retval = StrCatAlloc(&pPath, gszUserProfileRegPath, szSlash, pKey, NULL);
    }

    //
    // Open the current user key, handle the case we are running in an inpersonating thread.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegOpenCurrentUser(KEY_WRITE, &hUser);
    }

    //
    // Open the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval= RegOpenKeyEx(hUser, pPath, 0, KEY_WRITE, &hKey);
    }

    //
    // Set the string value data.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegSetValueEx(hKey, pValue, 0, REG_SZ, (LPBYTE)pString, nSize);
    }

    //
    // Clean up all allocated resources.
    //
    FreeSplMem((PWSTR)pPath);

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    if (hUser)
    {
        RegCloseKey(hUser);
    }

    if (Retval != ERROR_SUCCESS)
    {
        SetLastError(Retval);
    }

    return Retval == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\handle.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    handle.c

Abstract:

    Contains all functions related to the maintanence of print handles.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

DWORD
OpenPrinterRPC(
    PSPOOL pSpool
    );

BOOL
ClosePrinterRPC(
    IN  PSPOOL      pSpool,
    IN  BOOL        bRevalidate
    );

BOOL
ClosePrinterContextHandle(
    HANDLE hPrinter
    );

BOOL
ClosePrinterWorker(
    PSPOOL pSpool
    );

DWORD  gcClientHandle = 0;

#ifdef DBG_TRACE_HANDLE
PSPOOL gpFirstSpool = NULL;
#endif


EProtectResult
eProtectHandle(
    IN HANDLE hPrinter,
    IN BOOL bClose
    )

/*++

Routine Description:

    Protect a print handle so that it will not be deleted while it is
    being used.  If this is called by the Close routine, then this call
    returns whether the Close should continue or be aborted.

    Note: This only provides close protection--it does not guard against
    simultaneous access by non-close operations.

    There must always be a matching vUnprotect call when the callee is
    done with the handle.

Arguments:

    hPrinter - pSpool to protect.

    bClose - If TRUE, indicates that the callee wants to close the handle.
        (Generally called by ClosePrinter only.)  The return value will
        indicate whether the calleeis allowed to close the printer.

Return Value:

    kProtectHandleSuccess - Call succeeded; printer handle can be used normally.

    kProtectHandleInvalid - Handle is invalid; call failed.

    kProtectHandlePendingDeletion - This only occurs when bClose is TRUE.  The
        Operation on handle is in process, and the close will happen when the
        other thread has completed.

    LastError only set if handle kProtectHandleInvalid is returned.

--*/

{
    EProtectResult eResult = kProtectHandleInvalid;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    vEnterSem();

    try {
        if( pSpool &&
            (pSpool->signature == SP_SIGNATURE ) &&
            !( pSpool->Status & ( SPOOL_STATUS_CLOSE |
                                  SPOOL_STATUS_PENDING_DELETION ))){

            //
            // Valid handle.
            //
            eResult = kProtectHandleSuccess;

        } else {

            DBGMSG( DBG_WARN,
                    ( "Bad hPrinter %x %x\n",
                      pSpool,
                      pSpool ? pSpool->signature : 0 ));
        }

    } except( EXCEPTION_EXECUTE_HANDLER ){

        DBGMSG( DBG_WARN, ( "Unmapped pSpool %x\n", pSpool ));
    }

    if( eResult == kProtectHandleSuccess ){

        //
        // If bClose, then see if an operation is currently executing.
        //
        if( bClose ){

            if(( pSpool->Status & SPOOL_STATUS_PENDING_DELETION ) ||
                 pSpool->cActive ){

                //
                // Mark pSpool to close itself once the operation has
                // completed in the other thread.
                //
                pSpool->Status |= SPOOL_STATUS_PENDING_DELETION;
                eResult = kProtectHandlePendingDeletion;

            } else {

                //
                // No call is active, so mark ourselves as closing so
                // that no other call will succeed using this handle.
                //
                pSpool->Status |= SPOOL_STATUS_CLOSE;
            }
        }

    } else {

        //
        // Not a valid handle.
        //
        SetLastError( ERROR_INVALID_HANDLE );
    }

    if( eResult == kProtectHandleSuccess ){

        //
        // Returning success, we are now active.
        //
        ++pSpool->cActive;
    }

    vLeaveSem();

    return eResult;

}


VOID
vUnprotectHandle(
    IN HANDLE hPrinter
    )

/*++

Routine Description:

    Unprotect a print handle.  This must be called once for each
    successful bProtectHandle.

Arguments:

    hPrinter - Handle to unprotect.

Return Value:

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BOOL bCallClosePrinter = FALSE;

    vEnterSem();

    //
    // No longer active.  However, it it's closing, leave it marked
    // as closing since we don't want anyone else to use it.
    //
    --pSpool->cActive;

    if( pSpool->Status & SPOOL_STATUS_PENDING_DELETION &&
        !pSpool->cActive ){

        //
        // Someone called Close while we were active.  Since we are now
        // going to close it, don't let anyone else initiate a close by
        // marking SPOOL_STATUS_CLOSE.
        //
        pSpool->Status |= SPOOL_STATUS_CLOSE;
        pSpool->Status &= ~SPOOL_STATUS_PENDING_DELETION;
        bCallClosePrinter = TRUE;
    }

    vLeaveSem();

    if( bCallClosePrinter ){
        ClosePrinterWorker( pSpool );
    }
}



/********************************************************************

    OpenPrinter worker functions.

********************************************************************/


BOOL
OpenPrinterW(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    HANDLE  hPrinter;
    PSPOOL  pSpool = NULL;
    DWORD dwError;

    //
    // Pre-initialize the out parameter, so that *phPrinter is NULL
    // on failure.  This fixes Borland Paradox 7.
    //
    try {
        *phPrinter = NULL;
    } except( EXCEPTION_EXECUTE_HANDLER ){
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return FALSE;
    }

    pSpool = AllocSpool();

    if( !pSpool ){
        goto Fail;
    }

    //
    // Copy DevMode, defaults.  The printer name doesn't change.
    //
    if( !UpdatePrinterDefaults( pSpool, pPrinterName, pDefault )){
        goto Fail;
    }

    //
    // Update the access, since this is not set by UpdatePrinterDefaults.
    //
    if( pDefault ){
        pSpool->Default.DesiredAccess = pDefault->DesiredAccess;
    }

    dwError = OpenPrinterRPC( pSpool );

    if( dwError != ERROR_SUCCESS ){
        SetLastError( dwError );
        goto Fail;
    }

    //
    // We finally have a good pSpool.  Only now update the output
    // handle.  Since it was NULL initialized, this guarantees that
    // OpenPrinter returns *phPrinter NULL when it fails.
    //
    *phPrinter = pSpool;

    return TRUE;

Fail:

    FreeSpool( pSpool );

    return FALSE;
}

DWORD
OpenPrinterRPC(
    PSPOOL pSpool
    )

/*++

Routine Description:

    Open the printer handle using information in the pSpool object.

Arguments:

    pSpool - Printer handle to open.  Internal state of pSpool updated.

Return Value:

    ERROR_SUCCES - Succeed.
    Status code - Failed.

--*/

{
    DEVMODE_CONTAINER DevModeContainer;
    HANDLE hPrinter = NULL;
    DWORD dwReturn;
    DWORD dwSize;
    SPLCLIENT_CONTAINER SplClientContainer;

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SplClientContainer.Level = 2;
    SplClientContainer.ClientInfo.pClientInfo2 = NULL;

    RpcTryExcept {

        //
        // Construct the DevMode container.
        //
        if( SUCCEEDED(SplIsValidDevmodeNoSizeW( pSpool->Default.pDevMode ))){

            dwSize = pSpool->Default.pDevMode->dmSize +
                     pSpool->Default.pDevMode->dmDriverExtra;

            DevModeContainer.cbBuf = pSpool->Default.pDevMode->dmSize +
                                     pSpool->Default.pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pSpool->Default.pDevMode;
        }

        //
        // If the call is made from within the spooler, we also retrieve the
        // server side hPrinter. This will help avoid unnecessary RPC. We cant,
        // however, avoid RPC in this case since the spooler may need a client side
        // handle to pass to other functions or the driver.
        //

        if (bLoadedBySpooler) {

            if (SplClientContainer.ClientInfo.pClientInfo2 =
                            (LPSPLCLIENT_INFO_2) AllocSplMem(sizeof(SPLCLIENT_INFO_2))) {

                 SplClientContainer.ClientInfo.pClientInfo2->hSplPrinter = 0;

                 dwReturn = RpcSplOpenPrinter( (LPTSTR)pSpool->pszPrinter,
                                               &hPrinter,
                                               pSpool->Default.pDatatype,
                                               &DevModeContainer,
                                               pSpool->Default.DesiredAccess,
                                               &SplClientContainer );
            } else {

                 SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                 dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            dwReturn = RpcOpenPrinter( (LPTSTR)pSpool->pszPrinter,
                                       &hPrinter,
                                       pSpool->Default.pDatatype,
                                       &DevModeContainer,
                                       pSpool->Default.DesiredAccess );
        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwReturn = TranslateExceptionCode( RpcExceptionCode() );

    } RpcEndExcept


    if( dwReturn == ERROR_SUCCESS ){

        vEnterSem();

        //
        // hPrinter gets adopted by pSpool->hPrinter.
        //
        pSpool->hPrinter = hPrinter;

        if (bLoadedBySpooler) {
            pSpool->hSplPrinter = (HANDLE) SplClientContainer.ClientInfo.pClientInfo2->hSplPrinter;
        } else {
            pSpool->hSplPrinter = NULL;
        }

        vLeaveSem();
    }

    if (SplClientContainer.ClientInfo.pClientInfo2) {
        FreeSplMem(SplClientContainer.ClientInfo.pClientInfo2);
    }

    return dwReturn;
}


/********************************************************************

    ClosePrinter worker functions.

********************************************************************/

BOOL
ClosePrinter(
    HANDLE  hPrinter
    )
{
    PSPOOL pSpool = (PSPOOL)hPrinter;

    switch( eProtectHandle( hPrinter, TRUE  )){
    case kProtectHandleInvalid:
        return FALSE;
    case kProtectHandlePendingDeletion:
        return TRUE;
    default:
        break;
    }

    //
    // Note, there isn't a corresponding vUnprotectHandle, but that's ok
    // since we're deleting the handle.
    //

    return ClosePrinterWorker( pSpool );
}

//
// A simpler way to have a central function for closing spool file handles so we 
// don't have to reproduce code constantly.
//
VOID
CloseSpoolFileHandles(
    PSPOOL pSpool
    )
{
    if ( pSpool->hSpoolFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( pSpool->hSpoolFile );
        pSpool->hSpoolFile = INVALID_HANDLE_VALUE;
    }
    
    if (pSpool->hFile != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(pSpool->hFile);
        pSpool->hFile = INVALID_HANDLE_VALUE;
    }
}




BOOL
ClosePrinterWorker(
    PSPOOL pSpool
    )
{
    BOOL bReturnValue;
    FlushBuffer(pSpool, NULL);

    if (pSpool->Status & SPOOL_STATUS_ADDJOB)
        ScheduleJobWorker( pSpool, pSpool->JobId );

    vEnterSem();

    if( pSpool->pNotify ){

        //
        // There is a notification; disassociate it from
        // pSpool, since we are about to free it.
        //
        pSpool->pNotify->pSpool = NULL;
    }

    vLeaveSem();

    //
    // Close any open file handles, we do this before the RPC closeprinter
    // to allow the closeprinter on the other side a chance to delete the spool
    // files if they still exist.
    //
    CloseSpoolFileHandles( pSpool );

    bReturnValue = ClosePrinterRPC( pSpool, FALSE );
    FreeSpool( pSpool );

    return bReturnValue;
}

BOOL
ClosePrinterRPC(
    IN  PSPOOL      pSpool,
    IN  BOOL        bRevalidate
    )

/*++

Routine Description:

    Close down all RPC/network handles related to the pSpool object.
    Must be called outside the critical section. This function also
    is called handle revalidation in which case we don't want to
    close the event handle on the client side.

Arguments:

    pSpool      - Spooler handle to shut down.
    bRevalidate - If TRUE, this is being called as a result of a handle 
                  revalidation.

Return Value:

    TRUE - Success
    FALSE - Failed, LastError set.

--*/

{
    BOOL    bRetval     = FALSE;
    HANDLE  hPrinterRPC = NULL;

    vEnterSem();

    hPrinterRPC = pSpool->hPrinter;

    if ( hPrinterRPC )
    {
        //
        // If you close the RPC handle, you must also set the hSplPrinter since
        // this actually is an alias to the same handle.s
        // 
        pSpool->hPrinter = NULL;
        pSpool->hSplPrinter = NULL;

        FindClosePrinterChangeNotificationWorker( pSpool->pNotify,
                                                  hPrinterRPC, 
                                                  bRevalidate );

        vLeaveSem();

        bRetval = ClosePrinterContextHandle( hPrinterRPC );
    }
    else
    {
        vLeaveSem();

        SetLastError( ERROR_INVALID_HANDLE );
    }

    return bRetval;
}


BOOL
ClosePrinterContextHandle(
    HANDLE hPrinterRPC
    )

/*++

Routine Description:

    Close a printer context handle.

Arguments:

    hPrinterRPC - RPC context handle to close.

Return Value:

    TRUE - Success
    FALSE - Failure; LastError set

--*/

{
    BOOL bReturnValue;
    DWORD Status;

    if( !hPrinterRPC ){
        return FALSE;
    }

    RpcTryExcept {

        if( Status = RpcClosePrinter( &hPrinterRPC )) {

            SetLastError( Status );

            bReturnValue = FALSE;

        } else {

            bReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        bReturnValue = FALSE;

    } RpcEndExcept

    //
    // If we failed for some reason, then RpcClosePrinter did not
    // zero out the context handle.  Destroy it here.
    //
    if( hPrinterRPC ){
        RpcSmDestroyClientContext( &hPrinterRPC );
    }

    return bReturnValue;
}



/********************************************************************

    Constructor and destructor of pSpool.

********************************************************************/

PSPOOL
AllocSpool(
    VOID
    )

/*++

Routine Description:

    Allocate a spool handle.  Client should set pSpool->hPrinter
    when it is acquired.

Arguments:

Return Value:

    pSpool - allocated handle.
    NULL - failed.

--*/

{
    PSPOOL pSpool = AllocSplMem(sizeof(SPOOL));

    if( pSpool ){

        InterlockedIncrement( &gcClientHandle );

        pSpool->signature = SP_SIGNATURE;
        pSpool->hFile = INVALID_HANDLE_VALUE;
        pSpool->hSpoolFile = INVALID_HANDLE_VALUE;

#ifdef DBG_TRACE_HANDLE
        {
            ULONG Hash;

            //
            // Add to linked list.
            //
            vEnterSem();
            pSpool->pNext = gpFirstSpool;
            gpFirstSpool = pSpool;
            vLeaveSem();

#if i386
            //
            // Capture backtrace.
            //
            RtlCaptureStackBackTrace( 1,
                                      COUNTOF( pSpool->apvBackTrace ),
                                      pSpool->apvBackTrace,
                                      &Hash );
#endif
        }
#endif
    }

    return pSpool;
}


VOID
FreeSpool(
    PSPOOL pSpool
    )
{
    if( !pSpool ){
        return;
    }

    InterlockedDecrement( &gcClientHandle );

    if (pSpool->pBuffer != NULL ) {
        if (!VirtualFree(pSpool->pBuffer, 0, MEM_RELEASE)) {
            DBGMSG(DBG_WARNING, ("ClosePrinter VirtualFree Failed %x\n",
                                 GetLastError()));
        }
        DBGMSG(DBG_TRACE, ("Closeprinter cWritePrinters %d cFlushBuffers %d\n",
                           pSpool->cWritePrinters, pSpool->cFlushBuffers));
    }

    FreeSplStr( pSpool->pszPrinter );
    FreeSplMem( pSpool->Default.pDevMode );
    FreeSplMem( pSpool->Default.pDatatype );
    FreeSplMem( pSpool->pDoceventFilter);

    CloseSpoolFileHandles( pSpool );

#ifdef DBG_TRACE_HANDLE
    {
        //
        // Free from linked list.
        //
        PSPOOL *ppSpool;

        vEnterSem();

        for( ppSpool = &gpFirstSpool; *ppSpool; ppSpool = &(*ppSpool)->pNext ){

            if( *ppSpool == pSpool ){
                break;
            }
        }

        if( *ppSpool ){
            *ppSpool = pSpool->pNext;
        } else {
            DBGMSG( DBG_WARN,
                    ( "pSpool %x not found on linked list\n", pSpool ));
        }
        vLeaveSem();
    }
#endif

    FreeSplMem( pSpool );
}


/********************************************************************

    Utility functions.

********************************************************************/


BOOL
RevalidateHandle(
    PSPOOL pSpool
    )

/*++

Routine Description:

    Revalidates a pSpool with a new RPC handle, unless we mark it as a 
    non-recycleable handle.  This allows the spooler to be restarted yet 
    allow the handle to remain valid.

    This should only be called when a call fails with ERROR_INVALID_HANDLE.
    We can only save simple state information (pDefaults) from OpenPrinter
    and ResetPrinter.  If a user spooling and the context handle is lost,
    there is no hope of recovering the spool file state, since the
    spooler probably died before it could flush its buffers.

    We should not encounter any infinite loops when the server goes down,
    since the initial call will timeout with an RPC rather than invalid
    handle code.

    Note: If the printer is renamed, the context handle remains valid,
    but revalidation will fail, since we store the old printer name.

Arguments:

    pSpool - Printer handle to revalidate.

Return Value:

    TRUE - Success
    FALSE - Failed.

--*/

{
    DWORD  dwError;
    HANDLE hPrinter;
    BOOL   bReturn = TRUE;

    if ( pSpool->Status & SPOOL_STATUS_DONT_RECYCLE_HANDLE ) {
        bReturn = FALSE;
    } else {
        //
        // Close the existing handle.  We can't shouldn't just destroy the client
        // context since an api may return ERROR_INVALID_HANDLE even though
        // RPC context handle is fine (a handle downstream went bad).
        //
        ClosePrinterRPC( pSpool, TRUE );

        //
        // Reopen the printer handle with current defaults.
        //
        dwError = OpenPrinterRPC( pSpool );

        if ( dwError ) {
            SetLastError( dwError );
            bReturn = FALSE;
        }
    }

    return bReturn;
}

BOOL
UpdatePrinterDefaults(
    IN OUT PSPOOL pSpool,
    IN     LPCTSTR pszPrinter,  OPTIONAL
    IN     PPRINTER_DEFAULTS pDefault OPTIONAL
    )

/*++

Routine Description:

    Update the pSpool to the new defaults in pDefault, EXCEPT for
    pDefault->DesiredAccess.

    Since this attempts to read and update pSpool, we enter the
    critical section and revalidate the pSpool.

Arguments:

    pSpool - Spooler handle to update.

    pszPrinter - New printer name.

    pDefault - New defaults.

Return Value:

    TRUE - Success
    FALSE - Failure.

--*/

{
    BOOL bReturnValue = FALSE;

    vEnterSem();

    if( !UpdateString( pszPrinter, &pSpool->pszPrinter )){
        goto DoneExitSem;
    }

    if( pDefault ){

        //
        // Update the Datatype.
        //
        if( !UpdateString( pDefault->pDatatype, &pSpool->Default.pDatatype )){
            goto DoneExitSem;
        }

        //
        // Update the DevMode.
        //
        if( SUCCEEDED(SplIsValidDevmodeNoSizeW( pDefault->pDevMode ))){

            DWORD dwSize;
            PDEVMODE pDevModeNew;

            dwSize = pDefault->pDevMode->dmSize +
                     pDefault->pDevMode->dmDriverExtra;

            pDevModeNew = AllocSplMem( dwSize );

            if( !pDevModeNew ){
                goto DoneExitSem;
            }

            CopyMemory( pDevModeNew, pDefault->pDevMode, dwSize );

            FreeSplMem( pSpool->Default.pDevMode );
            pSpool->Default.pDevMode = pDevModeNew;
        }
    }
    bReturnValue = TRUE;

DoneExitSem:

    vLeaveSem();
    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\memory.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    memory.cxx

Abstract:

    Allocator class. We use this class in the printer persist code.
    The TPrnStream class uses this class through inheritance. 
    
    The reason why TPrnStream uses its own heap is that it is called
    by terminal services in the winlogon process. The heap protects
    our caller, cause in the worst case scenario we corrupt just our 
    own heap. Also, if an exception is raised in the TPrnStream methods,
    we don't leak, because the destructor frees the heap.
    
Author:

    Felix Maxa (amaxa) 31-Oct-2000

--*/

#include "precomp.h"
#pragma hdrstop
#include "memory.hxx"

/*++

Title:

    TAllocator::TAllocator

Routine Description:

    Constructor

Arguments:

    None.

Return Value:

    None.

--*/
TAllocator::
TAllocator(
    IN DWORD  Options,
    IN SIZE_T InitialSize
    ) : m_hHeap(NULL),
        m_Options(Options),
        m_InitialSize(InitialSize)
{
}

/*++

Title:

    TAllocator::~TAllocator

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.

--*/
TAllocator::
~TAllocator(
    VOID
    )
{
    if (m_hHeap) 
    {
        if (!HeapDestroy(m_hHeap))
        {
            DBGMSG(DBG_WARNING, ("TAllocator::~TAllocator Failed"
                                 "to destroy heap at 0x%x. Win32 error %u\n", m_hHeap, GetLastError()));
        }

        m_hHeap = NULL;
    }
}

/*++

Title:

    TAllocator::AllocMem

Routine Description:

    Allocates memory from a heap. The heap is created upon first
    call to this function.
    
Arguments:

    cbSize - number of bytes to allocate

Return Value:

    NULL - allocation failed
    valid pointer to memory allocated - allocation succeeded

--*/
PVOID
TAllocator::
AllocMem(
    IN SIZE_T CONST cbSize
    )
{
    LPVOID pMem = NULL;

    if (!m_hHeap) 
    {
        m_hHeap = HeapCreate(m_Options, m_InitialSize, 0);  

        if (!m_hHeap) 
        {
            DBGMSG(DBG_WARNING, ("TAllocator::AllocMem Failed to create heap. "
                                 "Win32 error %u\n", GetLastError()));
        }
    }
    
    if (m_hHeap) 
    {
        pMem = HeapAlloc(m_hHeap, m_Options, cbSize);

        if (!pMem) 
        {
            DBGMSG(DBG_WARNING, ("TAllocator::AllocMem Failed to allocated memory."
                                 " Win32 error %u\n", GetLastError()));
        }
    }
    
    return pMem;
}

/*++

Title:

    TAllocator::FreeMem

Routine Description:

    Frees a block of memory from the heap.

Arguments:

    pMem - pointer to block to free

Return Value:

    None.

--*/
VOID
TAllocator::
FreeMem(
    IN PVOID pMem
    )
{
    if (pMem && m_hHeap) 
    {
        if (!HeapFree(m_hHeap, m_Options, pMem))
        {
            DBGMSG(DBG_WARNING, ("TAllocator::FreeMem Failed to free block at 0x%x."
                                 " Win32 error %u\n", pMem, GetLastError()));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return (LocalAlloc(0,NumBytes));
}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\pfdlg.h ===
/*++  

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    pfdlg.h

Abstract:

    Print to file header

Author:

    Steve Kiraly (steveki) 5-May-1998

Environment:

    User Mode -Win32

Revision History:

--*/
#ifndef _PFDLG_H_
#define _PFDLG_H_


INT_PTR CALLBACK
PrintToFileDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
   );

BOOL
PrintToFileInitDialog(
    HWND  hwnd,
    LPWSTR  *ppFileName
    );

BOOL
PrintToFileCommandOK(
    HWND hwnd
    );

BOOL
PrintToFileCommandCancel(
    HWND hwnd
    );

BOOL
PrintToFileHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\pfdlg.c ===
/*++  

Copyright (c) 1990-1995  Microsoft Corporation
All rights reserved

Module Name:

    pfdlg.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "pfdlg.h"

static const DWORD g_aHelpIDs[]=
{
    IDD_PF_EF_OUTPUTFILENAME, 8810218, // Print to File: "" (Edit)
    0, 0
};

/*
 *
 */
INT_PTR CALLBACK
PrintToFileDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return PrintToFileInitDialog(hwnd, (LPWSTR *)lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return PrintToFileCommandOK(hwnd);

        case IDCANCEL:
            return PrintToFileCommandCancel(hwnd);
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:    
        return PrintToFileHelp(hwnd, msg, wparam, lparam);
        break;
    }

    return FALSE;
}


/*
 *
 */
BOOL
PrintToFileInitDialog(
    HWND  hwnd,
    LPWSTR *ppFileName
)
{
    BringWindowToTop( hwnd );

    SetFocus(hwnd);

    SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)ppFileName );

    SendDlgItemMessage( hwnd, IDD_PF_EF_OUTPUTFILENAME, EM_LIMITTEXT, MAX_PATH-2, 0);

    return TRUE;
}


/*
 *
 */
BOOL
PrintToFileCommandOK(
    HWND hwnd
)
{
    WCHAR           pFileName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE          hFile;
    HANDLE          hFind;
    LPWSTR          *ppFileName;

    ppFileName = (LPWSTR *)GetWindowLongPtr( hwnd, GWLP_USERDATA );

    GetDlgItemText( hwnd, IDD_PF_EF_OUTPUTFILENAME,
                    pFileName, MAX_PATH );

    hFind = FindFirstFile( pFileName, &FindData );

    //
    // If the file already exists, get the user to verify
    // before we overwrite it:
    //
    if( hFind != INVALID_HANDLE_VALUE )
    {
        FindClose( hFind );

        if( Message( hwnd, MB_OKCANCEL | MB_ICONEXCLAMATION, IDS_LOCALMONITOR,
                     IDS_OVERWRITE_EXISTING_FILE )
            != IDOK )
        {
            return TRUE;
        }
    }


    hFile = CreateFile( pFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );

    if( hFile != INVALID_HANDLE_VALUE )
    {
        LPWSTR pTempFileName;
        WCHAR szCurrentDir[MAX_PATH];
        WCHAR szQualifiedPath[MAX_PATH];
        LPWSTR pszIgnore;
        DWORD cchLen;

        CloseHandle(hFile);

        if (!GetCurrentDirectory(sizeof(szCurrentDir)/sizeof(szCurrentDir[0]),
                                 szCurrentDir))
            goto Fail;

        cchLen = SearchPath(szCurrentDir,
                            pFileName,
                            NULL,
                            sizeof(szQualifiedPath)/sizeof(szQualifiedPath[0]),
                            szQualifiedPath,
                            &pszIgnore);

        if (!cchLen)
            goto Fail;

        pTempFileName = LocalAlloc(LMEM_FIXED,
                                   (cchLen + 1) * sizeof(szQualifiedPath[0]));

        if (!pTempFileName)
            goto Fail;

        StringCchCopy(pTempFileName, cchLen+1, szQualifiedPath);
        *ppFileName = pTempFileName;

        EndDialog( hwnd, TRUE );

    } else {

Fail:
        ReportFailure( hwnd, IDS_LOCALMONITOR, IDS_COULD_NOT_OPEN_FILE );
    }

    return TRUE;
}



BOOL
PrintToFileCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, FALSE);
    return TRUE;
}


/*++

Routine Name:

    PrintToFileHelp

Routine Description:

    Handles context sensitive help.
    
Arguments:

    UINT        uMsg,        
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if message handled, otherwise FALSE.

--*/
BOOL
PrintToFileHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:       

        bStatus = WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                           szHelpFile, 
                           HELP_WM_HELP, 
                           (ULONG_PTR)g_aHelpIDs );
        break;

    case WM_CONTEXTMENU:    

        bStatus = WinHelp((HWND)wParam,
                           szHelpFile, 
                           HELP_CONTEXTMENU,  
                           (ULONG_PTR)g_aHelpIDs );
        break;

    } 
    
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Albert Ting (AlbertT)  30-Nov-1997

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef MODULE
#define MODULE "SPLCLIENT:"
#define MODULE_DEBUG ClientDebug
#define LINK_SPLLIB
#endif

#define INC_OLE2

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <rpcasync.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <winddiui.h>
#include "wingdip.h"
#include "gdispool.h"
#include <winsprlp.h>

#include <wininet.h>
#include "shlobj.h"
#include "shlobjp.h"
#include "cstrings.h"
#include <tchar.h>
#include "resource.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <dsrole.h>
#include <dsgetdc.h>
#include <wininet.h>
#include <activeds.h>
#include <ntdsapi.h>
#include <setupapi.h>
#include <splsetup.h>
#include <winsock2.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>

#include <strsafe.h>
#include <splcom.h>

#ifdef __cplusplus
#include <icm.h>
#include <winprtp.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\init.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Init.c

Abstract:

    Holds initialization code for winspool.drv

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

CRITICAL_SECTION ClientSection;
//
// bLoadedBySpooler indicates if this instance of winspool.drv is loaded in the spooler
// process. This flag is used to avoid unnecessary RPC.
//
BOOL bLoadedBySpooler;
//
// The following function pointers hold the spooler's server side function pointers.
// This list includes most of the calls made inside the spooler except OpenPrinter and
// ClosePrinter. We cant extend RPC elimination to cover (Open/Close)Printer unless
// "ALL" spooler APIs use RPC elimination inside the spooler.
//
DWORD (*fpYReadPrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
DWORD (*fpYSplReadPrinter)(HANDLE, LPBYTE *, DWORD, BOOL);
DWORD (*fpYWritePrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
DWORD (*fpYSeekPrinter)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD, BOOL, BOOL);
DWORD (*fpYGetPrinterDriver2)(HANDLE, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD,
                              DWORD, DWORD, PDWORD, PDWORD, BOOL);
DWORD (*fpYGetPrinterDriverDirectory)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, BOOL);
VOID  (*fpYDriverUnloadComplete)(LPWSTR);
DWORD  (*fpYFlushPrinter)(HANDLE,LPVOID,DWORD,LPDWORD,DWORD,BOOL);
DWORD (*fpYEndDocPrinter)(HANDLE,BOOL);
DWORD (*fpYSetPort)(LPWSTR, LPWSTR, LPPORT_CONTAINER, BOOL);
DWORD (*fpYSetJob)(HANDLE, DWORD, LPJOB_CONTAINER, DWORD, BOOL);

VOID InitializeGlobalVariables()

/*++
Function Description -- Initializes bLoadedBySpooler and function pointers.

Parameters - NONE

Return Values - NONE
--*/

{
    TCHAR   szSysDir[MAX_PATH];
    LPTSTR  pszSpoolerName = NULL, pszModuleName = NULL, pszSysDir = (LPTSTR) szSysDir;
    BOOL    bAllocSysDir = FALSE;
    DWORD   dwNeeded, dwSize;
    HANDLE  hLib;
    //
    // Preliminary initializations
    //
    bLoadedBySpooler = FALSE;
    fpYReadPrinter = fpYWritePrinter = NULL;
    fpYSplReadPrinter = NULL;
    fpYSeekPrinter = NULL;
    fpYGetPrinterDriver2 = NULL;
    fpYGetPrinterDriverDirectory = NULL;
    fpYDriverUnloadComplete = NULL;
    fpYFlushPrinter = NULL;
    fpYEndDocPrinter = NULL;

    hSurrogateProcess = NULL;


    dwSize = MAX_PATH * sizeof(TCHAR);

    if (!(dwNeeded = GetSystemDirectory(pszSysDir, MAX_PATH))) {
        goto CleanUp;
    }

    if (dwNeeded > dwSize)  {

       if (pszSysDir = (LPTSTR) AllocSplMem(dwNeeded)) {

           bAllocSysDir = TRUE;
           if (!GetSystemDirectory(pszSysDir, dwNeeded / sizeof(TCHAR))) {
               goto CleanUp;
           }

       } else {
          goto CleanUp;
       }
    }

    dwSize = (_tcslen(pszSysDir) + 1 + _tcslen(TEXT("\\spoolsv.exe"))) * sizeof(TCHAR);

    if ((!(pszSpoolerName = (LPTSTR) AllocSplMem(dwSize))) ||
        (!(pszModuleName  = (LPTSTR) AllocSplMem(dwSize))))   {

         goto CleanUp;
    }

    //
    // Get spooler name
    //
    StrNCatBuff(pszSpoolerName, dwSize / sizeof(WCHAR), pszSysDir, TEXT("\\spoolsv.exe"), NULL);
    //
    // Get module name. GetModuleFileName truncates the string if it is bigger than
    // the allocated buffer. There shouldn't be an executable spoolsv.exe* in the
    // system directory, which could be mistaken for the spooler.
    //
    if (!GetModuleFileName(NULL, pszModuleName, dwSize / sizeof(TCHAR))) {
        goto CleanUp;
    }

    if (!_tcsicmp(pszSpoolerName, pszModuleName)) {
       //
       // winspool.drv has been loaded by the spooler
       //
       bLoadedBySpooler = TRUE;
       if (hLib = LoadLibrary(pszSpoolerName)) {

          fpYReadPrinter               = (DWORD (*)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL))
                                             GetProcAddress(hLib, "YReadPrinter");
          fpYSplReadPrinter            = (DWORD (*)(HANDLE, LPBYTE *, DWORD, BOOL))
                                             GetProcAddress(hLib, "YSplReadPrinter");
          fpYWritePrinter              = (DWORD (*)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL))
                                             GetProcAddress(hLib, "YWritePrinter");
          fpYSeekPrinter               = (DWORD (*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER,
                                                     DWORD, BOOL, BOOL))
                                             GetProcAddress(hLib, "YSeekPrinter");
          fpYGetPrinterDriver2         = (DWORD (*)(HANDLE, LPWSTR, DWORD, LPBYTE, DWORD,
                                                    LPDWORD, DWORD, DWORD, PDWORD, PDWORD, BOOL))
                                             GetProcAddress(hLib, "YGetPrinterDriver2");
          fpYGetPrinterDriverDirectory = (DWORD (*)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD,
                                                    LPDWORD, BOOL))
                                             GetProcAddress(hLib, "YGetPrinterDriverDirectory");
          fpYDriverUnloadComplete      = (VOID (*)(LPWSTR))
                                             GetProcAddress(hLib, "YDriverUnloadComplete");
          fpYFlushPrinter              = (DWORD (*)(HANDLE,LPVOID,DWORD,LPDWORD,DWORD,BOOL))
                                             GetProcAddress(hLib,"YFlushPrinter");
          fpYEndDocPrinter             = (DWORD (*)(HANDLE,BOOL))
                                             GetProcAddress(hLib,"YEndDocPrinter");
          fpYSetPort                   = (DWORD (*)(LPWSTR,LPWSTR,LPPORT_CONTAINER,BOOL))
                                             GetProcAddress(hLib,"YSetPort");
          fpYSetJob                    = (DWORD (*)(HANDLE, DWORD, LPJOB_CONTAINER, DWORD, BOOL))
                                             GetProcAddress(hLib,"YSetJob");


          //
          // We can leave spoolsv.exe loaded since it is in the spooler process
          //
       }
    }

CleanUp:

    if (pszSpoolerName) {
        FreeSplMem(pszSpoolerName);
    }

    if (pszModuleName) {
        FreeSplMem(pszModuleName);
    }

    if (bAllocSysDir) {
        FreeSplMem(pszSysDir);
    }

    return;
}


//
// This entry point is called on DLL initialisation.
// We need to know the module handle so we can load resources.
//
BOOL DllMain(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    DWORD LastError;
    DBG_UNREFERENCED_PARAMETER(pctx);    

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HMODULE)hmod);
        hInst = hmod;

        __try {

            if( !bSplLibInit(NULL) ) {
                return FALSE;
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            SetLastError(GetExceptionCode());
            return FALSE;
        }

        InitializeGlobalVariables();

        if (!InitializeCriticalSectionAndSpinCount(&ClientSection, 0x80000000))
        {
            return FALSE;
        }

        if (!InitializeCriticalSectionAndSpinCount(&ListAccessSem, 0x80000000))
        {
            LastError = GetLastError();
            DeleteCriticalSection(&ClientSection);
            SetLastError(LastError);
            return FALSE;
        }

        if (!InitializeCriticalSectionAndSpinCount(&ProcessHndlCS, 0x80000000))
        {
            LastError = GetLastError();
            DeleteCriticalSection(&ClientSection);
            DeleteCriticalSection(&ListAccessSem);
            SetLastError(LastError);
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        vSplLibFree();

        DeleteCriticalSection( &ClientSection );
        DeleteCriticalSection( &ListAccessSem );
        DeleteCriticalSection( &ProcessHndlCS);

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\prnprst.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    PrnPrst.cxx

Abstract:

    TPrinterPersist member definitions.

    This class implements methods for storing , restoring printer settings into a file

    Also , implements read, write , seek methods to operate a file likewise a stream

Author:

    Adina Trufinescu (AdinaTru)  4-Nov-1998

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "prnprst.hxx"

/*++

Title:                  

    TPrinterPersist

Routine Description:    

    Initialise m_pPrnStream to NULL.
    TPrinterPersist functionality is implemented through this object methods call.
    m_pPrnStream is created when   BindPrinterAndFile is called. If this function fails, 
    any subsequent method call will fail too.

Arguments:  

    None

Return Value:  

    Nothing

--*/
TPrinterPersist::
TPrinterPersist()
{
    m_pPrnStream = NULL;
}

/*++

Title:                  

    ~TPrinterPersist

Routine Description:    

    destructor: if created , deletes PrnStream object

Arguments:  

    None

Return Value:  

    Nothing

--*/

TPrinterPersist::
~TPrinterPersist()
{
    if(m_pPrnStream)
    {
        delete m_pPrnStream;
    }
}

/*++

Title:                  

    BindPrinterAndFile

Routine Description:

    Create  a TPrnStream object and if succeeded , bind it to a printer and a file
                    
Arguments:

    pszPrinter  - printer to bind to
    pszFile     - file to bind to

Return Value:  

    BindPrinterAndFile could return E_OUTOFMEMORY if failed to allocate memory,
    an error code mapped to HRESULT with storage facility set if failed to open printer in TPrnStream::BindPrnStream
    or S_OK if suceeded

--*/
HRESULT
TPrinterPersist::
BindPrinterAndFile(
    IN LPCTSTR pszPrinter,
    IN LPCTSTR pszFile
    )
{
    TStatusB    bStatus;
    TStatusH    hr;

    // 
    //  Create a TPrnStream obj ant initialise it with printer name and file name
    //
    m_pPrnStream = new TPrnStream(pszPrinter, pszFile);

    bStatus DBGCHK = (m_pPrnStream != NULL);

    if(bStatus)
    {
        DBGMSG(DBG_TRACE , ("BindPrinterAndFile to : " TSTR " \n" , pszPrinter));
        //
        // calls TPrnStream bind method; it will open the printer with maximum access rights
        // and will create a TStream object that will open the file
        //
        hr DBGCHK = m_pPrnStream->BindPrnStream();

        //
        //  if failed to bind TPrnStream to printer and file , delete it!!!
        //
        if(FAILED(hr))
        {
            delete m_pPrnStream;

            m_pPrnStream = NULL;
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
    

}

/*++

Title:                  

    UnBindPrinterAndFile

Routine Description:

    Call UnBindPrnStream method of m_pPrnStream.After this function is called , any subsequent method call will fail.
    
Arguments:

    None

Return Value:
    
    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrinterPersist::
UnBindPrinterAndFile(
    )
{
    TStatusH    hr;

    DBGMSG(DBG_TRACE , ("UnBindPrinterAndFile!!! \n"));

    hr DBGNOCHK = E_FAIL;

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->UnBindPrnStream();
    }


    return hr;
}

/*++

Title:                  

    bGetPrinterAndFile

Routine Description:

    Query m_pPrnStream for printer and file it is binded

Arguments: 

    pszPrinter  -   outs printer name
    pszFile     -   outs file name

Return Value:  

    TRUE if m_pPrnStream is initialized 
    FALSE otherwise

--*/
BOOL
TPrinterPersist::   
bGetPrinterAndFile(
    OUT LPCTSTR& pszPrinter,
    OUT LPCTSTR& pszFile
    )
{
    TStatusB    bStatus;

    if(m_pPrnStream != NULL)
    {
        pszPrinter   = m_pPrnStream->GetPrinterName();

        pszFile      = m_pPrnStream->GetFileName();

        bStatus DBGNOCHK = TRUE;
    }
    else
    {
        bStatus DBGCHK = FALSE;
    }

    return bStatus;

}
/*++

Title:                  

    Read

Routine Description:

    Indirects call to PrnStream which , in turns , idirects it to TStream  
    Eventually , this function will be called through IStream interface
    Arguments the same as IStream::Read
                    
Arguments: 

    pv  -   The buffer that the bytes are read into
    cb  -   The offset in the stream to begin reading from.
    pcbRead -   The number of bytes to read

Return Value:

    S_OK if succeeded
    ReadFile Win32 error mapped to HRESULT(FACILITY_STORAGE) if failed

--*/
HRESULT
TPrinterPersist::
Read(                                
    IN VOID * pv,      
    IN ULONG  cb,       
    IN ULONG * pcbRead 
    )
{
    if(m_pPrnStream)
    {
        return m_pPrnStream->GetIStream()->Read(pv, cb, pcbRead);
    }
    else
    {
        return STG_E_NOMOREFILES;
    }
    
}
/*++

Title:                  

    Write

Routine Description:

    Indirects call to PrnStream which , in turns , idirects it to TStream  
    Eventually , this function will be called through IStream interface
    Arguments the same as IStream::Write
                    
Arguments:  

    pv  -   The buffer to write from.
    cb  -   The offset in the array to begin writing from
    pcbRead -   The number of bytes to write

Return Value:

    S_OK if succeeded
    WriteFile Win32 error mapped to HRESULT(FACILITY_STORAGE) if failed

--*/
HRESULT
TPrinterPersist::
Write(                            
    IN VOID     const* pv,  
    IN ULONG    cb,
    IN ULONG*   pcbWritten 
    )
{
    if(m_pPrnStream)
    {
        return m_pPrnStream->GetIStream()->Write(pv, cb, pcbWritten);
    }
    else
    {
        return STG_E_NOMOREFILES;
    }
}

/*++

Title:                  

    Seek

Routine Description:

    Indirects call to PrnStream which , in turns , idirects it to TStream  
    Arguments the same as IStream::Seek
    Eventually , this function will be called through IStream interface
                    
Arguments: 

    dlibMove        -   The offset relative to dwOrigin
    dwOrigin        -   The origin of the offset
    plibNewPosition -   Pointer to value of the new seek pointer from the beginning of the stream  

Return Value:  

    S_OK if succeeded
    SetFilePointer Win32 error mapped to HRESULT(FACILITY_STORAGE) if failed

--*/
HRESULT
TPrinterPersist::
Seek(                                
    IN LARGE_INTEGER dlibMove,  
    IN DWORD dwOrigin,          
    IN ULARGE_INTEGER * plibNewPosition 
    )
{
    if(m_pPrnStream)
    {
        return m_pPrnStream->GetIStream()->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    else
    {
        return STG_E_NOMOREFILES;
    }
}


/*++

Title:                  

    bStorePrinterInfo

Routine Description:    

    Writes the printer settings into file.
    Depending on specified flags, call TPrnStream   methods to store printer data
    This function must be called after calling BindPrinterAndFile which bind the object to 
    a printer and to a file.For that fnct to succeed, current user must have PRINTER_READ rights
    on specified printer.

Arguments:  

    Flags       -   specifies what settings should be stored
    StoredFlags -   specifies what settings were actually stored

Return Value:

    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrinterPersist::
StorePrinterInfo(
    IN  DWORD   Flags,
    OUT DWORD&  StoredFlags
    )
{
    TStatusH    hr;

    DBGMSG(DBG_TRACE , ("Store Printer Flag %x \n" , Flags));

    hr DBGNOCHK = E_FAIL;

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->StorePrinterInfo(Flags, StoredFlags);
    }


    DBGMSG( DBG_TRACE, ( "Store Completed :: %x \n" ,hr));


    return hr;

}


/*++

Title:                  

    RestorePrinterInfo

Routine Description:    

    Depending on specified flags, call TPrnStream   methods to restore printer data
    This function must be called after calling BindPrinterAndFile which bind the object to 
    a printer and to a file.For that fnct to succeed, current user has to have PRINTER_ALL_ACCESS rights.
    If he don't , BindPrinterAndFile will bind to printer with PRINTER_READ which will lead to 
    SetPrinter failure. 
    
Arguments:              

    Flags         -   specifies what settings should be restored
    RestoredFlags -   specifies what settings were actually restored

Return Value:
    
    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed


--*/
HRESULT
TPrinterPersist::
RestorePrinterInfo(
    IN DWORD    Flags,
    OUT DWORD&  RestoredFlags
    )
{
    TStatusH            hr;
    TStatusB            bStatus;
    
    hr DBGNOCHK = E_FAIL;



    RestoredFlags = 0;

    DBGMSG(DBG_TRACE , ("Restore Printer info %x \n" , Flags));

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->CheckPrinterNameIntegrity(Flags);

        if(SUCCEEDED(hr))
        {
            DBGMSG( DBG_TRACE, ( "CheckPrinterNameIntegrity OK!!! %x \n" , hr));

            hr DBGCHK = m_pPrnStream->RestorePrinterInfo(Flags, RestoredFlags);
        }

    }

    DBGMSG( DBG_TRACE, ( "RESTORE END!!! %x \n" , hr));
    return hr;

}

/*++

Title:                  

    SafeRestorePrinterInfo

Routine Description:    

    Before restoring ant flags, create a new temporary persistent object binded to also to printer which stores current printer settings. 
    If something fails at the restoring, we are able to roll back all the changes made and we will leave printer in the 
    initial state.
    A temporary file which holds initial printer settings are created by invoking StorePrinterInfo for temporary object.
    This file will be deleted by calling UnBindPrinterAndFile for temporary object.

Arguments:              

    Flags         -   specifies what settings should be restored
    
Return Value:
    
    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed


--*/
HRESULT
TPrinterPersist::
SafeRestorePrinterInfo(
    IN DWORD    Flags
    )
{
    LPTSTR  pszPrinterTemp;
    LPTSTR  pszFile;
    TString strFileTempPrefix(_T("Prst"));
    TCHAR   szTempFileName[MAX_PATH];
    TCHAR   szTempPath[MAX_PATH];


    TStatusH hr;
    TStatusH hrBkp;

    DWORD StoredFlags;
    DWORD RestoredFlags;

    //
    // initialize hr to Backup error; if something wrong happens when trying to build backup version of file,
    // fnct will return Back-up Error
    //
    hr  DBGNOCHK     = MakePrnPersistHResult(PRN_PERSIST_ERROR_BACKUP);

    hrBkp DBGNOCHK   = MakePrnPersistHResult(PRN_PERSIST_ERROR_BACKUP);

    //
    // Create temporary object for storing current settings
    // In case the main restoring fails , current settings can be restored
    //
    TPrinterPersist* pPrnPersistTemp = new TPrinterPersist;

    if(pPrnPersistTemp != NULL)
    {
        if(bGetPrinterAndFile(pszPrinterTemp, pszFile))
        {
            TStatus Status;
            //
            // create a temp file for saving current settings
            //
            Status DBGNOCHK = GetTempPathW(MAX_PATH, szTempPath); 
            if (Status > 0 && Status <= MAX_PATH) {
                GetTempFileName(szTempPath, strFileTempPrefix, 0, szTempFileName);
            }
            else {
                GetTempFileName(_T("."), strFileTempPrefix, 0, szTempFileName);
            }
            
            hrBkp DBGCHK = pPrnPersistTemp->BindPrinterAndFile(pszPrinterTemp, szTempFileName);

            if(SUCCEEDED(hrBkp))
            {
                hrBkp DBGCHK = pPrnPersistTemp->StorePrinterInfo(Flags, StoredFlags);

                if(SUCCEEDED(hrBkp))
                {
                    hr DBGCHK = RestorePrinterInfo(Flags, RestoredFlags);

                    if(FAILED(hr))
                    {
                        //
                        // if main restoring failed , try backup restoring with flags set to:
                        //      flags successfully restored
                        //      &
                        //      flags that were successfully stored in backup file
                        // fct will still return hr = reason for main restoring failure
                        //
                        // PRST_FORCE_NAME must be always set on force for a scenario like this:
                        // restore settings from file ( printer P1 stored) on top of printer P2 with f flag set
                        // restoring fails (printer P2 could become P1 at this point) and back-up is needed; 
                        // in back-up file , printer name is P2 . This means we have to force printer name from back-up file,
                        // in order to become P2 again
                        // If it's not the case then printer was renamed and the restoring failed,f flag is harmless
                        //
                        hrBkp DBGCHK = pPrnPersistTemp->RestorePrinterInfo((StoredFlags & RestoredFlags) | PRST_FORCE_NAME , RestoredFlags);

                        if(FAILED(hrBkp))
                        {
                            // if backup restoring failed also,
                            // set hr to FATAL Error
                            //
                            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_FATAL);
                        }

                    }

                }

            }

            pPrnPersistTemp->UnBindPrinterAndFile();

        }

        delete pPrnPersistTemp;
    }

    return hr;
}

/*++

Title:                  

    QueryPrinterInfo

Routine Description:    

    Read from 
                    
Arguments:              

    Flags       -   specifies what settings should be restored
    pPrstInfo   -   pointer to union that holds a pointer to read item

Return Value:

    S_OK if succeeded;
    ERROR_INVALID_PARAMETER maped to HRESULT if more than one flag specified;
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed;

--*/
HRESULT
TPrinterPersist::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag           Flag,
    OUT PersistentInfo                      *pPrstInfo
    )
{
    TStatusH            hr;
    TStatusB            bStatus;
    
    hr DBGNOCHK = E_FAIL;



    DBGMSG(DBG_TRACE , ("Restore Printer info %x \n" , Flag));

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->QueryPrinterInfo(Flag, pPrstInfo);
    
    }

    DBGMSG( DBG_TRACE, ( "QueryPrinterInfo END!!! %x \n" , hr));

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\resource.h ===
/*++  

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    resource.h

Abstract:

    Resource ids header

Author:

    Steve Kiraly (steveki) 1-May-1998

Environment:

    User Mode -Win32

Revision History:

--*/

#define DLG_PRINTTOFILE                 100

#define IDD_PF_EF_OUTPUTFILENAME        201
#define IDD_PF_PB_HELP                  202

#define IDS_LOCALMONITOR                300
#define IDS_COULD_NOT_OPEN_FILE         301
#define IDS_OVERWRITE_EXISTING_FILE     302

#define IDS_DUPLICATE_PRINTQUEUE        400
#define IDS_DUPLICATE_PRINTQUEUE_TITLE  401
#define IDS_UNKNOWN_ERROR               402
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\property.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    Adds properties to ds

Author:

    Steve Wilson (NT) December 1996

Revision History:

--*/

#define INC_OLE2

#include "precomp.h"
#pragma hdrstop

#include "varconv.hxx"
#include "property.hxx"
#include "client.h"


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr;
    VARIANT varInputData;

    hr = PackString2Variant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&varInputData);

    return hr;
}


HRESULT
put_DWORD_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    DWORD *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDWORD2Variant(
            *pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
put_MULTISZ_Property(
    IADs    *pADsObject,
    BSTR    bstrPropertyName,
    BSTR    pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT var;
    VARIANT varInputData;
    BSTR    pStr;
    BSTR    *pStrArray;
    DWORD   i;
    BSTR    pMultiString;

    if (!pSrcStringProperty || !*pSrcStringProperty)
        pMultiString = L"";
    else
        pMultiString = pSrcStringProperty;

    VariantInit(&var);
    //
    // Convert MULTI_SZ to string array (last element of array must be NULL)
    //
    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        ;

    if (!(pStrArray = (BSTR *) AllocSplMem((i + 1)*sizeof(BSTR)))) {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        pStrArray[i] = pStr;
    pStrArray[i] = NULL;

    MakeVariantFromStringArray(pStrArray, &var);

    FreeSplMem(pStrArray);

    hr = PackVARIANTinVariant(
            var,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&var);
    VariantClear(&varInputData);

    return hr;
}

HRESULT
put_BOOL_Property(
    IADs *pADsObject,
    BSTR bstrPropertyName,
    BOOL *bSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BOOL    bVal;

    bVal = bSrcProperty ? *bSrcProperty : 0;

    hr = PackBOOL2Variant(
            bVal,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!bSrcProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:
    return hr;
}

HRESULT
get_BSTR_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\prnstrm.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    Stream.cxx

Abstract:

    implements TPrnStream class methods

Author:

    Adina Trufinescu (AdinaTru)  4-Nov-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "prnprst.hxx"

static
FieldInfo PrinterInfo2Fields[]={
                                {offsetof(PRINTER_INFO_2, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pShareName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pLocation), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pSepFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, DefaultPriority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, AveragePPM), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

static
FieldInfo PrinterInfo7Fields[]={
                                {offsetof(PRINTER_INFO_7, pszObjectGUID), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_7, dwAction), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

/*++

Title:

    TPrnStream

Routine Description:

    Initialize class members.
    Initialise m_pIStream to NULL.
    TPrnStream Read/write/Seek functionality is implemented through this object methods call.
    m_pIStream is created when  BindPrnStream is called. If this function fails,
    any subsequent method call will fail too.

Arguments:

    None

Return Value:

    Nothing

--*/
TPrnStream::
TPrnStream(
    IN  LPCTSTR pszPrnName,
    IN  LPCTSTR pszFileName
    ) : m_pIStream(NULL),
        m_strFileName(pszFileName),
        m_strPrnName(pszPrnName),
        m_hPrinterHandle(INVALID_HANDLE_VALUE),
        m_bHeaderWritten(FALSE),
        m_cIndex(0),
        m_ResolveCase(0),
        m_pPrnBinItem(NULL),
        m_EnumColorProfiles(NULL),
        m_AssociateColorProfileWithDevice(NULL),
        m_DisassociateColorProfileFromDevice(NULL),
        m_pColorProfileLibrary(NULL)
{
    m_cPrnDataItems.QuadPart = 0;

    m_uliSeekPtr.QuadPart = 0;

}
/*++

Title:

    ~TPrnStream

Routine Description:

    Close printer if opened ; free TStream if created

Arguments:

    None

Return Value:

    Nothing

--*/
TPrnStream::
~TPrnStream(
    )
{
    if(m_hPrinterHandle != INVALID_HANDLE_VALUE)
    {
        ClosePrinter(m_hPrinterHandle);
    }

    if(m_pIStream)
    {
        delete m_pIStream;
    }


    if(m_pPrnBinItem)
    {
        FreeMem(m_pPrnBinItem);
    }

    if (m_pColorProfileLibrary)
    {
        delete m_pColorProfileLibrary;
    }
}


/*++

Title:

    BindPrnStream

Routine Description:

    Open Printer , bind prinyter handle to WalkPrinter and create an TStream
    WalkPrinter can take a printer name or printer handle at constructing time
    It has also a default constructor explicit defined ; Printer handle can be binded later

Arguments:

Return Value:

    S_OK if succeeded,
    E_OUTOFMEMORY if failed to alloc mem
    an error code maped to a storage hresult

--*/
HRESULT
TPrnStream::
BindPrnStream(
    )
{
    TStatusB    bStatus;
    TStatus     Status;
    HRESULT     hr;
    DWORD       dwAccess = 0;

    Status DBGCHK = sOpenPrinter(   m_strPrnName,
                    &dwAccess,
                    &m_hPrinterHandle );

    DBGMSG( DBG_TRACE, ( "Printer Name : %x "TSTR" File: "TSTR" \n" , m_hPrinterHandle , (LPCTSTR)m_strPrnName , (LPCTSTR)m_strFileName) );

    if(dwAccess == PRINTER_ALL_ACCESS)
    {
        DBGMSG( DBG_TRACE, ( "Printer ALL Access Granted!!!\n" ) );
    }
    else
    {
        DBGMSG( DBG_TRACE, ( "Printer READ Access Granted!!!\n" ) );
    }


    if(Status == 0)
    {
        BindToPrinter(m_hPrinterHandle);

        m_pIStream = new TStream(m_strFileName);

        bStatus DBGCHK = (m_pIStream != NULL);

        if(bStatus)
        {
            DBGMSG( DBG_TRACE, ( "BINDING SUCCEEDED!!!\n "));

            hr = S_OK;
        }
        else
        {
            m_pIStream = NULL;

            m_hPrinterHandle = INVALID_HANDLE_VALUE;

            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = TStream::MapWin32ErrorCodeToHRes(GetLastError());

    }

    if (SUCCEEDED(hr))
    {
        hr = InitalizeColorProfileLibrary();
    }

    return hr;

}

/*++

Title:

    UnBindPrnStream

Routine Description:

    Close printer if opened , removefile if created , delete

Arguments:

    None

Return Value:

    S_OK if succeeded,
    a Win32 Error (generated by DeleteFile) mapped to a HRESULT if failed

--*/
HRESULT
TPrnStream::
UnBindPrnStream(
    )
{
    TStatusH    hr;

    hr DBGNOCHK = S_OK;

    if(m_hPrinterHandle != INVALID_HANDLE_VALUE)
    {
        ClosePrinter(m_hPrinterHandle);
        m_hPrinterHandle = INVALID_HANDLE_VALUE;
    }

    if(m_pIStream)
    {
        hr DBGCHK = m_pIStream->DestroyFile();
    }

    return hr;
}

/*++

Title:

    SetEndOfPrnStream

Routine Description:

    Set the end of PrnStream; In the case when overwrite an existing file, EOF must be set in order to trubcate the file at
    the actual dimension of the info written

Arguments:

    None

Return Value:

    TRUE if succeeded,

--*/
BOOL
TPrnStream::
SetEndOfPrnStream(
    )
{
    return m_pIStream->bSetEndOfFile();
}

/*++

Title:

    CheckPrinterNameIntegrity

Routine Description:

    Read printer name from file and compare with name specified at binding
    If they are different , depending on how FORCE or RESOLVE flags are set the new name will be resolved or forced.
    If no name solving is specified , return error
    Func called at restoring time

Arguments:

    Flags   -   flags specified at restoring time ; should specify who printer name conflicts are handles

Return Value:

    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
CheckPrinterNameIntegrity(
    IN DWORD    Flags
    )
{
    TStatusB            bStatus;
    TString             strStoredPrnName;
    TStatusH            hr;

    //
    // m_ResolveCase will indicate how to solve printer name conflicts
    // if one of <printer name resolving> flags are set, set m_ResolveCase
    //
    if(Flags & PRST_RESOLVE_NAME)
    {
        m_ResolveCase |= TPrnStream::kResolveName;
    }
    else if(Flags & PRST_FORCE_NAME)
    {
        m_ResolveCase |= TPrnStream::kForceName;
    }

    hr DBGCHK =  ReadPrnName(strStoredPrnName);

    if(SUCCEEDED(hr))
    {
        if(_tcsicmp( m_strPrnName, strStoredPrnName) != 0)
        {
            if(m_ResolveCase & TPrnStream::kResolveName)
            {
                DBGMSG(DBG_TRACE , ("RESOLVE for "TSTR"\n" , (LPCTSTR)m_strPrnName));

                hr DBGNOCHK = S_OK;
            }
            else if(m_ResolveCase & TPrnStream::kForceName)
            {
                DBGMSG(DBG_TRACE , ("FORCE to "TSTR"\n" , (LPCTSTR)strStoredPrnName));

                m_strPrnName.bUpdate(strStoredPrnName);

                hr DBGNOCHK = S_OK;
            }
            else
            {
                hr DBGNOCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_PRN_NAME_CONFLICT);
            }

        }

    }

    return hr;
}

/*++

Title:

    PortNameCase

Routine Description:

    Set m_ResolveCase to TPrnStream::kResolvePort if resolve port option is set

Arguments:

    Flags   -   this function is called with flags specified for RestorePrinterInfo at restoring time

Return Value:

    Nothing

--*/
VOID
TPrnStream::
PortNameCase(
    IN DWORD    Flags
    )
{
    if(Flags & PRST_RESOLVE_PORT)
    {
        m_ResolveCase |= TPrnStream::kResolvePort;
    }
}


/*++

Title:

    DriverNameCase

Routine Description:

    Set m_ResolveCase to TPrnStream::kDontChangeDriver if the caller wants to fail
    the call if the current driver is different than the one in the file.

Arguments:

    Flags   -   this function is called with flags specified for RestorePrinterInfo at restoring time

Return Value:

    Nothing

--*/
VOID
TPrnStream::
DriverNameCase(
    IN DWORD    Flags
    )
{
    if(Flags & PRST_DONT_CHANGE_DRIVER)
    {
        m_ResolveCase |= TPrnStream::kDontChangeDriver;
    }
}

/*++

Title:

    ShareNameCase

Routine Description:

    Set m_ResolveCase to TPrnStream::kGenerateShare if resolve port option is set

Arguments:

    Flags   -   this function is called with flags specified for RestorePrinterInfo at restoring time

Return Value:

    Nothing

--*/
VOID
TPrnStream::
ShareNameCase(
    IN DWORD    Flags
    )
{
    if(Flags & PRST_RESOLVE_SHARE)
    {
        m_ResolveCase |= TPrnStream::kGenerateShare;
    }
    else if(Flags & PRST_DONT_GENERATE_SHARE)
    {
        m_ResolveCase |= TPrnStream::kUntouchShare;
    }

}

/*++

Title:

    StorePrinterInfo

Routine Description:

    Define restoring function table and calls storing functions based on flag value

Arguments:

    flags   -   flags that specifies that functions should be called

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrinterInfo(
    IN  DWORD    Flags,
    OUT DWORD&   StoredFlags
    )
{

    TStatusH    hr;

    hr DBGNOCHK = S_OK;


    static PrstFunctEntry StoreFunctTable [] = {
    {PRST_PRINTER_INFO_2,               &TPrnStream::StorePrnInfo2},
    {PRST_PRINTER_INFO_7,               &TPrnStream::StorePrnInfo7},
    {PRST_COLOR_PROF,                   &TPrnStream::StoreColorProfiles},
    {PRST_PRINTER_DATA,                 &TPrnStream::StorePrnData},
    {PRST_PRINTER_SEC,                  &TPrnStream::StorePrnSecurity},
    {PRST_PRINTER_DEVMODE,              &TPrnStream::StorePrnDevMode},
    {PRST_USER_DEVMODE,                 &TPrnStream::StoreUserDevMode},
    {0,                                 NULL}};


    hr DBGCHK = WriteHeader(Flags);

    //
    // initialize the flags that were successfully stored with 0
    //
    StoredFlags = 0;

    for(int idx = 0 ; StoreFunctTable[idx].iKeyWord && SUCCEEDED(hr); idx++)
    {
        if(Flags & StoreFunctTable[idx].iKeyWord)
        {
            hr DBGCHK = (this->*StoreFunctTable[idx].pPrstFunc)();

            if(SUCCEEDED(hr))
            {
                StoredFlags |= StoreFunctTable[idx].iKeyWord;
            }
        }

    }

    if(SUCCEEDED(hr))
    {
        //
        // Truncate file; maybe the file was overwrited
        //
        SetEndOfPrnStream();
    }
    else
    {
        //
        //delete file if storing didn't succeed
        //
        UnBindPrnStream();
    }

    return hr;

}

/*++

Title:

    QueryPrinterInfo

Routine Description:

    query a file for stored settings

Arguments:

    Flags - specify what settings to query

    PrstInfo - Structure where read settings will be dumped

Return Value:

    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag      Flags,
    OUT PersistentInfo                  *pPrstInfo
    )
{
    TStatusH    hr;
    BOOL        bInsidePI2;


    static QueryFunctEntry QueryFunctTable [] = {
    {PRST_PRINTER_INFO_2,               &TPrnStream::ReadPrnInfo2},
    {PRST_PRINTER_INFO_7,               &TPrnStream::ReadPrnInfo7},
    {PRST_COLOR_PROF,                   &TPrnStream::ReadColorProfiles},
    {PRST_PRINTER_SEC,                  &TPrnStream::ReadPrnSecurity},
    {PRST_PRINTER_DEVMODE,              &TPrnStream::ReadPrnInfo8},
    {0,                                 NULL}};

    //
    // delete in case QueryPrinterInfo was previously called
    // m_pPrnBinItem store a PrnBinInfo block when Query ;
    // it has to be deleted between to Querys and at destruction time
    //
    if(m_pPrnBinItem)
    {
        delete m_pPrnBinItem;
    }

    hr DBGNOCHK = S_OK;

    for(int idx = 0 ; QueryFunctTable[idx].iKeyWord && SUCCEEDED(hr); idx++)
    {
        if(Flags & QueryFunctTable[idx].iKeyWord)
        {
            hr DBGCHK = (this->*QueryFunctTable[idx].pReadFunct)(&m_pPrnBinItem);

            if(SUCCEEDED(hr))
            {
                DBGMSG( DBG_TRACE, ( "QueryPrinterInfo: pReadFunct OK \n"));

                pPrstInfo->pi2 = reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(m_pPrnBinItem) + m_pPrnBinItem->pData);

            }
            else
            {
                DBGMSG( DBG_TRACE, ( "QueryPrinterInfo: pReadFunct FAILED \n"));
            }
        }

    }


    return hr;

}

/*++

Title:

    RestorePrinterInfo

Routine Description:

    Handle port name conflicts by calling PortNameCase before any restoring
    Define restoring function table and calls restoring functions based on flag value

Arguments:

    flags   -   flags that specifies that functions should be called

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrinterInfo(
    IN  DWORD       Flags,
    OUT DWORD&      RestoredFlags
    )
{

    TStatusH    hr;

    hr DBGNOCHK = S_OK;


    static PrstFunctEntry RestoreFunctTable [] = {
    {PRST_PRINTER_INFO_2,               &TPrnStream::RestorePrnInfo2},
    {PRST_COLOR_PROF,                   &TPrnStream::RestoreColorProfiles},
    {PRST_PRINTER_DEVMODE,              &TPrnStream::RestorePrnDevMode},
    {PRST_PRINTER_INFO_7,               &TPrnStream::RestorePrnInfo7},
    {PRST_PRINTER_DATA,                 &TPrnStream::RestorePrnData},
    {PRST_PRINTER_SEC,                  &TPrnStream::RestorePrnSecurity},
    {PRST_USER_DEVMODE,                 &TPrnStream::RestoreUserDevMode},
    {0,                                 NULL}};


    //
    // initialize the flags that were successfully stored with 0
    //
    RestoredFlags = 0;

    //
    // if  PRST_RESOLVE_PORT is set , update m_ResolveCase so RestorePrnInfo2 can act properly
    //
    PortNameCase(Flags);

    //
    // If PRST_DONT_CHANGE_DRIVER is set, update m_ResolveCase
    //
    DriverNameCase(Flags);

    //
    // if  PRST_RESOLVE_SHARE is set , update m_ResolveCase so RestorePrnInfo2 can act properly
    //
    ShareNameCase(Flags);

    for(int idx = 0 ; RestoreFunctTable[idx].iKeyWord && SUCCEEDED(hr); idx++)
    {
        if(Flags & RestoreFunctTable[idx].iKeyWord)
        {
            hr DBGCHK = (this->*RestoreFunctTable[idx].pPrstFunc)();

            if(SUCCEEDED(hr))
            {
                RestoredFlags |= RestoreFunctTable[idx].iKeyWord;
            }

        }

    }


    return hr;

}
/*++

Title:

    bStorePrnInfo2

Routine Description:

    Build an item based on P_I_2 and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnInfo2(
    VOID
    )
{
    DWORD               cbSize;
    TStatusH            hr;
    TStatusB            bStatus;
    LPPRINTER_INFO_2    lpPrinterInfo2 = NULL;


    //
    // Get P_I_2
    //
    cbSize = 1;

    if(bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                    2,
                                    reinterpret_cast<PVOID*>(&lpPrinterInfo2),
                                    &cbSize))
    {
        DBGMSG( DBG_TRACE,  ("StorePrnInfo2 %d \n" , cbSize) );

        hr DBGCHK = WritePrnInfo2(lpPrinterInfo2, cbSize);

        FreeMem(lpPrinterInfo2);

    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_PI2);
    }

    return hr;

}

/*++

Title:

    bRestorePrnInfo2

Routine Description:

    Apply P_I_2 settings read from stream  to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnInfo2(
    VOID
    )
{
    PrnBinInfo*         pSourcePI2 = NULL;
    TStatusH            hr;
    TStatusB            bStatus;
    PRINTER_INFO_2*     pDestinationPI2 = NULL;
    DWORD               cbSize = 0;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo2(&pSourcePI2);

    if(SUCCEEDED(hr))
    {
        cbSize = 1;

        bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                     2,
                                     reinterpret_cast<PVOID*>(&pDestinationPI2),
                                     &cbSize);

        if(bStatus)
        {
            LPTSTR* ppszDrvName       = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pDriverName
                                         );


            LPTSTR* ppszStoredPrnName = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pPrinterName
                                         );

            LPTSTR* ppShareName       = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pShareName
                                         );

            LPTSTR* ppPortName       = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pPortName
                                         );

            LPTSTR* ppPrintProcessor = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pPrintProcessor
                                         );

            LPDWORD pAttributes = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->Attributes
                                         );

            DBGMSG(DBG_TRACE , (" Stored Prn Name: "TSTR" Share:"TSTR"\n" , *ppszStoredPrnName , *ppShareName));

            if( (m_ResolveCase & kDontChangeDriver) && 
                (_tcsicmp( pDestinationPI2->pDriverName, *ppszDrvName ) != 0))
            {
                hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);

                goto End;
            }


            //
            //  check against printer name
            //
            if( _tcsicmp( pDestinationPI2->pPrinterName, *ppszStoredPrnName ) != 0)
            {
                if(m_ResolveCase & kResolveName)
                {
                    // RESOLVE!!!
                    // if printer name differs from printer name stored into file ,
                    // update read structure with open printer
                    //
                    DBGMSG(DBG_TRACE , (" RESOLVE Printer : "TSTR" Share:"TSTR" old : "TSTR"\n" , *ppszStoredPrnName , *ppShareName , pDestinationPI2->pShareName));

                    *ppszStoredPrnName = pDestinationPI2->pPrinterName;


                }
                else if(m_ResolveCase & kForceName)
                {
                    // FORCE!!!
                    // if printer name differs from printer name stored into file ,
                    // let printer name and share name as they are in the stored file
                    //

                    DBGMSG(DBG_TRACE , (" FORCE Printer : "TSTR" Share:"TSTR"\n" , *ppszStoredPrnName , *ppShareName));

                }
                else
                {

                    //
                    // if printer name differs from printer name stored into file ,
                    // return error ; printer names are different but the flags are not used
                    //
                    hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);

                    goto End;
                }
            }

            //
            //  if resolve port option was set , port name from the printer configuration settings to be ignored in lieu of
            //  the port name that printer curently has
            //
            if(m_ResolveCase & kResolvePort)
            {
                *ppPortName = pDestinationPI2->pPortName;;
            }


            //
            // if the print processor from the printer configuration settings differs from the curent installed print processor
            // just ignore it
            //
            if( _tcsicmp( pDestinationPI2->pPrintProcessor, *ppPrintProcessor) != 0 )
            {
                *ppPrintProcessor = pDestinationPI2->pPrintProcessor;
            }

            if((reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData))->pDevMode)
            {
                (reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData))->pDevMode = NULL;

                DBGMSG(DBG_TRACE , (" Reset devmode to NULL!\n" ));
            }

            //
            // Set printer with read settings
            //
            bStatus DBGCHK = SetPrinter(m_hPrinter,
                             2,
                             reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData,
                             0);

            //
            // If SetPrinter failed with ERROR_INVALID_SHARENAME and a resolve share flag is set,
            // retry call SetPrinter with a new generated share name
            //
            if(!bStatus &&
               (m_ResolveCase & ( kUntouchShare | kGenerateShare )) &&
               GetLastError() == ERROR_INVALID_SHARENAME)
            {

                TString strShareName;
                TString strPrinterName( pDestinationPI2->pPrinterName );

                //
                // If already shared, use the current share name
                // Even if generating share flag is set, don't create a new share name
                // as long as the printer is shared. The whole point of this share name generation is
                // to allow the printer to be shared, but since it is , don't waist any time.
                //
                if( pDestinationPI2->Attributes & PRINTER_ATTRIBUTE_SHARED &&
                    pDestinationPI2->pShareName &&
                    pDestinationPI2->pShareName[0] )
                {
                    *ppShareName  = pDestinationPI2->pShareName;
                    *pAttributes |= PRINTER_ATTRIBUTE_SHARED;

                }
                else
                {
                    //
                    // Resolve share name by generating a new share name
                    //
                    if(m_ResolveCase & kGenerateShare)
                    {
                        if( VALID_OBJ( strPrinterName ) )
                        {
                            bStatus DBGCHK = bNewShareName(pDestinationPI2->pServerName, strPrinterName, strShareName);

                            *ppShareName  = (LPTSTR)(LPCTSTR)(strShareName);
                            *pAttributes |= PRINTER_ATTRIBUTE_SHARED;

                            //
                            // *ppShareName is NULL if bNewShareName fails
                            //
                            DBGMSG( DBG_TRACE, ( "Created share name for " TSTR " " TSTR "\n", (LPCTSTR)strPrinterName, (LPCTSTR)strShareName ) );
                        }

                    }

                    //
                    // Don't share it at all
                    //
                    if(m_ResolveCase & kUntouchShare)
                    {
                        *pAttributes &= ~PRINTER_ATTRIBUTE_SHARED;
                        *ppShareName  = NULL;
                    }

                }

                //
                // Set printer with read settings
                //
                bStatus DBGCHK = SetPrinter(m_hPrinter,
                                 2,
                                 reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData,
                                 0);

                DBGMSG(DBG_TRACE , (" RESOLVE Printer : "TSTR" Share:"TSTR"\n" , *ppszStoredPrnName , *ppShareName));

            }

            if(bStatus)
            {
                hr DBGNOCHK = S_OK;

                DBGMSG(DBG_TRACE , (" SetPrinter on level 2 succeeded!\n" ));
            }
            else
            {

             hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);

            }
End:
            FreeMem(pSourcePI2);

            if(pDestinationPI2 != NULL)
            {
                FreeMem(pDestinationPI2);
            }

        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);
        }
    }


    return hr;
}

/*++

Title:

    bStorePrnInfo7

Routine Description:

    Build an item based on P_I_7 and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnInfo7(
    VOID
    )
{
    DWORD                               cbSize;
    TStatusH                        hr;
    TStatusB                        bStatus;
    LPPRINTER_INFO_7    lpPrinterInfo7 = NULL;

    //
    // Get P_I_7
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 7,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo7),
                                 &cbSize);

    if(bStatus)
    {
        //
        // remove DSPRINT_PENDING flags
        //
        lpPrinterInfo7->dwAction &= ~DSPRINT_PENDING;

        hr DBGCHK = WritePrnInfo7(lpPrinterInfo7, cbSize);

        FreeMem(lpPrinterInfo7);

    }
    else
    {
        if(GetLastError() == ERROR_INVALID_LEVEL)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_PI7);
        }

    }

    return hr;
}

/*++

Title:

    RestorePrnInfo7

Routine Description:

    Apply P_I_7 settings read from stream  to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnInfo7(
    VOID
    )
{
    DWORD           cbSize;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus;
    DWORD           LastError;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo7(&lpPrnBinItem);

    if(SUCCEEDED(hr) && lpPrnBinItem)
    {
        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     7,
                                     reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData,
                                     0);

        LastError = GetLastError();
        if(LastError == ERROR_IO_PENDING ||
           LastError == ERROR_DS_UNAVAILABLE)
        {
            //
            // If the error is io  pending the spooler
            // will publish in the background therefore we will silently fail.
            // and
            // The server must be stand alone and/or DirectoryService is not available.
            // Just continue.
            //
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI7);

        }

        FreeMem(lpPrnBinItem);
    }

    return hr;
}

/*++

Title:

    StorePrnSecurity

Routine Description:

    Build an item based on security descriptor and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR_GET_SEC error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnSecurity(
    VOID
    )
{
    DWORD           cbSize;
    TStatusH        hr;
    TStatusB        bStatus;
    PRINTER_INFO_2* lpPrinterInfo2 = NULL;


    //
    // Get P_I_2
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 2,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo2),
                                 &cbSize);
    if(bStatus)
    {
        hr DBGCHK = WritePrnSecurity(lpPrinterInfo2, cbSize);

        FreeMem(lpPrinterInfo2);

    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_SEC);
    }

    return hr;
}

/*++

Title:

    RestorePrnSecurity

Routine Description:

    Apply security descriptor read from stream to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/

HRESULT
TPrnStream::
RestorePrnSecurity(
    VOID
    )
{
    DWORD           cbSize;
    PRINTER_INFO_3  PrinterInfo3;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnSecurity(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        PrinterInfo3.pSecurityDescriptor =  reinterpret_cast<PSECURITY_DESCRIPTOR>(
                                            reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData
                                            );
        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     3,
                                     reinterpret_cast<LPBYTE>(&PrinterInfo3),
                                     0);
        if(bStatus)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_SEC);
        }

        FreeMem(lpPrnBinItem);

    }

    return hr;
}

/*++

Title:

    StoreUserDevMode

Routine Description:

    Build an item based on user dev mode and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StoreUserDevMode(
    VOID
    )
{
    DWORD               cbSize;
    TStatusH            hr;
    TStatusB            bStatus;
    LPPRINTER_INFO_9    lpPrinterInfo9 = NULL;

    //
    // Get P_I_9
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 9,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo9),
                                 &cbSize);
    if(bStatus)
    {
        //
        // call WritePrnInfo9 even if lpPrinterInfo9 is null ;
        // usually, when printer doesn't have a user mode attached ,is lpPrinterInfo9->pDevMode who is null
        // but still call it and check lpPrinterInfo9 == NULL on WritePrnInfo9, to act similar as lpPrinterInfo9->pDevMode == NULL
        //
        hr DBGCHK = WritePrnInfo9(lpPrinterInfo9, cbSize);

        FreeMem(lpPrinterInfo9);

    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_USR_DEVMODE);
    }

    return hr;
}
/*++

Title:

    RestoreUserDevMode

Routine Description:

    Apply user dev mode read from stream to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestoreUserDevMode(
    VOID
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    PRINTER_INFO_9  PrinterInfo9;
    TStatusH        hr;
    TStatusB        bStatus;
    DWORD           cbSize;


    hr DBGNOCHK = E_FAIL;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo9(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        if(lpPrnBinItem != NULL)
        {
            PrinterInfo9.pDevMode = reinterpret_cast<DEVMODE*>(
                                    reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData
                                    );
        }
        else
        {
            //
            // User dev mode can be null if there are no Printer prefferences set at the time the file is created
            // We remove per user devmode by calling SetPrinter with pDevMode equal with NULL
            //
            DBGMSG(DBG_TRACE , ("NO USER DEVMODE STORED!!!\n"));

            PrinterInfo9.pDevMode = NULL;
        }

        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     9,
                                     reinterpret_cast<LPBYTE>(&PrinterInfo9),
                                     0);

        if(bStatus)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_USR_DEVMODE);
        }


        FreeMem(lpPrnBinItem);

    }

    return hr;
}




/*++

Title:

    StorePrnDevMode

Routine Description:

    Build an item based on printer dev mode and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnDevMode(
    VOID
    )
{
    DWORD               cbSize;
    TStatusH            hr;
    TStatusB            bStatus;
    LPPRINTER_INFO_8    lpPrinterInfo8 = NULL;

    hr DBGNOCHK = E_FAIL;
    //
    // Get P_I_8
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 8,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo8),
                                 &cbSize);
    if(bStatus)
    {
        bStatus DBGCHK = (lpPrinterInfo8->pDevMode != NULL);

        if(bStatus)
        {
            hr DBGCHK = WritePrnInfo8(lpPrinterInfo8, cbSize);
        }

        FreeMem(lpPrinterInfo8);

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_PRN_DEVMODE);
    }

    return hr;
}

/*++

Title:

    RestorePrnDevMode

Routine Description:

    Apply printer dev mode read from stream to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnDevMode(
    VOID
    )
{
    DWORD           cbSize;
    PRINTER_INFO_8  PrinterInfo8;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus;
    BOOL            bInsidePI2;

    hr DBGNOCHK = E_FAIL;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo8(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        PrinterInfo8.pDevMode = reinterpret_cast<DEVMODE*>(
                                reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData
                                );
        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     8,
                                     reinterpret_cast<LPBYTE>(&PrinterInfo8),
                                     0);

        if(bStatus)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PRN_DEVMODE);
        }


        FreeMem(lpPrnBinItem);

    }

    return hr;
}

/*++

Title:

    StoreColorProfiles

Routine Description:

    strore a multi zero string with color profiles into stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StoreColorProfiles(
    VOID
    )
{
    TStatusH                    hr;
    TStatusB                        bStatus;

    DWORD           cbSize;
    DWORD           dwProfiles;
    ENUMTYPE        EnumType;

    LPTSTR          mszProfileNames;

    ZeroMemory(&EnumType, sizeof(EnumType));

    EnumType.dwSize      = sizeof(EnumType);
    EnumType.dwVersion   = ENUM_TYPE_VERSION;
    EnumType.dwFields    = ET_DEVICENAME | ET_DEVICECLASS;
    EnumType.pDeviceName = static_cast<LPCTSTR>(m_strPrnName);
    EnumType.dwDeviceClass = CLASS_PRINTER;


    cbSize = 0;

    m_EnumColorProfiles(NULL, &EnumType, NULL, &cbSize, &dwProfiles);

    mszProfileNames = (LPTSTR)AllocMem(cbSize);

    bStatus DBGCHK = (mszProfileNames != NULL);

    if(bStatus)
    {

        bStatus DBGCHK = m_EnumColorProfiles( NULL,
                                            &EnumType,
                                            reinterpret_cast<LPBYTE>(mszProfileNames),
                                            &cbSize,
                                            &dwProfiles);
        if(bStatus)
        {
            hr DBGCHK = WriteColorProfiles(reinterpret_cast<LPBYTE>(mszProfileNames), cbSize);
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_COLOR_PRF);
        }


        FreeMem(mszProfileNames);
    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_COLOR_PRF);
    }


    return hr;
}

/*++

Title:

    DeleteColorProfiles

Routine Description:

    deletes all profiles associated with printer
    it is called on restoring color settings; needed because if a new color profile is added ,
    settings from file will be restored on top ( #bug 274657)
    it could work Ok without calling this function when P_I_2 is also restored, because there color profiles are "somehow" restored,
    but even so, success was depending on the order of calls,which is bogus

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
BOOL
TPrnStream::
DeleteColorProfiles(
    VOID
    )
{
    TStatusB    bStatus;

    DWORD           cbSize;
    DWORD           cbPrfSize;
    DWORD           dwProfiles;
    ENUMTYPE        EnumType;

    LPTSTR          mszProfileNames;

    ZeroMemory(&EnumType, sizeof(EnumType));

    EnumType.dwSize        = sizeof(EnumType);
    EnumType.dwVersion     = ENUM_TYPE_VERSION;
    EnumType.dwFields      = ET_DEVICENAME | ET_DEVICECLASS;
    EnumType.pDeviceName   = static_cast<LPCTSTR>(m_strPrnName);
    EnumType.dwDeviceClass = CLASS_PRINTER;


    cbSize = 0;

    m_EnumColorProfiles(NULL, &EnumType, NULL, &cbSize, &dwProfiles);

    mszProfileNames = (LPTSTR)AllocMem(cbSize);

    bStatus DBGCHK = (mszProfileNames != NULL);

    if(bStatus)
    {

        bStatus DBGCHK = m_EnumColorProfiles( NULL,
                                            &EnumType,
                                            reinterpret_cast<LPBYTE>(mszProfileNames),
                                            &cbSize,
                                            &dwProfiles);
        if(bStatus)
        {
            LPTSTR pszProfileName = mszProfileNames;

            for(bStatus DBGNOCHK = TRUE ,cbPrfSize = 0; (cbPrfSize < cbSize) && bStatus;)
            {

                //
                // skip last two zeros
                //
                if(_tcsclen(pszProfileName) > 0)
                {
                    DBGMSG( DBG_TRACE, ( "DisassociateColorProfileWithDevice  "TSTR" ::  " TSTR " \n" ,
                    static_cast<LPCTSTR>(m_strPrnName) , pszProfileName ));

                    bStatus DBGCHK = m_DisassociateColorProfileFromDevice(NULL, pszProfileName, m_strPrnName);
                }

                cbPrfSize += (_tcsclen(pszProfileName) + 2) * sizeof(TCHAR);

                pszProfileName = pszProfileName + _tcsclen(pszProfileName) + 1;

            }

        }


        FreeMem(mszProfileNames);
    }


    return bStatus;
}

/*++

Title:

    RestoreColorProfiles

Routine Description:

    Reads multi zero string from stream and for every sz calls AssociateColorProfileWithDevice

Arguments:

    NONE

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestoreColorProfiles(
    VOID
    )
{
    DWORD           cSize;
    DWORD           i;
    LPTSTR          pszProfileName;
    LPTSTR          aszProfileNames;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus(DBG_WARN, ERROR_INSUFFICIENT_BUFFER);


    hr DBGCHK = ReadColorProfiles(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        //
        // first delete color profiles assoc with printer; fix for bug 274657
        //
        bStatus DBGCHK = DeleteColorProfiles();

        if(bStatus)
        {
            aszProfileNames = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData);

            cSize = lpPrnBinItem->cbData/sizeof(TCHAR);

            //
            // Traverse multisz string from tail to head starting with the first zero.
            // I relay on the fact that multisz is terminated by 2 zeros.
            // Default color profile is last color profile associated and we should preserve this setting.
            //
            for( bStatus DBGNOCHK = TRUE, i = 2; i <= cSize && bStatus; )
            {
                pszProfileName = aszProfileNames + cSize - i;

                if( *(pszProfileName - 1) == 0 || (i == cSize) )
                {
                    DBGMSG( DBG_TRACE, ( "AssociateColorProfileWithDevice  "TSTR" ::  " TSTR " \n" ,
                    static_cast<LPCTSTR>(m_strPrnName) , pszProfileName ));

                    bStatus DBGCHK = m_AssociateColorProfileWithDevice(NULL, pszProfileName, m_strPrnName);

                    hr DBGCHK = bStatus ? S_OK : MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_COLOR_PRF);

                }

                i++;

            }

        }

        FreeMem(lpPrnBinItem);
    }

    return hr;
}

/*++

Title:

    WritePrnData

Routine Description:

    Build an PrnBinInfo item from key and value and write it into stream, at current position

  steps:

        WriteHeader: if header is not wrriten into file , write it down
                Read from header number of items currently written
                Read from header where prn data items begins
                If no other items where written,get current position and after items storing, update header with start position
                Build an PrnBinInfo item and write it into stream, at current position
                Increase number of written items and Update header

Arguments:

    pKey            - key name ;

    pValueName      - key value ;

    cbValueName     - count bytes of pValueName

    dwType          - type

    pData           - actually data

    cbData          - count bytes of pData

Return Value:

    S_OK  if succeded


--*/
HRESULT
TPrnStream::
WritePrnData(
    IN  LPCTSTR pKey,
    IN  LPCTSTR pValueName,
    IN  DWORD   cbValueName,
    IN  DWORD   dwType,
    IN  LPBYTE  pData,
    IN  DWORD   cbData
    )
{
    ULARGE_INTEGER          culiPrnDataItems;
    ULARGE_INTEGER          uliCurrentPos;
    ULARGE_INTEGER          uliPrnDataRoot;
    TStatusB                bStatus;
    TStatusH                hr;

    bStatus DBGNOCHK = TRUE;

    //
    // Read from header number of items currently written
    //
    hr DBGCHK = ReadFromHeader(kcItems, &culiPrnDataItems);

    if(SUCCEEDED(hr))
    {
        //
        // Read from header where info begins in stream
        //
        hr DBGCHK = ReadFromHeader(kPrnDataRoot, &uliPrnDataRoot);

        if(SUCCEEDED(hr))
        {
            if(uliPrnDataRoot.QuadPart == 0)
            {
                // Get current seek position ; it will be stored in header
                //
                DBGMSG( DBG_TRACE, ( "TPrnStream::bWritePrnData:: First prn data item!\n " ));

                hr DBGCHK =  GetCurrentPosition(uliCurrentPos);

            }

            if(SUCCEEDED(hr))
            {
                //
                // Store item
                //
                hr DBGCHK = WriteItem(  pKey,
                                        pValueName,
                                        cbValueName,
                                        ktREG_TYPE + dwType,
                                        pData,
                                        cbData);
                if(SUCCEEDED(hr))
                {
                    //
                    // Updates number of items and start position in case that bWritePrnData succeded
                    // and it was the first prn data item written
                    //
                    culiPrnDataItems.QuadPart++;

                    hr DBGCHK = UpdateHeader(TPrnStream::kcItems, culiPrnDataItems);

                    if(SUCCEEDED(hr)  && uliPrnDataRoot.QuadPart == 0)
                    {
                        //
                        // Update header with position where item begins if it was the first prn data item written
                        //
                        hr DBGCHK = UpdateHeader(TPrnStream::kPrnDataRoot, uliCurrentPos);

                    }

                }

            }

        }

    }

    return hr;
}
/*++

Title:

    ReadNextPrnData

Routine Description:

    Read a printer data item from stream

Arguments:

    Param pointers will point inside of lpBuffer:

    pKey            - key name ;not null

        pValueName      - key value ;not  null

        cbValueName     - count bytes of pValueName

        dwType          - type

        pData           - actually data

        cbData          - count bytes of pData


        lpBuffer    -   a null ptr that will contain ptr to read item;
                    must be deallocated by the caller if function succeed

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadNextPrnData(
    OUT LPTSTR& lpszKey,
    OUT LPTSTR& lpszVal,
    OUT DWORD&  dwType,
    OUT LPBYTE& lpbData,
    OUT DWORD&  cbSize,
    OUT LPBYTE& lpBuffer    ORPHAN
    )
{
    TStatusH        hr;
    PrnBinInfo*     lpPrnBinItem = NULL;

    lpszKey = NULL;
    lpszVal = NULL;
    lpbData = NULL;
    lpBuffer = NULL;

    cbSize = 0;

    //
    // Initialization!!!
    // m_cIndex is current item for reading ; m_cPrnDataItems is  number of items in stream ( entry in header )
    // chesk to see if no items where read or if all itemes where read and m_cIndex passed the printers data area in stream
    //
    if((m_cPrnDataItems.QuadPart == 0) || (m_cIndex > m_cPrnDataItems.QuadPart))
    {
        //
        // Read from header number of printer data items in stream
        //
        hr DBGCHK = ReadFromHeader(kcItems, &m_cPrnDataItems);

        if(FAILED(hr))
        {
            goto End;
        }
        //
        // Read from header where info begins in stream
        // m_uliSeekPtr seek ptr will be always positioned where item begins
        //
        hr DBGCHK = ReadFromHeader(kPrnDataRoot, &m_uliSeekPtr);

        if(FAILED(hr))
        {
            goto End;
        }

        m_cIndex = 0;
    }

    if(m_cIndex == m_cPrnDataItems.QuadPart)
    {
        DBGMSG( DBG_TRACE, ( "bReadNextPrnData :: Reach end of prn data items \n" ));

        hr DBGNOCHK = STG_E_SEEKERROR;

        //
        // this way I indicate that I reached the end ;
        // next call will see that m_cIndex > m_cPrnDataItems.QuadPart and will do the same as if
        // I call this first time
        //
        m_cIndex++;

    }
    else
    {
        //
        // dwSeekPtr will be set to the position where next prn data item begins
        //
        hr DBGCHK = ReadItemFromPosition(m_uliSeekPtr, lpPrnBinItem);

        if(SUCCEEDED(hr))
        {
            m_cIndex++;

            lpszKey = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pKey);
            lpszVal = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pValue);
            lpbData = reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData;
            cbSize  = lpPrnBinItem->cbData;
            dwType  = lpPrnBinItem->dwType - ktREG_TYPE;

        }

    }


    End:

    if(FAILED(hr) && hr != STG_E_SEEKERROR)
    {
        //
        // build my own result ; it will override STG_ results
        //
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PRNDATA);
    }

    return hr;
}

/*++

Title:

    WritePrnInfo2

Routine Description:

    Build an item based on P_I_2 and write it into the stream
    Convert P_I_2 into a flat buffer( LPTSTR -> offsets)
    Build a PrnBinInfo item and write it into stream

Arguments:

    lpPrinterInfo2  -   ptr to P_I_2

    cbPI2Size       - P_I_2 buff size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo2(
    IN  PRINTER_INFO_2* lpPrinterInfo2,
    IN  DWORD           cbPI2Size
    )
{

    DWORD           dwWritten;
    ULARGE_INTEGER  uliCurrentPos;
    TStatusH        hr;
    TStatusB        bStatus;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo2 != NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            //
            // Convert P_I_2 to flat buffer
            //
            lpPrinterInfo2->pSecurityDescriptor = 0;

            MarshallDownStructure(reinterpret_cast<LPBYTE>(lpPrinterInfo2),
                                  PrinterInfo2Fields,
                                  sizeof(PRINTER_INFO_2),
                                  RPC_CALL);

            //
            // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
            //
            hr DBGCHK = WriteItem(NULL, NULL, 0, ktPrnInfo2 ,reinterpret_cast<LPBYTE>(lpPrinterInfo2), cbPI2Size);

            if(SUCCEEDED(hr))
            {
                //
                // Update header entry with start position in stream
                //
                hr DBGCHK = UpdateHeader(kPrnInfo2, uliCurrentPos);

                //
                // Printer name entry in header will point inside PI2
                // if PI2 is not stored , printer name will be stored like an usual item
                //
                if(SUCCEEDED(hr))
                {
                    //uliCurrentPos.QuadPart += OFFSETOF(PRINTER_INFO_2, pPrinterName);

                    hr DBGCHK = UpdateHeader(kPrnName, uliCurrentPos);

                }

            }

        }

    }


    if(FAILED(hr))
    {
        //
        // build my own result
        //
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PI2);
    }

    return hr;
}


/*++

Title:

    WritePrnName

Routine Description:

    Build a PrnBinInfo item from printer name and write it into stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnName(
    VOID
    )
{

    ULARGE_INTEGER          uliCurrentPos;
    TStatusH                hr;

    hr DBGNOCHK = E_FAIL;


    //
    // Get item's start position
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPos);

    if(SUCCEEDED(hr))
    {
        //
        // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
        //
        hr DBGCHK = WriteItem(  NULL,
                                NULL,
                                0,
                                ktPrnName ,
                                reinterpret_cast<LPBYTE>(const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strPrnName))),
                                (m_strPrnName.uLen() + 1) * sizeof(TCHAR));


        if(SUCCEEDED(hr))
        {
            hr DBGCHK = UpdateHeader(kPrnName, uliCurrentPos);
        }
    }

    if(FAILED(hr))
    {
        //
        // build my own result
        //
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PI2);
    }

    return hr;
}


/*++

Title:

    ReadPrnInfo2

Routine Description:

    Reads the P_I_2 entry in stream ;

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo2(
    OUT PrnBinInfo**        lppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;
    TStatusB        bStatus;


    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK = TRUE;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kPrnInfo2, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        //
        // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
        //
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

            if(SUCCEEDED(hr))
            {
                hr DBGCHK = MarshallUpItem(lpPrnBinItem);
            }
        }
        else
        {
            hr DBGCHK = E_FAIL;
        }
    }


    if(FAILED(hr))
    {
        if( lpPrnBinItem )
        {
            FreeMem(lpPrnBinItem);
        }

        *lppPrnBinItem = NULL;

        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PI7);
    }
    else
    {
        *lppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    ReadPrnName

Routine Description:

    Reads the P_I_2 entry in stream; if not P_I_2 settings stored , reads PrnName entry

Arguments:

    strPrnName    -  printer name read from file

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadPrnName(
    OUT     TString&        strPrnName
    )
{
    PrnBinInfo*         lpPrnBinItem = NULL;
    TStatusH            hr;
    ULARGE_INTEGER      uliSeekPtr;
    LPTSTR              lpszPrnName;
    

    //
    // Reads PRINTER_INFO_2 settings stored in stream.
    // Printer Name is not stored if  PRINTER_INFO_2 are stored.
    //
    hr DBGCHK = ReadPrnInfo2(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        //
        // printer name points inside P_I_2
        //

        DBGMSG( DBG_TRACE, ( "PrnName inside P_I2 \n"));

        lpszPrnName = (reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData)->pPrinterName);

        hr DBGCHK = strPrnName.bUpdate(lpszPrnName) ? S_OK : E_FAIL;

        DBGMSG( DBG_TRACE, ( "PrnName "TSTR" \n" , static_cast<LPCTSTR>(strPrnName)));

    }
    else
    {
        //
        // Reads the Header entry for Printer name.
        //
        hr DBGCHK = ReadFromHeader(kPrnName, &uliSeekPtr);

        if(SUCCEEDED(hr))
        {
            //
            // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
            //
            if(uliSeekPtr.QuadPart > 0)
            {
                //
                // Read an item from specified position
                //

                hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

                if(SUCCEEDED(hr))
                {
                    DBGMSG( DBG_TRACE, ( "ReadPrnName from %d %d \n" , uliSeekPtr.HighPart, uliSeekPtr.LowPart));

                    hr DBGCHK = strPrnName.bUpdate(reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData)) ?
                                S_OK : E_FAIL;

                    DBGMSG( DBG_TRACE, ( "PrnName "TSTR" \n" , static_cast<LPCTSTR>(strPrnName)));

                }
                else
                {
                    hr DBGCHK = E_FAIL;
                }

            }
            else
            {
                hr DBGCHK = E_FAIL;
            }

        }
    }

    if (lpPrnBinItem)
    {
        FreeMem(lpPrnBinItem);
    }

    return hr;
}


/*++

Title:

    WritePrnInfo7

Routine Description:

    Build an item based on P_I_7 and write it into the stream
    PRINTER_INFO_7.pszObjectGUID set on NULL because at restoring it has to be null -> no flat pointer conversion needed

Arguments:

    lpPrinterInfo7  -   ptr to P_I_7

    cbPI7Size       -   P_I_7 buff actual size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo7(
    IN  PRINTER_INFO_7* lpPrinterInfo7,
    IN  DWORD           cbPI7Size
    )
{

    DWORD           dwWritten;
    ULARGE_INTEGER  uliCurrentPos;
    TStatusB        bStatus;
    TStatusH        hr;


    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo7 != NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            //
            // Convert P_I_7 to flat buffer
            //

            lpPrinterInfo7->pszObjectGUID = NULL;

            MarshallDownStructure(reinterpret_cast<LPBYTE>(lpPrinterInfo7),
                                  PrinterInfo7Fields,
                                  sizeof(PRINTER_INFO_7),
                                  RPC_CALL);

            //
            // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
            //
            hr DBGCHK = WriteItem(NULL, NULL, 0, ktPrnInfo7 ,reinterpret_cast<LPBYTE>(lpPrinterInfo7), cbPI7Size);

            //
            // Update header entry with start position in stream
            //
            if(SUCCEEDED(hr))
            {
                hr DBGCHK = UpdateHeader(kPrnInfo7, uliCurrentPos);
            }
        }
    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PI7);
    }

    return hr;
}


/*++

Title:

    ReadPrnInfo7

Routine Description:

    Reads the P_I_7 entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo7(
    OUT  PrnBinInfo**   lppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusB        bStatus;
    TStatusH        hr;


    hr DBGNOCHK = E_FAIL;
    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kPrnInfo7, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        //
        // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
        // function will succeed
        //
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //

            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

            if(SUCCEEDED(hr))
            {
                hr DBGCHK = MarshallUpItem(lpPrnBinItem);
            }
        }
        else
        {
            hr DBGCHK = E_FAIL;
        }
    }

    if(FAILED(hr))
    {
        *lppPrnBinItem = NULL;

        if( lpPrnBinItem )
        {
            FreeMem(lpPrnBinItem);
        }

        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PI7);
    }
    else
    {
        *lppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WritePrnSecurity

Routine Description:

    Build an item based on SecurityDescriptor and write it into the stream

Arguments:

    lpPrinterInfo2  -   ptr to P_I_2

    cbPI2Size       - P_I_2 buff size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed
--*/
HRESULT
TPrnStream::
WritePrnSecurity(
    IN  PRINTER_INFO_2* lpPrinterInfo2,
    IN  DWORD           cbPI2Size
    )
{
    DWORD           cbSize;
    DWORD           dwWritten;
    ULARGE_INTEGER  uliCurrentPos;
    TStatusB    bStatus;
    TStatusH    hr;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo2 != NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            if(lpPrinterInfo2->pSecurityDescriptor != NULL)
            {
                cbSize = GetSecurityDescriptorLength(lpPrinterInfo2->pSecurityDescriptor);

                bStatus DBGCHK =( cbSize >= SECURITY_DESCRIPTOR_MIN_LENGTH);

                //
                // alloc mem for flat buffer
                //
                if(bStatus)
                {
                    //
                    // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
                    //
                    hr DBGCHK = WriteItem(  NULL,
                                            NULL,
                                            0,
                                            ktSecurity ,
                                            reinterpret_cast<LPBYTE>(lpPrinterInfo2->pSecurityDescriptor),
                                            cbSize);

                    if(SUCCEEDED(hr))
                    {
                        //
                        // Update header entry with start position in stream
                        //
                        hr DBGCHK = UpdateHeader(kSecurity, uliCurrentPos);
                    }
                }
                else
                {
                    hr DBGCHK = E_FAIL;
                }

            }

        }

    }


    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_SEC);
    }

    return hr;

}

/*++

Title:

    ReadPrnSecurity

Routine Description:

    Reads the Security entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnSecurity(
    OUT PrnBinInfo**    ppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;


    hr DBGNOCHK = E_FAIL;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kSecurity, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        //
        // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
        //
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //

            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }
        else
        {
            hr DBGCHK = E_FAIL;
        }

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_SEC);

        *ppPrnBinItem = NULL;
    }
    else
    {
        *ppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WritePrnInfo8

Routine Description:

    Call WriteDevMode to write devmode into stream

Arguments:

    lpPrinterInfo8  -   ptr to P_I_8

    cbSize          -   P_I_8 buffer actual size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo8(
    IN  PRINTER_INFO_8* lpPrinterInfo8,
    IN  DWORD           cbSize
    )
{
    TStatusB bStatus;
    TStatusH hr;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo8 != NULL) && (lpPrinterInfo8->pDevMode != NULL);

    if(bStatus)
    {
        hr DBGCHK = WriteDevMode(   lpPrinterInfo8->pDevMode,
                                    lpPrinterInfo8->pDevMode->dmSize + lpPrinterInfo8->pDevMode->dmDriverExtra,
                                    kPrnDevMode);
    }


    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PRN_DEVMODE);
    }

    return hr;
}

/*++

Title:

    ReadPrnInfo8

Routine Description:

    Reads the Printer Dev Mode entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

    bInsidePI2      -   TRUE if global dev mode was inside P_I_2 item

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo8(
    OUT PrnBinInfo**    lppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;

    hr DBGNOCHK = E_FAIL;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kPrnDevMode, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        if(uliSeekPtr.QuadPart == 0)
        {
            //
            // no dev mode stored
            //
            hr DBGCHK = E_FAIL;
        }
        else
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }

    }


    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PRN_DEVMODE);

        *lppPrnBinItem = NULL;
    }
    else
    {
        *lppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WritePrnInfo9

Routine Description:

    Call WriteDevMode to write devmode into stream

Arguments:

    lpPrinterInfo9  -   ptr to P_I_9

    cbSize          -   P_I_9 buff size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo9(
    IN  PRINTER_INFO_9* lpPrinterInfo9,
    IN  DWORD           cbSize
    )
{
    TStatusB bStatus;
    TStatusH hr;
    ULARGE_INTEGER  uliCurrentPos;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo9 != NULL) && (lpPrinterInfo9->pDevMode != NULL);

    if(bStatus)
    {
        hr DBGCHK = WriteDevMode(   lpPrinterInfo9->pDevMode,
                                    lpPrinterInfo9->pDevMode->dmSize + lpPrinterInfo9->pDevMode->dmDriverExtra,
                                    kUserDevMode);

    }
    else
    {
        //
        // set entry in header to a dummy value to show that dev mode was null
        //

        DBGMSG(DBG_TRACE , ("WritePrnInfo9 NO USER DEVMODE\n"));

        //
        // fix for bug 273541
        // For the case when per user dev mode is null , update the header with a special value ,
        // to signal that per user dev mode was stored in file.
        //
        uliCurrentPos.HighPart = -1;
        uliCurrentPos.LowPart  = -1;

        hr DBGCHK = UpdateHeader(kUserDevMode, uliCurrentPos);
    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_USR_DEVMODE);
    }

    return hr;
}

/*++

Title:

    ReadPrnInfo9

Routine Description:

    Reads the User Dev Mode entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo9(
    OUT PrnBinInfo**    ppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;

    hr DBGNOCHK = E_FAIL;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kUserDevMode, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        if(uliSeekPtr.QuadPart == 0)
        {
            //
            // no dev mode stored because no flags were specified
            //
            hr DBGCHK = E_FAIL;
        }
        else if(uliSeekPtr.LowPart == -1 && uliSeekPtr.HighPart == -1)
        {
            //
            // dev mode was null at the time it was stored ( no Printing Prefferences set )
            //
            hr DBGNOCHK = S_OK;

            *ppPrnBinItem = NULL;
        }
        else
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_USR_DEVMODE);

        *ppPrnBinItem = NULL;
    }
    else
    {
        *ppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WriteColorProfiles

Routine Description:

    Build a PrnBinInfo item from a multi sz string that contains color profiles names

Arguments:

    lpProfiles  -   ptr to multi zero string

    cbSize       -  multi zero string size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WriteColorProfiles(
    IN LPBYTE   lpProfiles,
    IN DWORD    cbSize
    )
{
    ULARGE_INTEGER          uliCurrentPos;
    TStatusB                bStatus;
    TStatusH                hr;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpProfiles !=  NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            //
            // Writes profiles(MULTI_SZ) into stream (WriteItem builds PrnBinInfo)
            //
            hr DBGCHK = WriteItem(NULL, NULL, 0, ktColorProfile, lpProfiles, cbSize);

            //
            // Update header entry with start position in stream
            //
            if(SUCCEEDED(hr))
            {
                hr DBGCHK = UpdateHeader(kColorProfile, uliCurrentPos);
            }
        }
    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_COLOR_PRF);
    }

    return hr;
}

/*++

Title:

    ReadColorProfiles

Routine Description:

    Reads the color profile entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadColorProfiles(
    OUT PrnBinInfo**    ppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kColorProfile, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }
        else
        {
            hr DBGCHK = E_FAIL;
        }

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_COLOR_PRF);

        *ppPrnBinItem = NULL;
    }
    else
    {
        *ppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WriteHeader

Routine Description:

    Write header at the begining of file ; the header is null initialized

    steps:

        Write header into the stream; this is the very first writing operation
        It reserves space at the beginning of stream for writing info about items inside the stream
        StorePrintreInfo function will call WriteHeader before any other writing operation
        If P_I_2 flag is NOT specified , write printre name as item ; if it is , printe name  will be stored with P_I_2

Arguments:

    Flags   -   flags specified at storing time ; needed for printer name handling

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
WriteHeader(
    IN DWORD    Flags
    )
{
    PrnHeader               PrinterHeader;
    DWORD                   dwSize = 0;
    LARGE_INTEGER           liStart = {0};
    TStatusH                hr;
    TStatusB                bStatus;

    // Init hr with S_OK;if header is already written in stream, this will be the return value
    //
    hr DBGNOCHK = S_OK;

    //
    // m_bHeaderWritten indicates if header was written into file
    //
    if(!m_bHeaderWritten)
    {
        //
        // Output the header.  This basically reserves
        // space at the beginning of the stream to store
        // the item-count.
        //
        PrinterHeader.pPrnName.QuadPart      = 0;
        PrinterHeader.pPrnDataRoot.QuadPart  = 0;
        PrinterHeader.cItems.QuadPart        = 0;
        PrinterHeader.pUserDevMode.QuadPart  = 0;
        PrinterHeader.pPrnDevMode.QuadPart   = 0;
        PrinterHeader.pPrnInfo2.QuadPart     = 0;
        PrinterHeader.pPrnInfo7.QuadPart     = 0;
        PrinterHeader.pSecurity.QuadPart     = 0;
        PrinterHeader.pColorProfileSettings.QuadPart  = 0;

        //
        // Make sure our header is positioned at the beginning of the stream.
        //

        hr DBGCHK = m_pIStream->Seek( liStart, STREAM_SEEK_SET, NULL );

        //
        // Write the header
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = m_pIStream->Write((LPBYTE)&PrinterHeader, sizeof(PrnHeader), &dwSize);

            //
            // indicates if header was written into file
            //
            m_bHeaderWritten = TRUE;

            //
            //  write printer info into an entry if P_I_2 is not stored.
            // if it is , prn name in header will point inside P_I_2
            //
            if(SUCCEEDED(hr) && !(Flags & PRST_PRINTER_INFO_2))
            {
                hr DBGCHK = WritePrnName();
            }
        }

        DBGMSG( DBG_TRACE ,( "WriteHeader %x !!!\n" , hr));
    }

    return hr;
}

#if DBG
VOID
TPrnStream::
CheckHeader (
    IN  TPrnStream::EHeaderEntryType    eHeaderEntryType,
    IN  ULARGE_INTEGER                  uliInfo
    )
{

    TStatusH    hr;
    ULARGE_INTEGER  uliPtr;

    EHeaderEntryType HeaderEntries[] = { kPrnDataRoot,
                                         kcItems,
                                         kUserDevMode,
                                         kPrnDevMode,
                                         kPrnInfo2,
                                         kPrnInfo7,
                                         kSecurity,
                                         kColorProfile };

    for( DWORD i = 0; i < sizeof (HeaderEntries) / sizeof (DWORD); i++ )
    {
        hr DBGCHK = ReadFromHeader(HeaderEntries[i], &uliPtr);

        if (SUCCEEDED(hr)) {

            //
            // PI2 and Printer Name can point to the same location. Don't do this check!
            //
            if ( ! ( HeaderEntries[i] == kPrnInfo2 && eHeaderEntryType == kPrnName ) ||
                   ( HeaderEntries[i] == kPrnName  && eHeaderEntryType == kPrnInfo2) ) {

                if( (uliPtr.LowPart && uliPtr.LowPart == uliInfo.LowPart ) || (uliPtr.HighPart && uliPtr.HighPart == uliInfo.HighPart) ) {
                    DBGMSG( DBG_TRACE,("*******CheckHeader:  %d overwrites %d\n" , eHeaderEntryType , HeaderEntries[i]));
                }
            }
        }

    }


}

#endif

/*++

Title:

    UpdateHeader

Routine Description:

    Write Info at specified entry in header
    Current position in stream in not modified after this call

Arguments:

    eHeaderEntryType    -   Specify entry in header

    uliInfo             -   Can be a pointer inside stream or a number of items

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
UpdateHeader(
    IN  TPrnStream::EHeaderEntryType    eHeaderEntryType,
    IN  ULARGE_INTEGER                  uliInfo
    )
{
    DWORD           dwSize;
    ULARGE_INTEGER  uliCurrentPosition;
    ULARGE_INTEGER  uliLastCurrentPosition;
    LARGE_INTEGER   liStart;
    TStatusH        hr;

#if DBG
    CheckHeader(eHeaderEntryType, uliInfo);
#endif

    // Saves current position into stream
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPosition);

    if(SUCCEEDED(hr))
    {
        //
        // Position stream pointer into the header on the specified entry
        //
        liStart.LowPart  = eHeaderEntryType * sizeof(LARGE_INTEGER);
        liStart.HighPart = 0;

        hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );

        DBGMSG( DBG_TRACE,("TPrnStream::UpdateHeader\n Update at %d with %d\n" , liStart.LowPart , uliInfo));

        //
        // Setup the header information.
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = m_pIStream->Write(reinterpret_cast<LPVOID>(&uliInfo), sizeof(LARGE_INTEGER), &dwSize);
        }

        //
        // Restore stream current pointer (even if writing failed)
        //
        liStart.QuadPart = uliCurrentPosition.QuadPart;

        hr DBGCHK = m_pIStream->Seek( liStart, STREAM_SEEK_SET, &uliLastCurrentPosition );

        SPLASSERT( uliCurrentPosition.LowPart == uliLastCurrentPosition.LowPart );
        SPLASSERT( uliCurrentPosition.HighPart == uliLastCurrentPosition.HighPart );


    }

    return hr;
}

/*++

Title:

    ReadFromHeader

Routine Description:

    Read Info from specified entry in header
    Current position in stream in not modified after this call

Arguments:

    eHeaderEntryType    -   Specify entry in header

    puliInfo            -   holds the value found in header at position kHeaderEntryType

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadFromHeader(
    IN  TPrnStream::EHeaderEntryType    kHeaderEntryType,
    OUT ULARGE_INTEGER*                 puliInfo
    )
{
    DWORD                   dwSize;
    ULARGE_INTEGER  uliEntryInfo;
    ULARGE_INTEGER  uliCurrentPos;
    LARGE_INTEGER   liStart;
    TStatusH                hr;

    DBGMSG( DBG_NONE, ( "Read Header!\n"));

    //
    // Save current pos
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPos);

    if(SUCCEEDED(hr))
    {
        //
        // seek pointer has to point to kHeaderEntryType into IStream
        //
        liStart.LowPart  = kHeaderEntryType * sizeof(LARGE_INTEGER);
        liStart.HighPart = 0;

        hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );

        //
        // Read from header entry a DWORD
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = m_pIStream->Read(&uliEntryInfo, sizeof(LARGE_INTEGER), &dwSize);

            if(SUCCEEDED(hr))
            {
                puliInfo->QuadPart = uliEntryInfo.QuadPart;
            }
            else
            {
                DBGMSG( DBG_TRACE, ( "Read Header! FAILED !!!\n"));
            }

            //
            // Restore stream current pointer (even if reading failed)
            //
            liStart.QuadPart = uliCurrentPos.QuadPart;

            hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );
        }
    }

    return hr;
}

/*++

Title:

    WriteDevMode

Routine Description:

    Build a PrnBinInfo item from ->DevMode and write it into stream

Arguments:

    lpDevMode  -   ptr to DEVMODE

    cbSize       - buff size

    eDevModeType    - type : user / printer

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
WriteDevMode(
    IN  PDEVMODE            lpDevMode,
    IN  DWORD               cbSize,
    IN  EHeaderEntryType    eDevModeType
    )
{
    ULARGE_INTEGER  uliCurrentPos;
    TStatusB        bStatus;
    TStatusH        hr;

    //
    // Get item's start position
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPos);

    if(SUCCEEDED(hr))
    {
        //
        // Writes devmode into stream (WriteItem builds PrnBinInfo)
        //
        hr DBGCHK = WriteItem(  NULL,
                                NULL,
                                0,
                                ktDevMode,
                                reinterpret_cast<LPBYTE>(lpDevMode),
                                cbSize);

        //
        // Update header entry with start position in stream
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = UpdateHeader(eDevModeType, uliCurrentPos);
        }
    }

    return hr;
}

/*++

Title:

    AdjustItemSizeForWin64

Routine Description:

    The item will be reallocated on Win64.
    When the file is generated on Win32, the item's size must be adjusted
    so that the 64bit stucture will fit in.
    The design doesn't allow to differenciate between files generated on Win32
    and Win64, therefore the adjustment will be always performed for
    Win64 up marshalling .

Arguments:

    lpPrnBinItem -- reference to a pointer to the item to be adjusted.

Return Value:

    S_OK  if succeded
    A Win32 error code converted to HRESULT

--*/
HRESULT
TPrnStream::
AdjustItemSizeForWin64(
    IN  OUT PrnBinInfo   *&lpPrnBinItem,
    IN      FieldInfo    *pFieldInfo,
    IN      SIZE_T       cbSize,
        OUT SIZE_T       &cbDifference
    )
{
    TStatusB    bStatus;
    TStatusH    hr(DBG_WARN, HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    SIZE_T      cbWin32Size = 0;
    SIZE_T      cbWin64Size = cbSize;
    PrnBinInfo  *lpNewPrnBinItem = NULL;

    switch (kPointerSize)
    {
        case kSpl32Ptr:
        {
            cbDifference = 0;

            hr DBGNOCHK = S_OK;

            break;
        }
        case kSpl64Ptr:
        {
            //
            // Adjust item only on Win64
            //
            lpNewPrnBinItem = NULL;

            bStatus DBGCHK = GetShrinkedSize(pFieldInfo, &cbWin32Size);

            if ( bStatus )
            {
                //
                // Calculate the quantity the item must grow with.
                // It it the difference between the PRINTER_INFO_n size on
                // Win64 and Win32.
                //
                cbDifference = cbWin64Size - cbWin32Size;

                //
                // Allocate a bufer that will hold the adjusted item.
                //
                lpNewPrnBinItem = (PrnBinInfo*)AllocMem(lpPrnBinItem->cbSize + (DWORD)cbDifference);

                bStatus DBGCHK = !!lpNewPrnBinItem;

                if ( bStatus )
                {
                    //
                    // Copy the old item's content in the new buffer.
                    //
                    CopyMemory( lpNewPrnBinItem, lpPrnBinItem, lpPrnBinItem->cbSize);

                    //
                    // This memory move will make room for Win64 PRINTER_INFO_n to grow
                    // without corrupting data.
                    // Source: the spot right after flatened Win32 structure, which will
                    // contain data for items generated on Win32.
                    // Destination: the spot righ after Win64 structure. PRINTER_INFO_n data
                    // comes after this spot on Win64.
                    //
                    MoveMemory( (LPBYTE)lpNewPrnBinItem + lpNewPrnBinItem->pData + cbWin64Size,
                                (LPBYTE)lpNewPrnBinItem + lpNewPrnBinItem->pData + cbWin32Size,
                                lpNewPrnBinItem->cbData - cbWin32Size);

                    //
                    // Adjust new item's size.
                    //
                    lpNewPrnBinItem->cbData += (DWORD)cbDifference;

                    //
                    // Free the memory for the old item.
                    //
                    FreeMem(lpPrnBinItem);

                    lpPrnBinItem = lpNewPrnBinItem;

                }
            }

            if(bStatus)
            {
                hr DBGNOCHK = S_OK;
            }
            else
            {
                hr DBGCHK = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }
        default:
        {
            //
            // Invalid pointer size; should not occur.
            //
            hr DBGCHK = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            break;
        }
    }


    return hr;
}

/*++

Title:

    MarshallUpItem

Routine Description:

    Convert a "flat" PRINTER_INFO_2 item to an "alive" item.
    Pointers inside PRINTER_INFO_2 data be converted to offsets before the item
    is persisted in the file. The format of the flatened item must be the same
    between Win64 and Win32,since the file will roam across TS servers.

Arguments:

    lpPrnBinItem -- reference to a pointer to the item to be converted;

Return Value:

    S_OK  if succeded
    A Win32 error code converted to HRESULT

--*/
HRESULT
TPrnStream::
MarshallUpItem (
    IN  OUT PrnBinInfo*& lpPrnBinItem
    )
{
    TStatusB    bStatus;
    TStatusH    hr(DBG_WARN, HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    SIZE_T      cbDifference = 0;
    SIZE_T      cbSize;
    FieldInfo   *pPrinterInfoFields;

    bStatus DBGCHK = !!lpPrnBinItem;

    if(bStatus)
    {
        switch (lpPrnBinItem->dwType)
        {
            case ktPrnInfo2:
            {
                cbSize = sizeof(PRINTER_INFO_2);
                pPrinterInfoFields = PrinterInfo2Fields;
                break;
            }
            case ktPrnInfo7:
            {
                cbSize = sizeof(PRINTER_INFO_7);
                pPrinterInfoFields = PrinterInfo7Fields;
                break;
            }
            default:
            {
                bStatus DBGCHK = FALSE;
                break;
            }
        }

        if(bStatus)
        {
            //
            // This item will be reallocated when marshalled on Win64.
            // On Win64, the item's size must be increased with
            // the difference between strcuture's size on Win64 and Win32.
            // The item could have been generated on Win32 and there is no room
            // left for the structure to expand.
            //
            hr DBGCHK = AdjustItemSizeForWin64(lpPrnBinItem, pPrinterInfoFields, cbSize, cbDifference);


            if(SUCCEEDED(hr))
            {
                bStatus DBGCHK = MarshallUpStructure((LPBYTE)lpPrnBinItem + lpPrnBinItem->pData,
                                                     pPrinterInfoFields,
                                                     cbSize,
                                                     RPC_CALL);
                if(bStatus)
                {
                    hr DBGNOCHK = S_OK;
                }
                else
                {
                    hr DBGCHK = HRESULT_FROM_WIN32(GetLastError());
                }

                //
                // If the item was adjusted, the pointers inside PRINTER_INFO_2 must be adjusted as well.
                // AdjustPointers cannot be executed before marshalling because the structure is still flat
                // as on Win32 and the pointers are not in their Win64 location.
                //
                if ( bStatus && cbDifference )
                {
                    AdjustPointers ( (LPBYTE)lpPrnBinItem + lpPrnBinItem->pData,
                                      pPrinterInfoFields,
                                      cbDifference);
                }
            }
        }
    }

    return hr;
}

/*++

Title:

    AlignSize

Routine Description:

    align a sice to DWORD size

Arguments:

    cbSize  -   size to align

Return Value:

    cbSize  - value to align

--*/
DWORD
TPrnStream::
AlignSize(
    IN  DWORD cbSize
    )
{
    return((cbSize)+3)&~3;
}

/*++

Title:

    StorePrnData

Routine Description:

    Writes into stream printer data;
    calls bInternalWalk that browse the registry key and to store the  printer(registry) settings
    WalkIn and WalkPost virtual methods of WalkPrinterData over-rided to store value data

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/

HRESULT
TPrnStream::
StorePrnData(
    VOID
    )
{
    TString     strNullKey(_T(""));
    DWORD       cItems = 0;
    TStatusB    bStatus;


    //
    //      Proceed bInternalWalk for NULL key
    //
    bStatus DBGCHK = strNullKey.bValid();

    if(bStatus)
    {
        cItems = 0;

        bStatus DBGCHK = bInternalWalk(strNullKey, &cItems);
    }

    return bStatus ? S_OK : MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PRNDATA);

}

/*++

Title:

    bRestorePrnData

Routine Description:

    Restore printer data from file;
    Call ReadNextPrnData until all items are browsed in stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnData(
    VOID
    )
{
    LPTSTR      lpszKey;
    LPTSTR      lpszVal;
    DWORD       dwType;
    LPBYTE      lpbData;
    DWORD       cDataSize;
    LPBYTE      lpPrinterBinInfo;
    TStatusB    bStatus;
    TStatus     Status;
    TStatusH    hr(DBG_WARN, STG_E_SEEKERROR);



    bStatus DBGNOCHK = TRUE;

    while(bStatus)
    {
        hr DBGCHK = ReadNextPrnData(lpszKey, lpszVal, dwType, lpbData, cDataSize, lpPrinterBinInfo);

        DBGMSG( DBG_TRACE, ( "bReadNextPrnData :: key " TSTR " value " TSTR " \n" ,(LPCTSTR)lpszKey , (LPCTSTR)lpszVal ));

        bStatus DBGCHK = SUCCEEDED(hr);

        if(bStatus)
        {
            Status DBGCHK = SetPrinterDataExW(m_hPrinter,
                            lpszKey,
                            lpszVal,
                            dwType,
                            lpbData,
                            cDataSize);

            if(Status != ERROR_SUCCESS)
            {
                hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PRNDATA);
            }

            FreeMem(lpPrinterBinInfo);

        }

        if(hr == STG_E_SEEKERROR)
        {
            //
            // End of Prn Data
            //
            hr DBGNOCHK = S_OK;
        }


    }

    return hr;
}
/*++

Title:

    bWalkPost

Routine Description:

    call bWriteKeyData : store key values into stream

Arguments:

    strKey   -   name of the key to walk
    lpcItems -   if not null , outs number of items actually written

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWalkPost (
    IN    TString& strKey,
    OUT   LPDWORD  lpcItems
    )
{
    DBGMSG( DBG_TRACE, ( "WALK POST :: " TSTR "\n" , (LPCTSTR)strKey ));

    return bWriteKeyData(strKey, lpcItems);
}

/*++

Title:

    bWalkIn

Routine Description:

    call bWriteKeyData : store key values into stream

Arguments:

    strKey   -   name of the key to walk
    lpcItems -   if not null , outs number of items actually written

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWalkIn (
    IN    TString& strKey,
    OUT   LPDWORD  lpcItems
    )
{
    DBGMSG( DBG_TRACE, ( "WALK IN :: " TSTR "\n" , (LPCTSTR)strKey ));

    return bWriteKeyData(strKey, lpcItems);
}

/*++

Title:

    WriteKeyData

Routine Description:

    Writes into stream all values for a given key name;
    calls EnumPrinterDataEx and browse PRINTER_ENUM_VALUES array

Arguments:

    strKey   -   name of the key to write
    lpcItems - if not null , outs number of items actually written

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWriteKeyData(
    IN  LPCTSTR lpszKey,
    OUT LPDWORD lpcItems    OPTIONAL
    )
{

    *lpcItems = 0;
    LPPRINTER_ENUM_VALUES   apevData;
    UINT                    idx;
    DWORD                   dwRet;
    DWORD                   cbSize = 0;
    DWORD                   cbNeededSize = 0;
    DWORD                   cItems = 0;
    TStatus                 Status(ERROR_MORE_DATA);
    TStatusB                bStatus;

    //
    // Only write data if we are given a valid-key.
    //
    if((lpszKey == NULL) || (*lpszKey == _T('\0')))
    {
        bStatus DBGNOCHK = TRUE;

        goto End;
    }

    //
    // Determine the size necessary to store the enumerated data.
    //
    cbSize = 0;

    Status DBGCHK = EnumPrinterDataEx(m_hPrinter, lpszKey, NULL, 0, &cbNeededSize, &cItems);

    //
    // Current key has no values
    //
    if(cbNeededSize == 0 && Status == ERROR_MORE_DATA)
    {
        bStatus DBGNOCHK = TRUE;

        goto End;
    }

    //
    // If current key has values, then proceed to enumerate and write the values into stream
    //
    if(cbNeededSize && (Status == ERROR_MORE_DATA))
    {
        if(apevData = (LPPRINTER_ENUM_VALUES)AllocMem(cbNeededSize)) //AllocBytes
        {
            //
            // Enumerate all values for the specified key.  This
            // returns an array of value-structs.
            //
            Status DBGCHK  = EnumPrinterDataExW( m_hPrinter,
                                                 lpszKey,
                                                 reinterpret_cast<LPBYTE>(apevData),
                                                 cbNeededSize,
                                                 &cbSize,
                                                 &cItems);

            bStatus DBGCHK = (Status == ERROR_SUCCESS) && (cbNeededSize == cbSize);

            //
            // Enumerate all data for the specified key and write to the stream.
            //
            // Write all the values for this key.
            //
            for(idx = 0; (idx < cItems) && bStatus; idx++)
            {
                bStatus DBGCHK = bWriteKeyValue(static_cast<LPCTSTR>(lpszKey), apevData + idx);
            }

            *lpcItems = bStatus ? cItems : 0;

            FreeMem(apevData);
        }

    }


    End:

    return bStatus;
}

/*++

Title:

    bWriteKeyValue

Routine Description:

    Writes into stream a value with it's data for a given key name
    (Write key/value name and PRINTER_ENUM_VALUES into stream)

Arguments:

    lpszKey - Key name

    lpPEV   - pointer to PRINTER_ENUM_VALUES assoc with key

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWriteKeyValue(
    IN  LPCTSTR                 lpszKey,
    IN  LPPRINTER_ENUM_VALUES   lpPEV
    )
{
    TStatusB        bStatus;
    TStatusH        hr;

    hr DBGCHK = WritePrnData(   lpszKey,
                                lpPEV->pValueName,
                                lpPEV->cbValueName,
                                lpPEV->dwType,
                                lpPEV->pData,
                                lpPEV->cbData);

    bStatus DBGCHK = SUCCEEDED(hr);

    return bStatus;
}

/*++

Title:

    WriteItem

Routine Description:

    Build a PrnBinInfo item and write it into stream, at current position

Arguments:

    pKey            - key name ; null for items other than printer data
    pValueName      - key value ; null for items other than printer data
    cbValueName     - count bytes of pValueName
    dwType          - type
    pData           - actually data
    cbData          - count bytes of pData

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
WriteItem(
    IN  LPCTSTR         pKey,
    IN  LPCTSTR         pValueName,
    IN  DWORD           cbValueName,
    IN  DWORD           dwType,
    IN  LPBYTE          pData,
    IN  DWORD           cbData
    )
{
    DWORD         cbKeySize;
    DWORD         cbKey;
    DWORD         cbName;
    DWORD         cbSize;
    DWORD         dwWritten;
    PrnBinInfo*   lppbi;
    TStatusH      hr;
    TStatusB      bStatus;


    // Calculate aligned sizes for the key-name and key-value strings.
    //

    DBGMSG( DBG_TRACE, ( "TPrnStream::WriteItem\n KEY: " TSTR "" , pKey ));
    DBGMSG( DBG_TRACE, ( "VALUE: " TSTR "\n" , pValueName ));

    cbKeySize = (pKey != NULL) ? (_tcslen(pKey) + 1) * sizeof(TCHAR) : 0;

    cbKey     = AlignSize(cbKeySize);

    cbName    = AlignSize(cbValueName);


    // Calculate size necessary to hold our PrnBinInfo information
    // which is written into stream.
    //
    cbSize = sizeof(PrnBinInfo) + cbKey + cbName + cbData;

    cbSize = AlignSize(cbSize);

    //
    // Allocate space for the structure.
    //
    lppbi = (PrnBinInfo*)AllocMem(cbSize);

    bStatus DBGCHK = (lppbi != NULL);

    if(bStatus)
    {
        //
        // Initialize the structure elements.  Since this information
        // is written to file, we must take care to convert the
        // pointers to byte-offsets.
        //
        lppbi->cbSize  = cbSize;
        lppbi->dwType  = dwType;
        lppbi->pKey    = sizeof(PrnBinInfo);
        lppbi->pValue  = lppbi->pKey + cbKey;
        lppbi->pData   = lppbi->pValue + cbName;
        lppbi->cbData  = cbData;

        CopyMemory(reinterpret_cast<LPBYTE>(lppbi) + lppbi->pKey  , pKey      , cbKeySize);
        CopyMemory(reinterpret_cast<LPBYTE>(lppbi) + lppbi->pValue, pValueName, cbValueName);
        CopyMemory(reinterpret_cast<LPBYTE>(lppbi) + lppbi->pData , pData     , cbData);

        hr DBGCHK = m_pIStream->Write(lppbi, lppbi->cbSize, &dwWritten);

        FreeMem(lppbi);
    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr ;
}


/*++

Title:

    ReadItem

Routine Description:

    Read an item from a current position in stream

Arguments:

    Param pointers will point inside of lpBuffer:

    pKey            - key name ; null for items other than printer data
    pValueName      - key value ; null for items other than printer data
    cbValueName     - count bytes of pValueName
    dwType          - type
    pData           - actually data
    cbData          - count bytes of pData
    lpBuffer        - a null ptr that will contain ptr to read item;
                      must be deallocated by the caller if function succeed

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadItem(
    OUT LPTSTR& lpszKey,
    OUT LPTSTR& lpszVal,
    OUT DWORD&  dwType,
    OUT LPBYTE& lpbData,
    OUT DWORD&  cbSize,
    OUT LPBYTE& lpBuffer
    )
{
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;
    PrnBinInfo*     lpPrnBinItem = NULL;


    lpszKey = NULL;
    lpszVal = NULL;
    lpbData = NULL;
    lpBuffer = NULL;

    hr DBGCHK = GetCurrentPosition(uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        if(SUCCEEDED(hr))
        {
            lpszKey = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pKey);
            lpszVal = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pValue);
            lpbData = reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData;
            cbSize  = lpPrnBinItem->cbData;
            dwType  = lpPrnBinItem->dwType - ktREG_TYPE;

            lpBuffer = reinterpret_cast<LPBYTE>(lpPrnBinItem);

        }

    }
    else
    {
        hr DBGNOCHK = E_UNEXPECTED;
    }


    return hr;

}
/*++

Title:

    ReadItemFromPosition

Routine Description:

    Read an item from a given position in stream
    Set seek pointer at the begining of the item
        Read item's size
        Set seek pointer at the begining of the item
        Read item
        uliSeekPtr will contain the seek pointer value after item's reading


Arguments:

    uliSeekPtr   - in start of item ; outs current seek ptr

    lpPrnBinItem - ptr to read item

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadItemFromPosition(
    IN  OUT ULARGE_INTEGER&   uliSeekPtr,
        OUT PrnBinInfo   *&   pPrnBinItem
    )
{
    DWORD   cbReadedSize;
    DWORD   cbSize = 0;

    LARGE_INTEGER   liStart = {0};
    TStatusH        hr;

    pPrnBinItem = NULL;

    //
    // Position seek pointer to where the item begins
    //
    liStart.QuadPart  = uliSeekPtr.QuadPart;

    hr DBGCHK = m_pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

    if(SUCCEEDED(hr))
    {
        //
        // Read size of item
        //
        hr DBGCHK = m_pIStream->Read(&cbSize, sizeof(DWORD), &cbReadedSize);

        DBGMSG( DBG_TRACE,  ("TPrnStream::ReadItemFromPosition\n Read item's size %d\n" ,cbSize) );

        if(SUCCEEDED(hr))
        {
            //
            // Go for start position again
            //
            hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );

            if(SUCCEEDED(hr))
            {
                pPrnBinItem = (PrnBinInfo*)AllocMem(cbSize);

                hr DBGCHK = pPrnBinItem ? S_OK : E_OUTOFMEMORY;

                if(SUCCEEDED(hr))
                {
                    hr DBGCHK = m_pIStream->Read(reinterpret_cast<LPBYTE>(pPrnBinItem), cbSize, &cbReadedSize);

                    SUCCEEDED(hr) ? GetCurrentPosition(uliSeekPtr) : FreeMem(pPrnBinItem);
                }
            }
        }
    }

    return hr;
}

/*++

Title:

    GetCurrentPosition

Routine Description:

    Gets the current value of seek pointer into IStream

Arguments:

    uliCurrentPosition - outs current seek ptr

Return Value:

    TRUE  if succeded

--*/
HRESULT
TPrnStream::
GetCurrentPosition(
    OUT ULARGE_INTEGER& uliCurrentPosition
    )
{
    LARGE_INTEGER   liMove = {0};
    TStatusH  hr;

    uliCurrentPosition.QuadPart = 0;

    hr DBGCHK = m_pIStream->Seek( liMove , STREAM_SEEK_CUR, &uliCurrentPosition );

    return hr;

}

/*++

Title:

    GetItemSize

Routine Description:

    read item's size from stream

Arguments:

    kHeaderEntryType    -   specify entry in header associated with item

Return Value:

    item's size if succeeded or -1 if failed

--*/
DWORD
TPrnStream::
GetItemSize(
    IN  TPrnStream::EHeaderEntryType kHeaderEntryType
    )
{
    DWORD           cbItemSize   = -1;
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr   = {0};
    TStatusH        hr;
    TStatusB        bStatus;

    cbItemSize = 0;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kHeaderEntryType, &uliSeekPtr);

    //
    // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
    //

    if(SUCCEEDED(hr) && uliSeekPtr.QuadPart > 0)
    {
        //
        // Read an item from specified position
        //
        if(SUCCEEDED(hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem)))
        {
            cbItemSize = lpPrnBinItem->cbSize;
        }
    }

    return cbItemSize;

}

/*++

Title:

    InitalizeColorProfileLibrary

Routine Description:

    Loads and gets the needed procedure address for the color profile related
    functions.  This library is explicitly loaded and un loaded to impove
    load performce for winspool.drv.  Note winspool.drv is a common dll loaded
    by many applications so loading less libraries is a good thing.

Arguments:

    None.

Return Value:

    An HRESULT

--*/
HRESULT
TPrnStream::
InitalizeColorProfileLibrary(
    VOID
    )
{
    HRESULT hRetval = E_FAIL;

    m_pColorProfileLibrary = new TLibrary(L"mscms.dll");

    hRetval = m_pColorProfileLibrary && m_pColorProfileLibrary->bValid() ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        m_EnumColorProfiles                     = (pfnEnumColorProfilesW)m_pColorProfileLibrary->pfnGetProc("EnumColorProfilesW");
        m_AssociateColorProfileWithDevice       = (pfnAssociateColorProfileWithDeviceW)m_pColorProfileLibrary->pfnGetProc("AssociateColorProfileWithDeviceW");
        m_DisassociateColorProfileFromDevice    = (pfnDisassociateColorProfileFromDeviceW)m_pColorProfileLibrary->pfnGetProc("DisassociateColorProfileFromDeviceW");

        if (!m_EnumColorProfiles || !m_AssociateColorProfileWithDevice || !m_DisassociateColorProfileFromDevice)
        {
            hRetval = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }

    return hRetval;
}

/*++

Routine Description:

    Opens printer for specified access.

Arguments:

    pszPrinter - Name of printer to open.  szNULL or NULL implies local server.

    pdwAccess - On entry, holds desired access (pointer to 0 indicates
        maximal access).  On successful exit, holds access granted.
        If the call fails, this value is undefined.

    phPrinter - Returns the open printer handle.  On failure, this value
        is set to NULL.

Return Value:

    STATUS - win32 error code or ERROR_SUCCESS if successful.

--*/
STATUS
TPrnStream::
sOpenPrinter(
    LPCTSTR pszPrinter,
    PDWORD pdwAccess,
    PHANDLE phPrinter
    )
{
    STATUS Status = ERROR_SUCCESS;

    TStatusB bOpen( DBG_WARN,
                    ERROR_ACCESS_DENIED,
                    RPC_S_SERVER_UNAVAILABLE,
                    ERROR_INVALID_PRINTER_NAME );
    bOpen DBGNOCHK = FALSE;

    static const DWORD adwAccessPrinter[] = {
        PRINTER_ALL_ACCESS,
        PRINTER_READ,
        READ_CONTROL,
        0,
    };

    static const DWORD adwAccessServer[] = {
        SERVER_ALL_ACCESS,
        SERVER_READ,
        0,
    };

    PRINTER_DEFAULTS Defaults;
    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;

    if( pszPrinter && !pszPrinter[0] ){

        //
        // szNull indicates local server also; change it to
        // NULL since OpenPrinter only likes NULL.
        //
        pszPrinter = NULL;
    }

    //
    // Now determine whether we are opening a server or a printer.
    // This is very messy.  Look for NULL or two beginning
    // backslashes and none thereafter to indicate a server.
    //
    PDWORD pdwAccessTypes;

    if( !pszPrinter ||
        ( pszPrinter[0] == TEXT( '\\' ) &&
          pszPrinter[1] == TEXT( '\\' ) &&
          !_tcschr( &pszPrinter[2], TEXT( '\\' )))){

        pdwAccessTypes = (PDWORD)adwAccessServer;
    } else {
        pdwAccessTypes = (PDWORD)adwAccessPrinter;
    }

    if( *pdwAccess ){

        Defaults.DesiredAccess = *pdwAccess;

        bOpen DBGCHK = OpenPrinter( (LPTSTR)pszPrinter,
                                    phPrinter,
                                    &Defaults );

        if( !bOpen ){
            Status = GetLastError();
        }
    } else {

        //
        // If no access is specified, then attempt to retrieve the
        // maximal access.
        //
        UINT i;

        for( i = 0; !bOpen && pdwAccessTypes[i]; ++i ){

            Defaults.DesiredAccess = pdwAccessTypes[i];

            bOpen DBGCHK = OpenPrinter( (LPTSTR)pszPrinter,
                                        phPrinter,
                                        &Defaults );

            if( bOpen ){

                //
                // Return the access requested by the successful OpenPrinter.
                // On failure, this value is 0 (*pdwAccess undefined).
                //
                *pdwAccess = pdwAccessTypes[i];
                break;
            }

            Status = GetLastError();

            if( ERROR_ACCESS_DENIED != Status )
                break;
        }
    }

    if( !bOpen ){
        SPLASSERT( Status );
        *phPrinter = NULL;
        return Status;
    }

    SPLASSERT( *phPrinter );

    return ERROR_SUCCESS;
}

/*++

Routine Description:

    Gets printer information, reallocing as necessary.

Arguments:

    hPrinter - Printer to query.

    dwLevel - PRINTER_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

Return Value:

    TRUE = success, FALSE = fail.

--*/
BOOL
TPrnStream::
bGetPrinter(
    IN     HANDLE hPrinter,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer,
    IN OUT PDWORD pcbBuffer
    )
{
    DWORD cbNeeded;

    enum
    {
        kMaxPrinterInfo2             = 0x1000,
        kExtraPrinterBufferBytes     = 0x80
    };

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kMaxPrinterInfo2;
    }

Retry:

    SPLASSERT( *pcbBuffer < 0x100000 );

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            return FALSE;
        }
    }

    if( !GetPrinter( hPrinter,
                     dwLevel,
                     (PBYTE)*ppvBuffer,
                     *pcbBuffer,
                     &cbNeeded )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded + kExtraPrinterBufferBytes;
        SPLASSERT( *pcbBuffer < 0x100000 );

        goto Retry;
    }
    return TRUE;
}

BOOL
TPrnStream::
bNewShareName(
    IN  LPCTSTR lpszServer,
    IN  LPCTSTR lpszBaseShareName,
    OUT TString &strShareName
    )
{
    BOOL bReturn = FALSE;

    if( lpszServer && lpszBaseShareName )
    {
        HRESULT hr = CoInitialize(NULL);
        BOOL bInitializedCOM = SUCCEEDED(hr);

        TCHAR szBuffer[255];
        IPrintUIServices *pPrintUI = NULL;

        if( SUCCEEDED(hr) &&
            SUCCEEDED(hr = CoCreateInstance(CLSID_PrintUIShellExtension, 0, CLSCTX_INPROC_SERVER,
                IID_IPrintUIServices, (void**)&pPrintUI)) &&
            pPrintUI &&
            SUCCEEDED(hr = pPrintUI->GenerateShareName(lpszServer, lpszBaseShareName, szBuffer, COUNTOF(szBuffer))) )
        {
            strShareName.bUpdate(szBuffer);
            bReturn = TRUE;
        }
        else
        {
            SetLastError(HRESULT_CODE(hr));
        }

        if( pPrintUI )
        {
            pPrintUI->Release();
        }

        if( bInitializedCOM )
        {
            CoUninitialize();
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\prop.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    Prop.c

Abstract:

    Handles new entry points to document and device properties.

    Public Entrypoints:

        DocumentPropertySheets
        DevicePropertySheets

Author:

    Albert Ting (AlbertT) 25-Sept-1995
    Steve Kiraly (SteveKi) 02-Feb-1996

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "winddiui.h"

//
// UI user data structure definition.
//
typedef struct _UIUserData
{
    HANDLE  hModule;
    LPWSTR pszTitle;
} UIUserData;


BOOL
CreateUIUserData(
    IN OUT  UIUserData  **pData,
    IN      HANDLE      hPrinter
    )
/*++

Routine Description:

    This function creates the UI user data and loads the printer
    driver UI module.

Arguments:

    pData       pointer to where to return the pointer to the UI user data
    hPrinter    handle to the open printer

Return Value:

    TRUE the UI user data was alloceted, FALSE error occurred.

--*/
{
    SPLASSERT( pData );

    //
    // Allocate the UI user data.
    //
    *pData = AllocSplMem( sizeof( UIUserData ) );

    if( *pData )
    {
        //
        // The title is not allocated initaly.
        //
        (*pData)->pszTitle = NULL;

        //
        // Load the printer driver UI module.
        //
        (*pData)->hModule = LoadPrinterDriver( hPrinter );

        if( !(*pData)->hModule )
        {
            FreeSplMem( *pData );
            *pData = NULL;
        }
    }

    return !!*pData;
}

VOID
DestroyUIUserData(
    IN UIUserData **pData
    )
/*++

Routine Description:

    This function destroys the UI user data and unloads the printer
    driver UI module.

Arguments:

    pData       pointer to the UI user data

Return Value:

    Nothing.

--*/
{
    if( pData && *pData )
    {
        if( (*pData)->hModule )
        {
            RefCntUnloadDriver( (*pData)->hModule, TRUE );
            (*pData)->hModule = NULL;
        }

        if( (*pData)->pszTitle )
        {
            FreeSplMem( (*pData)->pszTitle );
            (*pData)->pszTitle = NULL;
        }

        FreeSplMem( *pData );

        *pData = NULL;
    }
}

VOID
CreatePrinterFriendlyName(
    IN UIUserData   *pData,
    IN LPCWSTR      pszName
    )
/*++

Routine Description:

    This function creates the printer friendly name and stores
    the new name in the UIUserData.

Arguments:

    pData       pointer to the UI user data
    pszName     pointer to the unfriendly printer name

Return Value:

    Nothing.  If the operation fails the unfriendly name is used.

--*/
{
    UINT        nSize   = 0;
    HINSTANCE   hModule = NULL;
    BOOL        bStatus = FALSE;

    //
    // Load printui, which knows how to format the friendly name.
    //
    hModule = LoadLibrary( szPrintUIDll );

    if( hModule )
    {
        typedef BOOL (*pfConstructPrinterFriendlyName)( LPCWSTR, LPWSTR, UINT * );

        pfConstructPrinterFriendlyName pfn;

        pfn = (pfConstructPrinterFriendlyName)GetProcAddress( hModule, szConstructPrinterFriendlyName );

        if( pfn )
        {
            //
            // Query for the friendly name size.
            //
            if( !pfn( pszName, NULL, &nSize ) && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // Allocate the friendly name buffer.
                //
                pData->pszTitle = AllocSplMem( (nSize+1) * sizeof(WCHAR) );

                if( pData->pszTitle )
                {
                    //
                    // Get the printer friendly name.
                    //
                    bStatus = pfn( pszName, pData->pszTitle, &nSize );
                }
            }
        }

        //
        // Release the library.
        //
        FreeLibrary( hModule );
    }

    //
    // Something failed use the unfriendly name.
    //
    if( !bStatus )
    {
        FreeSplMem( pData->pszTitle );

        pData->pszTitle = AllocSplStr( pszName );
    }
}

BOOL
FixUpDEVMODEName(
    PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    This function fixed up the returned DEVMODE with friendly printer name
    in the dmDeviceName field (cut off at 31 character as CCHDEVICENAME)


Arguments:

    pDPHdr  - Pointer to the DOCUMENTPROPERTYHEADER structure


Return Value:

    TRUE if frendly name is copied, FALSE otherwise


Author:

    08-Jul-1996 Mon 13:36:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PPRINTER_INFO_2 pPI2 = NULL;
    DWORD           cbNeed = 0;
    DWORD           cbRet = 0;
    BOOL            bCopy = FALSE;


    if ((pDPHdr->fMode & (DM_COPY | DM_UPDATE))                         &&
        (!(pDPHdr->fMode & DM_NOPERMISSION))                            &&
        (pDPHdr->pdmOut)                                                &&
        (!GetPrinter(pDPHdr->hPrinter, 2, NULL, 0, &cbNeed))            &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                   &&
        (pPI2 = AllocSplMem(cbNeed))                                    &&
        (GetPrinter(pDPHdr->hPrinter, 2, (LPBYTE)pPI2, cbNeed, &cbRet)) &&
        (cbNeed == cbRet)) {

        StringCchCopy(pDPHdr->pdmOut->dmDeviceName,
                      CCHDEVICENAME - 1,
                      pPI2->pPrinterName);        

        bCopy = TRUE;
    }

    if (pPI2) {

        FreeSplMem(pPI2);
    }

    return(bCopy);
}


LONG_PTR
DevicePropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    )
/*++

Routine Description:

    Adds the device specific printer pages.  This replaces
    PrinterProperties.

Arguments:

    pCPSUIInfo  - pointer to common ui info header.
    lParam      - user defined lparam, see compstui for details.
                  \nt\public\oak\inc\compstui.h

Return Value:

    Returns > 0 if success
    Returns <= 0 if failure

--*/

{
    PDEVICEPROPERTYHEADER       pDevPropHdr     = NULL;
    PPROPSHEETUI_INFO_HEADER    pCPSUIInfoHdr   = NULL;
    PSETRESULT_INFO             pSetResultInfo  = NULL;
    LONG_PTR                    lResult         = FALSE;
    HANDLE                      hModule         = NULL;
    INT_FARPROC                 pfn             = NULL;
    extern HANDLE hInst;

    DBGMSG( DBG_TRACE, ("DrvDevicePropertySheets\n") );

    //
    // Ony compstui requests, are acknowledged.
    //
    if (pCPSUIInfo) {

        if ((!(pDevPropHdr = (PDEVICEPROPERTYHEADER)pCPSUIInfo->lParamInit))    ||
            (pDevPropHdr->cbSize < sizeof(DEVICEPROPERTYHEADER))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        switch (pCPSUIInfo->Reason) {

        case PROPSHEETUI_REASON_INIT:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_INIT\n") );

            //
            // Create the UI User data.
            //
            if( CreateUIUserData( &(UIUserData *)(pCPSUIInfo->UserData), pDevPropHdr->hPrinter ) ){

                if( ((UIUserData *)(pCPSUIInfo->UserData))->hModule ){

                    //
                    // Get the driver property sheet entry.
                    //
                    if ((pfn = (INT_FARPROC)GetProcAddress( ((UIUserData *)(pCPSUIInfo->UserData))->hModule, szDrvDevPropSheets))) {

                        //
                        // Before calling into the driver to add pages make sure the proper
                        // fusion activation context is set.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_SET_FUSION_CONTEXT,
                                                               (LPARAM)ACTCTX_EMPTY,
                                                               (LPARAM)0);
                        //
                        // Common ui will call the driver to add it's sheets.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_ADD_PFNPROPSHEETUI,
                                                               (LPARAM)pfn,
                                                               pCPSUIInfo->lParamInit );
                    }
                }
            }

            //
            // If something failed ensure we free the library
            // if it was loaded.
            //
            if( lResult <= 0 ){

                DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_INIT failed with %d\n", lResult ) );

                DestroyUIUserData( &(UIUserData *)(pCPSUIInfo->UserData) );
            }

            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_GET_INFO_HEADER\n") );

            pCPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam;

            CreatePrinterFriendlyName( (UIUserData *)(pCPSUIInfo->UserData), pDevPropHdr->pszPrinterName );

            pCPSUIInfoHdr->pTitle     = ((UIUserData *)(pCPSUIInfo->UserData))->pszTitle;
            pCPSUIInfoHdr->Flags      = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pCPSUIInfoHdr->hInst      = hInst;
            pCPSUIInfoHdr->IconID     = IDI_CPSUI_PRINTER;

            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_SET_RESULT\n") );

            pSetResultInfo = (PSETRESULT_INFO)lParam;
            pCPSUIInfo->Result = pSetResultInfo->Result;
            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_DESTROY:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_DESTROY\n") );

            DestroyUIUserData( &(UIUserData *)(pCPSUIInfo->UserData) );

            lResult = TRUE;

            break;
        }
    }

    return lResult;

}

LONG_PTR
DocumentPropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    )
/*++

Routine Description:

    Adds the document property pages.  This replaces DocumentProperties
    and Advanced DocumentProperties.

Arguments:

    pCPSUIInfo  - pointer to common ui info header.
    lParam      - user defined lparam, see compstui for details.
                  \nt\public\oak\inc\compstui.h

Return Value:

    Returns > 0 if success
    Returns <= 0 if failure

--*/

{

    PDOCUMENTPROPERTYHEADER     pDocPropHdr     = NULL;
    PPROPSHEETUI_INFO_HEADER    pCPSUIInfoHdr   = NULL;
    PSETRESULT_INFO             pSetResultInfo  = NULL;
    LONG_PTR                    lResult         = FALSE;
    HANDLE                      hModule         = NULL;
    INT_FARPROC                 pfn             = NULL;
    extern HANDLE hInst;

    DBGMSG( DBG_TRACE, ("DrvDocumentPropertySheets\n") );

    //
    // Ony compstui requests, are acknowledged.
    //
    if (pCPSUIInfo) {

        if ((!(pDocPropHdr = (PDOCUMENTPROPERTYHEADER)pCPSUIInfo->lParamInit))    ||
            (pDocPropHdr->cbSize < sizeof(PDOCUMENTPROPERTYHEADER))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        switch (pCPSUIInfo->Reason) {

        case PROPSHEETUI_REASON_INIT:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_INIT\n") );

            if (!(pDocPropHdr->fMode & DM_PROMPT)) {

                SetLastError(ERROR_INVALID_PARAMETER);
                return 0;
            }

            //
            // Create the UI User data.
            //
            if( CreateUIUserData( &(UIUserData *)(pCPSUIInfo->UserData), pDocPropHdr->hPrinter ) ){

                if( ((UIUserData *)(pCPSUIInfo->UserData))->hModule ){

                    if (pfn = (INT_FARPROC)GetProcAddress( ((UIUserData *)(pCPSUIInfo->UserData))->hModule, szDrvDocPropSheets)) {

                        //
                        // Before calling into the driver to add pages make sure the proper
                        // fusion activation context is set.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_SET_FUSION_CONTEXT,
                                                               (LPARAM)ACTCTX_EMPTY,
                                                               (LPARAM)0);
                        //
                        // Common ui will call the driver to add it's sheets.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_ADD_PFNPROPSHEETUI,
                                                               (LPARAM)pfn,
                                                               pCPSUIInfo->lParamInit );
                    }
                }
            }

            //
            // If something failed ensure we free the library
            // if it was loaded.
            //
            if( lResult <= 0 ){

                DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_INIT failed with %d\n", lResult ) );

                DestroyUIUserData( &(UIUserData *)(pCPSUIInfo->UserData) );
            }

            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_GET_INFO_HEADER\n") );

            pCPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam;

            CreatePrinterFriendlyName( (UIUserData *)(pCPSUIInfo->UserData), pDocPropHdr->pszPrinterName );

            pCPSUIInfoHdr->pTitle     = ((UIUserData *)(pCPSUIInfo->UserData))->pszTitle;
            pCPSUIInfoHdr->Flags      = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pCPSUIInfoHdr->hInst      = hInst;
            pCPSUIInfoHdr->IconID     = IDI_CPSUI_PRINTER;

            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_SET_RESULT\n") );

            pSetResultInfo = (PSETRESULT_INFO)lParam;

            if ((pCPSUIInfo->Result = pSetResultInfo->Result) > 0) {

                FixUpDEVMODEName(pDocPropHdr);
            }

            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_DESTROY:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_DESTROY\n") );

            DestroyUIUserData( &(UIUserData*)(pCPSUIInfo->UserData) );

            lResult = TRUE;

            break;
        }

    //
    // If a null pointer to common ui info header then
    // call the driver directly.
    //
    } else {

        lResult     = -1;

        if ((!(pDocPropHdr = (PDOCUMENTPROPERTYHEADER)lParam))    ||
            (pDocPropHdr->cbSize < sizeof(PDOCUMENTPROPERTYHEADER))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return lResult;
        }

        if (pDocPropHdr->fMode & DM_PROMPT) {

            SetLastError(ERROR_INVALID_PARAMETER);

        } else if ((hModule = LoadPrinterDriver(pDocPropHdr->hPrinter)) &&
                   (pfn = (INT_FARPROC)GetProcAddress(hModule, szDrvDocPropSheets))) {

            if ((lResult = (*pfn)(NULL, pDocPropHdr)) > 0) {

                FixUpDEVMODEName(pDocPropHdr);
            }

        } else {

            SetLastError(ERROR_INVALID_HANDLE);
        }

        if (hModule) {

            RefCntUnloadDriver(hModule, TRUE);
        }
    }

    return lResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\pubprn.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Abstract:

    This module provides functionality for publishing printers

Author:

    Steve Wilson (NT) November 1997

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "pubprn.hxx"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"
#include "client.h"

#define PPM_FACTOR  48

BOOL
PublishPrinterW(
    HWND    hwnd,
    PCWSTR  pszUNCName,
    PCWSTR  pszDN,
    PCWSTR  pszCN,
    PWSTR  *ppszDN,
    DWORD   dwAction
)
{
    PRINTER_DEFAULTS    Defaults;
    HANDLE              hPrinter = NULL;
    HANDLE              hServer = NULL;
    PWSTR               pszServerName = NULL;
    PWSTR               pszPrinterName = NULL;
    PPRINTER_INFO_2     pInfo2 = NULL;
    DWORD               dwRet = ERROR_SUCCESS;
    DWORD               dwType;
    DWORD               dwMajorVersion;
    DWORD               dwDsPresent;
    DWORD               cbNeeded;
    DWORD               dwLength;
    HRESULT             hr;
    WCHAR               szDNSMachineName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    WCHAR               szFullUNCName[MAX_UNC_PRINTER_NAME];
    WCHAR               szShortServerName[MAX_PATH+1];
    PWSTR               pszFullUNCName;
    PWSTR               pszShortServerName;
    PWSTR               pszFullServerName;

    if (InCSRProcess()) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    hr = CoInitialize(NULL);
    if (hr != S_OK && hr != S_FALSE) {
        SetLastError((DWORD)((HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : hr));
        return FALSE;
    }


    if (ppszDN)
        *ppszDN = NULL;
    //
    // Get server name
    //
    if (dwRet = UNC2Server(pszUNCName, &pszServerName))
        goto error;

    if(!OpenPrinter(pszServerName, &hServer, NULL)) {
        dwMajorVersion = 0;

    } else {
        dwRet = GetPrinterData( hServer,
                                SPLREG_MAJOR_VERSION,
                                &dwType,
                                (PBYTE) &dwMajorVersion,
                                sizeof dwMajorVersion,
                                &cbNeeded);
        if (dwRet != ERROR_SUCCESS) {
            //
            // ignore errors and assume lowest version
            //
            dwMajorVersion = 0;
            dwRet = ERROR_SUCCESS;        
        }

        if (dwMajorVersion >= WIN2000_SPOOLER_VERSION) {

            hr = MachineIsInMyForest(pszServerName);

            if (FAILED(hr)) {
                dwRet = HRESULT_CODE(hr);
                goto error;
            } else if(HRESULT_CODE(hr) == 1) {
                //
                // Machine is in my forest and is NT5+
                //
                dwRet = ERROR_INVALID_LEVEL;
                goto error;
            } else {
                //
                // Downgrade the version for NT5+ printers published in a non-DS domain
                //
                dwMajorVersion = WIN2000_SPOOLER_VERSION;
            }
        }
    }

    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;

    Defaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter((PWSTR) pszUNCName, &hPrinter, &Defaults)) {
        dwRet = GetLastError();
        goto error;
    }

    hr = GetPrinterInfo2(hPrinter, &pInfo2);
    if (FAILED(hr)) {
        dwRet = HRESULT_CODE(hr);
        goto error;
    }

    if (dwRet = UNC2Printer(pInfo2->pPrinterName, &pszPrinterName))
        goto error;


    if( dwMajorVersion >= WIN2000_SPOOLER_VERSION){
        if(dwRet = GetPrinterData(  hServer,
                                    SPLREG_DNS_MACHINE_NAME,
                                    &dwType,
                                    (PBYTE) szDNSMachineName,
                                    (INTERNET_MAX_HOST_NAME_LENGTH + 1) * sizeof(WCHAR),
                                    &cbNeeded) != ERROR_SUCCESS ) {
            goto error;
        }

        if (FAILED(hr = StringCchPrintf( szFullUNCName, 
                                         COUNTOF(szFullUNCName), 
                                         L"\\\\%s\\%s", 
                                         szDNSMachineName, 
                                         pszPrinterName )))
        {
            dwRet = HRESULT_CODE(hr);
            goto error;
        }

        dwLength = MAX_PATH + 1;
        if (!DnsHostnameToComputerName(pszServerName,
                                       szShortServerName,
                                       &dwLength)) {
            dwRet = GetLastError();
            goto error;
        }

        pszFullUNCName = szFullUNCName;
        pszFullServerName = szDNSMachineName;
        pszShortServerName = szShortServerName+2;


    } else {

        pszFullUNCName = (PWSTR)pszUNCName;
        pszFullServerName = pszServerName+2;
        pszShortServerName = pszServerName+2;
    }

    //
    // Verify PrintQueue doesn't already exist
    //
    if (dwAction != PUBLISHPRINTER_IGNORE_DUPLICATES) {
        if(dwRet = PrintQueueExists(hwnd, hPrinter, pszFullUNCName, dwAction, (PWSTR) pszDN, (PWSTR *) ppszDN))
            goto error;
    }

    if (dwRet = PublishDownlevelPrinter(hPrinter,
                                        (PWSTR) pszDN,
                                        (PWSTR) pszCN,
                                        pszFullServerName,
                                        pszShortServerName,
                                        pszFullUNCName,
                                        pszPrinterName,
                                        dwMajorVersion,
                                        ppszDN))
        goto error;


error:

    if (hPrinter != NULL)
        ClosePrinter(hPrinter);

    if (hServer != NULL)
        ClosePrinter(hServer);

    if (pszServerName)
        FreeSplMem(pszServerName);

    if (pszPrinterName)
        FreeSplMem(pszPrinterName);

    FreeSplMem(pInfo2);

    if (dwRet != ERROR_SUCCESS) {
        SetLastError(dwRet);
        return FALSE;
    }


    CoUninitialize();

    return TRUE;
}

DWORD
PublishDownlevelPrinter(
    HANDLE  hPrinter,
    PWSTR   pszDN,
    PWSTR   pszCN,
    PWSTR   pszServerName,
    PWSTR   pszShortServerName,
    PWSTR   pszUNCName,
    PWSTR   pszPrinterName,
    DWORD   dwVersion,
    PWSTR   *ppszObjectDN
)
{
    HRESULT         hr = S_OK;
    DWORD           dwRet = ERROR_SUCCESS;
    IADs            *pPrintQueue = NULL;
    IADsContainer   *pADsContainer = NULL;
    IDispatch       *pDispatch = NULL;
    PWSTR           pszCommonName = pszCN;
    BSTR            bstrADsPath = NULL;
    PWSTR           pszDNWithDC = NULL;


    if (ppszObjectDN)
        *ppszObjectDN = NULL;
    //
    // If pszCN is not supplied, generate default common name
    //
    if (!pszCommonName || !*pszCommonName) {
        dwRet = GetCommonName(hPrinter, &pszCommonName);
        if (dwRet != ERROR_SUCCESS) {
            hr = dw2hr(dwRet);
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Stick DC in DN
    //
    if (!(pszDNWithDC = GetDNWithServer(pszDN))) {
        pszDNWithDC = pszDN;
    }

    //
    // Get container
    //
    hr = ADsGetObject(pszDNWithDC, IID_IADsContainer, (void **) &pADsContainer);
    BAIL_ON_FAILURE(hr);

    //
    // Create printqueue
    //
    hr = pADsContainer->Create(SPLDS_PRINTER_CLASS, pszCommonName, &pDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pDispatch->QueryInterface(IID_IADs, (void **) &pPrintQueue);
    BAIL_ON_FAILURE(hr);

    //
    // Set properties
    //
    hr = SetProperties( hPrinter,
                        pszServerName,
                        pszShortServerName,
                        pszUNCName,
                        pszPrinterName,
                        dwVersion,
                        pPrintQueue);
    BAIL_ON_FAILURE(hr);

    //
    // Get ADsPath to printQueue
    //
    if (ppszObjectDN) {
        hr = pPrintQueue->get_ADsPath(&bstrADsPath);
        BAIL_ON_FAILURE(hr);

        if (!(*ppszObjectDN = AllocGlobalStr(bstrADsPath))) {
            dwRet = GetLastError();
            hr = dw2hr(dwRet);
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    if (pszDNWithDC != pszDN)
        FreeSplMem(pszDNWithDC);

    if (bstrADsPath)
        SysFreeString(bstrADsPath);

    if (pszCommonName != pszCN)
        FreeSplMem(pszCommonName);

    if (pADsContainer)
        pADsContainer->Release();

    if (pDispatch)
        pDispatch->Release();

    if (pPrintQueue)
        pPrintQueue->Release();

    if (FAILED(hr) && ppszObjectDN && *ppszObjectDN)
        FreeGlobalStr(*ppszObjectDN);


    return hr2dw(hr);
}


HRESULT
SetProperties(
    HANDLE  hPrinter,
    PWSTR   pszServerName,
    PWSTR   pszShortServerName,
    PWSTR   pszUNCName,
    PWSTR   pszPrinterName,
    DWORD   dwVersion,
    IADs    *pPrintQueue
)
{
    HRESULT    hr;

    hr = SetMandatoryProperties(pszServerName,
                                pszShortServerName,
                                pszUNCName,
                                pszPrinterName,
                                dwVersion,
                                pPrintQueue);
    BAIL_ON_FAILURE(hr);

    SetSpoolerProperties(hPrinter, pPrintQueue, dwVersion);
    SetDriverProperties(hPrinter, pPrintQueue);


error:

    return hr;
}

HRESULT
SetMandatoryProperties(
    PWSTR   pszServerName,
    PWSTR   pszShortServerName,
    PWSTR   pszUNCName,
    PWSTR   pszPrinterName,
    DWORD   dwVersion,
    IADs    *pPrintQueue
)
{
    HRESULT         hr;
    //
    // ServerName
    //
    hr = put_BSTR_Property(pPrintQueue, SPLDS_SERVER_NAME, pszServerName);
    BAIL_ON_FAILURE(hr);

    //
    // ShortServerName
    //
    hr = put_BSTR_Property(pPrintQueue, SPLDS_SHORT_SERVER_NAME, pszShortServerName);
    BAIL_ON_FAILURE(hr);

    //
    // UNC Name
    //  
    hr = put_BSTR_Property(pPrintQueue, SPLDS_UNC_NAME, pszUNCName);
    BAIL_ON_FAILURE(hr);

    //
    // PrinterName
    //          
    hr = put_BSTR_Property(pPrintQueue, SPLDS_PRINTER_NAME, pszPrinterName);
    BAIL_ON_FAILURE(hr);

    //
    // versionNumber
    //
    hr = put_DWORD_Property(pPrintQueue, SPLDS_VERSION_NUMBER, &dwVersion);
    BAIL_ON_FAILURE(hr);

    hr = pPrintQueue->SetInfo();
    if (FAILED(hr))
        pPrintQueue->GetInfo();

error:

    return hr;
}



HRESULT
SetSpoolerProperties(
    HANDLE  hPrinter,
    IADs    *pPrintQueue,
    DWORD   dwVersion
)
{
    HRESULT         hr = E_FAIL;
    PPRINTER_INFO_2 pInfo2 = NULL;
    DWORD           cbNeeded;
    BYTE            Byte;
    PWSTR           psz;

    //
    // Get PRINTER_INFO_2 properties
    //
    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, 0, &cbNeeded)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            hr = dw2hr(GetLastError());
            goto error;
        }

        if (!(pInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded))) {
            hr = dw2hr(GetLastError());
            goto error;
        }

        if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, cbNeeded, &cbNeeded)) {
            hr = dw2hr(GetLastError());
            goto error;
        }
    
        //
        // Description
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_DESCRIPTION,
                            REG_SZ,
                            (PBYTE) pInfo2->pComment);
        //
        // Driver-Name
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_DRIVER_NAME,
                            REG_SZ,
                            (PBYTE) pInfo2->pDriverName);
        //
        // Location
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_LOCATION,
                            REG_SZ,
                            (PBYTE) pInfo2->pLocation);
        //
        // portName (Port1,Port2,Port3)
        //
        if (pInfo2->pPortName) {

            PWSTR pszPortName;
            //
            // copy comma delimited strings to Multi-sz format
            //
            pszPortName = DelimString2MultiSz(pInfo2->pPortName, L',');

            if (pszPortName) {
                hr = PublishDsData( pPrintQueue,
                                    SPLDS_PORT_NAME,
                                    REG_MULTI_SZ,
                                    (PBYTE) pszPortName);

                FreeSplMem(pszPortName);
            }
        }

        //
        // startTime
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_START_TIME,
                            REG_DWORD,
                            (PBYTE) &pInfo2->StartTime);
        //
        // endTime
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_END_TIME,
                            REG_DWORD,
                            (PBYTE) &pInfo2->UntilTime);


        // keepPrintedJobs
        Byte = pInfo2->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ? 1 : 0;

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_KEEP_PRINTED_JOBS,
                                        REG_BINARY,
                                    (PBYTE) &Byte );
        //
        // printSeparatorFile
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_SEPARATOR_FILE,
                                            REG_SZ,
                            (PBYTE) pInfo2->pSepFile);
        //
        // printShareName
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_SHARE_NAME,
                            REG_SZ,
                            (PBYTE) pInfo2->pShareName);
        //
        // printSpooling
        //
        if (pInfo2->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
            psz = L"PrintDirect";
        } else if (pInfo2->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST) {
            psz = L"PrintAfterSpooled";
        } else {
            psz = L"PrintWhileSpooling";
        }

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_SPOOLING,
                            REG_SZ,
                            (PBYTE) psz);

        //
        // priority
        //
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRIORITY,
                            REG_DWORD,
                            (PBYTE) &pInfo2->Priority);


        //
        // Non-Info2 properties
        // URL - downlevel machines don't support http printers, so don't publish useless url
        //

        if (dwVersion >= WIN2000_SPOOLER_VERSION) {

            DWORD dwRet, dwType;
            PWSTR pszUrl = NULL;

            //
            // Get the url from the print server
            //
            dwRet = GetPrinterDataEx(   hPrinter,
                                        SPLDS_SPOOLER_KEY,
                                        SPLDS_URL,
                                        &dwType,
                                        (PBYTE) pszUrl,
                                        0,
                                        &cbNeeded);

            if (dwRet == ERROR_MORE_DATA) {
                if ((pszUrl = (PWSTR) AllocSplMem(cbNeeded))) {
                    dwRet = GetPrinterDataEx(   hPrinter,
                                                SPLDS_SPOOLER_KEY,
                                                SPLDS_URL,
                                                &dwType,
                                                (PBYTE) pszUrl,
                                                cbNeeded,
                                                &cbNeeded);

                    if (dwRet == ERROR_SUCCESS && dwType == REG_SZ) {
                        hr = PublishDsData( pPrintQueue,
                                            SPLDS_URL,
                                            REG_SZ,
                                            (PBYTE) pszUrl);
                    }
                    FreeSplMem(pszUrl);
                }
            }
        }
    }

error:

    FreeSplMem(pInfo2);

    return hr;
}



HRESULT
SetDriverProperties(
    HANDLE   hPrinter,
    IADs    *pPrintQueue
)
{

    DWORD       i, cbBytes, dwCount;
    LPWSTR      pStr;
    DWORD       dwResult;
    LPWSTR      pOutput = NULL, pTemp = NULL, pTemp1 = NULL;
    DWORD       cOutputBytes, cTempBytes;
    POINTS      point;
    WCHAR       pBuf[100];
    BOOL        bInSplSem = TRUE;
    DWORD       dwTemp, dwPrintRate, dwPrintRateUnit, dwPrintPPM;
    HRESULT     hr = S_OK;
    PPRINTER_INFO_2 pInfo2 = NULL;
    PWSTR       pszUNCName;

    //
    // Get UNCName
    //
    hr = GetPrinterInfo2(hPrinter, &pInfo2);
    BAIL_ON_FAILURE(hr);

    if (!pInfo2) {
        hr = dw2hr(GetLastError());
        goto error;
    }

    pszUNCName = pInfo2->pPrinterName;


    //
    // DeviceCapability properties
    //
    pOutput = (PWSTR) AllocSplMem(cOutputBytes = 200);
    if (!pOutput) {
        hr = dw2hr(GetLastError());
        goto error;
    }

    pTemp = (PWSTR) AllocSplMem(cTempBytes = 200);
    if (!pTemp) {
        hr = dw2hr(GetLastError());
        goto error;
    }

    //
    // printBinNames
    //
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_BINNAMES,
                    24,
                    SPLDS_PRINT_BIN_NAMES);

    //
    // printCollate (awaiting DC_COLLATE)
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_COLLATE,
                                    NULL,
                                    NULL);

    if (dwResult != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_COLLATE,
                            REG_BINARY,
                            (PBYTE) &dwResult);
    }

    //
    // printColor
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                                    NULL,
                                    DC_COLORDEVICE,
                                    NULL,
                                    NULL);

    if (dwResult == GDI_ERROR) {
        //
        // Try alternative method
        //
        dwResult = ThisIsAColorPrinter(pszUNCName);
    }

    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_COLOR,
                        REG_BINARY,
                        (PBYTE) &dwResult);


    //
    // printDuplexSupported
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_DUPLEX,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_DUPLEX_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult);
    }

    //
    // printStaplingSupported
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_STAPLE,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_STAPLING_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult);
    }

    //
    // printMaxXExtent & printMaxYExtent
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_MAXEXTENT,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MAX_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

        dwTemp = (DWORD) point.y;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MAX_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

    }


    //
    // printMinXExtent & printMinYExtent
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_MINEXTENT,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MIN_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

        dwTemp = (DWORD) point.y;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MIN_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

    }

    //
    // printMediaSupported
    //
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_PAPERNAMES,
                    64,
                    SPLDS_PRINT_MEDIA_SUPPORTED);

    //
    // printMediaReady
    //
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_MEDIAREADY,
                    64,
                    SPLDS_PRINT_MEDIA_READY);

    //
    // printNumberUp
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_NUP,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {
        //
        // DS NUp is boolean
        //
        dwResult = !!dwResult;

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_DUPLEX_SUPPORTED,
                            REG_DWORD,
                            (PBYTE) &dwResult);
    }

    //
    // printMemory
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTERMEM,
                                    NULL,
                                    NULL);

    if (dwResult != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MEMORY,
                            REG_DWORD,
                            (PBYTE) &dwResult);
    }

    //
    // printOrientationsSupported
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_ORIENTATION,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        StringCchCopy(pStr = pBuf, COUNTOF(pBuf), L"PORTRAIT");
        
        if (dwResult == 90 || dwResult == 270) {

            ULONG cchBuf = wcslen(pBuf) + 1;
            StringCchCopy(pStr = pBuf + cchBuf, COUNTOF(pBuf) - cchBuf, L"LANDSCAPE");
        }
        else {
            pStr = pBuf;            
        }

        pStr += wcslen(pStr) + 1;
        *pStr++ = L'\0';

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_ORIENTATIONS_SUPPORTED,
                            REG_MULTI_SZ,
                            (PBYTE) pBuf);
    }

    //
    // printMaxResolutionSupported
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_ENUMRESOLUTIONS,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        if (cOutputBytes < dwResult*2*sizeof(DWORD)) {
            if(!(pTemp1 = (PWSTR) ReallocSplMem(pOutput, 0, cOutputBytes = dwResult*2*sizeof(DWORD))))
                goto error;
            pOutput = pTemp1;
        }

        dwResult = DeviceCapabilities(  pszUNCName,
                                        NULL,
                                        DC_ENUMRESOLUTIONS,
                                        pOutput,
                                        NULL);
        if (dwResult == GDI_ERROR)
            goto error;

        //
        // Find the maximum resolution: we have dwResult*2 resolutions to check
        //
        for(i = dwTemp = 0 ; i < dwResult*2 ; ++i) {
            if (((DWORD *) pOutput)[i] > dwTemp)
                dwTemp = ((DWORD *) pOutput)[i];
        }

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED,
                            REG_DWORD,
                            (PBYTE) &dwTemp);
    }

    //
    // printLanguage
    //
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_PERSONALITY,
                    32,
                    SPLDS_PRINT_LANGUAGE);

    //
    // printRate
    // NOTE: If PrintRate is 0, no value is published
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTRATE,
                                    NULL,
                                    NULL);

    dwPrintRate = dwResult ? dwResult : GDI_ERROR;
    if (dwPrintRate != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_RATE,
                            REG_DWORD,
                            (PBYTE) &dwPrintRate);
    }


    //
    // printRateUnit
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTRATEUNIT,
                                    NULL,
                                    NULL);

    dwPrintRateUnit = dwResult;
    if (dwPrintRateUnit != GDI_ERROR) {

        switch (dwPrintRateUnit) {
            case PRINTRATEUNIT_PPM:
                pStr = L"PagesPerMinute";
                break;

            case PRINTRATEUNIT_CPS:
                pStr = L"CharactersPerSecond";
                break;

            case PRINTRATEUNIT_LPM:
                pStr = L"LinesPerMinute";
                break;

            case PRINTRATEUNIT_IPM:
                pStr = L"InchesPerMinute";
                break;

            default:
                pStr = L"";
                break;
        }

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_RATE_UNIT,
                            REG_SZ,
                            (PBYTE) pStr);
    }

    //
    // printPagesPerMinute
    // DevCap returns 0 if there is no entry in GPD
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTRATEPPM,
                                    NULL,
                                    NULL);

    if (dwResult == GDI_ERROR)
        dwResult = 0;

    dwPrintPPM = dwResult;

    //
    // If dwPrintPPM == 0, then calculate PPM from PrintRate
    //
    if (dwPrintPPM == 0) {
        if (dwPrintRate == GDI_ERROR) {
            dwPrintPPM = GDI_ERROR;
        } else {
            switch (dwPrintRateUnit) {
                case PRINTRATEUNIT_PPM:
                    dwPrintPPM = dwPrintRate;
                    break;

                case PRINTRATEUNIT_CPS:
                case PRINTRATEUNIT_LPM:
                    dwPrintPPM = dwPrintRate/PPM_FACTOR;
                    if (dwPrintPPM == 0) {
                        //
                        // min PPM is 1
                        //
                        dwPrintPPM = 1;     
                    }
                    break;

                default:
                    dwPrintPPM = GDI_ERROR;
                    break;
            }
        }
    }

    if (dwPrintPPM != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_PAGES_PER_MINUTE,
                            REG_DWORD,
                            (PBYTE) &dwPrintPPM);
    }

    //
    // printDriverVersion
    //
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_VERSION,
                                    NULL,
                                    NULL);

    if (dwResult != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_DRIVER_VERSION,
                            REG_DWORD,
                            (PBYTE) &dwResult);
    }




error:

    FreeSplMem(pInfo2);

    if (pOutput)
        FreeSplMem(pOutput);

    if (pTemp)
        FreeSplMem(pTemp);

    return hr;
}



HRESULT
PublishDsData(
    IADs   *pADs,
    PWSTR  pValue,
    DWORD  dwType,
    PBYTE  pData
)
{
    HRESULT hr;
    BOOL    bCreated = FALSE;

    switch (dwType) {
        case REG_SZ:
            hr = put_BSTR_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_MULTI_SZ:
            hr = put_MULTISZ_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_DWORD:
            hr = put_DWORD_Property(pADs, pValue, (DWORD *) pData);
            break;

        case REG_BINARY:
            hr = put_BOOL_Property(pADs, pValue, (BOOL *) pData);
            break;

        default:
            hr = dw2hr(ERROR_INVALID_PARAMETER);
    }
    BAIL_ON_FAILURE(hr);

    hr = pADs->SetInfo();
    if (FAILED(hr))
        pADs->GetInfo();

error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\splinit.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    SplInit.c

Abstract:

    Initialize the spooler.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

DWORD
TranslateExceptionCode(
    DWORD ExceptionCode);

BOOL
SpoolerInit(
    VOID)

{
    WCHAR szDefaultPrinter[MAX_PATH * 2];
    HKEY hKeyPrinters;
    DWORD ReturnValue;

    //
    // Preserve the old device= string in case we can't initialize and
    // must defer.
    //
    if (!RegOpenKeyEx(HKEY_CURRENT_USER,
                      szPrinters,
                      0,
                      KEY_WRITE|KEY_READ,
                      &hKeyPrinters)) {

        //
        // Attempt to retrieve the current default written out.
        //
        if (GetProfileString(szWindows,
                             szDevice,
                             szNULL,
                             szDefaultPrinter,
                             COUNTOF(szDefaultPrinter))) {

            //
            // If it exists, save it away in case we start later when
            // the spooler hasn't started (which means we clear device=)
            // and then restart the spooler and login.
            //
            RegSetValueEx(hKeyPrinters,
                          szDeviceOld,
                          0,
                          REG_SZ,
                          (PBYTE)szDefaultPrinter,
                          (wcslen(szDefaultPrinter)+1) *
                            sizeof(szDefaultPrinter[0]));

        }

        RegCloseKey(hKeyPrinters);
    }

    //
    // Clear out [devices] and [printerports] device=
    //
    WriteProfileString(szDevices, NULL, NULL);
    WriteProfileString(szPrinterPorts, NULL, NULL);
    WriteProfileString(szWindows, szDevice, NULL);

    RpcTryExcept {

        if (ReturnValue = RpcSpoolerInit((LPWSTR)szNULL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\sources.inc ===
MAJORCOMP=windows
MINORCOMP=winspool

NTPROFILEINPUT=yes

TARGETNAME=winspool
TARGETPATH=$(PROJECT_ROOT)\lib\$(_OBJ_DIR)
TARGETTYPE=DYNLINK
TARGETEXT=drv

PASS1_PUBLISH= \
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)}

# Warning: OLE32 cannot be loaded statically.
# (They must be delayloaded.)  Hydra will load winspool.drv
# into CSRSS, and OLE32 cannot be loaded into CSRSS.

TARGETLIBS=$(WINDOWS_LIB_PATH)\gdi32p.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib   \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\adsiid.lib \
           $(SDK_LIB_PATH)\activeds.lib \
           $(SDK_LIB_PATH)\netapi32.lib \
           $(SDK_LIB_PATH)\ntdsapi.lib \
           $(SDK_LIB_PATH)\ws2_32.lib \
           $(SDK_LIB_PATH)\dnsapi.lib \
           $(SDK_LIB_PATH)\uuid.lib

LINKLIBS=..\..\perf\$(O)\perf.lib\
         $(PROJECT_ROOT)\lib\$(O)\spllib.lib

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

USE_MSVCRT=1

INCLUDES=..\;\
         ..\..\idl;\
         ..\..\idl\$(O);\
         ..\..\splwow64\idl;\
         ..\..\splwow64\idl\$(O);\
         ..\..\..\inc;\
         ..\..\..\..\inc;\
         ..\..\..\..\..\inc;\
         $(WINDOWS_INC_PATH);\
         $(SHELL_INC_PATH);\
         $(NET_INC_PATH);\
         $(DS_INC_PATH);

SOURCES= ..\prop.c       \
         ..\dsutil.cxx   \
         ..\init.c       \
         ..\winsplc.c    \
         ..\winspool.c   \
         ..\splwow64c.c  \
         ..\bind.c       \
         ..\midluser.c   \
         ..\data.c       \
         ..\winspla.c    \
         ..\util.c       \
         ..\pfdlg.c      \
         ..\change.c     \
         ..\splinit.c    \
         ..\clusspl.c    \
         ..\defprn.c     \
         ..\cstrings.c   \
         ..\handle.c     \
         ..\varconv.cxx  \
         ..\property.cxx \
         ..\pubprn.cxx   \
         ..\prnprst.cxx  \
         ..\prnstrm.cxx  \
         ..\splperst.cxx \
         ..\stream.cxx   \
         ..\wlkprn.cxx   \
         ..\memory.cxx   \
         ..\winspool.rc  \
         ..\drvsetup.c   \

UMTYPE=windows

UMLIBS=$(SDK_LIB_PATH)\winspool.lib \
       $(SDK_LIB_PATH)\gdi32.lib    \
       $(SDK_LIB_PATH)\netapi32.lib \
       $(O)\winspool.res

C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -D_UNICODE \
          -DNO_STRICT -D_SPOOL32_ -DSPOOLKM -D_HYDRA_

DELAYLOAD=\
           ole32.dll;\
           oleaut32.dll;\
           activeds.dll;\
           netapi32.dll;\
           dnsapi.dll;\
           ntdsapi.dll

DLOAD_ERROR_HANDLER=kernel32

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\splperst.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    splperst.cxx

Abstract:

    Implementation of spooler persisting code
    IPrnStream & IStream 

Author:

    Adina Trufinescu (AdinaTru) 4-Nov-1998

Revision History:

    Lazar Ivanov (LazarI) Jul-2000 - moved from printui.

--*/

#include "precomp.h"
#pragma hdrstop

#include "prnprst.hxx"

#include <initguid.h>
#include "winprtp.h"

class TPrnPersist: public IPrnStream,
                   public IStream
{

public:
    TPrnPersist(
        VOID
        );

    ~TPrnPersist(
        VOID
        );

    //
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // IPrnStream
    //
    STDMETHODIMP
    BindPrinterAndFile(
        IN LPCTSTR pszPrinter,
        LPCTSTR pszFile
        );

    STDMETHODIMP
    StorePrinterInfo(
        IN DWORD   Flag
        );

    STDMETHODIMP
    RestorePrinterInfo(
        IN DWORD   Flag
        );

    STDMETHODIMP
    QueryPrinterInfo(
        IN  PrinterPersistentQueryFlag      Flag,
        OUT PersistentInfo                  *pPrstInfo
        );

    //
    // IStream
    //
    HRESULT STDMETHODCALLTYPE 
    Read(                                // IMPLEMENTED
        VOID * pv,      
        ULONG cb,       
        ULONG * pcbRead 
        );

    HRESULT STDMETHODCALLTYPE 
    Write(                                //IMPLEMENTED
        VOID const* pv,  
        ULONG cb,
        ULONG * pcbWritten 
        );

    HRESULT STDMETHODCALLTYPE 
    Seek(                                //IMPLEMENTED
        LARGE_INTEGER dlibMove,  
        DWORD dwOrigin,          
        ULARGE_INTEGER * plibNewPosition 
        );

    HRESULT STDMETHODCALLTYPE 
    SetSize(
        ULARGE_INTEGER nSize     
        );

    HRESULT STDMETHODCALLTYPE 
    CopyTo(                                //NOT_IMPLEMENTED
        LPSTREAM pStrm,  
        ULARGE_INTEGER cb,          
        ULARGE_INTEGER * pcbRead,  
        ULARGE_INTEGER * pcbWritten 
        );

    HRESULT STDMETHODCALLTYPE 
    Commit(                                //NOT_IMPLEMENTED
        IN DWORD dwFlags   
        );

    HRESULT STDMETHODCALLTYPE 
    Revert(                                //NOT_IMPLEMENTED
        VOID
        );

    HRESULT STDMETHODCALLTYPE 
    LockRegion(                            //NOT_IMPLEMENTED
        ULARGE_INTEGER cbOffset, 
        ULARGE_INTEGER cbLength, 
        DWORD dwFlags            
        );

    HRESULT STDMETHODCALLTYPE 
    UnlockRegion(                        //NOT_IMPLEMENTED
        ULARGE_INTEGER cbOffset, 
        ULARGE_INTEGER cbLength, 
        DWORD dwFlags            
        );

    HRESULT STDMETHODCALLTYPE 
    Stat(                                //NOT_IMPLEMENTED
        STATSTG * pStatStg,     
        DWORD dwFlags 
        );

    HRESULT STDMETHODCALLTYPE 
    Clone(                                //NOT_IMPLEMENTED
        OUT LPSTREAM * ppStrm       
        );

private:
    
    LONG m_cRef;
    TPrinterPersist *_pPrnPersist;    
};

TPrnPersist::
TPrnPersist(
    VOID
    ): m_cRef(1), 
       _pPrnPersist(NULL)       
{    
}

TPrnPersist::
~TPrnPersist(
    VOID
    )
{
    if( _pPrnPersist )
    {
        delete _pPrnPersist;
    }    
}

STDMETHODIMP TPrnPersist::QueryInterface(REFIID riid, void **ppv)
{
    if( !ppv )
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IPrnStream) )
    {
        *ppv = static_cast<IPrnStream*>(this);
    } 
    else if( IsEqualIID(riid, IID_IStream) )
    {
        *ppv = static_cast<IStream*>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) TPrnPersist::AddRef()
{    
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) TPrnPersist::Release()
{    
    ULONG cRefs = InterlockedDecrement(&m_cRef);
    if( 0 == cRefs )
    {
        delete this;
    }
    return cRefs;
}

/*++

Name:
    TPrnPersist::BindPrinterAndFile

Description:

    Creates a PrnStream object if it don't exists and bind it to a printer and a file

Arguments:

    printer name
    file name

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
BindPrinterAndFile(
    IN LPCTSTR pszPrinter,
    IN LPCTSTR pszFile
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the PrnStream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the BindPrinterAndFile method if the printer stream
    // object was create successfully.
    //
    if (_pPrnPersist != NULL)
    {

        DBGMSG(DBG_TRACE , ("TPrnPersist::BindPrinterAndFile \n"));

        hr = _pPrnPersist->BindPrinterAndFile(pszPrinter, pszFile);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    DBGMSG(DBG_TRACE , ("TPrnPersist::BindPrinterAndFile %x \n" , hr));
    return hr;

}

/*++

Name:
    TPrnPersist::StorePrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke StorePrinterInfo

Arguments:

    flags that specifies what settings to store

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
StorePrinterInfo(
    IN DWORD   Flag
    )
{
    TStatusH hr;

    hr DBGNOCHK = E_FAIL;

    DWORD StoredFlags;

    //
    // Create the PrnStream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the stote info method if the printer stream
    // object was create successfully.
    //
    DBGMSG(DBG_TRACE , ("TPrnPersist::StorePrinterInfo Flag %x \n" , Flag));

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            //
            // Winlogon calls this function for TS. We need to catch any possbile exception,
            // otherwise we may cause BSOD.
            //
            __try 
            {
                hr DBGCHK = _pPrnPersist->StorePrinterInfo(Flag, StoredFlags);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                DBGMSG(DBG_WARNING, ("TPrnPersist::StorePrinterInfo exception %x\n", GetExceptionCode()));
                
                hr DBGCHK = E_FAIL;
            }
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TPrnPersist::RestorePrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke RestorePrinterInfo

Arguments:

    flags that specifies what settings to restore

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
RestorePrinterInfo(
    IN DWORD   Flag
    )
{
    TStatusH hr;
    
    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the restore info  method if the printer stream
    // object was created successfully.
    //
    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            //
            // Winlogon calls this function on the machine where TS runs. If the file from which
            // we restore the settings is corrupted, we must protect us against AVs that can occur
            // while accessing bad data.
            //
            __try 
            {
                hr DBGCHK = _pPrnPersist->SafeRestorePrinterInfo(Flag);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                DBGMSG(DBG_WARNING, ("TPrnPersist::SafeRestorePrinterInfo exception %x\n", GetExceptionCode()));
                
                hr DBGCHK = E_FAIL;
            }
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TPrnPersist::QueryPrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke QueryPrinterInfo

Arguments:

    flags that specifies what settings to query

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag   Flag,
    OUT PersistentInfo              *pPrstInfo
    )
{
    TStatusH hr;

    hr DBGNOCHK = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the query info method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            __try 
            {
                hr DBGCHK = _pPrnPersist->QueryPrinterInfo(Flag , pPrstInfo);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                DBGMSG(DBG_WARNING, ("TPrnPersist::QueryPrinterInfo exception %x\n", GetExceptionCode()));
                
                hr DBGCHK = E_FAIL;
            }
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TPrnPersist::Read

Description:

    Creates a PrnStream object if it don't exists and invoke Read

Arguments:

    pv  -   The buffer that the bytes are read into
    cb  -   The offset in the stream to begin reading from.
    pcbRead -   The number of bytes to read

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
Read(
    VOID * pv,
    ULONG cb,
    ULONG * pcbRead
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the read method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            hr = _pPrnPersist->Read(pv, cb, pcbRead);
        }
        else
        {
            hr = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}

/*++

Name:
    TPrnPersist::Write

Description:

    Creates a PrnStream object if it don't exists and invoke Write

Arguments:

    pv  -   The buffer to write from.
    cb  -   The offset in the array to begin writing from
    pcbRead -   The number of bytes to write

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
Write(
    VOID const* pv,
    ULONG cb,
    ULONG * pcbWritten
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the write method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            hr = _pPrnPersist->Write(pv, cb, pcbWritten);
        }
        else
        {
            hr = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }


    return hr;
}


/*++

Name:
    TPrnPersist::Seek

Description:

    Creates a PrnStream object if it don't exists and invoke Seek

Arguments:

    dlibMove        -   The offset relative to dwOrigin
    dwOrigin        -   The origin of the offset
    plibNewPosition -   Pointer to value of the new seek pointer from the beginning of the stream

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the seek method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            hr = _pPrnPersist->Seek(dlibMove, dwOrigin, plibNewPosition);
        }
        else
        {
            hr = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }


    return hr;
}

/*++

Name:
    TPrnPersist::SetSize

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
SetSize(
     ULARGE_INTEGER nSize
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::CopyTo

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
CopyTo(
    LPSTREAM pStrm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER * pcbRead,
    ULARGE_INTEGER * pcbWritten
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Commit

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Commit(
    IN DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Revert

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Revert(
    VOID
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::LockRegion

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
LockRegion(
    ULARGE_INTEGER cbOffset,
    ULARGE_INTEGER cbLength,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::UnlockRegion

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
UnlockRegion(
    ULARGE_INTEGER cbOffset,
    ULARGE_INTEGER cbLength,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Stat

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Stat(
    STATSTG * pStatStg,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Clone

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Clone(
    LPSTREAM * ppStrm
    )
{
    return E_NOTIMPL;
}

#ifdef __cplusplus
extern "C" {
#endif

// forward declarations....
HRESULT TPrnPersist_CreateInstance(REFIID riid, void **ppv);
BOOL WebPnpEntry(LPCTSTR lpszCmdLine);
BOOL WebPnpPostEntry(BOOL fConnection, LPCTSTR lpszBinFile, LPCTSTR lpszPortName, LPCTSTR lpszPrtName);

/*++

Name:
    TPrnPersist_CreateInstance

Description:

    creates an instance of TPrnPersist

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT TPrnPersist_CreateInstance(
    IN  REFIID riid, 
    OUT void **ppv
    )
{
    HRESULT hr = E_INVALIDARG;

    if( ppv )
    {
        *ppv = NULL;
        TPrnPersist *pObj = new TPrnPersist;

        if( pObj ) 
        {
            hr = pObj->QueryInterface( riid, ppv );
            pObj->Release( );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}

/*++

Name:
    PrintUIWebPnpEntry

Description:

    wrapper around WebPnpEntry

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT PrintUIWebPnpEntry(
    LPCTSTR lpszCmdLine
    )
{
    return WebPnpEntry(lpszCmdLine) ? S_OK : E_FAIL;
}

/*++

Name:
    PrintUIWebPnpPostEntry

Description:

    wrapper around WebPnpPostEntry

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT PrintUIWebPnpPostEntry(BOOL fConnection, LPCTSTR lpszBinFile, LPCTSTR lpszPortName, LPCTSTR lpszPrtName)
{
    return WebPnpPostEntry(fConnection, lpszBinFile, lpszPortName, lpszPrtName) ? S_OK : E_FAIL;
}

/*++

Name:
    PrintUICreateInstance

Description:

    wrapper around TPrnPersist_CreateInstance

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT PrintUICreateInstance(REFIID riid, void **ppv)
{
    return TPrnPersist_CreateInstance(riid, ppv);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\splwow64c.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:
    splwow64c.c
    
Abstract:

    Stub file to allow splwow64_c.c to work with precompiled headers.

Author:
    Khaled Sedky 18 January 2000

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "splwow64_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\winsplc.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Stub file to allow winspl_c.c to work with precompiled headers.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "winspl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\stream.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    Stream.cxx

Abstract:

    implements TStream class methods

Author:

    Adina Trufinescu (AdinaTru)  4-Nov-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "stream.hxx"

/*++

Title:

    TStream

Routine Description:

    Initialize the TStream class; note the class is initaliy
    in an in valid state until a read or write occurs in which
    case the file handle is created and then the class becomes valid.

Arguments:

    None

Return Value:

    Nothing

--*/
TStream::
TStream(
    IN TString&   strFileName
    ) : m_strFileName(strFileName),
        m_hFileHandle(INVALID_HANDLE_VALUE),
        m_dwAccess(0),
        m_bCreated(FALSE)
{
    m_uliStreamSize.QuadPart = 0;
}

/*++

Title:

    ~TStream

Routine Description:

    Releases the stream file handle.

Arguments:

    None

Return Value:

    Nothing

--*/
TStream::
~TStream(
    VOID
    )
{
    if(m_hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFileHandle);
    }
}

/*++

Title:

    bValid

Routine Description:

    check class member validity : file handle invalid

Arguments:

    None

Return Value:

    TRUE if class is in a valid state.

--*/
BOOL
TStream::
bValid(
    VOID
    )
{
    return (m_hFileHandle != INVALID_HANDLE_VALUE);
}

/*++

Title:

    Read

Routine Description:

    Reads cb bytes into pv , from current position of file.
    Number of actual reded bytes stored in pbcRead

Arguments:

Return Value:

    The error code from ReadFile API is converted to HRESULT

--*/
HRESULT
TStream::
Read(
    VOID    *pv,
    ULONG   cb,
    ULONG   *pcbRead
    )
{
    TStatusH hr;

    if(!bValid())
    {
        m_hFileHandle = PCreateFile(&m_dwAccess);

        if(!bValid())
        {
            hr DBGCHK = E_UNEXPECTED;

            goto End;
        }
    }

    if(bValid())
    {
        if(pv)
        {
            if(!ReadFile( m_hFileHandle,
                          reinterpret_cast<LPDWORD>(pv),
                          static_cast<DWORD>(cb),
                          reinterpret_cast<LPDWORD>(pcbRead),
                          NULL))
            {
                *pcbRead = 0;

                hr DBGCHK =  MapWin32ErrorCodeToHRes(GetLastError());

                goto End;

            }

            hr DBGCHK = ((*pcbRead) == cb) && (*pcbRead != 0 && cb != 0) ? S_OK : E_FAIL;

        }
        else
        {
            hr DBGCHK = STG_E_INVALIDPOINTER;
        }
    }

End:

    return hr;

}
/*++

Title:

    Write

Routine Description:

    Writes cb bytes from pv , at current position of file.
    Number of actual written bytes stored in pcbWritten

Arguments:

Return Value:

  The error code from WriteFile API is converted to HRESULT

--*/
HRESULT
TStream::
Write(
    VOID const* pv,
    ULONG cb,
    ULONG * pcbWritten
    )
{
    HRESULT hr = E_UNEXPECTED;

    if(!bValid())
    {
        m_hFileHandle = PCreateFile(&m_dwAccess);

        if(!bValid())
        {
            goto End;
        }
    }

    if(bValid())
    {
        if(pv)
        {
            if(!WriteFile(m_hFileHandle,
                          static_cast<LPCVOID>(pv),
                          static_cast<DWORD>(cb),
                          reinterpret_cast<LPDWORD>(pcbWritten),
                          NULL))
            {
                if (pcbWritten)
                {
                    *pcbWritten = 0;
                }

                hr = MapWin32ErrorCodeToHRes(GetLastError());
            }

            if (pcbWritten)
            {
                hr = (*pcbWritten == cb) ? S_OK : hr;
            }
            else
            {
                hr = STG_E_INVALIDPOINTER;
            }

            if(SUCCEEDED(hr))
            {
                DBGMSG( DBG_NONE, ( "TPrnStream::Write OK !!!\n" ));
            }
        }
        else
        {
            hr = STG_E_INVALIDPOINTER;
        }
    }

End:

    return hr;

}

/*++

Title:

    Seek

Routine Description:

    Set stream pointer

Arguments:

    dlibMove    -   Offset relative to dwOrigin
    dwOrigin    -   Specifies the origin for the offset
    plibNewPosition -   Pointer to location containing new seek

Return Value:

    The error code from SetFilePointer API is converted to HRESULT

--*/
HRESULT
TStream::
Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition
    )
{
    DWORD   dwMoveMethod;
    DWORD   dwCurrentFilePosition ;
    LONG    lDistanceToMoveHigh;

    TStatusB    bStatus;
    TStatusH    hr;
    DWORD       dwError;

    static const DWORD adwMoveMethode[] =
            {
                FILE_BEGIN,
                FILE_CURRENT,
                FILE_END,
            };

    dwMoveMethod = adwMoveMethode[dwOrigin];

    if(!bValid())
    {
        m_hFileHandle = PCreateFile(&m_dwAccess);

        if(!bValid())
        {
            hr DBGCHK = E_UNEXPECTED;

            goto End;
        }
    }


    lDistanceToMoveHigh     = dlibMove.HighPart;

    dwCurrentFilePosition   = SetFilePointer(   m_hFileHandle,
                                                static_cast<LONG>(dlibMove.LowPart),
                                                &lDistanceToMoveHigh,
                                                dwMoveMethod );

    DBGMSG( DBG_NONE, ( "Seek: Current pos: high %d low %d\n" ,lDistanceToMoveHigh, dwCurrentFilePosition) );

    if (dwCurrentFilePosition == 0xFFFFFFFF && (dwError = GetLastError()) != NO_ERROR )
    {
        hr DBGCHK = MapWin32ErrorCodeToHRes(dwError);
    }
    else
    {
        if(plibNewPosition)
        {
            plibNewPosition->HighPart = static_cast<DWORD>(lDistanceToMoveHigh);

            plibNewPosition->LowPart  = dwCurrentFilePosition;
        }

        hr DBGNOCHK = S_OK;
    }

End:

    return hr;
}


/*++

Title:

    PCreateFile

Routine Description:

    If file doesn't exists , create it with write / read access
    If file exists , try open it with read wrire access ; if fail , try to open with read

Arguments:

    pdwAccess    -   access rights if succeeded , 0 if failed

Return Value:

    The error code from SetFilePointer API is converted to HRESULT

--*/
HANDLE
TStream::
PCreateFile(
    OUT LPDWORD pdwAccess
    )
{
    HANDLE  hFileHandle;
    DWORD   dwAccess;

    *pdwAccess = 0;

    //
    // try to open an existing file with read/write access
    //
    dwAccess = GENERIC_WRITE | GENERIC_READ;

    hFileHandle = CreateFile( m_strFileName,
                              dwAccess,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if(hFileHandle == INVALID_HANDLE_VALUE)
    {
        //
        // if last error is access denied , try to open only with read access
        //
        if(GetLastError() == ERROR_ACCESS_DENIED)
        {
            dwAccess = GENERIC_READ;

            hFileHandle = CreateFile( m_strFileName,
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
        }
        else if(GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            dwAccess = GENERIC_WRITE | GENERIC_READ;

            //
            // if last error was file don't exist , try to create it
            //
            hFileHandle = CreateFile( m_strFileName,
                                      dwAccess,
                                      0,
                                      NULL,
                                      OPEN_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

            m_bCreated = TRUE;

        }

    }


    if(hFileHandle != INVALID_HANDLE_VALUE)
    {
        *pdwAccess  = dwAccess;

        m_uliStreamSize.LowPart = GetFileSize(hFileHandle, &m_uliStreamSize.HighPart);
    }

    return hFileHandle;

}

/*++

Title:

    DestroyFile

Routine Description:

    If file handle is invalid , it means that file wasn't creaded - return TRUE
    If file handle is valid , close it and delete file

Arguments:

    None

Return Value:

    TRUE if succeeded

--*/
HRESULT
TStream::
DestroyFile(
    VOID
    )
{
    TStatusB    bStatus;

    bStatus DBGNOCHK = TRUE;

    if(m_hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFileHandle);

        m_hFileHandle = INVALID_HANDLE_VALUE;

        bStatus DBGCHK = DeleteFile(m_strFileName);
    }

    return bStatus ? S_OK : MapWin32ErrorCodeToHRes(GetLastError());
}

/*++

Title:

    bSetEndOfFile

Routine Description:

    If file handle is valid , set end of file
    Needed it for truncating the file in case of overwritting
    Called at the end of every successfull storing

Arguments:

    None

Return Value:

    TRUE if succeeded

--*/
BOOL
TStream::
bSetEndOfFile(
    VOID
    )
{
    TStatusB    bStatus;

    bStatus DBGCHK = (m_hFileHandle != INVALID_HANDLE_VALUE);

    if(bStatus)
    {
        bStatus DBGCHK = SetEndOfFile(m_hFileHandle);
    }

    return bStatus;

}

/*++

Title:

    MapWin32ErrorCodeToHRes

Routine Description:

    maps file error codes to HRESULT errors

Arguments:

    Error value to convert

Return Value:

    Converted error value to an HRESULT

Last Error:

--*/
HRESULT
TStream::
MapWin32ErrorCodeToHRes(
    IN DWORD dwErrorCode
    )
{
    return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_STORAGE, dwErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\varconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  varconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    SWilson     Nov 1996
//----------------------------------------------------------------------------

#define INC_OLE2

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "pubprn.hxx"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"


HRESULT
PackString2Variant(
    LPCWSTR lpszData,
    VARIANT * pvData
    )
{
    BSTR bstrData = NULL;
    WCHAR String[] = L"";
    LPCWSTR pStr;

    pStr = lpszData ? lpszData : (LPCWSTR) String;

    VariantInit(pvData);
    pvData->vt = VT_BSTR;

    bstrData = SysAllocString(pStr);

    if (!bstrData) {
        return MAKE_HRESULT(SEVERITY_ERROR,
                            FACILITY_WIN32,
                            ERROR_OUTOFMEMORY);
    }

    pvData->vt = VT_BSTR;
    pvData->bstrVal = bstrData;

    return ERROR_SUCCESS;
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = E_POINTER;

    if (pbstrDestString) 
    {
        if (varSrcData.vt != VT_BSTR) 
        {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
        }
        else
        {
            *pbstrDestString = SysAllocString(V_BSTR(&varSrcData) ? V_BSTR(&varSrcData) : L"");

            hr = *pbstrDestString ? S_OK : E_OUTOFMEMORY;
        }
    }
    
    return hr;
}


HRESULT
UnpackDispatchfromVariant(
    VARIANT varSrcData,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    if (!V_DISPATCH(&varSrcData)) {
        *ppDispatch = NULL;
        return S_OK;
    }

    *ppDispatch = V_DISPATCH(&varSrcData);

    return hr;
}



HRESULT
PackDispatch2Variant(
    IDispatch *pDispatch,
    VARIANT *pvData
)
{
    if (!pvData)
        return E_FAIL;

    V_VT(pvData) = VT_DISPATCH;
    V_DISPATCH(pvData) = pDispatch;

    return S_OK;
}


HRESULT
PackDWORD2Variant(
    DWORD dwData,
    VARIANT * pvData
    )
{
    if (!pvData) {
        return(E_FAIL);
    }


    pvData->vt = VT_I4;
    pvData->lVal = dwData;

    return S_OK;
}

HRESULT
PackBOOL2Variant(
    BOOL fData,
    VARIANT * pvData
    )
{
    pvData->vt = VT_BOOL;
    V_BOOL(pvData) = (BYTE) fData;

    return S_OK;
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT *pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_VARIANT;
    return VariantCopy( pvarInputData, &vaValue );
}


HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i = 0;
    long j = 0;
    long nCount;

    if ( (bstrList != NULL) && (*bstrList != 0) ) {

        for (nCount = 0 ;  bstrList[nCount] ; ++nCount)
            ;

        if ( nCount == 1 ) {
            VariantInit( pvVariant );
            V_VT(pvVariant) = VT_BSTR;
            if (!(V_BSTR(pvVariant) = SysAllocString( bstrList[0]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            return hr;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for (i = 0 ;  bstrList[i] ; ++i) {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (!(V_BSTR(&v) = SysAllocString(bstrList[i]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    } else {

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
UI1Array2IID(
    VARIANT var,
    IID *pIID
)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    LONG i;
    HRESULT hr = S_OK;
    UCHAR pGUID[16];

    if ( !( (V_VT(&var) &  VT_UI1) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    //
    // Check that there is only one dimension in this array
    //
    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);
    //
    // Check that there is at least one element in this array
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements != 16) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // We know that this is a valid single dimension array
    //
    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++)
    {

        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, pGUID + i - dwSLBound);
        if ( FAILED(hr) )
            continue;

    }

    *pIID = *(IID *) pGUID;

    hr = S_OK;

error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\winspla.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    winspla.c

Abstract:

    Ansi end to winspool.drv

Author:

Environment:

    User Mode -Win32

Revision History:

    amaxa July 2000 - Modified GetPrinterData(Ex)A and SetPrinterData(Ex)A to
                      have the same behavior like the unicode functions.

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "defprn.h"
#include "winsprlp.h"

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct {
    BOOL bOsVersionEx;
    union  {
        OSVERSIONINFOW   *pOsVersion;
        OSVERSIONINFOEXW *pOsVersionEx;
    } Unicode;
    union {
        OSVERSIONINFOA   *pOsVersion;
        OSVERSIONINFOEXA *pOsVersionEx;
    } Ansi;
} OSVERSIONWRAP;

WCHAR *szCurDevMode = L"Printers\\DevModes2";

BOOL
KickoffThread(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    INT_FARPROC pfn
);

LPWSTR
AllocateUnicodeStringWithSize(
    LPSTR  pPrinterName,
    DWORD  cbBytes          
);

VOID
ValidatePaperFields(
    LPCWSTR    pUnicodeDeviceName,
    LPCWSTR    pUnicodePort,
    LPDEVMODEW pDevModeIn
);

#define NULL_TERMINATED 0

DWORD
UnicodeToAnsi(
    IN     LPBYTE  pUnicode,
    IN     DWORD   cchUnicode,
    IN OUT LPBYTE  pData,
    IN     DWORD   cbData,
    IN OUT DWORD  *pcbCopied OPTIONAL
    );

/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 */
INT AnsiToUnicodeString( LPSTR pAnsi, LPWSTR pUnicode, DWORD StringLength )
{
    INT iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_THREAD_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 *
 * Notes:
 *      With DBCS enabled, we will allocate twice the size of the
 *      buffer including the null terminator to take care of double
 *      byte character strings - KrishnaG
 *
 *      pUnicode is truncated to StringLength characters.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 */
INT
UnicodeToAnsiString(
    LPWSTR  pUnicode,
    LPSTR   pAnsi,
    DWORD   StringLength)
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;
    LPWSTR pAlignedUnicode = NULL;

    if ((ULONG_PTR)pUnicode != (((ULONG_PTR) (pUnicode) + (sizeof(WCHAR) - 1))&~(sizeof(WCHAR) - 1))) {

        //
        // Calculate the length of the unaligned string.
        //
        if(StringLength == NULL_TERMINATED) {

            for (StringLength = 0;
                 !( ((LPSTR)pUnicode)[StringLength]   == '\0' &&
                    ((LPSTR)pUnicode)[StringLength+1] == '\0' );
                 StringLength += 2)
                ;

            StringLength /= 2;

        } else {

            //
            // WideCharToMultiByte doesn't NULL terminate if we're copying
            // just part of the string, so terminate here.
            //
            ((LPSTR)(pUnicode + StringLength))[0] = '\0';
            ((LPSTR)(pUnicode + StringLength))[1] = '\0';
        }

        StringLength++;

        pAlignedUnicode = LocalAlloc(LPTR, StringLength * sizeof(WCHAR));

        if (pAlignedUnicode) {

            memcpy(pAlignedUnicode, pUnicode, StringLength * sizeof(WCHAR));
        }

    } else {

        pAlignedUnicode = pUnicode;

        if(StringLength == NULL_TERMINATED) {

            //
            // StringLength is just the
            // number of characters in the string
            //
            StringLength = wcslen(pAlignedUnicode);
        }

        //
        // WideCharToMultiByte doesn't NULL terminate if we're copying
        // just part of the string, so terminate here.
        //
        pAlignedUnicode[StringLength] = 0;

        StringLength++;
    }


    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //
    if( pAnsi == (LPSTR)pAlignedUnicode )
    {
        pTempBuf = LocalAlloc( LPTR, StringLength * sizeof(WCHAR) );
        pAnsi = pTempBuf;
    }

    if( pAnsi && pAlignedUnicode )
    {
        rc = WideCharToMultiByte( CP_THREAD_ACP,
                                  0,
                                  pAlignedUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength*2,
                                  NULL,
                                  NULL );
    }

    //
    // If pTempBuf is non-null, we must copy the resulting string
    // so that it looks as if we did it in place:
    //
    if( pTempBuf )
    {
        if( rc > 0 )
        {
            pAnsi = (LPSTR)pAlignedUnicode;
            if (FAILED(StringCbCopyExA( pAnsi, StringLength * sizeof(WCHAR), pTempBuf, NULL, NULL, STRSAFE_FILL_ON_FAILURE)))
            {
                rc = 0;
            }
        }

        LocalFree( pTempBuf );
    }

    if (pAlignedUnicode != pUnicode) {

        LocalFree(pAlignedUnicode);
    }

    return rc;
}


void
ConvertUnicodeToAnsiStrings(
    LPBYTE  pStructure,
    LPDWORD pOffsets
)
{
    register DWORD       i=0;
    LPWSTR   pUnicode;
    LPSTR    pAnsi;

    while (pOffsets[i] != -1) {

        pUnicode = *(LPWSTR *)(pStructure+pOffsets[i]);
        pAnsi = (LPSTR)pUnicode;

        if (pUnicode) {
            UnicodeToAnsiString(pUnicode, pAnsi, NULL_TERMINATED);
        }

        i++;
   }
}

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
)
{
    LPWSTR  pUnicodeString;

    if (!pPrinterName)
        return NULL;

    pUnicodeString = LocalAlloc(LPTR, strlen(pPrinterName)*sizeof(WCHAR) +
                                      sizeof(WCHAR));

    if (pUnicodeString)
        AnsiToUnicodeString(pPrinterName, pUnicodeString, NULL_TERMINATED);

    return pUnicodeString;
}


LPWSTR
AllocateUnicodeStringWithSize(
    LPSTR  pData,
    DWORD  cbData
)
{
    LPWSTR  pUnicodeString = NULL;
    DWORD   iReturn;

    if (pData &&
        (pUnicodeString = LocalAlloc(LPTR, cbData*sizeof(WCHAR))))
    {
        iReturn = MultiByteToWideChar(CP_THREAD_ACP,
                                      MB_PRECOMPOSED,
                                      pData,
                                      cbData,
                                      pUnicodeString,
                                      cbData);

        if (iReturn != cbData)
        {
            LocalFree(pUnicodeString);

            pUnicodeString = NULL;
        }
    }

    return pUnicodeString;
}


LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
)
{
    if (!pUnicodeString)
        return NULL;

    return LocalFree(pUnicodeString);
}

LPBYTE
AllocateUnicodeStructure(
    LPBYTE  pAnsiStructure,
    DWORD   cbStruct,
    LPDWORD pOffsets
)
{
    DWORD   i, j;
    LPWSTR *ppUnicodeString;
    LPSTR  *ppAnsiString;
    LPBYTE  pUnicodeStructure;


    if (!pAnsiStructure) {
        return NULL;
    }
    pUnicodeStructure = LocalAlloc(LPTR, cbStruct);

    if (pUnicodeStructure) {

        memcpy(pUnicodeStructure, pAnsiStructure, cbStruct);

        for (i = 0 ; pOffsets[i] != -1 ; ++i) {

            ppAnsiString = (LPSTR *)(pAnsiStructure+pOffsets[i]);
            ppUnicodeString = (LPWSTR *)(pUnicodeStructure+pOffsets[i]);

            *ppUnicodeString = AllocateUnicodeString(*ppAnsiString);

            if (*ppAnsiString && !*ppUnicodeString) {

                for( j = 0 ; j < i ; ++j) {
                    ppUnicodeString = (LPWSTR *)(pUnicodeStructure+pOffsets[j]);
                    FreeUnicodeString(*ppUnicodeString);
                }
                LocalFree(pUnicodeStructure);
                pUnicodeStructure = NULL;
                break;
            }
       }
    }

    return pUnicodeStructure;
}

DWORD
CopyOsVersionUnicodeToAnsi(
    IN OUT OSVERSIONWRAP Arg
    )

/*++

Routine Name:

    CopyOsVersionUnicodeToAnsi

Routine Description:

    Copies the contents of the UNICODE structure OSVERSIONINFO(EX) into the ANSI structure.

Arguments:

    An OSVERSIONWRAP structure

Return Value:

    Win32 error core

--*/

{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    OSVERSIONINFOEXW *pIn  = Arg.Unicode.pOsVersionEx;
    OSVERSIONINFOEXA *pOut = Arg.Ansi.pOsVersionEx;

    if (pIn && pOut)
    {
        dwError = ERROR_SUCCESS;

        pOut->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        pOut->dwMajorVersion      = pIn->dwMajorVersion;
        pOut->dwMinorVersion      = pIn->dwMinorVersion;
        pOut->dwBuildNumber       = pIn->dwBuildNumber;
        pOut->dwPlatformId        = pIn->dwPlatformId;

        //
        // Initialize the array of chars szCSDVersion to 0 so that we are consistent with
        // the return of the UNICODE versions of GetPrinterData(Ex).
        //
        memset(pOut->szCSDVersion, 0, COUNTOF(pOut->szCSDVersion));

        UnicodeToAnsiString(pIn->szCSDVersion, pOut->szCSDVersion, NULL_TERMINATED);

        //
        // Copy the rest of the Ex structure
        //
        if (Arg.bOsVersionEx)
        {
            pOut->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
            pOut->wServicePackMajor   = pIn->wServicePackMajor;
            pOut->wServicePackMinor   = pIn->wServicePackMinor;
            pOut->wSuiteMask          = pIn->wSuiteMask;
            pOut->wProductType        = pIn->wProductType;
            pOut->wReserved           = pIn->wReserved;
        }
    }

    return dwError;
}

DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax)

/*++

Routine Description:

    Returns the length of the Unicode string, EXCLUDING the NULL.  If the
    string (plus NULL) won't fit into the cchBufMax, then the string len is
    decreased.

Arguments:

Return Value:

--*/

{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax)

/*++

Routine Description:

    Returns the length of the Ansi string, EXCLUDING the NULL.  If the
    string (plus NULL) won't fit into the cchBufMax, then the string len is
    decreased.

Arguments:

Return Value:

--*/

{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}



/***************************** Function Header ******************************
 * AllocateUnicodeDevMode
 *      Allocate a UNICODE version of the DEVMODE structure, and optionally
 *      copy the contents of the ANSI version passed in.
 *
 * RETURNS:
 *      Address of newly allocated structure, 0 if storage not available.
 *
 *
 ***************************************************************************/

LPDEVMODEW
AllocateUnicodeDevMode(
    LPDEVMODEA pANSIDevMode
    )
{
    LPDEVMODEW  pUnicodeDevMode;
    LPBYTE      p1, p2;
    DWORD       dwSize;

    //
    // If the devmode is NULL, then return NULL -- KrishnaG
    //
    if ( !pANSIDevMode || !pANSIDevMode->dmSize ) {
        return NULL;
    }

    SPLASSERT(BoolFromHResult(SplIsValidDevmodeNoSizeA(pANSIDevMode)));

    //
    // Determine output structure size.  This has two components:  the
    // DEVMODEW structure size,  plus any private data area.  The latter
    // is only meaningful when a structure is passed in.
    //
    dwSize = pANSIDevMode->dmSize + pANSIDevMode->dmDriverExtra
                                  + sizeof(DEVMODEW) - sizeof(DEVMODEA);

    pUnicodeDevMode = (LPDEVMODEW) LocalAlloc(LPTR, dwSize);

    if( !pUnicodeDevMode ) {
        return NULL;                   
    }

    //
    // Copy dmDeviceName which is a string
    //
    if (pANSIDevMode->dmDeviceName)
    {
        AnsiToUnicodeString(pANSIDevMode->dmDeviceName,
                            pUnicodeDevMode->dmDeviceName,
                            ComputeMaxStrlenA(pANSIDevMode->dmDeviceName,
                                         sizeof pANSIDevMode->dmDeviceName));
    }

    //
    // Does the devmode we got have a dmFormName? (Windows 3.1 had
    // DevMode of size 40 and did not have dmFormName)
    //
    if ( (LPBYTE)pANSIDevMode + pANSIDevMode->dmSize >
                                    (LPBYTE) pANSIDevMode->dmFormName ) {

        //
        // Copy everything between dmDeviceName and dmFormName
        //
        p1      = (LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName);
        p2      = (LPBYTE) pANSIDevMode->dmFormName;


        CopyMemory((LPBYTE) pUnicodeDevMode->dmDeviceName +
                            sizeof(pUnicodeDevMode->dmDeviceName),
                   p1,
                   p2 - p1);

        //
        // Copy dmFormName which is a string
        //
        if (pANSIDevMode->dmFormName)
        {
            AnsiToUnicodeString(pANSIDevMode->dmFormName,
                                pUnicodeDevMode->dmFormName,
                                ComputeMaxStrlenA(pANSIDevMode->dmFormName,
                                             sizeof pANSIDevMode->dmFormName));
        }

        //
        // Copy everything after dmFormName
        //
        p1      = (LPBYTE) pANSIDevMode->dmFormName +
                                sizeof(pANSIDevMode->dmFormName);
        p2      = (LPBYTE) pANSIDevMode + pANSIDevMode->dmSize
                                        + pANSIDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pUnicodeDevMode->dmFormName +
                                sizeof(pUnicodeDevMode->dmFormName),
                    p1,
                    p2 - p1);

        pUnicodeDevMode->dmSize = pANSIDevMode->dmSize + sizeof(DEVMODEW)
                                                       - sizeof(DEVMODEA);
    } else {

        //
        // Copy everything after dmDeviceName
        //
        p1 = (LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName);
        p2 = (LPBYTE) pANSIDevMode + pANSIDevMode->dmSize + pANSIDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pUnicodeDevMode->dmDeviceName +
                            sizeof(pUnicodeDevMode->dmDeviceName),
                   p1,
                   p2-p1);

        pUnicodeDevMode->dmSize = pANSIDevMode->dmSize
                                        + sizeof(pUnicodeDevMode->dmDeviceName)
                                        - sizeof(pANSIDevMode->dmDeviceName);
    }

    SPLASSERT(pUnicodeDevMode->dmDriverExtra == pANSIDevMode->dmDriverExtra);


    return pUnicodeDevMode;
}

/************************** Function Header ******************************
 * CopyAnsiDevModeFromUnicodeDevMode
 *      Converts the UNICODE version of the DEVMODE to the ANSI version.
 *
 * RETURNS:
 *      Nothing.
 *
 **************************************************************************/

void
CopyAnsiDevModeFromUnicodeDevMode(
    LPDEVMODEA  pANSIDevMode,              /* Filled in by us */
    LPDEVMODEW  pUnicodeDevMode            /* Source of data to fill above */
)
{
    LPBYTE  p1, p2, pExtra;
    WORD    dmSize, dmDriverExtra;

    //
    // NOTE:    THE TWO INPUT STRUCTURES MAY BE THE SAME.
    //
    dmSize          = pUnicodeDevMode->dmSize;
    dmDriverExtra   = pUnicodeDevMode->dmDriverExtra;
    pExtra          = (LPBYTE) pUnicodeDevMode + pUnicodeDevMode->dmSize;

    if (dmSize)
    {
        //
        // Copy dmDeviceName which is a string
        //
        UnicodeToAnsiString(pUnicodeDevMode->dmDeviceName,
                            pANSIDevMode->dmDeviceName,
                            ComputeMaxStrlenW(pUnicodeDevMode->dmDeviceName,
                                         sizeof pANSIDevMode->dmDeviceName));

        //
        // Does the devmode we got have a dmFormName? (Windows 3.1 had
        // DevMode of size 40 and did not have dmFormName)
        //
        if ( (LPBYTE)pUnicodeDevMode + dmSize >
                                        (LPBYTE) pUnicodeDevMode->dmFormName ) {

            //
            // Copy everything between dmDeviceName and dmFormName
            //
            p1      = (LPBYTE) pUnicodeDevMode->dmDeviceName +
                                        sizeof(pUnicodeDevMode->dmDeviceName);
            p2      = (LPBYTE) pUnicodeDevMode->dmFormName;

            MoveMemory((LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName),
                        p1,
                        p2 - p1);

            //
            // Copy dmFormName which is a string
            //
            UnicodeToAnsiString(pUnicodeDevMode->dmFormName,
                                pANSIDevMode->dmFormName,
                                ComputeMaxStrlenW(pUnicodeDevMode->dmFormName,
                                             sizeof pANSIDevMode->dmFormName));

            //
            // Copy everything after dmFormName
            //
            p1      = (LPBYTE) pUnicodeDevMode->dmFormName +
                                    sizeof(pUnicodeDevMode->dmFormName);
            p2      = (LPBYTE) pUnicodeDevMode + dmSize + dmDriverExtra;

            MoveMemory((LPBYTE) pANSIDevMode->dmFormName +
                                    sizeof(pANSIDevMode->dmFormName),
                        p1,
                        p2 - p1);


            pANSIDevMode->dmSize = dmSize + sizeof(DEVMODEA) - sizeof(DEVMODEW);
        } else {

            //
            // Copy everything after dmDeviceName
            //
            p1      = (LPBYTE) pUnicodeDevMode->dmDeviceName +
                                    sizeof(pUnicodeDevMode->dmDeviceName);
            p2      = (LPBYTE) pUnicodeDevMode + dmSize + dmDriverExtra;

            MoveMemory((LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName),
                       p1,
                       p2 - p1);


            pANSIDevMode->dmSize = dmSize + sizeof(pANSIDevMode->dmDeviceName)
                                          - sizeof(pUnicodeDevMode->dmDeviceName);
        }

        SPLASSERT(pANSIDevMode->dmDriverExtra == dmDriverExtra);
    }

    return;
}


BOOL
ConvertAnsiDevModeToUnicodeDevmode(
    PDEVMODEA   pAnsiDevMode,
    PDEVMODEW   pUnicodeDevMode,
    DWORD       dwUnicodeDevModeSize,
    PDWORD      pcbNeeded
    )
{
    PDEVMODEW   pDevModeW = NULL;
    BOOL        bRet = FALSE;

    if ( !pAnsiDevMode ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    SPLASSERT(BoolFromHResult(SplIsValidDevmodeNoSizeA(pAnsiDevMode)));

    pDevModeW = AllocateUnicodeDevMode(pAnsiDevMode);
    if ( !pDevModeW ) {

        goto Cleanup;
    }

    *pcbNeeded  = pDevModeW->dmSize + pDevModeW->dmDriverExtra;

    if ( *pcbNeeded > dwUnicodeDevModeSize ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    CopyMemory((LPBYTE)pUnicodeDevMode,
               (LPBYTE)pDevModeW,
               *pcbNeeded);

    bRet = TRUE;

Cleanup:

    if ( pDevModeW )
        LocalFree(pDevModeW);

    return bRet;
}


BOOL
ConvertUnicodeDevModeToAnsiDevmode(
    PDEVMODEW   pUnicodeDevMode,
    PDEVMODEA   pAnsiDevMode,
    DWORD       dwAnsiDevModeSize,
    PDWORD      pcbNeeded
    )
{
    LPBYTE      pDevMode = NULL;
    BOOL        bRet = FALSE;
    DWORD       dwSize;

    if ( !pUnicodeDevMode ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    dwSize      = pUnicodeDevMode->dmSize + pUnicodeDevMode->dmDriverExtra;

    pDevMode    = LocalAlloc(LPTR, dwSize);

    if ( !pDevMode ) {

        goto Cleanup;
    }

    CopyMemory(pDevMode,
               (LPBYTE)pUnicodeDevMode,
               dwSize);

    CopyAnsiDevModeFromUnicodeDevMode((PDEVMODEA) pDevMode,
                                      (PDEVMODEW) pDevMode);

    *pcbNeeded = ((PDEVMODEA)pDevMode)->dmSize + ((PDEVMODEA)pDevMode)->dmDriverExtra;

    if ( *pcbNeeded > dwAnsiDevModeSize ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    CopyMemory((LPBYTE)pAnsiDevMode,
               pDevMode,
               *pcbNeeded);

    bRet = TRUE;

Cleanup:
    if ( pDevMode )
        LocalFree(pDevMode);

    return bRet;
}


void
FreeUnicodeStructure(
    LPBYTE  pUnicodeStructure,
    LPDWORD pOffsets
)
{
    DWORD   i=0;

    if ( pUnicodeStructure == NULL ) {
        return;
    }

    if (pOffsets) {
        while (pOffsets[i] != -1) {

            FreeUnicodeString(*(LPWSTR *)(pUnicodeStructure+pOffsets[i]));
            i++;
        }
    }

    LocalFree( pUnicodeStructure );
}

BOOL
EnumPrintersA(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName;

    switch (Level) {

    case STRESSINFOLEVEL:
        pOffsets = PrinterInfoStressStrings;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 4:
        pOffsets = PrinterInfo4Strings;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 1:
        pOffsets = PrinterInfo1Strings;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 5:
        pOffsets = PrinterInfo5Strings;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(Name);
    if (Name && !pUnicodeName)
        return FALSE;

    ReturnValue = EnumPrintersW(Flags, pUnicodeName, Level, pPrinterEnum,
                                cbBuf, pcbNeeded, pcReturned);

    if (ReturnValue && pPrinterEnum) {

        DWORD   i=*pcReturned;

        while (i--) {


            ConvertUnicodeToAnsiStrings(pPrinterEnum, pOffsets);

            if ((Level == 2) && pPrinterEnum) {

                PRINTER_INFO_2 *pPrinterInfo2 = (PRINTER_INFO_2 *)pPrinterEnum;

                if (pPrinterInfo2->pDevMode)
                    CopyAnsiDevModeFromUnicodeDevMode(
                                        (LPDEVMODEA)pPrinterInfo2->pDevMode,
                                        (LPDEVMODEW)pPrinterInfo2->pDevMode);
            }

            pPrinterEnum+=cbStruct;
        }
    }

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
OpenPrinterA(
    LPSTR pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTSA pDefault
    )
{
    BOOL ReturnValue = FALSE;
    LPWSTR pUnicodePrinterName = NULL;
    PRINTER_DEFAULTSW UnicodeDefaults={NULL, NULL, 0};

    pUnicodePrinterName = AllocateUnicodeString(pPrinterName);
    if (pPrinterName && !pUnicodePrinterName)
        goto Cleanup;

    if (pDefault) {

        UnicodeDefaults.pDatatype = AllocateUnicodeString(pDefault->pDatatype);
        if (pDefault->pDatatype && !UnicodeDefaults.pDatatype)
            goto Cleanup;

        //
        // Milestones etc. 4.5 passes in a bogus devmode in pDefaults.
        // Be sure to validate here.
        //
        if( BoolFromHResult(SplIsValidDevmodeNoSizeA(pDefault->pDevMode))){
        
            UnicodeDefaults.pDevMode = AllocateUnicodeDevMode(
                                           pDefault->pDevMode );

            if( !UnicodeDefaults.pDevMode ){
                goto Cleanup;
            }
        }

        UnicodeDefaults.DesiredAccess = pDefault->DesiredAccess;
    }

    ReturnValue = OpenPrinterW(pUnicodePrinterName, phPrinter, &UnicodeDefaults);

    if (ReturnValue) {

        ((PSPOOL)*phPrinter)->Status |= SPOOL_STATUS_ANSI;
    }

Cleanup:

    if (UnicodeDefaults.pDevMode)
        LocalFree(UnicodeDefaults.pDevMode);

    FreeUnicodeString(UnicodeDefaults.pDatatype);
    FreeUnicodeString(pUnicodePrinterName);

    return ReturnValue;
}

BOOL
ResetPrinterA(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSA pDefault
)
{
    BOOL  ReturnValue = FALSE;
    PRINTER_DEFAULTSW UnicodeDefaults={NULL, NULL, 0};

    if (pDefault) {

        if (pDefault->pDatatype == (LPSTR)-1) {
            UnicodeDefaults.pDatatype = (LPWSTR)-1;
        } else {

            UnicodeDefaults.pDatatype = AllocateUnicodeString(pDefault->pDatatype);
            if (pDefault->pDatatype && !UnicodeDefaults.pDatatype)
                return FALSE;
        }

        if (pDefault->pDevMode == (LPDEVMODEA)-1) {
            UnicodeDefaults.pDevMode = (LPDEVMODEW)-1;
        } else {

            if( BoolFromHResult(SplIsValidDevmodeNoSizeA(pDefault->pDevMode))){
            
                UnicodeDefaults.pDevMode = AllocateUnicodeDevMode(
                                               pDefault->pDevMode );

                if( !UnicodeDefaults.pDevMode ){
                    goto Cleanup;
                }
            }
        }
    }

    ReturnValue = ResetPrinterW(hPrinter, &UnicodeDefaults);

    if (UnicodeDefaults.pDevMode &&
        (UnicodeDefaults.pDevMode != (LPDEVMODEW)-1)){

        LocalFree(UnicodeDefaults.pDevMode);
    }


Cleanup:

    if (UnicodeDefaults.pDatatype && (UnicodeDefaults.pDatatype != (LPWSTR)-1)) {
        FreeUnicodeString(UnicodeDefaults.pDatatype);
    }

    return ReturnValue;
}

BOOL
SetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL  ReturnValue=FALSE;
    LPBYTE pUnicodeStructure=NULL;
    LPDEVMODEW pDevModeW = NULL;
    DWORD   cbStruct;
    DWORD   *pOffsets;

    switch (Level) {

    case 0:
        break;

    case 1:
        pOffsets = JobInfo1Strings;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        return SetJobW( hPrinter, JobId, Level, pJob, Command );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    if (Level) {
        pUnicodeStructure = AllocateUnicodeStructure(pJob, cbStruct, pOffsets);
        if (pJob && !pUnicodeStructure)
            return FALSE;
    }

    if ( Level == 2 && pUnicodeStructure && pJob ) {

        if( BoolFromHResult(SplIsValidDevmodeNoSizeA(((LPJOB_INFO_2A)pJob)->pDevMode))){
        
            pDevModeW = AllocateUnicodeDevMode(((LPJOB_INFO_2A)pJob)->pDevMode);

            if( !pDevModeW ){
                ReturnValue = FALSE;
                goto Cleanup;
            }
            ((LPJOB_INFO_2W) pUnicodeStructure)->pDevMode = pDevModeW;
        }
    }

    ReturnValue = SetJobW(hPrinter, JobId, Level, pUnicodeStructure, Command);

    if ( pDevModeW ) {

        LocalFree(pDevModeW);
    }

Cleanup:
    FreeUnicodeStructure(pUnicodeStructure, pOffsets);

    return ReturnValue;
}

BOOL
GetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        break;

    case 3:
        return GetJobW( hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (GetJob(hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded)) {

        ConvertUnicodeToAnsiStrings(pJob, pOffsets);

        //
        // Convert the devmode in place for INFO_2.
        //
        if( Level == 2 ){

            PJOB_INFO_2A pJobInfo2 = (PJOB_INFO_2A)pJob;

            if( pJobInfo2->pDevMode ){
                CopyAnsiDevModeFromUnicodeDevMode(
                    (LPDEVMODEA)pJobInfo2->pDevMode,
                    (LPDEVMODEW)pJobInfo2->pDevMode);
            }
        }

        return TRUE;

    } else

        return FALSE;
}

BOOL
EnumJobsA(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        return EnumJobsW( hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded, pcReturned );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (EnumJobsW(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded,
                 pcReturned)) {

        i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pJob, pOffsets);

            //
            // Convert the devmode in place for INFO_2.
            //
            if( Level == 2 ){

                PJOB_INFO_2A pJobInfo2 = (PJOB_INFO_2A)pJob;

                if( pJobInfo2->pDevMode ){
                    CopyAnsiDevModeFromUnicodeDevMode(
                        (LPDEVMODEA)pJobInfo2->pDevMode,
                        (LPDEVMODEW)pJobInfo2->pDevMode);
                }
            }

            pJob += cbStruct;
        }

        return TRUE;

    } else

        return FALSE;
}

HANDLE
AddPrinterA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
)
{
    HANDLE  hPrinter = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDEVMODEW pDevModeW = NULL;
    LPWSTR  pUnicodeName = NULL;
    DWORD   cbStruct;
    DWORD   *pOffsets;

    switch (Level) {

    case 2:
        pOffsets = PrinterInfo2Strings;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return NULL;
    }

    if (!pPrinter) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pPrinter, cbStruct, pOffsets);
    if (pPrinter && !pUnicodeStructure)
        goto Cleanup;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    if ( pUnicodeStructure ) {

        if( BoolFromHResult(SplIsValidDevmodeNoSizeA(((LPPRINTER_INFO_2A)pPrinter)->pDevMode))){
            pDevModeW = AllocateUnicodeDevMode(
                            ((LPPRINTER_INFO_2A)pPrinter)->pDevMode);

            if( !pDevModeW ){
                goto Cleanup;
            }
        }

        ((LPPRINTER_INFO_2W)pUnicodeStructure)->pDevMode =  pDevModeW;

        hPrinter = AddPrinterW(pUnicodeName, Level, pUnicodeStructure);
    }

Cleanup:

    FreeUnicodeString( pUnicodeName );

    if ( pDevModeW ) {

        LocalFree(pDevModeW);
    }

    FreeUnicodeStructure( pUnicodeStructure, pOffsets );

    return hPrinter;
}

BOOL
AddPrinterConnectionA(
    LPSTR   pName
)
{
    BOOL    rc;
    LPWSTR  pUnicodeName;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        return FALSE;

    rc = AddPrinterConnectionW(pUnicodeName);

    FreeUnicodeString(pUnicodeName);

    return rc;
}

BOOL
DeletePrinterConnectionA(
    LPSTR   pName
)
{
    BOOL    rc;
    LPWSTR  pUnicodeName;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        return FALSE;

    rc = DeletePrinterConnectionW(pUnicodeName);

    FreeUnicodeString(pUnicodeName);

    return rc;
}

BOOL
SetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    LPBYTE  pUnicodeStructure;         /* Unicode version of input data */
    DWORD   cbStruct;                  /* Size of the output structure */
    DWORD  *pOffsets;                  /* -1 terminated list of addresses */
    DWORD   ReturnValue=FALSE;

    //
    // For APP compat. Win9x handled this
    //
    if (eProtectHandle(hPrinter, FALSE))
    {
        return FALSE;
    }

    switch (Level) {

    case 0:
        //
        // This could be 2 cases. STRESSINFOLEVEL, or the real 0 level.
        // If Command is 0 then it is STRESSINFOLEVEL, else real 0 level
        //
        if ( !Command ) {

            pOffsets = PrinterInfoStressStrings;
            cbStruct = sizeof( PRINTER_INFO_STRESS );
        }
        break;

    case 1:
        pOffsets = PrinterInfo1Strings;
        cbStruct = sizeof( PRINTER_INFO_1 );
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        cbStruct = sizeof( PRINTER_INFO_2 );
        break;

    case 3:
        pOffsets = PrinterInfo3Strings;
        cbStruct = sizeof( PRINTER_INFO_3 );
        break;

    case 4:
        pOffsets = PrinterInfo4Strings;
        cbStruct = sizeof( PRINTER_INFO_4 );
        break;

    case 5:
        pOffsets = PrinterInfo5Strings;
        cbStruct = sizeof( PRINTER_INFO_5 );
        break;

    case 6:
        break;

    case 7:
        pOffsets = PrinterInfo7Strings;
        cbStruct = sizeof( PRINTER_INFO_7 );
        break;

    case 8:
        pOffsets = PrinterInfo8Strings;
        cbStruct = sizeof( PRINTER_INFO_8 );
        break;

    case 9:
        pOffsets = PrinterInfo9Strings;
        cbStruct = sizeof( PRINTER_INFO_9 );
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        goto Done;
    }

     //
     //    The structure needs to have its CONTENTS converted from
     //  ANSI to Unicode.  The above switch() statement filled in
     //  the two important pieces of information needed to accomplish
     //  this goal.  First is the size of the structure, second is
     //  a list of the offset within the structure to UNICODE
     //  string pointers.  The AllocateUnicodeStructure() call will
     //  allocate a wide version of the structure, copy its contents
     //  and convert the strings to Unicode as it goes.  That leaves
     //  us to deal with any other pieces needing conversion.
     //

    //
    // If Level == 0 and Command != 0 then pPrinter is a DWORD
    //
    if ( Level == 6 || (!Level && Command) ) {

        if ( Level == 6 || Command == PRINTER_CONTROL_SET_STATUS )
            pUnicodeStructure = pPrinter;
        else
            pUnicodeStructure = NULL;

    } else {

        pUnicodeStructure = AllocateUnicodeStructure(pPrinter, cbStruct, pOffsets);
        if (pPrinter && !pUnicodeStructure)
        {
            goto Done;
        }
    }

#define pPrinterInfo2W  ((LPPRINTER_INFO_2W)pUnicodeStructure)
#define pPrinterInfo2A  ((LPPRINTER_INFO_2A)pPrinter)

    //
    //  The Level 2 structure has a DEVMODE struct in it: convert now
    //
    if ( Level == 2  &&
         pPrinterInfo2A &&
         pPrinterInfo2A->pDevMode ) {

        if( BoolFromHResult(SplIsValidDevmodeNoSizeA(pPrinterInfo2A->pDevMode))){
            pPrinterInfo2W->pDevMode = AllocateUnicodeDevMode(
                                           pPrinterInfo2A->pDevMode );

            if( !pPrinterInfo2W->pDevMode)
            {
                FreeUnicodeStructure(pUnicodeStructure, pOffsets);
                goto Done;
            }
        }
    }

#define pPrinterInfo8W  ((LPPRINTER_INFO_8W)pUnicodeStructure)
#define pPrinterInfo8A  ((LPPRINTER_INFO_8A)pPrinter)

    if (( Level == 8 || Level == 9 ) &&
         pPrinterInfo8A &&
         pPrinterInfo8A->pDevMode ) {

        if( BoolFromHResult(SplIsValidDevmodeNoSizeA(pPrinterInfo8A->pDevMode))){
            pPrinterInfo8W->pDevMode = AllocateUnicodeDevMode(
                                           pPrinterInfo8A->pDevMode );

            if( !pPrinterInfo8W->pDevMode)
            {
                FreeUnicodeStructure(pUnicodeStructure, pOffsets);
                goto Done;
            }
        }
    }

    ReturnValue = SetPrinterW( hPrinter, Level, pUnicodeStructure, Command );

    //
    //  Free the DEVMODE we allocated (if we did!), then the
    //  the Unicode structure and its contents.
    //
    if (Level == 2 &&
        pPrinterInfo2W &&
        pPrinterInfo2W->pDevMode ) {

        LocalFree( pPrinterInfo2W->pDevMode );
    }

    if ((Level == 8 || Level == 9) &&
        pUnicodeStructure &&
        pPrinterInfo8W->pDevMode ) {

        LocalFree( pPrinterInfo8W->pDevMode );
    }

    //
    // STRESS_INFO and Levels 1-5
    //
    if ( Level != 6 && (Level || !Command) )
        FreeUnicodeStructure( pUnicodeStructure, pOffsets );

#undef pPrinterInfo2W
#undef pPrinterInfo2A

Done:

    vUnprotectHandle(hPrinter);

    return ReturnValue;
}

BOOL
GetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;

    switch (Level) {

        case STRESSINFOLEVEL:
            pOffsets = PrinterInfoStressOffsets;
            break;

        case 1:
            pOffsets = PrinterInfo1Strings;
            break;

        case 2:
            pOffsets = PrinterInfo2Strings;
            break;

        case 3:
            pOffsets = PrinterInfo3Strings;
            break;

        case 4:
            pOffsets = PrinterInfo4Strings;
            break;

        case 5:
            pOffsets = PrinterInfo5Strings;
            break;

        case 6:
            pOffsets = PrinterInfo6Strings;
            break;

        case 7:
            pOffsets = PrinterInfo7Strings;
            break;

        case 8:
            pOffsets = PrinterInfo8Strings;
            break;

        case 9:
            pOffsets = PrinterInfo9Strings;
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    if (GetPrinter(hPrinter, Level, pPrinter, cbBuf, pcbNeeded)) {

        if (pPrinter) {

            ConvertUnicodeToAnsiStrings(pPrinter, pOffsets);

            if ((Level == 2) && pPrinter) {

                PRINTER_INFO_2 *pPrinterInfo2 = (PRINTER_INFO_2 *)pPrinter;

                if (pPrinterInfo2->pDevMode)
                    CopyAnsiDevModeFromUnicodeDevMode(
                                        (LPDEVMODEA)pPrinterInfo2->pDevMode,
                                        (LPDEVMODEW)pPrinterInfo2->pDevMode);
            }

            if ((Level == 8 || Level == 9) && pPrinter) {

                PRINTER_INFO_8 *pPrinterInfo8 = (PRINTER_INFO_8 *)pPrinter;

                if (pPrinterInfo8->pDevMode)
                    CopyAnsiDevModeFromUnicodeDevMode(
                                        (LPDEVMODEA)pPrinterInfo8->pDevMode,
                                        (LPDEVMODEW)pPrinterInfo8->pDevMode);
            }
        }

        return TRUE;
    }

    return FALSE;
}

BOOL
UnicodeToAnsiMultiSz(
    LPWSTR pUnicodeDependentFiles
    )
{
    LPWSTR  pAlignedUnicodeStr = NULL;
    LPWSTR  pUnicodeStr;
    DWORD   StringLength, rc;
    DWORD   Index;
    BOOL    bReturn = FALSE;

    //
    // Conversion in place
    //
    if (!(pUnicodeDependentFiles) || !*pUnicodeDependentFiles) {

        bReturn = TRUE;

    } else {

        if ((ULONG_PTR)pUnicodeDependentFiles != (((ULONG_PTR) (pUnicodeDependentFiles) + (sizeof(WCHAR) - 1))&~(sizeof(WCHAR) - 1))) {

            //
            // Calculate the length of the unaligned multisz string
            //
            for (StringLength = 0;
                 !( ((LPSTR)pUnicodeDependentFiles)[StringLength]     == '\0' &&
                    ((LPSTR)pUnicodeDependentFiles)[StringLength + 1] == '\0' &&
                    ((LPSTR)pUnicodeDependentFiles)[StringLength + 2] == '\0' &&
                    ((LPSTR)pUnicodeDependentFiles)[StringLength + 3] == '\0' );
                StringLength += 2)
                ;

            StringLength /= 2;

            //
            // Include NULL terminator for last string and NULL terminator for MULTI SZ
            //
            StringLength +=2;

        } else {

            //
            // The string is WCHAR aligned.
            //
            pUnicodeStr = pUnicodeDependentFiles;

            while ( *pUnicodeStr ) {

                pUnicodeStr += wcslen(pUnicodeStr) + 1;
            }

            StringLength = (DWORD) (pUnicodeStr - pUnicodeDependentFiles + 1);
        }

        //
        // Since WideCharToMultiByte doesn't do in place conversion,
        // duplicate the pUnicodeDependentFiles regardless if it is aligned or not.
        //
        if (pAlignedUnicodeStr = LocalAlloc(LPTR, StringLength * sizeof(char) * 2)) {

            memcpy( pAlignedUnicodeStr, pUnicodeDependentFiles, StringLength * sizeof(char)* 2);

            rc = WideCharToMultiByte(CP_THREAD_ACP,
                                     0,
                                     pAlignedUnicodeStr,
                                     StringLength,
                                     (LPSTR)pUnicodeDependentFiles,
                                     StringLength * 2,
                                     NULL, NULL );

            LocalFree( pAlignedUnicodeStr );

            bReturn = rc > 0;
        }

    }

    return bReturn;
}

BOOL
AnsiToUnicodeMultiSz(
    LPSTR   pAnsiDependentFiles,
    LPWSTR *pUnicodeDependentFiles
    )
{
    LPWSTR  pUnicodeStr;
    LPSTR   pAnsiStr;
    DWORD   len, rc;

    if ( ! (pAnsiStr = pAnsiDependentFiles) || !*pAnsiStr ) {
        *pUnicodeDependentFiles = NULL;
        return TRUE;
    }

    while ( *pAnsiStr )
            pAnsiStr += strlen(pAnsiStr) + 1;
    len = (DWORD) (pAnsiStr - pAnsiDependentFiles + 1);

    if ( !(*pUnicodeDependentFiles = LocalAlloc(LPTR, len * sizeof(WCHAR))) ) {

        return FALSE;
    }

    AnsiToUnicodeString(pAnsiDependentFiles, *pUnicodeDependentFiles, len-1);

    return TRUE;
}

BOOL
AddPrinterDriverExA(
    LPSTR   pName,
    DWORD   Level,
    PBYTE   pPrinter,
    DWORD   dwFileCopyFlags
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    LPWSTR  pUnicodeName = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDWORD pOffsets;

    switch (Level) {

    case 2:
        pOffsets = DriverInfo2Strings;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pOffsets = DriverInfo3Strings;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pOffsets = DriverInfo4Strings;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 6:
        pOffsets = DriverInfo6Strings;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!pPrinter) {

        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pPrinter, cbStruct, pOffsets);
    if (pPrinter && !pUnicodeStructure)
        goto Error;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Error;


    //
    // Handle dependent files which is upto \0\0
    //
    if ( ( Level == 3 || Level == 4 || Level ==6 ) &&
         !AnsiToUnicodeMultiSz(
                (LPSTR) ((PDRIVER_INFO_3A)pPrinter)->pDependentFiles,
                &(((PDRIVER_INFO_3W)pUnicodeStructure)->pDependentFiles)) ) {

            goto Error;
    }

    //
    // Handle pszzPreviousNames which is upto \0\0
    //
    if ( ( Level == 4 || Level == 6 ) &&
         !AnsiToUnicodeMultiSz(
                (LPSTR) ((PDRIVER_INFO_4A)pPrinter)->pszzPreviousNames,
                &(((PDRIVER_INFO_4W)pUnicodeStructure)->pszzPreviousNames)) ) {

            goto Error;
    }

    ReturnValue = AddPrinterDriverExW(pUnicodeName, Level, pUnicodeStructure,dwFileCopyFlags);

    if ( ( Level == 3 || Level == 4 || Level == 6)   &&
         ((PDRIVER_INFO_3W)pUnicodeStructure)->pDependentFiles ) {

            LocalFree(((PDRIVER_INFO_3W)pUnicodeStructure)->pDependentFiles);
    }

    if ( (Level == 4 || Level == 6 )&&
         (((PDRIVER_INFO_4)pUnicodeStructure)->pszzPreviousNames) )
        LocalFree(((PDRIVER_INFO_4)pUnicodeStructure)->pszzPreviousNames);

Error:

    FreeUnicodeStructure( pUnicodeStructure, pOffsets );

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}


BOOL
AddPrinterDriverA(
    LPSTR   pName,
    DWORD   Level,
    PBYTE   pPrinter
)
{
    return AddPrinterDriverExA(pName, Level, pPrinter, APD_COPY_NEW_FILES);
}

BOOL
EnumPrinterDriversA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Strings;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pOffsets = DriverInfo2Strings;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pOffsets = DriverInfo3Strings;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pOffsets = DriverInfo4Strings;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pOffsets = DriverInfo5Strings;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pOffsets = DriverInfo6Strings;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    if (ReturnValue = EnumPrinterDriversW(pUnicodeName, pUnicodeEnvironment,
                                          Level, pDriverInfo, cbBuf,
                                          pcbNeeded, pcReturned)) {
        if (pDriverInfo) {

            DWORD   i=*pcReturned;

            while (i--) {

                ConvertUnicodeToAnsiStrings(pDriverInfo, pOffsets);

                if ( ( Level == 3 || Level == 4 || Level == 6)   &&
                     !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_3) pDriverInfo)->pDependentFiles) )
                    ReturnValue = FALSE;

                if ( ( Level == 4 || Level == 6 )   &&
                     !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_4) pDriverInfo)->pszzPreviousNames) )
                    ReturnValue = FALSE;

                pDriverInfo+=cbStruct;
            }
        }

    }

Cleanup:

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
GetPrinterDriverA(
    HANDLE  hPrinter,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;
    LPWSTR  pUnicodeEnvironment = NULL;
    BOOL    ReturnValue;

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Strings;
        break;

    case 2:
        pOffsets = DriverInfo2Strings;
        break;

    case 3:
        pOffsets = DriverInfo3Strings;
        break;

    case 4:
        pOffsets = DriverInfo4Strings;
        break;

    case 5:
        pOffsets = DriverInfo5Strings;
        break;

    case 6:
        pOffsets = DriverInfo6Strings;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        return FALSE;

    if (ReturnValue = GetPrinterDriverW(hPrinter, pUnicodeEnvironment, Level,
                                        pDriverInfo, cbBuf, pcbNeeded)) {
        if (pDriverInfo) {

            ConvertUnicodeToAnsiStrings(pDriverInfo, pOffsets);

            if ( ( Level == 3 || Level == 4 || Level == 6)   &&
                 !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_3)pDriverInfo)->pDependentFiles) ) {

                  ReturnValue = FALSE;
            }

            if ( ( Level == 4 || Level == 6 ) &&
                 !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_4)pDriverInfo)->pszzPreviousNames) ) {

                  ReturnValue = FALSE;
            }
        }
    }

    //
    // If called to get the size of buffer it will return the size of a W structure and strings
    // rather than the A version.  also see enum
    // This cannot cause any harm since we are only allocating more memory than we need.
    //
    FreeUnicodeString(pUnicodeEnvironment);

    return ReturnValue;
}

BOOL
GetPrinterDriverDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pDriverDirectoryW = NULL;
    BOOL    ReturnValue = FALSE;
    DWORD   Offsets[]={0,(DWORD)-1};

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    if (ReturnValue = GetPrinterDriverDirectoryW(pUnicodeName,
                                                 pUnicodeEnvironment, Level,
                                                 pDriverDirectory,
                                                 cbBuf, pcbNeeded)) {

        if (pDriverDirectory) {

            UnicodeToAnsiString((LPWSTR)pDriverDirectory, pDriverDirectory, NULL_TERMINATED);

        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}


BOOL
DeletePrinterDriverExA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName,
   DWORD    dwDeleteFlag,
   DWORD    dwVersionNum
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeDriverName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodeDriverName = AllocateUnicodeString(pDriverName);
    if (pDriverName && !pUnicodeDriverName)
        goto Cleanup;

    rc = DeletePrinterDriverExW(pUnicodeName,
                               pUnicodeEnvironment,
                               pUnicodeDriverName,
                               dwDeleteFlag,
                               dwVersionNum);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeDriverName);

    return rc;
}


BOOL
DeletePrinterDriverA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeDriverName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodeDriverName = AllocateUnicodeString(pDriverName);
    if (pDriverName && !pUnicodeDriverName)
        goto Cleanup;

    rc = DeletePrinterDriverW(pUnicodeName,
                              pUnicodeEnvironment,
                              pUnicodeDriverName);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeDriverName);

    return rc;
}


BOOL
AddPerMachineConnectionA(
    LPCSTR    pServer,
    LPCSTR    pPrinterName,
    LPCSTR    pPrintServer,
    LPCSTR    pProvider
)
{

    LPWSTR  pUnicodeServer = NULL;
    LPWSTR  pUnicodePrinterName = NULL;
    LPWSTR  pUnicodePrintServer = NULL;
    LPWSTR  pUnicodeProvider = NULL;
    BOOL    rc = FALSE;

    pUnicodeServer = AllocateUnicodeString((LPSTR)pServer);
    if (pServer && !pUnicodeServer)
        goto Cleanup;

    pUnicodePrinterName = AllocateUnicodeString((LPSTR)pPrinterName);
    if (pPrinterName && !pUnicodePrinterName)
        goto Cleanup;

    pUnicodePrintServer = AllocateUnicodeString((LPSTR)pPrintServer);
    if (pPrintServer && !pUnicodePrintServer)
        goto Cleanup;

    pUnicodeProvider = AllocateUnicodeString((LPSTR)pProvider);
    if (pProvider && !pUnicodeProvider)
        goto Cleanup;


    rc = AddPerMachineConnectionW((LPCWSTR) pUnicodeServer,
                                  (LPCWSTR) pUnicodePrinterName,
                                  (LPCWSTR) pUnicodePrintServer,
                                  (LPCWSTR) pUnicodeProvider);

Cleanup:
    FreeUnicodeString(pUnicodeServer);

    FreeUnicodeString(pUnicodePrinterName);

    FreeUnicodeString(pUnicodePrintServer);

    FreeUnicodeString(pUnicodeProvider);

    return rc;
}

BOOL
DeletePerMachineConnectionA(
    LPCSTR    pServer,
    LPCSTR    pPrinterName
)
{

    LPWSTR  pUnicodeServer = NULL;
    LPWSTR  pUnicodePrinterName = NULL;
    BOOL    rc = FALSE;

    pUnicodeServer = AllocateUnicodeString((LPSTR)pServer);
    if (pServer && !pUnicodeServer)
        goto Cleanup;

    pUnicodePrinterName = AllocateUnicodeString((LPSTR)pPrinterName);
    if (pPrinterName && !pUnicodePrinterName)
        goto Cleanup;

    rc = DeletePerMachineConnectionW((LPCWSTR) pUnicodeServer,
                                     (LPCWSTR) pUnicodePrinterName);

Cleanup:
    FreeUnicodeString(pUnicodeServer);

    FreeUnicodeString(pUnicodePrinterName);

    return rc;
}

BOOL
EnumPerMachineConnectionsA(
    LPCSTR  pServer,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct,index;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeServer = NULL;

    pOffsets = PrinterInfo4Strings;
    cbStruct = sizeof(PRINTER_INFO_4);

    pUnicodeServer = AllocateUnicodeString((LPSTR)pServer);
    if (pServer && !pUnicodeServer)
        goto Cleanup;

    ReturnValue = EnumPerMachineConnectionsW((LPCWSTR) pUnicodeServer,
                                             pPrinterEnum,
                                             cbBuf,
                                             pcbNeeded,
                                             pcReturned);

    if (ReturnValue && pPrinterEnum) {
        index=*pcReturned;
        while (index--) {
            ConvertUnicodeToAnsiStrings(pPrinterEnum, pOffsets);
            pPrinterEnum+=cbStruct;
        }
    }

Cleanup:
    FreeUnicodeString(pUnicodeServer);
    return ReturnValue;
}

BOOL
AddPrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPathName,
    LPSTR   pPrintProcessorName
)
{
    BOOL    ReturnValue=FALSE;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodePathName = NULL;
    LPWSTR  pUnicodePrintProcessorName = NULL;

    if (!pPathName || !*pPathName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodePathName = AllocateUnicodeString(pPathName);
    if (pPathName && !pUnicodePathName)
        goto Cleanup;

    pUnicodePrintProcessorName = AllocateUnicodeString(pPrintProcessorName);
    if (pPrintProcessorName && !pUnicodePrintProcessorName)
        goto Cleanup;


    if (pUnicodePathName && pUnicodePrintProcessorName) {

        ReturnValue = AddPrintProcessorW(pUnicodeName, pUnicodeEnvironment,
                                         pUnicodePathName,
                                         pUnicodePrintProcessorName);
    }


Cleanup:
    FreeUnicodeString(pUnicodeName);
    FreeUnicodeString(pUnicodeEnvironment);
    FreeUnicodeString(pUnicodePathName);
    FreeUnicodeString(pUnicodePrintProcessorName);

    return ReturnValue;
}

BOOL
EnumPrintProcessorsA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;

    switch (Level) {

    case 1:
        pOffsets = PrintProcessorInfo1Strings;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    if (ReturnValue = EnumPrintProcessorsW(pUnicodeName,
                                           pUnicodeEnvironment, Level,
                                           pPrintProcessorInfo, cbBuf,
                                           pcbNeeded, pcReturned)) {
        if (pPrintProcessorInfo) {

            DWORD   i=*pcReturned;

            while (i--) {

                ConvertUnicodeToAnsiStrings(pPrintProcessorInfo, pOffsets);

                pPrintProcessorInfo+=cbStruct;
            }
        }

    }

Cleanup:

    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    return ReturnValue;
}

BOOL
GetPrintProcessorDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL    ReturnValue = FALSE;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    ReturnValue = GetPrintProcessorDirectoryW(pUnicodeName,
                                              pUnicodeEnvironment,
                                              Level,
                                              pPrintProcessorInfo,
                                              cbBuf, pcbNeeded);

    if (ReturnValue && pPrintProcessorInfo) {
                UnicodeToAnsiString((LPWSTR)pPrintProcessorInfo,
                                        (LPSTR)pPrintProcessorInfo,
                                        NULL_TERMINATED);
    }

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    return ReturnValue;
}

BOOL
EnumPrintProcessorDatatypesA(
    LPSTR   pName,
    LPSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatype,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodePrintProcessorName = NULL;

    switch (Level) {

    case 1:
        pOffsets = DatatypeInfo1Strings;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodePrintProcessorName = AllocateUnicodeString(pPrintProcessorName);
    if (pPrintProcessorName && !pUnicodePrintProcessorName)
        goto Cleanup;

    if (ReturnValue = EnumPrintProcessorDatatypesW(pUnicodeName,
                                                   pUnicodePrintProcessorName,
                                                   Level,
                                                   pDatatype,
                                                   cbBuf,
                                                   pcbNeeded,
                                                   pcReturned)) {
        if (pDatatype) {

            DWORD   i=*pcReturned;

            while (i--) {

                ConvertUnicodeToAnsiStrings(pDatatype, pOffsets);

                pDatatype += cbStruct;
            }
        }

    }

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodePrintProcessorName);

    return ReturnValue;
}

DWORD
StartDocPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL    ReturnValue = FALSE;
    LPBYTE  pUnicodeStructure = NULL;
    DWORD   cbStruct;

    // level 2 is supported on win95 and not on NT
    switch (Level) {
    case 1:
        cbStruct = sizeof(DOC_INFO_1A);
        break;
    case 3:
        cbStruct = sizeof(DOC_INFO_3A);
        break;
    default:        
        SetLastError(ERROR_INVALID_LEVEL);
        goto Cleanup;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pDocInfo, cbStruct, DocInfo1Offsets);
    if (pDocInfo && !pUnicodeStructure)
        goto Cleanup;

    ReturnValue = StartDocPrinterW(hPrinter, Level, pUnicodeStructure);

Cleanup:

    FreeUnicodeStructure(pUnicodeStructure, DocInfo1Offsets);

    return ReturnValue;
}

BOOL
AddJobA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL ReturnValue;

    if( Level == 2 || Level == 3 ){

        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    if (ReturnValue = AddJobW(hPrinter, Level, pData,
                              cbBuf, pcbNeeded))

        ConvertUnicodeToAnsiStrings(pData, AddJobStrings);

    return ReturnValue;
}

DWORD
GetPrinterDataA(
   HANDLE   hPrinter,
   LPSTR    pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue       = ERROR_SUCCESS;
    DWORD   ReturnType        = 0;
    LPWSTR  pUnicodeValueName = NULL;

    pUnicodeValueName = AllocateUnicodeString(pValueName);

    //
    // pUnicodeValueName will be NULL if the caller passed NULL for pValueName. The
    // invalid situation is when pValueName is non NULL and pUnicodeValueName is NULL
    //
    if (pUnicodeValueName || !pValueName)
    {
        if (!pType)
        {
            pType = (PDWORD)&ReturnType;
        }

        if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSION))
        {
            //
            // The caller wants OSVersion
            //
            OSVERSIONINFOW osw = {0};

            ReturnValue = GetPrinterDataW(hPrinter,
                                          pUnicodeValueName,
                                          pType,
                                          (PBYTE)&osw,
                                          nSize >= sizeof(OSVERSIONINFOA) ? sizeof(osw) : nSize,
                                          pcbNeeded);

            if (ReturnValue == ERROR_SUCCESS && pData)
            {
                OSVERSIONWRAP wrap = {0};

                wrap.bOsVersionEx       = FALSE;
                wrap.Unicode.pOsVersion = &osw;
                wrap.Ansi.pOsVersion    = (OSVERSIONINFOA *)pData;

                ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
            }

            //
            // Set correct number of bytes required/returned
            //
            if (pcbNeeded)
            {
                *pcbNeeded = sizeof(OSVERSIONINFOA);
            }
        }
        else if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSIONEX))
        {
            //
            // The caller wants OSVersionEx
            //
            OSVERSIONINFOEXW osexw = {0};

            ReturnValue = GetPrinterDataW(hPrinter,
                                          pUnicodeValueName,
                                          pType,
                                          (PBYTE)&osexw,
                                          nSize >= sizeof(OSVERSIONINFOEXA) ? sizeof(osexw) : nSize,
                                          pcbNeeded);

            if (ReturnValue == ERROR_SUCCESS && pData)
            {
                OSVERSIONWRAP wrap = {0};

                wrap.bOsVersionEx         = TRUE;
                wrap.Unicode.pOsVersionEx = &osexw;
                wrap.Ansi.pOsVersionEx    = (OSVERSIONINFOEXA *)pData;

                ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
            }

            //
            // Set correct number of bytes required/returned
            //
            if (pcbNeeded)
            {
                *pcbNeeded = sizeof(OSVERSIONINFOEXA);
            }
        }
        else
        {
            ReturnValue  = GetPrinterDataW(hPrinter, pUnicodeValueName, pType, pData, nSize, pcbNeeded);

            //
            // Special case string values
            //
            if ((ReturnValue == ERROR_MORE_DATA || ReturnValue == ERROR_SUCCESS) &&
                (*pType == REG_MULTI_SZ || *pType == REG_SZ || *pType == REG_EXPAND_SZ))
            {
                if (ReturnValue==ERROR_SUCCESS)
                {
                    //
                    // The buffer passed in by the caller was large enough. We only need to
                    // convert from UNICODE to ANSI. It can happen that a UNICODE char will
                    // be represented on 3 ansi chars, so we cannot assume that if a buffer
                    // is large enough for a unicode string, it can also accomodate the converted
                    // ansi string.
                    //
                    ReturnValue = UnicodeToAnsi(NULL,
                                                0,
                                                pData,
                                                *pcbNeeded,
                                                pcbNeeded);
                }
                else
                {
                    BYTE *pBuf = NULL;

                    if (pBuf = LocalAlloc(LPTR, *pcbNeeded))
                    {
                        if ((ReturnValue = GetPrinterDataW(hPrinter,
                                                           pUnicodeValueName,
                                                           pType,
                                                           pBuf,
                                                           *pcbNeeded,
                                                           pcbNeeded)) == ERROR_SUCCESS)
                        {
                            ReturnValue = UnicodeToAnsi(pBuf,
                                                        *pcbNeeded / sizeof(WCHAR),
                                                        pData,
                                                        nSize,
                                                        pcbNeeded);
                        }

                        LocalFree(pBuf);
                    }
                    else
                    {
                        ReturnValue = GetLastError();
                    }
                }
            }
        }
    }
    else
    {
        //
        // pUnicodeValueName is NULL and pValueName is NOT NULL, so AllocateUnicodeString failed
        // AllocateUnicodeString sets the LastError correctly 
        //
        ReturnValue = GetLastError();
    }

    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}

DWORD
GetPrinterDataExA(
   HANDLE   hPrinter,
   LPCSTR   pKeyName,
   LPCSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue       = ERROR_SUCCESS;
    DWORD   ReturnType        = 0;
    LPWSTR  pUnicodeValueName = NULL;
    LPWSTR  pUnicodeKeyName   = NULL;

    pUnicodeValueName = AllocateUnicodeString((LPSTR) pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    if (!pType) {
        pType = (PDWORD) &ReturnType;
    }

    if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSION))
    {
        //
        // The caller wants OSVersion
        //
        OSVERSIONINFOW osw = {0};

        ReturnValue = GetPrinterDataExW(hPrinter,
                                        (LPCWSTR)pUnicodeKeyName,
                                        (LPCWSTR)pUnicodeValueName,
                                        pType,
                                        (PBYTE)&osw,
                                        nSize >= sizeof(OSVERSIONINFOA) ? sizeof(osw) : nSize,
                                        pcbNeeded);

        if (ReturnValue == ERROR_SUCCESS && pData)
        {
            OSVERSIONWRAP wrap = {0};

            wrap.bOsVersionEx       = FALSE;
            wrap.Unicode.pOsVersion = &osw;
            wrap.Ansi.pOsVersion    = (OSVERSIONINFOA *)pData;

            ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
        }

        //
        // Set correct number of bytes required/returned
        //
        if (pcbNeeded)
        {
            *pcbNeeded = sizeof(OSVERSIONINFOA);
        }
    }
    else if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSIONEX))
    {
        //
        // The caller wants OSVersionEx
        //
        OSVERSIONINFOEXW osexw = {0};

        ReturnValue = GetPrinterDataExW(hPrinter,
                                        (LPCWSTR)pUnicodeKeyName,
                                        (LPCWSTR)pUnicodeValueName,
                                        pType,
                                        (PBYTE)&osexw,
                                        nSize >= sizeof(OSVERSIONINFOEXA) ? sizeof(osexw) : nSize,
                                        pcbNeeded);

        if (ReturnValue == ERROR_SUCCESS && pData)
        {
            OSVERSIONWRAP wrap = {0};

            wrap.bOsVersionEx         = TRUE;
            wrap.Unicode.pOsVersionEx = &osexw;
            wrap.Ansi.pOsVersionEx    = (OSVERSIONINFOEXA *)pData;

            ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
        }

        //
        // Set correct number of bytes required/returned
        //
        if (pcbNeeded)
        {
            *pcbNeeded = sizeof(OSVERSIONINFOEXA);
        }
    }
    else
    {
        ReturnValue  = GetPrinterDataExW(hPrinter,
                                         (LPCWSTR)pUnicodeKeyName,
                                         (LPCWSTR)pUnicodeValueName,
                                         pType,
                                         pData,
                                         nSize,
                                         pcbNeeded);

        //
        // Special case string values
        //
        if ((ReturnValue == ERROR_MORE_DATA || ReturnValue == ERROR_SUCCESS) &&
            (*pType == REG_MULTI_SZ || *pType == REG_SZ || *pType == REG_EXPAND_SZ))
        {
            if (ReturnValue==ERROR_SUCCESS)
            {
                //
                // The buffer passed in by the caller was large enough. We only need to
                // convert from UNICODE to ANSI. It can happen that a UNICODE char will
                // be represented on 3 ansi chars, so we cannot assume that if a buffer
                // is large enough for a unicode string, it can also accomodate the converted
                // ansi string.
                //
                ReturnValue = UnicodeToAnsi(NULL,
                                            0,
                                            pData,
                                            *pcbNeeded,
                                            pcbNeeded);
            }
            else
            {
                BYTE *pBuf = NULL;

                if (pBuf = LocalAlloc(LPTR, *pcbNeeded))
                {
                    if ((ReturnValue = GetPrinterDataExW(hPrinter,
                                                         (LPCWSTR)pUnicodeKeyName,
                                                         (LPCWSTR)pUnicodeValueName,
                                                         pType,
                                                         pBuf,
                                                         *pcbNeeded,
                                                         pcbNeeded)) == ERROR_SUCCESS)
                    {
                        ReturnValue = UnicodeToAnsi(pBuf,
                                                    *pcbNeeded / sizeof(WCHAR),
                                                    pData,
                                                    nSize,
                                                    pcbNeeded);
                    }

                    LocalFree(pBuf);
                }
                else
                {
                    ReturnValue = GetLastError();
                }
            }
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeKeyName);
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
EnumPrinterDataA(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPSTR   pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of pValueName
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of pData
    LPDWORD pcbData         // address for size of data buffer
)
{
    DWORD   ReturnValue = 0;
    DWORD   i;


    ReturnValue =  EnumPrinterDataW(hPrinter,
                                    dwIndex,
                                    (LPWSTR) pValueName,
                                    cbValueName,
                                    pcbValueName,
                                    pType,
                                    pData,
                                    cbData,
                                    pcbData);

    if (ReturnValue == ERROR_SUCCESS && (cbValueName || cbData))
    {
        if (pData && pType &&
            (*pType==REG_SZ ||
             *pType==REG_MULTI_SZ ||
             *pType==REG_EXPAND_SZ))
        {
            //
            // For this API we will require a buffer size that can accomodate UNICODE strings
            // We do not want UnicodeToAnsi to update the number of bytes needed to store
            // the string converted to ansi.
            //
            UnicodeToAnsi(NULL, 0, pData, *pcbData, NULL);
        }

        UnicodeToAnsiString((LPWSTR) pValueName, (LPSTR) pValueName, NULL_TERMINATED);
    }

    return ReturnValue;
}

DWORD
EnumPrinterDataExA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    DWORD   ReturnValue = 0;
    DWORD   i;
    PPRINTER_ENUM_VALUES pEnumValue;
    LPWSTR  pUnicodeKeyName = NULL;


    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;


    ReturnValue =  EnumPrinterDataExW(hPrinter,
                                      (LPCWSTR) pUnicodeKeyName,
                                      pEnumValues,
                                      cbEnumValues,
                                      pcbEnumValues,
                                      pnEnumValues);

    if (ReturnValue == ERROR_SUCCESS) {

        pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;

        for(i = 0 ; i < *pnEnumValues ; ++i, ++pEnumValue) {

            if (pEnumValue->cbValueName) {
                UnicodeToAnsiString((LPWSTR) pEnumValue->pValueName,
                                    (LPSTR) pEnumValue->pValueName,
                                    NULL_TERMINATED);
            }

            if (pEnumValue->pData &&
                (pEnumValue->dwType == REG_SZ ||
                 pEnumValue->dwType == REG_MULTI_SZ ||
                 pEnumValue->dwType == REG_EXPAND_SZ)) {

                //
                // For this API we will require a buffer size that can accomodate UNICODE strings
                // We do not want UnicodeToAnsi to update the number of bytes needed to store
                // the string converted to ansi.
                //
                UnicodeToAnsi(NULL,
                              0,
                              pEnumValue->pData,
                              pEnumValue->cbData,
                              NULL);
            }
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}


DWORD
EnumPrinterKeyA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPSTR   pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of pValueName
    LPDWORD pcbSubkey       // address for size of value buffer
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;


    ReturnValue =  EnumPrinterKeyW( hPrinter,
                                    (LPCWSTR) pUnicodeKeyName,
                                    (LPWSTR) pSubkey,
                                    cbSubkey,
                                    pcbSubkey);

    if (ReturnValue == ERROR_SUCCESS && cbSubkey)
    {
        ReturnValue = UnicodeToAnsi(NULL,
                                    0,
                                    pSubkey,
                                    *pcbSubkey,
                                    pcbSubkey);
    }
    else if (ReturnValue == ERROR_MORE_DATA)
    {
        BYTE *pBuf = NULL;

        if (pBuf = LocalAlloc(LPTR, *pcbSubkey))
        {
            if ((ReturnValue = EnumPrinterKeyW(hPrinter,
                                               (LPCWSTR)pUnicodeKeyName,
                                               (LPWSTR)pBuf,
                                               *pcbSubkey,
                                               pcbSubkey)) == ERROR_SUCCESS)
            {
                ReturnValue = UnicodeToAnsi(pBuf,
                                            *pcbSubkey / sizeof(WCHAR),
                                            pSubkey,
                                            cbSubkey,
                                            pcbSubkey);
            }

            LocalFree(pBuf);
        }
        else
        {
            ReturnValue = GetLastError();
        }
    }

Cleanup:
    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}


DWORD
DeletePrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeValueName = NULL;

    pUnicodeValueName = AllocateUnicodeString(pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;


    ReturnValue =  DeletePrinterDataW(hPrinter, (LPWSTR) pUnicodeValueName);

Cleanup:
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
DeletePrinterDataExA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPCSTR  pValueName
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;
    LPWSTR  pUnicodeValueName = NULL;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    pUnicodeValueName = AllocateUnicodeString((LPSTR) pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    ReturnValue =  DeletePrinterDataExW(hPrinter, (LPCWSTR) pUnicodeKeyName, (LPCWSTR) pUnicodeValueName);

Cleanup:
    FreeUnicodeString(pUnicodeKeyName);
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
DeletePrinterKeyA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    ReturnValue =  DeletePrinterKeyW(hPrinter, (LPCWSTR) pUnicodeKeyName);

Cleanup:
    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}


DWORD
SetPrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeValueName = NULL;
    LPWSTR  pUnicodeData = NULL;
    DWORD   cbDataString;
    DWORD   i;

    pUnicodeValueName = AllocateUnicodeString(pValueName);

    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    if (Type == REG_SZ || Type == REG_EXPAND_SZ || Type == REG_MULTI_SZ)
    {
        //
        // No matter if reg_sz or multi_sz, we want to mimic the registry APIs
        // in behavior. This means we will not check strings for null termination.
        // We will set as many bytes as specified by cbData
        //
        pUnicodeData = AllocateUnicodeStringWithSize(pData, cbData);

        if (pUnicodeData)
        {
            cbData *= sizeof(WCHAR);
            ReturnValue = SetPrinterDataW(hPrinter, pUnicodeValueName, Type, (LPBYTE) pUnicodeData, cbData);
            FreeUnicodeString(pUnicodeData);
        }
        else
        {
            ReturnValue = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        ReturnValue = SetPrinterDataW(hPrinter, pUnicodeValueName, Type, pData, cbData);
    }

Cleanup:
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
SetPrinterDataExA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPCSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;
    LPWSTR  pUnicodeValueName = NULL;
    LPWSTR  pUnicodeData = NULL;
    DWORD   cbDataString;
    DWORD   i;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    pUnicodeValueName = AllocateUnicodeString((LPSTR) pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    if (Type == REG_SZ || Type == REG_EXPAND_SZ || Type == REG_MULTI_SZ)
    {
        //
        // No matter if reg_sz or multi_sz, we want to mimic the registry APIs
        // in behavior. This means we will not check strings for null termination.
        // We will set as many bytes as specified by cbData
        //
        pUnicodeData = AllocateUnicodeStringWithSize(pData, cbData);

        if (pUnicodeData)
        {
            cbData *= sizeof(WCHAR);
            ReturnValue = SetPrinterDataExW(hPrinter,
                                            (LPCWSTR) pUnicodeKeyName,
                                            (LPCWSTR) pUnicodeValueName,
                                            Type,
                                            (LPBYTE) pUnicodeData,
                                            cbData);
            FreeUnicodeString(pUnicodeData);
        }
        else
        {
            ReturnValue = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        ReturnValue = SetPrinterDataExW(hPrinter,
                                        (LPCWSTR) pUnicodeKeyName,
                                        (LPCWSTR) pUnicodeValueName,
                                        Type,
                                        pData,
                                        cbData);
    }

Cleanup:
    FreeUnicodeString(pUnicodeValueName);
    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}



/**************************** Function Header *******************************
 * DocumentPropertiesA
 *      The ANSI version of the DocumentProperties function.  Basically
 *      converts the input parameters to UNICODE versions and calls
 *      the DocumentPropertiesW function.
 *
 * CAVEATS:  PRESUMES THAT IF pDevModeOutput IS SUPPLIED,  IT HAS THE SIZE
 *      OF THE UNICODE VERSION.  THIS WILL USUALLY HAPPEN IF THE CALLER
 *      FIRST CALLS TO FIND THE SIZE REQUIRED>
 *
 * RETURNS:
 *      Somesort of LONG.
 *
 ****************************************************************************/

LONG
DocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput,
    DWORD   fMode
)
{
    LPWSTR  pUnicodeDeviceName = NULL;
    LPDEVMODEW pUnicodeDevModeInput = NULL;
    LPDEVMODEW pUnicodeDevModeOutput = NULL;
    LONG    ReturnValue = -1;

    pUnicodeDeviceName = AllocateUnicodeString(pDeviceName);
    if (pDeviceName && !pUnicodeDeviceName)
        goto Cleanup;

    ReturnValue = DocumentPropertiesW(hWnd, hPrinter, pUnicodeDeviceName,
                                      NULL, NULL, 0);

    if (ReturnValue > 0) {

        if (fMode) {

            if (pUnicodeDevModeOutput = LocalAlloc(LMEM_FIXED, ReturnValue)) {

                //
                // Only convert the input buffer if one is specified
                // and fMode indicates it's valid.  WinNT 3.51 used
                // pDevModeInput regardless of DM_IN_BUFFER, but this
                // broke Borland Delphi for win95 + Corel Flow for win95.
                //
                if( pDevModeInput && ( fMode & DM_IN_BUFFER )){

                    //
                    // If the devmode is invalid, then don't pass one in.
                    // This fixes MS Imager32 (which passes dmSize == 0) and
                    // Milestones etc. 4.5.
                    //
                    // Note: this assumes that pDevModeOutput is still the
                    // correct size!
                    //
                    if( !BoolFromHResult(SplIsValidDevmodeNoSizeA(pDevModeInput))){
                    
                        fMode &= ~DM_IN_BUFFER;

                    } else {

                        pUnicodeDevModeInput = AllocateUnicodeDevMode(
                                                   pDevModeInput );

                        if( !pUnicodeDevModeInput ){
                            ReturnValue = -1;
                            goto Cleanup;
                        }
                    }
                }

                ReturnValue = DocumentPropertiesW(hWnd, hPrinter,
                                                  pUnicodeDeviceName,
                                                  pUnicodeDevModeOutput,
                                                  pUnicodeDevModeInput, fMode );

                //
                // The printer driver has filled in the DEVMODEW
                // structure - if one was passed in.  Now convert it
                // back to a DEVMODEA structure.
                //
                if (pDevModeOutput && (ReturnValue == IDOK)) {
                    CopyAnsiDevModeFromUnicodeDevMode(pDevModeOutput,
                                                      pUnicodeDevModeOutput);
                }

            } else

                ReturnValue = -1;

        } else

            ReturnValue-=sizeof(DEVMODEW)-sizeof(DEVMODEA);
    }

Cleanup:

    if (pUnicodeDevModeInput)
        LocalFree(pUnicodeDevModeInput);

    if (pUnicodeDevModeOutput)
        LocalFree(pUnicodeDevModeOutput);

    FreeUnicodeString(pUnicodeDeviceName);

    return ReturnValue;
}

BOOL
WriteCurDevModeToRegistry(
    LPWSTR      pPrinterName,
    LPDEVMODEW  pDevMode
    )
{
    DWORD Status;
    HKEY hDevMode;

    SPLASSERT(pDevMode);

    Status = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szCurDevMode,
                            0,
                            NULL,
                            0,
                            KEY_WRITE,
                            NULL,
                            &hDevMode,
                            NULL);

    if ( Status == ERROR_SUCCESS ) {

        Status = RegSetValueExW(hDevMode,
                                pPrinterName,
                                0,
                                REG_BINARY,
                                (LPBYTE)pDevMode,
                                pDevMode->dmSize + pDevMode->dmDriverExtra);

        RegCloseKey(hDevMode);
    }

    return Status == ERROR_SUCCESS;
}

BOOL
DeleteCurDevModeFromRegistry(
    PWSTR pPrinterName
)
{
    DWORD Status;
    HKEY hDevModeKey;

    Status = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szCurDevMode,
                            0,
                            NULL,
                            0,
                            KEY_WRITE,
                            NULL,
                            &hDevModeKey,
                            NULL);

    if ( Status == ERROR_SUCCESS ) {
        Status = RegDeleteValue(hDevModeKey, pPrinterName);
        RegCloseKey(hDevModeKey);
    }

    return Status == ERROR_SUCCESS;
}

LPDEVMODEW
AllocateCurDevMode(
    HANDLE  hPrinter,
    LPWSTR  pDeviceName,
    LONG cbDevMode
    )
{
    LPDEVMODEW  pRegDevMode  = NULL;
    LPDEVMODEW  pRealDevMode = NULL;
    LPDEVMODEW  pRetDevMode  = NULL;
    BOOL        bUpdateReg   = FALSE;
    HANDLE      hKeyDevMode  = INVALID_HANDLE_VALUE;
    DWORD       dwStatus, dwType;
    LONG        lDocStatus;

    //
    // This code now checks to see that the DEVMODE in the registry matches that of
    // the driver. If it does not, then 1. The driver has been migrated. 2. The user has been
    // using an incompatible driver. In this case, the per user DEVMODE settings are overwritten
    // with those obtained from the driver.
    //

    dwStatus = RegCreateKeyEx( HKEY_CURRENT_USER,
                               szCurDevMode,
                               0,
                               NULL,
                               0,
                               KEY_READ,
                               NULL,
                               &hKeyDevMode,
                               NULL);

    if( dwStatus != ERROR_SUCCESS )
        goto Cleanup;

    pRegDevMode  = (PDEVMODEW)LocalAlloc(LMEM_FIXED, cbDevMode);
    pRealDevMode = (PDEVMODEW)LocalAlloc(LMEM_FIXED, cbDevMode);

    //
    // This cbDevMode is obtained via a call to DocumentPropertiesW, thus it is
    // correct (unless race condition).
    //
    if( pRegDevMode == NULL || pRealDevMode == NULL)
        goto Cleanup;

    lDocStatus = DocumentPropertiesW( NULL,
                                      hPrinter,
                                      pDeviceName,
                                      pRealDevMode,
                                      NULL,
                                      DM_COPY );

    dwStatus = RegQueryValueExW(hKeyDevMode,
                                pDeviceName,
                                0,
                                &dwType,
                                (LPBYTE)pRegDevMode,
                                &cbDevMode);

    bUpdateReg = (dwStatus != ERROR_SUCCESS || dwType != REG_BINARY)
                        && lDocStatus == IDOK;

    if (dwStatus == ERROR_SUCCESS && lDocStatus == IDOK && !bUpdateReg) {

        if (BoolFromHResult(SplIsValidDevmodeNoSizeW(pRegDevMode)))
        {
            //
            // Check to see that our DEVMODE structures are compatible
            //
            bUpdateReg = pRealDevMode->dmSize          != pRegDevMode->dmSize        ||
                         pRealDevMode->dmDriverExtra   != pRegDevMode->dmDriverExtra ||
                         pRealDevMode->dmSpecVersion   != pRegDevMode->dmSpecVersion ||
                         pRealDevMode->dmDriverVersion != pRegDevMode->dmDriverVersion;

            if (!bUpdateReg)
                pRetDevMode = pRegDevMode;
        }
    }

    if (bUpdateReg) {
        //
        // The Registry is out of date, The read from the Document properties must have
        // succeded
        //
        if (!WriteCurDevModeToRegistry(pDeviceName, pRealDevMode) )
            goto Cleanup;
        else
            pRetDevMode = pRealDevMode;
    }

Cleanup:
    if (pRegDevMode != pRetDevMode && pRegDevMode != NULL)
        LocalFree(pRegDevMode);

    if (pRealDevMode != pRetDevMode && pRealDevMode != NULL)
        LocalFree(pRealDevMode);

    if (hKeyDevMode != INVALID_HANDLE_VALUE)
        RegCloseKey( hKeyDevMode );

    return pRetDevMode;
}


VOID
MergeDevMode(
    LPDEVMODEW  pDMOut,
    LPDEVMODEW  pDMIn
    )
{

    //
    //    Simply check each bit in the dmFields entry.  If set, then copy
    //  the input data to the output data.
    //

    if ( pDMIn->dmFields & DM_ORIENTATION ) {

        pDMOut->dmOrientation = pDMIn->dmOrientation;
        pDMOut->dmFields |= DM_ORIENTATION;
    }

    if( (pDMIn->dmFields & (DM_FORMNAME | DM_PAPERSIZE)) ||
        (pDMIn->dmFields & (DM_PAPERLENGTH | DM_PAPERWIDTH)) ==
                              (DM_PAPERLENGTH | DM_PAPERWIDTH) )
    {
        //
        //   Value user fields,  so use them.  And delete ALL ours!
        //
        pDMOut->dmFields &= ~(DM_FORMNAME | DM_PAPERSIZE | DM_PAPERLENGTH | DM_PAPERWIDTH);

        if( pDMIn->dmFields & DM_PAPERSIZE )
        {
            pDMOut->dmPaperSize = pDMIn->dmPaperSize;
            pDMOut->dmFields |= DM_PAPERSIZE;
        }

        if( pDMIn->dmFields & DM_PAPERLENGTH )
        {
            pDMOut->dmPaperLength = pDMIn->dmPaperLength;
            pDMOut->dmFields |= DM_PAPERLENGTH;
        }

        if( pDMIn->dmFields & DM_PAPERWIDTH )
        {
            pDMOut->dmPaperWidth = pDMIn->dmPaperWidth;
            pDMOut->dmFields |= DM_PAPERWIDTH;
        }

        if( pDMIn->dmFields & DM_FORMNAME )
        {
            CopyMemory( pDMOut->dmFormName, pDMIn->dmFormName,
                                          sizeof( pDMOut->dmFormName ) );
            pDMOut->dmFields |= DM_FORMNAME;
        }

    }

    if( pDMIn->dmFields & DM_SCALE ) {

        pDMOut->dmScale = pDMIn->dmScale;
        pDMOut->dmFields |= DM_SCALE;
    }

    if ( pDMIn->dmFields & DM_COPIES ) {

        pDMOut->dmCopies = pDMIn->dmCopies;
        pDMOut->dmFields |= DM_COPIES;
    }

    if ( pDMIn->dmFields & DM_DEFAULTSOURCE ) {

        pDMOut->dmDefaultSource = pDMIn->dmDefaultSource;
        pDMOut->dmFields |= DM_DEFAULTSOURCE;
    }

    if ( pDMIn->dmFields & DM_PRINTQUALITY ) {

        pDMOut->dmPrintQuality = pDMIn->dmPrintQuality;
        pDMOut->dmFields |= DM_PRINTQUALITY;
    }

    if ( pDMIn->dmFields & DM_COLOR ) {

        pDMOut->dmColor = pDMIn->dmColor;
        pDMOut->dmFields |= DM_COLOR;
    }

    if ( pDMIn->dmFields & DM_DUPLEX ) {

        pDMOut->dmDuplex = pDMIn->dmDuplex;
        pDMOut->dmFields |= DM_DUPLEX;
    }

    if ( pDMIn->dmFields & DM_YRESOLUTION ) {

        //
        //  Note that DM_YRESOLUTION implies there is data in dmPrintQuality.
        //  This latter field is used to specify the desired X resolution,
        //  which is only required for dot matrix printers.
        //
        pDMOut->dmYResolution = pDMIn->dmYResolution;
        pDMOut->dmPrintQuality = pDMIn->dmPrintQuality;
        pDMOut->dmFields |= DM_YRESOLUTION;
    }

    if ( pDMIn->dmFields & DM_TTOPTION ) {

        pDMOut->dmTTOption = pDMIn->dmTTOption;
        pDMOut->dmFields |= DM_TTOPTION;
    }

    if ( pDMIn->dmFields & DM_COLLATE ) {

         pDMOut->dmCollate = pDMIn->dmCollate;
         pDMOut->dmFields |= DM_COLLATE;
    }

    if ( pDMIn->dmFields & DM_ICMMETHOD ) {

        pDMOut->dmICMMethod = pDMIn->dmICMMethod;
        pDMOut->dmFields   |= DM_ICMMETHOD;
    }

    if ( pDMIn->dmFields & DM_ICMINTENT ) {

        pDMOut->dmICMIntent = pDMIn->dmICMIntent;
        pDMOut->dmFields   |= DM_ICMINTENT;
    }

    if ( pDMIn->dmFields & DM_MEDIATYPE ) {

        pDMOut->dmMediaType = pDMIn->dmMediaType;
        pDMOut->dmFields   |= DM_MEDIATYPE;
    }

    if ( pDMIn->dmFields & DM_DITHERTYPE ) {

        pDMOut->dmDitherType = pDMIn->dmDitherType;
        pDMOut->dmFields   |= DM_DITHERTYPE;
    }

}


LONG
ExtDeviceMode(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODEA  pDevModeOutput,
    LPSTR       pDeviceName,
    LPSTR       pPort,
    LPDEVMODEA  pDevModeInput,
    LPSTR       pProfile,
    DWORD       fMode
   )
{
    HANDLE  hPrinter = NULL;
    LONG    cbDevMode;
    DWORD   NewfMode;
    LPDEVMODEW pNewDevModeIn = NULL;
    LPDEVMODEW pNewDevModeOut = NULL, pTempDevMode = NULL;
    LONG    ReturnValue = -1;
    PRINTER_DEFAULTSW   PrinterDefaults={NULL, NULL, PRINTER_READ};
    LPWSTR  pUnicodeDeviceName;
    LPWSTR  pUnicodePort;

    pUnicodeDeviceName = AllocateUnicodeString(pDeviceName);
    if (pDeviceName && !pUnicodeDeviceName)
        return ReturnValue;

    pUnicodePort = AllocateUnicodeString(pPort);
    if (pPort && !pUnicodePort) {
        FreeUnicodeString(pUnicodeDeviceName);
        return ReturnValue;
    }

    if (OpenPrinterW(pUnicodeDeviceName, &hPrinter, &PrinterDefaults)) {

        cbDevMode = DocumentPropertiesW(hWnd, hPrinter, pUnicodeDeviceName,
                                        NULL, NULL, 0);

        if (!fMode || cbDevMode <= 0) {
            ClosePrinter(hPrinter);
            FreeUnicodeString(pUnicodeDeviceName);
            FreeUnicodeString(pUnicodePort);
            if (!fMode)
                cbDevMode -= sizeof(DEVMODEW) - sizeof(DEVMODEA);
            return cbDevMode;
        }

        pNewDevModeOut = (PDEVMODEW)LocalAlloc( LMEM_FIXED, cbDevMode );

        if( !pNewDevModeOut ){

            ClosePrinter(hPrinter);
            FreeUnicodeString(pUnicodeDeviceName);
            FreeUnicodeString(pUnicodePort);

            return -1;
        }

        //
        // If our flags specify an input DevMode, and we have
        // an input devmode, use it.
        //
        if(( fMode & DM_IN_BUFFER ) && pDevModeInput ){

            //
            // App may specify one or two fields in dmFields and expect us
            // to merge it with the global 16-bit devmode
            //
            pNewDevModeIn = AllocateCurDevMode(hPrinter,
                                               pUnicodeDeviceName,
                                               cbDevMode);

            pTempDevMode = AllocateUnicodeDevMode(pDevModeInput);

            //
            // correct any bogus field settings for the papersize stuff
            //
            ValidatePaperFields(pUnicodeDeviceName,
                                pUnicodePort,
                                pTempDevMode);

            if ( !pNewDevModeIn || !pTempDevMode ) {

                if ( pNewDevModeIn )
                    LocalFree(pNewDevModeIn);

                if ( pTempDevMode )
                    LocalFree(pTempDevMode);

                ClosePrinter(hPrinter);
                FreeUnicodeString(pUnicodeDeviceName);
                FreeUnicodeString(pUnicodePort);
                return -1;
            }

            //
            // Some apps will just set the public fields they want to be changed
            // from global devmode, so we need to merge input devmode with global
            // devmode
            //
            MergeDevMode(pNewDevModeIn, pTempDevMode);

            //
            // Copy input devmode's private section if present else send the
            // the private section from global devmode
            //
            if ( pTempDevMode->dmDriverExtra &&
                 pTempDevMode->dmDriverExtra == pNewDevModeIn->dmDriverExtra ) {

                    CopyMemory((LPBYTE)pNewDevModeIn + pNewDevModeIn->dmSize,
                               (LPBYTE)pTempDevMode + pTempDevMode->dmSize,
                               pTempDevMode->dmDriverExtra);
            }

            LocalFree(pTempDevMode);
            pTempDevMode = NULL;
        } else {

            //
            // Get the win16 global devmode.
            //
            pNewDevModeIn = AllocateCurDevMode( hPrinter,
                                                pUnicodeDeviceName,
                                                cbDevMode );

            if (!pNewDevModeIn) {
                ClosePrinter(hPrinter);
                FreeUnicodeString(pUnicodeDeviceName);
                FreeUnicodeString(pUnicodePort);
                return -1;
            }
            fMode |= DM_IN_BUFFER;
        }

        NewfMode = fMode;

        //
        // If DM_UPDATE is set, turn on DM_COPY so that we can update
        // the win16 devmode.
        //
        if (fMode & DM_UPDATE)
            NewfMode |= DM_COPY;

        ReturnValue = DocumentPropertiesW(hWnd,
                                          hPrinter,
                                          pUnicodeDeviceName,
                                          pNewDevModeOut,
                                          pNewDevModeIn,
                                          NewfMode);

        if ( ReturnValue == IDOK &&
             (fMode & DM_UPDATE) ) {

            if ( WriteCurDevModeToRegistry(pUnicodeDeviceName,
                                           pNewDevModeOut) ) {


                SendNotifyMessageW(HWND_BROADCAST,
                                   WM_DEVMODECHANGE,
                                   0,
                                   (LPARAM)pUnicodeDeviceName);
            } else {

                ReturnValue = -1;
            }
        }

        if (pNewDevModeIn)
            LocalFree(pNewDevModeIn);

        if ((ReturnValue == IDOK) && (fMode & DM_COPY) && pDevModeOutput)
            CopyAnsiDevModeFromUnicodeDevMode(pDevModeOutput, pNewDevModeOut);

        if (pNewDevModeOut)
            LocalFree(pNewDevModeOut);

        ClosePrinter(hPrinter);
    }

    FreeUnicodeString(pUnicodeDeviceName);
    FreeUnicodeString(pUnicodePort);

    return ReturnValue;
}

void
DeviceMode(
    HWND    hWnd,
    HANDLE  hModule,
    LPSTR   pDevice,
    LPSTR   pPort
)
{
    HANDLE  hPrinter, hDevMode;
    DWORD   cbDevMode;
    LPDEVMODEW   pNewDevMode, pDevMode=NULL;
    PRINTER_DEFAULTSW PrinterDefaults={NULL, NULL, PRINTER_READ};
    DWORD   Status, Type, cb;
    LPWSTR  pUnicodeDevice;

    pUnicodeDevice = AllocateUnicodeString(pDevice);
    if (pDevice && !pUnicodeDevice)
        return;

    if (OpenPrinterW(pUnicodeDevice, &hPrinter, &PrinterDefaults)) {

        Status = RegCreateKeyExW(HKEY_CURRENT_USER, szCurDevMode,
                                 0, NULL, 0, KEY_WRITE | KEY_READ,
                                 NULL, &hDevMode, NULL);

        if (Status == ERROR_SUCCESS) {

            Status = RegQueryValueExW(hDevMode, pUnicodeDevice, 0, &Type,
                                      NULL, &cb);

            if (Status == ERROR_SUCCESS) {

                pDevMode = LocalAlloc(LMEM_FIXED, cb);

                if (pDevMode) {

                    Status = RegQueryValueExW(hDevMode, pUnicodeDevice, 0,
                                              &Type, (LPBYTE)pDevMode, &cb);

                    if (Status != ERROR_SUCCESS || BoolFromHResult(SplIsValidDevmodeNoSizeW(pDevMode))) {
                        LocalFree(pDevMode);
                        pDevMode = NULL;
                    }

                } else {
                    goto Cleanup;
                }
            }

            cbDevMode = DocumentPropertiesW(hWnd, hPrinter,
                                           pUnicodeDevice, NULL,
                                           pDevMode, 0);
            if (cbDevMode > 0) {

                if (pNewDevMode = (PDEVMODEW)LocalAlloc(LMEM_FIXED,
                                                      cbDevMode)) {

                    if (DocumentPropertiesW(hWnd,
                                            hPrinter, pUnicodeDevice,
                                            pNewDevMode,
                                            pDevMode,
                                            DM_COPY | DM_PROMPT | DM_MODIFY)
                                                        == IDOK) {

                        Status = RegSetValueExW(hDevMode,
                                               pUnicodeDevice, 0,
                                               REG_BINARY,
                                               (LPBYTE)pNewDevMode,
                                               pNewDevMode->dmSize +
                                               pNewDevMode->dmDriverExtra);

                        //
                        // Everything succeeded if Status == ERROR_SUCCESS.
                        //
                    }
                    LocalFree(pNewDevMode);
                }
            }

            if (pDevMode)
                LocalFree(pDevMode);

            RegCloseKey(hDevMode);
        }

        ClosePrinter(hPrinter);
    }

Cleanup:
    FreeUnicodeString(pUnicodeDevice);

    return;
}

LONG
AdvancedDocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput
)
{
    LONG    ReturnValue = FALSE;
    LPWSTR  pUnicodeDeviceName = NULL;
    LPDEVMODEW pUnicodeDevModeInput = NULL;
    LPDEVMODEW pUnicodeDevModeOutput = NULL;

    LONG cbOutput = 0;

    pUnicodeDeviceName = AllocateUnicodeString(pDeviceName);
    if (pDeviceName && !pUnicodeDeviceName)
        goto Cleanup;

    if( BoolFromHResult(SplIsValidDevmodeNoSizeA(pDevModeInput))){
        pUnicodeDevModeInput = AllocateUnicodeDevMode(pDevModeInput);
        if( !pUnicodeDevModeInput ){
            goto Cleanup;
        }

        //
        // The output DevMode must be at least as big as the input
        // DevMode.
        //
        cbOutput = pDevModeInput->dmSize +
                   pDevModeInput->dmDriverExtra +
                   sizeof(DEVMODEW) - sizeof(DEVMODEA);
    }

    if( pDevModeOutput ){

        if( !cbOutput ){

            //
            // We don't know the output size of the devmode, so make
            // call DocumentPropertiesW to find out.
            //
            cbOutput = DocumentPropertiesW( hWnd,
                                            hPrinter,
                                            pUnicodeDeviceName,
                                            NULL,
                                            NULL,
                                            0 );
            if( cbOutput <= 0 ){
                goto Cleanup;
            }
        }

        pUnicodeDevModeOutput = (PDEVMODEW)LocalAlloc( LPTR, cbOutput );
        if( !pUnicodeDevModeOutput ){
            goto Cleanup;
        }
    }

    ReturnValue = AdvancedDocumentPropertiesW(hWnd, hPrinter,
                                              pUnicodeDeviceName,
                                              pUnicodeDevModeOutput,
                                              pUnicodeDevModeInput );

    if( pDevModeOutput && (ReturnValue > 0) ){
        CopyAnsiDevModeFromUnicodeDevMode(pDevModeOutput,
                                          pUnicodeDevModeOutput);
    }

    if ( !pDevModeOutput && ReturnValue > 0 )
        ReturnValue -= sizeof(DEVMODEW) - sizeof(DEVMODEA);

Cleanup:
    if (pUnicodeDevModeOutput)
        LocalFree(pUnicodeDevModeOutput);

    if (pUnicodeDevModeInput)
        LocalFree(pUnicodeDevModeInput);

    FreeUnicodeString(pUnicodeDeviceName);

    return ReturnValue;
}

LONG
AdvancedSetupDialog(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODEA  pDevModeInput,
    LPDEVMODEA  pDevModeOutput
)
{
    HANDLE  hPrinter;
    LONG    ReturnValue = -1;

    if (OpenPrinterA(pDevModeInput->dmDeviceName, &hPrinter, NULL)) {
        ReturnValue = AdvancedDocumentPropertiesA(hWnd, hPrinter,
                                                 pDevModeInput->dmDeviceName,
                                                 pDevModeOutput,
                                                 pDevModeInput);
        ClosePrinter(hPrinter);
    }

    return ReturnValue;
}

BOOL
AddFormA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    LPBYTE pUnicodeForm;

    pUnicodeForm = AllocateUnicodeStructure(pForm, sizeof(FORM_INFO_1A), FormInfo1Strings);
    if (pForm && !pUnicodeForm)
        return FALSE;

    ReturnValue = AddFormW(hPrinter, Level, pUnicodeForm);

    FreeUnicodeStructure(pUnicodeForm, FormInfo1Offsets);

    return ReturnValue;
}

BOOL
DeleteFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName
)
{
    BOOL  ReturnValue;
    LPWSTR  pUnicodeFormName;

    pUnicodeFormName = AllocateUnicodeString(pFormName);
    if (pFormName && !pUnicodeFormName)
        return FALSE;

    ReturnValue = DeleteFormW(hPrinter, pUnicodeFormName);

    FreeUnicodeString(pUnicodeFormName);

    return ReturnValue;
}

BOOL
GetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeFormName;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Strings;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeFormName = AllocateUnicodeString(pFormName);
    if (pFormName && !pUnicodeFormName)
        return FALSE;

    ReturnValue = GetFormW(hPrinter, pUnicodeFormName, Level, pForm,
                           cbBuf, pcbNeeded);

    if (ReturnValue && pForm)

        ConvertUnicodeToAnsiStrings(pForm, pOffsets);

    FreeUnicodeString(pUnicodeFormName);

    return ReturnValue;
}

BOOL
SetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue = FALSE;
    LPWSTR  pUnicodeFormName = NULL;
    LPBYTE  pUnicodeForm = NULL;

    pUnicodeFormName = AllocateUnicodeString(pFormName);
    if (pFormName && !pUnicodeFormName)
        goto Cleanup;

    pUnicodeForm = AllocateUnicodeStructure(pForm, sizeof(FORM_INFO_1A), FormInfo1Strings);
    if (pForm && !pUnicodeForm)
        goto Cleanup;

    ReturnValue = SetFormW(hPrinter, pUnicodeFormName, Level, pUnicodeForm);

Cleanup:

    FreeUnicodeString(pUnicodeFormName);

    FreeUnicodeStructure(pUnicodeForm, FormInfo1Offsets);

    return ReturnValue;
}

BOOL
EnumFormsA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Strings;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    ReturnValue = EnumFormsW(hPrinter, Level, pForm, cbBuf,
                             pcbNeeded, pcReturned);

    if (ReturnValue && pForm) {

        DWORD   i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pForm, pOffsets);

            pForm+=cbStruct;
        }

    }

    return ReturnValue;
}

BOOL
EnumPortsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;

    switch (Level) {

    case 1:
        pOffsets = PortInfo1Strings;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pOffsets = PortInfo2Strings;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    ReturnValue = EnumPortsW(pUnicodeName, Level, pPort, cbBuf,
                             pcbNeeded, pcReturned);

    if (ReturnValue && pPort) {

        DWORD   i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pPort, pOffsets);

            pPort+=cbStruct;
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
EnumMonitorsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitor,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;

    switch (Level) {

    case 1:
        pOffsets = MonitorInfo1Strings;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pOffsets = MonitorInfo2Strings;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    ReturnValue = EnumMonitorsW(pUnicodeName, Level, pMonitor, cbBuf,
                                          pcbNeeded, pcReturned);

    if (ReturnValue && pMonitor) {

        DWORD   i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pMonitor, pOffsets);

            pMonitor+=cbStruct;
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
AddPortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pMonitorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeMonitorName = NULL;
    DWORD   ReturnValue = FALSE;


    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeMonitorName = AllocateUnicodeString(pMonitorName);
    if (pMonitorName && !pUnicodeMonitorName)
        goto Cleanup;

    ReturnValue = AddPortW( pUnicodeName, hWnd, pUnicodeMonitorName );

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeMonitorName);

    return ReturnValue;
}

BOOL
ConfigurePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodePortName = NULL;
    DWORD   ReturnValue = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodePortName = AllocateUnicodeString(pPortName);
    if (pPortName && !pUnicodePortName)
        goto Cleanup;

    ReturnValue = ConfigurePortW( pUnicodeName, hWnd, pUnicodePortName );

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodePortName);

    return ReturnValue;
}

BOOL
DeletePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodePortName = NULL;
    DWORD   ReturnValue = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodePortName = AllocateUnicodeString(pPortName);
    if (pPortName && !pUnicodePortName)
        goto Cleanup;

    ReturnValue = DeletePortW( pUnicodeName, hWnd, pUnicodePortName );

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodePortName);

    return ReturnValue;
}

DWORD
PrinterMessageBoxA(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPSTR   pText,
    LPSTR   pCaption,
    DWORD   dwType
)
{
    DWORD   ReturnValue=FALSE;
    LPWSTR  pTextW = NULL;
    LPWSTR  pCaptionW = NULL;

    pTextW = AllocateUnicodeString(pText);
    if (pText && !pTextW)
        goto Cleanup;

    pCaptionW = AllocateUnicodeString(pCaption);
    if (pCaption && !pCaptionW)
        goto Cleanup;

    ReturnValue = PrinterMessageBoxW(hPrinter, Error, hWnd, pTextW,
                                     pCaptionW, dwType);

Cleanup:
    FreeUnicodeString(pTextW);
    FreeUnicodeString(pCaptionW);

    return ReturnValue;
}

int
DeviceCapabilitiesA(
    LPCSTR  pDevice,
    LPCSTR  pPort,
    WORD    fwCapability,
    LPSTR   pOutput,
    CONST DEVMODEA *pDevMode
)
{
    LPWSTR  pDeviceW = NULL;
    LPWSTR  pPortW = NULL;
    LPWSTR  pOutputW = NULL;
    LPWSTR  pKeepW = NULL;
    LPDEVMODEW  pDevModeW = NULL;
    DWORD   c, Size;
    int cb = 0;
    int rc = GDI_ERROR;

    pDeviceW = AllocateUnicodeString((LPSTR)pDevice);
    if (pDevice && !pDeviceW)
        goto Cleanup;

    pPortW = AllocateUnicodeString((LPSTR)pPort);
    if (pPort && !pPortW)
        goto Cleanup;

    if( BoolFromHResult(SplIsValidDevmodeNoSizeA((LPDEVMODEA)pDevMode))){
        pDevModeW = AllocateUnicodeDevMode((LPDEVMODEA)pDevMode);
        if( !pDevModeW ){
            goto Cleanup;
        }
    }

    switch (fwCapability) {
    //
    // These will require Unicode to Ansi conversion
    //
    case DC_BINNAMES:
    case DC_FILEDEPENDENCIES:
    case DC_PAPERNAMES:
    case DC_PERSONALITY:
    case DC_MEDIAREADY:
    case DC_MEDIATYPENAMES:

        if (pOutput) {

            cb = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability,
                                     NULL, pDevModeW);
            if (cb >= 0) {

                switch (fwCapability) {

                case DC_BINNAMES:
                    cb *= 48;
                    break;

                case DC_PERSONALITY:
                    cb *= 64;
                    break;

                case DC_FILEDEPENDENCIES:
                case DC_PAPERNAMES:
                case DC_MEDIAREADY:
                case DC_MEDIATYPENAMES:
                    cb *= 128;
                    break;

                }

                pOutputW = pKeepW = LocalAlloc(LPTR, cb);

                if (pKeepW) {

                    c = rc = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability,
                                                 pOutputW, pDevModeW);

                    switch (fwCapability) {

                    case DC_BINNAMES:
                        Size = 24;
                        break;

                    case DC_PERSONALITY:
                        Size = 32;
                        break;

                    case DC_FILEDEPENDENCIES:
                    case DC_PAPERNAMES:
                    case DC_MEDIAREADY:
                    case DC_MEDIATYPENAMES:
                        Size = 64;
                        break;
                    }

                    for (; c; c--) {

                        UnicodeToAnsiString(pOutputW, pOutput, NULL_TERMINATED);

                        pOutputW += Size;
                        pOutput += Size;
                    }

                    LocalFree(pKeepW);
                }
            }

        } else {

            rc = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability,
                                     NULL, pDevModeW);

        }

        break;

    default:
        rc = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability, (LPWSTR)pOutput, pDevModeW);

        //
        // If the call to find size of public portion of devmode and
        // it was succesful adjust the size for UNICODE->ANSI conversion
        //
        if ( fwCapability == DC_SIZE && rc > 0 ) {

            rc -= sizeof(DEVMODEW) - sizeof(DEVMODEA);
        }
    }


Cleanup:

    FreeUnicodeString(pDeviceW);
    FreeUnicodeString(pPortW);
    if (pDevModeW)
        LocalFree(pDevModeW);

    return  rc;
}

BOOL
AddMonitorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    LPWSTR  pUnicodeName = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDWORD pOffsets;

    switch (Level) {

    case 2:
        pOffsets = MonitorInfo2Strings;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pMonitorInfo, cbStruct, pOffsets);
    if (pMonitorInfo && !pUnicodeStructure)
        goto Cleanup;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    if (pUnicodeStructure) {

        ReturnValue = AddMonitorW(pUnicodeName, Level, pUnicodeStructure);
    }

Cleanup:

    FreeUnicodeStructure(pUnicodeStructure, pOffsets);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
DeleteMonitorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pMonitorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeMonitorName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodeMonitorName = AllocateUnicodeString(pMonitorName);
    if (pMonitorName && !pUnicodeMonitorName)
        goto Cleanup;

    rc = DeleteMonitorW(pUnicodeName,
                        pUnicodeEnvironment,
                        pUnicodeMonitorName);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeMonitorName);

    return rc;
}

BOOL
DeletePrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProcessorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodePrintProcessorName = NULL;
    BOOL    rc = FALSE;

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodePrintProcessorName = AllocateUnicodeString(pPrintProcessorName);
    if (pPrintProcessorName && !pUnicodePrintProcessorName)
        goto Cleanup;

    rc = DeletePrintProcessorW(pUnicodeName,
                               pUnicodeEnvironment,
                               pUnicodePrintProcessorName);


Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodePrintProcessorName);

    return rc;
}

BOOL
AddPrintProvidorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pProvidorInfo
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    LPWSTR  pUnicodeName = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDWORD pOffsets;

    if (!pProvidorInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pOffsets = ProvidorInfo1Strings;
        cbStruct = sizeof(PROVIDOR_INFO_1);
        break;

    case 2:
        pOffsets = ProvidorInfo2Strings;
        cbStruct = sizeof(PROVIDOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pProvidorInfo, cbStruct, pOffsets);
    if (!pProvidorInfo || !pUnicodeStructure)
        goto CleanUp;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto CleanUp;

    if ((Level == 2) &&
        !AnsiToUnicodeMultiSz((LPSTR) ((PPROVIDOR_INFO_2A) pProvidorInfo)->pOrder,
                              &(((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder))) {

        goto CleanUp;
    }

    if (pUnicodeStructure) {

        ReturnValue = AddPrintProvidorW(pUnicodeName, Level,
                                        pUnicodeStructure);
    }

    if ((Level == 2) &&
        ((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder) {

        LocalFree(((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder);
        ((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder = NULL;
    }

CleanUp:

    FreeUnicodeStructure(pUnicodeStructure, pOffsets);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
DeletePrintProvidorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProvidorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodePrintProvidorName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodePrintProvidorName = AllocateUnicodeString(pPrintProvidorName);
    if (pPrintProvidorName && !pUnicodePrintProvidorName)
        goto Cleanup;

    rc = DeletePrintProvidorW(pUnicodeName,
                              pUnicodeEnvironment,
                              pUnicodePrintProvidorName);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodePrintProvidorName);

    return rc;
}


BOOL
AddPortExA(
    IN LPSTR  pName, OPTIONAL
    IN DWORD  Level,
    IN LPBYTE pBuffer,
    IN LPSTR  pMonitorName
    )
{
    PPORT_INFO_1A pPortInfo1;
    PPORT_INFO_FFA pPortInfoFF;

    LPWSTR pNameW = NULL;
    LPWSTR pMonitorNameW = NULL;
    LPWSTR pPortNameW = NULL;

    PORT_INFO_1W PortInfo1;
    PORT_INFO_FFW PortInfoFF;

    DWORD LastError = ERROR_SUCCESS;
    BOOL bReturnValue = FALSE;

    //
    // Initialize variables that will be freed in error cases.
    //
    pNameW = AllocateUnicodeString( pName);
    if (pName && !pNameW) {
        LastError = GetLastError();
        goto Done;
    }

    pPortNameW = NULL;

    pMonitorNameW = AllocateUnicodeString( pMonitorName);
    if (pMonitorName && !pMonitorNameW) {
        LastError = GetLastError();
        goto Done;
    }

    if( !pBuffer || !pMonitorName ){
        LastError = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    // Catch out of memory conditions.
    //
    if( !pMonitorNameW || ( pName && !pNameW )){
        LastError = GetLastError();
        goto Done;
    }

    switch( Level ){
    case (DWORD)-1:

        pPortInfoFF = (PPORT_INFO_FFA)pBuffer;

        if( !pPortInfoFF->pName || !pPortInfoFF->pName[0] ){
            LastError = ERROR_INVALID_PARAMETER;
            goto Done;
        }

        pPortNameW = PortInfoFF.pName = AllocateUnicodeString( pPortInfoFF->pName);

        if( !pPortNameW ){
            LastError = GetLastError();
            goto Done;
        }

        PortInfoFF.cbMonitorData = pPortInfoFF->cbMonitorData;
        PortInfoFF.pMonitorData = pPortInfoFF->pMonitorData;

        bReturnValue = AddPortExW( pNameW,
                                   Level,
                                   (LPBYTE)&PortInfoFF,
                                   pMonitorNameW );

        if( !bReturnValue ){
            LastError = GetLastError();
        }
        break;

    case 1:

        pPortInfo1 = (PPORT_INFO_1A)pBuffer;

        if( !pPortInfo1->pName || !pPortInfo1->pName[0] ){
            LastError = ERROR_INVALID_PARAMETER;
            goto Done;
        }

        pPortNameW = PortInfo1.pName = AllocateUnicodeString( pPortInfo1->pName);

        if( !pPortNameW ){
            LastError = GetLastError();
            goto Done;
        }

        bReturnValue = AddPortExW( pNameW,
                                   Level,
                                   (LPBYTE)&PortInfo1,
                                   pMonitorNameW );

        if( !bReturnValue ){
            LastError = GetLastError();
        }
        break;

    default:
        LastError = ERROR_INVALID_LEVEL;
        break;
    }

Done:

    FreeUnicodeString( pNameW );
    FreeUnicodeString( pPortNameW );
    FreeUnicodeString( pMonitorNameW );

    if( !bReturnValue ){

        SetLastError( LastError );
        return FALSE;
    }
    return TRUE;
}



LPSTR
StartDocDlgA(
    HANDLE hPrinter,
    DOCINFOA *pDocInfo
    )
{
    DOCINFOW DocInfoW;
    LPSTR lpszAnsiOutput = NULL;
    LPSTR lpszAnsiString = NULL;
    LPWSTR lpszUnicodeString = NULL;
    DWORD  dwLen = 0;

    if (!pDocInfo) {
        DBGMSG(DBG_WARNING, ("StartDocDlgA: Null pDocInfo passed in\n"));
        return NULL;
    }
    memset(&DocInfoW, 0, sizeof(DOCINFOW));
    if (pDocInfo->lpszDocName) {
        DocInfoW.lpszDocName = (LPCWSTR)AllocateUnicodeString ((LPSTR)pDocInfo->lpszDocName);
        if (pDocInfo->lpszDocName && !DocInfoW.lpszDocName)
            return NULL;
    }
    if (pDocInfo->lpszOutput) {
        DocInfoW.lpszOutput = (LPCWSTR)AllocateUnicodeString((LPSTR)pDocInfo->lpszOutput);
        if (pDocInfo->lpszOutput && !DocInfoW.lpszOutput) {
            FreeUnicodeString((LPWSTR) DocInfoW.lpszDocName);
            return NULL;
        }
    }

    lpszUnicodeString = StartDocDlgW(hPrinter, &DocInfoW);

    if (lpszUnicodeString == (LPWSTR)-1) {
        lpszAnsiString = (LPSTR)-1;
    } else if (lpszUnicodeString == (LPWSTR)-2) {
         lpszAnsiString = (LPSTR)-2;
    } else if (lpszUnicodeString){
        dwLen = wcslen(lpszUnicodeString);
        if (lpszAnsiString = LocalAlloc(LPTR, dwLen+1)){
            UnicodeToAnsiString(lpszUnicodeString, lpszAnsiString, dwLen);
            LocalFree(lpszUnicodeString);
        } else {
            DBGMSG(DBG_WARNING, ("StartDocDlgA: LocalAlloc failed returning NULL\n"));
        }
    }

    if (DocInfoW.lpszDocName ) {
        FreeUnicodeString((LPWSTR)DocInfoW.lpszDocName);
    }

    if (DocInfoW.lpszOutput) {

        //
        // we might have changed the DocInfoW.lpszOutput as well
        // for pooled printing; so reconstruct pDocInfo->lpszOutput
        //
        dwLen = wcslen(DocInfoW.lpszOutput);
        UnicodeToAnsiString((LPWSTR)DocInfoW.lpszOutput, (LPSTR)pDocInfo->lpszOutput, dwLen);

        FreeUnicodeString((LPWSTR)DocInfoW.lpszOutput);
    }

    return lpszAnsiString;
}


BOOL
SetPortA(
    LPSTR       pszName,
    LPSTR       pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPorts
    )
{
    LPBYTE      pUnicodeStructure = NULL;
    DWORD       cbStruct;
    PDWORD      pOffsets = NULL;
    LPWSTR      pszUnicodeName = NULL;
    LPWSTR      pszUnicodePortName = NULL;
    BOOL        bRet = FALSE;


    switch (dwLevel) {

        case 3:
            pOffsets = PortInfo3Offsets;
            cbStruct = sizeof(PORT_INFO_3);
            break;

        default:
            SetLastError( ERROR_INVALID_LEVEL );
            return FALSE;
    }

    pszUnicodeName = AllocateUnicodeString(pszName);
    if (pszName && !pszUnicodeName)
        goto Cleanup;

    pszUnicodePortName  = AllocateUnicodeString(pszPortName);
    if (pszPortName && !pszUnicodePortName)
        goto Cleanup;

    pUnicodeStructure = AllocateUnicodeStructure(pPorts, cbStruct, pOffsets);
    if (pPorts && !pUnicodeStructure)
        goto Cleanup;

    bRet = SetPortW(pszUnicodeName, pszUnicodePortName, dwLevel, pUnicodeStructure);

Cleanup:

    FreeUnicodeStructure(pUnicodeStructure, pOffsets);
    FreeUnicodeString(pszUnicodePortName);
    FreeUnicodeString(pszUnicodeName);

    return bRet;
}

/*++

Routine Name:

    IsValidDevmodeA

Description:

    Check to see whether the devmode passed is valid.

Arguments:

    pDevmode    - The devmode
    DevmodeSize - The size of the buffer.

Return Value:

    TRUE if succeeded. 

--*/
BOOL
IsValidDevmodeA(
    IN  PDEVMODEA   pDevmode,
    IN  size_t      DevmodeSize
    )
{
    return BoolFromHResult(SplIsValidDevmodeA(pDevmode, DevmodeSize));
}

/********************************************************************

    Ansi version entry points for the default printer api set.

********************************************************************/
BOOL
GetDefaultPrinterA(
    IN LPSTR    pszBuffer,
    IN LPDWORD  pcchBuffer
    )
{
    BOOL    bRetval             = TRUE;
    LPWSTR  pszUnicodeBuffer    = NULL;
    LPDWORD pcchUnicodeBuffer   = pcchBuffer;

    if( pszBuffer && pcchBuffer && *pcchBuffer )
    {
        pszUnicodeBuffer = LocalAlloc( LMEM_FIXED, *pcchBuffer * sizeof( WCHAR ) );

        bRetval = pszUnicodeBuffer ? TRUE : FALSE;
    }

    if( bRetval )
    {
        bRetval = GetDefaultPrinterW( pszUnicodeBuffer, pcchUnicodeBuffer );

        if( bRetval && pszUnicodeBuffer )
        {
            bRetval = UnicodeToAnsiString( pszUnicodeBuffer, pszBuffer, 0 ) > 0;
        }
    }

    if( pszUnicodeBuffer )
    {
        LocalFree( pszUnicodeBuffer );
    }

    return bRetval;
}

BOOL
SetDefaultPrinterA(
    IN LPCSTR pszPrinter
    )
{
    BOOL    bRetval     = TRUE;
    LPWSTR  pszUnicode  = NULL;

    if( pszPrinter )
    {
        pszUnicode = AllocateUnicodeString( (PSTR) pszPrinter );

        bRetval = pszUnicode ? TRUE : FALSE;
    }

    if( bRetval )
    {
        bRetval = SetDefaultPrinterW( pszUnicode );
    }

    if( pszUnicode )
    {
        FreeUnicodeString( pszUnicode );
    }

    return bRetval;
}


BOOL
PublishPrinterA(
    HWND   hwnd,
    PCSTR  pszUNCName,
    PCSTR  pszDN,
    PCSTR  pszCN,
    PSTR   *ppszDN,
    DWORD  dwAction
)
{
    PWSTR       pszUnicodeUNCName = NULL;
    PWSTR       pszUnicodeDN = NULL;
    PWSTR       pszUnicodeCN = NULL;
    BOOL        bRet = FALSE;

    pszUnicodeUNCName = AllocateUnicodeString((PSTR) pszUNCName);
    if (pszUNCName && !pszUnicodeUNCName)
        goto error;

    pszUnicodeDN = AllocateUnicodeString((PSTR) pszDN);
    if (pszDN && !pszUnicodeDN)
        goto error;

    pszUnicodeCN = AllocateUnicodeString((PSTR) pszCN);
    if (pszCN && !pszUnicodeCN)
        goto error;

    bRet = PublishPrinterW( hwnd,
                            pszUnicodeUNCName,
                            pszUnicodeDN,
                            pszUnicodeCN,
                            (PWSTR *) ppszDN,
                            dwAction);

    if (ppszDN && *ppszDN) {
        if (!UnicodeToAnsiString((PWSTR) *ppszDN, *ppszDN, NULL_TERMINATED))
            bRet = FALSE;
    }


error:

    FreeUnicodeString(pszUnicodeUNCName);
    FreeUnicodeString(pszUnicodeDN);
    FreeUnicodeString(pszUnicodeCN);

    return bRet;
}



VOID
ValidatePaperFields(
    LPCWSTR    pUnicodeDeviceName,
    LPCWSTR    pUnicodePort,
    LPDEVMODEW pDevModeIn
)
{
    POINTS ptMinSize, ptMaxSize;


    if(!pUnicodeDeviceName    ||
       !pUnicodeDeviceName[0] ||
       !pUnicodePort          ||
       !pUnicodePort[0]       ||
       !pDevModeIn)                 {
            return;
    }

    //
    // this logic was swiped from the MergeDevMode() code for the Win3.1 UNIDRV
    //
    // According to UNIDRV, dmPaperSize must be set to DMPAPER_USER if custom
    // paper sizes are going to be taken seriously.
    //
    if((pDevModeIn->dmPaperSize == DMPAPER_USER)   &&
       (pDevModeIn->dmFields    &  DM_PAPERWIDTH)  &&
       (pDevModeIn->dmFields    &  DM_PAPERLENGTH)) {

        pDevModeIn->dmFields |= (DM_PAPERLENGTH | DM_PAPERLENGTH);

        //
        // Get the minimum size this printer supports
        //
        if(DeviceCapabilitiesW(pUnicodeDeviceName,
                               pUnicodePort,
                               DC_MINEXTENT,
                               (PWSTR) &ptMinSize,
                               NULL) == -1) {
            //
            // No changes.
            //            
            return;  
        }

        if(DeviceCapabilitiesW(pUnicodeDeviceName,
                               pUnicodePort,
                               DC_MAXEXTENT,
                               (PWSTR) &ptMaxSize,
                               NULL) == -1) {
            //
            // No changes.
            //
            return;  
        }

        //
        // Force the custom paper size to fit the machine's capabilities
        //
        if(pDevModeIn->dmPaperWidth < ptMinSize.x)
            pDevModeIn->dmPaperWidth = ptMinSize.x;
        else if(pDevModeIn->dmPaperWidth > ptMaxSize.x)
            pDevModeIn->dmPaperWidth = ptMaxSize.x;

        if(pDevModeIn->dmPaperLength < ptMinSize.y)
            pDevModeIn->dmPaperLength = ptMinSize.y;
        else if(pDevModeIn->dmPaperLength > ptMaxSize.y)
            pDevModeIn->dmPaperLength = ptMaxSize.y;

    }
    //
    // Else if they don't have it right, turn these guys off so they don't
    // get merged into the default devmode later.
    //
    else {
        pDevModeIn->dmFields &= ~(DM_PAPERLENGTH | DM_PAPERWIDTH);
        pDevModeIn->dmPaperWidth  = 0;
        pDevModeIn->dmPaperLength = 0;
    }
}

DWORD
UnicodeToAnsi(
    IN     LPBYTE  pUnicode,
    IN     DWORD   cchUnicode,
    IN OUT LPBYTE  pData,
    IN     DWORD   cbData,
    IN OUT DWORD  *pcbCopied OPTIONAL
    )
/*++

Routine Name:

    UnicodeToAnsi

Routine Description:

    Converts the content of a buffer from unicode to ansi. There is no assumption about
    NULL terminator. If pUnicode is not NULL, then it must be WCHAR aligned and cchUnicode
    indicates the number of WCHARs in the buffer that will be converted to ansi. If pUnicode
    is NULL, then the function converts in place the contents of pData from Unicode to Ansi.

Arguments:

    pUnicode   - buffer aligned to WCHAR that contains a unicode string
    cchUnicode - number of WCHARs in pUnicode buffer
    pData      - buffer that will hold the converted string
    cbData     - sizeo in bytes of the buffer pDa
    pcbCopied  - number of bytes copied to pData or needed to accomodate the converted string

Return Value:

    None.

--*/
{
    DWORD cReturn  = cbData;
    DWORD cbCopied = 0;
    DWORD Error    = ERROR_INVALID_PARAMETER;

    //
    // If the size of both input buffer is 0, then we do not do anything and return success.
    // Otherwise, the caller must give us either valid pData or a valid pUnicode that is
    // WCHAR aligned
    //
    if (!cbData && !cchUnicode)
    {
        Error = ERROR_SUCCESS;
    }
    else if (pData || pUnicode && !((ULONG_PTR)pUnicode % sizeof(WCHAR)))
    {
        LPWSTR pAligned = (LPWSTR)pUnicode;

        Error = ERROR_SUCCESS;

        if (!pAligned)
        {
            //
            // We convert contents of pData from unicode to ansi
            //
            if (pAligned = LocalAlloc(LPTR, cbData))
            {
                memcpy(pAligned, pData, cbData);

                cchUnicode = cbData / sizeof(WCHAR);
            }
            else
            {
                Error = GetLastError();
            }
        }

        //
        // Convert data to ansi or find out how many bytes are
        // necessary to accomodate the string
        //
        if (Error == ERROR_SUCCESS)
        {
            cbCopied = WideCharToMultiByte(CP_THREAD_ACP,
                                           0,
                                           pAligned,
                                           cchUnicode,
                                           pData,
                                           cbData,
                                           NULL,
                                           NULL);

            //
            // WideCharToMultiByte tells us how many bytes we need
            //
            if (!cbCopied)
            {
                Error = ERROR_MORE_DATA;

                cbCopied = WideCharToMultiByte(CP_THREAD_ACP,
                                               0,
                                               pAligned,
                                               cchUnicode,
                                               pData,
                                               0,
                                               NULL,
                                               NULL);
            }
            else if (!cbData)
            {
                Error = ERROR_MORE_DATA;
            }

            if (pAligned != (LPWSTR)pUnicode)
            {
                LocalFree(pAligned);
            }
        }
    }

    if (pcbCopied)
    {
        *pcbCopied = cbCopied;
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\util.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Client Side Utility Routines


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

HANDLE hCSR = INVALID_HANDLE_VALUE;

BOOL
InCSRProcess(
    VOID
    )
{
    //
    // hCSR == INVALID_HANDLE_VALUE  Not initialized, must check.
    //         NULL                  Not running in CSR
    //         hModule value         Running in CSR
    //

    if (hCSR != NULL) {

        //
        // Check if we are running in CSR.  If so, then don't try
        // any notifications.
        //
        if (hCSR == INVALID_HANDLE_VALUE) {
            hCSR = GetModuleHandle( gszCSRDll );
        }
    }

    return hCSR != NULL;
}

LPVOID
DllAllocSplMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    PDWORD_PTR  pMem;
    DWORD    cbNew;

    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb+sizeof(DWORD_PTR)+sizeof(DWORD);

    pMem= LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        DBGMSG( DBG_WARNING, ("Memory Allocation failed for %d bytes\n", cbNew ));
        return 0;
    }

    *pMem=cb;
    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadbeef;

    return (LPVOID)(pMem+1);
}

BOOL
DllFreeSplMem(
   LPVOID pMem
)
{
    DWORD_PTR   cbNew;
    PDWORD_PTR pNewMem;

    if( !pMem ){
        return TRUE;
    }
    pNewMem = pMem;
    pNewMem--;

    cbNew = *pNewMem;

    if (*(LPDWORD)((LPBYTE)pMem + cbNew) != 0xdeadbeef) {
        DBGMSG(DBG_ERROR, ("DllFreeSplMem Corrupt Memory in winspool : %0p\n", pNewMem));
        return FALSE;
    }

    memset(pNewMem, 0x65, (size_t) cbNew);

    LocalFree((LPVOID)pNewMem);

    return TRUE;
}

LPVOID
ReallocSplMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocSplMem(cbNew);

    if (pOldMem && pNewMem) {

        if (cbOld) {
            CopyMemory( pNewMem, pOldMem, min(cbNew, cbOld));
        }
        FreeSplMem(pOldMem);
    }
    return pNewMem;
}

LPTSTR
AllocSplStr(
    LPCTSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPTSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = AllocSplMem( _tcslen(pStr)*sizeof(TCHAR) + sizeof(TCHAR) ))
      StringCchCopy(pMem, _tcslen(pStr)+1, pStr);

   return pMem;
}

BOOL
DllFreeSplStr(
   LPTSTR pStr
)
{
   return pStr ?
              DllFreeSplMem(pStr) :
              FALSE;
}

BOOL
ReallocSplStr(
   LPTSTR *ppStr,
   LPCTSTR pStr
)
{
    LPWSTR pOldStr = *ppStr;

    *ppStr=AllocSplStr(pStr);
    FreeSplStr(pOldStr);

    return TRUE;
}

/* Message
 *
 * Displays a message by loading the strings whose IDs are passed into
 * the function, and substituting the supplied variable argument list
 * using the varargs macros.
 *
 */
INT
Message(
    HWND    hwnd,
    DWORD   Type,
    INT     CaptionID,
    INT     TextID,
    ...
    )
{
    TCHAR MsgText[256];
    TCHAR MsgFormat[256];
    TCHAR MsgCaption[40];
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      COUNTOF(MsgFormat)) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption, COUNTOF(MsgCaption) ) > 0 ) )
    {
        va_start( vargs, TextID );
        StringCchVPrintf( MsgText, 256, MsgFormat, vargs );
        va_end( vargs );

        return MessageBox( hwnd, MsgText, MsgCaption, Type );
    }
    else
        return 0;
}

/*
 *
 */
LPTSTR
GetErrorString(
    DWORD   Error
)
{
    TCHAR   Buffer[1024];
    LPTSTR  pErrorString = NULL;
    DWORD   dwFlags;
    HANDLE  hModule;

    if ((Error >= NERR_BASE) && (Error <= MAX_NERR)){
        hModule = LoadLibrary(szNetMsgDll);
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;
    }
    else {
        hModule = NULL;
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;
    }

    if( FormatMessage( dwFlags, hModule,
                       Error, 0, Buffer,
                       COUNTOF(Buffer), NULL )
      == 0 )

        LoadString( hInst, IDS_UNKNOWN_ERROR, Buffer,
                    COUNTOF(Buffer));

    pErrorString = AllocSplStr(Buffer);

    if (hModule) {
        FreeLibrary(hModule);
    }

    return pErrorString;
}

DWORD ReportFailure( HWND  hwndParent,
                   DWORD idTitle,
                   DWORD idDefaultError )
{
    DWORD  ErrorID;
    DWORD  MsgType;
    LPTSTR pErrorString;

    ErrorID = GetLastError( );

    MsgType = MB_OK | MB_ICONSTOP;

    pErrorString = GetErrorString( ErrorID );

    Message( hwndParent, MsgType, idTitle,
             idDefaultError, pErrorString );

    FreeSplStr( pErrorString );


    return ErrorID;
}

/*
 *
 */
#define ENTRYFIELD_LENGTH      256
LPTSTR AllocDlgItemText(HWND hwnd, int id)
{
    TCHAR string[ENTRYFIELD_LENGTH];

    GetDlgItemText (hwnd, id, string, COUNTOF(string));
    return ( *string ? AllocSplStr(string) : NULL );
}

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
    )
/*++


--*/
{
    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   SDLength = 0;


    //
    // Initialize *pSizeSD = 0;
    //

    *pSizeSD = 0;
    if (!IsValidSecurityDescriptor(pPrinterSD)) {
        return(NULL);
    }
    if (!InitializeSecurityDescriptor (&AbsoluteSD, SECURITY_DESCRIPTOR_REVISION1)) {
        return(NULL);
    }

    if(!GetSecurityDescriptorOwner(pPrinterSD,
                                    &pOwnerSid, &Defaulted)){
        return(NULL);
    }
    SetSecurityDescriptorOwner(&AbsoluteSD,
                               pOwnerSid, Defaulted );

    if(! GetSecurityDescriptorGroup( pPrinterSD,
                                    &pGroupSid, &Defaulted )){
        return(NULL);
    }
    SetSecurityDescriptorGroup( &AbsoluteSD,
                                    pGroupSid, Defaulted );

    if(!GetSecurityDescriptorDacl( pPrinterSD,
                                   &DaclPresent, &pDacl, &Defaulted )){
        return(NULL);
    }

    SetSecurityDescriptorDacl( &AbsoluteSD,
                                   DaclPresent, pDacl, Defaulted );

    if(!GetSecurityDescriptorSacl( pPrinterSD,
                                   &SaclPresent, &pSacl, &Defaulted)){
        return(NULL);
    }
    SetSecurityDescriptorSacl( &AbsoluteSD,
                                 SaclPresent, pSacl, Defaulted );

    SDLength = GetSecurityDescriptorLength( &AbsoluteSD);
    pRelative = LocalAlloc(LPTR, SDLength);
    if (!pRelative) {
        return(NULL);
    }
    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &SDLength)) {
        LocalFree(pRelative);
        return(NULL);
    }

    *pSizeSD = SDLength;
    return(pRelative);
}


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    /* Scan through the string looking for commas,
     * ensuring that each is followed by a non-NULL character:
     */
    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +

         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocSplMem(cb)))
        return NULL;

    pResult->cb = cb;

    /* Initialise pDest to point beyond the token pointers:
     */
    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    /* Then copy the key data buffer there:
     */
    StringCchCopy(pDest, 
                  (cb - sizeof(KEYDATA) - (cTokens-1) * sizeof(LPWSTR))/2,
                  pKeyData);

    ppToken = pResult->pTokens;

    psz = pDest;

    do {

        *ppToken++ = psz;

        if ( psz = wcschr(psz, L',') )
            *psz++ = L'\0';

    } while (psz);

    pResult->cTokens = cTokens;

    return( pResult );
}


LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    )
{
    LPBYTE pMem;
    LPTSTR pPort;
    DWORD  dwPassed = 1024; //Try 1K to start with
    LPPRINTER_INFO_2 pPrinter;
    DWORD dwLevel = 2;
    DWORD dwNeeded;
    PKEYDATA pKeyData;
    DWORD i = 0;
    LPWSTR pPortNames = NULL;


    pMem = AllocSplMem(dwPassed);
    if (pMem == NULL) {
        return FALSE;
    }
    if (!GetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
        DBGMSG(DBG_TRACE, ("Last error is %d\n", GetLastError()));
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            return NULL;
        }
        pMem = ReallocSplMem(pMem, dwPassed, dwNeeded);
        dwPassed = dwNeeded;
        if (!GetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
            FreeSplMem(pMem);
            return (NULL);
        }
    }
    pPrinter = (LPPRINTER_INFO_2)pMem;

    //
    // Fixes the null pPrinter->pPortName problem where
    // downlevel may return null
    //

    if (!pPrinter->pPortName) {
        FreeSplMem(pMem);
        return(NULL);
    }

    pPortNames = AllocSplStr(pPrinter->pPortName);
    FreeSplMem(pMem);

    return(pPortNames);
}

BOOL
UpdateString(
    IN     LPCTSTR pszString,  OPTIONAL
       OUT LPTSTR* ppszOut
    )

/*++

Routine Description:

    Updates an output string if the input is non-NULL.

Arguments:

    pszString - String to update to.  If NULL or -1, function does nothing.

Return Value:

    TRUE - Success
    FALSE - FAILED.  *ppszOut = NULL

--*/

{
    if( pszString && pszString != (LPCTSTR)-1 ){

        FreeSplStr( *ppszOut );
        *ppszOut = AllocSplStr( pszString );

        if( !*ppszOut ){
            return FALSE;
        }
    }
    return TRUE;
}

DWORD
RouterFreeBidiResponseContainer(
    PBIDI_RESPONSE_CONTAINER pData
)
{
    BIDI_RESPONSE_DATA *p;
    DWORD              Count = 0;
    DWORD              NumOfRspns;
    DWORD              dwRet = ERROR_SUCCESS;

    try
    {
        if(pData)
        {
            Count = pData->Count;

            for(NumOfRspns= 0,
                p         = &pData->aData[0];

                NumOfRspns < Count;

                NumOfRspns++,
                p++
               )
            {
                if(p)
                {
                    if(p->pSchema)
                    {
                        MIDL_user_free(p->pSchema);
                    }

                    switch(p->data.dwBidiType)
                    {
                        //
                        // Text Data (ANSI String)
                        //
                        case BIDI_TEXT:
                        //
                        // String (UNICODE string)
                        //
                        case BIDI_ENUM:
                        //
                        // Enumeration Data (ANSI String)
                        //
                        case BIDI_STRING:
                        {
                            if(p->data.u.sData)
                            {
                                MIDL_user_free(p->data.u.sData);
                            }
                        }
                        break;

                        //
                        // Binary Data (BLOB)
                        //
                        case BIDI_BLOB:
                        {
                            if(p->data.u.biData.pData)
                            {
                                MIDL_user_free(p->data.u.biData.pData);
                            }
                        }
                        break;

                        //
                        // Undefined Type
                        //
                        default:
                        {
                            //
                            // Nothing really , just return
                            //
                        }
                        break;
                    }
                }
            }
            MIDL_user_free(pData);
        }
    }
    except(1)
    {
        dwRet = TranslateExceptionCode(GetExceptionCode());
        DBGMSG(DBG_ERROR, ("RouterFreeBidiResponseContainer raised an exception : %u \n", dwRet));
    }
    return(dwRet);
}

ClientVersion
GetClientVer()
{
    ClientVersion ClientVer;
    return(ClientVer = sizeof(ULONG_PTR));
}

ServerVersion
GetServerVer()
{
    ULONG_PTR       ul;
    NTSTATUS        st;
    ServerVersion   CurrVer;

    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &ul,
                                   sizeof(ul),
                                   NULL);
    if (NT_SUCCESS(st))
    {
        // If this call succeeds, we're on Win2000 or newer machines.
        if (0 != ul)
        {
            // 32-bit code running on Win64
            CurrVer = THUNKVERSION;
        } else
        {
            // 32-bit code running on Win2000 or later 32-bit OS
            CurrVer = NATIVEVERSION;
        }
    } else
    {
        CurrVer = NATIVEVERSION;
    }
    return(CurrVer);
}

BOOL
RunInWOW64()
{
    return((GetClientVer() == RUN32BINVER)  &&
           (GetServerVer() == THUNKVERSION) &&
           !bLoadedBySpooler);
    /*return(bLoadedBySpooler ? FALSE : TRUE);*/
}

HWND
GetForeGroundWindow(
    VOID
)
{
    //
    // get the foreground window first
    //
    HWND hWndOwner;
    HWND hWndLastPopup;
    HWND hWndForeground = GetForegroundWindow();
    //
    // climb up to the top parent in case it's a child window...
    //
    HWND hWndParent = hWndForeground;
    while ( hWndParent = GetParent(hWndParent) )
    {
        hWndForeground = hWndParent;
    }
    //
    // get the owner in case the top parent is owned
    //
    hWndOwner= GetWindow(hWndForeground, GW_OWNER);

    if ( hWndOwner )
    {
        hWndForeground = hWndOwner;
    }

    hWndLastPopup = GetLastActivePopup(hWndForeground);

    return(hWndLastPopup);
}

LPCWSTR
FindFileName(
    IN      LPCWSTR pPathName
    )
/*++

Routine Description:

    Retrieve the filename portion of a path.

    This will can the input string until it finds the last backslash,
    then return the portion of the string immediately following it.
    If the string terminates with a backslash, then NULL is returned.

    Note: this can return illegal file names; no validation is done.

Arguments:

    pPathName - Path name to parse.

Return Value:

    Last portion of file name or NULL if none available.

--*/

{
    LPCWSTR pSlash;
    LPCWSTR pTemp;

    if( !pPathName ){
       return NULL;
    }

    pTemp = pPathName;
    while( pSlash = wcschr( pTemp, L'\\' )) {
        pTemp = pSlash+1;
    }

    if( !*pTemp ){
       return NULL;
    }

    return pTemp;
}

/*++

Name:

    BuildSpoolerObjectPath

Description:

    This function addresses bug 461462. When the spooler is not running,
    this function can build the path to the drivers directory or the print 
    processors directory. The result of this function is a path like:
    C:\Windows\System32\spool\Drivers\w32x86
    or
    C:\Windows\System32\spool\Prtprocs\w32x86
    depending on the pszPath argument.
    
Arguments:

    pszPath          - can be "drivers" or "prtprocs"
    pszName          - must be NULL or ""
    pszEnvironment   - can be "windows nt x86" etc. This argument must be validated by the caller
                       (GetPrinterDriverDirectoryW and GetPrintProcessorDirectoryW)  
    Level            - must be 1
    pDriverDirectory - buffer where to store the path
    cbBuf            - count of bytes in the buffer
    pcbNeeded        - count of bytes needed to store the path


Return Value:

    TRUE - the function succeeded, pDriverDirectory can be used
    FALSE - the function failed, pDriverDirectory cannot be used.
    
Last error:

    This function sets the last error in both failure and success cases.    

--*/
BOOL
BuildSpoolerObjectPath(
    IN  PCWSTR  pszPath,
    IN  PCWSTR  pszName,
    IN  PCWSTR  pszEnvironment, 
    IN  DWORD   Level, 
    IN  PBYTE   pDriverDirectory, 
    IN  DWORD   cbBuf, 
    IN  PDWORD  pcbNeeded
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pcbNeeded && (!pszName || !*pszName))
    {
        HKEY  hkRoot = NULL;
        HKEY  hkEnv  = NULL;
        DWORD cchDir = MAX_PATH;
        WCHAR szDir[MAX_PATH];
        
        Error = GetSystemWindowsDirectory(szDir, cchDir) ? ERROR_SUCCESS : GetLastError();
        
        if (Error == ERROR_SUCCESS &&
            (Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                  gszRegEnvironments, 
                                  0, 
                                  KEY_READ, 
                                  &hkRoot)) == ERROR_SUCCESS &&
            (Error = RegOpenKeyEx(hkRoot, 
                                  pszEnvironment, 
                                  0, 
                                  KEY_READ, 
                                  &hkEnv)) == ERROR_SUCCESS &&
            (Error = StrNCatBuff(szDir,
                                 cchDir,
                                 szDir,
                                 szSlash,
                                 gszSystem32Spool,
                                 szSlash,
                                 pszPath,
                                 szSlash,
                                 NULL)) == ERROR_SUCCESS)
        {
            DWORD Length       = wcslen(szDir);
            DWORD cbAvailable  = (cchDir - Length) * sizeof(WCHAR);
            
            if ((Error = RegQueryValueEx(hkEnv, 
                                         gszEnivronmentDirectory, 
                                         NULL, 
                                         NULL, 
                                         (PBYTE)&szDir[Length], 
                                         &cbAvailable)) == ERROR_SUCCESS)
            {
                *pcbNeeded = (wcslen(szDir) + 1) * sizeof(WCHAR);

                if (cbBuf >= *pcbNeeded)
                {
                    StringCchCopy((PWSTR)pDriverDirectory, 
                                  cbBuf/2,
                                  szDir);                    
                }
                else
                {
                    Error = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }
        else if (Error == ERROR_FILE_NOT_FOUND)
        {
            //
            // If we cannot open the "pszEnvironment" key then the environment is invalid.
            //
            Error = ERROR_INVALID_ENVIRONMENT;
        }

        if (hkRoot) RegCloseKey(hkRoot);
        if (hkEnv)  RegCloseKey(hkEnv);
    }

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\wlkprn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    walkreg.cxx

Abstract:

    Printer data walking class definition.

Author:

    Adina Trufinescu (AdinaTru)  15-Oct-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "wlkprn.hxx"

#define gszWack TEXT("\\")

/*++

Title:

    WalkPrinterData::WalkPrinterData

Routine Description:

    Default constructor

Arguments:

    None

Return Value:

    None

--*/
WalkPrinterData::
WalkPrinterData(
    VOID
    )
{
    InitializeClassVariables();
}

/*++

Title:

    WalkPrinterData

Routine Description:

    class constructor

Arguments:

    pszPrinterName      -- printer name

    resource type       -- printer / server

    access type     -- converted to printer access flags

Return Value:

    Nothing

--*/

WalkPrinterData::
WalkPrinterData(
    IN TString&                         pszPrinterName,
    IN WalkPrinterData::EResourceType   eResourceType,
    IN WalkPrinterData::EAccessType     eAccessType
    )
{
    InitializeClassVariables();

    m_strPrnName.bUpdate( pszPrinterName );

    PRINTER_DEFAULTS Access = {0, 0, PrinterAccessFlags( eResourceType, eAccessType ) };

    //
    // Null string indicate the local server.
    //
    if(m_strPrnName.bValid())
    {
        if (OpenPrinter(const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strPrnName)), &m_hPrinter, &Access))
        {
            m_eAccessType = eAccessType;
        }
    }
}

/*++

Title:

    WalkPrinterData

Routine Description:

    constructor

Arguments:

    hPrinter -- handle to an open printer

Return Value:

    Nothing

--*/
WalkPrinterData::
WalkPrinterData(
    IN HANDLE       hPrinter
    )
{
    InitializeClassVariables();
    m_hPrinter          = hPrinter;
    m_bAcceptedHandle   = TRUE;
}

/*++

Title:

    Bind

Routine Description:

    late initialization

Arguments:

    hPrinter -- handle to an opened printer

Return Value:

    Nothing

--*/
VOID
WalkPrinterData::
BindToPrinter(
    IN HANDLE   hPrinter
    )
{
    m_hPrinter          = hPrinter;
    m_bAcceptedHandle   = TRUE;
}


/*++

Title:

    ~WalkPrinterData

Routine Description:

    class    destructor

Arguments:

    None

Return Value:

    Nothing

--*/
WalkPrinterData::
~WalkPrinterData(
    VOID
    )
{
    if( !m_bAcceptedHandle && m_hPrinter )
    {
        ClosePrinter(m_hPrinter);
    }
}


/*++

Title:

    bValid

Routine Description:

    Checks member initialisation

Arguments:

    None

Return Value:

    TRUE if valid m_hPrinter

--*/
BOOL
WalkPrinterData::
bValid(
    VOID
    ) const
{
    return m_hPrinter != INVALID_HANDLE_VALUE ;

}


/*++

Title:

    InitializeClassVariables

Routine Description:

    initialise class members

Arguments:

Return Value:

    VOID

Last Error:

--*/
VOID
WalkPrinterData::
InitializeClassVariables(
    VOID
    )
{
    m_strPrnName.bUpdate(NULL);

    m_hPrinter                  = NULL;
    m_eAccessType               = kAccessUnknown;
    m_bAcceptedHandle           = FALSE;
}

/*++

Title:

    PrinterAccessFlags

Routine Description:

    Convert class access flags to printer ACCESS_MASK

Arguments:

    resource type       -- printer / server

    access type     -- converted to printer access flags

Return Value:

    an access mask built upon eResourceType and eAccessType

--*/
ACCESS_MASK
WalkPrinterData::
PrinterAccessFlags(
    IN EResourceType   eResourceType,
    IN EAccessType     eAccessType
    ) const
{
    static const DWORD adwAccessPrinter[] =
    {
        PRINTER_ALL_ACCESS,
        PRINTER_READ  | PRINTER_WRITE,
        0,
    };

    static const DWORD adwAccessServer[] =
    {
        SERVER_ALL_ACCESS,
        SERVER_READ       | SERVER_WRITE,
        0,
    };

    DWORD   dwAccess    = 0;
    UINT    uAccessType = eAccessType > 3 ? 2 : eAccessType;

    switch( eResourceType )
    {
        case kResourceServer:
            dwAccess = adwAccessServer[uAccessType];
            break;

        case kResourcePrinter:
            dwAccess = adwAccessPrinter[uAccessType];
            break;

        case kResourceUnknown:
        default:
            break;
    }

    return dwAccess;
}



/*++

Title:  NextStrT

Routine Description:

    Returns next sz string in a multi zero string

Arguments:

    lpszStr - ptr to multi zero string

Return Value:

    pointer to zero string

--*/
LPTSTR
WalkPrinterData::
NextStrT(
    IN  LPCTSTR lpszStr
    )
{
    return const_cast<LPTSTR>(lpszStr) + (_tcslen(lpszStr) + 1);
}


/*++

Title:

    bHasSubKeys

Routine Description:

    Check if a Printer data key has subkeys

Arguments:

    strKey  -   key string

    mszSubKeys -    ptr to multi zero string

    must be checked at return time ; fnct can return TRUE and

    mszSubKeys == NULL -> has subkeys but couldn't allocate mszSubKeys

Return Value:

    TRUE if is has subkeys
    FALSE if has no sub keys

--*/
BOOL
WalkPrinterData::
bHasSubKeys(
    IN   TString&   strKey,
    OUT  LPTSTR*    mszSubKeys  //ORPHAN
    )
{
    DWORD       cbSize;
    TStatus     Status(DBG_WARN, ERROR_MORE_DATA);
    TStatusB    bStatus;

    bStatus DBGCHK =  bValid();

    if(bStatus)
    {
        //
        // Determine the size necessary for enumerating all the
        // sub-keys for this key.

        cbSize = 0;

        Status  DBGCHK = EnumPrinterKey(m_hPrinter, static_cast<LPCTSTR>(strKey), NULL, 0, &cbSize);

        //
        // If OK, then proceed to the enumeration.
        //
        if (cbSize && (Status == ERROR_MORE_DATA))
        {
            //
            // Allocate the space for retrieving the keys.
            //
            *mszSubKeys = reinterpret_cast<LPTSTR>( AllocMem(cbSize) );

            bStatus DBGCHK = (*mszSubKeys != NULL);

            if(bStatus)
            {
                //
                // Enumerate the sub-keys for this level in (lpszKey).
                //
                Status DBGCHK = EnumPrinterKey(m_hPrinter, static_cast<LPCTSTR>(strKey), *mszSubKeys, cbSize, &cbSize);

                bStatus DBGCHK = (Status == ERROR_SUCCESS);

                if(bStatus)
                {
                    goto End;
                }

                //
                // Free mszSubKeys if EnumPrinterKey fails
                //
                FreeMem(*mszSubKeys);
            }

        }
        else
        {
            bStatus DBGCHK = FALSE;
        }
    }

End:

    return bStatus;

}


/*++

Title:

    bInternalWalk

Routine Description:

    Walking function through printer data keys; calls Walk IN/POST/PRE for every key

Arguments:

    strKey  - key string

    lpcItems - number of keys walked through

Return Value:

    TRUE if is has subkeys

    FALSE if has no sub keys

--*/
BOOL
WalkPrinterData::
bInternalWalk (
    IN   TString& strKey,
    OUT  LPDWORD  lpcItems  OPTIONAL
    )
{
    LPTSTR          lpszSubKey;
    LPTSTR          mszSubKeys;
    TString         strFullSubKey;
    DWORD           cItems = 0;
    TStatusB        bStatus;

    *lpcItems = 0;

    if(bHasSubKeys(strKey, &mszSubKeys))
    {
        bStatus DBGCHK =  (mszSubKeys != NULL);

        if(bStatus)
        {
            //
            // Walk PRE before walking subkeys
            //
            bStatus DBGCHK = bWalkPre(strKey , &cItems);

            //
            // Browse subkeys multi zero string and call bInternalWalk for every subkey
            // this loop will won't execute if bWalkPre failed
            //
            for (lpszSubKey = mszSubKeys; *lpszSubKey && bStatus; )
            {
                //
                // Builds strSubKey and strFullKey
                //
                if(strKey.uLen() > 0)
                {
                    bStatus DBGCHK = strFullSubKey.bUpdate(strKey)  &&
                                     strFullSubKey.bCat(gszWack)    &&
                                     strFullSubKey.bCat(lpszSubKey);
                }
                else
                {
                    bStatus DBGCHK = strFullSubKey.bUpdate(lpszSubKey);
                }


                if(bStatus)
                {
                    bStatus DBGCHK = bInternalWalk(strFullSubKey, &cItems);
                    bStatus ? *lpcItems += cItems :  *lpcItems;
                    lpszSubKey = NextStrT(lpszSubKey);
                }

            }

           FreeMem(mszSubKeys);
        }

        if(bStatus)
        {
            //
            // Walk POST after walking all subkeys
            //
            bStatus DBGCHK = bWalkPost(strKey , &cItems);

            bStatus ? *lpcItems += cItems :  *lpcItems;
        }
    }
    else
    {
        //
        // Current key is not <directory> ,so walk IN!!!
        //
        bStatus DBGCHK = bWalkIn(strKey , &cItems);

        bStatus ? *lpcItems = cItems : *lpcItems;

    }

    return bStatus;
}



/*++

Title:

    bWalkPre

Routine Description:

    PRE walking

Arguments:

    strKey  -   key string

Return Value:

    TRUE

--*/
BOOL
WalkPrinterData::
bWalkPre(
    IN   TString&    strKey,
    OUT  LPDWORD     lpcItems
    )
{
    return TRUE;
}

/*++

Title:

    bWalkIn

Routine Description:

    IN walking

Arguments:

    strKey  -   key string

Return Value:

    TRUE

Last Error:

--*/
BOOL
WalkPrinterData::
bWalkIn (
    IN   TString&     str,
    OUT  LPDWORD      lpcItems
    )
{
    return TRUE;
}

/*++

Title:

    bWalkPost

Routine Description:

    POST walking

Arguments:

    strKey  -   key string

Return Value:

    TRUE

--*/
BOOL
WalkPrinterData::
bWalkPost (
    IN   TString&     strKey,
    OUT  LPDWORD      lpcItem
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\client\winspool.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    Winspool.c

Abstract:

    Bulk of winspool.drv code

Author:

Environment:

    User Mode -Win32

Revision History:
    mattfe  april 14 94     added caching to writeprinter
    mattfe  jan 95          Add SetAllocFailCount api

    13-Jun-1996 Thu 15:07:16 updated  -by-  Daniel Chou (danielc)
        Make PrinterProperties call PrinterPropertySheets and
             DocumentProperties call DocumentPropertySheets

    SWilson Dec 1996 - added GetPrinterDataEx, SetPrinterDataEx, EnumPrinterDataEx,
                             EnumPrinterKey, DeletePrinterDataEx, and DeletePrinterKey

    khaleds Feb 2000 - Added DocumentPropertiesThunk,
                             AddPortWThunk,
                             CongigurePortWThunk,
                             DeleteProtWThunk,
                             DeviceCapabilitesWThunk,
                             PrinterPropertiesWThunk,
                             DocmentEvenThunk,
                             SpoolerPrinterEventThunk
                       Renamed the above native functions from xx to xxNative

   Khaleds Mar 2000 - Added SendRecvBidiData
   Khaleds Mar 2001 - Fix for WritePrinter
   LazarI - Oct-30-2000 added GetCurrentThreadLastPopup & fixed StartDocDlgW
   AMaxa 11 Oct 2001 - Support GetPrinterDriverDirectory and GetPrintProcessorDirectory
                       even if the spooler process is not running

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "winsprlp.h"
#include "pfdlg.h"
#include "splwow64.h"
#include "drvsetup.h"

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

HANDLE           hInst = NULL;
CRITICAL_SECTION ProcessHndlCS;
HANDLE           hSurrogateProcess = NULL;
WndHndlList*     GWndHndlList=NULL;
BOOL             bMonitorThreadCreated = FALSE;

LPWSTR szEnvironment     = LOCAL_ENVIRONMENT;
LPWSTR szIA64Environment = L"Windows IA64";

HANDLE hShell32 = INVALID_HANDLE_VALUE;

//
// pointer to the start of the list containing the driver file handles
//
PDRVLIBNODE   pStartDrvLib = NULL;

CRITICAL_SECTION  ListAccessSem;

DWORD gcClientICHandle = 0;

#define DM_MATCH( dm, sp )  ((((sp)+50)/100-dm)<15&&(((sp)+50)/100-dm)>-15)
#define DM_PAPER_WL         (DM_PAPERWIDTH | DM_PAPERLENGTH)

#define JOB_CANCEL_CHECK_INTERVAL   2000    // 2 seconds
#define MAX_RETRY_INVALID_HANDLE    2       // 2 retries


/*++

Routine Name:

    IsInvalidHandleError
    
Routine Description:

    If the error returned by the RPC routine was an Invalid Handle Error or not.

Arguments:

    dwLastError  -  The LastError that recieved from the RPC call.

Return Value:

    BOOL.

--*/
BOOL
IsInvalidHandleError(
    DWORD  dwLastError
    )
{
    return (dwLastError == ERROR_INVALID_HANDLE || dwLastError == RPC_X_SS_IN_NULL_CONTEXT);
}
LONG
CallCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )
/*++

Routine Description:

    This function dymically load the compstui.dll and call its entry


Arguments:

    pfnPropSheetUI  - Pointer to callback function

    lParam          - lParam for the pfnPropSheetUI

    pResult         - pResult for the CommonPropertySheetUI


Return Value:

    LONG    - as describe in compstui.h


Author:

    01-Nov-1995 Wed 13:11:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HINSTANCE           hInstCPSUI;
    FARPROC             pProc;
    LONG                Result = ERR_CPSUI_GETLASTERROR;

    //
    // ONLY need to call the ANSI version of LoadLibrary
    //

    if ((hInstCPSUI = LoadLibraryA(szCompstuiDll)) &&
        (pProc = GetProcAddress(hInstCPSUI, szCommonPropertySheetUIW))) {

        RpcTryExcept {

            Result = (LONG)((*pProc)(hWndOwner, pfnPropSheetUI, lParam, pResult));

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            Result = ERR_CPSUI_GETLASTERROR;

        } RpcEndExcept

    }

    if (hInstCPSUI) {

        FreeLibrary(hInstCPSUI);
    }

    return(Result);
}

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
)
{
    switch (ExceptionCode) {

    case EXCEPTION_ACCESS_VIOLATION:
    case EXCEPTION_DATATYPE_MISALIGNMENT:
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
    case EXCEPTION_INT_OVERFLOW:
    case EXCEPTION_PRIV_INSTRUCTION:
    case ERROR_NOACCESS:
    case RPC_S_INVALID_BOUND:

        return ERROR_INVALID_PARAMETER;
        break;
    default:
        return ExceptionCode;
    }
}

BOOL
EnumPrintersW(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pPrinterEnum)
            memset(pPrinterEnum, 0, cbBuf);

        if (ReturnValue = RpcEnumPrinters(Flags, Name, Level, pPrinterEnum, cbBuf,
                                          pcbNeeded, pcReturned)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPrinterEnum) {

                ReturnValue = MarshallUpStructuresArray(pPrinterEnum, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
ResetPrinterW(
    HANDLE   hPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    BOOL  ReturnValue = FALSE;
    DEVMODE_CONTAINER    DevModeContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwFlags = 0;
    LPWSTR pDatatype = NULL;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    if( !UpdatePrinterDefaults( pSpool, NULL, pDefault )){
        goto Done;
    }

    if (pDefault && pDefault->pDatatype) {
        if (pDefault->pDatatype == (LPWSTR)-1) {
            pDatatype = NULL;
            dwFlags |=  RESET_PRINTER_DATATYPE;
        } else {
            pDatatype = pDefault->pDatatype;
        }
    } else {
        pDatatype = NULL;
    }

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    if( pDefault ){

        if (pDefault->pDevMode == (LPDEVMODE)-1) {

            dwFlags |= RESET_PRINTER_DEVMODE;

        } else if( BoolFromHResult(SplIsValidDevmodeNoSizeW( pDefault->pDevMode ))){

            DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                     pDefault->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
        }
    }


    do {

        RpcTryExcept {

            if (ReturnValue = RpcResetPrinterEx(pSpool->hPrinter,
                                             pDatatype, &DevModeContainer,
                                             dwFlags
                                             )) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:

    vUnprotectHandle( hPrinter );

    return ReturnValue;
}

BOOL
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL  ReturnValue = FALSE;
    GENERIC_CONTAINER   GenericContainer;
    GENERIC_CONTAINER *pGenericContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    switch (Level) {

    case 0:
        break;

    case 1:
    case 2:
    case 3:
        if (!pJob) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        if (pJob) {

            GenericContainer.Level = Level;
            GenericContainer.pData = pJob;
            pGenericContainer = &GenericContainer;

        } else {

            pGenericContainer = NULL;
        }
           
        if (bLoadedBySpooler && fpYSetJob && pSpool->hSplPrinter) {

            ReturnValue = (*fpYSetJob)(pSpool->hSplPrinter, 
                                       JobId,
                                       (JOB_CONTAINER *)pGenericContainer,
                                       Command,
                                       NATIVE_CALL);
        } else {

            RpcTryExcept {

                ReturnValue = RpcSetJob(pSpool->hPrinter, 
                                        JobId,
                                        (JOB_CONTAINER *)pGenericContainer,
                                        Command);

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                ReturnValue = TranslateExceptionCode(RpcExceptionCode());
                
            } RpcEndExcept

        }

        if (ReturnValue != ERROR_SUCCESS) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {
            ReturnValue = TRUE;
        }
        
    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    SIZE_T  cbStruct;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if (ReturnValue = RpcGetJob(pSpool->hPrinter, JobId, Level, pJob, cbBuf,
                                        pcbNeeded)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = MarshallUpStructure(pJob, pFieldInfo, cbStruct, RPC_CALL);
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


BOOL
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if (ReturnValue = RpcEnumJobs(pSpool->hPrinter, FirstJob, NoJobs, Level, pJob,
                                          cbBuf, pcbNeeded, pcReturned)) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = MarshallUpStructuresArray(pJob, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

HANDLE
AddPrinterW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
)
{
    DWORD  ReturnValue;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    HANDLE  hPrinter;
    PSPOOL  pSpool = NULL;
    PVOID   pNewSecurityDescriptor = NULL;
    SECURITY_DESCRIPTOR_CONTROL SecurityDescriptorControl = 0;
    PPRINTER_INFO_2             pPrinterInfo = (PPRINTER_INFO_2)pPrinter;
    

    switch (Level) {

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return NULL;
    }

    if ( !pPrinter ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SecurityContainer.cbBuf = 0;
    SecurityContainer.pSecurity = NULL;

    if (Level == 2) {

        //
        // If valid (non-NULL and properly formatted), then update the
        // global DevMode (not per-user).
        //
        if( BoolFromHResult(SplIsValidDevmodeNoSizeW( pPrinterInfo->pDevMode ))){

            DevModeContainer.cbBuf = pPrinterInfo->pDevMode->dmSize +
                                     pPrinterInfo->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo->pDevMode;

        }

        if (pPrinterInfo->pSecurityDescriptor) {

            DWORD   sedlen = 0;

            //
            // We must construct a self relative security descriptor from
            // whatever we get as input: If we get an Absolute SD we should
            // convert it to a self-relative one. (this is a given) and we
            // should also convert any self -relative input SD into a a new
            // self relative security descriptor; this will take care of
            // any holes in the Dacl or the Sacl in the self-relative sd
            //
            pNewSecurityDescriptor = BuildInputSD(
                                         pPrinterInfo->pSecurityDescriptor,
                                         &sedlen);

            if (pNewSecurityDescriptor) {
                SecurityContainer.cbBuf = sedlen;
                SecurityContainer.pSecurity = pNewSecurityDescriptor;

            }
        }
    }

    RpcTryExcept {

        if (ReturnValue = RpcAddPrinter(pName,
                                    (PPRINTER_CONTAINER)&PrinterContainer,
                                    (PDEVMODE_CONTAINER)&DevModeContainer,
                                    (PSECURITY_CONTAINER)&SecurityContainer,
                                    &hPrinter)) {
            SetLastError(ReturnValue);
            hPrinter = FALSE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        hPrinter = FALSE;

    } RpcEndExcept

    if (hPrinter) {

        WCHAR   szFullPrinterName[MAX_UNC_PRINTER_NAME];
        HRESULT hr = S_OK;
        szFullPrinterName[0] = 0;

        if (pSpool = AllocSpool())
        {
            if( pPrinterInfo->pServerName) {

                hr = StrNCatBuff(szFullPrinterName, 
                                 MAX_UNC_PRINTER_NAME, 
                                 pPrinterInfo->pServerName,
                                 L"\\",
                                 NULL);
            }

            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(szFullPrinterName, MAX_UNC_PRINTER_NAME, pPrinterInfo->pPrinterName);
            }

            if ( SUCCEEDED(hr) &&
                 UpdatePrinterDefaults( pSpool, szFullPrinterName, NULL ) &&
                 ( !DevModeContainer.pDevMode ||
                   WriteCurDevModeToRegistry(pPrinterInfo->pPrinterName,
                                             (LPDEVMODEW)DevModeContainer.pDevMode)) ) {

                pSpool->hPrinter = hPrinter;

                //
                // Update the access.
                //
                pSpool->Default.DesiredAccess = PRINTER_ALL_ACCESS;

            } else {

                RpcDeletePrinter(hPrinter);
                RpcClosePrinter(&hPrinter);
                FreeSpool(pSpool);
                pSpool = NULL;

                if (FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                }
            }
        }
    }

    //
    // Free Memory allocated for the SecurityDescriptor
    //

    if (pNewSecurityDescriptor) {
        LocalFree(pNewSecurityDescriptor);
    }

    //
    // Some apps check for last error instead of return value
    // and report failures even if the return handle is not NULL.
    // For success case, set last error to ERROR_SUCCESS.
    //
    if (pSpool) {
        SetLastError(ERROR_SUCCESS);
    }
   return pSpool;
}

BOOL
DeletePrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    do {
        RpcTryExcept {

            if (ReturnValue = RpcDeletePrinter(pSpool->hPrinter)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                DeleteCurDevModeFromRegistry(pSpool->pszPrinter);
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}



BOOL
SpoolerPrinterEventNative(
    LPWSTR  pName,
    INT     PrinterEvent,
    DWORD   Flags,
    LPARAM  lParam,
    DWORD   *pdwErrorReturned
)
/*++

    //
    //  Some printer drivers, like the FAX driver want to do per client
    //  initialization at the time a connection is established
    //  For example in the FAX case they want to push up UI to get all
    //  the client info - Name, Number etc.
    //  Or they might want to run Setup, in initialize some other components
    //  Thus on a successful conenction we call into the Printer Drivers UI
    //  DLL to give them this oportunity
    //
    //                                                      
--*/
{
    BOOL    ReturnValue = FALSE;
    HANDLE  hPrinter;
    HANDLE  hModule;
    INT_FARPROC pfn;

    *pdwErrorReturned = ERROR_SUCCESS;

    if (OpenPrinter((LPWSTR)pName, &hPrinter, NULL)) {

        if (hModule = LoadPrinterDriver(hPrinter)) {

            if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DrvPrinterEvent")) {

                try {

                    ReturnValue = (*pfn)( pName, PrinterEvent, Flags, lParam );

                } except(1) {

                    *pdwErrorReturned = TranslateExceptionCode(RpcExceptionCode());
                }
            }
            else
            {
                *pdwErrorReturned = ERROR_PROC_NOT_FOUND;
            }

            RefCntUnloadDriver(hModule, TRUE);
        }

        ClosePrinter(hPrinter);
    }

    return  ReturnValue;
}


BOOL
SpoolerPrinterEventThunk(
    LPWSTR  pName,
    INT     PrinterEvent,
    DWORD   Flags,
    LPARAM  lParam,
    DWORD   *pdwErrorReturned
)
/*++

    //
    //  Some printer drivers, like the FAX driver want to do per client
    //  initialization at the time a connection is established
    //  For example in the FAX case they want to push up UI to get all
    //  the client info - Name, Number etc.
    //  Or they might want to run Setup, in initialize some other components
    //  Thus on a successful conenction we call into the Printer Drivers UI
    //  DLL to give them this oportunity
--*/
{
    BOOL        ReturnValue = FALSE;
    HANDLE      hPrinter;
    HANDLE      hModule;
    INT_FARPROC pfn;

    *pdwErrorReturned = ERROR_SUCCESS;

    RpcTryExcept
    {
         if((*pdwErrorReturned = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS)
         {
             ReturnValue = RPCSplWOW64SpoolerPrinterEvent(pName,
                                                          PrinterEvent,
                                                          Flags,
                                                          lParam,
                                                          pdwErrorReturned);
         }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
         *pdwErrorReturned = TranslateExceptionCode(RpcExceptionCode());
    }
    RpcEndExcept

    return  ReturnValue;
}


BOOL
SpoolerPrinterEvent(
    LPWSTR  pName,
    INT     PrinterEvent,
    DWORD   Flags,
    LPARAM  lParam,
    DWORD   *pdwErrorReturned
)
{
     if(RunInWOW64())
     {
          return(SpoolerPrinterEventThunk(pName,
                                          PrinterEvent,
                                          Flags,
                                          lParam,
                                          pdwErrorReturned));
     }
     else
     {
          return(SpoolerPrinterEventNative(pName,
                                           PrinterEvent,
                                           Flags,
                                           lParam,
                                           pdwErrorReturned));
     }
}


VOID
CopyFileEventForAKey(
    HANDLE  hPrinter,
    LPWSTR  pszPrinterName,
    LPWSTR  pszModule,
    LPWSTR  pszKey,
    DWORD   dwEvent
    )
{
    DWORD               dwNeeded, dwVersion = 0;
    HMODULE             hModule = NULL;
    LPDRIVER_INFO_5     pDriverInfo5 = NULL;
    WCHAR               szPath[MAX_PATH];
    LPWSTR              psz;
    BOOL                (*pfn)(LPWSTR, LPWSTR, DWORD);
    BOOL                bAllocBuffer = FALSE, bLoadedDriver = FALSE;
    BYTE                btBuffer[MAX_STATIC_ALLOC];

    pDriverInfo5 = (LPDRIVER_INFO_5) btBuffer;

    if (!pszModule || !*pszModule) {
        goto CleanUp;
    }

    //
    // Get the Driver config file name
    //
    if (!GetPrinterDriverW(hPrinter, NULL, 5, (LPBYTE) pDriverInfo5,
                           MAX_STATIC_ALLOC, &dwNeeded)) {

        if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
            (pDriverInfo5 = (LPDRIVER_INFO_5)LocalAlloc(LMEM_FIXED, dwNeeded))) {

             bAllocBuffer = TRUE;

             if (!GetPrinterDriverW(hPrinter, NULL, 5,
                                    (LPBYTE)pDriverInfo5, dwNeeded, &dwNeeded)) {

                 goto CleanUp;
             }

        } else goto CleanUp;
    }

    //
    // If module name is the same as the config file, use reference counting
    //
    if (SUCCEEDED(StringCchCopy(szPath, MAX_PATH, pDriverInfo5->pConfigFile)))
    {
        // Get the pointer to just the file name
        psz = wcsrchr(szPath, L'\\');
    }

    if (psz && !_wcsicmp(pszModule, (psz+1))) {

        if (hModule = RefCntLoadDriver(szPath,
                                       LOAD_WITH_ALTERED_SEARCH_PATH,
                                       pDriverInfo5->dwConfigVersion,
                                       TRUE)) {
            bLoadedDriver = TRUE;
        }
    }

    if (!hModule) {
        hModule = LoadLibraryEx(pszModule, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }

    if (!hModule) {
        if (GetLastError() != ERROR_MOD_NOT_FOUND) {            
            goto CleanUp;
        }

        //
        // The module could not be found in users path check if it is there
        // in the printer driver directory
        //
        dwNeeded = (DWORD) (psz - szPath + wcslen(pszModule) + 1);
        if (dwNeeded  > MAX_PATH) {
            //
            // Sanity check for file name size
            //
            goto CleanUp;
        }

        if (SUCCEEDED(StringCchCopy(psz, MAX_PATH - (psz - szPath + 1), pszModule)))
        {
            hModule = LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        }
    }

    //
    // Call the SpoolerCopyFileEvent export
    //
    if (hModule &&
        ((FARPROC)pfn = GetProcAddress(hModule, "SpoolerCopyFileEvent"))) {

         pfn(pszPrinterName, pszKey, dwEvent);
    }

CleanUp:

    if (bAllocBuffer) {
        LocalFree(pDriverInfo5);
    }

    //
    // Use reference counting for config file and FreeLibrary for others
    //
    if (hModule) {
        if (bLoadedDriver) {
            RefCntUnloadDriver(hModule, TRUE);
        } else {
            FreeLibrary(hModule);
        }
    }
}


VOID
DoCopyFileEventForAllKeys(
    LPWSTR  pszPrinterName,
    DWORD   dwEvent
    )
{
    DWORD       dwLastError, dwNeeded, dwType;
    LPWSTR      pszBuf = NULL, psz, pszSubKey, pszModule;
    HANDLE      hPrinter;
    WCHAR       szKey[MAX_PATH];
    BOOL        bAllocBufferEnum = FALSE, bAllocBufferGPD = FALSE;
    BYTE        btBuffer[MAX_STATIC_ALLOC], btBufferGPD[MAX_STATIC_ALLOC];

    pszBuf = (LPTSTR) btBuffer;
    ZeroMemory(pszBuf, MAX_STATIC_ALLOC);

    if ( !OpenPrinter(pszPrinterName, &hPrinter, NULL) )
        return;

    dwLastError = EnumPrinterKeyW(hPrinter,
                                  L"CopyFiles",
                                  pszBuf,
                                  MAX_STATIC_ALLOC,
                                  &dwNeeded);

    //
    // If CopyFiles key is not found there is nothing to do
    //
    if ( dwLastError != ERROR_SUCCESS )
        goto Cleanup;

    if (dwNeeded > MAX_STATIC_ALLOC) {

        if (pszBuf = (LPWSTR) LocalAlloc(LPTR, dwNeeded)) {

            bAllocBufferEnum = TRUE;
            if (EnumPrinterKeyW(hPrinter,
                                L"CopyFiles",
                                pszBuf,
                                dwNeeded,
                                &dwNeeded) != ERROR_SUCCESS) {
                goto Cleanup;
            }

        } else goto Cleanup;
    }

    for ( psz = (LPWSTR) pszBuf ; *psz ; psz += wcslen(psz) + 1 ) {

        if ( wcslen(psz) + wcslen(L"CopyFiles") + 2
                            > sizeof(szKey)/sizeof(szKey[0]) )
            continue;

        if (FAILED(StringCchPrintf(szKey, MAX_PATH, L"CopyFiles\\%s", psz)))
        {
            continue;
        }

        bAllocBufferGPD = FALSE;
        pszModule = (LPTSTR) btBufferGPD;
        ZeroMemory(pszModule, MAX_STATIC_ALLOC);

        dwLastError = GetPrinterDataExW(hPrinter,
                                        szKey,
                                        L"Module",
                                        &dwType,
                                        (LPBYTE) pszModule,
                                        MAX_STATIC_ALLOC,
                                        &dwNeeded);

        if (dwLastError != ERROR_SUCCESS) {
            continue;
        }

        if (dwNeeded > MAX_STATIC_ALLOC) {

            if (pszModule = (LPWSTR) LocalAlloc(LPTR, dwNeeded)) {

                bAllocBufferGPD = TRUE;
                dwLastError = GetPrinterDataExW(hPrinter,
                                                szKey,
                                                L"Module",
                                                &dwType,
                                                (LPBYTE) pszModule,
                                                MAX_STATIC_ALLOC,
                                                &dwNeeded);

                if (dwLastError != ERROR_SUCCESS) {
                    LocalFree((LPBYTE)pszModule);
                    continue;
                }

            } else continue;
        }

        CopyFileEventForAKey(hPrinter, pszPrinterName, pszModule,
                             szKey, dwEvent);

        if (bAllocBufferGPD) {
            LocalFree((LPBYTE)pszModule);
        }
    }

Cleanup:

    ClosePrinter(hPrinter);

    if (bAllocBufferEnum) {
        LocalFree((LPBYTE)pszBuf);
    }
    return;
}



BOOL
AddPrinterConnectionW(
    LPWSTR   pName
)
{
    BOOL    ReturnValue;
    DWORD   LastError;
    HANDLE  hPrinter, hModule;
    FARPROC pfn;

    RpcTryExcept {

        if (LastError = RpcAddPrinterConnection(pName)) {
            SetLastError(LastError);
            ReturnValue = FALSE;
        } else
            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue=FALSE;

    } RpcEndExcept

    if ( ReturnValue ) {

        SpoolerPrinterEvent( pName, PRINTER_EVENT_ADD_CONNECTION, 0, (LPARAM)NULL, &LastError );
        DoCopyFileEventForAllKeys(pName, COPYFILE_EVENT_ADD_PRINTER_CONNECTION);
    }

   return ReturnValue;
}

BOOL
DeletePrinterConnectionW(
    LPWSTR   pName
)
{
    BOOL    ReturnValue;
    DWORD   LastError;

    SpoolerPrinterEvent( pName, PRINTER_EVENT_DELETE_CONNECTION, 0, (LPARAM)NULL, &LastError );
    DoCopyFileEventForAllKeys(pName, COPYFILE_EVENT_DELETE_PRINTER_CONNECTION);

    RpcTryExcept {

        //
        // We are deliberately overwriting the LastError from SpoolerPrinterEvent because
        // we dont use that returned error code.
        //
        if (LastError = RpcDeletePrinterConnection(pName)) {
            SetLastError(LastError);
            ReturnValue = FALSE;
        } else
            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue=FALSE;

    } RpcEndExcept

   return ReturnValue;
}

BOOL
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    BOOL  ReturnValue = FALSE;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    PPRINTER_INFO_2     pPrinterInfo2;
    PPRINTER_INFO_3     pPrinterInfo3;
    PRINTER_INFO_6      PrinterInfo6;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    PVOID               pNewSecurityDescriptor = NULL;
    DWORD               sedlen = 0;
    PDEVMODE pDevModeWow = NULL;
    DWORD dwSize = 0;
    UINT  cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SecurityContainer.cbBuf = 0;
    SecurityContainer.pSecurity = NULL;

    switch (Level) {

    case STRESSINFOLEVEL:

        //
        // Internally we treat the Level 0, Command PRINTER_CONTROL_SET_STATUS
        // as Level 6 since level 0 could be STRESS_INFO (for rpc)
        //
        if ( Command == PRINTER_CONTROL_SET_STATUS ) {

            PrinterInfo6.dwStatus = (DWORD)(ULONG_PTR)pPrinter;
            pPrinter = (LPBYTE)&PrinterInfo6;
            Command = 0;
            Level   = 6;
        }
        break;

    case 2:

        pPrinterInfo2 = (PPRINTER_INFO_2)pPrinter;

        if (pPrinterInfo2 == NULL) {

            DBGMSG(DBG_TRACE, ("Error: SetPrinter pPrinterInfo2 is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }

        //
        // If valid (non-NULL and properly formatted), then update the
        // per-user DevMode.  Note that we don't remove the per-user DevMode
        // if this is NULL--client should user INFO_LEVEL_9 instead.
        //
        if( BoolFromHResult(SplIsValidDevmodeNoSizeW( pPrinterInfo2->pDevMode ))){

            //
            // We won't setup the container, since setting a DevMode
            // with INFO_2 doesn't change the global default.
            // Use INFO_8 instead.
            //
            pDevModeWow = pPrinterInfo2->pDevMode;

            DevModeContainer.cbBuf = pPrinterInfo2->pDevMode->dmSize +
                                     pPrinterInfo2->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo2->pDevMode;

        }

        if (pPrinterInfo2->pSecurityDescriptor) {

            //
            // We must construct a self relative security descriptor from
            // whatever we get as input: If we get an Absolute SD we should
            // convert it to a self-relative one. (this is a given) and we
            // should also convert any self -relative input SD into a a new
            // self relative security descriptor; this will take care of
            // any holes in the Dacl or the Sacl in the self-relative sd
            //

            pNewSecurityDescriptor = BuildInputSD(pPrinterInfo2->pSecurityDescriptor,
                                                    &sedlen);
            if (pNewSecurityDescriptor) {
                SecurityContainer.cbBuf = sedlen;
                SecurityContainer.pSecurity = pNewSecurityDescriptor;
            }

        }
        break;

    case 3:

        pPrinterInfo3 = (PPRINTER_INFO_3)pPrinter;

        if (pPrinterInfo3 == NULL) {

            DBGMSG(DBG_TRACE, ("Error: SetPrinter pPrinterInfo3 is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }

        if (pPrinterInfo3->pSecurityDescriptor) {

            //
            // We must construct a self relative security descriptor from
            // whatever we get as input: If we get an Absolute SD we should
            // convert it to a self-relative one. (this is a given) and we
            // should also convert any self -relative input SD into a a new
            // self relative security descriptor; this will take care of
            // any holes in the Dacl or the Sacl in the self-relative sd
            //

            pNewSecurityDescriptor = BuildInputSD(pPrinterInfo3->pSecurityDescriptor,
                                                    &sedlen);
            if (pNewSecurityDescriptor) {
                SecurityContainer.cbBuf = sedlen;
                SecurityContainer.pSecurity = pNewSecurityDescriptor;
            }
        }
        break;

    case 4:
    case 5:
        if ( pPrinter == NULL ) {

            DBGMSG(DBG_TRACE,("Error SetPrinter pPrinter is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
        break;

    case 6:
        if ( pPrinter == NULL ) {

            DBGMSG(DBG_TRACE,("Error SetPrinter pPrinter is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
        break;

    case 7:
        if ( pPrinter == NULL ) {

            DBGMSG(DBG_TRACE,("Error SetPrinter pPrinter is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }

        break;

    case 8:
    {
        PPRINTER_INFO_8 pPrinterInfo8;

        //
        // Global DevMode
        //
        pPrinterInfo8 = (PPRINTER_INFO_8)pPrinter;

        if( !pPrinterInfo8 || !BoolFromHResult(SplIsValidDevmodeNoSizeW( pPrinterInfo8->pDevMode ))){

            DBGMSG(DBG_TRACE,("Error SetPrinter 8 pPrinter\n"));
            SetLastError( ERROR_INVALID_PARAMETER );
            goto Done;
        }

        pDevModeWow = pPrinterInfo8->pDevMode;

        DevModeContainer.cbBuf = pPrinterInfo8->pDevMode->dmSize +
                                 pPrinterInfo8->pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo8->pDevMode;

        break;
    }
    case 9:
    {
        PPRINTER_INFO_9 pPrinterInfo9;

        //
        // Per-user DevMode
        //
        pPrinterInfo9 = (PPRINTER_INFO_9)pPrinter;

        //
        // Update the per-user DevMode if it's a valid DevMode,
        // or it is NULL, which indicates that the per-user DevMode
        // should be removed.
        //
        if( !pPrinterInfo9 ||
            (  pPrinterInfo9->pDevMode &&
               !BoolFromHResult(SplIsValidDevmodeNoSizeW( pPrinterInfo9->pDevMode )))){

            DBGMSG(DBG_TRACE,("Error SetPrinter 9 pPrinter\n"));
            SetLastError( ERROR_INVALID_PARAMETER );
            goto Done;
        }

        if( pPrinterInfo9->pDevMode ){

            pDevModeWow = pPrinterInfo9->pDevMode;

            DevModeContainer.cbBuf = pPrinterInfo9->pDevMode->dmSize +
                                     pPrinterInfo9->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo9->pDevMode;
        }

        break;
    }
    default:

        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    do {

        RpcTryExcept {

            if (ReturnValue = RpcSetPrinter(
                                  pSpool->hPrinter,
                                  (PPRINTER_CONTAINER)&PrinterContainer,
                                  (PDEVMODE_CONTAINER)&DevModeContainer,
                                  (PSECURITY_CONTAINER)&SecurityContainer,
                                  Command)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    //
    // Need to write DevMode to registry so that dos apps doing
    // ExtDeviceMode can pick up the new devmode
    //
    if( ReturnValue && pDevModeWow ){

        if( !WriteCurDevModeToRegistry( pSpool->pszPrinter,
                                        pDevModeWow )){
            DBGMSG( DBG_WARN,
                    ( "Write wow DevMode failed: %d\n", GetLastError( )));
        }

        //
        // Per-user DevMode is handled in the client's spoolsv process.
        //
    }


    //
    // Did we allocate memory for a new self-relative SD?
    // If we did, let's free it.
    //
    if (pNewSecurityDescriptor) {
        LocalFree(pNewSecurityDescriptor);
    }

Done:
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    SIZE_T  cbStruct;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 3:
        pFieldInfo = PrinterInfo3Fields;
        cbStruct = sizeof(PRINTER_INFO_3);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    case 6:
        pFieldInfo = PrinterInfo6Fields;
        cbStruct = sizeof(PRINTER_INFO_6);
        break;

    case 7:
        pFieldInfo = PrinterInfo7Fields;
        cbStruct = sizeof(PRINTER_INFO_7);
        break;

    case 8:
        pFieldInfo = PrinterInfo8Fields;
        cbStruct = sizeof(PRINTER_INFO_8);
        break;

    case 9:
        pFieldInfo = PrinterInfo9Fields;
        cbStruct = sizeof(PRINTER_INFO_9);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    if (pPrinter)
        memset(pPrinter, 0, cbBuf);

    do {

        RpcTryExcept {

            if (ReturnValue = RpcGetPrinter(pSpool->hPrinter, Level, pPrinter, cbBuf, pcbNeeded)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pPrinter) {
                    ReturnValue = MarshallUpStructure(pPrinter, pFieldInfo, cbStruct, RPC_CALL);
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));
Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetOSVersion(
    IN     LPCTSTR          pszServerName,     OPTIONAL
    OUT    OSVERSIONINFO    *pOSVer
    )
{
    DWORD dwStatus  = ERROR_SUCCESS;

    dwStatus = pOSVer ? S_OK : ERROR_INVALID_PARAMETER;
        
    if (ERROR_SUCCESS == dwStatus)
    { 
        ZeroMemory(pOSVer, sizeof(OSVERSIONINFO));       
        pOSVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if(!pszServerName || !*pszServerName)  // allow string to be empty?
        {
            dwStatus = GetVersionEx((POSVERSIONINFO) pOSVer) ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            HANDLE           hPrinter  = NULL;
            DWORD            dwNeeded  = 0;
            DWORD            dwType    = REG_BINARY;
            PRINTER_DEFAULTS Defaults  = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            dwStatus = OpenPrinter((LPTSTR) pszServerName, &hPrinter, &Defaults) ? ERROR_SUCCESS : GetLastError();
            
            //
            // Get the os version from the remote spooler.
            //
            if (ERROR_SUCCESS == dwStatus) 
            {
                dwStatus = GetPrinterData(hPrinter,
                                          SPLREG_OS_VERSION,
                                          &dwType,
                                          (PBYTE)pOSVer,
                                          sizeof(OSVERSIONINFO),
                                          &dwNeeded);
            }
             
            if (ERROR_INVALID_PARAMETER == dwStatus)
            {
                //
                // Assume that we're on NT4 as it doesn't support SPLREG_OS_VERSION
                // at it's the only OS that doesn't that could land up in this remote code path.
                //
                dwStatus = ERROR_SUCCESS;
                pOSVer->dwMajorVersion = 4;
                pOSVer->dwMinorVersion = 0;
            }
            
            if (NULL != hPrinter )
            {
                ClosePrinter(hPrinter);
            } 
        }       
    }

    SetLastError(dwStatus);
    return ERROR_SUCCESS == dwStatus ? TRUE : FALSE ;
}

BOOL
AddPrinterDriverExW(
    LPWSTR   pName,
    DWORD    Level,
    PBYTE    lpbDriverInfo,
    DWORD    dwFileCopyFlags
)
{
    BOOL  ReturnValue;
    DRIVER_CONTAINER   DriverContainer;
    BOOL bDefaultEnvironmentUsed = FALSE;
    LPRPC_DRIVER_INFO_4W    pRpcDriverInfo4 = NULL;
    DRIVER_INFO_4          *pDriverInfo4    = NULL;
    LPRPC_DRIVER_INFO_6W    pRpcDriverInfo6 = NULL;
    DRIVER_INFO_6          *pDriverInfo6    = NULL;
    BOOL                    bShowUI         = FALSE;     
    BOOL                    bMapUnknownPrinterDriverToBlockedDriver = FALSE;
    OSVERSIONINFO           OsVer;
    LPWSTR                  pStr;

    //
    // Validate Input Parameters
    //
    if (!lpbDriverInfo) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    DriverContainer.Level = Level;

    switch (Level) {

    case 2:

        if ( (((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment == NULL ) ||
            (*((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment == L'\0') ) {

            bDefaultEnvironmentUsed = TRUE;
            ((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment = szEnvironment;
        }

        DriverContainer.DriverInfo.Level2 = (DRIVER_INFO_2 *)lpbDriverInfo;

        break;

    case 3:
    case 4:

        //
        // DRIVER_INFO_4 is 3 + pszzPreviousNames field
        // We will use RPC_DRIVER_INFO_4 for both cases
        //
        DriverContainer.Level = Level;

        if ( (((LPDRIVER_INFO_4)lpbDriverInfo)->pEnvironment == NULL ) ||
            (*((LPDRIVER_INFO_4)lpbDriverInfo)->pEnvironment == L'\0') ) {

            bDefaultEnvironmentUsed = TRUE;
            ((LPDRIVER_INFO_4)lpbDriverInfo)->pEnvironment = szEnvironment;
        }

        if ( !(pRpcDriverInfo4=AllocSplMem(sizeof(RPC_DRIVER_INFO_4W))) ) {

            return FALSE;
        }

        pDriverInfo4                        = (DRIVER_INFO_4 *)lpbDriverInfo;
        pRpcDriverInfo4->cVersion           = pDriverInfo4->cVersion;
        pRpcDriverInfo4->pName              = pDriverInfo4->pName;
        pRpcDriverInfo4->pEnvironment       = pDriverInfo4->pEnvironment;
        pRpcDriverInfo4->pDriverPath        = pDriverInfo4->pDriverPath;
        pRpcDriverInfo4->pDataFile          = pDriverInfo4->pDataFile;
        pRpcDriverInfo4->pConfigFile        = pDriverInfo4->pConfigFile;
        pRpcDriverInfo4->pHelpFile          = pDriverInfo4->pHelpFile;
        pRpcDriverInfo4->pDependentFiles    = pDriverInfo4->pDependentFiles;
        pRpcDriverInfo4->pMonitorName       = pDriverInfo4->pMonitorName;
        pRpcDriverInfo4->pDefaultDataType   = pDriverInfo4->pDefaultDataType;

        //
        // Set the char count of the mz string.
        // NULL   --- 0
        // szNULL --- 1
        // string --- number of characters in the string including the last '\0'
        //
        if ( pStr = pDriverInfo4->pDependentFiles ) {

            while ( *pStr )
               pStr += wcslen(pStr) + 1;
            pRpcDriverInfo4->cchDependentFiles
                                = (DWORD) (pStr - pDriverInfo4->pDependentFiles + 1);
        } else {

            pRpcDriverInfo4->cchDependentFiles = 0;
        }

        pRpcDriverInfo4->cchPreviousNames = 0;
        if ( Level == 4                                 &&
             (pStr = pDriverInfo4->pszzPreviousNames)   &&
             *pStr ) {

            pRpcDriverInfo4->pszzPreviousNames = pStr;

            while ( *pStr )
                pStr += wcslen(pStr) + 1;

            pRpcDriverInfo4->cchPreviousNames
                                = (DWORD) (pStr - pDriverInfo4->pszzPreviousNames + 1);
        }

        DriverContainer.DriverInfo.Level4 = pRpcDriverInfo4;
        break;

    case 6:

        DriverContainer.Level = Level;

        if ( (((LPDRIVER_INFO_6)lpbDriverInfo)->pEnvironment == NULL ) ||
            (*((LPDRIVER_INFO_6)lpbDriverInfo)->pEnvironment == L'\0') ) {

            bDefaultEnvironmentUsed = TRUE;
            ((LPDRIVER_INFO_6)lpbDriverInfo)->pEnvironment = szEnvironment;
        }

        if ( !(pRpcDriverInfo6=AllocSplMem(sizeof(RPC_DRIVER_INFO_6W))) ) {

            return FALSE;
        }

        pDriverInfo6                        = (DRIVER_INFO_6 *)lpbDriverInfo;
        pRpcDriverInfo6->cVersion           = pDriverInfo6->cVersion;
        pRpcDriverInfo6->pName              = pDriverInfo6->pName;
        pRpcDriverInfo6->pEnvironment       = pDriverInfo6->pEnvironment;
        pRpcDriverInfo6->pDriverPath        = pDriverInfo6->pDriverPath;
        pRpcDriverInfo6->pDataFile          = pDriverInfo6->pDataFile;
        pRpcDriverInfo6->pConfigFile        = pDriverInfo6->pConfigFile;
        pRpcDriverInfo6->pHelpFile          = pDriverInfo6->pHelpFile;
        pRpcDriverInfo6->pDependentFiles    = pDriverInfo6->pDependentFiles;
        pRpcDriverInfo6->pMonitorName       = pDriverInfo6->pMonitorName;
        pRpcDriverInfo6->pDefaultDataType   = pDriverInfo6->pDefaultDataType;
        pRpcDriverInfo6->ftDriverDate       = pDriverInfo6->ftDriverDate;
        pRpcDriverInfo6->dwlDriverVersion   = pDriverInfo6->dwlDriverVersion;
        pRpcDriverInfo6->pMfgName           = pDriverInfo6->pszMfgName;
        pRpcDriverInfo6->pOEMUrl            = pDriverInfo6->pszOEMUrl;
        pRpcDriverInfo6->pHardwareID        = pDriverInfo6->pszHardwareID;
        pRpcDriverInfo6->pProvider          = pDriverInfo6->pszProvider;


        //
        // Set the char count of the mz string.
        // NULL   --- 0
        // szNULL --- 1
        // string --- number of characters in the string including the last '\0'
        //
        if ( pStr = pDriverInfo6->pDependentFiles ) {

            while ( *pStr )
               pStr += wcslen(pStr) + 1;
            pRpcDriverInfo6->cchDependentFiles = (DWORD) (pStr - pDriverInfo6->pDependentFiles + 1);
        } else {

            pRpcDriverInfo6->cchDependentFiles = 0;
        }

        pRpcDriverInfo6->cchPreviousNames = 0;
        if ( Level == 6                                 &&
             (pStr = pDriverInfo6->pszzPreviousNames)   &&
             *pStr ) {

            pRpcDriverInfo6->pszzPreviousNames = pStr;

            while ( *pStr )
                pStr += wcslen(pStr) + 1;

            pRpcDriverInfo6->cchPreviousNames
                                = (DWORD) (pStr - pDriverInfo6->pszzPreviousNames + 1);
        }

        DriverContainer.DriverInfo.Level6 = pRpcDriverInfo6;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // The driver path is at the same location in all of the DRIVER_INFO_X
    // structures, as is the driver name. If this changes, the
    // CheckForBlockedDrivers() call will have to do different things
    // depending on the level.
    //
    SPLASSERT(Level >= 2 && Level <= 6);

    //
    // APD_NO_UI has no meaning at the server side, so clear it before the 
    // RPC call.
    //
    bShowUI = !(dwFileCopyFlags & APD_NO_UI); 
    dwFileCopyFlags &= ~APD_NO_UI;
    
    //
    // GetOSVersionEx has set last error correctly.
    //
    ReturnValue = GetOSVersion(pName, &OsVer);
    if (!ReturnValue) {
        goto Cleanup;
    }
    
    //
    // If the server is Whistler or later, instruct the spooler to 
    // return the actual blocking code ERROR_PRINTER_DRIVER_BLOCKED or
    // ERROR_PRINTER_DRIVER_WARNED. 
    //
    // A win2k server returns ERROR_UNKNOWN_PRINTER_DRIVER for blocked 
    // driver, so we need to re-map this code to the correct blocking 
    // code.
    //
    if (OsVer.dwMajorVersion >= 5 && OsVer.dwMinorVersion > 0) 
    {
        dwFileCopyFlags |= APD_RETURN_BLOCKING_STATUS_CODE;
    }
    else 
    {
        //
        // APD_DONT_SET_CHECKPOINT has no meaning at the server side, so clear it 
        // before the RPC call.
        //
        dwFileCopyFlags &= ~APD_DONT_SET_CHECKPOINT;

        dwFileCopyFlags &= ~APD_INSTALL_WARNED_DRIVER;

        if (OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion == 0) 
        {
            bMapUnknownPrinterDriverToBlockedDriver = TRUE;
        }
    }
    
    RpcTryExcept {
        ReturnValue = RpcAddPrinterDriverEx(pName,
                                            &DriverContainer,
                                            dwFileCopyFlags);  
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        ReturnValue = TranslateExceptionCode(RpcExceptionCode());
    } RpcEndExcept
    
    if (bMapUnknownPrinterDriverToBlockedDriver && (ERROR_UNKNOWN_PRINTER_DRIVER == ReturnValue))
    {
        ReturnValue = ERROR_PRINTER_DRIVER_BLOCKED;
    }

    //
    // Popup UI but do not offer replacement for all cases.
    //     
    if (bShowUI && ((ERROR_PRINTER_DRIVER_BLOCKED == ReturnValue) || (ERROR_PRINTER_DRIVER_WARNED == ReturnValue))) {             
        ReturnValue = ShowPrintUpgUI(ReturnValue);
        
        //
        // For warned driver and the user instructs to install it, retry it
        // with APD_INSTALL_WARNED_DRIVER.
        //                
        if ((ERROR_SUCCESS == ReturnValue)) {
             dwFileCopyFlags |= APD_INSTALL_WARNED_DRIVER;            
             RpcTryExcept {
                 ReturnValue = RpcAddPrinterDriverEx(pName,
                                                     &DriverContainer,
                                                     dwFileCopyFlags);
            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {        
                ReturnValue = TranslateExceptionCode(RpcExceptionCode());        
            } RpcEndExcept
        }
    }    
     
    if (ERROR_SUCCESS != ReturnValue) {
        SetLastError(ReturnValue);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
         
    if (bDefaultEnvironmentUsed) {
        if ( Level == 2 )
            ((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment = NULL;
        else //Level == 3
            ((LPDRIVER_INFO_3)lpbDriverInfo)->pEnvironment = NULL;
    }

Cleanup:

    FreeSplMem(pRpcDriverInfo4);

    FreeSplMem(pRpcDriverInfo6);

    return ReturnValue;
}

BOOL
AddDriverCatalog(
    HANDLE   hPrinter,
    DWORD    dwLevel,
    VOID     *pvDriverInfCatInfo,
    DWORD    dwCatalogCopyFlags
    )
{
    HRESULT hRetval = E_FAIL;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    DRIVER_INFCAT_CONTAINER DriverInfCatContainer;

    hRetval = pvDriverInfCatInfo && hPrinter ? S_OK : E_INVALIDARG; 
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = eProtectHandle(hPrinter, FALSE) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        switch (dwLevel) 
        {    
        case 1:
                    
            DriverInfCatContainer.dwLevel = dwLevel;
            DriverInfCatContainer.DriverInfCatInfo.pDriverInfCatInfo1 = (LPRPC_DRIVER_INFCAT_INFO_1) pvDriverInfCatInfo;
    
            break;

        case 2:

            DriverInfCatContainer.dwLevel = dwLevel;
            DriverInfCatContainer.DriverInfCatInfo.pDriverInfCatInfo2 = (LPRPC_DRIVER_INFCAT_INFO_2) pvDriverInfCatInfo;
        
            break;
    
        default:
            
            hRetval = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);
            
            break;
        }

        if (SUCCEEDED(hRetval)) 
        {    
            do 
            {        
                RpcTryExcept 
                {
                    hRetval = HResultFromWin32(RpcAddDriverCatalog(pSpool->hPrinter,
                                                                   &DriverInfCatContainer,
                                                                   dwCatalogCopyFlags)); 
                } 
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
                {
                    hRetval = HResultFromWin32(TranslateExceptionCode(RpcExceptionCode()));
                } 
                RpcEndExcept
    
            } while (FAILED(hRetval) && HRESULT_FACILITY(hRetval) == FACILITY_WIN32 &&
                     IsInvalidHandleError(HRESULT_CODE(hRetval)) &&
                     (cRetry++ < MAX_RETRY_INVALID_HANDLE) &&
                     RevalidateHandle( pSpool ));
        }
        
        vUnprotectHandle(hPrinter);
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}

BOOL
AddPrinterDriverW(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   lpbDriverInfo
)
{
    return AddPrinterDriverExW(pName, Level, lpbDriverInfo, APD_COPY_NEW_FILES);
}


BOOL
EnumPrinterDriversW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcEnumPrinterDrivers(pName, pEnvironment, Level,
                                                pDriverInfo, cbBuf,
                                                pcbNeeded, pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pDriverInfo) {

                ReturnValue = MarshallUpStructuresArray(pDriverInfo, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    SIZE_T  cbStruct;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwMajorVersionNeeded = (DWORD)-1, dwMinorVersionNeeded = (DWORD)-1;
    DWORD dwServerMajorVersion;
    DWORD dwServerMinorVersion;
    UINT cRetry = 0;
    CALL_ROUTE Route;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        if (pDriverInfo)
            memset(pDriverInfo, 0, cbBuf);

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = RunInWOW64() ? szIA64Environment : szEnvironment;
        else if ( !lstrcmp(pEnvironment, cszWin95Environment) )
            dwMajorVersionNeeded = dwMinorVersionNeeded = 0;

        if (bLoadedBySpooler && fpYGetPrinterDriver2 && pSpool->hSplPrinter) {

            Route = NATIVE_CALL;

            ReturnValue = (*fpYGetPrinterDriver2)(pSpool->hSplPrinter,
                                                  pEnvironment,
                                                  Level, pDriverInfo, cbBuf,
                                                  pcbNeeded,
                                                  dwMajorVersionNeeded,
                                                  dwMinorVersionNeeded,
                                                  &dwServerMajorVersion,
                                                  &dwServerMinorVersion,
                                                  Route);

            if (ERROR_SUCCESS != ReturnValue) {

                SetLastError(ReturnValue);           
                ReturnValue = FALSE;

            } else {
            
                ReturnValue = TRUE;   
        
                if (pDriverInfo) {

                    if (!MarshallUpStructure(pDriverInfo, pFieldInfo, cbStruct, Route)) {

                        ReturnValue = FALSE;                
                        break;
                    }
                }  
            }

        } else {

            RpcTryExcept {

                Route = RPC_CALL;

                ReturnValue = RpcGetPrinterDriver2(pSpool->hPrinter,
                                                   pEnvironment,
                                                   Level, pDriverInfo, cbBuf,
                                                   pcbNeeded,
                                                   dwMajorVersionNeeded,
                                                   dwMinorVersionNeeded,
                                                   &dwServerMajorVersion,
                                                   &dwServerMinorVersion);                   

                if (ERROR_SUCCESS != ReturnValue) {

                    SetLastError(ReturnValue);           
                    ReturnValue = FALSE;
    
                } else {
                
                    ReturnValue = TRUE;   
            
                    if (pDriverInfo) {
    
                        if (!MarshallUpStructure(pDriverInfo, pFieldInfo, cbStruct, Route)) {
    
                            ReturnValue = FALSE;                
                            break;
                        }
                    }  
                }

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                  ReturnValue = FALSE;

            } RpcEndExcept
        }

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));
Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetPrinterDriverDirectoryW(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = pEnvironment = RunInWOW64() ? szIA64Environment : szEnvironment;

        if (bLoadedBySpooler && fpYGetPrinterDriverDirectory) {

            ReturnValue = (*fpYGetPrinterDriverDirectory)(pName, pEnvironment,
                                                          Level,
                                                          pDriverDirectory,
                                                          cbBuf, pcbNeeded,
                                                          FALSE);
        } else {

            ReturnValue = RpcGetPrinterDriverDirectory(pName,
                                                       pEnvironment,
                                                       Level,
                                                       pDriverDirectory,
                                                       cbBuf, pcbNeeded);
        }

        if (ReturnValue) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        DWORD Error;
          
        Error = TranslateExceptionCode(RpcExceptionCode());

        if (Error == RPC_S_SERVER_UNAVAILABLE)
        {
            ReturnValue = BuildSpoolerObjectPath(gszPrinterDriversPath, 
                                                 pName, 
                                                 pEnvironment, 
                                                 Level, 
                                                 pDriverDirectory, 
                                                 cbBuf, 
                                                 pcbNeeded); 
        }
        else
        {
            SetLastError(Error);
            ReturnValue = FALSE;
        }

    } RpcEndExcept

    return ReturnValue;
}


BOOL
DeletePrinterDriverExW(
   LPWSTR     pName,
   LPWSTR     pEnvironment,
   LPWSTR     pDriverName,
   DWORD      dwDeleteFlag,
   DWORD      dwVersionNum
)
{
    BOOL  ReturnValue;

    if (!pDriverName || !*pDriverName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrinterDriverEx(pName,
                                                   pEnvironment,
                                                   pDriverName,
                                                   dwDeleteFlag,
                                                   dwVersionNum)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
DeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
)
{
    BOOL  ReturnValue;

    if (!pDriverName || !*pDriverName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrinterDriver(pName,
                                                 pEnvironment,
                                                 pDriverName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
AddPerMachineConnectionW(
   LPCWSTR     pServer,
   LPCWSTR     pPrinterName,
   LPCWSTR     pPrintServer,
   LPCWSTR     pProvider
)
{
    BOOL  ReturnValue;
    WCHAR DummyStr[] = L"";

    if (!pPrinterName || !*pPrinterName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pPrintServer || !*pPrintServer) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    //
    // pProvider is an optional parameter and can be NULL. Since RPC does not
    // accept NULL pointers we have to pass some dummy pointer to szNULL.
    //
    if (!pProvider) {
       pProvider = (LPCWSTR) DummyStr;
    }


    RpcTryExcept {

        if (ReturnValue = RpcAddPerMachineConnection((LPWSTR) pServer,
                                                     pPrinterName,
                                                     pPrintServer,
                                                     pProvider)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePerMachineConnectionW(
   LPCWSTR     pServer,
   LPCWSTR     pPrinterName
)
{
    BOOL  ReturnValue;

    if (!pPrinterName || !*pPrinterName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (ReturnValue = RpcDeletePerMachineConnection((LPWSTR) pServer,
                                                        pPrinterName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPerMachineConnectionsW(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct, index;
    FieldInfo *pFieldInfo;

    pFieldInfo = PrinterInfo4Fields;
    cbStruct = sizeof(PRINTER_INFO_4);


    RpcTryExcept {

        if (pPrinterEnum)
            memset(pPrinterEnum, 0, cbBuf);

        if (ReturnValue = RpcEnumPerMachineConnections((LPWSTR) pServer,
                                                       pPrinterEnum,
                                                       cbBuf,
                                                       pcbNeeded,
                                                       pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {
            ReturnValue = TRUE;
            if (pPrinterEnum) {

                ReturnValue = MarshallUpStructuresArray(pPrinterEnum, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
AddPrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
)
{
    BOOL ReturnValue;

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if (!pPathName || !*pPathName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcAddPrintProcessor(pName, pEnvironment, pPathName,
                                               pPrintProcessorName)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPrintProcessorsW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcEnumPrintProcessors(pName, pEnvironment, Level,
                                                pPrintProcessorInfo, cbBuf,
                                                pcbNeeded, pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPrintProcessorInfo) {

                ReturnValue = MarshallUpStructuresArray(pPrintProcessorInfo, *pcReturned,
                                                        pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
GetPrintProcessorDirectoryW(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = pEnvironment = RunInWOW64() ? szIA64Environment : szEnvironment;

        if (ReturnValue = RpcGetPrintProcessorDirectory(pName,
                                                        pEnvironment,
                                                        Level,
                                                        pPrintProcessorInfo,
                                                        cbBuf,
                                                        pcbNeeded)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        DWORD Error;
          
        Error = TranslateExceptionCode(RpcExceptionCode());

        if (Error == RPC_S_SERVER_UNAVAILABLE)
        {
            ReturnValue = BuildSpoolerObjectPath(gszPrintProcessorsPath, 
                                                 pName, 
                                                 pEnvironment, 
                                                 Level, 
                                                 pPrintProcessorInfo, 
                                                 cbBuf, 
                                                 pcbNeeded); 
        }
        else
        {
            SetLastError(Error);
            ReturnValue = FALSE;
        }

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPrintProcessorDatatypesW(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (ReturnValue = RpcEnumPrintProcessorDatatypes(pName,
                                                         pPrintProcessorName,
                                                         Level,
                                                         pDatatypes,
                                                         cbBuf,
                                                         pcbNeeded,
                                                         pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pDatatypes) {

                ReturnValue = MarshallUpStructuresArray(pDatatypes, *pcReturned,
                                                        pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


DWORD
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    DWORD        ReturnValue      = 0;
    BOOL         EverythingWorked = FALSE;
    BOOL         PrintingToFile   = FALSE;
    PSPOOL       pSpool           = (PSPOOL)hPrinter;
    PDOC_INFO_1  pDocInfo1        = NULL;
    PDOC_INFO_3  pDocInfo3        = NULL;
    LPBYTE       pBuffer          = NULL;
    DWORD        cbBuffer         = MAX_STATIC_ALLOC;
    DWORD        cbNeeded;
    BOOL         bReturn; 
    
    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if ( pSpool->Status & SPOOL_STATUS_STARTDOC ) {

        SetLastError(ERROR_INVALID_PRINTER_STATE);
        goto Done;
    }

    
    DBGMSG(DBG_TRACE,("Entered StartDocPrinterW client side  hPrinter = %x\n", hPrinter));

    //
    // level 2 is supported on win95 and not on NT
    //
    switch (Level) {
    case 1:
        pDocInfo1 = (PDOC_INFO_1)pDocInfo;
        break;

    case 3:
        pDocInfo1 = (PDOC_INFO_1)pDocInfo;
        pDocInfo3 = (PDOC_INFO_3)pDocInfo;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    pBuffer = AllocSplMem(cbBuffer);

    if (!pBuffer) {
        goto Done;
    }
    
    try {

        //
        // Earlier on, if we had a non-null string, we assumed it to be
        // printing to file. Print to file will not go thru the client-side
        // optimization code. Now gdi is passing us  pOutputFile name
        // irrespective of whether it is file or not. We must determine if
        // pOutputFile is really a file name
        //

        if (pDocInfo1->pOutputFile &&
            (*(pDocInfo1->pOutputFile) != L'\0') &&
            IsaFileName(pDocInfo1->pOutputFile, (LPWSTR)pBuffer, cbBuffer / sizeof(WCHAR))){

            PrintingToFile = TRUE;
        }
        
        if (!PrintingToFile &&
            !((Level == 3) && (pDocInfo3->dwFlags & DI_MEMORYMAP_WRITE)) &&
            AddJobW(hPrinter, 1, pBuffer, cbBuffer, &cbNeeded)) {

            PADDJOB_INFO_1 pAddJob = (PADDJOB_INFO_1)pBuffer;

            pSpool->JobId = pAddJob->JobId;
            pSpool->hFile = CreateFile(pAddJob->Path,
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL);

            if (pSpool->hFile != INVALID_HANDLE_VALUE) {

                if (pSpool->JobId == (DWORD)-1) {

                    IO_STATUS_BLOCK Iosb;
                    NTSTATUS Status;
                    QUERY_PRINT_JOB_INFO JobInfo;

                    Status = NtFsControlFile(pSpool->hFile, NULL, NULL, NULL,
                                             &Iosb,
                                             FSCTL_GET_PRINT_ID,
                                             NULL, 0,
                                             &JobInfo, sizeof(JobInfo));

                    if (NT_SUCCESS(Status)) {
                        pSpool->JobId = JobInfo.JobId;
                    }
                }

                ZeroMemory(pBuffer, cbBuffer);

                if (!(bReturn = GetJob(hPrinter, pSpool->JobId, 1, pBuffer, cbBuffer, &cbNeeded))) {

                    if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
                        FreeSplMem(pBuffer) &&
                        (pBuffer = AllocSplMem(cbNeeded))) {
                    
                        //
                        // Update the new size of our work buffer
                        //
                        cbBuffer = cbNeeded;
                        
                        bReturn = GetJob(hPrinter, pSpool->JobId, 1, pBuffer, cbBuffer, &cbNeeded);
                    }
                }

                if (bReturn) {

                    PJOB_INFO_1 pJob = (PJOB_INFO_1)pBuffer;

                    pJob->pDocument = pDocInfo1->pDocName;
                    if (pDocInfo1->pDatatype) {
                        pJob->pDatatype = pDocInfo1->pDatatype;
                    }
                    pJob->Position = JOB_POSITION_UNSPECIFIED;

                    if (SetJob(hPrinter, pSpool->JobId,
                               1, (LPBYTE)pJob, 0))      {

                        EverythingWorked = TRUE;
                    }
                }                                
            }

            if (!PrintingToFile && !EverythingWorked) {

                if (pSpool->hFile != INVALID_HANDLE_VALUE) {
                    if (CloseHandle(pSpool->hFile)) {
                        pSpool->hFile = INVALID_HANDLE_VALUE;
                    }
                }

                SetJob(hPrinter,pSpool->JobId, 0, NULL, JOB_CONTROL_CANCEL);
                ScheduleJob(hPrinter, pSpool->JobId);
                pSpool->JobId = 0;
            }
        }

        if (EverythingWorked) {
            ReturnValue = pSpool->JobId;

        } else {

            UINT cRetry = 0;

            //
            // If it's invalid datatype, fail immediately instead of trying
            // StartDocPrinter.
            //
            if( GetLastError() == ERROR_INVALID_DATATYPE ){

                ReturnValue = 0;

            } else {

                GENERIC_CONTAINER DocInfoContainer;
                DWORD             JobId;

                pSpool->hFile = INVALID_HANDLE_VALUE;
                pSpool->JobId = 0;

                //
                // Level 3 data is required only on the client
                //
                DocInfoContainer.Level = 1;
                DocInfoContainer.pData = pDocInfo;

                do {

                    RpcTryExcept {

                        if (ReturnValue = RpcStartDocPrinter(
                                              pSpool->hPrinter,
                                              (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                              &JobId)) {

                            SetLastError(ReturnValue);
                            ReturnValue = 0;

                        } else

                            ReturnValue = JobId;

                    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                        ReturnValue = 0;

                    } RpcEndExcept

                } while( !ReturnValue &&
                         IsInvalidHandleError(GetLastError()) &&
                         cRetry++ < MAX_RETRY_INVALID_HANDLE &&
                         RevalidateHandle( pSpool ));
            }
        }

        if (ReturnValue) {
            pSpool->Status |= SPOOL_STATUS_STARTDOC;
        }

        //
        // If the tray icon has not been notified, then do so now.  Set
        // the flag so that we won't call it multiple times.
        //
        if( ReturnValue && !( pSpool->Status & SPOOL_STATUS_TRAYICON_NOTIFIED )){
            vUpdateTrayIcon( hPrinter, ReturnValue );
        }

    } except (1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = 0;
    }

Done:

    FreeSplMem(pBuffer);
    
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
StartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    try {

        FlushBuffer(pSpool, NULL);

        RpcTryExcept {

            if (ReturnValue = RpcStartPagePrinter(pSpool->hPrinter)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } except (1) {

        SetLastError(ERROR_INVALID_HANDLE);
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
FlushBuffer(
    PSPOOL  pSpool,
    PDWORD pcbWritten
)
{
    DWORD   ReturnValue = TRUE;
    DWORD   cbWritten = 0;

    SPLASSERT (pSpool != NULL);
    SPLASSERT (pSpool->signature == SP_SIGNATURE);

    DBGMSG(DBG_TRACE, ("FlushBuffer - pSpool %x\n",pSpool));

    if (pSpool->cbBuffer) {

        SPLASSERT(pSpool->pBuffer != NULL);

        DBGMSG(DBG_TRACE, ("FlushBuffer - Number Cached WritePrinters before Flush %d\n", pSpool->cCacheWrite));
        pSpool->cCacheWrite = 0;
        pSpool->cFlushBuffers++;

        if (pSpool->hFile != INVALID_HANDLE_VALUE) {

            //
            // FileIO
            //
            ReturnValue = WriteFile( pSpool->hFile,
                                     pSpool->pBuffer,
                                     pSpool->cbBuffer,
                                     &cbWritten, NULL);

            DBGMSG(DBG_TRACE, ("FlushBuffer - WriteFile pSpool %x hFile %x pBuffer %x cbBuffer %d cbWritten %d\n",
                               pSpool, pSpool->hFile, pSpool->pBuffer, pSpool->cbBuffer, cbWritten));

        } else {

            if (bLoadedBySpooler && fpYWritePrinter && pSpool->hSplPrinter) {

                ReturnValue = (*fpYWritePrinter)(pSpool->hSplPrinter,
                                                 pSpool->pBuffer,
                                                 pSpool->cbBuffer,
                                                 &cbWritten,
                                                 FALSE);
            } else {

                RpcTryExcept {

                    //
                    // RPC IO
                    //
                    ReturnValue = RpcWritePrinter(pSpool->hPrinter,
                                                  pSpool->pBuffer,
                                                  pSpool->cbBuffer,
                                                  &cbWritten);

                } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
                    
                    ReturnValue = TranslateExceptionCode(RpcExceptionCode());;
                    DBGMSG(DBG_WARNING, ("RpcWritePrinter Exception Error %d\n",GetLastError()));

                } RpcEndExcept
            }

            if (ReturnValue) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;
                DBGMSG(DBG_WARNING, ("FlushBuffer - RpcWritePrinter Failed Error %d\n",GetLastError() ));

            } else {
                ReturnValue = TRUE;
                DBGMSG(DBG_TRACE, ("FlushBuffer - RpcWritePrinter Success hPrinter %x pBuffer %x cbBuffer %x cbWritten %x\n",
                                    pSpool->hPrinter, pSpool->pBuffer,
                                    pSpool->cbBuffer, cbWritten));

            }

            //
            // This routine seems messed up.
            // If it doesn't flush the entire buffer, it apparently still
            // returns TRUE.  It correctly updates the buffer pointers
            // so it doesn't send duplicate information, but it
            // doesn't send back bytes written.  When WritePrinter
            // sees success, it assumes that all bytes have been written.
            //

        }

        //
        // We have sent more data to the printer.  If we had any bytes
        // from the previous write, we have just sent part of them to the
        // printer.  Update the cbFlushPending count to reflect the
        // sent bytes.  cbWritten may be > cbFlushPending, since we
        // may have sent new bytes too.
        //
        if (pSpool->cbFlushPending < cbWritten) {
            pSpool->cbFlushPending = 0;
        } else {
            pSpool->cbFlushPending -= cbWritten;
        }

        if (pSpool->cbBuffer <= cbWritten) {

            if ( pSpool->cbBuffer < cbWritten) {


                DBGMSG( DBG_WARNING, ("FlushBuffer cbBuffer %d < cbWritten %d ReturnValue %x LastError %d\n",
                        pSpool->cbBuffer, cbWritten, ReturnValue, GetLastError() ));
            }

            //
            // Successful IO. Empty the cache buffer count
            //
            pSpool->cbBuffer = 0;

        } else if ( cbWritten != 0 ) {

            //
            // Partial IO
            // Adjust the buffer so it contains the data that was not
            // written
            //
            SPLASSERT(pSpool->cbBuffer <= BUFFER_SIZE);
            SPLASSERT(cbWritten <= BUFFER_SIZE);
            SPLASSERT(pSpool->cbBuffer >= cbWritten);

            DBGMSG(DBG_WARNING, ("Partial IO adjusting buffer data\n"));

            MoveMemory(pSpool->pBuffer,
                       pSpool->pBuffer + cbWritten,
                       BUFFER_SIZE - cbWritten);

            pSpool->cbBuffer -= cbWritten;

        }
    }

    DBGMSG(DBG_TRACE, ("FlushBuffer returns %d\n",ReturnValue));

    if (pcbWritten) {
        *pcbWritten = cbWritten;
    }

    if(!pSpool->cOKFlushBuffers                                    &&
       (ReturnValue || (ERROR_PRINT_CANCELLED == GetLastError()))  &&
       cbWritten)
    {
        pSpool->cOKFlushBuffers=1;
    }

    return ReturnValue;
}


BOOL
SeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
    )
{
    DWORD dwReturnValue;
    BOOL bReturnValue = FALSE;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    LARGE_INTEGER liUnused;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if( !pliNewPointer ){
        pliNewPointer = &liUnused;
    }

    if (bLoadedBySpooler && fpYSeekPrinter && pSpool->hSplPrinter) {

        dwReturnValue = (*fpYSeekPrinter)( pSpool->hSplPrinter,
                                           liDistanceToMove,
                                           pliNewPointer,
                                           dwMoveMethod,
                                           bWritePrinter,
                                           FALSE );
    } else {

        RpcTryExcept {

            dwReturnValue = RpcSeekPrinter( pSpool->hPrinter,
                                            liDistanceToMove,
                                            pliNewPointer,
                                            dwMoveMethod,
                                            bWritePrinter );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
    
            dwReturnValue = RpcExceptionCode();

        } RpcEndExcept
    }

    if( dwReturnValue == ERROR_SUCCESS ){
        bReturnValue = TRUE;
    } else {
        SetLastError( dwReturnValue );
    }
    
    vUnprotectHandle( hPrinter );
    return bReturnValue;
}

BOOL
FlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)

/*++
Function Description: FlushPrinter is typically used by the driver to send a burst of zeros
                      to the printer and introduce a delay in the i/o line to the printer.
                      The spooler does not schedule any job for cSleep milliseconds.

Parameters:  hPrinter  - printer handle
             pBuf      - buffer to be sent to the printer
             cbBuf     - size of the buffer
             pcWritten - pointer to return the number of bytes written
             cSleep    - sleep time in milliseconds.

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    DWORD   dwError, cWritten, Buffer;
    BOOL    bReturn = FALSE;

    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (eProtectHandle( hPrinter, FALSE ))
    {
        return FALSE;
    }

    //
    // In case the job was canceled or a printer failure
    // occured before priting any part of the document, we
    // just short circuit and return to prevent any unnecessary
    // delays in returning to the caller.
    //

    if (!pSpool->cOKFlushBuffers)
    {
        bReturn = TRUE;
        goto Done;
    }

    //
    //  Use temp variables since RPC does not take NULL pointers
    //
    if (!pcWritten)
    {
        pcWritten = &cWritten;
    }

    if (!pBuf)
    {
        if (cbBuf == 0)
        {
            pBuf = (LPVOID) &Buffer;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
    }

    if(bLoadedBySpooler && fpYFlushPrinter && pSpool->hSplPrinter)
    {
        dwError = (*fpYFlushPrinter)(pSpool->hSplPrinter,
                                     pBuf,
                                     cbBuf,
                                     pcWritten,
                                     cSleep,
                                     FALSE);
    } else {


        //
        // Rpc to the spooler
        //
        RpcTryExcept {

            dwError = RpcFlushPrinter( pSpool->hPrinter,
                                       pBuf,
                                       cbBuf,
                                       pcWritten,
                                       cSleep );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwError = RpcExceptionCode();

        } RpcEndExcept
    }

    
    if (dwError == ERROR_SUCCESS)
    {
        bReturn = TRUE;
    }
    else
    {
        SetLastError( dwError );
    }

Done:

    vUnprotectHandle( hPrinter );

    return bReturn;
}


BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    )
{
    BOOL    ReturnValue=TRUE, bAllocBuffer = FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    DWORD   cb;
    DWORD   cbWritten = 0;
    DWORD   cTotalWritten = 0;
    LPBYTE  pBuffer = pBuf;
    LPBYTE  pInitialBuf = pBuf;
    PSPOOL  pSpool  = (PSPOOL)hPrinter;
    PJOB_INFO_1  pJob;
    DWORD   cbNeeded;
    DWORD   dwTickCount, dwTickCount1;
    DWORD   FlushPendingDataSize;
    DWORD   ReqTotalDataSize;
    DWORD   ReqToWriteDataSize   = cbBuf;
    DWORD   NumOfCmpltWrts       = 0;


    DBGMSG(DBG_TRACE, ("WritePrinter - hPrinter %x pBuf %x cbBuf %d pcWritten %x\n",
                        hPrinter, pBuf, cbBuf, pcWritten));


    if( eProtectHandle( hPrinter, FALSE ))
    {
        return FALSE;
    }

    if (pSpool && pSpool->Flushed)
    {
        ReturnValue = FALSE;
        goto EndWritePrinter;
    }

    FlushPendingDataSize = pSpool->cbFlushPending;
    ReqTotalDataSize     = FlushPendingDataSize + ReqToWriteDataSize;

    *pcWritten = 0;

    if ( !(pSpool->Status & SPOOL_STATUS_STARTDOC) ) {

        SetLastError(ERROR_SPL_NO_STARTDOC);
        ReturnValue = FALSE;

        goto EndWritePrinter;
    }

    //
    // Check if local job is cancelled every JOB_CANCEL_CHECK_INTERVAL bytes
    //
    if (!pSpool->cWritePrinters) {
        pSpool->dwTickCount = GetTickCount();
        pSpool->dwCheckJobInterval = JOB_CANCEL_CHECK_INTERVAL;
    }

    if (pSpool->hFile != INVALID_HANDLE_VALUE &&
        pSpool->dwTickCount + pSpool->dwCheckJobInterval < (dwTickCount = GetTickCount())) {

        bAllocBuffer = FALSE;
        pJob = (PJOB_INFO_1) btBuffer;
        ZeroMemory(pJob, MAX_STATIC_ALLOC);

        ReturnValue = GetJob((HANDLE) pSpool, pSpool->JobId, 1, (LPBYTE)pJob,
                              MAX_STATIC_ALLOC, &cbNeeded);

        if (!ReturnValue &&
            (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
            (pJob = (PJOB_INFO_1) AllocSplMem(cbNeeded))) {

             bAllocBuffer = TRUE;
             ReturnValue = GetJob(hPrinter, pSpool->JobId, 1, (LPBYTE)pJob,
                                  cbNeeded, &cbNeeded);
        }

        if (ReturnValue) {

           //
           // Don't allow GetJob calls to take more than 1% pSpool->dwCheckJobInterval
           //
           dwTickCount1 = GetTickCount();

           if (dwTickCount1 > dwTickCount + (pSpool->dwCheckJobInterval/100)) {

               pSpool->dwCheckJobInterval *= 2;

           } else if (dwTickCount1 - dwTickCount < JOB_CANCEL_CHECK_INTERVAL/100) {

              pSpool->dwCheckJobInterval = JOB_CANCEL_CHECK_INTERVAL;
           }

           if (!pJob->pStatus && (pJob->Status & JOB_STATUS_DELETING)) {

                SetLastError(ERROR_PRINT_CANCELLED);
                if (bAllocBuffer) {
                    FreeSplMem(pJob);
                }
                ReturnValue = FALSE;

                goto EndWritePrinter;
           }
        }

        if (bAllocBuffer) {
            FreeSplMem(pJob);
        }

        pSpool->dwTickCount = GetTickCount();
    }

    pSpool->cWritePrinters++;

    //
    //  WritePrinter will cache on the client side all IO's
    //  into BUFFER_SIZE writes.    This is done to minimize
    //  the number of RPC calls if the app is doing a lot of small
    //  sized IO's.
    //
    while (cbBuf && ReturnValue) {

        //
        // Special Case FileIO's since file system prefers large
        // writes, RPC is optimal with smaller writes.
        //
        // RPC should manage its own buffer size.  I'm not sure why we
        // only do this optimization for file writes.
        //
        if ((pSpool->hFile != INVALID_HANDLE_VALUE) &&
            (pSpool->cbBuffer == 0) &&
            (cbBuf > BUFFER_SIZE)) {

            ReturnValue = WriteFile(pSpool->hFile, pBuffer, cbBuf, &cbWritten, NULL);

            DBGMSG(DBG_TRACE, ("WritePrinter - WriteFile pSpool %x hFile %x pBuffer %x cbBuffer %d cbWritten %d\n",
                               pSpool, pSpool->hFile, pBuffer, pSpool->cbBuffer, *pcWritten));


        } else {

            //
            // Fill cache buffer so IO is optimal size.
            //
            SPLASSERT(pSpool->cbBuffer <= BUFFER_SIZE);

            //
            // cb is the amount of new data we want to put in the buffer.
            // It is the min of the space remaining, and the size of the
            // input buffer.
            //
            cb = min((BUFFER_SIZE - pSpool->cbBuffer), cbBuf);

            if (cb != 0) {
                if (pSpool->pBuffer == NULL) {
                    pSpool->pBuffer = VirtualAlloc(NULL, BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);
                    if (pSpool->pBuffer == NULL) {

                        DBGMSG(DBG_WARNING, ("VirtualAlloc Failed to allocate 4k buffer %d\n",GetLastError()));
                        ReturnValue = FALSE;
                        goto EndWritePrinter;
                    }
                }
                CopyMemory( pSpool->pBuffer + pSpool->cbBuffer, pBuffer, cb);
                pSpool->cbBuffer += cb;
                cbWritten = cb;
                pSpool->cCacheWrite++;
            }

            //
            // cbWritten is the amount of new data that has been put into
            // the buffer.  It may not have been written to the device, but
            // since it is in our buffer, the driver can assume it has been
            // written (e.g., the *pcbWritten out parameter to WritePrinter
            // includes this data).
            //
            if (pSpool->cbBuffer == BUFFER_SIZE)
            {
                DWORD cbPending = pSpool->cbFlushPending;
                DWORD cbFlushed = 0;
                ReturnValue = FlushBuffer(pSpool, &cbFlushed);
                if(!NumOfCmpltWrts && ReturnValue)
                {
                    NumOfCmpltWrts = 1;
                }
                if(!ReturnValue &&
                   (ERROR_PRINT_CANCELLED == GetLastError()) &&
                   pSpool->hSplPrinter &&
                   pSpool->cOKFlushBuffers)
                {
                    SJobCancelInfo JobCancelInfo;

                    JobCancelInfo.pSpool                 = pSpool;
                    JobCancelInfo.pInitialBuf            = pInitialBuf;
                    JobCancelInfo.pcbWritten             = &cbWritten;
                    JobCancelInfo.pcTotalWritten         = &cTotalWritten;
                    JobCancelInfo.NumOfCmpltWrts         = NumOfCmpltWrts;  
                    JobCancelInfo.cbFlushed              = cbFlushed;
                    JobCancelInfo.ReqTotalDataSize       = ReqTotalDataSize;
                    JobCancelInfo.ReqToWriteDataSize     = ReqToWriteDataSize;
                    JobCancelInfo.FlushPendingDataSize   = FlushPendingDataSize;
                    JobCancelInfo.ReturnValue            = ReturnValue;

                    ReturnValue = JobCanceled(&JobCancelInfo);
                }
            }
        }

        //
        // Update Total Byte Count after the Flush or File IO
        // This is done because the IO might fail and thus
        // the correct value written might have changed.
        //
        if(!pSpool->Flushed)
        {
            SPLASSERT(cbBuf >= cbWritten);
            cbBuf         -= cbWritten;
            pBuffer       += cbWritten;
            cTotalWritten += cbWritten;
        }
        else
            break;

    }

    //
    // Return the number of bytes written.
    //
    *pcWritten = cTotalWritten;

    DBGMSG(DBG_TRACE, ("WritePrinter cbWritten %d ReturnValue %d\n",*pcWritten, ReturnValue));

    //
    // Remember if there is a flush pending on this WritePrinter.  If there
    // is, then when we return, we say we've written all the bytes, but
    // we really haven't since there's some left in the buffer.  If the
    // user cancels the next job, then we need to flush out the last
    // bytes, since the driver assumes that we've written it out and
    // tracks the printer state.
    //
    if(!pSpool->Flushed)
        pSpool->cbFlushPending = pSpool->cbBuffer;

    
EndWritePrinter:

    vUnprotectHandle( hPrinter );

    return ReturnValue;
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue = TRUE;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    try {

        FlushBuffer(pSpool, NULL);

        if( pSpool->hFile == INVALID_HANDLE_VALUE ){

            RpcTryExcept {

                if (ReturnValue = RpcEndPagePrinter(pSpool->hPrinter)) {

                    SetLastError(ReturnValue);
                    ReturnValue = FALSE;

                } else

                    ReturnValue = TRUE;

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                ReturnValue = FALSE;

            } RpcEndExcept
        }

    } except (1) {

        SetLastError(ERROR_INVALID_HANDLE);
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;

}

BOOL
AbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwNumWritten = 0;
    DWORD   dwPointer = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    //
    // No longer in StartDoc mode; also resetting the tray icon notification
    // flag so that upcoming StartDocPrinter/AddJobs indicate a new job.
    //
    pSpool->Status &= ~(SPOOL_STATUS_STARTDOC|SPOOL_STATUS_TRAYICON_NOTIFIED);

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {

        if (pSpool->Status & SPOOL_STATUS_ADDJOB) {
            //
            // Close your handle to the .SPL file, otherwise the
            // DeleteJob will fail in the Spooler
            //
            CloseSpoolFileHandles( pSpool );

            if (!SetJob(hPrinter,pSpool->JobId, 0, NULL, JOB_CONTROL_DELETE)) {
                DBGMSG(DBG_WARNING, ("Error: SetJob cancel returned failure with %d\n", GetLastError()));
            }

            ReturnValue = ScheduleJob(hPrinter, pSpool->JobId);
            goto Done;

        } else {
            DBGMSG(DBG_WARNING, ("Error: pSpool->hFile != INVALID_HANDLE_VALUE and pSpool's status is not SPOOL_STATUS_ADDJOB\n"));
        }

    }

    RpcTryExcept {

        if (ReturnValue = RpcAbortPrinter(pSpool->hPrinter)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
)
{
    BOOL    bReturn = FALSE;
    DWORD   dwStatus;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    cbBuf = min(BUFFER_SIZE, cbBuf);

    if (bLoadedBySpooler && fpYReadPrinter && pSpool->hSplPrinter) {

            dwStatus = (*fpYReadPrinter)(pSpool->hSplPrinter, pBuf, cbBuf, pNoBytesRead, FALSE);

    } else {

        RpcTryExcept {

            dwStatus = RpcReadPrinter(pSpool->hPrinter, pBuf, cbBuf, pNoBytesRead);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwStatus = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept
    }

    if (dwStatus) {
        SetLastError(dwStatus);
    } else {
        bReturn = TRUE;
    }

Done:

    vUnprotectHandle( hPrinter );
    return bReturn;
}

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
    )

/*++
    Function Description:  This is an internal function used by the spooler during playback of
                           EMF jobs. It is called from gdi32.dll. SplReadPrinter is equivalent
                           to ReadPrinter in all respects except that it returns a pointer to the
                           buffer in pBuf. The spool file is memory mapped.

    Parameters:  hPrinter  --  handle to the printer
                 pBuf      --  pointer to the buffer
                 cbBuf     --  number to bytes to read

    Return Values: TRUE if sucessful (pBuf contains the required pointer)
                   FALSE otherwise
--*/
{
    BOOL bReturn = FALSE;
    DWORD   dwStatus = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    //
    // If we recycle handles we end up calling close printer which releases the mapped memory.
    // Since we dont want to do that we shall mark this handle as non-recycleable.
    //
    vEnterSem();
    pSpool->Status |= SPOOL_STATUS_DONT_RECYCLE_HANDLE;
    vLeaveSem();

    //
    // This function is to be used only internally. Hence no RPC interface is required.
    //
    if (!bLoadedBySpooler || !fpYSplReadPrinter || !pSpool->hSplPrinter) {
        SetLastError(ERROR_NOT_SUPPORTED);
        goto Done;
    }

    FlushBuffer(pSpool, NULL);

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    //
    // Optimal buffer size of 4K need not be used for non RPC code paths.
    //
    dwStatus = (*fpYSplReadPrinter)(pSpool->hSplPrinter, pBuf, cbBuf, FALSE);

    if (dwStatus) {
        SetLastError(dwStatus);
    } else {
        bReturn = TRUE;
    }

Done:

    vUnprotectHandle( hPrinter );
    return bReturn;
}

BOOL
EndDocPrinter(
    HANDLE  hPrinter
    )
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD dwRetryTimes;
    DWORD dwNeeded;
    USEROBJECTFLAGS uof;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if (GetUserObjectInformation(GetProcessWindowStation(), UOI_FLAGS, &uof, sizeof(uof), &dwNeeded) && (WSF_VISIBLE & uof.dwFlags)) {

        //
        // If we are in interactive window station (i.e. not in a service)
        // we need to wait the tray code to startup, so we don't miss balloon
        // notifications. there is still possibility of missing balloon notifications
        // but very unlikely. the complete fix will come with CSR in place (i.e. in
        // Blackcomb)
        //
        dwRetryTimes = 20;
        while (dwRetryTimes--){

            if (NULL == FindWindow(cszTrayListenerClassName, NULL)){

                Sleep(100);
                continue;
            }

            Sleep(100);
            break;
        }
    }

    try {

        FlushBuffer(pSpool, NULL);

        //
        // No longer in StartDoc mode; also resetting the tray icon
        // notification flag so that upcoming StartDocPrinter/AddJobs
        // indicate a new job.
        //
        pSpool->Status &= ~(SPOOL_STATUS_STARTDOC|SPOOL_STATUS_TRAYICON_NOTIFIED);

        if (pSpool->hFile != INVALID_HANDLE_VALUE) {

            if (CloseHandle(pSpool->hFile)) {
                pSpool->hFile = INVALID_HANDLE_VALUE;
            }

            ReturnValue = ScheduleJob(hPrinter, pSpool->JobId);
            pSpool->Status &= ~SPOOL_STATUS_ADDJOB;

            DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));

        } else {

            if(bLoadedBySpooler && fpYEndDocPrinter && pSpool->hSplPrinter)
            {
                ReturnValue = (*fpYEndDocPrinter)(pSpool->hSplPrinter,FALSE);
            }
            else
            {
                RpcTryExcept {

                    ReturnValue = RpcEndDocPrinter(pSpool->hPrinter);

                } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                    ReturnValue = TranslateExceptionCode(RpcExceptionCode());

                } RpcEndExcept             
            }

            if (ReturnValue) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;
            }
            else {

                ReturnValue = TRUE;
            }
                
            DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));
        }

    } except (1) {
        SetLastError(ERROR_INVALID_HANDLE);
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    BOOL        ReturnValue = FALSE;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    UINT        cRetry = 0;
    FieldInfo   *pFieldInfo;
    DWORD       cbStruct;
    HRESULT     hr;

    switch (Level) {

    case 1:
        pFieldInfo = AddJobFields;
        cbStruct = sizeof(ADDJOB_INFO_1W);
        ReturnValue = TRUE;
        break;

    case 2:
    case 3:
    {
        //
        // Level 3 is meant to be used only by RDR/SRV. The spooler needs
        // to know whether the job comes from RDR/SRV. See LocalScheduleJob
        // in localspl.dll for details
        //
        //
        // This is an internal call used by the server when it needs
        // to submit a job with a specific machine name (used for
        // netbiosless notifications, or if the user want the notification
        // to go to the computer instead of the user).
        //
        // IN: (PADDJOB_INFO_2W)pData - points to buffer that receives the
        //         path and ID.  On input, pData points to the computer name.
        //         pData->pData must not point to a string inside of the pData
        //         buffer, and it must be smaller than cbBuf -
        //         sizeof( ADDJOB_INFO_2W ).  It must not be szNull or NULL.
        //

        PADDJOB_INFO_2W pInfo2;

        pInfo2 = (PADDJOB_INFO_2W)pData;

        //
        // Check valid pointer and buffer.
        //
        if( !pInfo2 ||
            !pInfo2->pData ||
            !pInfo2->pData[0] ||
            cbBuf < sizeof( *pInfo2 ) +
                    (wcslen( pInfo2->pData ) + 1) * sizeof( WCHAR )){

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        //
        // Simple marshalling.
        //
        if (SUCCEEDED(hr = StringCbCopy( (LPWSTR)(pInfo2 + 1), cbBuf - sizeof( *pInfo2 ), pInfo2->pData )))
        {
            pInfo2->pData = (LPWSTR)sizeof( *pInfo2 );

            pFieldInfo = AddJob2Fields;
            cbStruct = sizeof(ADDJOB_INFO_2W);
            ReturnValue = TRUE;
        }
        else
        {
            SetLastError(HRESULT_CODE(hr));
        }

        break;
    }

    default:
        SetLastError(ERROR_INVALID_LEVEL);
    }

    if (eProtectHandle(hPrinter, FALSE))
    {
        return FALSE;
    }

    if (ReturnValue)
    {
        try {

            do {

                RpcTryExcept {

                    if (ReturnValue = RpcAddJob(pSpool->hPrinter, Level, pData,
                                                cbBuf, pcbNeeded)) {

                        SetLastError(ReturnValue);
                        ReturnValue = FALSE;

                    } else {

                        ReturnValue = MarshallUpStructure(pData, pFieldInfo, cbStruct, RPC_CALL);
                        pSpool->Status |= SPOOL_STATUS_ADDJOB;
                    }

                } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                    SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                    ReturnValue = FALSE;

                } RpcEndExcept

            } while( !ReturnValue &&
                     IsInvalidHandleError(GetLastError()) &&
                     cRetry++ < MAX_RETRY_INVALID_HANDLE &&
                     RevalidateHandle( pSpool ));

            if( ReturnValue ){

                //
                // Notify the tray icon that a new job has been sent.
                //
                vUpdateTrayIcon( hPrinter, ((PADDJOB_INFO_1)pData)->JobId );
            }

        } except (1) {
            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;
        }

        vUnprotectHandle( hPrinter );
    }

    
    return ReturnValue;
}

BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
    )
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    BOOL bReturn;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    bReturn = ScheduleJobWorker( pSpool, JobId );

    vUnprotectHandle( hPrinter );

    return bReturn;
}

BOOL
ScheduleJobWorker(
    PSPOOL pSpool,
    DWORD  JobId
    )
{
    BOOL ReturnValue;

    try {

        //
        // The job has been scheduled, so reset the flag that indicates
        // the tray icon has been notified.  Any new AddJob/StartDocPrinter/
        // StartDoc events should send a new notification, since it's really
        // a new job.
        //
        pSpool->Status &= ~SPOOL_STATUS_TRAYICON_NOTIFIED;

        FlushBuffer(pSpool, NULL);

        RpcTryExcept {

            if (ReturnValue = RpcScheduleJob(pSpool->hPrinter, JobId)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                pSpool->Status &= ~SPOOL_STATUS_ADDJOB;
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

        return ReturnValue;
    } except (1) {
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return(FALSE);
    }
}

DWORD WINAPI
AsyncPrinterProperties(
    PVOID pData
    )
{
     PrtPropsData *ThrdData = (PrtPropsData *)pData;

     RpcTryExcept
     {
         RPCSplWOW64PrinterProperties(ThrdData->hWnd,
                                      ThrdData->PrinterName,
                                      ThrdData->Flag,
                                      ThrdData->dwRet);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}

BOOL
PrinterPropertiesNative(
    HWND    hWnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    This is main PrinterProperties entri point and will call into the
    our DevicePropertySheets() for UI pop up


Arguments:

    hWnd        - Handle to the window parent

    hPrinter    - Handle to the printer interested


Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.
    To get extended error information, call GetLastError.

Author:

    13-Jun-1996 Thu 15:22:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PRINTER_INFO_2          *pPI2 = NULL;
    DEVICEPROPERTYHEADER    DPHdr;
    LONG                    Result;
    DWORD                   cb;
    DWORD                   dwValue = 1;
    BOOL                    bAllocBuffer = FALSE, bReturn;
    BYTE                    btBuffer[MAX_STATIC_ALLOC];

    //
    // Ensure the printer handle is valid
    //
    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.hPrinter       = hPrinter;
    DPHdr.Flags          = DPS_NOPERMISSION;

    //
    // Do a GetPrinter() level2 to get the printer name.
    //

    pPI2 = (PPRINTER_INFO_2) btBuffer;

    bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, MAX_STATIC_ALLOC, &cb);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pPI2 = (PPRINTER_INFO_2)LocalAlloc(LMEM_FIXED, cb))) {

         bAllocBuffer = TRUE;
         bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, cb, &cb);
    }

    //
    // Set the printer name.
    //
    if (bReturn) {
        DPHdr.pszPrinterName = pPI2->pPrinterName;
    } else {
        DPHdr.pszPrinterName = NULL;
    }

    //
    // Attempt to set the printer data to determine access privilages.
    //
    if (SetPrinterData( hPrinter,
                        TEXT( "PrinterPropertiesPermission" ),
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof( dwValue ) ) == STATUS_SUCCESS ) {
        //
        // Indicate we have permissions.
        //
        DPHdr.Flags &= ~DPS_NOPERMISSION;
    }

    //
    // Call Common UI to call do the and call the driver.
    //
    if ( CallCommonPropertySheetUI(hWnd,
                                  (PFNPROPSHEETUI)DevicePropertySheets,
                                  (LPARAM)&DPHdr,
                                  (LPDWORD)&Result) < 0 ) {
        Result = FALSE;

    } else {

        Result = TRUE;

    }

    if (bAllocBuffer) {
        LocalFree((HLOCAL)pPI2);
    }

    vUnprotectHandle( hPrinter );
    return Result;
}


BOOL
PrinterPropertiesThunk(
    HWND    hWnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    This is main PrinterProperties entri point and will call into the
    our DevicePropertySheets() for UI pop up


Arguments:

    hWnd        - Handle to the window parent

    hPrinter    - Handle to the printer interested


Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.
    To get extended error information, call GetLastError.

--*/

{
    PRINTER_INFO_2          *pPI2 = NULL;
    DEVICEPROPERTYHEADER    DPHdr;
    LONG                    Result;
    DWORD                   cb;
    DWORD                   dwValue = 1;
    BOOL                    bAllocBuffer = FALSE, bReturn;
    BYTE                    btBuffer[MAX_STATIC_ALLOC];
    DWORD                   dwRet;

    //
    // Ensure the printer handle is valid
    //
    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.hPrinter       = hPrinter;
    DPHdr.Flags          = DPS_NOPERMISSION;

    //
    // Do a GetPrinter() level2 to get the printer name.
    //

    pPI2 = (PPRINTER_INFO_2) btBuffer;

    bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, MAX_STATIC_ALLOC, &cb);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pPI2 = (PPRINTER_INFO_2)LocalAlloc(LMEM_FIXED, cb))) {

         bAllocBuffer = TRUE;
         bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, cb, &cb);
    }

    //
    // Set the printer name.
    //
    if (bReturn)
    {
        if(pPI2->pPrinterName)
        {
             //
             // Attempt to set the printer data to determine access privilages.
             //
             DWORD Flag = DPS_NOPERMISSION;

             if (SetPrinterData( hPrinter,
                                 TEXT( "PrinterPropertiesPermission" ),
                                 REG_DWORD,
                                 (LPBYTE)&dwValue,
                                 sizeof( dwValue ) ) == STATUS_SUCCESS )
             {
                 //
                 // Indicate we have permissions.
                 //
                 Flag &= ~DPS_NOPERMISSION;
             }

             RpcTryExcept
             {
                  if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
                     ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                  {
                       HANDLE hUIMsgThrd  = NULL;
                       DWORD  UIMsgThrdId = 0;
                       PrtPropsData ThrdData;

                       ThrdData.hWnd        = (ULONG_PTR)hWnd;
                       ThrdData.dwRet       = &dwRet;
                       ThrdData.PrinterName = (LPWSTR)pPI2->pPrinterName;
                       ThrdData.Flag        = Flag;

                       if(!(hUIMsgThrd = CreateThread(NULL,
                                                      INITIAL_STACK_COMMIT,
                                                      AsyncPrinterProperties,
                                                      (PVOID)&ThrdData,
                                                      0,
                                                      &UIMsgThrdId)))
                       {
                            dwRet = GetLastError();
                       }
                       //
                       // The following is the required message loop for processing messages
                       // from the UI in case we have a window handle.
                       //
                       //
                       if(hUIMsgThrd)
                       {
                           MSG msg;
                           while (GetMessage(&msg, NULL, 0, 0))
                           {
                               //
                               // In This message loop We should trap a User defined message
                               // which indicates the success or the failure of the operation
                               //
                               if(msg.message == WM_ENDPRINTERPROPERTIES)
                               {
                                    Result     = (LONG)msg.wParam;
                                    if(Result == FALSE)
                                         SetLastError((DWORD)msg.lParam);
                                    DelHandleFromList(hWnd);
                                    break;
                               }
                               else if(msg.message == WM_SURROGATEFAILURE)
                               {
                                    //
                                    // This means that the server process died and we have
                                    // break from the message loop
                                    //
                                    Result = FALSE;
                                    SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                    break;
                               }
                               TranslateMessage(&msg);
                               DispatchMessage(&msg);
                           }
                       }

                       if(hUIMsgThrd)
                       {
                           WaitForSingleObject(hUIMsgThrd,INFINITE);
                           CloseHandle(hUIMsgThrd);
                       }
                  }
                  else
                  {
                      SetLastError(dwRet);
                  }
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
             }
             RpcEndExcept
        }
        else
        {
             Result = FALSE;
        }
    }
    else
    {
         Result = FALSE;
    }

    if (bAllocBuffer) {
        LocalFree((HLOCAL)pPI2);
    }

    vUnprotectHandle( hPrinter );
    return Result;
}


BOOL
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
    )
{
     if(RunInWOW64())
     {
          return(PrinterPropertiesThunk(hWnd,
                                        hPrinter));
     }
     else
     {
          return(PrinterPropertiesNative(hWnd,
                                         hPrinter));
     }
}


DWORD
GetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    WCHAR   szEMFDatatype[] = L"PrintProcCaps_EMF";
    WCHAR   szEMFDatatypeWithVersion[] = L"PrintProcCaps_NT EMF 1.008";

    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){
        pData = (PBYTE)&ReturnValue;
    }

    if (!pType) {
        pType = (PDWORD) &ReturnType;
    }

    //
    // If pValueName is PrintProcCaps_datatype add the EMF version if necessary.
    // This hardcoded EMF version number will have to be modified whenever GDI changes
    // the version number. This change has been made for GetPrintProcessorCapabilities.
    //

    if (pValueName && !_wcsicmp(pValueName, szEMFDatatype)) {
         pValueName = (LPWSTR) szEMFDatatypeWithVersion;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcGetPrinterData(pSpool->hPrinter, pValueName, pType,
                                             pData, nSize, pcbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

DWORD
GetPrinterDataExW(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   Key = 0;
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){
        pData = (PBYTE)&ReturnValue;
    }

    if (!pType) {
        pType = (PDWORD) &ReturnType;
    }

    if (!pKeyName) {
        pKeyName = (PWSTR) &Key;
    }

    do
    {
        RpcTryExcept {

            ReturnValue =  RpcGetPrinterDataEx( pSpool->hPrinter,
                                                pKeyName,
                                                pValueName,
                                                pType,
                                                pData,
                                                nSize,
                                                pcbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while (IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle(pSpool));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

HANDLE
GetSpoolFileHandle(
    HANDLE   hPrinter
)

/*++
Function Description: Gets spool file handle which is used by GDI in recording EMF
                      data.

Parameters: hPrinter - Printer handle

Return Values: Handle to the spool file if successful
               INVALID_HANDLE_VALUE otherwise
--*/

{
    HANDLE hReturn = INVALID_HANDLE_VALUE;
    DWORD  dwAppProcessId, cbBuf, dwNeeded, dwRpcReturn;

    FILE_INFO_CONTAINER FileInfoContainer;
    SPOOL_FILE_INFO_1 SpoolFileInfo;

    PSPOOL pSpool = (PSPOOL) hPrinter;

    if (eProtectHandle(hPrinter, FALSE)) {
        return hReturn;
    }

    if (pSpool->hSpoolFile != INVALID_HANDLE_VALUE) {
        // GetSpoolFileHandle has already been called; return old handles
        hReturn = pSpool->hSpoolFile;
        goto CleanUp;
    }

    dwAppProcessId = GetCurrentProcessId();

    FileInfoContainer.Level = 1;
    FileInfoContainer.FileInfo.Level1 = &SpoolFileInfo;

    RpcTryExcept {

        dwRpcReturn = RpcGetSpoolFileInfo2(pSpool->hPrinter,
                                          dwAppProcessId,
                                          1,
                                          &FileInfoContainer);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwRpcReturn = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    if (dwRpcReturn) {
        SetLastError(dwRpcReturn);
    } else {

        pSpool->hSpoolFile = FileInfoContainer.FileInfo.Level1->hSpoolFile;
        pSpool->dwSpoolFileAttributes = FileInfoContainer.FileInfo.Level1->dwAttributes;
        hReturn = pSpool->hSpoolFile;
    }

CleanUp:

    vUnprotectHandle(hPrinter);

    return hReturn;
}


HANDLE
CommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile,
    DWORD   cbCommit
)

/*++
Function Description: Commits cbCommit bytes in the spool file. For temporary files, a new
                      spool file handle is returned.

Parameters: hPrinter   -- printer handle
            hSpoolFile -- spool file handle (from GetSpoolFileHandle)
            cbCommit   -- number of bytes to commit (incremental count)

Return Values: New spool file handle for temporary spool files and
               old handle for persistent files
--*/

{
    HANDLE  hReturn = INVALID_HANDLE_VALUE;
    DWORD   dwAppProcessId, dwRpcReturn;
    DWORD   dwNeeded, cbBuf;
    HANDLE  hNewSpoolFile;

    FILE_INFO_CONTAINER FileInfoContainer;
    SPOOL_FILE_INFO_1 SpoolFileInfo;

    PSPOOL pSpool = (PSPOOL) hPrinter;

    if (eProtectHandle(hPrinter, FALSE)) {
        return hReturn;
    }

    if ((pSpool->hSpoolFile == INVALID_HANDLE_VALUE) ||
        (pSpool->hSpoolFile != hSpoolFile)) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto CleanUp;
    }

    dwAppProcessId = GetCurrentProcessId();

    FileInfoContainer.Level = 1;
    FileInfoContainer.FileInfo.Level1 = &SpoolFileInfo;


    RpcTryExcept {

        dwRpcReturn = RpcCommitSpoolData2(pSpool->hPrinter,
                                         dwAppProcessId,
                                         cbCommit,
                                         1,
                                         &FileInfoContainer);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwRpcReturn = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    if (dwRpcReturn) {

        SetLastError(dwRpcReturn);

    } else {

        hNewSpoolFile = FileInfoContainer.FileInfo.Level1->hSpoolFile;

        if (hNewSpoolFile != SPOOL_INVALID_HANDLE_VALUE_32BIT &&
            hNewSpoolFile != INVALID_HANDLE_VALUE) {
            CloseHandle(pSpool->hSpoolFile);
            pSpool->hSpoolFile = hNewSpoolFile;
        }

        hReturn = pSpool->hSpoolFile;
    }

CleanUp:

    vUnprotectHandle(hPrinter);

    return hReturn;
}



BOOL
CloseSpoolFileHandle(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile
)

/*++
Function Description:  Closes the client and server handles for the spool file.

Parameters: hPrinter    - printer handle
            hSpoolFile  - spool file handle (used for consistency across APIs)

Return Values: TRUE if sucessfule; FALSE otherwise
--*/

{
    BOOL   bReturn = FALSE;
    DWORD  dwLastError = ERROR_SUCCESS;
    PSPOOL pSpool = (PSPOOL) hPrinter;

    if (eProtectHandle(hPrinter, FALSE)) {
        return FALSE;
    }

    if (pSpool->hSpoolFile != hSpoolFile) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    if (pSpool->hSpoolFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pSpool->hSpoolFile);
        pSpool->hSpoolFile = INVALID_HANDLE_VALUE;
    }

    RpcTryExcept {

       dwLastError = RpcCloseSpoolFileHandle(pSpool->hPrinter);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

       dwLastError = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    if (dwLastError != ERROR_SUCCESS) {
        SetLastError(dwLastError);
    } else {
        bReturn = TRUE;
    }

Done:

    vUnprotectHandle(hPrinter);
    return bReturn;
}

DWORD
EnumPrinterDataW(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of pValueName
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of pData
    LPDWORD pcbData         // address for size of data buffer
    )
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pValueName && !cbValueName)
        pValueName = (LPWSTR) &ReturnValue;

    if( !pData && !cbData )
        pData = (PBYTE)&ReturnValue;

    if (!pType)
        pType = (PDWORD) &ReturnType;

    do {

        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterData(  pSpool->hPrinter,
                                                dwIndex,
                                                pValueName,
                                                cbValueName,
                                                pcbValueName,
                                                pType,
                                                pData,
                                                cbData,
                                                pcbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

DWORD
EnumPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
    )
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   i;
    PPRINTER_ENUM_VALUES pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pEnumValues && !cbEnumValues)
        pEnumValues = (LPBYTE) &ReturnValue;


    do {

        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterDataEx(pSpool->hPrinter,
                                                pKeyName,
                                                pEnumValues,
                                                cbEnumValues,
                                                pcbEnumValues,
                                                pnEnumValues);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

        if (ReturnValue == ERROR_SUCCESS) {

            if (pEnumValues) {

                if (!MarshallUpStructuresArray((LPBYTE)pEnumValue, *pnEnumValues,PrinterEnumValuesFields,
                                                sizeof(PRINTER_ENUM_VALUES), RPC_CALL) ) {

                    ReturnValue = GetLastError();
                }
            }
        }
    } while ( IsInvalidHandleError(ReturnValue) &&
              cRetry++ < MAX_RETRY_INVALID_HANDLE &&
              RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
EnumPrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of pValueName
    LPDWORD pcbSubkey       // address for size of value buffer
    )
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pSubkey && !cbSubkey)
        pSubkey = (LPWSTR) &ReturnValue;

    do {
        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterKey(pSpool->hPrinter,
                                             pKeyName,
                                             pSubkey,
                                             cbSubkey,
                                             pcbSubkey);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while ( IsInvalidHandleError(ReturnValue) &&
              cRetry++ < MAX_RETRY_INVALID_HANDLE &&
              RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
DeletePrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName
    )
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterData(pSpool->hPrinter, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
DeletePrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
    )
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterDataEx(pSpool->hPrinter, pKeyName, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

DWORD
DeletePrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
    )
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterKey(pSpool->hPrinter, pKeyName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterData(pSpool->hPrinter, pValueName, Type,
                                            pData, cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
SetPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    if (!pKeyName)
        pKeyName = L"";

    do {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterDataEx(  pSpool->hPrinter,
                                                pKeyName,
                                                pValueName,
                                                Type,
                                                pData,
                                                cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( IsInvalidHandleError(ReturnValue) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

VOID
SplDriverUnloadComplete(
    LPWSTR      pDriverFile
)
/*++
Function Description: The information on the driver unload is set to the spooler
                      so that it may continue any pending upgrades.

Parameters:  pDriverFile       --  driver file name which was unloaded

Return Value: NONE
--*/
{
    if (bLoadedBySpooler && fpYDriverUnloadComplete) {
        (*fpYDriverUnloadComplete)(pDriverFile);
    }
}


HANDLE
LoadNewCopy(
    LPWSTR      pConfigFile,
    DWORD       dwFlags,
    DWORD       dwVersion
)
/*++
Function Description: This function loads the driver file and creates a node to
                      maintain its reference count. It is called inside ListAccessSem.

Parameters:  pConfigFile       --  driver config file path
             dwFlags           --  flags for loading
             dwVersion         --  version number of the driver since reboot

Return Value: handle to the library
--*/
{
    HANDLE          hReturn = NULL;
    PDRVLIBNODE     pTmpDrvLib, pNewDrvLib = NULL;
    ULONG_PTR       lActCtx         = 0;
    BOOL            bDidActivate    = FALSE;

    //
    // Activate the empty context
    //
    bDidActivate = ActivateActCtx( ACTCTX_EMPTY, &lActCtx );

    // Inside ListAccessSem

    hReturn = LoadLibraryEx(pConfigFile, NULL, dwFlags);

    if (hReturn) {

       // Create a new DRVLIBNODE
       if (pNewDrvLib = (PDRVLIBNODE) AllocSplMem(sizeof(DRVLIBNODE))) {

           pNewDrvLib->hLib = hReturn;
           pNewDrvLib->dwVersion = dwVersion;

           // Initialize ref cnt to 2. This ensures that the library remains loaded
           // in the normal course.
           pNewDrvLib->dwNumHandles = 2;
           pNewDrvLib->bArtificialIncrement = TRUE;

           if (!(pNewDrvLib->pConfigFile = AllocSplStr(pConfigFile)))
           {
               FreeSplMem(pNewDrvLib);
               pNewDrvLib = NULL;
           }

       }

       if (!pNewDrvLib) {
           // Free the library
           FreeLibrary(hReturn);
           hReturn = NULL;
       } else {
           // Add the node to the list
           pNewDrvLib->pNext = pStartDrvLib;
           pStartDrvLib = pNewDrvLib;
       }
    }

    //
    // Deactivate the context
    //
    if( bDidActivate ){
        DeactivateActCtx( 0, lActCtx );
    }

    return hReturn;
}

PDRVLIBNODE
FindDriverNode(
    LPWSTR    pConfigFile,
    DWORD     dwVersion,
    BOOL      bUseVersion
)
/*++
Function Description: Searches thru the list of driver nodes to get the
                      required driver information. In case of version mismatch the
                      artificial increment on the old driver is removed.

                      This function is called inside the ListAccessSem

Parameters:  pConfigFile       --  driver config file name
             dwVersion         --  version number of the driver since reboot
             bUseVersion       --  flag to use the version number

Return Values: pDrvLibNode for the required driver, if present
--*/
{
    PDRVLIBNODE pTmpDrvLib;

    for (pTmpDrvLib = pStartDrvLib; pTmpDrvLib; pTmpDrvLib = pTmpDrvLib->pNext) {
        if (!_wcsicmp(pConfigFile, pTmpDrvLib->pConfigFile)) {
            break;
        }
    }

    if (pTmpDrvLib && bUseVersion && (pTmpDrvLib->dwVersion != dwVersion)) {
        if (pTmpDrvLib->bArtificialIncrement) {
            pTmpDrvLib->bArtificialIncrement = FALSE;
            if (RefCntUnloadDriver(pTmpDrvLib->hLib, FALSE)) {
                pTmpDrvLib = NULL;
            }
        }
    }

    return pTmpDrvLib;
}

HANDLE
RefCntLoadDriver(
    LPWSTR  pConfigFile,
    DWORD   dwFlags,
    DWORD   dwVersion,
    BOOL    bUseVersion
)
/*++
Function Description: This function loads the driver config file. It reuses existing handles
                      to avoid expensive Loads and Frees. In case of a version mismatch the
                      original handle is freed and we load the driver again.

Parameters:  pConfigFile       --  driver config file name
             dwFlags           --  flags for loading (ignored if existing handle is returned)
             dwVersion         --  version of the driver file since reboot
             bUseVersion       --  flag to use the version number check

Return Value: handle to the library
--*/
{
    HANDLE      hReturn = NULL;
    PDRVLIBNODE pTmpDrvLib;

    if (!pConfigFile || !*pConfigFile) {
        // nothing to load
        return hReturn;
    }

    EnterCriticalSection( &ListAccessSem );

    pTmpDrvLib = FindDriverNode(pConfigFile, dwVersion, bUseVersion);

    // Use existing handle, if any.
    if (pTmpDrvLib) {

        // Increment the ref cnt for library usage;
        pTmpDrvLib->dwNumHandles += 1;
        hReturn = pTmpDrvLib->hLib;

    } else {

        // Reload the library
        hReturn = LoadNewCopy(pConfigFile, dwFlags, dwVersion);
    }

    LeaveCriticalSection( &ListAccessSem );

    return hReturn;
}

BOOL
RefCntUnloadDriver(
    HANDLE  hLib,
    BOOL    bNotifySpooler
)
/*++
Function Description: This function decrements the reference count for the library usage.
                      It also frees the library if the reference count falls to zero.

Parameters: hLib           -- handle of the library to free
            bNotifySpooler -- flag to notify the spooler of the unload

Return Value: TRUE if the driver library was freed
              FALSE otherwise
--*/
{
    BOOL        bReturn = FALSE;
    PDRVLIBNODE *ppTmpDrvLib, pTmpDrvLib;
    LPWSTR      pConfigFile = NULL;

    EnterCriticalSection( &ListAccessSem );

    for (ppTmpDrvLib = &pStartDrvLib;
         pTmpDrvLib = *ppTmpDrvLib;
         ppTmpDrvLib = &(pTmpDrvLib->pNext)) {

         if (pTmpDrvLib->hLib == hLib) {

            // Reduce the ref cnt
            SPLASSERT(pTmpDrvLib->dwNumHandles > 0);
            pTmpDrvLib->dwNumHandles -= 1;

            // Free the library and the node if ref cnt is zero
            if (pTmpDrvLib->dwNumHandles == 0) {

                FreeLibrary(hLib);
                *ppTmpDrvLib = pTmpDrvLib->pNext;
                pConfigFile = AllocSplStr(pTmpDrvLib->pConfigFile);
                FreeSplStr(pTmpDrvLib->pConfigFile);
                FreeSplMem(pTmpDrvLib);

                bReturn = TRUE;
            }

            break;
        }
    }

    LeaveCriticalSection( &ListAccessSem );

    if (bNotifySpooler && bReturn) {
        SplDriverUnloadComplete(pConfigFile);

    }

    FreeSplStr(pConfigFile);

    return bReturn;
}

BOOL
ForceUnloadDriver(
    LPWSTR  pConfigFile
)
/*++
Function Description: This function will remove any artificial increment on the
                      config file.

Parameters:  pConfigFile   --  driver config file name

Return Values: TRUE if the config file no longer loaded;
               FALSE otherwise
--*/
{
    BOOL        bReturn = TRUE;
    PDRVLIBNODE *ppTmpDrvLib, pTmpDrvLib;

    if (!pConfigFile || !*pConfigFile) {
       // nothing to unload
       return bReturn;
    }

    EnterCriticalSection( &ListAccessSem );

    pTmpDrvLib = FindDriverNode(pConfigFile, 0, FALSE);

    if (pTmpDrvLib) {
        if (pTmpDrvLib->bArtificialIncrement) {
            pTmpDrvLib->bArtificialIncrement = FALSE;
            bReturn = RefCntUnloadDriver(pTmpDrvLib->hLib, FALSE);
        } else {
            bReturn = FALSE;
        }
    } else {
        bReturn = TRUE;
    }

    LeaveCriticalSection( &ListAccessSem );

    return bReturn;
}


HANDLE
LoadPrinterDriver(
    HANDLE  hPrinter
)
{
    PDRIVER_INFO_5  pDriverInfo;
    DWORD   cbNeeded, dwVersion;
    HANDLE  hModule=FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    BOOL    bAllocBuffer = FALSE, bReturn;

    pDriverInfo = (PDRIVER_INFO_5) btBuffer;

    bReturn = GetPrinterDriverW(hPrinter, NULL, 5, (LPBYTE)pDriverInfo,
                                MAX_STATIC_ALLOC, &cbNeeded);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pDriverInfo = (PDRIVER_INFO_5)LocalAlloc(LMEM_FIXED, cbNeeded))) {

         bAllocBuffer = TRUE;
         bReturn = GetPrinterDriverW(hPrinter, NULL, 5, (LPBYTE)pDriverInfo,
                                     cbNeeded, &cbNeeded);
    }

    if (bReturn) {

        hModule = RefCntLoadDriver(pDriverInfo->pConfigFile,
                                   LOAD_WITH_ALTERED_SEARCH_PATH,
                                   pDriverInfo->dwConfigVersion,
                                   TRUE);
    }

    if (bAllocBuffer) {
        LocalFree(pDriverInfo);
    }

    return hModule;
}


DWORD WINAPI
AsyncDocumentPropertiesW(
    PVOID pData
    )
{
     PumpThrdData *ThrdData = (PumpThrdData *)pData;

     RpcTryExcept
     {
         *ThrdData->Result = RPCSplWOW64DocumentProperties(ThrdData->hWnd,
                                                           ThrdData->PrinterName,
                                                           ThrdData->TouchedDevModeSize,
                                                           ThrdData->ClonedDevModeOutSize,
                                                           ThrdData->ClonedDevModeOut,
                                                           ThrdData->DevModeInSize,
                                                           ThrdData->pDevModeInput,
                                                           ThrdData->ClonedDevModeFill,
                                                           ThrdData->fMode,
                                                           ThrdData->dwRet);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}



LONG
DocumentPropertiesWNative(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput,
    DWORD       fMode
    )

/*++

Routine Description:

    DocumentProperties entry point to call DocumentPropertySheets() depends on
    the DM_PROMPT

Arguments:


Return Value:


Author:

    13-Jun-1996 Thu 15:35:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DOCUMENTPROPERTYHEADER  DPHdr;
    PDEVMODE                pDM;
    LONG                    Result = -1;
    HANDLE                  hTmpPrinter = NULL;

    //
    //  Compatibility with Win95
    //  Win95 allows for hPrinter to be NULL
    //
    if (hPrinter == NULL) {

        //
        // Open the printer for default access.
        //
        if (!OpenPrinter( pDeviceName, &hTmpPrinter, NULL )) {

            hTmpPrinter = NULL;
        }

    } else {

        hTmpPrinter = hPrinter;
    }

    //
    // Ensure the printer handle is valid
    //
    if( !eProtectHandle( hTmpPrinter, FALSE )){

        //
        // If fMode doesn't specify DM_IN_BUFFER, then zero out
        // pDevModeInput.
        //
        // Old 3.51 (version 1-0) drivers used to ignore the absence of
        // DM_IN_BUFFER and use pDevModeInput if it was not NULL.  It
        // probably did this because Printman.exe was broken.
        //
        // If the devmode is invalid, then don't pass one in.
        // This fixes MS Imager32 (which passes dmSize == 0) and
        // Milestones etc. 4.5.
        //
        // Note: this assumes that pDevModeOutput is still the
        // correct size!
        //
        if( !(fMode & DM_IN_BUFFER) || 
            !BoolFromHResult(SplIsValidDevmodeNoSizeW( pDevModeInput ))){

            //
            // If either are not set, make sure both are not set.
            //
            pDevModeInput = NULL;
            fMode &= ~DM_IN_BUFFER;
        }

        DPHdr.cbSize         = sizeof(DPHdr);
        DPHdr.Reserved       = 0;
        DPHdr.hPrinter       = hTmpPrinter;
        DPHdr.pszPrinterName = pDeviceName;

        if (pDevModeOutput) {

            //
            // Get the driver devmode size at here
            //

            DPHdr.pdmIn  = NULL;
            DPHdr.pdmOut = NULL;
            DPHdr.fMode  = 0;

            DPHdr.cbOut = (LONG)DocumentPropertySheets(NULL, (LPARAM)&DPHdr);

        } else {

            DPHdr.cbOut = 0;
        }

        DPHdr.pdmIn  = (PDEVMODE)pDevModeInput;
        DPHdr.pdmOut = (PDEVMODE)pDevModeOutput;
        DPHdr.fMode  = fMode;

        if (fMode & DM_PROMPT) {

            Result = CPSUI_CANCEL;

            if ((CallCommonPropertySheetUI(hWnd,
                                           (PFNPROPSHEETUI)DocumentPropertySheets,
                                           (LPARAM)&DPHdr,
                                           (LPDWORD)&Result)) < 0) {

                Result = -1;

            } else {

                Result = (Result == CPSUI_OK) ? IDOK : IDCANCEL;
            }

        } else {

            Result = (LONG)DocumentPropertySheets(NULL, (LPARAM)&DPHdr);
        }

        vUnprotectHandle( hTmpPrinter );
    }

    if (Result != -1 && pDevModeOutput)
    {
        Result = BoolFromHResult(SplIsValidDevmodeNoSizeW(pDevModeOutput)) ? Result : -1;
    }

    if (hPrinter == NULL) {

        if( hTmpPrinter ){

            ClosePrinter(hTmpPrinter);

        }
    }

    return Result;
}


LONG
DocumentPropertiesWThunk(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput,
    DWORD       fMode
    )

/*++

Routine Description:

    DocumentProperties entry point to call DocumentPropertySheets() depends on
    the DM_PROMPT

--*/

{
    DOCUMENTPROPERTYHEADER  DPHdr;
    PDEVMODE                pDM;
    LONG                    Result = -1;
    HANDLE                  hTmpPrinter = NULL;
    PSPOOL                  pSpool  = (PSPOOL)hPrinter;


    if (hPrinter == NULL)
    {
        if (!OpenPrinter( pDeviceName, &hTmpPrinter, NULL ))
        {
            hTmpPrinter = NULL;
        }
    }
    else
    {

        hTmpPrinter = hPrinter;
    }


    if( !eProtectHandle( hTmpPrinter, FALSE ))
    {
        LPWSTR PrinterName;
        MSG    msg;
        LONG   RetVal;
        DWORD  dwRet                = ERROR_SUCCESS;
        DWORD  ClonedDevModeOutSize = 0;
        DWORD  TouchedDevModeSize   = 0;
        BOOL   ClonedDevModeFill = (!!(fMode & DM_OUT_BUFFER) && pDevModeOutput);
        DWORD  DevModeInSize =  pDevModeInput ? (pDevModeInput->dmSize + pDevModeInput->dmDriverExtra) : 0;
        byte   **ClonedDevModeOut = NULL;

        if(ClonedDevModeOut = (byte **)LocalAlloc(LPTR,sizeof(byte *)))
        {
            *ClonedDevModeOut = NULL;

            if(pSpool)
            {
                PrinterName = pSpool->pszPrinter;
            }
            else
            {
                PrinterName = pDeviceName;
            }

            //
            // If fMode doesn't specify DM_IN_BUFFER, then zero out
            // pDevModeInput.
            //
            // Old 3.51 (version 1-0) drivers used to ignore the absence of
            // DM_IN_BUFFER and use pDevModeInput if it was not NULL.  It
            // probably did this because Printman.exe was broken.
            //
            // If the devmode is invalid, then don't pass one in.
            // This fixes MS Imager32 (which passes dmSize == 0) and
            // Milestones etc. 4.5.
            //
            // Note: this assumes that pDevModeOutput is still the
            // correct size!
            //
            if( !(fMode & DM_IN_BUFFER) || 
                !BoolFromHResult(SplIsValidDevmodeNoSizeW( pDevModeInput )))
            {

                //
                // If either are not set, make sure both are not set.
                //
                pDevModeInput  = NULL;
                DevModeInSize  = 0;
                fMode &= ~DM_IN_BUFFER;
            }

            RpcTryExcept
            {
                if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess,
                                                     (hWnd && (fMode & DM_PROMPT)) ?
                                                     TRUE : FALSE)) == ERROR_SUCCESS) &&
                   (!hWnd ||
                    ((dwRet = ((fMode & DM_PROMPT) ? AddHandleToList(hWnd) : ERROR_SUCCESS)) == ERROR_SUCCESS)))
                 {
                      HANDLE       hUIMsgThrd  = NULL;
                      DWORD        UIMsgThrdId = 0;
                      PumpThrdData ThrdData;

                      ThrdData.hWnd                 = (ULONG_PTR)hWnd;
                      ThrdData.PrinterName          = PrinterName;
                      ThrdData.TouchedDevModeSize   = &TouchedDevModeSize;
                      ThrdData.ClonedDevModeOutSize = &ClonedDevModeOutSize;
                      ThrdData.ClonedDevModeOut     = (byte**)ClonedDevModeOut;
                      ThrdData.DevModeInSize        = DevModeInSize;
                      ThrdData.pDevModeInput        = (byte*)pDevModeInput;
                      ThrdData.fMode                = fMode;
                      ThrdData.fExclusionFlags      = 0;
                      ThrdData.dwRet                = &dwRet;
                      ThrdData.ClonedDevModeFill    = ClonedDevModeFill;
                      ThrdData.Result               = &Result;


                      if(hWnd && (fMode & DM_PROMPT))
                      {
                          //
                          // If we have a window handle , the following functions cann't
                          // proceed synchronasly. The reason for that is in order to show
                          // the UI of the driver property sheets we need to be able to dispatch
                          // incomming messages and process them.For this reason the following
                          // call would be asynchronous call and the success or failure doesn't
                          // in reality tell us anything more than than the async process started
                          // or not. We get the success of failure from the termination message.
                          // If we don't have a window handle, then the call is synchronous.
                          //
                          if(!(hUIMsgThrd = CreateThread(NULL,
                                                         INITIAL_STACK_COMMIT,
                                                         AsyncDocumentPropertiesW,
                                                         (PVOID)&ThrdData,
                                                         0,
                                                         &UIMsgThrdId)))
                          {
                               dwRet = GetLastError();
                          }
                          else
                          {
                              //
                              // The following is the required message loop for processing messages
                              // from the UI in case we have a window handle.
                              //
                              //
                              while (GetMessage(&msg, NULL, 0, 0))
                              {
                                  //
                                  // In This message loop We should trap a User defined message
                                  // which indicates the success or the failure of the operation
                                  //
                                  if(msg.message == WM_ENDDOCUMENTPROPERTIES)
                                  {
                                      Result     = (LONG)msg.wParam;

                                      if(Result == -1)
                                      {
                                          SetLastError((DWORD)msg.lParam);
                                      }

                                      DelHandleFromList(hWnd);

                                      break;
                                  }
                                  else if(msg.message == WM_SURROGATEFAILURE)
                                  {
                                      //
                                      // This means that the server process died and we have
                                      // break from the message loop
                                      //
                                      Result = -1;
                                      SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                      break;
                                  }
                                  TranslateMessage(&msg);
                                  DispatchMessage(&msg);
                              }

                              WaitForSingleObject(hUIMsgThrd,INFINITE);
                              CloseHandle(hUIMsgThrd);
                          }
                      }
                      else
                      {
                          AsyncDocumentPropertiesW((PVOID)&ThrdData);
                      }


                      if(Result != -1 && pDevModeOutput)
                      {
                         Result = BoolFromHResult(SplIsValidDevmodeW((PDEVMODEW)(*ClonedDevModeOut), 
                                                                     TouchedDevModeSize)) ? 
                                     Result : 
                                     -1;

                         if (Result != -1)
                         {
                             memcpy((PVOID)pDevModeOutput,(PVOID)*ClonedDevModeOut,TouchedDevModeSize);
                         }
                      }

                      if (*ClonedDevModeOut)
                      {
                           MIDL_user_free((PVOID)*ClonedDevModeOut);
                      }

                      if(ClonedDevModeOut)
                      {
                           LocalFree((PVOID) ClonedDevModeOut);
                      }
                 }
                 else
                 {
                      SetLastError(dwRet);
                 }
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                 SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            }
            RpcEndExcept

            vUnprotectHandle( hTmpPrinter );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }

    }

    if (hPrinter == NULL)
    {
        if( hTmpPrinter )
        {
            ClosePrinter(hTmpPrinter);
        }
    }
    return(Result);
}



LONG
DocumentPropertiesW(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput,
    DWORD       fMode
    )
{
     if(RunInWOW64())
     {
          return(DocumentPropertiesWThunk(hWnd,
                                          hPrinter,
                                          pDeviceName,
                                          pDevModeOutput,
                                          pDevModeInput,
                                          fMode));
     }
     else
     {
          return(DocumentPropertiesWNative(hWnd,
                                           hPrinter,
                                           pDeviceName,
                                           pDevModeOutput,
                                           pDevModeInput,
                                           fMode));
     }

}

LONG
AdvancedDocumentPropertiesW(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput
    )

/*++

Routine Description:

    AdvanceDocumentProperties() will call DocumentProperties() with DM_ADVANCED
    flag mode set


Arguments:



Return Value:

    TRUE/FALSE


Author:

    13-Jun-1996 Thu 16:00:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    return((DocumentPropertiesW(hWnd,
                                hPrinter,
                                pDeviceName,
                                pDevModeOutput,
                                pDevModeInput,
                                DM_PROMPT           |
                                    DM_MODIFY       |
                                    DM_COPY         |
                                    DM_ADVANCED) == CPSUI_OK) ? 1 : 0);

}

LONG
AdvancedSetupDialogW(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODE   pDevModeInput,
    LPDEVMODE   pDevModeOutput
)
{
    HANDLE  hPrinter;
    LONG    ReturnValue = -1;

    if (pDevModeInput &&
        OpenPrinterW(pDevModeInput->dmDeviceName, &hPrinter, NULL)) {
        ReturnValue = AdvancedDocumentPropertiesW(hWnd, hPrinter,
                                                  pDevModeInput->dmDeviceName,
                                                  pDevModeOutput,
                                                  pDevModeInput);
        ClosePrinter(hPrinter);
    }

    return ReturnValue;
}

int
WINAPI
DeviceCapabilitiesWNative(
    LPCWSTR   pDevice,
    LPCWSTR   pPort,
    WORD    fwCapability,
    LPWSTR   pOutput,
    CONST DEVMODEW *pDevMode
)
{
    HANDLE  hPrinter, hModule;
    int  ReturnValue=-1;
    INT_FARPROC pfn;

    if (!pDevMode ||
        BoolFromHResult(SplIsValidDevmodeNoSizeW((PDEVMODEW)(pDevMode))))
    {        
        if (OpenPrinter((LPWSTR)pDevice, &hPrinter, NULL)) {

            if (hModule = LoadPrinterDriver(hPrinter)) {

                if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DrvDeviceCapabilities")) {

                    try {

                        ReturnValue = (*pfn)(hPrinter, pDevice, fwCapability,
                                             pOutput, pDevMode);

                    } except(1) {

                        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                        ReturnValue = -1;
                    }
                }

                RefCntUnloadDriver(hModule, TRUE);
            }

            ClosePrinter(hPrinter);
        }
    }

    return  ReturnValue;
}


int
WINAPI
DeviceCapabilitiesWThunk(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD    fwCapability,
    LPWSTR  pOutput,
    CONST DEVMODEW *pDevMode
)
{
    HANDLE      hPrinter, hModule;
    int         ReturnValue = -1;
    INT_FARPROC pfn;
    LPWSTR      DriverFileName;


    DWORD    DevModeSize;
    DWORD    ClonedOutputSize = 0;
    BOOL     ClonedOutputFill = FALSE;
    DWORD    dwRet            = ERROR_SUCCESS;
    byte     **ClonedOutput = NULL;
    DevModeSize      = pDevMode ? (pDevMode->dmSize + pDevMode->dmDriverExtra) : 0;
    ClonedOutputFill = (pOutput != NULL);

    if (!pDevMode ||
        BoolFromHResult(SplIsValidDevmodeNoSizeW((PDEVMODEW)(pDevMode))))
    {
        if(ClonedOutput = (byte **)LocalAlloc(LPTR,sizeof(byte *)))
        {
            *ClonedOutput    = NULL;
            RpcTryExcept
            {
                if((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS)
                {
                     ReturnValue = RPCSplWOW64DeviceCapabilities((LPWSTR)pDevice,
                                                                 (LPWSTR)pPort,
                                                                 fwCapability,
                                                                 DevModeSize,
                                                                 (byte*)pDevMode,
                                                                 ClonedOutputFill,
                                                                 &ClonedOutputSize,
                                                                 (byte**)ClonedOutput,
                                                                 &dwRet);
                     if(ReturnValue!=-1 &&
                        pOutput         &&
                        *ClonedOutput)
                     {
                         memcpy((PVOID)pOutput,(PVOID)*ClonedOutput,ClonedOutputSize);
                     }
                     if(*ClonedOutput)
                     {
                          MIDL_user_free((PVOID)*ClonedOutput);
                     }
                }
                else
                {
                     SetLastError(dwRet);
                }
                if(ClonedOutput)
                {
                     LocalFree((PVOID) ClonedOutput);
                }
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                ReturnValue = -1;
            }
            RpcEndExcept
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return(ReturnValue);
}


int
WINAPI
DeviceCapabilitiesW(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD    fwCapability,
    LPWSTR  pOutput,
    CONST DEVMODEW *pDevMode
)
{
     if(RunInWOW64())
     {
          return(DeviceCapabilitiesWThunk(pDevice,
                                         pPort,
                                         fwCapability,
                                         pOutput,
                                         pDevMode));
     }
     else
     {
          return(DeviceCapabilitiesWNative(pDevice,
                                           pPort,
                                           fwCapability,
                                           pOutput,
                                           pDevMode));
     }
}


BOOL
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
    )
{
    BOOL                ReturnValue;
    GENERIC_CONTAINER   FormContainer;
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    UINT                cRetry = 0;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FormContainer.Level = Level;
    FormContainer.pData = pForm;

    do {

        RpcTryExcept {

            if (ReturnValue = RpcAddForm(pSpool->hPrinter,
                                         (PFORM_CONTAINER)&FormContainer)) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (ReturnValue = RpcDeleteForm(pSpool->hPrinter, pFormName)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    FieldInfo *pFieldInfo;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;
    SIZE_T cbStruct;

    switch (Level) {

    case 1:
        pFieldInfo = FormInfo1Fields;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (pForm)
                memset(pForm, 0, cbBuf);

            if (ReturnValue = RpcGetForm(pSpool->hPrinter, pFormName, Level, pForm,
                                         cbBuf, pcbNeeded)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    ReturnValue = MarshallUpStructure(pForm, pFieldInfo, cbStruct, RPC_CALL);
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
SetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER FormContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FormContainer.Level = Level;
    FormContainer.pData = pForm;

    do {

        RpcTryExcept {

            if (ReturnValue = RpcSetForm(pSpool->hPrinter, pFormName,
                                        (PFORM_CONTAINER)&FormContainer)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL        ReturnValue;
    DWORD       cbStruct, cbStruct32;
    FieldInfo   *pFieldInfo;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    UINT        cRetry = 0;

    switch (Level) {

    case 1:
        pFieldInfo = FormInfo1Fields;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (pForm)
                memset(pForm, 0, cbBuf);

            if (ReturnValue = RpcEnumForms(pSpool->hPrinter, Level, pForm, cbBuf,
                                           pcbNeeded, pcReturned)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    ReturnValue = MarshallUpStructuresArray(pForm, *pcReturned, pFieldInfo,
                                                            cbStruct, RPC_CALL);

                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
EnumPortsW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL        ReturnValue;
    DWORD       cbStruct;
    FieldInfo   *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = PortInfo1Fields;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pFieldInfo = PortInfo2Fields;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pPort)
            memset(pPort, 0, cbBuf);

        if (ReturnValue = RpcEnumPorts(pName, Level, pPort, cbBuf,
                                       pcbNeeded, pcReturned)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPort) {

                ReturnValue = MarshallUpStructuresArray(pPort, *pcReturned, pFieldInfo,
                                                        cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumMonitorsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitor,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = MonitorInfo1Fields;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pFieldInfo = MonitorInfo2Fields;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pMonitor)
            memset(pMonitor, 0, cbBuf);

        if (ReturnValue = RpcEnumMonitors(pName, Level, pMonitor, cbBuf,
                                          pcbNeeded, pcReturned)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pMonitor) {

                ReturnValue = MarshallUpStructuresArray(pMonitor, *pcReturned, pFieldInfo,
                                                        cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

typedef struct {
    LPWSTR pName;
    HWND  hWnd;
    LPWSTR pPortName;
    HANDLE Complete;
    DWORD  ReturnValue;
    DWORD  Error;
    INT_FARPROC pfn;
} CONFIGUREPORT_PARAMETERS;

void
PortThread(
    CONFIGUREPORT_PARAMETERS *pParam
)
{
    DWORD   ReturnValue;

    /* It's no use setting errors here, because they're kept on a per-thread
     * basis.  Instead we have to pass any error code back to the calling
     * thread and let him set it.
     */

    RpcTryExcept {

        if (ReturnValue = (*pParam->pfn)(pParam->pName, pParam->hWnd,
                                           pParam->pPortName)) {
            pParam->Error = ReturnValue;
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        pParam->Error = TranslateExceptionCode(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    pParam->ReturnValue = ReturnValue;

    SetEvent(pParam->Complete);
}

BOOL
KickoffThread(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    INT_FARPROC pfn
)
{
    CONFIGUREPORT_PARAMETERS Parameters;
    HANDLE  ThreadHandle;
    MSG      msg;
    DWORD  ThreadId;

    if( hWnd ){
        EnableWindow(hWnd, FALSE);
    }

    Parameters.pName = pName;
    Parameters.hWnd = hWnd;
    Parameters.pPortName = pPortName;
    Parameters.Complete = CreateEvent(NULL, TRUE, FALSE, NULL);
    Parameters.pfn = pfn;

    ThreadHandle = CreateThread(NULL, INITIAL_STACK_COMMIT,
                                (LPTHREAD_START_ROUTINE)PortThread,
                                 &Parameters, 0, &ThreadId);

    if( ThreadHandle ){

        CloseHandle(ThreadHandle);

        while (MsgWaitForMultipleObjects(1, &Parameters.Complete, FALSE, INFINITE,
                                         QS_ALLEVENTS | QS_SENDMESSAGE) == 1) {

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(Parameters.Complete);

        if( hWnd ){
            EnableWindow(hWnd, TRUE);
            SetForegroundWindow(hWnd);

            SetFocus(hWnd);
        }

        if(!Parameters.ReturnValue)
            SetLastError(Parameters.Error);

        return Parameters.ReturnValue;
    }

    return FALSE;
}


BOOL
AddPortWNative(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    PMONITORUIDATA pMonitorUIData = NULL;

    dwRet = GetMonitorUI(pName, pMonitorName, L"XcvMonitor", &pMonitorUI, &pMonitorUIData);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS) {
            bRet = (*pMonitorUI->pfnAddPortUI)(pName, hWnd, pMonitorName, NULL);
            dwRet = GetLastError();
        } else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId) {
            bRet = FALSE;
            dwRet = ERROR_NOT_SUPPORTED;
        } else {
            bRet = KickoffThread(pName, hWnd, pMonitorName, RpcAddPort);
            dwRet = GetLastError();
        }

        SetLastError(dwRet);

    } else {

        SetLastError(dwRet);
        bRet = FALSE;
    }

    FreeMonitorUI(pMonitorUIData);

    return bRet;
}


BOOL
AddPortWThunk(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    LPWSTR      pMonitorUIDll = NULL;

    dwRet = GetMonitorUIDll(pName,pMonitorName,L"XcvMonitor",&pMonitorUIDll);

    RpcTryExcept
    {
         if (dwRet == ERROR_SUCCESS ||
             dwRet == ERROR_INVALID_PRINT_MONITOR ||
             dwRet == ERROR_INVALID_PRINTER_NAME ||
             dwRet == ERROR_NOT_SUPPORTED ||
             dwRet == ERROR_MOD_NOT_FOUND ||
             dwRet == ERROR_UNKNOWN_PORT) {

             if (dwRet == ERROR_SUCCESS)
             {
                 MSG    msg;
                 if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
                    ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                 {
                      //
                      // The following functions cann't proceed synchronasly. The reason
                      // for that is in order to show the UI of the port monitor we need
                      // to be able to dispatch incomming messages and process them.
                      // For this reason the following call is an asynchronous call and the
                      // success or failure doesn't in reality tell us anything more than
                      // than the async process started or not
                      //
                      if(bRet = RPCSplWOW64AddPort((ULONG_PTR)hWnd,
                                                   pName,
                                                   pMonitorUIDll,
                                                   pMonitorName,
                                                   &dwRet))
                      {
                           //
                           // The following is the required message loop for processing messages
                           // from the UI. The window handle has to be NULL in order to process
                           // messages from all windows in the calling Thread , otherwise we would
                           // have message dispatching problems
                           //
                           while (GetMessage(&msg, NULL, 0, 0))
                           {
                               //
                               // In This message loop We should trap a User defined message
                               // which indicates the success or the failure of the operation
                               //
                               if(msg.message == WM_ENDADDPORT)
                               {
                                   bRet      = (BOOL)msg.wParam;
                                   if(!bRet)
                                        dwRet = (DWORD)msg.lParam;
                                   else
                                        dwRet = ERROR_SUCCESS;
                                   DelHandleFromList(hWnd);
                                   break;
                               }
                               else if(msg.message == WM_SURROGATEFAILURE)
                               {
                                    //
                                    // This means that the server process died and we have
                                    // break from the message loop
                                    //
                                    bRet = FALSE;
                                    SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                    PostMessage(hWnd,WM_ACTIVATEAPP,TRUE,0);
                                    break;
                               }
                               TranslateMessage(&msg);
                               DispatchMessage(&msg);
                           }
                      }
                 }
                 else
                 {
                      bRet = FALSE;
                 }
                 SetLastError(dwRet);
             }
             else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId)
             {
                 bRet  = FALSE;
                 dwRet = ERROR_NOT_SUPPORTED;
             }
             else
             {
                 bRet = KickoffThread(pName, hWnd, pMonitorName, RpcAddPort);
                 dwRet = GetLastError();
             }

             if(pMonitorUIDll)
             {
                FreeSplMem(pMonitorUIDll);
             }
             /* FreeLibrary is busting the last error, so we need to set it here
              */
             SetLastError(dwRet);
         }
         else
         {
             SetLastError(dwRet);
             bRet = FALSE;
         }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
          bRet = FALSE;
    }
    RpcEndExcept

    return(bRet);
}


BOOL
AddPortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
    )
{
     if(RunInWOW64())
     {
          return(AddPortWThunk(pName,
                               hWnd,
                               pMonitorName));
     }
     else
     {
          return(AddPortWNative(pName,
                                hWnd,
                                pMonitorName));
     }
}


BOOL
ConfigurePortWNative(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    PMONITORUIDATA pMonitorUIData = NULL;

    dwRet = GetMonitorUI(pName, pPortName, L"XcvPort", &pMonitorUI, &pMonitorUIData);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS) {
            bRet = (*pMonitorUI->pfnConfigurePortUI)(pName, hWnd, pPortName);
        } else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId) {
            bRet = FALSE;
            SetLastError(ERROR_NOT_SUPPORTED);
        } else {
            bRet = KickoffThread(pName, hWnd, pPortName, RpcConfigurePort);
        }

    } else {

        SetLastError(dwRet);

        bRet = FALSE;
    }

    FreeMonitorUI(pMonitorUIData);

    return bRet;
}


BOOL
ConfigurePortWThunk(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    LPWSTR      pMonitorUIDll = NULL;

    dwRet = GetMonitorUIDll(pName,pPortName,L"XcvPort",&pMonitorUIDll);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME  ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS)
        {
             RpcTryExcept
             {
                  MSG    msg;
                  if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
                     ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                  {
                       //
                       // The following functions cann't proceed synchronasly. The reason
                       // for that is in order to show the UI of the port monitor we need
                       // to be able to dispatch incomming messages and process them.
                       // For this reason the following call is an asynchronous call and the
                       // success or failure doesn't in reality tell us anything more than
                       // than the async process started or not
                       //
                       if(bRet = RPCSplWOW64ConfigurePort((ULONG_PTR)hWnd,
                                                          pName,
                                                          pMonitorUIDll,
                                                          pPortName,
                                                          &dwRet))
                       {
                            //
                            // The following is the required message loop for processing messages
                            // from the UI. The window handle has to be NULL in order to process
                            // messages from all windows in the calling Thread , otherwise we would
                            // have message dispatching problems
                            //
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                //
                                // In This message loop We should trap a User defined message
                                // which indicates the success or the failure of the operation
                                //
                                if(msg.message == WM_ENDCFGPORT)
                                {
                                    bRet      = (BOOL)msg.wParam;
                                    if(!bRet)
                                         dwRet = (DWORD)msg.lParam;
                                    else
                                         dwRet = ERROR_SUCCESS;
                                    DelHandleFromList(hWnd);
                                    break;
                                }
                                else if(msg.message == WM_SURROGATEFAILURE)
                                {
                                     //
                                     // This means that the server process died and we have
                                     // break from the message loop
                                     //
                                     bRet = FALSE;
                                     SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                     break;
                                }
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                       }
                  }
                  else
                  {
                       bRet = FALSE;
                  }

                  SetLastError(dwRet);
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                  bRet = FALSE;
             }
             RpcEndExcept
        }
        else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId) {
            bRet = FALSE;
            SetLastError(ERROR_NOT_SUPPORTED);
        } else {
            bRet = KickoffThread(pName, hWnd, pPortName, RpcConfigurePort);
        }

        if(pMonitorUIDll)
        {
           FreeSplMem(pMonitorUIDll);
        }

    }
    else
    {
        SetLastError(dwRet);
        bRet = FALSE;
    }
    return(bRet);
}


BOOL
ConfigurePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
     if(RunInWOW64())
     {
          return(ConfigurePortWThunk(pName,
                                     hWnd,
                                     pPortName));
     }
     else
     {
          return(ConfigurePortWNative(pName,
                                      hWnd,
                                      pPortName));
     }
}


BOOL
DeletePortWNative(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    DWORD       dwRet;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    PMONITORUIDATA pMonitorUIData = NULL;

    dwRet = GetMonitorUI(pName, pPortName, L"XcvPort", &pMonitorUI, &pMonitorUIData);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS)
            bRet = (*pMonitorUI->pfnDeletePortUI)(pName, hWnd, pPortName);
        else
            bRet = KickoffThread(pName, hWnd, pPortName, RpcDeletePort);

    } else {

        SetLastError(dwRet);
        bRet = FALSE;
    }

    FreeMonitorUI(pMonitorUIData);

    return bRet;
}


BOOL
DeletePortWThunk(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    DWORD       dwRet;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    LPWSTR      pMonitorUIDll = NULL;

    dwRet = GetMonitorUIDll(pName,pPortName,L"XcvPort",&pMonitorUIDll);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS)
        {
             RpcTryExcept
             {
                  MSG    msg;
                  if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
                     ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                  {
                       //
                       // The following functions cann't proceed synchronasly. The reason
                       // for that is in order to show the UI of the port monitor we need
                       // to be able to dispatch incomming messages and process them.
                       // For this reason the following call is an asynchronous call and the
                       // success or failure doesn't in reality tell us anything more than
                       // than the async process started or not
                       //
                       if(bRet = RPCSplWOW64DeletePort((ULONG_PTR)hWnd,
                                                       pName,
                                                       pMonitorUIDll,
                                                       pPortName,
                                                       &dwRet))
                       {
                            //
                            // The following is the required message loop for processing messages
                            // from the UI. The window handle has to be NULL in order to process
                            // messages from all windows in the calling Thread , otherwise we would
                            // have message dispatching problems
                            //
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                //
                                // In This message loop We should trap a User defined message
                                // which indicates the success or the failure of the operation
                                //
                                if(msg.message == WM_ENDDELPORT)
                                {
                                    bRet      = (BOOL)msg.wParam;
                                    if(!bRet)
                                         dwRet = (DWORD)msg.lParam;
                                    else
                                         dwRet = ERROR_SUCCESS;
                                    DelHandleFromList(hWnd);
                                    break;
                                }
                                else if(msg.message == WM_SURROGATEFAILURE)
                                {
                                     //
                                     // This means that the server process died and we have
                                     // break from the message loop
                                     //
                                     bRet = FALSE;
                                     SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                     break;
                                }
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                       }
                  }
                  else
                  {
                       bRet = FALSE;
                  }
                  SetLastError(dwRet);
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                  bRet = FALSE;
             }
             RpcEndExcept
        }
        else
            bRet = KickoffThread(pName, hWnd, pPortName, RpcDeletePort);

        if(pMonitorUIDll)
        {
           FreeSplMem(pMonitorUIDll);
        }

    }
    else
    {
        SetLastError(dwRet);
        bRet = FALSE;
    }
    return(bRet);
}


BOOL
DeletePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
     if(RunInWOW64())
     {
          return(DeletePortWThunk(pName,
                                  hWnd,
                                  pPortName));
     }
     else
     {
          return(DeletePortWNative(pName,
                                   hWnd,
                                   pPortName));
     }
}

DWORD
GetMonitorUI(
    IN PCWSTR           pszMachineName,
    IN PCWSTR           pszObjectName,
    IN PCWSTR           pszObjectType,
    OUT PMONITORUI      *ppMonitorUI,
    OUT PMONITORUIDATA  *ppMonitorUIData
    )
{
    DWORD   ReturnValue;
    DWORD   dwDummy;        // RPC needs an address for 'out' parameters
    HANDLE  hXcv = NULL;
    PBYTE   pOutputData = NULL;
    DWORD   cbOutput;
    PWSTR   pszServerName = NULL;
    PRINTER_DEFAULTS Default;
    PMONITORUI  (*pfnInitializePrintMonitorUI)(VOID) = NULL;
    DWORD   dwStatus;
    BOOL    bAllocBuffer = FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    PMONITORUIDATA pMonitorUIData = NULL;
    HRESULT hRetval;

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    *ppMonitorUI        = NULL;
    *ppMonitorUIData    = NULL;

    if (!(pszServerName = ConstructXcvName(pszMachineName, pszObjectName, pszObjectType))) {
        ReturnValue = GetLastError();
        goto Done;
    }

    RpcTryExcept {

        ReturnValue = OpenPrinter(  pszServerName,
                                    &hXcv,
                                    &Default);

        if (!ReturnValue) {
            ReturnValue = GetLastError();
            goto Done;
        }

        pOutputData = (PBYTE) btBuffer;
        ZeroMemory(pOutputData, MAX_STATIC_ALLOC);

        ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                    L"MonitorUI",
                                    (PBYTE) &dwDummy,
                                    0,
                                    pOutputData,
                                    MAX_STATIC_ALLOC,
                                    &cbOutput,
                                    &dwStatus);

        if (ReturnValue != ERROR_SUCCESS)
             goto Done;

        if (dwStatus != ERROR_SUCCESS) {

            if (dwStatus != ERROR_INSUFFICIENT_BUFFER) {
                ReturnValue = dwStatus;
                goto Done;
            }
            if (!(pOutputData = AllocSplMem(cbOutput))) {
                ReturnValue = GetLastError();
                goto Done;
            }

            bAllocBuffer = TRUE;
            ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                        L"MonitorUI",
                                        (PBYTE) &dwDummy,
                                        0,
                                        pOutputData,
                                        cbOutput,
                                        &cbOutput,
                                        &dwStatus);
        }

        if (ReturnValue != ERROR_SUCCESS)
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            ReturnValue = dwStatus;
            goto Done;
        }

        //
        // Create and initialize the monitor UI data.
        //
        hRetval = CreateMonitorUIData(&pMonitorUIData);

        if (FAILED(hRetval)) {
            ReturnValue = HRESULT_CODE(hRetval);
            goto Done;
        }

        //
        // Get and activate the monitor UI context.
        //
        hRetval = GetMonitorUIActivationContext((PCWSTR)pOutputData, pMonitorUIData);

        if (FAILED(hRetval)) {
            ReturnValue = HRESULT_CODE(hRetval);
            goto Done;
        }

        if (!(pMonitorUIData->hLibrary = LoadLibrary(pMonitorUIData->pszMonitorName))) {
            ReturnValue = GetLastError();
            goto Done;
        }

        pfnInitializePrintMonitorUI = (PMONITORUI (*)(VOID))
                                       GetProcAddress(pMonitorUIData->hLibrary, "InitializePrintMonitorUI");

        if (!pfnInitializePrintMonitorUI) {
            ReturnValue = GetLastError();
            goto Done;
        }

        *ppMonitorUI     = (*pfnInitializePrintMonitorUI)();
        *ppMonitorUIData = pMonitorUIData;
        pMonitorUIData   = NULL;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(ReturnValue = TranslateExceptionCode(RpcExceptionCode()));

    } RpcEndExcept


Done:

    if (bAllocBuffer) {
        FreeSplMem(pOutputData);
    }

    if (hXcv) {
        ClosePrinter(hXcv);
    }

    FreeSplMem(pszServerName);
    FreeMonitorUI(pMonitorUIData);

    return ReturnValue;
}

/*++

Routine Name:

    CreateMonitorUIData

Routine Description:

    This function creates and initialize the monitor UI data.

Arguments:

    ppMonitorUIData - pointer where to return the monitor UI data

Returns:

    An HRESULT

--*/
HRESULT
CreateMonitorUIData(
    OUT MONITORUIDATA **ppMonitorUIData
    )
{
    HRESULT         hRetval         = E_FAIL;
    MONITORUIDATA   *pMonitorUIData = NULL;

    hRetval = ppMonitorUIData ? S_OK : E_POINTER;

    if (SUCCEEDED(hRetval))
    {
        *ppMonitorUIData = NULL;
    }

    if (SUCCEEDED(hRetval))
    {
        pMonitorUIData = AllocSplMem(sizeof(MONITORUIDATA));

        hRetval = pMonitorUIData ? S_OK : E_OUTOFMEMORY;
    }

    //
    // Initialize the monitor UI data.
    //
    if (SUCCEEDED(hRetval))
    {
        ZeroMemory(pMonitorUIData, sizeof(MONITORUIDATA));
        pMonitorUIData->hActCtx = INVALID_HANDLE_VALUE;
    }

    //
    // Everything succeeded, copy back the pointer.
    //
    if (SUCCEEDED(hRetval))
    {
        *ppMonitorUIData = pMonitorUIData;
    }

    return hRetval;
}

/*++

Routine Name:

    FreeMonitorUI

Routine Description:

    This function releases the monitor UI data.  It is responsible
    for releasing the monitor library as well the monitor fusion
    activation context.  Note this function is called in error cases
    when GetMonitorUI fails so all the parameters must be checked
    for validity before use.

Arguments:

    pMonitorUIData - pointer to the monitor UI data created in GetMonitorUI

Returns:

    Nothing.

--*/
VOID
FreeMonitorUI(
    IN PMONITORUIDATA pMonitorUIData
    )
{
    //
    // Preserve the last error.
    //
    DWORD dwLastError = GetLastError();

    if (pMonitorUIData)
    {
        //
        // Release the monitor library.
        //
        if (pMonitorUIData->hLibrary)
        {
            FreeLibrary(pMonitorUIData->hLibrary);
        }

        //
        // If we have an activation cookie then deactivate this context
        //
        if (pMonitorUIData->bDidActivate)
        {
            DeactivateActCtx(0, pMonitorUIData->lActCtx);
        }

        //
        // If we have created an activation context then release it.
        //
        if (pMonitorUIData->hActCtx != INVALID_HANDLE_VALUE && pMonitorUIData->hActCtx != ACTCTX_EMPTY)
        {
            ReleaseActCtx(pMonitorUIData->hActCtx);
        }

        //
        // Release the monitor name
        //
        if (pMonitorUIData->pszMonitorName)
        {
            FreeSplMem(pMonitorUIData->pszMonitorName);
        }

        //
        // Release the monitor UI data back to the heap.
        //
        FreeSplMem(pMonitorUIData);
    }

    SetLastError(dwLastError);
}

/*++

Routine Name:

    GetMonitorUIActivationContext

Routine Description:

    This routine gets the monitor UI activation context and then
    activates the context.  If the monitor does not have an activation
    context in it's resource file it will activate the empty context
    for compatiblity with previous version of common control.

Arguments:

    pszMonitorName  - pointer to the monitor name.
    pMonitorUIData  - pointer to the monitor UI data created in GetMonitorUI

Returns:

    An HRESULT

--*/
HRESULT
GetMonitorUIActivationContext(
    IN PCWSTR           pszMonitorName,
    IN MONITORUIDATA    *pMonitorUIData
    )
{
    HRESULT hRetval     = E_FAIL;

    hRetval = pszMonitorName && pMonitorUIData ? S_OK : E_INVALIDARG;

    //
    // Get the monitor full name.
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetMonitorUIFullName(pszMonitorName, &pMonitorUIData->pszMonitorName);
    }

    //
    // See if there is an activation context in the resouce of this
    // monitor UI binary.  If there is we will create this context
    // else we will create the empty context for backward compatibility.
    //
    if (SUCCEEDED(hRetval))
    {
        ACTCTX  act;

        ZeroMemory(&act, sizeof(act));

        act.cbSize          = sizeof(act);
        act.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpSource        = pMonitorUIData->pszMonitorName;
        act.lpResourceName  = MAKEINTRESOURCE(ACTIVATION_CONTEXT_RESOURCE_ID);

        pMonitorUIData->hActCtx = CreateActCtx(&act);

        if (pMonitorUIData->hActCtx == INVALID_HANDLE_VALUE)
        {
            pMonitorUIData->hActCtx = ACTCTX_EMPTY;
        }

        hRetval = pMonitorUIData->hActCtx ? S_OK : E_FAIL;
    }

    //
    // Activate this context.
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = ActivateActCtx(pMonitorUIData->hActCtx,
                                 &pMonitorUIData->lActCtx) ? S_OK : GetLastErrorAsHResult();

        pMonitorUIData->bDidActivate = SUCCEEDED(hRetval);
    }

    return hRetval;
}

/*++

Routine Name:

    GetMonitorUIFullName

Routine Description:

    Get's the full monitor name.  XCV is currently returning just the file name
    not fully qualified.  However the ddk does not indicate whether a monitor
    should or should not return the monitor name fully qualified or not.  Hence
    this routine was written.  It first builds a full name then it checkes if the
    name is valid and if it is not then the orginal name is assumed fully
    qualified and returned to the caller.

Arguments:

    pszMonitorName  - pointer to the monitor name.
    ppszMonitorName - pointer where to return a monitor name pointer

Returns:

    An HRESULT

--*/
HRESULT
GetMonitorUIFullName(
    IN PCWSTR   pszMonitorName,
    IN PWSTR    *ppszMonitorName
    )
{
    HRESULT hRetval             = E_FAIL;
    PWSTR   pszTempMonitorName  = NULL;
    PWSTR   pszBuff             = NULL;
    DWORD   dwRetval            = ERROR_SUCCESS;
    PWSTR   pFileName           = NULL;   

    hRetval = pszMonitorName && ppszMonitorName ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *ppszMonitorName = NULL;

        //
        // Allocate a temp buffer, use the heap.  Too much stack usage
        // will cause stress failures.
        //
        pszBuff = (PWSTR)AllocSplMem((MAX_PATH) * sizeof(WCHAR));

        hRetval = pszBuff ? S_OK : E_OUTOFMEMORY;

        if (SUCCEEDED(hRetval))
        {
            //
            // Get the monitor full path and the monitor name.
            //
            hRetval = GetFullPathName(pszMonitorName, MAX_PATH, pszBuff, &pFileName) ? 
                         S_OK : 
                         GetLastErrorAsHResult();

            if (SUCCEEDED(hRetval))
            {
                //
                // Check to see if the monitor name came as a fully qualified path.
                //
                if (_wcsicmp(pszBuff, pszMonitorName) == 0) 
                {
                    //
                    // We got a full path. Use it as it is.
                    //
                    dwRetval = StrCatAlloc(&pszTempMonitorName,
                                           pszBuff,
                                           NULL);

                    hRetval = HRESULT_FROM_WIN32(dwRetval);
                }
                else if (_wcsicmp(pFileName, pszMonitorName) == 0) 
                {
                    //
                    // Xcv can return the monitor name. We want to build the full path 
                    // out of the name and system directory.
                    //    
                    hRetval = GetSystemDirectory(pszBuff, MAX_PATH) ? S_OK : GetLastErrorAsHResult();

                    if (SUCCEEDED(hRetval))
                    {
                        //
                        // Append the monitor name to the system directory.
                        //    
                        dwRetval = StrCatAlloc(&pszTempMonitorName,
                                               pszBuff,
                                               szSlash,
                                               pszMonitorName,
                                               NULL);

                        hRetval = HRESULT_FROM_WIN32(dwRetval);
                    }

                }     
                else
                {
                    //
                    // We got a relative path. Just fail the call.
                    //
                    hRetval = HResultFromWin32(ERROR_INVALID_NAME);
                    
                }
                
                if (SUCCEEDED(hRetval))
                {
                    hRetval = GetFileAttributes(pszTempMonitorName) != INVALID_FILE_ATTRIBUTES ? 
                                              S_OK : 
                                              GetLastErrorAsHResult();                            
                }
            }
        }
    }

    //
    // We have a valid name return it to the caller.
    //
    if (SUCCEEDED(hRetval))
    {
        *ppszMonitorName    = pszTempMonitorName;
        pszTempMonitorName  = NULL;
    }

    FreeSplMem(pszBuff);
    FreeSplMem(pszTempMonitorName);

    return hRetval;
}

DWORD
GetMonitorUIDll(
    PCWSTR      pszMachineName,
    PCWSTR      pszObjectName,
    PCWSTR      pszObjectType,
    PWSTR       *pMonitorUIDll
)
{
    DWORD   ReturnValue;
    DWORD   dwDummy;        // RPC needs an address for 'out' parameters
    HANDLE  hXcv = NULL;
    PBYTE   pOutputData = NULL;
    DWORD   cbOutput;
    PWSTR   pszServerName = NULL;
    PRINTER_DEFAULTS Default;
    PMONITORUI  (*pfnInitializePrintMonitorUI)(VOID) = NULL;
    DWORD   dwStatus;
    BOOL    bAllocBuffer = FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    HRESULT hr;

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    *pMonitorUIDll = NULL;

    if (!(pszServerName = ConstructXcvName(pszMachineName, pszObjectName, pszObjectType))) {
        ReturnValue = GetLastError();
        goto Done;
    }

    RpcTryExcept {

        ReturnValue = OpenPrinter(  pszServerName,
                                    &hXcv,
                                    &Default);

        if (!ReturnValue) {
            ReturnValue = GetLastError();
            goto Done;
        }

        pOutputData = (PBYTE) btBuffer;
        ZeroMemory(pOutputData, MAX_STATIC_ALLOC);

        ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                    L"MonitorUI",
                                    (PBYTE) &dwDummy,
                                    0,
                                    pOutputData,
                                    MAX_STATIC_ALLOC,
                                    &cbOutput,
                                    &dwStatus);

        if (ReturnValue != ERROR_SUCCESS)
             goto Done;

        if (dwStatus != ERROR_SUCCESS) {

            if (dwStatus != ERROR_INSUFFICIENT_BUFFER) {
                ReturnValue = dwStatus;
                goto Done;
            }
            if (!(pOutputData = AllocSplMem(cbOutput))) {
                ReturnValue = GetLastError();
                goto Done;
            }

            bAllocBuffer = TRUE;
            ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                        L"MonitorUI",
                                        (PBYTE) &dwDummy,
                                        0,
                                        pOutputData,
                                        cbOutput,
                                        &cbOutput,
                                        &dwStatus);
        }
        else
        {
            cbOutput = MAX_STATIC_ALLOC;
        }

        if (ReturnValue != ERROR_SUCCESS)
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            ReturnValue = dwStatus;
            goto Done;
        }

        if (!(*pMonitorUIDll = AllocSplMem(cbOutput))) {
                ReturnValue = GetLastError();
                goto Done;
        }

        if (FAILED(hr = StringCbCopy(*pMonitorUIDll, cbOutput, (LPWSTR)pOutputData)))
        {
            SetLastError(ReturnValue = HRESULT_CODE(hr));
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(ReturnValue = TranslateExceptionCode(RpcExceptionCode()));

    } RpcEndExcept


Done:

    if (bAllocBuffer) {
        FreeSplMem(pOutputData);
    }

    FreeSplMem(pszServerName);

    if (hXcv) {
        ClosePrinter(hXcv);
    }
    return ReturnValue;
}

HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW   pDevMode
)
{
    HANDLE  ReturnValue;
    DWORD   Error;
    DEVMODE_CONTAINER DevModeContainer;
    HANDLE  hGdi;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if( BoolFromHResult(SplIsValidDevmodeNoSizeW(pDevMode ))){

        DevModeContainer.cbBuf = pDevMode->dmSize + pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pDevMode;

    } else {

        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = (LPBYTE)pDevMode;
    }

    do {

        RpcTryExcept {

            if (Error = RpcCreatePrinterIC( pSpool->hPrinter,
                                            &hGdi,
                                            &DevModeContainer )){

                SetLastError(Error);
                ReturnValue = FALSE;

            } else {

                ReturnValue = hGdi;
                InterlockedIncrement( &gcClientICHandle );
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    BOOL ReturnValue;

    RpcTryExcept {

        if (ReturnValue = RpcPlayGdiScriptOnPrinterIC(hPrinterIC, pIn, cIn,
                                                      pOut, cOut, ul)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
)
{
    BOOL    ReturnValue;

    RpcTryExcept {

        if (ReturnValue = RpcDeletePrinterIC(&hPrinterIC)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
            InterlockedDecrement( &gcClientICHandle );
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


/****************************************************************************
*  INT QueryRemoteFonts( HANDLE, PUNIVERSAL_FONT_ID, ULONG )
*
* This is a version of QueryRemoteFonts that doesn't do any
* caching based on the time stamp returned by QueryFonts.  Additionally,
* it uses the CreatePrinterIC/PlayGdiScriptOnDC mechanism since it was
* already in place.  It may be better to eliminate CreatePrinterIC and use
* an HPRINTER instead.
*
* Note that if the user doesn't pass in a buffer large enough to hold all
* the fonts we truncate the list and copy only enough fonts for which there
* is room but will still return success.  This is okay because the worst
* that can happen in this case is that we may download unecessary fonts in
* the spool stream.
*
*
*  History:
*   5/25/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/


INT QueryRemoteFonts(
    HANDLE hPrinter,
    PUNIVERSAL_FONT_ID pufi,
    ULONG nBufferSize
)
{
    HANDLE hPrinterIC;
    PBYTE pBuf;
    DWORD dwDummy,cOut;
    INT  iRet = -1;

    hPrinterIC = CreatePrinterIC( hPrinter, NULL );

    if( hPrinterIC )
    {
        cOut = (nBufferSize * sizeof(UNIVERSAL_FONT_ID)) + sizeof(INT);

        pBuf = LocalAlloc( LMEM_FIXED, cOut );

        if( pBuf )
        {
            // Just call PlayGdiScriptOnPrinterIC for now since the piping is in place.
            // For some reason the RPC stuff doesn't like NULL pointers for pIn so we
            // use &dwDummy instead;


            if(PlayGdiScriptOnPrinterIC(hPrinterIC,(PBYTE) &dwDummy,
                                        sizeof(dwDummy),pBuf,cOut, 0))
            {
                DWORD dwSize = *((DWORD*) pBuf );

                iRet = (INT) dwSize;
                SPLASSERT( iRet >= 0 );

                //
                // If the supplied buffer is not large enough, we truncate the data
                // The caller needs to check if he needs to call again this function
                // with a larger buffer
                //
                if( dwSize > nBufferSize )
                {
                    dwSize = nBufferSize;
                }
                memcpy(pufi,pBuf+sizeof(DWORD),dwSize * sizeof(UNIVERSAL_FONT_ID));
            }

            LocalFree( pBuf );
        }

        DeletePrinterIC( hPrinterIC );
    }

    return(iRet);
}



DWORD
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    return ERROR_NOT_SUPPORTED;
}

BOOL
AddMonitorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    BOOL  ReturnValue;
    MONITOR_CONTAINER   MonitorContainer;
    MONITOR_INFO_2  MonitorInfo2;

    switch (Level) {

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (pMonitorInfo)
        MonitorInfo2 = *(PMONITOR_INFO_2)pMonitorInfo;
    else
        memset(&MonitorInfo2, 0, sizeof(MonitorInfo2));

    if (!MonitorInfo2.pEnvironment || !*MonitorInfo2.pEnvironment) {
        if(RunInWOW64()) {
            MonitorInfo2.pEnvironment = szIA64Environment;
        }
        else {
            MonitorInfo2.pEnvironment = szEnvironment;
        }
    }

    MonitorContainer.Level = Level;
    MonitorContainer.MonitorInfo.pMonitorInfo2 = (MONITOR_INFO_2 *)&MonitorInfo2;

    RpcTryExcept {

        if (ReturnValue = RpcAddMonitor(pName, &MonitorContainer)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeleteMonitorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
)
{
    BOOL  ReturnValue;

    if (!pMonitorName || !*pMonitorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeleteMonitor(pName,
                                           pEnvironment,
                                           pMonitorName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    BOOL  ReturnValue;

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrintProcessor(pName,
                                                  pEnvironment,
                                                  pPrintProcessorName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
AddPrintProvidorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pProvidorInfo
)
{
    BOOL    ReturnValue;
    LPWSTR  pStr;

    PROVIDOR_CONTAINER   ProvidorContainer;
    RPC_PROVIDOR_INFO_2W RpcProvidorInfo;

    ProvidorContainer.Level = Level;

    switch (Level) {

    case 1:
        ProvidorContainer.ProvidorInfo.pProvidorInfo1 = (PROVIDOR_INFO_1 *)pProvidorInfo;
        break;

    case 2:
        RpcProvidorInfo.pOrder = ((PROVIDOR_INFO_2 *) pProvidorInfo)->pOrder;

        for (pStr = RpcProvidorInfo.pOrder;
             pStr && *pStr;
             pStr += (wcslen(pStr) + 1)) ;

        // Set the character count for the multisz string
        RpcProvidorInfo.cchOrder = (DWORD) ((ULONG_PTR) (pStr - RpcProvidorInfo.pOrder + 1));

        ProvidorContainer.ProvidorInfo.pRpcProvidorInfo2 = &RpcProvidorInfo;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (ReturnValue = RpcAddPrintProvidor(pName, &ProvidorContainer)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrintProvidorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProvidorName
)
{
    BOOL  ReturnValue;

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrintProvidor(pName,
                                                 pEnvironment,
                                                 pPrintProvidorName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

LPWSTR
IsaFileName(
    LPWSTR pOutputFile,
    LPWSTR FullPathName,
    DWORD  cchFullPathName
    )
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LPWSTR  pFileName=NULL;
    LPWSTR  pFullPathName=NULL;

    //
    // Special case for Word20c.Win
    //
    if (!_wcsicmp(pOutputFile, L"FILE")) {
        return NULL;
    }

    //
    // cchFullPathName needs to be at least MAX_PATH
    //
    if (GetFullPathName(pOutputFile, cchFullPathName, FullPathName, &pFileName)) {

        DBGMSG(DBG_TRACE, ("Fully qualified filename is %ws\n", FullPathName));

        //
        // Filenames containing ":" create a stream and a file on NTFS.  When the file is closed,
        // the stream is deleted (if DELETE_ON_CLOSE is specified) but the file remains.  Not only
        // that, but GetFileType will return FILE_TYPE_DISK.  You can see this by printing from IE
        // to a network printer.  The incoming name will be something like "157.55.3.5:PASSTHRU".
        // Therefore, we need to catch this case here.
        //
        if (pFileName && wcschr(pFileName, L':')) {
            return NULL;
        }

        hFile = CreateFile(pOutputFile,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE) {

            hFile = CreateFile(pOutputFile,
                               GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                               NULL);
        }

        if (hFile != INVALID_HANDLE_VALUE) {
            if (GetFileType(hFile) == FILE_TYPE_DISK) {
                pFullPathName = FullPathName;
            }
            CloseHandle(hFile);
        }
    }

    return pFullPathName;
}

BOOL IsaPortName(
        PKEYDATA pKeyData,
        LPWSTR pOutputFile
        )
{
    DWORD i = 0;
    UINT uStrLen;

    if (!pKeyData) {
        return(FALSE);
    }
    for (i=0; i < pKeyData->cTokens; i++) {

        //
        // If FILE: is one of the ports, and the app got the port
        // name from win.in (e.g., Nexx:), then we will put up the
        // print to file dialog, so we're not really printing to a port.
        //
        if (!lstrcmpi(pKeyData->pTokens[i], szFilePort)) {
            if ((!wcsncmp(pOutputFile, L"Ne", 2)) &&
                (*(pOutputFile + 4) == L':')) {
                return(FALSE);
            } else {
                continue;
            }
        }

        if (!lstrcmpi(pKeyData->pTokens[i], pOutputFile)) {
            return(TRUE);
        }
    }

    //
    // Fix for NeXY: ports
    //
    if (!_wcsnicmp(pOutputFile, L"Ne", 2)) {

        uStrLen = wcslen( pOutputFile );

        //
        // Ne00: or Ne00 if app truncates it
        //
        if (( uStrLen == 5 ) || ( uStrLen == 4 ) )  {

            // Check for two Digits

            if (( pOutputFile[2] >= L'0' ) && ( pOutputFile[2] <= L'9' ) &&
                ( pOutputFile[3] >= L'0' ) && ( pOutputFile[3] <= L'9' )) {

                //
                // Check for the final : as in Ne01:,
                // note some apps will truncate it.
                //
                if (( uStrLen == 5 ) && (pOutputFile[4] != L':')) {
                    return FALSE;
                }
                return TRUE;
            }
        }
    }
    return(FALSE);
}

BOOL HasAFilePort(PKEYDATA pKeyData)
{
    DWORD i = 0;

    if (!pKeyData) {
        return(FALSE);
    }
    for (i=0; i < pKeyData->cTokens; i++) {
        if (!lstrcmpi(pKeyData->pTokens[i], szFilePort)) {
            return(TRUE);
        }
    }
    return(FALSE);
}

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT
GetCurrentThreadLastPopup(
        OUT HWND    *phwnd
    )
{
    HWND hwndOwner, hwndParent;
    HRESULT hr = E_INVALIDARG;
    GUITHREADINFO ti = {0};

    if( phwnd )
    {
        hr = E_FAIL;
        *phwnd = NULL;

        ti.cbSize = sizeof(ti);
        if( GetGUIThreadInfo(0, &ti) && ti.hwndActive )
        {
            *phwnd = ti.hwndActive;
            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner window
            *phwnd = GetLastActivePopup(*phwnd);
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}

LPWSTR
StartDocDlgW(
        HANDLE hPrinter,
        DOCINFO *pDocInfo
        )
 {
     DWORD       dwError = 0;
     DWORD       dwStatus = FALSE;
     LPWSTR      lpFileName = NULL;
     DWORD       rc = 0;
     PKEYDATA    pKeyData = NULL;
     LPWSTR      pPortNames = NULL;
     WCHAR      FullPathName[MAX_PATH];
     WCHAR      CurrentDirectory[MAX_PATH];
     PKEYDATA   pOutputList = NULL;
     WCHAR      PortNames[MAX_PATH];
     DWORD      i = 0;
     HWND       hwndParent = NULL;
     DWORD      cbSize;

#if DBG


     GetCurrentDirectory(MAX_PATH, CurrentDirectory);
     DBGMSG(DBG_TRACE, ("The Current Directory is %ws\n", CurrentDirectory));
#endif

     if (pDocInfo) {
         DBGMSG(DBG_TRACE, ("lpOutputFile is %ws\n", pDocInfo->lpszOutput ? pDocInfo->lpszOutput: L""));
     }
     memset(FullPathName, 0, sizeof(WCHAR)*MAX_PATH);

     pPortNames = GetPrinterPortList(hPrinter);
     pKeyData = CreateTokenList(pPortNames);

     //
     //  Check for the presence of multiple ports in the lpszOutput field
     //  the assumed delimiter is the comma. Thus there can be  no files with commas
     //

     if (pDocInfo && pDocInfo->lpszOutput && pDocInfo->lpszOutput[0]) {

         DWORD cchDocInfoOutput = wcslen(pDocInfo->lpszOutput) + 1;

         //
         // Make a copy of the pDocInfo->lpszOutput because CreateTokenList is destructive
         //

         wcsncpy(PortNames, pDocInfo->lpszOutput, COUNTOF(PortNames)-1);
         PortNames[COUNTOF(PortNames)-1] = 0;

         pOutputList = CreateTokenList(PortNames);
         if (pOutputList && (pOutputList->cTokens > 1) &&
             !lstrcmpi(pPortNames, pDocInfo->lpszOutput))
         {
             for (i= 0; i < pOutputList->cTokens; i++) {
                 if (!lstrcmpi(pOutputList->pTokens[i], szFilePort)) {

                     if (FAILED(StringCchCopy((LPWSTR)pDocInfo->lpszOutput, 
                                cchDocInfoOutput, 
                                szFilePort)))
                     {
                         goto StartDocDlgWReturn;
                     }
                     break;
                 }
            }
            if (i == pOutputList->cTokens) {

                if (FAILED(StringCchCopy((LPWSTR)pDocInfo->lpszOutput, 
                           cchDocInfoOutput, 
                           pOutputList->pTokens[0])))
                {
                    goto StartDocDlgWReturn;
                }
            }
         }

         FreeSplMem(pOutputList);
     }


     if (pDocInfo && pDocInfo->lpszOutput && pDocInfo->lpszOutput[0]) {

         if (IsaPortName(pKeyData, (LPWSTR)pDocInfo->lpszOutput)) {
             lpFileName = NULL;
             goto StartDocDlgWReturn;
         }

         if (IsaFileName((LPWSTR)pDocInfo->lpszOutput, FullPathName, COUNTOF(FullPathName))) {

             //
             // Fully Qualify the pathname for Apps like PageMaker and QuatroPro
             //
             if (lpFileName = LocalAlloc(LPTR, cbSize = (wcslen(FullPathName)+1)*sizeof(WCHAR))) {
                 StringCbCopy(lpFileName, cbSize, FullPathName);
             }
             goto StartDocDlgWReturn;
         }

     }

     if ((HasAFilePort(pKeyData)) ||
                 (pDocInfo && pDocInfo->lpszOutput
                    && (!_wcsicmp(pDocInfo->lpszOutput, L"FILE:") ||
                        !_wcsicmp(pDocInfo->lpszOutput, L"FILE"))))
     {
        //
        // since we have no idea who is calling us and we want to show
        // modal against the last active popup, we need to figure out
        // who is the last active popup of the calling app and then specify
        // as parent - GetCurrentThreadLastPopup does a little magic to
        // find the appropriate window.
        //
        DBGMSG(DBG_TRACE, ("We returned True from has file\n"));
        rc = (DWORD)DialogBoxParam( hInst,
                            MAKEINTRESOURCE( DLG_PRINTTOFILE ),
                            SUCCEEDED(GetCurrentThreadLastPopup(&hwndParent)) ? hwndParent : NULL, PrintToFileDlg,
                            (LPARAM)&lpFileName );
        if (rc == -1) {
           DBGMSG(DBG_TRACE, ("Error from DialogBoxParam- %d\n", GetLastError()));
           lpFileName = (LPWSTR)-1;
           goto StartDocDlgWReturn;

        } else if (rc == 0) {
           DBGMSG(DBG_TRACE, ("User cancelled the dialog\n"));
           lpFileName = (LPWSTR)-2;
           SetLastError( ERROR_CANCELLED );
           goto StartDocDlgWReturn;
        } else {
           DBGMSG(DBG_TRACE, ("The string was successfully returned\n"));
           DBGMSG(DBG_TRACE, ("The string is %ws\n", lpFileName? lpFileName: L"NULL"));
           goto StartDocDlgWReturn;
         }
     } else {
         lpFileName = (LPWSTR)NULL;
    }

StartDocDlgWReturn:

    FreeSplMem(pKeyData);
    FreeSplStr(pPortNames);

    return(lpFileName);
  }

BOOL
AddPortExW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
)
{
    DWORD   ReturnValue;
    PORT_CONTAINER PortContainer;
    PORT_VAR_CONTAINER PortVarContainer;
    PPORT_INFO_FF pPortInfoFF;
    PPORT_INFO_1 pPortInfo1;


    if (!lpBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (Level) {
    case (DWORD)-1:
        pPortInfoFF = (PPORT_INFO_FF)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfoFF = (PPORT_INFO_FF)pPortInfoFF;
        PortVarContainer.cbMonitorData = pPortInfoFF->cbMonitorData;
        PortVarContainer.pMonitorData = pPortInfoFF->pMonitorData;
        break;

    case 1:
        pPortInfo1 = (PPORT_INFO_1)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfo1 = (PPORT_INFO_1)pPortInfo1;
        PortVarContainer.cbMonitorData = 0;
        PortVarContainer.pMonitorData = NULL;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return(FALSE);
    }

    RpcTryExcept {
        if (ReturnValue = RpcAddPortEx(pName, (LPPORT_CONTAINER)&PortContainer,
                                         (LPPORT_VAR_CONTAINER)&PortVarContainer,
                                         lpMonitorName
                                         )) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else {
            ReturnValue = TRUE;
        }
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;
    } RpcEndExcept

    return ReturnValue;
}



BOOL
DevQueryPrint(
    HANDLE      hPrinter,
    LPDEVMODE   pDevMode,
    DWORD      *pResID
)
{
    BOOL        Ok = FALSE;
    HANDLE      hModule;
    INT_FARPROC pfn;

    if (hModule = LoadPrinterDriver(hPrinter)) {

        if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrint")) {

            try {

                Ok = (*pfn)(hPrinter, pDevMode, pResID);

            } except(1) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                Ok = FALSE;
            }
        }

        RefCntUnloadDriver(hModule, TRUE);
    }

    return(Ok);
}



BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
)
{
    BOOL        Ok = FALSE;
    HANDLE      hModule;
    INT_FARPROC pfn;

    if (hModule = LoadPrinterDriver(pDQPInfo->hPrinter)) {

        if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrintEx")) {

            try {

                Ok = (*pfn)(pDQPInfo);

            } except(1) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                Ok = FALSE;
            }
        }

        RefCntUnloadDriver(hModule, TRUE);
    }

    return(Ok);
}



BOOL
SpoolerDevQueryPrintW(
    HANDLE     hPrinter,
    LPDEVMODE  pDevMode,
    DWORD      *pResID,
    LPWSTR     pszBuffer,
    DWORD      cchBuffer
)
{
    BOOL        bRetVal = FALSE;
    HANDLE      hModule;
    INT_FARPROC pfn;

    if (!pDevMode ||
        BoolFromHResult(SplIsValidDevmodeNoSizeW(pDevMode)))
    {
        if (hModule = LoadPrinterDriver(hPrinter)) {

            if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrintEx")) {

                DEVQUERYPRINT_INFO  DQPInfo;

                DQPInfo.cbSize      = sizeof(DQPInfo);
                DQPInfo.Level       = 1;
                DQPInfo.hPrinter    = hPrinter;
                DQPInfo.pDevMode    = pDevMode;
                DQPInfo.pszErrorStr = (LPTSTR)pszBuffer;
                DQPInfo.cchErrorStr = (WORD)cchBuffer;
                DQPInfo.cchNeeded   = 0;

                try {

                    *pResID = (bRetVal = (*pfn)(&DQPInfo)) ? 0 : 0xDCDCDCDC;

                } except(1) {

                    SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                    bRetVal = FALSE;
                }

            } else if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrint")) {

                HRESULT hr;

                try {

                    if ((bRetVal = (*pfn)(hPrinter, pDevMode, pResID))  &&
                        (*pResID)) {

                        UINT    cch;

                        *pszBuffer = L'\0';

                        if (SUCCEEDED(hr = SelectFormNameFromDevMode(hPrinter, pDevMode, pszBuffer, cchBuffer)))
                        {
                            if (cch = lstrlen(pszBuffer)) {

                                pszBuffer    += cch;
                                *pszBuffer++  = L' ';
                                *pszBuffer++  = L'-';
                                *pszBuffer++  = L' ';
                                cchBuffer    -= (cch + 3);
                            }

                            LoadString(hModule, *pResID, pszBuffer, cchBuffer);
                        }
                        else
                        {
                            bRetVal = FALSE;
                            SetLastError(HRESULT_CODE(hr));
                        }
                    }

                } except(1) {

                    SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                    bRetVal = FALSE;
                }
            }

            RefCntUnloadDriver(hModule, TRUE);
        }
    }

    return(bRetVal);
}


HRESULT
SelectFormNameFromDevMode(
    HANDLE      hPrinter,
    PDEVMODEW   pDevModeW,
    LPWSTR      pFormName,
    ULONG       cchBuffer
    )

/*++

Routine Description:

    This function pick the current form associated with current devmode and
    return a form name pointer


Arguments:

    hPrinter    - Handle to the printer object

    pDevModeW   - Pointer to the unicode devmode for this printer

    FormName    - Pointer to the formname to be filled


Return Value:

    Either a pointer to the FormName passed in if we do found one form,
    otherwise it return NULL to signal a failue


Author:

    21-Mar-1995 Tue 16:57:51 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    DWORD           cb;
    DWORD           cRet;
    LPFORM_INFO_1   pFIBase;
    LPFORM_INFO_1   pFI;
    BYTE            btBuffer[MAX_STATIC_ALLOC];
    BOOL            bAllocBuffer = FALSE;
    HRESULT         hr           = S_OK;

    //
    // 1. If the DM_FORMNAME is turned on, then we want to check this bit first
    //    because it only specific to the NT which using form.  The form name
    //    supposed set by any NT driver but not win31 or Win95.Use the
    //    dmFormName only if dmPaperSize, dmPaperLength and dmPaperWidth fields
    //    are not set. If any of them is set then we have to find a form using
    //    the value in these fields.
    //

    if ( (pDevModeW->dmFields & DM_FORMNAME)
         && (!(pDevModeW->dmFields & (DM_PAPERSIZE |
                                      DM_PAPERLENGTH |
                                      DM_PAPERWIDTH))) ) {

        return StringCchCopy(pFormName, cchBuffer, pDevModeW->dmFormName);
    }

    //
    // For all other cases we need to get forms data base first, but we want
    // to set the form name to NULL so that we can check if we found one
    //

    cb      =
    cRet    = 0;
    pFIBase =
    pFI     = NULL;

    pFIBase = (LPFORM_INFO_1) btBuffer;
    ZeroMemory(pFIBase, MAX_STATIC_ALLOC);

    if (!EnumForms(hPrinter, 
                   1, 
                   (LPBYTE)pFIBase, 
                   MAX_STATIC_ALLOC,
                   &cb, 
                   &cRet)                             &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pFIBase = (LPFORM_INFO_1)LocalAlloc(LPTR, cb))) {

         bAllocBuffer = TRUE;
         hr = EnumForms(hPrinter, 1, (LPBYTE)pFIBase, cb, &cb, &cRet) ? 
                 S_OK : 
                 GetLastErrorAsHResult();         
    }

    if (SUCCEEDED(hr)) {

        //
        // 2. If user specified dmPaperSize then honor it, otherwise, it must
        //    be a custom form, and we will check to see if it match one of
        //    in the database
        //

        if ((pDevModeW->dmFields & DM_PAPERSIZE)        &&
            (pDevModeW->dmPaperSize >= DMPAPER_FIRST)   &&
            (pDevModeW->dmPaperSize <= (SHORT)cRet)) {

            //
            // We go the valid index now
            //

            pFI = pFIBase + (pDevModeW->dmPaperSize - DMPAPER_FIRST);

        } else if ((pDevModeW->dmFields & DM_PAPER_WL) == DM_PAPER_WL) {

            LPFORM_INFO_1   pFICur = pFIBase;

            while (cRet--) {

                if ((DM_MATCH(pDevModeW->dmPaperWidth,  pFICur->Size.cx)) &&
                    (DM_MATCH(pDevModeW->dmPaperLength, pFICur->Size.cy))) {

                    //
                    // We found the match which has discern size differences
                    //

                    pFI = pFICur;

                    break;
                }

                pFICur++;
            }
        }
    }

    //
    // If we found the form then copy the name down, otherwise set the
    // formname to be NULL
    //

    if (pFI) {

        hr = StringCchCopy(pFormName, cchBuffer, pFI->pName);

    } else {

        *pFormName = L'\0';
        pFormName  = NULL;        
    }

    if (bAllocBuffer) {
        LocalFree((HLOCAL)pFIBase);
    }

    return hr;
}


BOOL
SetAllocFailCount(
    HANDLE  hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (ReturnValue = RpcSetAllocFailCount( pSpool->hPrinter,
                                                    dwFailCount,
                                                    lpdwAllocCount,
                                                    lpdwFreeCount,
                                                    lpdwFailCountHit )) {


                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}



BOOL
WINAPI
EnumPrinterPropertySheets(
    HANDLE  hPrinter,
    HWND    hWnd,
    LPFNADDPROPSHEETPAGE lpfnAdd,
    LPARAM  lParam
)
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
}


VOID
vUpdateTrayIcon(
    IN HANDLE hPrinter,
    IN DWORD JobId
    )
{
    SHCNF_PRINTJOB_DATA JobData;
    LPPRINTER_INFO_1 pPrinterInfo1;
    FARPROC pfnSHChangeNotify;
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BYTE btBuffer[MAX_PRINTER_INFO1];

    SPLASSERT( JobId );

    //
    // Avoid sending multiple notifications by setting this flag.
    // When other calls (notably StartDocPrinter) see this,
    // they will avoid sending a notification.
    //
    pSpool->Status |= SPOOL_STATUS_TRAYICON_NOTIFIED;

    if (InCSRProcess() || bLoadedBySpooler) {

        //
        // We are running in CSR or within the spooler, don't load up shell.
        //
        return;
    }

    ZeroMemory( &JobData, sizeof( JobData ));
    JobData.JobId = JobId;

    //
    // Get a copy of the real printer name
    //
    pPrinterInfo1 = (LPPRINTER_INFO_1) btBuffer;
    ZeroMemory(pPrinterInfo1, MAX_PRINTER_INFO1);

    if( pPrinterInfo1 ){

        DWORD dwNeeded;

        if( GetPrinter( hPrinter,
                        1,
                        (PBYTE)pPrinterInfo1,
                        MAX_PRINTER_INFO1,
                        &dwNeeded )){

            if (hShell32 == INVALID_HANDLE_VALUE)
                hShell32 = LoadLibrary( gszShell32 );

            if (hShell32) {

                pfnSHChangeNotify = GetProcAddress( hShell32,
                                                    "SHChangeNotify" );

                if( pfnSHChangeNotify ){

                    (*pfnSHChangeNotify)(
                        SHCNE_CREATE,
                        SHCNF_PRINTJOB | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
                        pPrinterInfo1->pName,
                        &JobData );

                }
            }
        }
    }
}


INT
CallDrvDocumentEventNative(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )
/*++

Routine Description:

    Call DrvDocumentEvent on driver UI

Arguments:

Return Value:

    -1  : DOCUMENTEVENT_FAILURE
     0  : DOCUMENTEVENT_UNSUPPORTED
     1  : DOCUMENTEVENT_SUCCESS

--*/
{
    HANDLE          hLibrary;
    INT_FARPROC     pfn;
    INT             ReturnValue=DOCUMENTEVENT_UNSUPPORTED;
    PSPOOL          pSpool = (PSPOOL)hPrinter;
    ULONG_PTR       lActCtx = 0;
    BOOL            bDidActivate = FALSE;

    if ( hLibrary = LoadPrinterDriver( hPrinter )) {

        //
        // Activate the empty context, we do not check the return value.
        // because this may be called for non UI document events.
        //
        bDidActivate = ActivateActCtx( ACTCTX_EMPTY, &lActCtx );

        //
        // Disable the call so we don't recurse if the
        // callback calls StartPage, etc.
        //
        pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

        if( pfn = (INT_FARPROC)GetProcAddress( hLibrary, "DrvDocumentEvent")){

            try {

                ReturnValue = (*pfn)( hPrinter,
                                      hdc,
                                      iEsc,
                                      cbIn,
                                      pulIn,
                                      cbOut,
                                      pulOut);

            } except(1) {

                SetLastError(TranslateExceptionCode(GetExceptionCode()));
                ReturnValue = DOCUMENTEVENT_FAILURE;
            }

            //
            // When driver does not export DrvDocumentEvent we leave
            // this bit disabled so we will not try to load the DLL
            // for future calls
            //
            pSpool->Status |= SPOOL_STATUS_DOCUMENTEVENT_ENABLED;
        }

        //
        // Deactivate the context
        //
        if( bDidActivate ){
            DeactivateActCtx( 0, lActCtx );
        }

        RefCntUnloadDriver(hLibrary, TRUE);
    }

    return ReturnValue;
}

INT
CallDrvDocumentEventThunk(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )
/*++

Routine Description:

    Call DrvDocumentEvent on driver UI

Arguments:

Return Value:

    -1  : DOCUMENTEVENT_FAILURE
     0  : DOCUMENTEVENT_UNSUPPORTED
     1  : DOCUMENTEVENT_SUCCESS

--*/
{
    HANDLE          hLibrary;
    INT_FARPROC     pfn;
    INT             ReturnValue=DOCUMENTEVENT_UNSUPPORTED;
    DWORD           dwRet = ERROR_SUCCESS;
    PSPOOL          pSpool = (PSPOOL)hPrinter;

    LPWSTR  PrinterName = pSpool->pszPrinter;

    pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

    RpcTryExcept
    {
        *((PULONG_PTR)pulOut) = (ULONG_PTR)0L;

        if((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS)
        {
             ReturnValue = RPCSplWOW64DocumentEvent(PrinterName,
                                                    (ULONG_PTR)hdc,
                                                    iEsc,
                                                    cbIn,
                                                    (LPBYTE) pulIn,
                                                    &cbOut,
                                                    (LPBYTE*) pulOut,
                                                    &dwRet);
        }
        else
        {
            SetLastError(dwRet);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = -1;
    }
    RpcEndExcept

    pSpool->Status |= SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

    return ReturnValue;
}

INT
CallDrvDocumentEvent(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )
{
     if(RunInWOW64())
     {
          return(CallDrvDocumentEventThunk(hPrinter,
                                           hdc,
                                           iEsc,
                                           cbIn,
                                           pulIn,
                                           cbOut,
                                           pulOut));
     }
     else
     {
          return(CallDrvDocumentEventNative(hPrinter,
                                            hdc,
                                            iEsc,
                                            cbIn,
                                            pulIn,
                                            cbOut,
                                            pulOut));
     }
}


INT
DocumentEvent(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )

/*++

Routine Description:

    Allow the driver UI dll to hook specific print events.

Arguments:

Return Value:

    -1  : DOCUMENTEVENT_FAILURE
     0  : DOCUMENTEVENT_UNSUPPORTED
     1  : DOCUMENTEVENT_SUCCESS

--*/

{
    DWORD               cbNeeded;
    INT                 ReturnValue = DOCUMENTEVENT_FAILURE;
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    PDOCEVENT_FILTER    pDoceventFilter = NULL;
    BOOL                bDocEventFilter = FALSE;
    BOOL                bCallDriver     = TRUE;
    UINT                uIndex;

    if( eProtectHandle( hPrinter, FALSE )){
        return DOCUMENTEVENT_FAILURE;
    }

    if( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_CREATEDCPRE ){

        if ( pSpool->pDoceventFilter ) {

            FreeSplMem(pSpool->pDoceventFilter);
            pSpool->pDoceventFilter = NULL;
        }

        //
        // First we will check if the driver wants to filter the events
        //
        cbNeeded = sizeof(DOCEVENT_FILTER) + sizeof(DWORD) * (DOCUMENTEVENT_LAST-2);
        pDoceventFilter = AllocSplMem(cbNeeded);

        if ( pDoceventFilter == NULL )
            goto Fail;

        pDoceventFilter->cbSize             = sizeof(DOCEVENT_FILTER);
        pDoceventFilter->cElementsAllocated = DOCUMENTEVENT_LAST-1;
        pDoceventFilter->cElementsReturned  = (UINT)-1;
        pDoceventFilter->cElementsNeeded    = (UINT)-1;

        //
        // Before every CreateDC, re-enable DocumentEvent.
        // If it fails on the first try, then don't try again
        // until the next CreateDC.
        //
        pSpool->Status |= SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

        ReturnValue = CallDrvDocumentEvent( hPrinter,
                                            hdc,
                                            DOCUMENTEVENT_QUERYFILTER,
                                            cbIn,
                                            pulIn,
                                            cbNeeded,
                                            (PVOID)pDoceventFilter);

        //
        // We only regard the call to be successful if the driver returned
        // success _and_ modified aither cElementsReturned or cElementsNeeded.
        // This is to handle the case where a driver returns success, but in
        // fact does not know how to handle the call.
        //
        bDocEventFilter = ReturnValue == DOCUMENTEVENT_SUCCESS &&
                            (pDoceventFilter->cElementsReturned  != (UINT)-1 ||
                             pDoceventFilter->cElementsNeeded    != (UINT)-1);

        if (pDoceventFilter->cElementsReturned  == (UINT)-1)
        {
            pDoceventFilter->cElementsReturned = 0;
        }

        if (pDoceventFilter->cElementsNeeded  == (UINT)-1)
        {
            pDoceventFilter->cElementsNeeded = 0;
        }

        if (bDocEventFilter) {

            //
            // Validity check
            //
            if ( pDoceventFilter->cElementsReturned > pDoceventFilter->cElementsAllocated ) {

                SPLASSERT(pDoceventFilter->cElementsReturned <= pDoceventFilter->cElementsAllocated);
                ReturnValue = DOCUMENTEVENT_FAILURE;
                goto Fail;

            //
            // For drivers that are written for future OS (with new doc events)
            // we still want to filter and send the doc events we support
            //
            // So we realloc and query
            //
            } else if ( pDoceventFilter->cElementsNeeded > pDoceventFilter->cElementsAllocated ) {

                uIndex = pDoceventFilter->cElementsNeeded;
                cbNeeded = sizeof(DOCEVENT_FILTER) + sizeof(DWORD) * (uIndex - 1);
                FreeSplMem(pDoceventFilter);
                ReturnValue = DOCUMENTEVENT_FAILURE;

                pDoceventFilter = AllocSplMem(cbNeeded);
                if ( pDoceventFilter == NULL )
                    goto Fail;

                pDoceventFilter->cbSize             = sizeof(DOCEVENT_FILTER);
                pDoceventFilter->cElementsAllocated = uIndex;

                ReturnValue = CallDrvDocumentEvent( hPrinter,
                                                    hdc,
                                                    DOCUMENTEVENT_QUERYFILTER,
                                                    cbIn,
                                                    pulIn,
                                                    cbNeeded,
                                                    (PVOID)pDoceventFilter);

                //
                // Validity check for second call
                //
                if ( ReturnValue == DOCUMENTEVENT_SUCCESS ) {

                    if ( pDoceventFilter->cElementsReturned > pDoceventFilter->cElementsAllocated ) {

                        SPLASSERT(pDoceventFilter->cElementsReturned <= pDoceventFilter->cElementsAllocated);
                        ReturnValue = DOCUMENTEVENT_FAILURE;;
                        goto Fail;
                    }
                }
            }
        }

        //
        // Not supported we go to old behavior (no filtering)
        //
        if ( bDocEventFilter && ReturnValue == DOCUMENTEVENT_SUCCESS )  {

            pSpool->pDoceventFilter = pDoceventFilter;
        } else {

            FreeSplMem(pDoceventFilter);
            pDoceventFilter = NULL;
        }
    }

    ReturnValue = DOCUMENTEVENT_UNSUPPORTED;

    if( pSpool->Status & SPOOL_STATUS_DOCUMENTEVENT_ENABLED ){

        //
        // When driver supports DOCUMENTEVENT_QUERYFILTER we will
        // only call events in the filter with
        // DOCUMENTEVENT_CREATEDCPRE being an exception
        //
        // When driver does not support it (or fails it) we revert to old
        // behavior and make all callbacks
        //
        if ( DOCUMENTEVENT_EVENT( iEsc ) != DOCUMENTEVENT_CREATEDCPRE   &&
             (pDoceventFilter = pSpool->pDoceventFilter) != NULL ) {

            for ( uIndex = 0, bCallDriver = FALSE ;
                  uIndex < pDoceventFilter->cElementsReturned && !bCallDriver ;
                  ++uIndex ) {

                if ( pDoceventFilter->aDocEventCall[uIndex] == DOCUMENTEVENT_EVENT(iEsc) )
                    bCallDriver = TRUE;
            }
        }

        if ( bCallDriver ) {

            ReturnValue = CallDrvDocumentEvent( hPrinter,
                                                hdc,
                                                iEsc,
                                                cbIn,
                                                pulIn,
                                                cbOut,
                                                pulOut);

            //
            // Old (i.e. before DOCUMENTEVENT_QUERYFILTER) behavior is
            // on DOCUMENTEVENT_CREATEDCPRE failure no more calls are made
            // to the driver UI dll. We preserve the same behavior.
            //
            // Note that some drivers return a large positive value for a success
            // code. So, ReturnValue <= DOCUMENTEVENT_UNSUPPORTED is the correct
            // implementation.
            // 
            if ( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_CREATEDCPRE   &&
                 ReturnValue <= DOCUMENTEVENT_UNSUPPORTED )
                pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;
        }

    }

    //
    // If it's a StartDocPost, a job was just added.  Notify the
    // tray icon if we haven't already.
    //
    if( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_STARTDOCPOST ){

        if( !( pSpool->Status & SPOOL_STATUS_TRAYICON_NOTIFIED )){

            //
            // If we have a StartDocPost, then issue a notification so that
            // the user's tray starts polling.  pulIn[0] holds the JobId.
            //
            vUpdateTrayIcon( hPrinter, (DWORD)((PULONG_PTR)pulIn)[0] );
        }

    } else {

        //
        // If we have sent a notification, then by the next time we get a
        // document event, we have completed any additional AddJobs or
        // StartDocPrinters.  Therefore we can reset the TRAYICON_NOTIFIED
        // flag, since any more AddJobs/StartDocPrinters are really new
        // jobs.
        //
        pSpool->Status &= ~SPOOL_STATUS_TRAYICON_NOTIFIED;
    }

Fail:
    if ( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_CREATEDCPRE   &&
         ReturnValue == DOCUMENTEVENT_FAILURE ) {

        FreeSplMem(pDoceventFilter);
        pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;
        pSpool->pDoceventFilter = NULL;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

/****************************************************************************
* INT QueryColorProfile()
*
* Returns:
*
*  -1 : Printer driver does not hook color profile.
*   0 : Error.
*   1 : Success.
*
* History:
*   8/Oct/1997 by Hideyuki Nagase [hideyukn]
*  Wrote it.
*****************************************************************************/

INT
QueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdevmode,
    ULONG       ulQueryMode,
    PVOID       pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
)
{
    INT    iRet = 0;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return 0;
    }

    if (pSpool->Status & SPOOL_STATUS_NO_COLORPROFILE_HOOK) {

        //
        // DrvQueryColorProfile is not supported in Printer driver.
        //
        iRet = -1;

    } else {

        HANDLE  hLibrary;
        INT_FARPROC pfn;

        if (!pdevmode ||
            BoolFromHResult(SplIsValidDevmodeNoSizeW(pdevmode)))
        {

            if (hLibrary = LoadPrinterDriver( hPrinter )) {

                if (pfn = (INT_FARPROC)GetProcAddress( hLibrary, "DrvQueryColorProfile" )) {

                    try {

                        //
                        // Call the Printer UI driver.
                        //
                        iRet = (*pfn)( hPrinter,
                                       pdevmode,
                                       ulQueryMode,
                                       pvProfileData,
                                       pcbProfileData,
                                       pflProfileData );

                    } except(1) {

                        SetLastError(TranslateExceptionCode(RpcExceptionCode()));

                    }

                } else {

                    //
                    // Mark this driver does not export it, so later
                    // we can fail without load printer driver.
                    //
                    pSpool->Status |= SPOOL_STATUS_NO_COLORPROFILE_HOOK;

                    //
                    // Tell callee it is not supported.
                    //
                    iRet = -1;
                }

                RefCntUnloadDriver(hLibrary, TRUE);
            }
        }
    }

    vUnprotectHandle( hPrinter );

    return (iRet);
}

/****************************************************************************
*  BOOL QuerySpoolMode( hPrinter, pflSpoolMode, puVersion )
*
*  This function is called by GDI at StartDoc time when printing to an EMF.
*  It tell GDI whether to embed fonts in the job as well as what version of
*  EMF to generate.
*
*  GetPrinterInfo is called to determine
*  if the target is a remote machine and if so always telling GDI to embed
*  fonts which don't exist on the server into spool file.  Eventually this
*  call will be routed to the print processor on the target machine which
*  will use some UI/registry setting to determine what to do with fonts and
*  set the version number correctly.
*
*****************************************************************************/

// !!later move this define to the appropriate header file

#define QSM_DOWNLOADFONTS       0x00000001

BOOL
QuerySpoolMode(
    HANDLE hPrinter,
    LONG *pflSpoolMode,
    ULONG *puVersion
    )
{
    DWORD dwPrinterInfoSize = 0;
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    BOOL bRet = FALSE, bStatus, bAllocBuffer = FALSE;
    BYTE btBuffer[MAX_STATIC_ALLOC];


    pPrinterInfo2 = (PPRINTER_INFO_2) btBuffer;
    ZeroMemory(pPrinterInfo2, MAX_STATIC_ALLOC);

    bStatus = GetPrinter(hPrinter, 2, (LPBYTE) pPrinterInfo2,
                         MAX_STATIC_ALLOC, &dwPrinterInfoSize);

    if (!bStatus &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pPrinterInfo2 = (PRINTER_INFO_2*) LocalAlloc(LPTR,
                                                      dwPrinterInfoSize)))
    {
         bAllocBuffer = TRUE;
         bStatus = GetPrinter(hPrinter, 2, (LPBYTE) pPrinterInfo2,
                               dwPrinterInfoSize, &dwPrinterInfoSize);
    }

    if (bStatus)
    {
        *puVersion = 0x00010000;    // version 1.0

        //
        // No server means we are printing locally
        //
        *pflSpoolMode = ( pPrinterInfo2->pServerName == NULL ) ?
                            0 :
                            QSM_DOWNLOADFONTS;
        bRet = TRUE;
    }
    else
    {
        DBGMSG( DBG_WARNING, ( "QuerySpoolMode: GetPrinter failed %d.\n", GetLastError( )));
    }

    if (bAllocBuffer)
    {
        LocalFree( pPrinterInfo2 );
    }
    return bRet;
}


BOOL
SetPortW(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    )
{
    BOOL            ReturnValue;
    PORT_CONTAINER  PortContainer;

    switch (dwLevel) {

        case 3:
            if ( !pPortInfo ) {

                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            PortContainer.Level                 = dwLevel;
            PortContainer.PortInfo.pPortInfo3   = (PPORT_INFO_3)pPortInfo;
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    RpcTryExcept {

        if (bLoadedBySpooler && fpYSetPort) {

            ReturnValue = (*fpYSetPort)(pszName, pszPortName, &PortContainer, NATIVE_CALL);
        }
        else {
            ReturnValue = RpcSetPort(pszName, pszPortName, &PortContainer);
        }

        if (ReturnValue != ERROR_SUCCESS) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else {

            ReturnValue = TRUE;
        }
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
XcvDataW(
    HANDLE  hPrinter,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType  = 0;
    PSPOOL  pSpool      = (PSPOOL)hPrinter;
    UINT    cRetry      = 0;

    if (!pcbOutputNeeded){
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pInputData && !cbInputData)
        pInputData = (PBYTE) &ReturnValue;

    if (!pOutputData && !cbOutputData)
        pOutputData = (PBYTE) &ReturnValue;

    do {
        RpcTryExcept {

            if (ReturnValue = RpcXcvData(   pSpool->hPrinter,
                                            pszDataName,
                                            pInputData,
                                            cbInputData,
                                            pOutputData,
                                            cbOutputData,
                                            pcbOutputNeeded,
                                            pdwStatus)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;
            } else {
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             IsInvalidHandleError(GetLastError()) &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    if (!ReturnValue) {
        DBGMSG(DBG_TRACE,("XcvData Exception: %d\n", GetLastError()));
    }

    vUnprotectHandle( hPrinter );

    return ReturnValue;
}


PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
)
{
    DWORD   cchOutput;
    PWSTR   pOut;
    DWORD   Error = ERROR_SUCCESS;

    //
    // Chars for server and whack
    //
    cchOutput  = pServerName ? wcslen(pServerName) + 1 : 0;   /* "\\Server\," */
    cchOutput += wcslen(pObjectType);                        /* "\\Server\,XcvPort _" */
    cchOutput += pObjectName ? wcslen(pObjectName) : 0;      /* "\\Server\,XcvPort Object_" */

    //
    // Add chars for comma, space and NULL
    //
    cchOutput += 3;

    //
    // AllocSplMem zero fills the memory, so pOut will represent the empty string
    //
    if (pOut = AllocSplMem(cchOutput * sizeof(WCHAR))) 
    {
        Error = StrNCatBuff(pOut, 
                            cchOutput,
                            pServerName ? pServerName : L"",
                            pServerName ? L"\\," : L",",
                            pObjectType,
                            L" ",
                            pObjectName ? pObjectName : L"",
                            NULL);                
    }
    else
    {
        Error = GetLastError();
    }

    if (Error != ERROR_SUCCESS)
    {
        FreeSplMem(pOut);

        pOut = NULL;
    }

    return pOut;
}


HANDLE
ConnectToPrinterDlg(
    IN HWND hwnd,
    IN DWORD dwFlags
    )
{
    typedef HANDLE (WINAPI *PF_CONNECTTOPRINTERDLG)( HWND, DWORD );

    PF_CONNECTTOPRINTERDLG  pfConnectToPrinterDlg   = NULL;
    HANDLE                  hHandle                 = NULL;
    HINSTANCE               hLib                    = NULL;

    hLib = LoadLibrary( szPrintUIDll );

    if( hLib )
    {
        pfConnectToPrinterDlg = (PF_CONNECTTOPRINTERDLG)GetProcAddress( hLib, "ConnectToPrinterDlg" );

        if( pfConnectToPrinterDlg )
        {
            hHandle = pfConnectToPrinterDlg( hwnd, dwFlags );
        }

        FreeLibrary( hLib );

    }

    return hHandle;
}

DWORD
SendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCWSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
    )
{
    DWORD  dwRet  = ERROR_SUCCESS;
    PSPOOL pSpool = (PSPOOL)hPrinter;
    UINT   cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE ))
    {
        dwRet = GetLastError();
    }
    else
    {
        do
        {
            RpcTryExcept
            {
                if(ppResData)
                {
                    *ppResData = NULL;
                }

                dwRet = RpcSendRecvBidiData(pSpool->hPrinter,
                                            pAction,
                                            (PRPC_BIDI_REQUEST_CONTAINER)pReqData,
                                            (PRPC_BIDI_RESPONSE_CONTAINER*)ppResData);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                 dwRet = TranslateExceptionCode(RpcExceptionCode());
            }
            RpcEndExcept

        } while (IsInvalidHandleError(dwRet) &&
                 cRetry++ < MAX_RETRY_INVALID_HANDLE &&
                 RevalidateHandle( pSpool ));

        vUnprotectHandle( hPrinter );
    }
    //
    // If we are trying to communicate with a downlevel router, that does
    // not understand the meaning of SendRecvBidiData , we would get the
    // error code: RPC_S_PROCNUM_OUT_OF_RANGE which might be converted to
    // ERROR_NOT_SUPPORTED for better clearity and more consistency with
    // the a genaral return error code if feature is not supported.
    //
    if(dwRet == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        dwRet = ERROR_NOT_SUPPORTED;
    }
    return (dwRet);
}

VOID
PrintUIQueueCreate(
    IN HWND    hWnd,
    IN LPCWSTR PrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{

     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIQueueCreate((ULONG_PTR)GetForeGroundWindow(),
                                                       PrinterName,
                                                       CmdShow,
                                                       lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDQUEUECREATE)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}


VOID
PrintUIPrinterPropPages(
    IN HWND    hWnd,
    IN LPCWSTR PrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIPrinterPropPages((ULONG_PTR)GetForeGroundWindow(),
                                                            PrinterName,
                                                            CmdShow,
                                                            lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDPRINTERPROPPAGES)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}


VOID
PrintUIDocumentDefaults(
    IN HWND    hWnd,
    IN LPCWSTR PrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIDocumentDefaults((ULONG_PTR)GetForeGroundWindow(),
                                                            PrinterName,
                                                            CmdShow,
                                                            lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDDOCUMENTDEFAULTS)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}

DWORD WINAPI
AsyncPrinterSetup(
    PVOID pData
    )
{
     PrinterSetupData *pThrdData = (PrinterSetupData *)pData;

     RpcTryExcept
     {
         RPCSplWOW64PrintUIPrinterSetup((ULONG_PTR)GetForeGroundWindow(),
                                         pThrdData->uAction,
                                         pThrdData->cchPrinterName,
                                         pThrdData->PrinterNameSize,
                                         (byte *)pThrdData->pszPrinterName,
                                         pThrdData->pcchPrinterName,
                                         pThrdData->pszServerName);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}


BOOL
PrintUIPrinterSetup(
    IN     HWND     hWnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPWSTR   pszPrinterName,
       OUT UINT     *pcchPrinterName,
    IN     LPCWSTR  pszServerName
    )
{

    BOOL bRet   = FALSE;
    DWORD dwRet = ERROR_SUCCESS;


    RpcTryExcept
    {
        if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
           ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
        {
            HANDLE           hAsyncSetupThrd  = NULL;
            DWORD            AsyncSetupThrdId = 0;
            PrinterSetupData ThrdData;

            AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

            ThrdData.hWnd            = (ULONG_PTR)GetForeGroundWindow();
            ThrdData.uAction         = uAction;
            ThrdData.cchPrinterName  = cchPrinterName;
            ThrdData.PrinterNameSize = cchPrinterName*2;
            ThrdData.pszPrinterName  = pszPrinterName;
            ThrdData.pcchPrinterName = pcchPrinterName;
            ThrdData.pszServerName    = pszServerName;

            if(!(hAsyncSetupThrd = CreateThread(NULL,
                                                INITIAL_STACK_COMMIT,
                                                AsyncPrinterSetup,
                                                (PVOID)&ThrdData,
                                                0,
                                                &AsyncSetupThrdId)))
            {
                 dwRet = GetLastError();
            }
            else
            {
                MSG msg;
                while(GetMessage(&msg, NULL, 0, 0))
                {
                    if(msg.message == WM_ENDPRINTERSETUP)
                    {
                        bRet = (BOOL)msg.wParam;
                        SetLastError((DWORD)msg.lParam);
                        DelHandleFromList(hWnd);
                        break;
                    }
                    else if(msg.message == WM_SURROGATEFAILURE)
                    {
                         //
                         // This means that the server process died and we have
                         // break from the message loop
                         //
                         SetLastError(RPC_S_SERVER_UNAVAILABLE);
                         break;
                    }
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                WaitForSingleObject(hAsyncSetupThrd,INFINITE);
                CloseHandle(hAsyncSetupThrd);
            }
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
         SetLastError(TranslateExceptionCode(RpcExceptionCode()));
    }
    RpcEndExcept

    return bRet;
}

VOID
PrintUIServerPropPages(
    IN HWND    hWnd,
    IN LPCWSTR ServerName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIServerPropPages((ULONG_PTR)GetForeGroundWindow(),
                                                            ServerName,
                                                            CmdShow,
                                                            lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDSERVERPROPPAGES)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}


DWORD WINAPI
AsyncDocumentPropertiesWrap(
    PVOID pData
    )
{
     PumpThrdData *ThrdData = (PumpThrdData *)pData;

     RpcTryExcept
     {
         *ThrdData->Result = RPCSplWOW64PrintUIDocumentProperties(ThrdData->hWnd,
                                                                  ThrdData->PrinterName,
                                                                  ThrdData->TouchedDevModeSize,
                                                                  ThrdData->ClonedDevModeOutSize,
                                                                  ThrdData->ClonedDevModeOut,
                                                                  ThrdData->DevModeInSize,
                                                                  ThrdData->pDevModeInput,
                                                                  ThrdData->ClonedDevModeFill,
                                                                  ThrdData->fMode,
                                                                  ThrdData->fExclusionFlags,
                                                                  ThrdData->dwRet);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}


LONG
PrintUIDocumentPropertiesWrap(
    HWND hWnd,                  // handle to parent window
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    )
{
    DOCUMENTPROPERTYHEADER  DPHdr;
    PDEVMODE                pDM;
    LONG                    Result = -1;
    HANDLE                  hTmpPrinter = NULL;
    PSPOOL                  pSpool  = (PSPOOL)hPrinter;


    if (hPrinter == NULL)
    {
        if (!OpenPrinter( pDeviceName, &hTmpPrinter, NULL ))
        {
            hTmpPrinter = NULL;
        }
    }
    else
    {

        hTmpPrinter = hPrinter;
    }


    if( !eProtectHandle( hTmpPrinter, FALSE ))
    {
        LPWSTR PrinterName;
        MSG    msg;
        LONG   RetVal;
        DWORD  dwRet                = ERROR_SUCCESS;
        DWORD  ClonedDevModeOutSize = 0;
        DWORD  TouchedDevModeSize   = 0;
        BOOL   ClonedDevModeFill = (!!(fMode & DM_OUT_BUFFER) && pDevModeOutput);
        DWORD  DevModeInSize =  pDevModeInput ? (pDevModeInput->dmSize + pDevModeInput->dmDriverExtra) : 0;
        byte   **ClonedDevModeOut = NULL;

        if(ClonedDevModeOut = (byte **)LocalAlloc(LPTR,sizeof(byte *)))
        {
            *ClonedDevModeOut = NULL;

            if(pSpool)
            {
                PrinterName = pSpool->pszPrinter;
            }
            else
            {
                PrinterName = pDeviceName;
            }

            //
            // If fMode doesn't specify DM_IN_BUFFER, then zero out
            // pDevModeInput.
            //
            // Old 3.51 (version 1-0) drivers used to ignore the absence of
            // DM_IN_BUFFER and use pDevModeInput if it was not NULL.  It
            // probably did this because Printman.exe was broken.
            //
            // If the devmode is invalid, then don't pass one in.
            // This fixes MS Imager32 (which passes dmSize == 0) and
            // Milestones etc. 4.5.
            //
            // Note: this assumes that pDevModeOutput is still the
            // correct size!
            //
            if( !(fMode & DM_IN_BUFFER) || 
                !BoolFromHResult(SplIsValidDevmodeNoSizeW(pDevModeInput)))
            {

                //
                // If either are not set, make sure both are not set.
                //
                pDevModeInput  = NULL;
                DevModeInSize  = 0;
                fMode &= ~DM_IN_BUFFER;
            }

            RpcTryExcept
            {
                if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess, TRUE)) == ERROR_SUCCESS) &&
                   (!hWnd ||
                   ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS)))
                 {
                      HANDLE       hUIMsgThrd  = NULL;
                      DWORD        UIMsgThrdId = 0;
                      PumpThrdData ThrdData;

                      ThrdData.hWnd = (ULONG_PTR)hWnd;
                      ThrdData.PrinterName=PrinterName;
                      ThrdData.TouchedDevModeSize   = &TouchedDevModeSize;
                      ThrdData.ClonedDevModeOutSize = &ClonedDevModeOutSize;
                      ThrdData.ClonedDevModeOut = (byte**)ClonedDevModeOut;
                      ThrdData.DevModeInSize = DevModeInSize;
                      ThrdData.pDevModeInput = (byte*)pDevModeInput;
                      ThrdData.fMode = fMode;
                      ThrdData.fExclusionFlags = fExclusionFlags;
                      ThrdData.dwRet = &dwRet;
                      ThrdData.ClonedDevModeFill = ClonedDevModeFill;
                      ThrdData.Result = &Result;


                      //
                      // If we have a window handle , the following functions cann't
                      // proceed synchronasly. The reason for that is in order to show
                      // the UI of the driver property sheets we need to be able to dispatch
                      // incomming messages and process them.For this reason the following
                      // call would be asynchronous call and the success or failure doesn't
                      // in reality tell us anything more than than the async process started
                      // or not. We get the success of failure from the termination message.
                      // If we don't have a window handle, then the call is synchronous.
                      //
                      if(!(hUIMsgThrd = CreateThread(NULL,
                                                     INITIAL_STACK_COMMIT,
                                                     AsyncDocumentPropertiesWrap,
                                                     (PVOID)&ThrdData,
                                                     0,
                                                     &UIMsgThrdId)))
                      {
                           dwRet = GetLastError();
                      }
                      //
                      // The following is the required message loop for processing messages
                      // from the UI in case we have a window handle.
                      //
                      //
                       if(hUIMsgThrd && hWnd)
                       {
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                 //
                                 // In This message loop We should trap a User defined message
                                 // which indicates the success or the failure of the operation
                                 //
                                 if(msg.message == WM_ENDPRINTUIDOCUMENTPROPERTIES)
                                 {
                                      Result     = (LONG)msg.wParam;
                                      if(Result == -1)
                                           SetLastError((DWORD)msg.lParam);
                                      DelHandleFromList(hWnd);
                                      break;
                                 }
                                 else if(msg.message == WM_SURROGATEFAILURE)
                                 {
                                      //
                                      // This means that the server process died and we have
                                      // break from the message loop
                                      //
                                      Result = -1;
                                      SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                      break;
                                 }
                                 TranslateMessage(&msg);
                                 DispatchMessage(&msg);
                            }
                      }

                      if(hUIMsgThrd)
                      {
                          WaitForSingleObject(hUIMsgThrd,INFINITE);
                          CloseHandle(hUIMsgThrd);
                      }

                      if(Result!=-1 && pDevModeOutput)
                      {
                          Result = BoolFromHResult(SplIsValidDevmodeW((PDEVMODEW)(*ClonedDevModeOut), 
                                                                      TouchedDevModeSize)) ? 
                                     Result : 
                                     -1;

                         if (Result != -1)
                         {
                             memcpy((PVOID)pDevModeOutput,(PVOID)*ClonedDevModeOut,TouchedDevModeSize);
                         }
                          
                      }
                      if(*ClonedDevModeOut)
                      {
                           MIDL_user_free((PVOID)*ClonedDevModeOut);
                      }

                      if(ClonedDevModeOut)
                      {
                           LocalFree((PVOID) ClonedDevModeOut);
                      }
                 }
                 else
                 {
                      SetLastError(dwRet);
                 }
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                 SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            }
            RpcEndExcept

            vUnprotectHandle( hTmpPrinter );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }

    }

    if (hPrinter == NULL)
    {
        if( hTmpPrinter )
        {
            ClosePrinter(hTmpPrinter);
        }
    }
    return(Result);
}

/*++
    Function Name:
        MonitorRPCServerProcess

    Description:
        This function monitors the status of the RPC surrogate
        process. The one used in loading the required 64 dlls
        in a 32 bit client.This function always run in a
        separate thread

     Parameters:
        pData : Pointer to the process handle to monitor

     Return Value
       Always return 0
--*/


DWORD WINAPI
MonitorRPCServerProcess(
    PVOID pData
    )
{
    WndHndlList      ListObj;
    HANDLE*          phProcess;
    HANDLE           hEvent;
    LPMonitorThrdData pThrdData = (LPMonitorThrdData)pData;

    ListObj.Head       = 0x00000000;
    ListObj.Tail       = 0x00000000;
    ListObj.NumOfHndls = 0;

    //
    // reconstruct the Data for the thread
    //
    hEvent    = pThrdData->hEvent;
    phProcess = pThrdData->hProcess;

    EnterCriticalSection(&ProcessHndlCS);
    {
        GWndHndlList = &ListObj;
    }
    LeaveCriticalSection(&ProcessHndlCS);

    SetEvent(hEvent);

    WaitForSingleObject(*phProcess,INFINITE);

    EnterCriticalSection(&ProcessHndlCS);
    {
        CloseHandle(*((HANDLE *)phProcess));
        *((HANDLE *)phProcess) = 0x00000000;
        bMonitorThreadCreated = FALSE;
        RpcBindingFree(&hSurrogate);
        //
        // Release any windows which might be
        // locked on a surrogate process waiting
        // for its completion
        //
        ReleaseAndCleanupWndList();
    }
    LeaveCriticalSection(&ProcessHndlCS);

    return(0);
}

/*++
    Function Name:
        ConnectToLd64In32Server

    Description:
        This function make sure that we retry connection to the server
        in case of a very slight window where the Server terminated between
        our connection and the very first call.

     Parameters:
        hProcess : Pointer to the process handle that retrieves
                   the process handle of the server

     Return Value

--*/
DWORD
ExternalConnectToLd64In32Server(
    HANDLE *hProcess
    )
{
     DWORD RetVal = ERROR_SUCCESS;

     //
     // As GDI would be using the same monitoring Thread, So we spin
     // only one thread.
     //
     if(!hProcess)
     {
         hProcess = &hSurrogateProcess;
     }

     if( (RetVal =  ConnectToLd64In32ServerWorker(hProcess, TRUE)) != ERROR_SUCCESS)
     {
          if(RetVal == RPC_S_SERVER_UNAVAILABLE || RetVal == RPC_S_CALL_FAILED_DNE)
          {
               RetVal =  ConnectToLd64In32ServerWorker(hProcess,TRUE);
          }
     }
     return(RetVal);
}

DWORD
ConnectToLd64In32Server(
    HANDLE *hProcess,
    BOOL   bThread
    )
{
     DWORD RetVal = ERROR_SUCCESS;

     //
     // As GDI would be using the same monitoring Thread, So we spin
     // only one thread.
     //
     if(!hProcess)
     {
         hProcess = &hSurrogateProcess;
     }

     if( (RetVal =  ConnectToLd64In32ServerWorker(hProcess, bThread)) != ERROR_SUCCESS)
     {
          if(RetVal == RPC_S_SERVER_UNAVAILABLE || RetVal == RPC_S_CALL_FAILED_DNE)
          {
               RetVal =  ConnectToLd64In32ServerWorker(hProcess,bThread);
          }
     }
     return(RetVal);
}

/*++
    Function Name:
        ConnectToLd64In32ServerWorker

    Description:
        This function handles the connectivity issues with
        the RPC surrogate process (the one that loads 64 bit
        dlls in a 32 bit process).

     Parameters:
        hProcess : Pointer to the process handle that retrieves
                   the process handle of the server

     Return Value

--*/
DWORD
ConnectToLd64In32ServerWorker(
    HANDLE *hProcess,
    BOOL   bThread
    )
{
    DWORD      RetVal = ERROR_SUCCESS;
    RPC_STATUS RpcStatus;

    EnterCriticalSection(&ProcessHndlCS);
    {
        if(!*hProcess)
        {
               WCHAR*                StringBinding = NULL;
               STARTUPINFO           StartUPInfo;
               PROCESS_INFORMATION   ProcessInfo;
               HANDLE                hOneProcessMutex = NULL;

               ZeroMemory(&StartUPInfo,sizeof(STARTUPINFO));
               ZeroMemory(&ProcessInfo,sizeof(PROCESS_INFORMATION));
               StartUPInfo.cb = sizeof(STARTUPINFO);

               RpcTryExcept
               {
                   WCHAR  SessionEndPoint[50];
                   DWORD  CurrSessionId;
                   DWORD  CurrProcessId = GetCurrentProcessId();

                   if(ProcessIdToSessionId(CurrProcessId,&CurrSessionId))
                   {
                       PWSTR            pszServerPrincName = L"Default";
                       RPC_SECURITY_QOS RpcSecurityQOS;

                       StringCchPrintf(SessionEndPoint,COUNTOF(SessionEndPoint), L"%s_%x",L"splwow64",CurrSessionId);

                       RpcSecurityQOS.Version              = RPC_C_SECURITY_QOS_VERSION;
                       RpcSecurityQOS.Capabilities         = RPC_C_QOS_CAPABILITIES_DEFAULT;
                       RpcSecurityQOS.ImpersonationType    = RPC_C_IMP_LEVEL_IMPERSONATE;
                       RpcSecurityQOS.IdentityTracking     = RPC_C_QOS_IDENTITY_DYNAMIC;

                       if(!(((RpcStatus = RpcStringBindingCompose(NULL,
                                                                  L"ncalrpc",
                                                                  NULL,
                                                                  SessionEndPoint,
                                                                  NULL,
                                                                  &StringBinding))==RPC_S_OK)     &&

                            ((RpcStatus = RpcBindingFromStringBinding(StringBinding,
                                                                      &hSurrogate))==RPC_S_OK)    &&

                            ((RpcStatus = RpcBindingSetAuthInfoEx(hSurrogate,
                                                                  pszServerPrincName,
                                                                  RPC_C_AUTHN_LEVEL_DEFAULT,
                                                                  RPC_C_AUTHN_WINNT,
                                                                  NULL,
                                                                  0,
                                                                  &RpcSecurityQOS)) == RPC_S_OK)  &&

                            ((RpcStatus = RpcStringFree(&StringBinding)) == RPC_S_OK)))
                        {
                            RetVal = (DWORD)RpcStatus;
                        }
                        else
                        {
                             //
                             // This mutex is defined as Local to be different for
                             // each TS session
                             //
                             if(hOneProcessMutex = CreateMutex(NULL,
                                                               FALSE,
                                                               L"Local\\WinSpl64To32Mutex"))
                             {
                                  HANDLE hThread;
                                  HANDLE hMonitorStartedEvent;
                                  DWORD  ThreadId;
                                  DWORD i=0;
                                  DWORD RpcRetCode;

                                  WaitForSingleObject(hOneProcessMutex,INFINITE);
                                  {
                                       if(RpcMgmtIsServerListening(hSurrogate) == RPC_S_NOT_LISTENING)
                                       {
                                            WCHAR ProcessName[MAX_PATH+1];
                                            WCHAR WindowsDirectory[MAX_PATH+1];
                                            WCHAR szCommandLine[] = L"splwow64";
                                            //
                                            // In the future this should work , but
                                            // for the time being , wow64 redirects
                                            // any CreateProcess initiated from a wow
                                            // app and requesting an app from system32
                                            // to syswow64. That is why I moving the exe
                                            // out of the system32 directory.
                                            //
                                            GetSystemWindowsDirectory(WindowsDirectory,MAX_PATH);
                                            StringCchPrintf(ProcessName, COUNTOF(ProcessName), L"%ws\\splwow64.exe",WindowsDirectory);

                                            if(!CreateProcess(ProcessName,
                                                              szCommandLine,
                                                              NULL,
                                                              NULL,
                                                              FALSE,
                                                              CREATE_DEFAULT_ERROR_MODE |
                                                              CREATE_NO_WINDOW          |
                                                              DETACHED_PROCESS,
                                                              NULL,
                                                              WindowsDirectory,
                                                              &StartUPInfo,
                                                              &ProcessInfo))
                                            {
                                                 RetVal = GetLastError();
                                            }
                                            else
                                            {
                                                 if(bThread)
                                                 {
                                                     *hProcess = ProcessInfo.hProcess;
                                                 }
                                                 //
                                                 // A spinlock making sure that the process is really live and kicking.
                                                 // I also added to the spin lock a time out value in order not to enter
                                                 // in an endless loop. So, after a minute we just break.
                                                 //
                                                 for(i=0,
                                                     RpcRetCode = RpcMgmtIsServerListening(hSurrogate);

                                                     ((i<60) && (RpcRetCode == RPC_S_NOT_LISTENING));

                                                     Sleep(1000),
                                                     RpcRetCode = RpcMgmtIsServerListening(hSurrogate),
                                                     i++
                                                     );
                                            }
                                       }
                                       else
                                       {
                                            if(bThread)
                                            {
                                                HANDLE hRemoteProcess = NULL;

                                                hRemoteProcess = (HANDLE) RPCSplWOW64GetProcessHndl((DWORD)GetCurrentProcessId(),&RetVal);

                                                InterlockedCompareExchangePointer( hProcess,
                                                                                   hRemoteProcess,
                                                                                   NULL);
                                            }
                                       }
                                  }
                                  ReleaseMutex(hOneProcessMutex);
                                  CloseHandle(hOneProcessMutex);
                                  hOneProcessMutex = NULL;

                                  if(bThread && !bMonitorThreadCreated)
                                  {
                                      if(!(hMonitorStartedEvent=CreateEvent(NULL,FALSE,FALSE,NULL)))
                                      {
                                          RetVal = GetLastError();
                                      }
                                      else
                                      {
                                          MonitorThrdData ThrdData;

                                          ThrdData.hEvent   = hMonitorStartedEvent;
                                          ThrdData.hProcess = hProcess;

                                          if(!(hThread = CreateThread(NULL,
                                                                      INITIAL_STACK_COMMIT,
                                                                      MonitorRPCServerProcess,
                                                                      (PVOID)&ThrdData,
                                                                      0,
                                                                      &ThreadId)))
                                          {
                                               RetVal = GetLastError();
                                          }
                                          else
                                          {
                                              bMonitorThreadCreated = TRUE;
                                              LeaveCriticalSection(&ProcessHndlCS);
                                              {
                                                  WaitForSingleObject(hMonitorStartedEvent,INFINITE);
                                              }
                                              EnterCriticalSection(&ProcessHndlCS);

                                              CloseHandle(hThread);
                                          }
                                          CloseHandle(hMonitorStartedEvent);
                                      }
                                  }
                             }
                             else
                             {
                                  RetVal = GetLastError();
                             }
                        }

                   }
                   else
                   {
                        RetVal = GetLastError();
                   }
               }
               RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
               {
                    RetVal = RpcExceptionCode();
                    //
                    // To prevent deadlocking in case of
                    // an RPC exception
                    //
                    if(hOneProcessMutex)
                    {
                        ReleaseMutex(hOneProcessMutex);
                        CloseHandle(hOneProcessMutex);
                    }
               }
               RpcEndExcept

        }
        else
        {
             //
             // Refresh the life of the server
             //
             RpcTryExcept
             {
                  RPCSplWOW64RefreshLifeSpan();
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  RetVal = RpcExceptionCode();
             }
             RpcEndExcept
        }

    }
    LeaveCriticalSection(&ProcessHndlCS);
    return(RetVal);
}


DWORD
AddHandleToList(
    HWND hWnd
    )
{
    LPWndHndlNode NewNode = 0x00000000;
    DWORD         RetVal  = ERROR_SUCCESS;

    EnterCriticalSection(&ProcessHndlCS);
    {
        if(GWndHndlList)
        {
            if(NewNode = (LPWndHndlNode)LocalAlloc(LMEM_FIXED, sizeof(WndHndlNode)))
            {
                NewNode->PrevNode = 0x000000000;
                NewNode->NextNode = 0x000000000;
                NewNode->hWnd     = hWnd;
                if(!GWndHndlList->Head &&
                   !GWndHndlList->NumOfHndls)
                {
                    GWndHndlList->Head = NewNode;
                    GWndHndlList->Tail = NewNode;
                }
                else
                {
                     NewNode->PrevNode            = GWndHndlList->Tail;
                     GWndHndlList->Tail->NextNode = NewNode;
                     GWndHndlList->Tail           = NewNode;
                }
                GWndHndlList->NumOfHndls++;
            }
            else
            {
                RetVal = GetLastError();
            }
        }
        else
        {
            RetVal = ERROR_INVALID_PARAMETER;
        }
    }
    LeaveCriticalSection(&ProcessHndlCS);

    return(RetVal);
}


BOOL
DelHandleFromList(
    HWND hWnd
    )
{
    DWORD       RetVal = ERROR_SUCCESS;
    BOOL        Found  = FALSE;

    EnterCriticalSection(&ProcessHndlCS);
    {
        LPWndHndlNode TempNode = 0x00000000;

        if(GWndHndlList)
        {
            if(GWndHndlList->NumOfHndls)
            {
                //
                // Is it last Element in list
                //
                if(GWndHndlList->Tail->hWnd == hWnd)
                {
                    TempNode = GWndHndlList->Tail;
                    GWndHndlList->Tail = TempNode->PrevNode;
                    if(GWndHndlList->Tail)
                    {
                        GWndHndlList->Tail->NextNode = 0x00000000;
                    }
                    Found = TRUE;
                }

                //
                // Is it first Element in list
                //
                else if(GWndHndlList->Head->hWnd == hWnd)
                {
                    TempNode = GWndHndlList->Head;
                    GWndHndlList->Head = TempNode->NextNode;
                    if(GWndHndlList->Head)
                        GWndHndlList->Head->PrevNode = 0x00000000;
                    Found = TRUE;
                }

                //
                // Is it an intermediate Element
                //
                else
                {
                    TempNode = GWndHndlList->Head->NextNode;
                    while(TempNode                 &&
                          (TempNode->hWnd != hWnd) &&
                          TempNode != GWndHndlList->Tail)
                    {
                        TempNode = TempNode->NextNode;
                    }
                    if(TempNode && TempNode!=GWndHndlList->Tail)
                    {
                        Found = TRUE;
                        TempNode->PrevNode->NextNode = TempNode->NextNode;
                        TempNode->NextNode->PrevNode = TempNode->PrevNode;
                    }
                }
                if(Found)
                {
                    if(!--GWndHndlList->NumOfHndls)
                    {
                        GWndHndlList->Head = GWndHndlList->Tail = 0x00000000;
                    }
                    LocalFree(TempNode);
                }
            }
        }
        else
        {
            RetVal = ERROR_INVALID_PARAMETER;
        }
    }
    LeaveCriticalSection(&ProcessHndlCS);

    return(RetVal);
}

VOID
ReleaseAndCleanupWndList(
    VOID
    )
{
    LPWndHndlNode TempNode = (LPWndHndlNode)GWndHndlList->Head;
    while(TempNode)
    {
        PostMessage(TempNode->hWnd,
                    WM_SURROGATEFAILURE,
                    0,
                    0);
        GWndHndlList->Head = TempNode->NextNode;
        LocalFree(TempNode);
        TempNode = GWndHndlList->Head;
    }
    GWndHndlList->NumOfHndls = 0;
    GWndHndlList = NULL;
}

BOOL
JobCanceled(
    IN PSJobCancelInfo pJobCancelInfo
    )
{
    if (!pJobCancelInfo->NumOfCmpltWrts && pJobCancelInfo->pSpool->cbFlushPending)
    {
        //
        // Data to be flushed =
        // pSpool->cbFlushPending
        //
        DWORD cbWritten = 1;

        for(pJobCancelInfo->cbFlushed=0;
            (pJobCancelInfo->pSpool->cbFlushPending&&
             cbWritten > 0 &&
             FlushPrinter(pJobCancelInfo->pSpool,
                          pJobCancelInfo->pSpool->pBuffer+pJobCancelInfo->cbFlushed,
                          pJobCancelInfo->pSpool->cbFlushPending,
                          &cbWritten,
                          0));
            pJobCancelInfo->pSpool->cbFlushPending-=cbWritten,
            pJobCancelInfo->cbFlushed+=cbWritten,
            *pJobCancelInfo->pcbWritten+=cbWritten
           );

        pJobCancelInfo->pSpool->Flushed = 1;
    }
    else
    {
        DWORD WrittenDataSize = *pJobCancelInfo->pcTotalWritten + pJobCancelInfo->cbFlushed;
        //
        // Data to be flushed =
        // I/P Data + Pending Data - Total Written
        //    
        SPLASSERT(WrittenDataSize <= pJobCancelInfo->ReqTotalDataSize);

        if (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize)
        {
            LPBYTE pFlushBuffer;
            //
            // Location in pFlushBuffer where data from the 
            // i/p buffer starts
            //
            DWORD  InitialBuffStart = 0;
            if ((pFlushBuffer = VirtualAlloc(NULL,
                                             (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize),
                                             MEM_COMMIT, PAGE_READWRITE)))
            {
                DWORD cbWritten = 1;
                //
                // Since this seems to be quite a complicated functionality
                // I'll try explaining it in details here
                // These are the Data Buffers we are dealing with and their
                // initial states
                //
                //      pSpool->pBuffer             pBuf = pInitialBuf
                //   ____________________   _________________________________
                //  |       |           |  |                                |
                //  |       |           |  |                                |
                //  --------------------   ---------------------------------
                //  <------->              <-------------------------------->
                //   pending                      ReqToWriteDataSize      
                //      |                                 |  
                //      |                                 |
                //       ----------------+----------------
                //                       |
                //            (RequiredTotalDataSize)
                //
                // At this stage of the function we could have the
                // following conditions
                // 1. Written < Pending   -----> Then we have to 
                //                               count both Buffers for Flushing
                // 2. Written > Pending   -----> Then we count only pBuf for 
                //                               Flushing
                // Based on these conditions we need to figure out which of the 
                // of the 2 buffers is used for flushing the data and what pointer 
                // in either is the starting point of this data
                // For Condition 1 FlushBuffer would be the aggregation of :
                //      pSpool->pBuffer             pBuf = pInitialBuf
                //   ____________________   _________________________________
                //  |    |   |          |  |                                |
                //  |    |   |          |  |                                |
                //  --------------------   ---------------------------------
                //       <--->             <------------------------------->
                //    Pending-Written              ReqToWriteDataSize
                //
                //                    FlushBuffer
                //         _____________________________________
                //        |   |                                |
                //        |   |                                |
                //        -------------------------------------
                //           |
                //           |
                //     InitialBuffStart(where pBuf starts in FlushBuffer)
                //        <---><------------------------------->
                //    Pending-Written   ReqToWriteDataSize
                //
                // For Condition 2 FlushBuffer would be a portion of pBuf:
                //             pBuf = pInitialBuf
                //    _________________________________
                //   |        |                       |
                //   |        |                       |
                //   ---------------------------------
                //            <----------------------->
                //            ReqTotalDataSize - Written
                //
                //               FlushBuffer
                //         _______________________
                //        |                      |
                //        |                      |
                //        -----------------------
                //        |
                //        |
                //     InitialBuffStart(at the very beginning)
                //        <--------------------->
                //      ReqTotalDataSize - Written
                //
                if (WrittenDataSize < pJobCancelInfo->FlushPendingDataSize)
                {
                    InitialBuffStart = pJobCancelInfo->FlushPendingDataSize - WrittenDataSize;
                    CopyMemory( pFlushBuffer ,
                                pJobCancelInfo->pSpool->pBuffer + WrittenDataSize,
                                InitialBuffStart);
                }

                CopyMemory(pFlushBuffer + InitialBuffStart ,
                           pJobCancelInfo->pInitialBuf + 
                           (InitialBuffStart ? 0 : WrittenDataSize - pJobCancelInfo->FlushPendingDataSize),
                           pJobCancelInfo->ReqTotalDataSize - WrittenDataSize - InitialBuffStart);

                for(*pJobCancelInfo->pcbWritten=0;
                    (cbWritten > 0                                                                          &&
                     (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize - *pJobCancelInfo->pcbWritten) > 0 &&
                     FlushPrinter(pJobCancelInfo->pSpool,
                                  pFlushBuffer + *pJobCancelInfo->pcbWritten,
                                  pJobCancelInfo->ReqTotalDataSize - WrittenDataSize - *pJobCancelInfo->pcbWritten,
                                  &cbWritten,
                                  0));
                    *pJobCancelInfo->pcbWritten+=cbWritten
                   );
                
                VirtualFree(pFlushBuffer,
                            0,
                            MEM_RELEASE);

                pJobCancelInfo->ReturnValue = TRUE;
                pJobCancelInfo->pSpool->Flushed = 1;
                if (*pJobCancelInfo->pcbWritten == (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize))
                {
                    *pJobCancelInfo->pcTotalWritten+=pJobCancelInfo->ReqToWriteDataSize;
                }
            }
            else
            {
                DBGMSG(DBG_WARNING, ("JObCanceled::VirtualAlloc Failed to allocate 4k buffer %d\n",GetLastError()));
            }
        }
    }
    if (pJobCancelInfo->pSpool->Flushed)
    {
        pJobCancelInfo->pSpool->cbFlushPending = 0;
        pJobCancelInfo->pSpool->cbBuffer       = 0;
    }
    return pJobCancelInfo->ReturnValue;
}

/*++

Routine Name:

    IsValidDevmodeW

Description:

    Check to see whether the devmode passed is valid.

Arguments:

    pDevmode    - The devmode
    DevmodeSize - The size of the buffer.

Return Value:

    A boolean

--*/
BOOL
IsValidDevmodeW(
    IN  PDEVMODE    pDevmode,
    IN  size_t      DevmodeSize
    )
{
    return BoolFromHResult(SplIsValidDevmodeW(pDevmode, DevmodeSize));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines

Author:

    Dave Snipp (davesn)     01-Jun-1991

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LPWSTR InterfaceAddress = L"\\pipe\\spoolss";
handle_t GlobalBindHandle;

handle_t
STRING_HANDLE_bind (
    STRING_HANDLE  lpStr)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    lpStr - \\ServerName\PrinterName

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;
    WCHAR   ServerName[MAX_PATH+2];
    DWORD   i;

    if (lpStr && lpStr[0] == L'\\' && lpStr[1] == L'\\') 
    {

        // We have a servername
        for (i = 2 ; lpStr[i] && lpStr[i] != L'\\' ; ++i)
            ;

        if (i >= COUNTOF(ServerName))
            return FALSE;
        
        wcsncpy(ServerName, lpStr, i);
        ServerName[i] = L'\0';

    }
    else
    {
        return NULL;
    }

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", ServerName,
                                         InterfaceAddress,
                                         L"Security=Impersonation Static True",
                                         &StringBinding);

    if ( RpcStatus != RPC_S_OK ) 
    {
       return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK )
    {
       return NULL;
    }

    return(BindingHandle);
}


void
STRING_HANDLE_unbind (
    STRING_HANDLE  lpStr,
    handle_t    BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles implementation for WaitForPrinterChange and related apis.

    FindFirstPrinterChangeNotification
    RouterFindNextPrinterChangeNotification
    FindClosePrinterChangeNotification

    Used by providors:

    ReplyPrinterChangeNotification  [Function Call]
    CallRouterFindFirstPrinterChangeNotification [Function Call]

Author:

    Albert Ting (AlbertT) 18-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntfytab.h>

#define PRINTER_NOTIFY_DEFAULT_POLLTIME 10000

CRITICAL_SECTION  RouterNotifySection;
PCHANGEINFO       pChangeInfoHead;
HANDLE            hEventPoll;


BOOL
SetupReplyNotification(
    PCHANGE pChange,
    DWORD fdwOptions,
    DWORD fdwStatus,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit);

BOOL
FindFirstPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent,
    BOOL bSpooler);

DWORD
FindClosePrinterChangeNotificationWorker(
    HANDLE hPrinter);

BOOL
SetupChange(
    PPRINTHANDLE pPrintHandle,
    DWORD dwPrinterRemote,
    LPWSTR pszLocalMachine,
    PDWORD pfdwStatus,
    DWORD fdwOptions,
    DWORD fdwFilterFlags,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT* pPrinterNotifyInit);

VOID
FailChange(
    PPRINTHANDLE pPrintHandle);

BOOL
RouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PPRINTER_NOTIFY_INFO* ppInfo);


BOOL
WPCInit()
{
    //
    // Create non-signaled, autoreset event.
    //
    hEventPoll = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!hEventPoll)
        return FALSE;

    __try {

        InitializeCriticalSection(&RouterNotifySection);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        SetLastError(GetExceptionCode());
        return FALSE;
    }            

    return TRUE;
}

VOID
WPCDestroy()
{
#if 0
    DeleteCriticalSection(&RouterNotifySection);
    CloseHandle(hEventPoll);
#endif
}





BOOL
RouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent)
{
    return FindFirstPrinterChangeNotificationWorker(
               hPrinter,
               fdwFilterFlags,
               fdwOptions,
               dwPID,
               pPrinterNotifyOptions,
               phEvent,
               FALSE);
}


BOOL
FindFirstPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent,
    BOOL bSpooler)

/*++

Routine Description:

    Sets up notification (coming from client side, winspool.drv).
    Create an event and duplicate it into the clients address
    space so we can communicate with it.

Arguments:

    hPrinter - Printer to watch

    fdwFilterFlags - Type of notification to set up (filter)

    fdwOptions - user specified option (GROUPING, etc.)

    dwPID - PID of the client process (needed to dup handle)

    phEvent - hEvent to pass back to the client.

    bSpooler - Indicates if called from spooler.  If TRUE, then we don't
               need to duplicate the event.

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    HANDLE hProcess;
    DWORD fdwStatus = 0;
    PCHANGE pChange = NULL;
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit = NULL;
    BOOL bReturn;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    EnterRouterSem();

    //
    // Clear this out
    //
    *phEvent = NULL;

    // Give a unique DWORD session ID for pPrintHandle
    while (pPrintHandle->dwUniqueSessionID == 0  ||
           pPrintHandle->dwUniqueSessionID == 0xffffffff) {

        pPrintHandle->dwUniqueSessionID = dwRouterUniqueSessionID++;
    }

    if (!SetupChange(pPrintHandle,
                     pPrintHandle->dwUniqueSessionID,
                     szMachineName,
                     &fdwStatus,
                     fdwOptions,
                     fdwFilterFlags,
                     pPrinterNotifyOptions,
                     &pPrinterNotifyInit)) {

        LeaveRouterSem();
        return FALSE;
    }

    //
    // !! LATER !!
    //
    // When Delegation is supported:
    //
    // Create the event with security access based on the impersonation
    // token so that we can filter out bogus notifications from
    // random people. (Save the token in the pSpool in localspl, then
    // impersonate before RPCing back here.  Then we can check if
    // we have access to the event.)
    //

    //
    // Create the event here that we trigger on notifications.
    // We will duplicate this event into the target client process.
    //
    pPrintHandle->pChange->hEvent = CreateEvent(
                                       NULL,
                                       TRUE,
                                       FALSE,
                                       NULL);

    if (!pPrintHandle->pChange->hEvent) {
        goto Fail;
    }

    if (bSpooler) {

        //
        // Client is in the spooler process.
        //
        *phEvent = pPrintHandle->pChange->hEvent;

    } else {

        //
        // Client is local.
        //

        //
        // Success, create pair
        //
        hProcess = OpenProcess(PROCESS_DUP_HANDLE,
                               FALSE,
                               dwPID);

        if (!hProcess) {
            goto Fail;
        }

        bReturn = DuplicateHandle(GetCurrentProcess(),
                                  pPrintHandle->pChange->hEvent,
                                  hProcess,
                                  phEvent,
                                  EVENT_ALL_ACCESS,
                                  TRUE,
                                  0);
        CloseHandle(hProcess);

        if (!bReturn) {
            goto Fail;
        }
    }

    bReturn = SetupReplyNotification(pPrintHandle->pChange,
                                     fdwStatus,
                                     fdwOptions,
                                     pPrinterNotifyOptions,
                                     pPrinterNotifyInit);

    if (bReturn) {

        pPrintHandle->pChange->eStatus &= ~STATUS_CHANGE_FORMING;
        pPrintHandle->pChange->eStatus |=
            STATUS_CHANGE_VALID|STATUS_CHANGE_CLIENT;

    } else {

Fail:
        if (pPrintHandle->pChange->hEvent)
            CloseHandle(pPrintHandle->pChange->hEvent);

        //
        // Local case must close handle twice since we may have
        // duplicated the event.
        //
        if (!bSpooler && *phEvent)
            CloseHandle(*phEvent);

        FailChange(pPrintHandle);
        bReturn = FALSE;
    }

    LeaveRouterSem();

    return bReturn;
}


BOOL
RemoteFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterRemote,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions)

/*++

Routine Description:

    Handles FFPCN coming from other machines.  Providers can use
    the ProvidorRemoteFFPCN call to initiate the RPC which this function
    handles.  This code ships the call to the print provider.  Note
    that we don't create any events here since the client is on
    a remote machine.

Arguments:

    hPrinter - printer to watch

    fdwFilterFlags - type of notification to watch

    fdwOptions -- options on watch

    pszLocalMachine - name of local machine that requested the watch

    dwPrinterRemote - remote Printer handle

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    BOOL bReturn;
    DWORD fdwStatus = 0;
    PCHANGE pChange = NULL;
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit = NULL;
    LPWSTR pszLocalMachineCopy;

    pszLocalMachineCopy = AllocSplStr(pszLocalMachine);

    if (!pszLocalMachineCopy)
        return FALSE;

    EnterRouterSem();

    if (!SetupChange(pPrintHandle,
                     dwPrinterRemote,
                     pszLocalMachineCopy,
                     &fdwStatus,
                     fdwOptions,
                     fdwFilterFlags,
                     pPrinterNotifyOptions,
                     &pPrinterNotifyInit)) {

        LeaveRouterSem();
        return FALSE;
    }

    bReturn = SetupReplyNotification(pPrintHandle->pChange,
                                     fdwStatus,
                                     fdwOptions,
                                     pPrinterNotifyOptions,
                                     pPrinterNotifyInit);

    if (bReturn) {

        pPrintHandle->pChange->eStatus = STATUS_CHANGE_VALID;

    } else {

        FailChange(pPrintHandle);
    }

    LeaveRouterSem();

    return bReturn;
}


BOOL
RouterFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    LPDWORD pfdwChangeFlags,
    PPRINTER_NOTIFY_OPTIONS pOptions,
    PPRINTER_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Return information about notification that just occurred and
    reset to look for more notifications.

Arguments:

    hPrinter - printer to reset event handle

    fdwFlags - flags (PRINTER_NOTIFY_NEXT_INFO)

    pfdwChange - return result of changes

    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions

    pReplyContainer - Reply info to pass out.

Return Value:

    BOOL

    ** NOTE **
    Always assume client process is on the same machine.  The client
    machine router always handles this call.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    PCHANGE pChange = pPrintHandle->pChange;
    BOOL bReturn = FALSE;

    if (ppInfo) {
        *ppInfo = NULL;
    }

    //
    // Currently only REFRESH option is defined.
    //
    if( pOptions && ( pOptions->Flags & ~PRINTER_NOTIFY_OPTIONS_REFRESH )){

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    EnterRouterSem();

    if (pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pChange ||
        !(pChange->eStatus & (STATUS_CHANGE_VALID|STATUS_CHANGE_CLIENT))) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    //
    // For now, we collapse all notifications into 1.
    //
    pChange->dwCount = 0;

    //
    // Tell the user what changes occurred,
    // then clear it out.
    //
    *pfdwChangeFlags = pChange->fdwChangeFlags;
    pChange->fdwChangeFlags = 0;

    ResetEvent(pChange->hEvent);

    if (pOptions && pOptions->Flags & PRINTER_NOTIFY_OPTIONS_REFRESH) {

        //
        // Increment color.
        //
        pPrintHandle->pChange->dwColor++;

        LeaveRouterSem();

        bReturn = RouterRefreshPrinterChangeNotification(
                      hPrinter,
                      pPrintHandle->pChange->dwColor,
                      pOptions,
                      ppInfo);

        return bReturn;
    }

    //
    // If they want data && (we have data || if we have flags that we wish
    // to send to the user), copy the data.
    //
    if( ppInfo &&
        (fdwFlags & PRINTER_NOTIFY_NEXT_INFO) &&
        NotifyNeeded( pChange )){

        *ppInfo = pChange->ChangeInfo.pPrinterNotifyInfo;
        pChange->ChangeInfo.pPrinterNotifyInfo = NULL;

        //
        // If we need to notify because of a DISCARD, but we don't
        // have a pPrinterNotifyInfo, then allocate one and return it.
        //
        if( !*ppInfo ){

            DBGMSG( DBG_TRACE,
                    ( "RFNPCN: Discard with no pPrinterNotifyInfo: pChange %x\n",
                      pChange ));

            //
            // We need to return some information back to the client, so
            // allocate a block that has zero items.  The header will be
            // marked as DISCARDED, which tells the user to refresh.
            //
            *ppInfo = RouterAllocPrinterNotifyInfo( 0 );

            if( !*ppInfo ){

                //
                // Failed to alloc memory; fail the call.
                //
                bReturn = FALSE;
                goto Done;
            }

            //
            // Mark the newly allocated information as DISCARDED.
            //
            (*ppInfo)->Flags = PRINTER_NOTIFY_INFO_DISCARDED;
        }
    }

    bReturn = TRUE;

Done:
    LeaveRouterSem();

    return bReturn;
}





BOOL
FindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    DWORD dwError;
    LPPRINTHANDLE pPrintHandle = (LPPRINTHANDLE)hPrinter;

    EnterRouterSem();

    if (pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange ||
        !(pPrintHandle->pChange->eStatus & STATUS_CHANGE_VALID)) {

        DBGMSG(DBG_WARN, ("FCPCNW: Invalid handle 0x%x\n", pPrintHandle));
        dwError = ERROR_INVALID_HANDLE;

    } else {

        dwError = FindClosePrinterChangeNotificationWorker(hPrinter);
    }

    LeaveRouterSem();

    if (dwError) {

        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}

DWORD
FindClosePrinterChangeNotificationWorker(
    HANDLE hPrinter)

/*++

Routine Description:

    Close a notification.

Arguments:

    hPrinter -- printer that we want to close

Return Value:

    ERROR code

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    BOOL bLocal = FALSE;
    HANDLE hNotifyRemote = NULL;
    DWORD dwError = ERROR_SUCCESS;

    DBGMSG(DBG_NOTIFY, ("FCPCN: Closing 0x%x ->pChange 0x%x\n",
                        pPrintHandle, pPrintHandle->pChange));

    RouterInSem();

    //
    // If the notification exists, shut it down (this is the
    // local case).  If we are called remotely, we don't need to
    // do this, since hEvent wasn't created.
    //
    if (pPrintHandle->pChange->eStatus & STATUS_CHANGE_CLIENT) {

        CloseHandle(pPrintHandle->pChange->hEvent);
        bLocal = TRUE;
    }

    //
    // Remember what the hNotifyRemote is, in case we want to delete it.
    //
    hNotifyRemote = pPrintHandle->pChange->hNotifyRemote;

    //
    // Failure to free implies we're using it now.  In this case,
    // don't try and free the hNotifyRemote.
    //
    if (!FreeChange(pPrintHandle->pChange)) {
        hNotifyRemote = NULL;
    }

    //
    // If local, don't allow new reply-s to be set up.
    //
    if (bLocal) {

        RemoveReplyClient(pPrintHandle,
                          REPLY_TYPE_NOTIFICATION);
    }


    //
    // We must zero this out to prevent other threads from
    // attempting to close this context handle (client side)
    // at the same time we are closing it.
    //
    pPrintHandle->pChange = NULL;

    if (!bLocal) {

        //
        // Remote case, shut down the notification handle if
        // there is one here.  (If there is a double hop, only
        // the second hop will have a notification reply.  Currently
        // only 1 hop is support during registration, however.)
        //
        LeaveRouterSem();

        CloseReplyRemote(hNotifyRemote);

        EnterRouterSem();
    }

    LeaveRouterSem();

    RouterOutSem();

    if (!(*pPrintHandle->pProvidor->PrintProvidor.
          fpFindClosePrinterChangeNotification) (pPrintHandle->hPrinter)) {

          dwError = GetLastError();
    }
    EnterRouterSem();

    return dwError;
}



BOOL
SetupReplyNotification(
    PCHANGE pChange,
    DWORD fdwStatus,
    DWORD fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit)
{
    DWORD dwReturn = ERROR_SUCCESS;

    RouterInSem();

    if (!pChange) {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto Fail;
    }

    SPLASSERT(pChange->eStatus & STATUS_CHANGE_FORMING);

    if (fdwStatus & PRINTER_NOTIFY_STATUS_ENDPOINT) {

        //
        // For remote notification, we must setup a reply.
        //
        if (_wcsicmp(pChange->pszLocalMachine, szMachineName)) {

            LeaveRouterSem();

            dwReturn = OpenReplyRemote(pChange->pszLocalMachine,
                                       &pChange->hNotifyRemote,
                                       pChange->dwPrinterRemote,
                                       REPLY_TYPE_NOTIFICATION,
                                       0,
                                       NULL);

            EnterRouterSem();

            if (dwReturn)
                goto Fail;
        }

        //
        // The user can specify different status flags for the
        // notfication.  Process them here.
        //

        if (fdwStatus & PRINTER_NOTIFY_STATUS_POLL) {

            //
            // If there wasn't an error, then our reply notification
            // handle is valid, and we should do the polling.
            //
            pChange->ChangeInfo.dwPollTime =
                (pPrinterNotifyInit &&
                pPrinterNotifyInit->PollTime) ?
                    pPrinterNotifyInit->PollTime :
                    PRINTER_NOTIFY_DEFAULT_POLLTIME;

            pChange->ChangeInfo.dwPollTimeLeft = pChange->ChangeInfo.dwPollTime;

            //
            // Don't cause a poll the first time it's added.
            //
            pChange->ChangeInfo.bResetPollTime = TRUE;
            LinkAdd(&pChange->ChangeInfo.Link, (PLINK*)&pChangeInfoHead);

            SetEvent(hEventPoll);

        }
        pChange->ChangeInfo.fdwStatus = fdwStatus;

    } else {

        pChange->dwPrinterRemote = 0;
    }

    if (pPrinterNotifyOptions) {

        pChange->eStatus |= STATUS_CHANGE_INFO;
    }

Fail:
    if (dwReturn) {
        SetLastError(dwReturn);
        return FALSE;
    }

    return TRUE;
}



//
// The Reply* functions handle calls from the server back to the client,
// indicating that something changed.
//



BOOL
ReplyPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD dwColor,
    DWORD fdwChangeFlags,
    PDWORD pdwResult,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
    )

/*++

Routine Description:

    Notifies the client that something happened.  If local, simply
    set the event.  If remote, call ThreadNotify which spawns a thread
    to RPC to the client router.  (This call from the server -> client
    requires that the spooler pipe use the NULL session, since we
    are in local system context and RPC calls (with no impersonation)
    use the NULL session.)

Arguments:

    hPrinter -- printer that changed

    dwColor -- color time stamp of data

    fdwChangeFlags -- flags that changed

    pdwResult -- result flags (OPTIONAL)

    pPrinterNotifyInfo -- Notify info data.  Note that if this is NULL,
                          we don't set the DISCARDED flag.  This is different
                          than PartialRPN,

Return Value:

    BOOL  TRUE  = success
          FALSE = fail

--*/

{
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;
    PCHANGE pChange;
    BOOL bReturn = FALSE;

    EnterRouterSem();

    if (!pPrintHandle ||
        pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange ||
        !(pPrintHandle->pChange->eStatus & STATUS_CHANGE_VALID)) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    pChange = pPrintHandle->pChange;

    if (pdwResult) {
        *pdwResult = 0;
    }

    if (pChange->eStatus & STATUS_CHANGE_DISCARDED) {

        DBGMSG(DBG_WARNING,
               ("RPCNW: Discarded x%x, eStatus = 0x%x, pInfo = 0x%x\n",
                pChange,
                pChange->eStatus,
                pChange->ChangeInfo.pPrinterNotifyInfo));

        if (pdwResult && pPrinterNotifyInfo) {

            *pdwResult |= (PRINTER_NOTIFY_INFO_DISCARDED |
                          PRINTER_NOTIFY_INFO_DISCARDNOTED);
        }

        //
        // If the discard has already been noted, then we don't need
        // to notify the client.  If it hasn't been noted, we need to
        // trigger a notification, since the the client needs to refresh.
        //
        if (pChange->eStatus & STATUS_CHANGE_DISCARDNOTED) {
            bReturn = TRUE;
            goto Done;
        }
    }

    if (pChange->eStatus & STATUS_CHANGE_INFO && pPrinterNotifyInfo) {

        *pdwResult |= AppendPrinterNotifyInfo(pPrintHandle,
                                              dwColor,
                                              pPrinterNotifyInfo);

        //
        // AppendPrinterNotifyInfo will set the color mismatch
        // bit if the notification info is stale (doesn't match color).
        //
        if (*pdwResult & PRINTER_NOTIFY_INFO_COLORMISMATCH) {

            DBGMSG(DBG_WARNING, ("RPCN: Color mismatch; discarding\n"));

            bReturn = TRUE;
            goto Done;
        }
    }

    //
    // Store up the changes for querying later.
    //
    pChange->fdwChangeFlags |= fdwChangeFlags;

    //
    // Ensure that there is a valid notification waiting.
    // This is an optimization that avoids the case where the print
    // providor calls PartialRPCN several times, then is about to
    // call ReplyPCN.  Before it does this, we process the
    // the notification (either the client picks it up, or it rpcs
    // out to a remote router).  Suddenly we have no notification
    // data, so return instead of sending nothing.
    //
    if (!NotifyNeeded(pChange)) {

        bReturn = TRUE;
        goto Done;
    }

    //
    // Notify Here
    //
    // If this is the local machine, then just set the event and update.
    //
    if (pChange->eStatus & STATUS_CHANGE_CLIENT) {

        if (!pChange->hEvent ||
            pChange->hEvent == INVALID_HANDLE_VALUE) {

            DBGMSG(DBG_WARNING, ("ReplyNotify invalid event\n"));
            SetLastError(ERROR_INVALID_HANDLE);

            goto Done;
        }

        if (!SetEvent(pChange->hEvent)) {

            //
            // SetEvent failed!
            //
            DBGMSG(DBG_ERROR, ("ReplyNotify SetEvent Failed (ignore it!): Error %d.\n", GetLastError()));

            goto Done;
        }

        //
        // Keep count of notifications so that we return the correct
        // number of FNPCNs.
        //
        pChange->dwCount++;

        DBGMSG(DBG_NOTIFY, (">>>> Local trigger 0x%x\n", fdwChangeFlags));
        bReturn = TRUE;

    } else {

        //
        // Remote case.
        //
        // Note: pPrintHandle is invalid, since hNotify is valid only in the
        // client router address space.
        //

        DBGMSG(DBG_NOTIFY, ("*** Trigger remote event *** 0x%x\n",
                            pPrintHandle));

        bReturn = ThreadNotify(pPrintHandle);
    }

Done:
    LeaveRouterSem();
    return bReturn;
}


BOOL
FreeChange(
    PCHANGE pChange)

/*++

Routine Description:

    Frees the change structure.

Arguments:

Return Value:

    TRUE = Deleted
    FALSE = deferred.

NOTE: Assumes in Critical Section

--*/

{
    RouterInSem();

    //
    // Remove ourselves from the list if the providor wanted us
    // to send out polling notifications.
    //
    if (pChange->ChangeInfo.fdwStatus & PRINTER_NOTIFY_STATUS_POLL)
        LinkDelete(&pChange->ChangeInfo.Link, (PLINK*)&pChangeInfoHead);

    //
    // pPrintHandle should never refer to the pChange again.  This
    // ensures that the FreePrinterHandle only frees the pChange once.
    //
    if (pChange->ChangeInfo.pPrintHandle) {

        pChange->ChangeInfo.pPrintHandle->pChange = NULL;
        pChange->ChangeInfo.pPrintHandle = NULL;
    }

    if (pChange->cRef || pChange->eStatus & STATUS_CHANGE_FORMING) {

        pChange->eStatus |= STATUS_CHANGE_CLOSING;

        DBGMSG(DBG_NOTIFY, ("FreeChange: 0x%x in use: cRef = %d\n",
                            pChange,
                            pChange->cRef));
        return FALSE;
    }

    //
    // If the pszLocalMachine is ourselves, then don't free it,
    // since there's a single instance locally.
    //
    if (pChange->pszLocalMachine != szMachineName && pChange->pszLocalMachine)
        FreeSplStr(pChange->pszLocalMachine);

    if (pChange->ChangeInfo.pPrinterNotifyInfo) {

        RouterFreePrinterNotifyInfo(pChange->ChangeInfo.pPrinterNotifyInfo);
    }

    DBGMSG(DBG_NOTIFY, ("FreeChange: 0x%x ->pPrintHandle 0x%x\n",
                        pChange, pChange->ChangeInfo.pPrintHandle));

    FreeSplMem(pChange);

    return TRUE;
}


VOID
FreePrinterHandle(
    PPRINTHANDLE pPrintHandle
    )
{
    if( !pPrintHandle ){
        return;
    }

    EnterRouterSem();

    //
    // If on wait list, force wait list to free it.
    //
    if (pPrintHandle->pChange) {

        FreeChange(pPrintHandle->pChange);
    }

    //
    // Inform all notifys on this printer handle that they are gone.
    //
    FreePrinterHandleNotifys(pPrintHandle);

    LeaveRouterSem();

    DBGMSG(DBG_NOTIFY, ("FreePrinterHandle: 0x%x, pChange = 0x%x, pNotify = 0x%x\n",
                        pPrintHandle, pPrintHandle->pNotify,
                        pPrintHandle->pChange));

    // Log warning to detect handle free
    DBGMSG(DBG_TRACE, ("FreePrinterHandle: 0x%x\n", pPrintHandle));

    // Close tempfile handle, if any
    if (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE) {
        CloseHandle(pPrintHandle->hFileSpooler);
    }

    if (pPrintHandle->szTempSpoolFile) {

        if (!DeleteFile(pPrintHandle->szTempSpoolFile)) {

            MoveFileEx(pPrintHandle->szTempSpoolFile, NULL,
                       MOVEFILE_DELAY_UNTIL_REBOOT);
        }

        FreeSplMem(pPrintHandle->szTempSpoolFile);
        pPrintHandle->szTempSpoolFile = NULL;
    }

    FreeSplStr( pPrintHandle->pszPrinter );

    FreeSplMem( pPrintHandle );
}


VOID
HandlePollNotifications(
    VOID)

/*++

Routine Description:

    This handles the pulsing of notifications for any providor that wants
    to do polling.  It never returns.

Arguments:

    VOID

Return Value:

    VOID  (also never returns)

    NOTE: This thread should never exit, since hpmon uses this thread
          for initialization.  If this thread exists, certain services
          this thread initializes quit.

--*/

{
    HANDLE          hWaitObjects[1];
    PCHANGEINFO     pChangeInfo;
    DWORD           dwSleepTime = INFINITE, dwTimeElapsed, dwPreSleepTicks,
                    dwEvent;
    MSG             msg;

    hWaitObjects[0] = hEventPoll;


    while (TRUE) {

        dwPreSleepTicks = GetTickCount();

        dwEvent = MsgWaitForMultipleObjects(1,
                                            hWaitObjects,
                                            FALSE,
                                            dwSleepTime,
                                            QS_ALLEVENTS | QS_SENDMESSAGE);

        if ( dwEvent == WAIT_TIMEOUT ) {

            dwTimeElapsed = dwSleepTime;

        } else if ( dwEvent == WAIT_OBJECT_0 + 0 ) {

            dwTimeElapsed = GetTickCount() - dwPreSleepTicks;
        } else {

            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) ) {

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            continue;
        }

        EnterRouterSem();

        //
        // Initialize sleep time to INFINITY.
        //
        dwSleepTime = INFINITE;

        for (pChangeInfo = pChangeInfoHead;
            pChangeInfo;
            pChangeInfo = (PCHANGEINFO)pChangeInfo->Link.pNext) {

            //
            // If first time or a notification came in,
            // we just want to reset the time.
            //
            if (pChangeInfo->bResetPollTime) {

                pChangeInfo->dwPollTimeLeft = pChangeInfo->dwPollTime;
                pChangeInfo->bResetPollTime = FALSE;

            } else if (pChangeInfo->dwPollTimeLeft <= dwTimeElapsed) {

                //
                // Cause a notification.
                //
                ReplyPrinterChangeNotificationWorker(
                    pChangeInfo->pPrintHandle,
                    0,
                    pChangeInfo->fdwFilterFlags,
                    NULL,
                    NULL);

                pChangeInfo->dwPollTimeLeft = pChangeInfo->dwPollTime;

            } else {

                //
                // They've slept dwTimeElapsed, so take that off of
                // their dwPollTimeLeft.
                //
                pChangeInfo->dwPollTimeLeft -= dwTimeElapsed;
            }

            //
            // Now compute what is the least amout of time we wish
            // to sleep before the next guy should be woken up.
            //
            if (dwSleepTime > pChangeInfo->dwPollTimeLeft)
                dwSleepTime = pChangeInfo->dwPollTimeLeft;
        }

        LeaveRouterSem();
    }
}



BOOL
SetupChange(
    PPRINTHANDLE pPrintHandle,
    DWORD dwPrinterRemote,
    LPWSTR pszLocalMachine,
    PDWORD pfdwStatus,
    DWORD fdwOptions,
    DWORD fdwFilterFlags,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT* ppPrinterNotifyInit)

/*++

Routine Description:

    Sets up the pChange structure.  Validates the handle,
    then attempts to alloc it.

Arguments:

Return Value:

--*/

{
    PCHANGE pChange;
    BOOL bReturn;

    RouterInSem();

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pPrintHandle->pChange) {

        DBGMSG(DBG_WARN, ("FFPCN: Already watching printer handle.\n"));

        //
        // Error: already watched
        //
        SetLastError(ERROR_ALREADY_WAITING);
        return FALSE;
    }

    pChange = AllocSplMem(sizeof(CHANGE));

    DBGMSG(DBG_NOTIFY, ("FFPCN pChange allocated 0x%x\n", pChange));

    if (!pChange) {

        //
        // Failed to allocate memory, quit.
        //
        return FALSE;
    }

    pPrintHandle->pChange = pChange;

    pChange->signature = CHANGEHANDLE_SIGNATURE;
    pChange->eStatus = STATUS_CHANGE_FORMING;
    pChange->ChangeInfo.pPrintHandle = pPrintHandle;
    pChange->ChangeInfo.fdwOptions = fdwOptions;

    //
    // Don't watch for Failed Connections.
    //
    pChange->ChangeInfo.fdwFilterFlags =
        fdwFilterFlags & ~PRINTER_CHANGE_FAILED_CONNECTION_PRINTER;

    pChange->dwPrinterRemote = dwPrinterRemote;
    pChange->pszLocalMachine = pszLocalMachine;

    //
    // As soon as we leave the critical section, pPrintHandle
    // may vanish!  If this is the case, out pChange->eStatus STATUS_CHANGE_CLOSING
    // bit will be set.
    //
    LeaveRouterSem();

    //
    // Once we leave the critical section, we are may try and
    // alter the notification.  To guard against this, we always
    // check eValid.
    //
    bReturn = (*pPrintHandle->pProvidor->PrintProvidor.
              fpFindFirstPrinterChangeNotification) (pPrintHandle->hPrinter,
                                                     fdwFilterFlags,
                                                     fdwOptions,
                                                     (HANDLE)pPrintHandle,
                                                     pfdwStatus,
                                                     pPrinterNotifyOptions,
                                                     ppPrinterNotifyInit);

    EnterRouterSem();

    //
    // On fail exit.
    //
    if (!bReturn) {

        pPrintHandle->pChange = NULL;

        if (pChange) {

            //
            // We no longer need to be saved, so change
            // eStatus to be 0.
            //
            pChange->eStatus = 0;
            DBGMSG(DBG_NOTIFY, ("FFPCN: Error %d, pChange deleting 0x%x %d\n",
                                GetLastError(),
                                pChange));

            FreeChange(pChange);
        }

        return FALSE;
    }

    return TRUE;
}

VOID
FailChange(
    PPRINTHANDLE pPrintHandle)
{
    LeaveRouterSem();

    //
    // Shut it down since we failed.
    //
    (*pPrintHandle->pProvidor->PrintProvidor.
    fpFindClosePrinterChangeNotification) (pPrintHandle->hPrinter);

    EnterRouterSem();

    //
    // We no longer need to be saved, so change
    // eStatus to be 0.
    //
    pPrintHandle->pChange->eStatus = 0;
    DBGMSG(DBG_NOTIFY, ("FFPCN: Error %d, pChange deleting 0x%x %d\n",
                        GetLastError(),
                        pPrintHandle->pChange));

    FreeChange(pPrintHandle->pChange);
}



/*------------------------------------------------------------------------

    Entry points for providors.

------------------------------------------------------------------------*/

BOOL
ProvidorFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    HANDLE hChange,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT* ppPrinterNotifyInit)

/*++

Routine Description:

    Handles any FFPCN that originates from a providor.
    Localspl does this when it wants to put a notification on a port.

Arguments:

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    BOOL bReturnValue;
    DWORD fdwStatus = 0;

    bReturnValue = (*pPrintHandle->pProvidor->PrintProvidor.
            fpFindFirstPrinterChangeNotification) (pPrintHandle->hPrinter,
                                                   fdwFilterFlags,
                                                   fdwOptions,
                                                   hChange,
                                                   &fdwStatus,
                                                   pPrinterNotifyOptions,
                                                   ppPrinterNotifyInit);

    if (bReturnValue) {

        //
        // !! LATER !! Check return value of SetupReply...
        //
        EnterRouterSem();

        SetupReplyNotification(((PPRINTHANDLE)hChange)->pChange,
                               fdwStatus,
                               fdwOptions,
                               pPrinterNotifyOptions,
                               ppPrinterNotifyInit ?
                                   *ppPrinterNotifyInit :
                                   NULL);

        LeaveRouterSem();
    }

    return bReturnValue;
}


DWORD
CallRouterFindFirstPrinterChangeNotification(
    HANDLE hPrinterRPC,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    HANDLE hPrinterLocal,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions)

/*++

Routine Description:

    This is called by providers if they want to pass a notification
    along to another machine.  This notification must originate from
    this machine but needs to be passed to another spooler.

Arguments:

    hPrinter - context handle to use for communication

    fdwFilterFlags - watch items

    fdwOptions - watch options

    hPrinterLocal - pPrinter structure valid in this address space,
                    and also is the sink for the notifications.

Return Value:

    Error code

--*/
{
    DWORD ReturnValue = 0;
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinterLocal;

    EnterRouterSem();

    BeginReplyClient(pPrintHandle,
                     REPLY_TYPE_NOTIFICATION);

    LeaveRouterSem();

    RpcTryExcept {

        ReturnValue = RpcRemoteFindFirstPrinterChangeNotificationEx(
                          hPrinterRPC,
                          fdwFilterFlags,
                          fdwOptions,
                          pPrintHandle->pChange->pszLocalMachine,
                          pPrintHandle->dwUniqueSessionID,
                          (PRPC_V2_NOTIFY_OPTIONS)pPrinterNotifyOptions);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        ReturnValue = RpcExceptionCode();

    } RpcEndExcept

    //
    // Talking to downlevel (Daytona) box.
    //
    if (ReturnValue == RPC_S_PROCNUM_OUT_OF_RANGE) {

        if (!pPrinterNotifyOptions) {

            RpcTryExcept {

                ReturnValue = RpcRemoteFindFirstPrinterChangeNotification(
                                  hPrinterRPC,
                                  fdwFilterFlags,
                                  fdwOptions,
                                  pPrintHandle->pChange->pszLocalMachine,
                                  pPrintHandle->dwUniqueSessionID,
                                  0,
                                  NULL);

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                ReturnValue = RpcExceptionCode();

            } RpcEndExcept
        }
    }

    EnterRouterSem();

    EndReplyClient(pPrintHandle,
                   REPLY_TYPE_NOTIFICATION);

    LeaveRouterSem();

    return ReturnValue;
}



BOOL
ProvidorFindClosePrinterChangeNotification(
    HANDLE hPrinter)

/*++

Routine Description:

    Handles any FCPCN that originates from a providor.
    Localspl does this when it wants to put a notification on a port.

Arguments:

Return Value:

    NOTE: Assumes a client notification was setup already.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    return  (*pPrintHandle->pProvidor->PrintProvidor.
            fpFindClosePrinterChangeNotification) (pPrintHandle->hPrinter);
}





/*------------------------------------------------------------------------

    Entry points for spooler components.

------------------------------------------------------------------------*/

BOOL
SpoolerFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    PHANDLE phEvent,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PVOID pvReserved)
{
    return FindFirstPrinterChangeNotificationWorker(
               hPrinter,
               fdwFilterFlags,
               fdwOptions,
               0,
               pPrinterNotifyOptions,
               phEvent,
               TRUE);
}


BOOL
SpoolerFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    LPDWORD pfdwChange,
    LPVOID pPrinterNotifyOptions,
    LPVOID *ppPrinterNotifyInfo)

/*++

Routine Description:

    Jump routine for FindNext for internal spooler components to use.

Arguments:

Return Value:

--*/

{
    BOOL bReturn;
    DWORD fdwFlags = 0;

    if (ppPrinterNotifyInfo) {

        fdwFlags = PRINTER_NOTIFY_NEXT_INFO;
    }

    bReturn = RouterFindNextPrinterChangeNotification(
                  hPrinter,
                  fdwFlags,
                  pfdwChange,
                  pPrinterNotifyOptions,
                  (PPRINTER_NOTIFY_INFO*)ppPrinterNotifyInfo);

    return bReturn;
}

VOID
SpoolerFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo)
{
    RouterFreePrinterNotifyInfo(pInfo);
}

BOOL
SpoolerFindClosePrinterChangeNotification(
    HANDLE hPrinter)

/*++

Routine Description:

    Jump routine for FindClose for internal spooler components to use.

Arguments:

Return Value:

--*/

{
    return FindClosePrinterChangeNotification(hPrinter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\clusspl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusspl.c

Abstract:

    Cluster code support.

Author:

    Albert Ting (AlbertT) 1-Oct-96

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "local.h"
#include "clusrout.h"

typedef struct _CLUSTERHANDLE {
    DWORD       signature;
    LPPROVIDOR  pProvidor;
    HANDLE      hCluster;
} CLUSTERHANDLE, *PCLUSTERHANDLE;


BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )

/*++

Routine Description:

    Open a hSpooler resource by searching the providers.

Arguments:

    pszServer - Server that should be opened.  Currently only NULL
        is supported.

    pszResource - Name of the resource to open.

    phSpooler - Receives new spooler handle.

    pszName - Name that the resource should recognize.  Comma delimted.

    pszAddress - Tcp/ip address the resource should recognize.  Comma delimited.

Return Value:

    TRUE - Success

    FALSE - Failure, GetLastError() set.

--*/

{
    LPPROVIDOR      pProvidor;
    DWORD           dwFirstSignificantError = ERROR_INVALID_NAME;
    PCLUSTERHANDLE  pClusterHandle;
    LPWSTR          pPrinterName;
    DWORD           dwStatus;
    HANDLE          hCluster;

    WaitForSpoolerInitialization();

    if( pszServer ){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pClusterHandle = AllocSplMem( sizeof( CLUSTERHANDLE ));

    if (!pClusterHandle) {

        DBGMSG( DBG_WARNING, ("Failed to alloc cluster handle."));
        return FALSE;
    }


    pProvidor = pLocalProvidor;
    *phSpooler = NULL;

    while (pProvidor) {

        dwStatus = (*pProvidor->PrintProvidor.fpClusterSplOpen)(
                       pszServer,
                       pszResource,
                       &hCluster,
                       pszName,
                       pszAddress);

        if ( dwStatus == ROUTER_SUCCESS ) {

            pClusterHandle->signature = CLUSTERHANDLE_SIGNATURE;
            pClusterHandle->pProvidor = pProvidor;
            pClusterHandle->hCluster = hCluster;

            *phSpooler = (HANDLE)pClusterHandle;
            return TRUE;

        } else {

            UpdateSignificantError( GetLastError(),
                                    &dwFirstSignificantError );
        }

        pProvidor = pProvidor->pNext;
    }

    FreeSplMem(pClusterHandle);

    UpdateSignificantError( ERROR_INVALID_PRINTER_NAME,
                            &dwFirstSignificantError );
    SetLastError(dwFirstSignificantError);

    return FALSE;
}

BOOL
ClusterSplClose(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Closes the spooler handle.

Arguments:

    hSpooler - hSpooler to close.

Return Value:

    TRUE - Success

    FALSE - Failure.  LastError set.

    Note: What happens if this fails?  Should the user try again.

--*/

{
    PCLUSTERHANDLE pClusterHandle=(PCLUSTERHANDLE)hSpooler;

    EnterRouterSem();

    if (!pClusterHandle ||
        pClusterHandle->signature != CLUSTERHANDLE_SIGNATURE) {

        LeaveRouterSem();
        SetLastError(ERROR_INVALID_HANDLE);

        return FALSE;
    }

    LeaveRouterSem();

    if ((*pClusterHandle->pProvidor->PrintProvidor.fpClusterSplClose)(
              pClusterHandle->hCluster)) {

        FreeSplMem( pClusterHandle );
        return TRUE;
    }

    return FALSE;
}

BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Determines whether the spooler is alive.

Arguments:

    hSpooler - Spooler to check.

Return Value:

    TRUE - Alive

    FALSE - Dead, LastError set.

--*/


{
    PCLUSTERHANDLE pClusterHandle=(PCLUSTERHANDLE)hSpooler;

    if (!pClusterHandle ||
        pClusterHandle->signature != CLUSTERHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pClusterHandle->pProvidor->PrintProvidor.fpClusterSplIsAlive)(
                 pClusterHandle->hCluster );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\info.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    info.c

Abstract:

    Handles marshalling support for notifications.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntfytab.h>
#include <stddef.h>

#define PRINTER_STRINGS
#include <data.h>

#define DEFINE(field, attrib, table, x, y) { attrib, table },

NOTIFY_ATTRIB_TABLE NotifyAttribPrinter[] = {
#include "ntfyprn.h"
};

NOTIFY_ATTRIB_TABLE NotifyAttribJob[] = {
#include "ntfyjob.h"
};
#undef DEFINE

PNOTIFY_ATTRIB_TABLE pNotifyAttribTable[] = {
    NotifyAttribPrinter,
    NotifyAttribJob
};

DWORD adwNotifyAttribMax[] = {
    COUNTOF(NotifyAttribPrinter),
    COUNTOF(NotifyAttribJob)
};

DWORD adwNotifyDatatypes[] = NOTIFY_DATATYPES;
extern DWORD cDefaultPrinterNotifyInfoData;

//
// Forward prototypes.
//

PPRINTER_NOTIFY_INFO
RouterAllocPrinterNotifyInfo(
    DWORD cPrinterNotifyInfoData)
{
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo = NULL;

    if (!cPrinterNotifyInfoData)
        cPrinterNotifyInfoData = cDefaultPrinterNotifyInfoData;

    pPrinterNotifyInfo = MIDL_user_allocate(
                             sizeof(PRINTER_NOTIFY_INFO)      -
                             sizeof(PRINTER_NOTIFY_INFO_DATA) +
                             (cPrinterNotifyInfoData * sizeof(PRINTER_NOTIFY_INFO_DATA)));

    //
    // Must initialize version/count.
    //
    if (pPrinterNotifyInfo != NULL) {
        pPrinterNotifyInfo->Version = NOTIFICATION_VERSION;
        pPrinterNotifyInfo->Count = 0;

        if (pPrinterNotifyInfo) {

            ClearPrinterNotifyInfo(pPrinterNotifyInfo, NULL);
        }
    }

    return pPrinterNotifyInfo;
}

VOID
SetupPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange)
{
    //
    // Set the color flag.
    //
    pInfo->Flags |= PRINTER_NOTIFY_INFO_COLORSET;

    //
    // We should set the discard bit if there was a previous overflow
    // and we didn't or couldn't allocate a pInfo structure.
    // Do it now.
    //
    if (pChange && pChange->eStatus & STATUS_CHANGE_DISCARDED) {

        pInfo->Flags |= PRINTER_NOTIFY_INFO_DISCARDED;
    }
}


BOOL
FreePrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfo)
{
    DWORD i;
    PPRINTER_NOTIFY_INFO_DATA pData;

    for(pData = pInfo->aData, i=pInfo->Count;
        i;
        pData++, i--) {

        if ((TABLE)pData->Reserved != TABLE_DWORD) {

            MIDL_user_free(pData->NotifyData.Data.pBuf);
        }
    }
    return TRUE;
}



BOOL
RouterFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo)
{
    if (!pInfo) {

        DBGMSG(DBG_WARNING, ("RFreePrinterNotifyInfo called with NULL!\n"));
        return FALSE;
    }

    FreePrinterNotifyInfoData(pInfo);

    MIDL_user_free(pInfo);
    return TRUE;
}



VOID
ClearPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange)

/*++

Routine Description:

    Clears the PRINTER_NOTIFY structure for more notifications.

Arguments:

    pInfo - Info to clear ( pInfo->aData must be valid if pInfo->Count != 0 )

    pChange - Associated pChange structure.

Return Value:

--*/

{
    if (!pInfo)
        return;

    FreePrinterNotifyInfoData(pInfo);

    pInfo->Flags = 0;
    pInfo->Count = 0;

    if (pChange)
        SetupPrinterNotifyInfo(pInfo, pChange);
}


VOID
SetDiscardPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange)
{
    if (pInfo) {

        FreePrinterNotifyInfoData(pInfo);

        pInfo->Count = 0;
        pInfo->Flags |= PRINTER_NOTIFY_INFO_DISCARDED;
    }

    if (pChange)
        pChange->eStatus |= STATUS_CHANGE_DISCARDED;
}


DWORD
AppendPrinterNotifyInfo(
    PPRINTHANDLE pPrintHandle,
    DWORD dwColor,
    PPRINTER_NOTIFY_INFO pInfoSrc)

/*++

Routine Description:

    Appends pInfoSrc to the pPrintHandle.  We may get Src with zero
    notifications.  This occurs when when the user requests a refresh
    and the client spooler synchronously replies back to clear out
    everything.

Arguments:

    pPrintHandle -- handle to update

    pInfoSrc -- Source of info.  NULL = no info.

Return Value:

    Result of action.

--*/

{
    PPRINTER_NOTIFY_INFO pInfoDest;
    PCHANGE pChange;
    PPRINTER_NOTIFY_INFO_DATA pDataSrc;

    DWORD i;

    pChange = pPrintHandle->pChange;
    pInfoDest = pChange->ChangeInfo.pPrinterNotifyInfo;


    //
    // May be NULL if RPCing and the buffer is being used.
    // The worker thread will free the data.
    //
    if (!pInfoDest) {

        pInfoDest = RouterAllocPrinterNotifyInfo(0);

        if (!pInfoDest) {

            DBGMSG(DBG_WARNING,
                   ("AppendPrinterNotifyInfo: Alloc fail, Can't set DISCARD\n"));

            goto Discard;
        }

        SetupPrinterNotifyInfo(pInfoDest, pChange);
        pChange->ChangeInfo.pPrinterNotifyInfo = pInfoDest;
    }


    if (!pInfoSrc) {
        return 0;
    }


    //
    // We must handle the case where the user requests and receives
    // a refresh, but the there was an outstanding RPC that is just
    // now being processed.  In this case, we must drop this
    // notification.  We determine this by maintaining a color value.
    //
    // Note that we can't return the DISCARDNOTED flag, since this can't
    // trigger an overflow.
    //
    // If (Color is set) AND (NOT color same) fail.
    //
    if (pInfoSrc->Flags & PRINTER_NOTIFY_INFO_COLORSET) {

        if (dwColor != pChange->dwColor) {

            DBGMSG(DBG_WARNING, ("AppendPrinterNotifyInfo: Color mismatch info %d != %d; discard\n",
                                 dwColor, pChange->dwColor));
            //
            // Clear it out, and we're done.
            //
            ClearPrinterNotifyInfo(pInfoDest,
                                   pChange);

            return PRINTER_NOTIFY_INFO_COLORMISMATCH;
        }
    }

    //
    // OR in the flags.
    //
    pInfoDest->Flags |= pInfoSrc->Flags;

    //
    // Check for overflow.
    //
    if (pInfoSrc->Count + pInfoDest->Count < cDefaultPrinterNotifyInfoData) {

        //
        // Now copy everything over.
        //
        for (pDataSrc = pInfoSrc->aData, i = pInfoSrc->Count;
            i;
            i--, pDataSrc++) {

            AppendPrinterNotifyInfoData(
                pInfoDest,
                pDataSrc,
                PRINTER_NOTIFY_INFO_DATA_COMPACT);
        }
    } else {

Discard:
        SetDiscardPrinterNotifyInfo(pInfoDest, pChange);

        return PRINTER_NOTIFY_INFO_DISCARDED |
               PRINTER_NOTIFY_INFO_DISCARDNOTED;
    }
    return 0;
}


BOOL
AppendPrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfoDest,
    PPRINTER_NOTIFY_INFO_DATA pDataSrc,
    DWORD fdwFlags)

/*++

Routine Description:

    Append the data to the pInfoDest.  If pDataSrc is NULL, set discard.

Arguments:

Return Value:

--*/

{
    PPRINTER_NOTIFY_INFO_DATA pDataDest;
    DWORD i;
    BOOL bCompact = FALSE;
    DWORD Count;
    PPRINTER_NOTIFY_INFO_DATA pDataNew;
    BOOL bNewSlot = TRUE;

    DWORD Type;
    DWORD Field;
    DWORD Table;
    DWORD Id;

    EnterRouterSem();

    if (!pDataSrc || (pInfoDest->Flags & PRINTER_NOTIFY_INFO_DISCARDED)) {

        SetLastError(ERROR_OUT_OF_STRUCTURES);
        goto DoDiscard;
    }

    Type = pDataSrc->Type;
    Field = pDataSrc->Field;
    Table = pDataSrc->Reserved;
    Id = pDataSrc->Id;

    //
    // Validate this is a correct type.
    //
    if (Type < NOTIFY_TYPE_MAX && Field < adwNotifyAttribMax[Type]) {

        //
        // If Table == 0, then the caller did not specify the type,
        // so we fill it in as appropriate.
        //
        // If it is non-zero and it's doesn't match our value, then
        // return an error.
        //
        if (Table != pNotifyAttribTable[Type][Field].Table) {

            if (Table) {

                //
                // The specified table type does not match our table
                // type.  Punt, since we can't marshall.
                //
                DBGMSG(DBG_WARNING, ("Table = %d, != Type %d /Field %d!\n",
                                     Table, Field, Type));

                SetLastError(ERROR_INVALID_PARAMETER);
                goto DoDiscard;
            }

            //
            // Fix up the Table entry.
            //
            Table = pNotifyAttribTable[Type][Field].Table;
            pDataSrc->Reserved = (TABLE)Table;
        }

        bCompact = (fdwFlags & PRINTER_NOTIFY_INFO_DATA_COMPACT) &&
                   (pNotifyAttribTable[Type][Field].Attrib &
                       TABLE_ATTRIB_COMPACT);
    } else {

        //
        // This is not an error case, since we can still marshall fields
        // we don't know about as long as the Table is valid.
        //
        DBGMSG(DBG_WARNING, ("Unknown: Type= %d Field= %d!\n", Type, Field));
    }

    if (!Table || Table >= COUNTOF(adwNotifyDatatypes)) {

        DBGMSG(DBG_WARNING, ("Table %d unknown; can't marshall!\n",
                             Table));

        SetLastError(ERROR_INVALID_PARAMETER);
        goto DoDiscard;
    }

    SPLASSERT(Table);

    //
    // Check if compactable.
    //
    if (bCompact) {

        //
        // We can compact, see if there is a match.
        //
        for (pDataDest = pInfoDest->aData, i = pInfoDest->Count;
            i;
            pDataDest++, i--) {

            if (Type == pDataDest->Type &&
                Field == pDataDest->Field &&
                Id == pDataDest->Id) {

                if (Table == TABLE_DWORD) {

                    pDataDest->NotifyData.adwData[0] =
                        pDataSrc->NotifyData.adwData[0];

                    pDataDest->NotifyData.adwData[1] =
                        pDataSrc->NotifyData.adwData[1];

                    goto Done;
                }

                //
                // Must copy the data, so free the old one.
                //
                MIDL_user_free(pDataDest->NotifyData.Data.pBuf);

                bNewSlot = FALSE;
                break;
            }
        }

        //
        // pDataDest now points to the correct slot (either end or
        // somewhere in the middle if we are compacting.
        //

    } else {

        //
        // Slot defaults to the end.
        //
        pDataDest = &pInfoDest->aData[pInfoDest->Count];
    }


    //
    // Copy structure first
    //
    *pDataDest = *pDataSrc;

    //
    // The data may be either a pointer or the actual DWORD data.
    //
    if (adwNotifyDatatypes[Table] & TABLE_ATTRIB_DATA_PTR) {

        DWORD cbData = pDataSrc->NotifyData.Data.cbBuf;

        //
        // Now copy everything over.
        //
        pDataNew = (PPRINTER_NOTIFY_INFO_DATA)MIDL_user_allocate(cbData);

        if (!pDataNew) {

            pDataDest->NotifyData.Data.pBuf = NULL;
            DBGMSG( DBG_WARNING, ("Alloc %d bytes failed with %d\n",
                                  GetLastError()));
            goto DoDiscard;
        }

        CopyMemory(pDataNew, pDataSrc->NotifyData.Data.pBuf, cbData);

        pDataDest->NotifyData.Data.cbBuf = cbData;
        pDataDest->NotifyData.Data.pBuf = pDataNew;
    }

    //
    // Increment if necessary.
    //
    if (bNewSlot)
        pInfoDest->Count++;

Done:

    LeaveRouterSem();
    return TRUE;

DoDiscard:

    SetDiscardPrinterNotifyInfo(pInfoDest, NULL);
    LeaveRouterSem();

    return FALSE;
}


BOOL
RouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PPRINTER_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Implements the refresh portion of FindNextPrinterChangeNotification.

Arguments:

Return Value:

--*/

{
    PPRINTHANDLE pPrintHandle = (PPRINTHANDLE)hPrinter;
    BOOL bReturn;

    EnterRouterSem();

    if (!pPrintHandle ||
        pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange ||
        !(pPrintHandle->pChange->eStatus & (STATUS_CHANGE_VALID |
                                            STATUS_CHANGE_INFO))) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Fail;
    }

    if (!pPrintHandle->pProvidor->PrintProvidor.fpRefreshPrinterChangeNotification) {

        SetLastError(RPC_S_PROCNUM_OUT_OF_RANGE);
        goto Fail;
    }

    pPrintHandle->pChange->dwColor = dwColor;

    //
    // Allow notifications to begin again.
    //
    pPrintHandle->pChange->eStatus &= ~(STATUS_CHANGE_DISCARDED |
                                        STATUS_CHANGE_DISCARDNOTED);

    ClearPrinterNotifyInfo(pPrintHandle->pChange->ChangeInfo.pPrinterNotifyInfo,
                           pPrintHandle->pChange);

    LeaveRouterSem();

    bReturn = (*pPrintHandle->pProvidor->PrintProvidor.fpRefreshPrinterChangeNotification)(
                  pPrintHandle->hPrinter,
                  pPrintHandle->pChange->dwColor,
                  pPrinterNotifyRefresh,
                  ppInfo);

    //
    // On failure, set discard.
    //
    if (!bReturn) {

        EnterRouterSem();

        //
        // The handle should be valid since RPC guarentees that context
        // handle access is serialized.  However, a misbehaved
        // multithreaded spooler component could cause this to happen.
        //
        SPLASSERT(pPrintHandle->signature == PRINTHANDLE_SIGNATURE);

        if (pPrintHandle->pChange) {

            //
            // Disallow notifications since the refresh failed.
            //
            pPrintHandle->pChange->eStatus |= STATUS_CHANGE_DISCARDED;
        }

        LeaveRouterSem();
    }

    return bReturn;

Fail:
    LeaveRouterSem();
    return FALSE;
}



BOOL
NotifyNeeded(
    PCHANGE pChange)
{
    register PPRINTER_NOTIFY_INFO pInfo;

    pInfo = pChange->ChangeInfo.pPrinterNotifyInfo;

    if (pChange->eStatus & STATUS_CHANGE_DISCARDNOTED) {
        return FALSE;
    }

    if (pChange->fdwChangeFlags || pChange->eStatus & STATUS_CHANGE_DISCARDED) {
        return TRUE;
    }

    if (!pInfo) {
        return FALSE;
    }

    if (pInfo->Flags & PRINTER_NOTIFY_INFO_DISCARDED || pInfo->Count) {
        return TRUE;
    }
    return FALSE;
}


/*------------------------------------------------------------------------

    Entry points for providors.

------------------------------------------------------------------------*/


BOOL
ReplyPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwChangeFlags,
    PDWORD pdwResult,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
    )

/*++

Routine Description:

    Updates a notification with an entire pPrinterNotifyInfo packet.
    Providers can call PartialRPCN several times with small packets (the
    router won't send them until ReplyPrinterChangeNotification is sent).
    This allows batching and guarentees atmoic notifications.

Arguments:

    hPrinter - Handle that is being watched.

    fdwChangeFlags - Flags that changed (WPC type flags for compatibility)

    pdwResult - Result of changes (OPTIONAL).  Indicates whether changes
        were discarded, and if the discard was noted.

    pPrinterNotifyInfo - Information about change.

Return Value:

    TRUE - success
    FALSE - failure, call GetLastError().

--*/

{
    return ReplyPrinterChangeNotificationWorker(
               hPrinter,
               0,
               fdwChangeFlags,
               pdwResult,
               pPrinterNotifyInfo);
}


BOOL
PartialReplyPrinterChangeNotification(
    HANDLE hPrinter,
    PPRINTER_NOTIFY_INFO_DATA pDataSrc
    )

/*++

Routine Description:

    Updates the notify info without triggering a notification.  This is
    used to send multiple infos without rpcing on each one.  Do a
    ReplyPrinterChangeNotificiation at the end.

Arguments:

    hPrinter -- Printer handle that changed.

    pDataSrc -- Partial data to store.  If NULL, indicates a discard
        should be stored, causing the client to refresh.

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;
    BOOL bReturn = FALSE;
    PPRINTER_NOTIFY_INFO* ppInfoDest;

    EnterRouterSem();

    if (!pPrintHandle ||
        pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange) {

        DBGMSG(DBG_WARNING, ("PartialRPCN: Invalid handle 0x%x!\n",
                             hPrinter));
        SetLastError(ERROR_INVALID_HANDLE);
        goto Fail;
    }

    if (!(pPrintHandle->pChange->eStatus &
        (STATUS_CHANGE_VALID|STATUS_CHANGE_INFO))) {

        DBGMSG(DBG_WARNING, ("PartialRPCN: Invalid handle 0x%x state = 0x%x!\n",
                             hPrinter,
                             pPrintHandle->pChange->eStatus));

        SetLastError(ERROR_INVALID_HANDLE);
        goto Fail;
    }

    ppInfoDest = &pPrintHandle->pChange->ChangeInfo.pPrinterNotifyInfo;

    if (!pDataSrc) {

        bReturn = TRUE;
        goto Discard;
    }

    //
    // May be NULL if RPCing and the buffer is being used.
    // The worker thread will free the data.
    //
    if (!*ppInfoDest) {

        *ppInfoDest = RouterAllocPrinterNotifyInfo(0);

        if (!*ppInfoDest) {

            DBGMSG(DBG_WARNING,
                   ("PartialReplyPCN: Alloc failed, discarding\n"));

            //
            // We should set the discard flag here, but we can't,
            // so punt.
            //
            goto Discard;
        }

        SetupPrinterNotifyInfo(*ppInfoDest, pPrintHandle->pChange);
    }

    //
    // Check that we have enough space for the current data.
    //
    if ((*ppInfoDest)->Count < cDefaultPrinterNotifyInfoData) {

        bReturn = AppendPrinterNotifyInfoData(
                      *ppInfoDest,
                      pDataSrc,
                      PRINTER_NOTIFY_INFO_DATA_COMPACT);
    } else {

        SetLastError(ERROR_OUT_OF_STRUCTURES);

Discard:
        SetDiscardPrinterNotifyInfo(*ppInfoDest, pPrintHandle->pChange);
    }

Fail:
    LeaveRouterSem();
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\devmode.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved

Module Name:

    devmode.c

Abstract:

    Handles per-user devmode implementation.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"
#include <offsets.h>

/********************************************************************

    Forward prototypes

********************************************************************/

BOOL
bGetDevModeLocation(
    IN HKEY hKeyUser, OPTIONAL
    IN LPCWSTR pszPrinter,
    OUT PHKEY phKey,
    OUT LPCWSTR *ppszValue
    );


const WCHAR gszPrinterConnections[] = L"Printers\\Connections\\";
const WCHAR gszDevMode[] = L"DevMode";
const WCHAR gszDevModePerUserLocal[] = L"Printers\\DevModePerUser";

/********************************************************************

    Private  Functions

********************************************************************/


DWORD
RegOpenConnectionKey(
    HKEY hKeyUser,
    LPWSTR pszPrinter,
    PHKEY phKey
    )
{
    PWCHAR pszPrinterScratch = NULL;
    DWORD  dwRetValue        = ERROR_SUCCESS;
    DWORD  cchSize           = MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX + COUNTOF( gszPrinterConnections );

    if (pszPrinter &&
        wcslen(pszPrinter) < MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX) {

        if (pszPrinterScratch = AllocSplMem(cchSize * sizeof(WCHAR))) {

            StringCchCopy(pszPrinterScratch, cchSize, gszPrinterConnections);

            FormatPrinterForRegistryKey(pszPrinter,
                                        &pszPrinterScratch[ COUNTOF( gszPrinterConnections )-1],
                                        cchSize - COUNTOF( gszPrinterConnections ) - 1);

            dwRetValue = RegOpenKeyEx(hKeyUser,
                                      pszPrinterScratch,
                                      0,
                                      KEY_READ | KEY_WRITE,
                                      phKey );

            FreeSplMem(pszPrinterScratch);

        } else {

            dwRetValue = GetLastError();
        }

    } else {

        dwRetValue = ERROR_INVALID_PARAMETER;
    }

    return dwRetValue;
}


/********************************************************************

    Public functions

********************************************************************/

BOOL
bSetDevModePerUser(
    HANDLE hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE pDevMode
    )

/*++

Routine Description:

    Sets the per-user DevMode in HKCU.

Arguments:

    hKeyUser - HKEY_CURRENT_USER handle.  OPTIONAL

    pszPrinter - Printer to set.

    pDevMode - DevMode to save.  If NULL, deletes value.

Return Value:

    TRUE - Success
    FALSE - Failure

--*/

{
    HKEY hKey = NULL;
    LPWSTR pszValue = NULL;
    DWORD Status;

    if( !pszPrinter ){
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    //
    // Retrieve the location of the DevMode.
    //
    if( !bGetDevModeLocation( hKeyUser,
                              pszPrinter,
                              &hKey,
                              &pszValue )){

        return FALSE;
    }

    if( !pDevMode ){

        //
        // NULL, so delete the value.
        //
        Status = RegDeleteValue( hKey, pszValue );

        //
        // If value not found, don't fail.
        //
        if( Status == ERROR_FILE_NOT_FOUND ){
            Status = ERROR_SUCCESS;
        }

    } else {

        Status = RegSetValueEx( hKey,
                                pszValue,
                                0,
                                REG_BINARY,
                                (PBYTE)pDevMode,
                                pDevMode->dmSize +
                                    pDevMode->dmDriverExtra );

        if( Status == ERROR_SUCCESS ){

            //
            // Notify everyone that the DevMode has changed.
            //
            SendNotifyMessage( HWND_BROADCAST,
                               WM_DEVMODECHANGE,
                               0,
                               (LPARAM)pszPrinter );
        }
    }

    RegCloseKey( hKey );

    if( Status != ERROR_SUCCESS ){
        SetLastError( Status );
        return FALSE;
    }

    return TRUE;
}

BOOL
bGetDevModePerUser(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE *ppDevMode
    )

/*++

Routine Description:

    Retrieves the per-user DevMode based on the current user.

Arguments:

    hKeyUser - HKEY_CURRENT_USER handle.  OPTIONAL

    pszPrinter - Printer to get.

    ppDevMode - Receives pointer to devmode.  Must be freed by callee.

Return Value:

    TRUE - Success: able to check if per-user DevMode exists.  *ppDevMode
        is NULL if no per-user DevMode is there.  (TRUE does not indicate
        that a per-user DevMode was found, only that we successfully checked.)

    FALSE - Failure.

--*/

{
    HKEY hKey = NULL;
    LPWSTR pszValue = NULL;
    LONG Status;

    *ppDevMode = NULL;

    if( !pszPrinter ){
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }
    //
    // Retrieve the location of the DevMode.
    //
    if( !bGetDevModeLocation( hKeyUser,
                              pszPrinter,
                              &hKey,
                              &pszValue )){

        Status = GetLastError();

    } else {

        DWORD cbDevModePerUser;

        //
        // Key exists.  See if we can read it and get the per-user DevMode.
        //
        Status = RegQueryInfoKey( hKey,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &cbDevModePerUser,
                                  NULL,
                                  NULL );

        if( Status == ERROR_SUCCESS ){

            if( cbDevModePerUser >= MIN_DEVMODE_SIZEW ){

                *ppDevMode = AllocSplMem( cbDevModePerUser );

                if( !*ppDevMode ){

                    Status = GetLastError();

                } else {

                    Status = RegQueryValueEx( hKey,
                                              pszValue,
                                              NULL,
                                              NULL,
                                              (PBYTE)*ppDevMode,
                                              &cbDevModePerUser );

                    if (ERROR_SUCCESS == Status) {

                        Status = StatusFromHResult(SplIsValidDevmodeW(*ppDevMode, cbDevModePerUser));

                        //
                        // If the devmode isn't valid, delete it and treat it
                        // as if the devmode cannot be found.
                        //
                        if (ERROR_SUCCESS != Status) {

                            //
                            // If we can delete the key, just consider it as if
                            // it does not exist.
                            //
                            if (ERROR_SUCCESS == RegDeleteValue(hKey, pszValue)) {

                                Status = ERROR_FILE_NOT_FOUND;
                            }
                        }
                    }

                    if( Status != ERROR_SUCCESS ){
                        FreeSplMem( *ppDevMode );
                        *ppDevMode = NULL;
                    }

                    //
                    // Allow ERROR_FILE_NOT_FOUND to return success.  *ppDevMode
                    // is still NULL, but we return TRUE to indicate that we
                    // successfully checked the registry--we just didn't find one.
                    //
                    if( Status == ERROR_FILE_NOT_FOUND ){
                        Status = ERROR_SUCCESS;
                    }
                }
            }
        }

        RegCloseKey( hKey );
    }

    if( Status != ERROR_SUCCESS ){
        SetLastError( Status );
        return FALSE;
    }

    return TRUE;
}


BOOL
bCompatibleDevMode(
    PPRINTHANDLE pPrintHandle,
    PDEVMODE pDevModeBase,
    PDEVMODE pDevModeNew
    )

/*++

Routine Description:

    Check if two DevModes are compatible (e.g., they can be used
    interchangably).

    This is done by checking size and version information.  Not
    foolproof, but the best we can do since we can't look at private
    information.

Arguments:

    pPrintHandle - Printer to check.

    pDevModeBase - Known good DevMode.

    pDevModeNew - DevMode to check.

Return Value:

    TRUE - Appears compatible.
    FALSE - Not compatible.

--*/
{
    if( !pDevModeBase || ! pDevModeNew ){
        return FALSE;
    }

    return pDevModeBase->dmSize == pDevModeNew->dmSize &&
           pDevModeBase->dmDriverExtra == pDevModeNew->dmDriverExtra &&
           pDevModeBase->dmSpecVersion == pDevModeNew->dmSpecVersion &&
           pDevModeBase->dmDriverVersion == pDevModeNew->dmDriverVersion;
}

/********************************************************************

    Support Functions

********************************************************************/

BOOL
bGetDevModeLocation(
    IN HKEY hKeyUser, OPTIONAL
    IN LPCWSTR pszPrinter,
    OUT PHKEY phKey,
    OUT LPCWSTR *ppszValue
    )

/*++

Routine Description:

    Retrieves the location of the per-user DevMode.

    On success, caller is responsible for closing phKey.  ppszValue's
    life is dependent on pszPrinter.

Arguments:

    hKeyUser - HKEY_CURRENT_USER key--optional.  If not specified, current
        impersonation used.

    pszPrinter - Printer to use.

    phKey - Receives R/W key of per-user DevMode.  On success, this
        must be closed by caller.

    ppszValue - Receives value of per-user DevMode (where to read/write).

Return Value:

    TRUE - Success

    FALSE - Failure, LastError set.

--*/

{
    HANDLE hKeyClose = NULL;
    DWORD Status;

    *phKey = NULL;
    *ppszValue = NULL;

    if( !hKeyUser ){

        hKeyUser = GetClientUserHandle( KEY_READ|KEY_WRITE );
        hKeyClose = hKeyUser;
    }

    if( !hKeyUser ){

        //
        // Failed to get impersonation information.  Probably because
        // we're not impersonating, so there's no per-user information.
        //
        Status = GetLastError();

    } else {

        //
        // If it starts with two backslashes, it may be either a connection
        // or a masq printer.
        //
        if( pszPrinter[0] == L'\\' && pszPrinter[1] == L'\\' )
        {

            //
            // Query the registry for pszPrinter and look for DevMode.
            // First look at the HKCU:Printer\Connections.
            //

            if((Status = RegOpenConnectionKey(hKeyUser,(LPWSTR)pszPrinter,phKey)) == ERROR_SUCCESS)
            {
                *ppszValue = gszDevMode;
            }
        }

        //
        // If we didn't find it in Printer\Connection, then it
        // must be a local or masq printer.
        //
        if( !*ppszValue ){

            DWORD dwIgnore;

            //
            // Not a connection or didn't exist in the connections key.
            // Look in the Printers\DevModePerUser key.
            //
            Status = RegCreateKeyEx( hKeyUser,
                                     gszDevModePerUserLocal,
                                     0,
                                     NULL,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     phKey,
                                     &dwIgnore );

            if( Status == ERROR_SUCCESS ){
                *ppszValue = pszPrinter;
            }
        }
    }

    if( hKeyClose ){
        RegCloseKey( hKeyClose );
    }

    if( Status != ERROR_SUCCESS ){
        SetLastError( Status );
        return FALSE;
    }

    return TRUE;
}

BOOL bGetDevModePerUserEvenForShares(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE *ppDevMode
    )
{
    BOOL   RetVal = FALSE;
    HANDLE hPrinter;

    if(OpenPrinter((LPWSTR)pszPrinter,&hPrinter,NULL))
    {
        DWORD            PrntrInfoSize=0,PrntrInfoSizeReq=0;
        PPRINTER_INFO_2  pPrinterInfo2 = NULL;

        if(!GetPrinter(hPrinter,
                       2,
                       (LPBYTE)pPrinterInfo2,
                       PrntrInfoSize,
                       &PrntrInfoSizeReq)                                                      &&
           (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                                       &&
           (pPrinterInfo2 = (PPRINTER_INFO_2)AllocSplMem((PrntrInfoSize = PrntrInfoSizeReq)))  &&
           GetPrinter(hPrinter,
                      2,
                      (LPBYTE)pPrinterInfo2,
                      PrntrInfoSize,
                      &PrntrInfoSizeReq))
        {
            RetVal = bGetDevModePerUser( hKeyUser,
                                         pPrinterInfo2->pPrinterName,
                                         ppDevMode );
        }

        if(hPrinter)
            ClosePrinter(hPrinter);

        if(pPrinterInfo2)
            FreeSplMem(pPrinterInfo2);
    }
    else
    {
        RetVal = bGetDevModePerUser( hKeyUser,
                                     pszPrinter,
                                     ppDevMode );
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\init.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    init.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss
     
--*/

#include "precomp.h"
#include "local.h"
#include <wmi.h>
#include "ncmgr.hxx"
#pragma hdrstop

WCHAR szDefaultPrinterNotifyInfoDataSize[] = L"DefaultPrinterNotifyInfoDataSize";
WCHAR szFailAllocs[] = L"FailAllocs";

WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];

#define DEFAULT_PRINTER_NOTIFY_DATA 0x80
DWORD cDefaultPrinterNotifyInfoData = DEFAULT_PRINTER_NOTIFY_DATA;
WCHAR szRouterCacheSize[] = L"RouterCacheSize";

WCHAR szUpgradeInProgKey[] = L"UpgradeInProgress";
WCHAR szMiniSetupInProgKey[] = L"MiniSetupInProgress";

fnWinSpoolDrv   fnClientSide;
BOOL            bWinspoolInitialized  = FALSE;

HANDLE                  hEventInit    = NULL;
BOOL                    Initialized   = FALSE;
DWORD                   dwUpgradeFlag = 0;
SERVICE_STATUS_HANDLE   ghSplHandle   = NULL;

extern CRITICAL_SECTION RouterCriticalSection;
extern CRITICAL_SECTION DeviceArrivalCS;
extern PROUTERCACHE RouterCacheTable;
extern DWORD RouterCacheSize;
extern LPWSTR *ppszOtherNames;

BOOL
SpoolerInitAll();

VOID
RegisterForPnPEvents(
    VOID
    );

LPPROVIDOR
InitializeProvidor(
   LPWSTR   pProvidorName,
   LPWSTR   pFullName)
{
    BOOL        bRet      = FALSE;
    HANDLE      hModule   = NULL;
    LPPROVIDOR  pProvidor = NULL;
    HANDLE      hToken    = NULL;
    UINT        ErrorMode;

    hToken = RevertToPrinterSelf();

    if (!hToken)
    {
        goto Cleanup;
    }

    //
    // WARNING-WARNING-WARNING, we null set the print providor
    // structure. older version of the print providor have different print
    // providor sizes so they will set only some function pointers and not
    // all of them
    //

    if ( !(pProvidor = (LPPROVIDOR)AllocSplMem(sizeof(PROVIDOR)))   ||
         !(pProvidor->lpName = AllocSplStr(pProvidorName)) ) {

        DBGMSG(DBG_ERROR,
               ("InitializeProvidor can't allocate memory for %ws\n",
                pProvidorName));
        goto Cleanup;
    }
    
    //
    // Make sure we don't get any dialogs popping up while this goes on.
    //
    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    
    hModule = pProvidor->hModule = LoadLibraryEx( pProvidorName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    
    SetErrorMode( ErrorMode );
    
    if ( !hModule ) {

        DBGMSG(DBG_WARNING,
               ("InitializeProvider failed LoadLibrary( %ws ) error %d\n",
                pProvidorName, GetLastError() ));
        goto Cleanup;
    }

    pProvidor->fpInitialize = GetProcAddress(hModule, "InitializePrintProvidor");

    if ( !pProvidor->fpInitialize )
        goto Cleanup;

    bRet = (BOOL)pProvidor->fpInitialize(&pProvidor->PrintProvidor,
                                   sizeof(PRINTPROVIDOR),
                                   pFullName);

    if ( !bRet ) {

        DBGMSG(DBG_WARNING,
               ("InitializePrintProvider failed for providor %ws error %d\n",
                pProvidorName, GetLastError()));
    }

    //
    // It is not a critical error if ImpersonatePrinterClient fails.
    // If fpInitialize succeeds and ImpersonatePrinterClient fails, 
    // then if we set bRet to FALSE we forcefully unload the initialized 
    // provider DLL and can cause resource leaks.
    //
    ImpersonatePrinterClient(hToken);
    
Cleanup:

    if ( bRet ) {

        //
        // Fixup any NULL entrypoints.
        //
        FixupOldProvidor( &pProvidor->PrintProvidor );

        return pProvidor;
    } else {

        if ( hModule )
            FreeLibrary(hModule);

        if ( pProvidor ) {

            FreeSplStr(pProvidor->lpName);
            FreeSplMem(pProvidor);
        }
        return NULL;
    }
}

BOOL
DllMain(
    HINSTANCE hInstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    BOOL Failed            = FALSE;
    BOOL ThreadInitted     = FALSE,
         WPCInitted        = FALSE,
         RouterCritSecInit = TRUE,
         DevArrCritSecInit = TRUE;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:


        if( !bSplLibInit(NULL)){
            Failed = TRUE;
            goto Done;
        }

        DisableThreadLibraryCalls(hInstDLL);

        if(!InitializeCriticalSectionAndSpinCount(&RouterCriticalSection, 0x80000000))
        {
            Failed = TRUE;
            RouterCritSecInit = FALSE;
            goto Done;
        }  

        if(!InitializeCriticalSectionAndSpinCount(&DeviceArrivalCS, 0x80000000))
        {
            Failed = TRUE;
            DevArrCritSecInit = FALSE;
            goto Done;
        }       

        if (!WPCInit()) {
            Failed = TRUE;
            goto Done;
        } else {
            WPCInitted = TRUE;
        }

        if (!ThreadInit()) {
            Failed = TRUE;
            goto Done;
        } else {
            ThreadInitted = TRUE;
        }
        
        //
        // Create our global init event (manual reset)
        // This will be set when we are initialized.
        //
        hEventInit = CreateEvent(NULL,
                                 TRUE,
                                 FALSE,
                                 NULL);

        if (!hEventInit) {

            Failed = TRUE;
            goto Done;
        }
        
Done:
        if (Failed)
        {
            if (RouterCritSecInit) {
                DeleteCriticalSection(&RouterCriticalSection);
            }

            if (DevArrCritSecInit)
            {
                DeleteCriticalSection(&DeviceArrivalCS);
            }

            if (hEventInit) {
                CloseHandle(hEventInit);
            }

            if (WPCInitted) {
                WPCDestroy();
            }
            
            if (ThreadInitted) {
                ThreadDestroy();
            }

            WmiTerminateTrace();    // Unregisters spoolss from WMI.

            return FALSE;
        }
        break;

    case DLL_PROCESS_DETACH:

        ThreadDestroy();
        WPCDestroy();

        CloseHandle(hEventInit);
        break;
    }
    return TRUE;
}




BOOL
InitializeRouter(
    IN      RouterInitializationParams      *pRouterParams
)
/*++

Routine Description:

    This function will Initialize the Routing layer for the Print Providors.
    This will involve scanning the win.ini file, loading Print Providors, and
    creating instance data for each.

Arguments:

    pRouterParams       -   Parameters passed in to the router.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPPROVIDOR  pProvidor;
    DWORD   cbDll;
    WCHAR   ProvidorName[MAX_PATH], Dll[MAX_PATH], szFullName[MAX_PATH];
    HKEY    hKey, hKey1;
    LONG    Status;

    LPWSTR  lpMem = NULL;
    LPWSTR  psz = NULL;
    DWORD   dwRequired = 0;
    BOOL    bRet = FALSE;

    DWORD   SpoolerPriorityClass = 0;
    NT_PRODUCT_TYPE NtProductType;
    DWORD   dwCacheSize = 0;

    DWORD dwType;
    DWORD cbData;

    DWORD i;
    extern DWORD cOtherNames;
    WCHAR szSetupKey[] = L"System\\Setup";

    //
    // First, assign the server side exports to our global variable to keep
    // track of them.
    //
    gpServerExports = (PrintSpoolerServerExports*)(pRouterParams->pExports);

    //
    // WMI Trace Events. Registers spoolss with WMI.
    //
    WmiInitializeTrace();  

    //
    // Initliaize the name cache
    //
    {
        HRESULT hr;

        hr = CacheInitNameCache();

        if (SUCCEEDED(hr))
        {
            hr = InitializePnPIPAddressChangeListener(CacheRefresh);
        }

        if (FAILED(hr))
        {
            DBGMSG(DBG_ERROR, ("Failed initializing the cache hr %x\n", hr));

            ExitProcess(0);
        }
    }
    
    ghSplHandle = pRouterParams->SpoolerStatusHandle;

    //
    // We are now assume that the other services and drivers have
    // initialized.  The loader of this dll must do this syncing.
    //
    // spoolss\server does this by using the GroupOrderList
    // SCM will try load load parallel and serial before starting
    // the spooler service.
    //

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szPrintKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey)) {

        cbData = sizeof(SpoolerPriorityClass);

        //
        // SpoolerPriority
        //
        Status = RegQueryValueEx(hKey,
                                 L"SpoolerPriority",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&SpoolerPriorityClass,
                                 &cbData);


        if (Status == ERROR_SUCCESS &&
           (SpoolerPriorityClass == IDLE_PRIORITY_CLASS ||
            SpoolerPriorityClass == NORMAL_PRIORITY_CLASS ||
            SpoolerPriorityClass == HIGH_PRIORITY_CLASS)) {

                Status = SetPriorityClass(GetCurrentProcess(), SpoolerPriorityClass);
        }


        cbData = sizeof(cDefaultPrinterNotifyInfoData);

        //
        // Ignore failure case since we can use the default
        //
        RegQueryValueEx(hKey,
                        szDefaultPrinterNotifyInfoDataSize,
                        NULL,
                        &dwType,
                        (LPBYTE)&cDefaultPrinterNotifyInfoData,
                        &cbData);


        RegCloseKey(hKey);
    }


    // Is it an upgrade?

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szSetupKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey)) {

        /*++
            You can tell if you are inside gui setup by looking for
            HKLM\System\Setup\SystemSetupInProgress  -- non zero means gui-setup is running.
        

            The following description is outdated. 

            Description: the query update flag is set up by TedM. We will read this flag
            if the flag has been set, we will set a boolean variable saying that we're in
            the upgrade mode. All upgrade activities will be carried out based on this flag.
            For subsequents startups of the spooler, this flag will be unvailable so we
            won't run the spooler in upgrade mode.

        --*/

        dwUpgradeFlag = 0;

        cbData = sizeof(dwUpgradeFlag);

        Status = RegQueryValueEx(hKey,
                                 L"SystemSetupInProgress",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwUpgradeFlag,
                                 &cbData);


        if (Status != ERROR_SUCCESS) {
            dwUpgradeFlag = 0;
        }

        
        DBGMSG(DBG_TRACE, ("The Spooler Upgrade flag is %d\n", dwUpgradeFlag));

        //
        // In case of OutOfBoxExperience(OOBE) the SystemSetupInProgress key is set as well.
        // However, we want to run spooler in normal mode in this case. So, if we find that
        // OOBE is running we are going to reset dwUpgradeFlag to zero.
        //
        if (dwUpgradeFlag)
        {
            DWORD dwUpgradeInProgFlag   = 0;
            DWORD dwMiniSetupInProgFlag = 0;

            cbData = sizeof(dwUpgradeInProgFlag);

            Status = RegQueryValueEx(hKey,
                                     szUpgradeInProgKey,
                                     NULL,
                                     NULL,
                                     (LPBYTE)&dwUpgradeInProgFlag,
                                     &cbData);

            if (Status == ERROR_SUCCESS)
            {
                cbData = sizeof(dwMiniSetupInProgFlag);

                Status = RegQueryValueEx(hKey,
                                         szMiniSetupInProgKey,
                                         NULL,
                                         NULL,
                                         (LPBYTE)&dwMiniSetupInProgFlag,
                                         &cbData);
            }
            //
            // If we successfully read all the registry keys, and the minisetup flag is 
            // not set  and the upgrade flag is set. It means that OOBE is running, so we
            // want to run spooler in normal mode.
            //
            if (Status == ERROR_SUCCESS && !dwMiniSetupInProgFlag && dwUpgradeInProgFlag)
            {
                dwUpgradeFlag = 0;
            }
        }

        RegCloseKey(hKey);
    }



    // Setup machine names
    szMachineName[0] = szMachineName[1] = L'\\';

    i = MAX_COMPUTERNAME_LENGTH + 1;

    if (!GetComputerName(szMachineName+2, &i)) {
        DBGMSG(DBG_ERROR, ("Failed to get computer name %d\n", GetLastError()));
        ExitProcess(0);
    }

    if (!BuildOtherNamesFromMachineName(&ppszOtherNames, &cOtherNames)) {
        DBGMSG(DBG_TRACE, ("Failed to determine other machine names %d\n", GetLastError()));
    }


    if (!(pLocalProvidor = InitializeProvidor(szLocalSplDll, NULL))) {

        DBGMSG(DBG_WARN, ("Failed to initialize local print provider, error %d\n", GetLastError() ));

        ExitProcess(0);
    }

    pProvidor = pLocalProvidor;

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryProvidors, 0,
                          KEY_READ, &hKey);

    if (Status == ERROR_SUCCESS) {

        //
        // Now query szCacheSize for the RouterCacheSize value
        // if there is no RouterCacheSize replace it with the
        // default value.
        //
        RouterCacheSize = ROUTERCACHE_DEFAULT_MAX;

        cbData = sizeof(dwCacheSize);

        Status = RegQueryValueEx(hKey,
                                 szRouterCacheSize,
                                 NULL, NULL,
                                 (LPBYTE)&dwCacheSize,
                                 &cbData);

        if (Status == ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("RouterCacheSize = %d\n", dwCacheSize));

            if (dwCacheSize > 0) {
                RouterCacheSize = dwCacheSize;
            }
        }

        if ((RouterCacheTable = AllocSplMem(RouterCacheSize *
                                            sizeof(ROUTERCACHE))) == NULL) {

            DBGMSG(DBG_ERROR, ("Error: Cannot create RouterCache Table\n"));
            RouterCacheSize = 0;
        }

        //
        // Now query szRegistryProvidors for the Order value
        // if there is no Order value for szRegistryProvidors
        // RegQueryValueEx will return ERROR_FILE_NOT_FOUND
        // if that's the case, then quit, because we have
        // no providors to initialize.
        //
        Status = RegQueryValueEx(hKey, szOrder, NULL, NULL,
                                (LPBYTE)NULL, &dwRequired);

        //
        // If RegQueryValueEx returned ERROR_SUCCESS, then
        // call it again to determine how many bytes were
        // allocated. Note, if Order does exist, but it has
        // no data then dwReturned will be zero, in which
        // don't allocate any memory for it, and don't
        // bother to call RegQueryValueEx a second time.
        //
        if (Status == ERROR_SUCCESS) {
            if (dwRequired != 0) {
                lpMem = (LPWSTR) AllocSplMem(dwRequired);
                if (lpMem == NULL) {

                    Status = GetLastError();

                } else {
                    Status = RegQueryValueEx(hKey, 
                                             szOrder, 
                                             NULL, 
                                             NULL,
                                             (LPBYTE)lpMem, 
                                             &dwRequired);
                }
            }
        }
        if (Status == ERROR_SUCCESS) {

            cbDll = sizeof(Dll);

            pProvidor = pLocalProvidor;

            // Now parse the string retrieved from \Providors{Order = "....."}
            // Remember each string is separated by a null terminator char ('\0')
            // and the entire array is terminated by two null terminator chars

            // Also remember, that if there was no data in Order, then
            // psz = lpMem = NULL, and we have nothing to parse, so
            // break out of the while loop, if psz is NULL as well

            psz =  lpMem;

            while (psz && *psz) {

               //
               // Truncate the provider name if it does not fit in
               // the stack allocated buffer.
               // 
               lstrcpyn(ProvidorName, psz, COUNTOF(ProvidorName));

               psz = psz + lstrlen(psz) + 1; // skip (length) + 1
                                             // lstrlen returns length sans '\0'

               if (RegOpenKeyEx(hKey, ProvidorName, 0, KEY_READ, &hKey1)
                                                            == ERROR_SUCCESS) {

                    cbDll = sizeof(Dll);

                    if (RegQueryValueEx(hKey1, 
                                        L"Name", 
                                        NULL, 
                                        NULL,
                                        (LPBYTE)Dll, 
                                        &cbDll) == ERROR_SUCCESS)
                    {
                        if((StrNCatBuff(szFullName,
                                       COUNTOF(szFullName),
                                       szRegistryProvidors,
                                       L"\\",
                                       ProvidorName,
                                       NULL)==ERROR_SUCCESS))
                        {
                             if (pProvidor->pNext = InitializeProvidor(Dll, szFullName))
                             {
     
                                 pProvidor = pProvidor->pNext;
                             }
                        }
                    } //close RegQueryValueEx

                    RegCloseKey(hKey1);

                } // closes RegOpenKeyEx on ERROR_SUCCESS

            } //  end of while loop parsing REG_MULTI_SZ

            // Now free the buffer allocated for RegQuery
            // (that is if you have allocated - if dwReturned was
            // zero, then no memory was allocated (since none was
            // required (Order was empty)))

            if (lpMem) {
                FreeSplMem(lpMem);
            }

        }   //  closes RegQueryValueEx on ERROR_SUCCESS

        RegCloseKey(hKey);
    }

    //
    // We are now initialized!
    //
    SetEvent(hEventInit);
    Initialized=TRUE;

    //
    // Register for PnP events we care about
    //
    RegisterForPnPEvents();

    bRet = SpoolerInitAll();

    //
    // Free the passed in router parameters.
    //
    FreeSplMem(pRouterParams);

    // When we return this thread goes away

    //
    // NOTE-NOTE-NOTE-NOTE-NOTE KrishnaG  12/22/93
    // This thread should go away, however the HP Monitor relies on this
    // thread. HPMon calls the initialization function on this thread which
    // calls an asynchronous receive for data. While the data itself is
    // picked up by hmon!_ReadThread, if the thread which initiated the
    // receive goes away, we will not be able to receive the data.
    //

    //
    // Instead of sleeping infinite, let's use it to for providors that
    // just want FFPCNs to poll.  This call never returns.
    //

    HandlePollNotifications();
    return bRet;
}


VOID
WaitForSpoolerInitialization(
    VOID)
{
    HANDLE hPhase2Init;
    HANDLE hImpersonationToken = NULL;
    
    if (!Initialized)
    {
        //
        // Impersonate the spooler service token
        //
        hImpersonationToken = RevertToPrinterSelf();
        
        //
        // Start phase 2 initialization. hPhase2Init may set multiple times, but that
        // is OK since there is only 1 thread waiting once on this event.
        //
        hPhase2Init = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"RouterPreInitEvent");

        if (hPhase2Init == NULL)
        {
            //
            // Fail if the event is not created
            //
            DBGMSG(DBG_ERROR, ("Failed to create Phase2Init Event in WaitForSpoolerInitialization, error %d\n", GetLastError()));
            ExitProcess(0);
        }
        SetEvent(hPhase2Init);
        CloseHandle(hPhase2Init);

        //
        // Revert back to the client token
        //
        if (hImpersonationToken)
        {  
            if (!ImpersonatePrinterClient(hImpersonationToken))
            {
                DBGMSG(DBG_ERROR, ("Failed to impersonate the client, error %d\n", GetLastError()));
                ExitProcess(0);
            }
        }

        WaitForSingleObject(hEventInit, INFINITE);
    }
}

VOID
ShutDownProvidor(
    LPPROVIDOR pProvidor)
{
    if (pProvidor->PrintProvidor.fpShutDown) {

        (*pProvidor->PrintProvidor.fpShutDown)(NULL);
    }

    FreeSplStr(pProvidor->lpName);
    FreeLibrary(pProvidor->hModule);
    FreeSplMem(pProvidor);
    return;
}


VOID
SplShutDownRouter(
    VOID
    )
{
    DBGMSG(DBG_TRACE, ("SplShutDownRouter:\n"));

    //
    // WMI Trace Events. Unregisters spoolss from WMI.
    //
    WmiTerminateTrace();
}

BOOL
SplInitializeWinSpoolDrv(
    pfnWinSpoolDrv    pfnList)
{
    HANDLE  hWinSpoolDrv;

    // Check if the client side handles are available in fnClientSide
    if (!bWinspoolInitialized) {

       if (!(hWinSpoolDrv = LoadLibrary(TEXT("winspool.drv")))) {
           // Could not load the client side of the spooler
           return FALSE;
       }

       fnClientSide.pfnOpenPrinter   = (BOOL (*)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS))
                                        GetProcAddress( hWinSpoolDrv,"OpenPrinterW" );

       fnClientSide.pfnClosePrinter  = (BOOL (*)(HANDLE))
                                        GetProcAddress( hWinSpoolDrv,"ClosePrinter" );

       fnClientSide.pfnDocumentProperties = (LONG (*)(HWND, HANDLE, LPWSTR, PDEVMODE,
                                                      PDEVMODE, DWORD))
                                             GetProcAddress( hWinSpoolDrv,"DocumentPropertiesW" );

       fnClientSide.pfnDevQueryPrint = (BOOL (*)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD))
                                        GetProcAddress( hWinSpoolDrv,"SpoolerDevQueryPrintW" );

       fnClientSide.pfnPrinterEvent  = (BOOL (*)(LPWSTR, INT, DWORD, LPARAM, DWORD *))
                                        GetProcAddress( hWinSpoolDrv,"SpoolerPrinterEvent" );

       fnClientSide.pfnLoadPrinterDriver  = (HANDLE (*)(HANDLE))
                                             GetProcAddress( hWinSpoolDrv,
                                                             (LPCSTR)MAKELPARAM( 212, 0 ));

       fnClientSide.pfnRefCntLoadDriver  = (HANDLE (*)(LPWSTR, DWORD, DWORD, BOOL))
                                            GetProcAddress( hWinSpoolDrv,
                                                            (LPCSTR)MAKELPARAM( 213, 0 ));

       fnClientSide.pfnRefCntUnloadDriver  = (BOOL (*)(HANDLE, BOOL))
                                              GetProcAddress( hWinSpoolDrv,
                                                              (LPCSTR)MAKELPARAM( 214, 0 ));

       fnClientSide.pfnForceUnloadDriver  = (BOOL (*)(LPWSTR))
                                           GetProcAddress( hWinSpoolDrv,
                                                           (LPCSTR)MAKELPARAM( 215, 0 ));

       if ( fnClientSide.pfnOpenPrinter        == NULL ||
            fnClientSide.pfnClosePrinter       == NULL ||
            fnClientSide.pfnDocumentProperties == NULL ||
            fnClientSide.pfnPrinterEvent       == NULL ||
            fnClientSide.pfnDevQueryPrint      == NULL ||
            fnClientSide.pfnLoadPrinterDriver  == NULL ||
            fnClientSide.pfnRefCntLoadDriver   == NULL ||
            fnClientSide.pfnRefCntUnloadDriver == NULL ||
            fnClientSide.pfnForceUnloadDriver  == NULL ) {

             FreeLibrary(hWinSpoolDrv);

             return FALSE;
       }

       // Use these pointers for future calls to SplInitializeWinspoolDrv
       bWinspoolInitialized = TRUE;
    }

    pfnList->pfnOpenPrinter        = fnClientSide.pfnOpenPrinter;
    pfnList->pfnClosePrinter       = fnClientSide.pfnClosePrinter;
    pfnList->pfnDocumentProperties = fnClientSide.pfnDocumentProperties;
    pfnList->pfnDevQueryPrint      = fnClientSide.pfnDevQueryPrint;
    pfnList->pfnPrinterEvent       = fnClientSide.pfnPrinterEvent;
    pfnList->pfnLoadPrinterDriver  = fnClientSide.pfnLoadPrinterDriver;
    pfnList->pfnRefCntLoadDriver   = fnClientSide.pfnRefCntLoadDriver;
    pfnList->pfnRefCntUnloadDriver = fnClientSide.pfnRefCntUnloadDriver;
    pfnList->pfnForceUnloadDriver  = fnClientSide.pfnForceUnloadDriver;

    return TRUE;
}


BOOL
SpoolerHasInitialized(
    VOID
    )
{
    return Initialized;
}

/*++

Routine Name

    SplPowerEvent

Routine Description:

    Checks if the spooler is ready for power management events like hibernation/stand by.
    
Arguments:

    Event - power management event
    
Return Value:

    TRUE  - the spooler allowd the system to be powered down
    FALSE - the spooler denies the request for powering down
    
--*/
BOOL
SplPowerEvent(
    DWORD Event
    )
{
    BOOL bRet = TRUE;

    //
    // We need the router to be completely initialized and having loaded
    // all print providers in order to check if we can allow powering down
    // the system
    //
    if (SpoolerHasInitialized()) 
    {
        HMODULE   hLib = NULL;
        typedef BOOL (*PACPIFUNC)(DWORD);
        PACPIFUNC pfn;
        
        if ((hLib = LoadLibrary(L"localspl.dll")) &&
            (pfn  = (PACPIFUNC)GetProcAddress(hLib, "SplPowerEvent"))) 
        {
            bRet = (*pfn)(Event);
        }
        else
        {
            bRet = FALSE;
        }
        
        if (hLib) 
        {
            FreeLibrary(hLib);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\local.h ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Header file for Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matt Feton (MattFe) Jan 17 1995 add separate heaps

--*/


#define ONEDAY  60*24

#define MIN_UNC_PRINTER_NAME 5

// Timeout to start spooler's phase 2 initialization in milliseconds
#define SPOOLER_START_PHASE_TWO_INIT 2*60*1000

#define offsetof(type, identifier) (DWORD)(&(((type*)0)->identifier))

extern  char  *szDriverIni;
extern  char  *szDriverFileEntry;
extern  char  *szDriverDataFile;
extern  char  *szDriverConfigFile;
extern  char  *szDriverDir;
extern  char  *szPrintProcDir;
extern  char  *szPrinterDir;
extern  char  *szPrinterIni;
extern  char  *szAllShadows;
extern  char  *szNullPort;
extern  char  *szComma;

extern  HANDLE   hHeap;
extern  HANDLE   HeapSemaphore;
extern  HANDLE   InitSemaphore;
extern  BOOL     Initialized;
extern  CRITICAL_SECTION    SpoolerSection;
extern  DWORD    gbFailAllocs;
extern  PrintSpoolerServerExports   *gpServerExports;

BOOL
LocalInitialize(
   VOID
);

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

LPVOID
DllAllocSplMem(
    DWORD cb
);

BOOL
DllFreeSplMem(
   LPVOID pMem
);

LPVOID
DllReallocSplMem(
   LPVOID lpOldMem,
   DWORD cbOld,
   DWORD cbNew
);

BOOL
DllFreeSplStr(
   LPWSTR lpStr
);

BOOL
ValidateReadPointer(
    PVOID pPoint,
    ULONG Len
);

BOOL
ValidateWritePointer(
    PVOID pPoint,
    ULONG Len
);

BOOL
DeleteSubKeyTree(
    HKEY ParentHandle,
    WCHAR SubKeyName[]
);

LPWSTR
AppendOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

LPWSTR
RemoveOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

LPPROVIDOR
InitializeProvidor(
   LPWSTR   pProvidorName,
   LPWSTR   pFullName
);

VOID
WaitForSpoolerInitialization(
    VOID
);

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
);


BOOL
MyUNCName(
    LPWSTR   pNameStart
);


BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszMyOtherNames,
    DWORD   *cOtherNames
);

BOOL
bCompatibleDevMode(
    PPRINTHANDLE pPrintHandle,
    PDEVMODE pDevModeBase,
    PDEVMODE pDevModeNew
    );



LPWSTR
FormatPrinterForRegistryKey(
    LPCWSTR pSource,      /* The string from which backslashes are to be removed. */
    LPWSTR  pScratch,     /* Scratch buffer for the function to write in;     */
    DWORD   cchScratchLen /* must be at least as long as pSource.             */
    );

LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,      /* The string from which backslashes are to be added. */
    LPWSTR pScratch,     /* Scratch buffer for the function to write in;     */
    DWORD  cchScratchLen /* must be at least as long as pSource.             */
    );



PWSTR
AutoCat(
    PCWSTR pszInput,
    PCWSTR pszCat
);

BOOL
bGetDevModePerUserEvenForShares(
    IN  HKEY hKeyUser, OPTIONAL
    IN  LPCWSTR pszPrinter,
    OUT PDEVMODE *ppDevMode
    );

DWORD
GetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN LPDWORD pValue
    );

DWORD
SetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN DWORD   Value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\job.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    job.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
SetJobW(
    HANDLE hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command)

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetJob) (pPrintHandle->hPrinter,
                                                 JobId, Level, pJob, Command);
}

BOOL
GetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pJob == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetJob)
                    (pPrintHandle->hPrinter, JobId, Level, pJob,
                     cbBuf, pcbNeeded);
}

BOOL
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pJob == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumJobs)(pPrintHandle->hPrinter,
                                               FirstJob, NoJobs,
                                               Level, pJob, cbBuf,
                                               pcbNeeded, pcReturned);
}



BOOL
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pAddJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pAddJob == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpAddJob) (pPrintHandle->hPrinter,
                                                     Level, pAddJob, cbBuf,
                                                     pcbNeeded);
}

BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpScheduleJob) (pPrintHandle->hPrinter,
                                                      JobId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\memory.c ===
/*++


Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994


Revision History:

    Matthew Felton  (MattFe) Jan 21 1995
    Add Failure Count

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
SetAllocFailCount(
    HANDLE   hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
}


LPVOID
DllAllocSplMem(
    DWORD cbAlloc
    )

/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    PVOID pvMemory;

    pvMemory = AllocMem( cbAlloc );

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}

BOOL
DllFreeSplMem(
    LPVOID pMem
    )
{
    FreeMem( pMem );
    return TRUE;
}

LPVOID
ReallocSplMem(
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    LPVOID pNewMem;

    pNewMem=AllocSplMem(cbNew);

    if (pOldMem && pNewMem) {

        if (cbOld) {
            CopyMemory( pNewMem, pOldMem, min(cbNew, cbOld));
        }
        FreeSplMem(pOldMem);
    }
    return pNewMem;
}

BOOL
DllFreeSplStr(
    LPWSTR pStr
    )
{
    return pStr ?
               FreeSplMem(pStr) :
               FALSE;
}

LPWSTR
AllocSplStr(
    LPCWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}

BOOL
ReallocSplStr(
    LPWSTR *ppStr,
    LPCWSTR pStr
    )
{
    LPWSTR pNewStr;

    pNewStr = AllocSplStr(pStr);

    if( pStr && !pNewStr ){
        return FALSE;
    }

    FreeSplStr(*ppStr);
    *ppStr = pNewStr;

    return TRUE;
}



LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    LPBYTE pRet = NULL;
    
    //
    // Make sure all our parameters are valid.
    // This will return NULL if one of the parameters is NULL.
    //
    if (pSource && pDest && DestOffsets && pEnd) {
        
        WORD_ALIGN_DOWN(pEnd);

        while (*DestOffsets != -1) {
            if (*pSource) {
                cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
                pEnd -= cbStr;
                CopyMemory( pEnd, *pSource, cbStr);
                *(LPWSTR UNALIGNED *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
            } else {
                *(LPWSTR UNALIGNED *)(pDest+*DestOffsets)=0;
            }
            pSource++;
            DestOffsets++;
        }
    
        pRet = pEnd;
    }
    return pRet;
}



LPVOID
AlignRpcPtr (
    LPVOID  pBuffer,
    LPDWORD pcbBuf
    )
/*++

Routine Description:

    This routine is called on the server side for methods using custom marshalling. 
    These methods cheat on RPC by asking for LPBYTE pointers and using the buffer as 
    pointer to structures. The LPBYTE pointer that RPC sends us can be unaligned.
    Here is where we take data missalignments.
    The reason the size of the buffer is aligned down is because providers will use
    the end of the buffer as a pEnd = pBuffer + cbBuf pointer. 
    If cbBuf is an unaligned value, pEnd will be unaligned as well. This will generate unaligned 
    pointers inside the structure as well.

Arguments:

    pBuffer - Pointer to a buffer
    pcbBuf  - Pointer to a DWORD representing the size of the buffer


Return Value:

    Aligned pointer

--*/
{
    LPVOID pAligned = NULL;
    
    pAligned = (LPVOID)ALIGN_PTR_UP(pBuffer);

    *pcbBuf = (DWORD)ALIGN_DOWN(*pcbBuf, ULONG_PTR);

    if (pAligned != pBuffer)
    {
        pAligned = AllocSplMem(*pcbBuf);
    }

    return pAligned;

}

VOID
UndoAlignRpcPtr (
    LPVOID  pBuffer,
    LPVOID  pAligned,
    SIZE_T  cbSize,
    LPDWORD pcbNeeded
    )
/*++

Routine Description:

    This routine is called on the server side for methods using custom marshalling. 
    These methods cheat on RPC by asking for LPBYTE pointers and using the buffer as 
    pointer to structures. The LPBYTE pointer that RPC sends us can be unaligned.
    Here is where we take data missalignments.
    This routine moves data between pointers if they are different. 
    Free pSource pointer after copy data to pDestination.
    pcbNeeded is adjusted evey time. The providor could request a a buffer size which is unaligned.
    We always align up the needed size, no matter the provider.
    
Arguments:

    pDestination - Pointer to a destination buffer
    pSource      - Pointer to a source buffer
    cbSize       - Number of bites

Return Value:

--*/
{
    //
    // pBuffer and pAligned will be either both NULL or both not NULL. See AlignRpcPtr.
    //
    if (pBuffer != pAligned)
    {
        //
        // The way AlignRpcPtr and UndoAlignRpcPtr use the pBuffer and pAligned is 
        // very subtle and confusing. UndoAlignRpcPtr doesn't offer any indication
        // that it won't access NULL pointers in CopyMemory. That's why the if 
        // statement is here, though not required.
        //
        if (pBuffer && pAligned) 
        {
            CopyMemory(pBuffer, pAligned, cbSize);
        }

        FreeSplMem(pAligned);
    }

    if (pcbNeeded)
    {
        *pcbNeeded = (DWORD)ALIGN_UP(*pcbNeeded, ULONG_PTR);        
    }
}


LPVOID
AlignKMPtr (
	LPVOID	pBuffer,
    DWORD   cbBuf
    )
/*++

Routine Description:

    This routine is called for Do* methods inside splkernl.c
    The buffer used by spooler in user mode is a pointer inside 
    The message send by GDI from kernel mode. This pointer can be unaligned.
    This method duplicates the pBuffer if unaligned.

    !!! All Do* methods could have this problem is the pointer is unaligned.
    Even so, not all of them fault. To minimize the regression chances and code pollution,
    I only call this functions for the methods where I coulds see missalignent faults.!!!

Arguments:

    pBuffer - Pointer to a buffer
    bBuf    - Size of the buffer

Return Value:

    Aligned pointer

--*/
{
    LPVOID pAligned = NULL;
    
    pAligned = (LPVOID)ALIGN_PTR_UP(pBuffer);

    if (pAligned != pBuffer)
    {
        pAligned = AllocSplMem(cbBuf);

        if (pAligned) 
        {
            CopyMemory( pAligned, pBuffer, cbBuf);
        }
    }

    return pAligned;

}

VOID
UndoAlignKMPtr (
    LPVOID  pBuffer,
    LPVOID  pAligned
    )
/*++

Routine Description:

    This method frees the duplicated memory allocated in the case where the 
    pointer is misaligned.    

Arguments:

    pBuffer     - Pointer to potentially unaligned buffer
    pAligned    - Pointer to an aligned buffer; pAligned is a copy of pBuffer    

Return Value:

--*/
{
    if (pAligned != pBuffer)
    {
        FreeSplMem(pBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\monitor.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    monitor.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

BOOL
GetPortInfo2UsingPortInfo1(
    LPPROVIDOR      pProvidor,
    LPWSTR          pName,
    LPBYTE          pPorts,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded,
    LPDWORD         pcReturned
    )
{

    BOOL            bRet;
    LPPORT_INFO_1   pPortInfo1;
    LPPORT_INFO_2   pPortInfo2;
    DWORD           cReturned;

    bRet = (*pProvidor->PrintProvidor.fpEnumPorts) (pName, 1, pPorts, cbBuf,
                                          pcbNeeded, pcReturned);

    if ( !bRet ) {

        //
        // This is the upperbound
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            *pcbNeeded += (*pcbNeeded / sizeof(PORT_INFO_1)) *
                                  (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));
    } else {

        *pcbNeeded += *pcReturned * (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));


        if ( *pcbNeeded <= cbBuf ) {

            cReturned = *pcReturned;
            while ( cReturned-- ) {

                pPortInfo1 = (LPPORT_INFO_1) (pPorts + cReturned * sizeof(PORT_INFO_1));
                pPortInfo2 = (LPPORT_INFO_2) (pPorts + cReturned * sizeof(PORT_INFO_2));

                pPortInfo2->pPortName    = pPortInfo1->pName;
                pPortInfo2->pMonitorName = NULL;
                pPortInfo2->pDescription = NULL;
                pPortInfo2->fPortType    = 0;
                pPortInfo2->Reserved     = 0;
            }
        } else {

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            *pcReturned = 0;
            bRet = FALSE;
        }
    }

    return bRet;
}


BOOL
EnumPortsW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pPort,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    DWORD   cReturned, TotalcbNeeded;
    DWORD   Error = ERROR_SUCCESS, TempError = ERROR_SUCCESS;
    PROVIDOR *pProvidor;
    DWORD   BufferSize=cbBuf;
    BOOL bPartialSuccess = FALSE;
    DWORD rc;

    if ((pPort == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    TotalcbNeeded = cReturned = 0;

    while (pProvidor) {

        *pcReturned = 0;
        *pcbNeeded = 0;

        //
        // CLS
        //
        rc = (*pProvidor->PrintProvidor.fpEnumPorts)(pName, Level,
                                                     pPort, BufferSize,
                                                     pcbNeeded, pcReturned);

        if( !rc ){

            TempError = GetLastError();

            //
            // Netware providor returns INVALID_NAME and not INVALID_LEVEL
            // So if Level = 2 and error always try a Level 1 query
            //
            if ( Level == 2 &&
                 ( TempError == ERROR_INVALID_LEVEL ||
                   TempError == ERROR_INVALID_NAME) ) {

                TempError = ERROR_SUCCESS;
                if ( !GetPortInfo2UsingPortInfo1(pProvidor,
                                                 pName,
                                                 pPort,
                                                 BufferSize,
                                                 pcbNeeded,
                                                 pcReturned) ) {

                    TempError = GetLastError();
                } else {

                    bPartialSuccess = TRUE;
                }
            }

            //
            // HACK FIX:
            //
            // NT 3.51 returns bogus pcbNeeded/pcReturned data if the
            // Level is invalid (i.e., PORT_INFO_2).  So we should zero
            // these vars if the level is bad, otherwise the error returned
            // is ERROR_INSUFFICIENT_BUFFER.
            //
            if ( TempError ) {

                *pcReturned = 0;
                Error = TempError;
                if ( Error != ERROR_INSUFFICIENT_BUFFER )
                    *pcbNeeded = 0;
            }

        } else {

            bPartialSuccess = TRUE;
        }

        cReturned += *pcReturned;

        switch (Level) {

            case 1:
                pPort += *pcReturned * sizeof(PORT_INFO_1);
                break;

            case 2:
                pPort += *pcReturned * sizeof(PORT_INFO_2);
                break;

            default:
                DBGMSG(DBG_ERROR,
                       ("EnumPortsW: invalid level %d", Level));
                SetLastError(ERROR_INVALID_LEVEL);
                return FALSE;
        }

        if (*pcbNeeded <= BufferSize)
            BufferSize -= *pcbNeeded;
        else
            BufferSize = 0;

        TotalcbNeeded += *pcbNeeded;

        //
        // CLS
        //
        // Stop routing if the provider tells us to.
        //
        if( rc == ROUTER_STOP_ROUTING ){
            break;
        }

        pProvidor = pProvidor->pNext;
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cReturned;

    if (TotalcbNeeded > cbBuf) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    } else if (bPartialSuccess) {
        SetLastError(ERROR_SUCCESS);
    } else if (Error != ERROR_SUCCESS) {
        SetLastError(Error);
        return FALSE;
    }

    return TRUE;
}

BOOL
EnumMonitorsW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pMonitor,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    DWORD   cReturned, cbStruct, TotalcbNeeded;
    DWORD   Error;
    PROVIDOR *pProvidor;
    DWORD   BufferSize=cbBuf;
    BOOL bPartialSuccess = FALSE;
    DWORD rc;

    if ((pMonitor == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    switch (Level) {

    case 1:
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
         DBGMSG(DBG_ERROR,
                ("EnumMonitorsW: invalid level %d", Level));
         SetLastError(ERROR_INVALID_LEVEL);
         return FALSE;
    }

    pProvidor = pLocalProvidor;

    TotalcbNeeded = cReturned = 0;

    Error = ERROR_SUCCESS;

    while (pProvidor) {

        *pcReturned = 0;

        *pcbNeeded = 0;

        rc = (*pProvidor->PrintProvidor.fpEnumMonitors) (pName,
                                                         Level,
                                                         pMonitor,
                                                         BufferSize,
                                                         pcbNeeded,
                                                         pcReturned);

        cReturned += *pcReturned;

        pMonitor += *pcReturned * cbStruct;

        if (*pcbNeeded <= BufferSize)
            BufferSize -= *pcbNeeded;
        else
            BufferSize = 0;

        TotalcbNeeded += *pcbNeeded;

        if( rc == ROUTER_UNKNOWN ){

            Error = GetLastError();

        } else {

            bPartialSuccess = TRUE;

            if( rc == ROUTER_STOP_ROUTING ){

                break;
            }
        }

        pProvidor = pProvidor->pNext;
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cReturned;

    if (TotalcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    } else if (bPartialSuccess) {
        SetLastError(ERROR_SUCCESS);
    } else if (Error != ERROR_SUCCESS) {
        SetLastError(Error);
        return FALSE;
    }

    return TRUE;
}




BOOL
AddPortExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pBuffer,
    LPWSTR  pMonitorName
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (pProvidor->PrintProvidor.fpAddPortEx) {
            if ((*pProvidor->PrintProvidor.fpAddPortEx) (pName, Level, pBuffer, pMonitorName)) {
                return TRUE;
            }
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}



BOOL
AddPortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
)
{
    LPPROVIDOR  pProvidor;
    DWORD       Error = NO_ERROR;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!pProvidor->PrintProvidor.fpAddPort)
            break;

        if ((*pProvidor->PrintProvidor.fpAddPort)(pName, hWnd, pMonitorName)) {

            return TRUE;

        } else {

            DWORD LastError = GetLastError();

            /* If the function is not supported, don't return yet
             * in case there's a print provider that does support it.
             */
            if (LastError == ERROR_NOT_SUPPORTED)
                Error = ERROR_NOT_SUPPORTED;

            else if (LastError != ERROR_INVALID_NAME)
                return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(Error == NO_ERROR ? ERROR_INVALID_PARAMETER : Error);

    return FALSE;
}

BOOL
ConfigurePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    LPPROVIDOR  pProvidor;
    DWORD       Error = NO_ERROR;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!pProvidor->PrintProvidor.fpConfigurePort)
            break;

        if ((*pProvidor->PrintProvidor.fpConfigurePort) (pName, hWnd, pPortName)) {

            return TRUE;

        } else {

            DWORD LastError = GetLastError();

            /* If the function is not supported, don't return yet
             * in case there's a print provider that does support it.
             */
            if (LastError == ERROR_NOT_SUPPORTED)
                Error = ERROR_NOT_SUPPORTED;

            else if ((LastError != ERROR_INVALID_NAME) && (LastError != ERROR_UNKNOWN_PORT))
                return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(Error == NO_ERROR ? ERROR_INVALID_PARAMETER : Error);

    return FALSE;
}

BOOL
DeletePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    LPPROVIDOR  pProvidor;
    DWORD       Error = NO_ERROR;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!pProvidor->PrintProvidor.fpDeletePort)
            break;

        if ((*pProvidor->PrintProvidor.fpDeletePort) (pName, hWnd, pPortName)) {

            return TRUE;

        } else {

            DWORD LastError = GetLastError();

            /* If the function is not supported, don't return yet
             * in case there's a print provider that does support it.
             */
            if (LastError == ERROR_NOT_SUPPORTED)
                Error = ERROR_NOT_SUPPORTED;

            else if ((LastError != ERROR_INVALID_NAME) && (LastError != ERROR_UNKNOWN_PORT))
                return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(Error == NO_ERROR ? ERROR_INVALID_PARAMETER : Error);

    return FALSE;
}


BOOL
AddMonitorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddMonitor) (pName, Level, pMonitorInfo)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
DeleteMonitorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpDeleteMonitor)
                                (pName, pEnvironment, pMonitorName)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
SetPortW(
    LPWSTR  pszName,
    LPWSTR  pszPortName,
    DWORD   dwLevel,
    LPBYTE  pPortInfo
    )
{
    LPPROVIDOR  pProvidor;
    DWORD       dwLastError;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ( (*pProvidor->PrintProvidor.fpSetPort)(pszName,
                                                   pszPortName,
                                                   dwLevel,
                                                   pPortInfo) ) {

            return TRUE;
        }

        dwLastError = GetLastError();
        if ( dwLastError != ERROR_INVALID_NAME    &&
             dwLastError != ERROR_UNKNOWN_PORT    &&
             dwLastError != ERROR_NOT_SUPPORTED ) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\ncclusfunc.cxx ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    NCclusfunc.cxx

Abstract:

    This module provides several utility functions for cluster related operations.

Author:

    Felix Maxa (AMaxa) 16 May 2001

Revision History:

--*/

#include "precomp.h"
#include <clusapi.h>
#include "ncnamecache.hxx"
#include "ncclusapi.hxx"    

using namespace NCoreLibrary;

LPCWSTR g_pszIPAddressResource = L"IP Address";
LPCWSTR g_pszIPAddressProperty = L"Address";

/*++

Name:

    ClusResControl

Description:

    Helper function. Encapsulates a call to ClusterResourceControl. The function
    allocates a buffer. Upon success, the caller nedds to free the buffer using
    delete [].
    
Arguments:

    ClusterAPI      - reference to object exposing cluster APIs
    hResource       - handle to cluster resource
    ControlCode     - control code for ClusterResourceControl
    ppBuffer        - pointer to address where to store byte array
    pcBytesReturned - number of bytes returned by ClusterResourceControl (not
                      necessarily the number of byes allocated for *ppBuffer)

Return Value:

    S_OK - success. ppBuffer can be used and must be freed using delete []
    any other HRESULT - failure

--*/
HRESULT
ClusResControl(
    IN  TClusterAPI&   ClusterAPI,
    IN  HRESOURCE      hResource,
    IN  DWORD          ControlCode,
    OUT BYTE         **ppBuffer,
    IN  DWORD         *pcBytesReturned OPTIONAL
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = ppBuffer ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        DWORD Error;
        DWORD cbBuffer = kBufferAllocHint;
        DWORD cbNeeded = 0;

        *ppBuffer = new BYTE[cbBuffer];

        Error = *ppBuffer ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;

        if (Error == ERROR_SUCCESS)
        {
            Error = ClusterAPI.pfnClusterResourceControl(hResource,
                                                         NULL, 
                                                         ControlCode,
                                                         NULL,
                                                         0,
                                                         *ppBuffer,
                                                         cbBuffer,
                                                         &cbNeeded);

            if (Error == ERROR_MORE_DATA) 
            {
                cbBuffer = cbNeeded;

                delete [] *ppBuffer;

                *ppBuffer = new BYTE[cbBuffer];

                Error = *ppBuffer ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
                
                if (Error == ERROR_SUCCESS) 
                {
                    Error = ClusterAPI.pfnClusterResourceControl(hResource,
                                                                 NULL, 
                                                                 ControlCode,
                                                                 NULL,
                                                                 0,
                                                                 *ppBuffer,
                                                                 cbBuffer,
                                                                 &cbNeeded);
                }
            }

            if (Error != ERROR_SUCCESS)
            {
                delete [] *ppBuffer;

                *ppBuffer = NULL;
                
                cbNeeded = 0;
            }

            if (pcBytesReturned)
            {
                *pcBytesReturned = cbNeeded;
            }
        }

        hRetval DBGCHK = HRESULT_FROM_WIN32(Error);        
    }

    return hRetval;
}

/*++

Name:

    GetResourceIPAddress

Description:

    Helper function used in GetClusterIPAddresses. Checks if a cluster resource is an IP address
    reosurce, in which case it retrieve the IP associated.
    
Arguments:

    ClusterAPI  - reference to object exposing cluster APIs
    hCluster    - handle retrieved via OpenCluster
    pszResource - resource name
    ppszAddress - pointer to where to receive string representing IP address

Return Value:

    S_OK - success. ppszAddress may still be NULL on success. success means
           either the reosurce is not IP resource or it is IP resource and 
           the ppszAddress is then not NULL. ppszAddress must be freed by caller
           using LocalFree.
    any other HRESULT - failure

--*/
HRESULT
GetResourceIPAddress(
    IN  TClusterAPI& ClusterAPI, 
    IN  HCLUSTER     hCluster, 
    IN  LPCWSTR      pszResource,
    OUT LPWSTR      *ppszAddress
    )
{
    HRESOURCE hResource;
    TStatusH  hRetval;
    
    hRetval DBGCHK = hCluster && pszResource && ppszAddress ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *ppszAddress = NULL;

        hResource = ClusterAPI.pfnOpenClusterResource(hCluster, pszResource);

        hRetval DBGCHK = hResource ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        BYTE *pResType = NULL;
        
        hRetval DBGCHK = ClusResControl(ClusterAPI,
                                        hResource,
                                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                        &pResType,
                                        NULL);

        if (SUCCEEDED(hRetval))
        {
            //
            // Check resource type. We are interested only in IP Address resources.
            //
            if (!_wcsicmp(reinterpret_cast<LPWSTR>(pResType), g_pszIPAddressResource)) 
            {
                LPWSTR  pszIPAddress = NULL;
                BYTE   *pResProp     = NULL;
                DWORD   cbResProp    = 0;
                
                //
                // Get all the private properties of the IP Address resource.
                //
                hRetval DBGCHK = ClusResControl(ClusterAPI,
                                                hResource,
                                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                                                &pResProp,
                                                &cbResProp);
                if (SUCCEEDED(hRetval)) 
                {
                    //
                    // Scan for the property indicating the IP address of the resource
                    //
                    DWORD Error = ClusterAPI.pfnResUtilFindSzProperty(pResProp, 
                                                                      cbResProp, 
                                                                      g_pszIPAddressProperty, 
                                                                      ppszAddress);                        

                    hRetval DBGCHK = HRESULT_FROM_WIN32(Error);
                }

                delete [] pResProp;
            }
        }

        delete [] pResType;
                
        ClusterAPI.pfnCloseClusterResource(hResource);                                                  
    }

    return hRetval;
}
   
/*++

Name:

    GetClusterIPAddresses

Description:

    Fill in a list with the IP addresses used by the cluster service running on the local machine.
    The function returns S_OK if the cluster service is not running. In that case the list will be
    empty.
    
Arguments:

    pClusterIPsList - pointer to list of TStringNodes.
    
Return Value:

    S_OK - success. pClusterIPsList will have 0 or more elements represeting each
           an IP address used by cluster resources
    any other HRESULT - failure

--*/
HRESULT
GetClusterIPAddresses(
    IN TList<TStringNode> *pClusterIPsList
    )
{
    TStatusH    hRetval;
    HCLUSTER    hCluster;
    TClusterAPI ClusterAPI;

    hRetval DBGCHK = pClusterIPsList ? ClusterAPI.Valid() : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        hCluster = ClusterAPI.pfnOpenCluster(NULL);

        //
        // If we cannot open the cluster then we return success to our caller. 
        //
        if (hCluster) 
        {
            HCLUSENUM hClusEnum;
    
            hClusEnum = ClusterAPI.pfnClusterOpenEnum(hCluster, CLUSTER_ENUM_RESOURCE);
    
            hRetval DBGCHK = hClusEnum ? S_OK : GetLastErrorAsHResult();
    
            if (SUCCEEDED(hRetval)) 
            {
                BOOL   bDone        = FALSE;
                DWORD  Index        = 0;
                LPWSTR pszName      = NULL;
                DWORD  cchName      = 0;
                DWORD  cchNeeded;
                DWORD  ResourceType;
    
                cchName = cchNeeded = kBufferAllocHint;
    
                //
                // We need to initialize pszName to a valid non NULL memory block, otherwise
                // CluserEnum AV's.
                //
                pszName = new WCHAR[cchName];
    
                hRetval DBGCHK = pszName ? S_OK : E_OUTOFMEMORY;
    
                for (Index = 0; !bDone && SUCCEEDED(hRetval);) 
                {
                    DWORD Error;
    
                    cchNeeded = cchName;
                    
                    Error = ClusterAPI.pfnClusterEnum(hClusEnum,
                                                      Index,   
                                                      &ResourceType,
                                                      pszName,  
                                                      &cchNeeded);
    
                    switch (Error)
                    {
                        case ERROR_SUCCESS:
                        {
                            LPWSTR pszAddress = NULL;
    
                            hRetval DBGCHK = GetResourceIPAddress(ClusterAPI, hCluster, pszName, &pszAddress);
    
                            if (pszAddress)
                            {
                                TStringNode *pNode = new TStringNode(pszAddress);
    
                                hRetval DBGCHK = pNode ? S_OK : E_OUTOFMEMORY;
    
                                if (SUCCEEDED(hRetval))
                                {
                                    hRetval DBGCHK = pNode->Valid();
                                }
    
                                if (SUCCEEDED(hRetval))
                                {
                                    hRetval DBGCHK = pClusterIPsList->AddAtHead(pNode);
    
                                    if (SUCCEEDED(hRetval))
                                    {
                                        //
                                        // List took ownership of pNode.
                                        //
                                        pNode = NULL;
                                    }
                                }
    
                                delete pNode;
    
                                LocalFree(pszAddress);
                            }
    
                            Index++;
    
                            break;
                        }
                        
                        case ERROR_MORE_DATA:
                        {
                            delete [] pszName;
        
                            //
                            // cchNeeded returns the number of characters needed, excluding the terminating NULL
                            //
                            cchName = cchNeeded + 1;
        
                            pszName = new WCHAR[cchName];
                            
                            if (!pszName) 
                            {
                                hRetval DBGCHK = E_OUTOFMEMORY;
                            }
        
                            break;
                        }
    
                        case ERROR_NO_MORE_ITEMS:
                        {
                            delete [] pszName;
                            bDone = TRUE;
                            break;
                        }
    
                        default:
                        {
                            delete [] pszName;
                            hRetval DBGCHK = HRESULT_FROM_WIN32(Error);
                        }
                    }
                }
                
                ClusterAPI.pfnClusterCloseEnum(hClusEnum);
            }
    
            ClusterAPI.pfnCloseCluster(hCluster);
        }
        else
        {
            DWORD Error = GetLastError();

            DBGMSG(DBG_WARN, ("\n\nGetClusterIPAddresses OpenCluster failed with Win32 error %u !!!\n\n", Error));
        }
    }
    
    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\ncclusapi.cxx ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    NCclusapi.cxx

Abstract:

    This module implements the methods for the TClusterAPI class. It provides
    several utility functions for cluster related operations.

Author:

    Felix Maxa (AMaxa) 16 May 2001

Revision History:

--*/

#include "precomp.h"
#include <clusapi.h>
#include <stddef.h>
#include "ncclusapi.hxx"    

CONST TClusterAPI::FUNCTIONMAP TClusterAPI::m_FunctionMap[] = 
{
    {offsetof(TClusterAPI, TClusterAPI::pfnResUtilFindSzProperty),  "ResUtilFindSzProperty",  TClusterAPI::kResUtil},
    {offsetof(TClusterAPI, TClusterAPI::pfnOpenCluster),            "OpenCluster",            TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnCloseCluster),           "CloseCluster",           TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnClusterOpenEnum),        "ClusterOpenEnum",        TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnClusterCloseEnum),       "ClusterCloseEnum",       TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnClusterEnum),            "ClusterEnum",            TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnOpenClusterResource),    "OpenClusterResource",    TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnCloseClusterResource),   "CloseClusterResource",   TClusterAPI::kClusApi},
    {offsetof(TClusterAPI, TClusterAPI::pfnClusterResourceControl), "ClusterResourceControl", TClusterAPI::kClusApi}
};

CONST LPCWSTR TClusterAPI::m_ClusterDlls[kEndMarker] = 
{
    L"clusapi.dll",
    L"resutils.dll"
};

/*++

Name:

    TClusterAPI::TClusterAPI

Description:

    CTOR. Use Valid() method to see if the CTOR did the work successfully.
    
Arguments:

    None.

Return Value:

    None.

--*/
TClusterAPI::
TClusterAPI(
    VOID 
    )
{
    DWORD   Index;
    HRESULT hr = S_OK;

    //
    // Initialize array of HMODULEs
    //
    for (Index = 0; Index < kEndMarker; Index++)
    {
        m_Libraries[Index] = NULL;
    }

    //
    // Load cluster libraries
    //
    for (Index = 0; Index < kEndMarker; Index++)
    {
        m_Libraries[Index] = LoadLibrary(m_ClusterDlls[Index]);

        if (!m_Libraries[Index]) 
        {
            hr = GetLastErrorAsHResult();

            break;
        }
    }

    //
    // Get addresses of functions
    //
    if (SUCCEEDED(hr)) 
    {
        for (Index = 0; Index < sizeof(m_FunctionMap) / sizeof(*m_FunctionMap); Index++) 
        {
            FARPROC *pFunc = reinterpret_cast<FARPROC *>(reinterpret_cast<LPBYTE>(this) + m_FunctionMap[Index].Offset);

            *pFunc = GetProcAddress(m_Libraries[m_FunctionMap[Index].eClusterDll], m_FunctionMap[Index].pszFunction);

            if (!*pFunc) 
            {
                hr = GetLastErrorAsHResult();

                break;
            }
        }
    }

    m_Valid = hr;
}

/*++

Name:

    TClusterAPI::~TClusterAPI

Description:

    DTOR.
    
Arguments:

    None.

Return Value:

    None.

--*/
TClusterAPI::
~TClusterAPI(
    VOID 
    )
{
    DWORD   Index;
    
    for (Index = 0; Index < kEndMarker; Index++)
    {
        if (m_Libraries[Index]) 
        {
            FreeLibrary(m_Libraries[Index]);
        }                                  
    }    
}

/*++

Name:

    TClusterAPI::Valid

Description:

    
    
Arguments:

    None.

Return Value:

    S_OK - the CTOR executed successfully
    other HRESULT - an error occurred during CTOR execution

--*/
HRESULT
TClusterAPI::
Valid(
    VOID 
    )
{
    return m_Valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include "precomp.h"
#pragma hdrstop

PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{

#if SPOOLER_HEAP
    return (PVOID)HeapAlloc( ghMidlHeap, HEAP_ZERO_MEMORY, NumBytes );
#else
    return AllocSplMem(NumBytes);
#endif

}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
#if SPOOLER_HEAP
    HeapFree( ghMidlHeap, 0, (LPVOID)MemPointer );
#else
    FreeSplMem(MemPointer);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\ncsockets.cxx ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    NCsockets.cxx

Abstract:

    Contains implementatio of classes and functions which expose
    sockets related funcitonaliuty.

Author:

    Felix Maxa (AMaxa) 16 May 2001

Revision History:

--*/

#include "precomp.h"
#include <winsock2.h>
#include <Ws2tcpip.h>
#include "ncsockets.hxx"

/*++

Name:

    IsIPAddress

Description:

    Checks if a string represents an IP address

Arguments:

    pszName - name to check

Return Value:

    S_OK          - pszName represents an IP address
    S_FALSE       - pszName is a valid name
    other HRESULT - an error occurred while trying to check the name

--*/
HRESULT
IsIPAddress(
    IN LPCWSTR pszName
    )
{
    TStatusH hRetval;
     
    hRetval DBGNOCHK = E_INVALIDARG;
    
    if (pszName && *pszName) 
    {
        LPSTR pszAnsi = NULL;

        hRetval DBGCHK = UnicodeToAnsiWithAlloc(pszName, &pszAnsi);

        if (SUCCEEDED(hRetval)) 
        {
            TWinsockStart WsaStart;
    
            hRetval DBGCHK = WsaStart.Valid();
    
            if (SUCCEEDED(hRetval)) 
            {
                DWORD     Error;
                ADDRINFO *pAddrInfo;
                ADDRINFO  Hint = {0};
                
                Hint.ai_flags  = AI_NUMERICHOST;
                Hint.ai_family = PF_INET;
            
                Error = getaddrinfo(pszAnsi, NULL, &Hint, &pAddrInfo);
            
                if (Error == ERROR_SUCCESS) 
                {
                    //
                    // It is an IP address
                    //
                    hRetval DBGCHK = S_OK;
        
                    freeaddrinfo(pAddrInfo);
                }
                else if (Error == EAI_NONAME) 
                {
                    //
                    // It is not an IP address
                    //
                    hRetval DBGCHK = S_FALSE;
                }
                else
                {
                    //
                    // Host does not exist
                    //
                    hRetval DBGCHK = GetWSAErrorAsHResult();
                }                
            }

            delete [] pszAnsi;
        }
    }

    return hRetval;
}

/*++

Name:

    GetWSAErrorAsHResult

Description:

    Retreives last WSA error as HRESULT

Arguments:

    None

Return Value:

    HRESULT

--*/
HRESULT
GetWSAErrorAsHResult(
    VOID
    )
{
    DWORD WSAError = WSAGetLastError();

    return HRESULT_FROM_WIN32(WSAError);
}

/*++

Name:

    TWinsockStart::TWinsockStart

Description:

    Initializes winsock for the current thread. Use Valid() member function
    to verify if the CTOR terminated successfully.

Arguments:

    MajorVersion - major version of winsock to initialize
    MinorVersion - minor version of winsock to initialize

Return Value:

    None

--*/
TWinsockStart::
TWinsockStart(
    IN DWORD MajorVersion,
    IN DWORD MinorVersion
    )
{
    WORD  wVersion = MAKEWORD(MajorVersion, MinorVersion);
    DWORD Result   = WSAStartup(wVersion, &m_WSAData);

    m_hr = HRESULT_FROM_WIN32(Result);
}

/*++

Name:

    TWinsockStart::~TWinsockStart

Description:

    The destructor cleans up the winsock structures initialized
    by WSAStartup in the constructor

Arguments:

    None

Return Value:

    None

--*/
TWinsockStart::
~TWinsockStart(
    VOID
    )
{
    if (m_hr == S_OK) 
    {
        WSACleanup();        
    }
}

/*++

Name:

    TWinsockStart::Valid

Description:

    Checks if the object is valid. 

Arguments:

    None

Return Value:

    S_OK - object is valid
    other HRESULT, the object is not valid

--*/
HRESULT
TWinsockStart::
Valid(
    VOID
    ) CONST
{
    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\netid.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    netid.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define MAXNETIDS       100

extern WCHAR *szRegDevicesPath;
extern WCHAR *szDotDefault;

DWORD
GetNetworkIdWorker(
    HKEY hKeyDevices,
    LPWSTR pDeviceName);


LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  &&
            (*string >= L'0') &&
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}


DWORD
GetNextNetId(
    DWORD pNetTable[]
    )
{
    DWORD i;
    for (i = 0; i < MAXNETIDS; i++) {
        if (!ISBITON(pNetTable, i)) {
            return(i);
        }
    }
    return((DWORD)-1);
}

DWORD
GetNetworkId(
    HKEY hKeyUser,
    LPWSTR pDeviceName)
{
    HKEY hKeyUserDevices;
    DWORD dwNetId;

    if (RegOpenKeyEx(hKeyUser,
                     szRegDevicesPath,
                     0,
                     KEY_READ,
                     &hKeyUserDevices) != ERROR_SUCCESS) {

        return 0;
    }

    dwNetId = GetNetworkIdWorker(hKeyUserDevices,
                                 pDeviceName);

    RegCloseKey(hKeyUserDevices);

    return dwNetId;
}


DWORD
GetNetworkIdWorker(
    HKEY hKeyUserDevices,
    LPWSTR pDeviceName)

/*++

    Parses the Devices section of Win.ini to determine if the
    printer device is a remote device.  We determine this by checking
    if the first two characters are "Ne." If they are then we know
    that the next two characters are the NetId.  If we find a Printer
    device mapping the input pDeviceName, then return the id.  If we
    don't find a Printer device mapping return the next possible /
    available id.

--*/

{
    LPWSTR p;
    WCHAR szData[MAX_PATH];
    WCHAR szValue[MAX_PATH];
    DWORD cchValue;
    DWORD cbData;
    DWORD i;
    DWORD dwId;

    DWORD dwError;

    //
    // Alloc 104 bits  - but we'll use only 100 bits
    //
    DWORD  adwNetTable[4];

    memset(adwNetTable, 0, sizeof(adwNetTable));

    for (i=0; TRUE; i++) {

        cchValue = COUNTOF(szValue);
        cbData = sizeof(szData);

        dwError = RegEnumValue(hKeyUserDevices,
                               i,
                               szValue,
                               &cchValue,
                               NULL,
                               NULL,
                               (PBYTE)szData,
                               &cbData);

        if (dwError != ERROR_SUCCESS)
            break;

        if (*szData) {

            if (p = wcschr(szData, L',')) {

                //
                // null set szOutput; szPrinter is now the
                // the name of our printer.
                //
                *p = 0;

                //
                // Get the Port name out of szOutput
                //
                p++;
                while (*p == ' ') {
                    p++;
                }

                if (!_wcsnicmp(p, L"Ne", 2)) {

                    p += 2;
                    *(p+2) = L'\0';
                    dwId = wtol(p);

                    //
                    // if we have a match for the id, then
                    // use it and return, no need to generate
                    // a table
                    //
                    if (!wcscmp(szValue, pDeviceName)) {
                        return dwId;
                    }

                    //
                    // Error if >= 100!
                    //
                    if (dwId < 100)
                        MARKUSE(adwNetTable, dwId);
                }
            }
        }
    }

    //
    //  So we didn't find the printer
    //

    return GetNextNetId(adwNetTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for router.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef MODULE
#define MODULE "SPL:"
#define MODULE_DEBUG RouterDebug
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <excpt.h>

#include <windows.h>
#include <strsafe.h>
#include <rpc.h>    // DataTypes and runtime APIs
#include <rpcasync.h>
#include <winspool.h>
#include <winsplp.h>
#include <winspl.h> // generated by the MIDL complier
#include <wininet.h>
#include <splcom.h>
#include <change.h>
#include <dbt.h>
#include "router.h"
#include "reply.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\ncmgr.cxx ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    NCmgr.cxx

Abstract:

    Implenetation of functions that operate on the name cache.
    The initialization and delete functions are declared in NCmgr.hxx.
    The rest of the functions are in winsplp.h.
    
Author:

    Felix Maxa (AMaxa) 16 May 2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <winsock2.h>
#include <iphlpapi.h>
#include "ncmgr.hxx"
#include "NCshared.hxx"
#include "ncnamecache.hxx"
#include "ncsockets.hxx"

TNameResolutionCache *g_pNameCache      = NULL;

WCHAR                 g_szHttpPrefix0[] = L"\\\\http://";
WCHAR                 g_szHttpPrefix1[] = L"\\\\https://";

/*++

Name:

    IsHttpPrinter

Description:

    Checks whether a string can be the name of an HTTP printer.
    
Arguments:

    pszPrinter  - string. Can be NULL.
    
Return Value:

    TRUE  - pszPrinter has the prefix characteristic to HTTP printers
    FALSE - pszPrinter does not have the prefix characteristic to HTTP printers

--*/
BOOL
IsHttpPrinter(
    IN LPCWSTR pszPrinter
    )
{
    BOOL bIsHttp = FALSE;

    if (pszPrinter && *pszPrinter)
    {
        bIsHttp = !_wcsnicmp(pszPrinter, g_szHttpPrefix0, COUNTOF(g_szHttpPrefix0) - 1) ||
                  !_wcsnicmp(pszPrinter, g_szHttpPrefix1, COUNTOF(g_szHttpPrefix1) - 1);
    }

    return bIsHttp;
}

/*++

Name:

    CacheInitNameCache

Description:

    Initialize the name cache object and the object that listens for
    IP changes for the local machine. This function must be called
    before any other thread has a chance of calling the rest of the
    cache functions. This is because we do not protect access on
    the pointer to the cache object.
    
Arguments:

    None.
    
Return Value:

    S_OK - the cache was initialized successfully
    other HRESULT - an error occurred, the cache cannot be used.

--*/
HRESULT
CacheInitNameCache(
    VOID
    )
{
    HRESULT hr = S_OK;

    g_pNameCache = new TNameResolutionCache;
    
    hr = g_pNameCache ? S_OK : E_OUTOFMEMORY;
    
    return hr;
}

/*++

Name:

    CacheDeleteNameCache

Description:

    Clean up the name cache object and the object that listens for
    IP changes for the local machine.
        
Arguments:

    None.
    
Return Value:

    None.

--*/
VOID
CacheDeleteNameCache(
    VOID
    )
{
    delete g_pNameCache;    
}

/*++

Name:

    CacheAddName

Description:

    Adds a name to the local cache. The name will be added only if
    it refers to the local machine or cluster resources running on
    the local machine.
        
Arguments:

    pszName - server name. Must be "\\" prefixed !!!
    
Return Value:

    S_OK - name was added to the cache.
    S_FALSE - name does not refer to the local machine
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
CacheAddName(
    IN LPCWSTR pszName
    )
{
    HRESULT hr = E_INVALIDARG;

    if (pszName                 && 
        *pszName                &&
        pszName[0] == L'\\'     &&
        pszName[1] == L'\\'     &&
        !IsHttpPrinter(pszName))
    {
        WCHAR *pcMark = wcschr(pszName + 2, L'\\');

        if (pcMark)
        {
            *pcMark = 0;
        }
                                           
        hr = g_pNameCache->AddName(pszName + 2);

        if (pcMark)
        {
            *pcMark = L'\\';
        }               
    }
    
    return hr;
}

/*++

Name:

    CacheCreateAndAddNode

Description:

    Creates a node supporting the "pszName". The IP addresses
    for the node are determined by calling getaddrinfo(pszName).
        
Arguments:

    pszName      - server name. Cannnot be "\\" prefixed.
    bClusterNode - TRUE if the node is created by a cluster pIniSpooler
    
Return Value:

    S_OK - node was added to the cache. (or existed there already)
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
CacheCreateAndAddNode(
    IN LPCWSTR pszName,
    IN BOOL    bClusterNode
    )
{
    HRESULT hr = g_pNameCache->CreateAndAddNode(pszName, bClusterNode);

    return hr;
}

/*++

Name:

    CacheCreateAndAddNodeWithIPAddresses

Description:

    Creates a node supporting the "pszName". The IP addresses
    are passed in a argument by the caller. Thus a certain
    node can support IP addresses that don't event resolve to
    the pszName itself.

Arguments:

    pszName         - server name. Cannnot be "\\" prefixed.
    bClusterNode    - TRUE if the node is created by a cluster pIniSpooler
    ppszIPAddresses - array of strings represeting IP addresses
    cIPAddresses    - number of strings in the array
    
Return Value:

    S_OK - node was added to the cache. (or existed there already)
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
CacheCreateAndAddNodeWithIPAddresses(
    IN LPCWSTR  pszName,
    IN BOOL     bClusterNode,
    IN LPCWSTR *ppszIPAddresses,
    IN DWORD    cIPAddresses
    )
{
    HRESULT hr = g_pNameCache->CreateAndAddNodeWithIPAddresses(pszName, 
                                                               bClusterNode, 
                                                               ppszIPAddresses, 
                                                               cIPAddresses);

    return hr;
}

/*++

Name:

    CacheDeleteNode

Description:

    Deletes a node from the cache.

Arguments:

    pszName      - server name. Cannnot be "\\" prefixed.
    
Return Value:

    S_OK - node was deleted from the cache
    S_FALSE - node was not found in cache
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
CacheDeleteNode(
    IN LPCWSTR pszNode
    )
{
    return g_pNameCache->DeleteNode(pszNode);
}

/*++

Name:

    CacheIsNameInNodeList

Description:

    Checks if the node pszNode supports the pszName name in its list.

Arguments:

    psznode - node in the cache list
    pszName - server name. Cannnot be "\\" prefixed.
    
Return Value:

    S_OK - pszName is in the cache of pszNode 
    S_FALSE - pszName is NOT in the cache of pszNode 
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
CacheIsNameInNodeList(
    IN LPCWSTR pszNode,
    IN LPCWSTR pszName
    )
{
    return g_pNameCache->IsNameInNodeCache(pszNode, pszName);
}

/*++

Name:

    CacheRefresh

Description:

    Refershes the list of IP addresses supported by the local machine node.
    Should be called when a change of IP PNP event occurrs. The name of
    the local node is the short name of the local machine.

Arguments:

    None.
    
Return Value:

    S_OK - local machine node was refreshed
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
CacheRefresh(
    VOID
    )
{
    HRESULT hr = g_pNameCache->RefreshNode(szMachineName + 2);

    return hr;
}

/*++

Name:

    PnpIPAddressChangeListener

Description:

    This function loops and waits for events that indicate changes in IP address.
    Chnages in ip address occurr when you can "ipconfig /release", when the IP
    address resource of a cluster comes online or goes offline, etc.
    The function takes ownership of the pointer (the meory pointer to by the pointer)
    Also, the function takes ownership of the hWaitEvent.
    The function does not take ownership of the hTerminateEvent. That event must be 
    aglobal mutex for the spooler process and can be used to terminate the looping thread.

Arguments:

    pVoid - pointer to IPADDRESSCHANGEARGS structure
    
Return Value:

    None.

--*/
VOID
PnpIPAddressChangeListener(
    VOID *pVoid
    )
{
    SIPADDRESSCHANGEARGS *pArgs           = reinterpret_cast<SIPADDRESSCHANGEARGS *>(pVoid);
    PFNVOID               pfnCallBack     = pArgs->pfnCallBack;
    HANDLE                hTerminateEvent = pArgs->hTerminateEvent;
    OVERLAPPED            InterfaceChange = {0};
    BOOL                  bLoop           = TRUE;
    
    InterfaceChange.hEvent = pArgs->hWaitEvent;
    
    while (bLoop)
    {
        HANDLE hNotify = NULL;
        DWORD  Error   = NotifyAddrChange(&hNotify, &InterfaceChange);

        bLoop = FALSE;

        if (Error == ERROR_IO_PENDING)
        {
            HANDLE hHandles[2] = {InterfaceChange.hEvent, hTerminateEvent};
            DWORD  cHandles    = hTerminateEvent ? 2 : 1;
            DWORD  WaitStatus;
    
            WaitStatus = WaitForMultipleObjects(cHandles, hHandles, FALSE, INFINITE);
                
            switch(WaitStatus)
            {
                case WAIT_OBJECT_0:
                {
                    bLoop = TRUE;

                    (*pfnCallBack)();

                    break;
                }
                
                case WAIT_OBJECT_0 + 1:
                {
                    //
                    // We're done waiting, bLoop is FALSE so the while will terminate
                    //
                    break;
                }
                
                default:
                {
                    DBGMSG(DBG_ERROR, ("PnpIPAddressChangeListener WaitForMultipleObjects failed\n"));
                    break;
                }                
            }            
        }
        else
        {
            DBGMSG(DBG_WARN, ("PnpIPAddressChangeListener NotifyAddrChange failed. Win32 error %u\n", Error));
        }
    }

    CloseHandle(InterfaceChange.hEvent);

    delete pArgs;
}

/*++

Name:

    InitializePnPIPAddressChangeListener

Description:

    Launches a separate thread which waits for IP change events.

Arguments:

    pfnCallBack - function to call when a change in IP address occurs
    
Return Value:

    S_OK - the IP change listener was initialized successfully
    other HRESULT - an error occurred while executing the function

--*/
HRESULT
InitializePnPIPAddressChangeListener(
    IN PFNVOID pfnCallBack
    )
{
    TStatusH              hRetval;
    SIPADDRESSCHANGEARGS *pArgs = new SIPADDRESSCHANGEARGS;

    hRetval DBGCHK = pfnCallBack ? (pArgs ? S_OK : E_OUTOFMEMORY) : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        HANDLE hThread;
        DWORD  ThreadId;
        
        pArgs->pfnCallBack     = pfnCallBack;
        
        //
        // When the spooler can finally shut down properly, then we can specify 
        // here an event to terminate the PnpIPAddressChangeListener
        //
        pArgs->hTerminateEvent = NULL;
        
        //
        // Note that PnpIPAddressChangeListener takes ownership of this event
        // so PnpIPAddressChangeListener must call CloseHandle on the event
        //
        pArgs->hWaitEvent      = CreateEvent(NULL, FALSE, FALSE, NULL);
        
        hRetval DBGCHK         = pArgs->hWaitEvent ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            if (hThread = CreateThread(NULL,
                                       0,
                                       (LPTHREAD_START_ROUTINE)PnpIPAddressChangeListener,
                                       pArgs,
                                       0,
                                       &ThreadId))
            {
                CloseHandle(hThread);  

                //
                // Note that PnpIPAddressChangeListener takes ownership of pArgs and must free it
                //
                pArgs = NULL;
            }
            else
            {
                hRetval DBGCHK = GetLastErrorAsHResult();
            }             
        }
    }

    delete pArgs;

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\ncnamecache.cxx ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    NCnamecache.cxx

Abstract:

    Implemntation of the name relosution cache classes and functions.

Author:

    Felix Maxa (AMaxa) 16 May  2001 - Created
    Felix Maxa (AMaxa) 30 Sept 2001 - Added the cache for failures

Revision History:

--*/

#include "precomp.h"
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <lm.h>
#include "ncnamecache.hxx"
#include "ncsockets.hxx"    
#include "ncclusfunc.hxx"    

using namespace NCoreLibrary;

/*++

Explanation of how the cache works.

The basic idea is that every local or cluster pIniSpooler has an associated node in the cache. Each node keeps
a list of IPs that are handled by the node name, and a list of alternate names (FQDN, aliases etc.). When a
node is created only the IP lists are popoluated. The alternate names are popoluated dynalically, when a request
to add a name to the cache comes in.

Example of cache. List of nodes after the pIniSpooler for the local machine is created.
    AMAXA-NODE1 (this is the node name)
        IP Addresses: 172.31.173.91 <--- populated by the cache with the result of getaddrinfo("amaxa-node1")
        Alternate names: Empty
                         
Nodes for cluster pIniSpooler are always added in the head of the list, so they are searched first. We search
the nodes when we add a new name to the cache. We need to find the node where to add the new name. The algorithm is
the following:
If getaddrinfo(NewName) succeeds, then we get a list of IPs, NewNameIPs. We start searching if the NewNameIPs
are a subset of the IP addresses of nodes in the cache. For cluster nodes,  every IP in NewNameIPs must be found
in the set of IP addresses for the node. For local nodes, one single IP in NewNameIPs must be found in IP Addresses.

If  getaddrinfo(NewName) fails, then we check if the server name is in the list of transports enumerated by
NetServerTransportEnum. If positive, then it is an emulated server and we add it to the list of alternate names 
for the node representing the local machine (AMAXA_NODE1 in the example)

Example of node list with cluster node.
    AMAXA-CLS1 (this is the node name)
        IP Addresses: 172.31.172.31
                      172.31.172.32
        Alternate names: AMAXA-CLS1.NTDEV.MICROSOFT.COM
                         
    AMAXA-NODE1 (this is the node name)
        IP Addresses: 172.31.173.91
        Alternate names: 

Note that a spooler cluster resource can be dependent on more than one IP address. That is why when cluster nodes
are created one needs to specify whet IP addresses it recognizes.

Let's say we want to add "AMAXA-NODE1.NTDEV.MICROSOFT.COM" to the cache. If the cluster IP resources are online,
then getaddrinfo("amaxxa-node1.ntdev.microsoft.com") returns 172.31.173.91 (IP gotten at boot) and 172.31.172.31,
172.31.172.32, IPs registered by the cluster. Based on the search algorithm above, the result will be:

    AMAXA-CLS1 (this is the node name)
        IP Addresses: 172.31.172.31
                      172.31.172.32
        Alternate names: AMAXA-CLS1.NTDEV.MICROSOFT.COM
                         
    AMAXA-NODE1 (this is the node name)
        IP Addresses: 172.31.173.91
        Alternate names: AMAXA-NODE1.NTDEV.MICROSOFT.COM
           

Special cases when the cluster service is running on a machine.

Scenario 1)
a) spooler is stopped
b) cluster is running and resitered the IPs: 172.31.172.31, 172.31.172.32
c) spooler starts
d) the cache initializes and a node for the local machine is added
e) getaddrinfo(local machine) returns also the cluster IPs
f) local node has the list: 172.31.172.31, 172.31.172.32, 172.31.173.91
g) before the cluster ini spooler is created a call to OpenPrinter("\\AMAXA-CLS1") comes in
h) getaddrinfo("AMAXA-CLS1") resolves to 172.31.172.31
i) 172.31.172.31 is in the list of IPs for the local machine, so AMAXA-CLS1 is added to the alternate names for AMAXA-NODE1
This is NOT wnat we want! So we need to get rid of the cluster IPs in the list of the local node. When a local node is created,
the list of IP addresses is set to
Set of IPs returned by getaddrinfo() - Set of IPs belonging to cluster resources.

A PnP event is triggered when the local machine gets a new IP either via ipconfig or because a cluster IP resource comes 
online or goes offline. We cannot distinguish if the event was triggered by cluster activity or by ipconfig. So when
we get such an event we refresh only the local node(s). We refresh it by deleting it from the cache and then adding it back.
That way the list of IPs is repopoluated.

The cluster nodes do not need refreshing. A spooler resource needs to be taken offline in order to make changes in its dependent
resources. In that case the cluster node is removed from the cache.

The failed cache.
Once the name cache was checked in we ran into bug 470345 "CSNW:Printing operations painfully slow". We had a printer connection
to a NetWare server. getaddrinfo(NetWareServerName) failed and took about 2.3 seconds to complete. This meant a huge performance
loss when printing to the NetWare server, because for each single OpenPrinter the spooler took at least 2 seconds before the
name cache failed in getaddrinfo(). So there was a need for a cache of failed server names. If getaddrinfo fails on a name, we add 
the name to the fast cache. We keep the name in the cache for 1 minute. We won't call getaddrinfo on the name before that minute expires.


--*/


/*++

Name:

    TNameResolutionCache::TNameResolutionCache

Description:

    CTOR for TNameResolutionCache

Arguments:

    None

Return Value:

    None

--*/
TNameResolutionCache::
TNameResolutionCache(
    IN DWORD AgingTime
    ) : m_AgingTime(AgingTime)
{  
}

/*++

Name:

    TNameResolutionCache::~TNameResolutionCache

Description:

    DTOR for TNameResolutionCache

Arguments:

    None

Return Value:

    None

--*/
TNameResolutionCache::
~TNameResolutionCache(
    VOID
    )
{    
}

/*++

Name:

    TNameResolutionCache::IsValid

Description:

    Returns S_OK if the TNameResolutionCache object was intialized
    properly, any other HRESULT if initialization failed.

Arguments:

    None

Return Value:

    HRESULT

--*/
HRESULT
TNameResolutionCache::
IsValid(
    VOID
    )
{    
    TStatusH hRet;
     
    hRet DBGCHK = m_Lock.IsValid();

    if (SUCCEEDED(hRet))
    {
        hRet DBGCHK = m_FailedCache.IsValid();
    }

    return hRet;
}

/*++

Name:

    TNameResolutionCache::GetNetBiosInfo

Description:

    Gets the list of emulated sever names for the local machine. Checks if pszName
    is in the list of emulated names. If it is, then paliasedServer will contain
    the name of the machine the alias refers to (the local machine)

Arguments:

    pszName        - server alis to search for
    pAliasedServer - will receive the server name that pszName refers to

Return Value:

    S_OK    - pszName is an alias for the local machine
    S_FALSE - pszName is not an alias for the local machine
    any other HR - an error occurred

--*/
HRESULT
TNameResolutionCache::
GetNetBiosInfo(
    IN LPCSTR   pszName, 
    IN TString *pAliasedServer
    )
{
    TStatusH hRetval;
     
    hRetval DBGNOCHK = E_INVALIDARG;
    
    if (pszName && *pszName && pAliasedServer) 
    {
        PSERVER_TRANSPORT_INFO_0 TransportInfo = NULL;
        DWORD                    EntriesRead;
        DWORD                    EntriesTotal;
        NET_API_STATUS           Status;

        Status = NetServerTransportEnum(NULL,
                                        0,
                                        reinterpret_cast<PBYTE *>(&TransportInfo),
                                        MAX_PREFERRED_LENGTH,
                                        &EntriesRead,
                                        &EntriesTotal,
                                        NULL);

        hRetval DBGCHK = Status == NERR_Success ? S_OK : HRESULT_FROM_WIN32(Status);
        
        if (SUCCEEDED(hRetval)) 
        {
            DWORD Index;
            DWORD NameLength = strlen(pszName);

            //
            // pszName not found
            //
            hRetval DBGNOCHK = S_FALSE;
           
            for (Index = 0; Index < EntriesRead; Index++) 
            {
                if (TransportInfo[Index].svti0_transportaddresslength == NameLength) 
                {
                    //
                    // Check if pszName matches any of the addresses returned by NetServerTransportEnum
                    // 
                    if (!_strnicmp(pszName,
                                   reinterpret_cast<LPSTR>(TransportInfo[Index].svti0_transportaddress),
                                   NameLength)) 
                    {
                        hRetval DBGCHK = pAliasedServer->Update(szMachineName + 2);
                        
                        //
                        // No need to continue looping
                        //
                        break;
                    }                    
                }
            }
        
            NetApiBufferFree(TransportInfo);
        }
    }
    
    return hRetval;
}

/*++

Name:

    TNameResolutionCache::GetAddrInfo

Description:

    This function calls getaddrinfo on a server name. Then it populates
    2 lists with the results of getaddrinfo. One list contains all
    the IP address, the other one all the names associated with the
    server name.

Arguments:

    pszName         - server name. Cannot be prefixed wth "\\".
    pIPAddresses    - pointer to list where to append the IP addresses
    pAlternateNames - pointer to list where to append the names (normally the FQDN)

Return Value:

    S_OK - getaddrinfo succeeded and the lists were populated
    other HRESULT - an error occurred

--*/
HRESULT
TNameResolutionCache::
GetAddrInfo(
    IN LPCSTR                            pszName,
    IN NCoreLibrary::TList<TStringNode> *pIPAddresses, 
    IN NCoreLibrary::TList<TStringNode> *pAlternateNames
    )
{
    TStatusH hRetval;
     
    hRetval DBGNOCHK = E_INVALIDARG;
    
    if (pszName && *pszName && pIPAddresses && pAlternateNames) 
    {
        TWinsockStart WsaStart;

        hRetval DBGCHK = WsaStart.Valid();

        if (SUCCEEDED(hRetval)) 
        {
            DWORD     Error;
            ADDRINFO *pAddrInfo;
            ADDRINFO  Hint = {0};
        
            Hint.ai_flags  = AI_CANONNAME;
            Hint.ai_family = PF_INET;
    
            Error = getaddrinfo(pszName, NULL, &Hint, &pAddrInfo);

            hRetval DBGCHK = Error == ERROR_SUCCESS ? S_OK : GetWSAErrorAsHResult();
    
            if (SUCCEEDED(hRetval)) 
            {
                ADDRINFO *pTemp;
                LPWSTR    pszBuffer   = NULL;
                DWORD     cchBuffer   = kBufferAllocHint;
                DWORD     cchNeeded   = cchBuffer;  
                INT       WsaError;

                pszBuffer = new WCHAR[cchBuffer];

                hRetval DBGCHK = pszBuffer ? S_OK : E_OUTOFMEMORY;

                if (SUCCEEDED(hRetval)) 
                {
                    for (pTemp = pAddrInfo; pTemp; pTemp = pTemp->ai_next) 
                    {
                        WsaError = WSAAddressToString(pTemp->ai_addr,
                                                      pTemp->ai_addrlen,
                                                      NULL,
                                                      pszBuffer,
                                                      &cchNeeded);
    
                        if (WsaError == SOCKET_ERROR) 
                        {
                            hRetval DBGCHK = GetWSAErrorAsHResult();
    
                            if (SCODE_CODE(hRetval) == WSAEFAULT) 
                            {
                                delete [] pszBuffer;

                                cchBuffer = cchNeeded;
    
                                pszBuffer = new WCHAR[cchBuffer];
    
                                hRetval DBGCHK = pszBuffer ? S_OK : E_OUTOFMEMORY;
    
                                if (SUCCEEDED(hRetval)) 
                                {
                                    WsaError = WSAAddressToString(pTemp->ai_addr,
                                                                  pTemp->ai_addrlen,
                                                                  NULL,
                                                                  pszBuffer,
                                                                  &cchNeeded);
    
                                    hRetval DBGCHK = !WsaError ? S_OK : GetWSAErrorAsHResult();  
                                }
                                else
                                {
                                    //
                                    // Fatal error. Mem alloc failed.
                                    //
                                    break;
                                }
                            }
                        }
                    
                        if (SUCCEEDED(hRetval)) 
                        {
                            TStringNode *pItem = new TStringNode(pszBuffer);
    
                            hRetval DBGCHK = pItem ? pItem->Valid() : E_OUTOFMEMORY;
    
                            if (SUCCEEDED(hRetval)) 
                            {
                                hRetval DBGCHK = pIPAddresses->AddAtHead(pItem);
                            }
                        } 

                        if (pTemp->ai_canonname) 
                        {
                            LPWSTR pszUnicode = NULL;
    
                            hRetval DBGCHK = AnsiToUnicodeWithAlloc(pTemp->ai_canonname, &pszUnicode);
                            
                            if (SUCCEEDED(hRetval)) 
                            {
                                TStringNode *pItem = new TStringNode(pszUnicode);
    
                                hRetval DBGCHK = pItem ? pItem->Valid() : E_OUTOFMEMORY;
                    
                                if (SUCCEEDED(hRetval)) 
                                {
                                    hRetval DBGCHK = pAlternateNames->AddAtHead(pItem);
                                }
    
                                delete [] pszUnicode;
                            }
                        }
                    } // for loop

                    delete [] pszBuffer;
                }
        
                freeaddrinfo(pAddrInfo);
            }             
        }                       
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::ExcludeIPsUsedByCluster

Description:

    Excludes from pList all the names present in pClusterIPs.

Arguments:

    pClusterIPs - list of IP addresses used by the cluster resources
    pList       - list of IP addresses

Return Value:

    S_OK - all the elements in pClusterIPs were eliminated from pList
    any other HRESULT - an error occurred

--*/
HRESULT
TNameResolutionCache::
ExcludeIPsUsedByCluster(
    IN TList<TStringNode> *pClusterIPs,
    IN TList<TStringNode> *pList
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pClusterIPs ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval)) 
    {
        TList<TStringNode>::TIterator ItClus(pClusterIPs);
                            
        for (ItClus.First(); !ItClus.IsDone(); ItClus.Next())
        {
            LPCWSTR pszClusString = ItClus.Current()->m_String;

            DBGMSG(DBG_TRACE, ("IP used by cluster %ws\n", pszClusString));

            TList<TStringNode>::TIterator  ItList(pList);
            
            for (ItList.First(); !ItList.IsDone(); ItList.Next())
            {
                if (!_wcsicmp(ItList.Current()->m_String, pszClusString)) 
                {
                    TStringNode *pNodeToElim = ItList.Current();

                    hRetval DBGCHK = pList->Remove(pNodeToElim);
        
                    delete pNodeToElim;
                    
                    break;
                }                
            }           
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::IsNodeInCache

Description:

    Checks if there is a node called pszName in the cache.
    This function locks the cache.

Arguments:

    pszNode - name to look for in the node list

Return Value:

    S_OK     - a node with name "pszName" is present in the list
    S_FALSE  - no node with name "pszName" is present
    other HR - an error occrred while searching for pszName node 

--*/
HRESULT
TNameResolutionCache::
IsNodeInCache(
    IN LPCWSTR pszNode
    ) 
{
    TStatusH hRetval;

    hRetval DBGCHK = pszNode ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
        
        hRetval DBGNOCHK = S_FALSE;

        for (It.First(); !It.IsDone(); It.Next())
        {
            hRetval DBGNOCHK = It.Current()->IsSameName(pszNode);

            if (hRetval == S_OK)
            {
                break;
            }
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::DeleteNode

Description:

    Deletes a node from the cache. The function locks the cache

Arguments:

    pszNode - node to delete
    
Return Value:

    S_OK     - node was deleted
    S_FALSE  - node was not found
    other HR - an error occrred while performing operation

--*/
HRESULT
TNameResolutionCache::
DeleteNode(
    IN LPCWSTR pszNode
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pszNode && *pszNode ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        TResolutionCacheNode *pNode = NULL;
        
        m_Lock.Enter();

        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
        
        //
        // We have not found a node containing pszName
        //
        hRetval DBGNOCHK = S_FALSE;

        for (It.First(); !It.IsDone(); It.Next())
        {
            //
            // Check if pszName is the name of the node
            //
            if (!_wcsicmp(It.Current()->m_Name, pszNode))
            {
                hRetval DBGCHK = S_OK;

                pNode = It.Current();

                if (pNode) 
                {
                    hRetval DBGCHK = m_NodeList.Remove(pNode);
                }

                break;
            }
        }
        
        m_Lock.Leave();

        delete pNode;
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::IsNameInNodeCache

Description:

    Looks for pszName in the list of IPs and names associated with the
    node named pszNode. The function locks the cache

Arguments:

    pszNode - node where to search for pszName
    pszName - name to search for in a node

Return Value:

    S_OK     - a pszName is present in the list of names associated to pszNode
    S_FALSE  - a pszName is NOT present in the list of names associated to pszNode
    other HR - an error occrred while searching for pszName node 

--*/
HRESULT
TNameResolutionCache::
IsNameInNodeCache(
    IN LPCWSTR pszNode,
    IN LPCWSTR pszName
    ) 
{
    TStatusH hRetval;

    hRetval DBGCHK = pszNode && pszName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
        
        hRetval DBGNOCHK = S_FALSE;

        for (It.First(); !It.IsDone(); It.Next())
        {
            //
            // Check of pszNode matches the name of the node pointer by the iterator
            //
            if (It.Current()->IsSameName(pszNode) == S_OK)
            {
                hRetval DBGCHK = It.Current()->IsNameInNodeCache(pszName);

                break;
            }            
        }
    }

    return hRetval;;
}

/*++

Name:

    TNameResolutionCache::IsNameInCache

Description:

    Checks is pszName is in the list of IPs and names associated with a
    node in the cache. The function locks the cache.

Arguments:

    pszName - name to search for in the cache

Return Value:

    S_OK     - a pszName is present in the cache
    S_FALSE  - a pszName is NOT present in the cache
    other HR - an error occrred while searching for pszName  

--*/
HRESULT
TNameResolutionCache::
IsNameInCache(
    IN LPCWSTR pszName
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pszName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
        
        hRetval DBGNOCHK = S_FALSE;

        for (It.First(); !It.IsDone(); It.Next())
        {
            hRetval DBGNOCHK = It.Current()->IsNameInNodeCache(pszName);

            if (hRetval == S_OK) 
            {
                break;
            }
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::FindNameInCacheAndAgeOut

Description:

    Searches for a certain name in the cache. If the name is found in the cache,
    but it is aged out, the name is eliminated and S_FALSE is returned. The aging
    time of names is specified as argument to the constructor of TNameResolutionCache

Arguments:

    pszName - name to look for

Return Value:

    S_OK         - name was found
    S_FALSE      - name was not found or it is aged out (and was eliminated therefore)
    any other HR - an error occurred

--*/
HRESULT
TNameResolutionCache::
FindNameInCacheAndAgeOut(
    IN LPCWSTR pszName
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pszName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        TStringNode *pStringNode = NULL;
        
        m_Lock.Enter();

        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
        
        //
        // We have not found a node containing pszName
        //
        hRetval DBGNOCHK = S_FALSE;

        for (It.First(); !It.IsDone(); It.Next())
        {
            //
            // Check if pszName is the name of the node
            //
            if (!_wcsicmp(It.Current()->m_Name, pszName))
            {
                hRetval DBGCHK = S_OK;

                break;
            }
            else
            { 
                //
                // Check if the name is in the list of alternate names
                //
                hRetval DBGNOCHK = It.Current()->GetStringNodeFromName(pszName, &pStringNode);

                if (hRetval == S_OK) 
                {
                    //
                    // We found pszName in the node pointed to by pStringNode
                    //
                    DWORD CurrentTick = GetTickCount();
                    
                    //
                    // Check if we need to age out the node
                    //
                    if (CurrentTick - pStringNode->m_Time > m_AgingTime) 
                    {
                        hRetval DBGCHK = It.Current()->m_pAlternateNames->Remove(pStringNode);
                        
                        if (SUCCEEDED(hRetval)) 
                        {
                            //
                            // Since the entry was aged out, we pretend we did not find it
                            //
                            hRetval DBGNOCHK = S_FALSE;
                        }                                       
                    }
                    else
                    {
                        //
                        // Not aged out, prevent it from being deleted
                        //
                        pStringNode = NULL;
                    }

                    break;
                }
            }
        }

        m_Lock.Leave();

        delete pStringNode;        
    }

    return hRetval;;
}

/*++

Name:

    TNameResolutionCache::CreateAndAddNodeWithIPAddresses

Description:

    Checks if a node with pszName name is already in the cache. If not,
    it creates a new node and populates it with data. Then it adds the
    node to the list of nodes. pszName cannot be an IP address. 
    This function does not call getaddrinfo on pszName. It blindly fills
    in the IP list for the node with data in ppszIPAddresses
    
Arguments:

    pszName         - name to create a new node for
    bClusterNode    - specifies if this node corresponds to a cluster ini spooler
    ppszIPAddresses - array of strings representing IPs
    cIPAddresses    - count of lements in the array           

Return Value:

    S_OK    - a new node was created and added to the cache
    S_FALSE - a node with pszName name already existed in the cache
    any other HR - an error occurred while performing the operation

--*/
HRESULT
TNameResolutionCache::
CreateAndAddNodeWithIPAddresses(
    IN LPCWSTR  pszName,
    IN BOOL     bClusterNode,
    IN LPCWSTR *ppszIPAddresses,
    IN DWORD    cIPAddresses
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pszName && 
                     ppszIPAddresses && 
                     *ppszIPAddresses && 
                     cIPAddresses > 0 ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        //
        // The function IsNodeInCache will lock the cache for the search
        // 
        hRetval DBGCHK = IsNodeInCache(pszName);

        //
        // Not found in the cache
        //
        if (hRetval == S_FALSE) 
        {
            TResolutionCacheNode *pNode = new TResolutionCacheNode(pszName, bClusterNode);

            hRetval DBGCHK = pNode ? pNode->Valid() : E_OUTOFMEMORY;
            
            //
            // Add all the supported IP addresses
            //
            if (SUCCEEDED(hRetval)) 
            {
                DWORD Index;

                for (Index = 0; Index < cIPAddresses && SUCCEEDED(hRetval); Index++) 
                {
                    TStringNode *pItem = new TStringNode(ppszIPAddresses[Index]);

                    hRetval DBGCHK = pItem ? pItem->Valid() : E_OUTOFMEMORY;
                    
                    if (SUCCEEDED(hRetval)) 
                    {
                        hRetval DBGCHK = pNode->m_pIPAddresses->AddAtHead(pItem);

                        if (SUCCEEDED(hRetval)) 
                        {
                            //
                            // List tooks ownership of string node object
                            //
                            pItem = NULL;
                        }
                    }
                    
                    delete pItem;                                        
                }
            }

            if (SUCCEEDED(hRetval)) 
            {
                NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);
    
                //
                // Make sure a node with pszName was not added to the cache while
                // we were calling the TResolutionCacheNode CTOR
                //
                hRetval DBGCHK = IsNodeInCache(pszName);
    
                //
                // Node not found
                //
                if (hRetval == S_FALSE) 
                {
                    
                    if (bClusterNode)
                    {
                        hRetval DBGCHK = m_NodeList.AddAtHead(pNode);
                    }
                    else
                    {
                        hRetval DBGCHK = m_NodeList.AddAtTail(pNode);
                    }
                    
                    if (SUCCEEDED(hRetval)) 
                    {
                        //
                        // The cache took owership of pNode
                        //
                        pNode = NULL;
                    }
                }
            }
            
            delete pNode;                                                                                    
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::Purge

Description:

    Purges the cache. The function locks the cache.

Arguments:

    None

Return Value:

    S_OK         - cache was purged
    any other HR - an error occurred

--*/
HRESULT
TNameResolutionCache::
Purge(
    VOID
    )
{
    m_Lock.Enter();

    while (!m_NodeList.IsEmpty())
    {
        TResolutionCacheNode *pItem = m_NodeList.RemoveAtHead();
        
        delete pItem;        
    }

    m_Lock.Leave();

    return S_OK;
}

/*++

Name:

    TNameResolutionCache::CreateAndAddNode

Description:

    Checks if a node with pszName name is already in the cache. If not,
    it creates a new node and populates it with data. Then it adds the
    node to the list of nodes. pszName cannot be an IP address. 
    getaddrinfo must succeed on pszName. pszName cannot be an emulated
    server name. The function locks the cache.
    
Arguments:

    pszName      - name to create a new node for
    bClusterNode - specifies if this node corresponds to a cluster ini spooler
    
Return Value:

    S_OK    - a new node was created and added to the cache
    S_FALSE - a node with pszName name already existed in the cache
    any other HR - an error occurred while performing the operation

--*/
HRESULT
TNameResolutionCache::
CreateAndAddNode(
    IN LPCWSTR pszName,
    IN BOOL    bClusterNode
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pszName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        //
        // The function will lock the cache for the search
        // 
        hRetval DBGCHK = IsNodeInCache(pszName);

        //
        // Not found in the cache
        //
        if (hRetval == S_FALSE) 
        {
            hRetval DBGCHK = IsIPAddress(pszName);
    
            if (hRetval == S_OK) 
            {
                //
                // We do not add IPs to our cache
                //
                hRetval DBGCHK = E_FAIL;
            }
            else
            {
                LPSTR pszAnsiName;

                hRetval DBGCHK = UnicodeToAnsiWithAlloc(pszName, &pszAnsiName);
    
                if (SUCCEEDED(hRetval)) 
                {
                    TResolutionCacheNode *pNode = new TResolutionCacheNode(pszName, bClusterNode);

                    hRetval DBGCHK = pNode ? pNode->Valid() : E_OUTOFMEMORY;
                    
                    if (SUCCEEDED(hRetval)) 
                    {
                        hRetval DBGCHK = ResolveNameToAddress(pszAnsiName, pNode->m_pIPAddresses, pNode->m_pAlternateNames);

                        if (SUCCEEDED(hRetval))
                        {
                            TList<TStringNode> AddressesUsedByCluster;

                            //
                            // Check if the local machine has any IPs used by the cluster service
                            //
                            hRetval DBGCHK = GetClusterIPAddresses(&AddressesUsedByCluster);

                            if (SUCCEEDED(hRetval)) 
                            {
                                hRetval DBGCHK = ExcludeIPsUsedByCluster(&AddressesUsedByCluster, pNode->m_pIPAddresses);
                            }
                        }
                        else if (SCODE_CODE(hRetval) == WSAHOST_NOT_FOUND)
                        {
                            //
                            // There are situations when the name of the local machine cannot be resolved
                            // to an IP. This can happen for example when networking is partly initialized
                            // In this case we want the spooler to function. The only thing is that it 
                            // won't keep an IP address associated with the node corresponding to the name
                            // of the machine. Basically this is the node created by 
                            // SplCreateSpooler(\\local-machine-name). If the machine gets an IP address
                            // later, then we will be notified and we can refresh the node. 
                            //
                            if (!_wcsicmp(pszName, szMachineName + 2))
                            {
                                hRetval DBGNOCHK = S_OK;
                            }
                        }

                        if (SUCCEEDED(hRetval))
                        {
                            NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

                            //
                            // Make sure a node with pszName was not added to the cache while
                            // we were calling the TResolutionCacheNode CTOR
                            //
                            hRetval DBGCHK = IsNodeInCache(pszName);

                            //
                            // Node not found
                            //
                            if (hRetval == S_FALSE)
                            {
                                if (bClusterNode)
                                {
                                    hRetval DBGCHK = m_NodeList.AddAtHead(pNode);
                                }
                                else
                                {
                                    //
                                    // A local node cache is always added at the tail of the list, so
                                    // it is searched after cluster nodes.
                                    //
                                    hRetval DBGCHK = m_NodeList.AddAtTail(pNode);
                                }

                                if (SUCCEEDED(hRetval))
                                {
                                    //
                                    // The cache took owership of pNode
                                    //
                                    pNode = NULL;
                                }
                            }
                        }                                                
                    }
                    
                    delete pNode;                                                                        
                    
                    delete [] pszAnsiName;
                }
            }
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::ResolveNameToAddress

Description:

    
    
Arguments:

    
    
Return Value:

    
--*/
HRESULT
TNameResolutionCache::
ResolveNameToAddress(
    IN LPCSTR              pszName,
    IN TList<TStringNode> *pAddresses,
    IN TList<TStringNode> *pNames
    )
{
    TStatusH hRetval;
     
    hRetval DBGNOCHK = E_INVALIDARG;
    
    if (pszName && *pszName && pAddresses && pNames) 
    {
        hRetval DBGCHK = m_FailedCache.IsStringInCache(pszName);

        if (hRetval == S_FALSE)
        {
            hRetval DBGCHK = GetAddrInfo(pszName, pAddresses, pNames);

            if (SCODE_CODE(hRetval) == WSAHOST_NOT_FOUND)
            {
                //
                // We intentionally ignore the error returned by this function
                // because we do not want to overwrite hRetval. Out callers need
                // the exact error code returned by GetAddrInfo
                //
                m_FailedCache.AddString(pszName);
            }
        }
        else
        {
            hRetval DBGNOCHK = HRESULT_FROM_WIN32(WSAHOST_NOT_FOUND);
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::RefreshNode

Description:

    Checks if a node with pszName name is already in the cache. If not,
    it creates a new node and populates it with data. Then it adds the
    node to the list of nodes. pszName cannot be an IP address. 
    getaddrinfo must succeed on pszName. pszName cannot be an emulated
    server name. The function locks the cache.
    
Arguments:

    pszName      - name to create a new node for
    bClusterNode - specifies if this node corresponds to a cluster ini spooler
    
Return Value:

    S_OK    - a new node was created and added to the cache
    S_FALSE - a node with pszName name already existed in the cache
    any other HR - an error occurred while performing the operation

--*/
HRESULT
TNameResolutionCache::
RefreshNode(
    IN LPCWSTR pszName
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pszName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        //
        // Find the node matching pszName
        //
        hRetval DBGCHK = IsNodeInCache(pszName);

        //
        // We found the node that we need to refresh
        //
        if (hRetval == S_OK)
        {
            LPSTR pszAnsiName;

            hRetval DBGCHK = UnicodeToAnsiWithAlloc(pszName, &pszAnsiName);
    
            if (SUCCEEDED(hRetval)) 
            {
                TList<TStringNode>  AddressesUsedByCluster;
                TList<TStringNode> *pNewAddresses = new TList<TStringNode>;
                TList<TStringNode> *pNewNames     = new TList<TStringNode>;

                hRetval DBGCHK = pNewAddresses && pNewNames ? S_OK : E_OUTOFMEMORY;

                if (SUCCEEDED(hRetval))
                {
                    //
                    // Get new IPs and names
                    //
                    hRetval DBGCHK = ResolveNameToAddress(pszAnsiName, pNewAddresses, pNewNames);
                    
                    if (SUCCEEDED(hRetval))
                    {
                        //
                        // Check if the local machine has any IPs coming from the cluster service
                        //
                        hRetval DBGCHK = GetClusterIPAddresses(&AddressesUsedByCluster);
    
                        if (SUCCEEDED(hRetval)) 
                        {
                            hRetval DBGCHK = ExcludeIPsUsedByCluster(&AddressesUsedByCluster, pNewAddresses);
                        }
                    }
                    
                    //
                    // Replace current IP and name list for the node with the new IPs and names
                    //
                    if (SUCCEEDED(hRetval))
                    {
                        TResolutionCacheNode *pCacheNode      = NULL;
                        TList<TStringNode>   *pOldIPAddresses = NULL;
                        TList<TStringNode>   *pOldNames       = NULL;

                        m_Lock.Enter();

                        //
                        // Find the node macthing pszName. We need to make sure our node was not deleted while we
                        // were out of the crit sec
                        //
                        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
                        
                        hRetval DBGNOCHK = S_FALSE;
                
                        for (It.First(); !It.IsDone(); It.Next())
                        {
                            hRetval DBGNOCHK = It.Current()->IsSameName(pszName);
                
                            if (hRetval == S_OK)
                            {
                                pCacheNode = It.Current();
                
                                break;
                            }
                        }

                        if (hRetval == S_OK)
                        {
                            pOldIPAddresses = pCacheNode->m_pIPAddresses;
                            pOldNames       = pCacheNode->m_pAlternateNames;
                            
                            pCacheNode->m_pIPAddresses    = pNewAddresses;
                            pCacheNode->m_pAlternateNames = pNewNames;
    
                            //
                            // The node took ownership of the lists
                            //
                            pNewAddresses = NULL;
                            pNewNames     = NULL;
                        }
                        
                        m_Lock.Leave();

                        delete pOldIPAddresses;
                        delete pOldNames;                        
                    }
                }

                delete pNewAddresses;
                delete pNewNames;                               
            }

            delete [] pszAnsiName;
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::AddName

Description:

    Adds a name to the cache. We try adding a name to the cache
    by fining out to which node it belongs. The membership is determined
    based on the IP(s) associated with the server name. If getaddrinfo
    fails on pszName, when we look if the name is an alias to the local 
    machine added with NetServerComputerNameAdd.

Arguments:

    pszName - name to add to the cache

Return Value:

    S_OK   - name was present in the cache or was added
    E_FAIL - the name is an IP and was not added to the cache
    other HRESULT - an error occurred while performing the operation

--*/
HRESULT
TNameResolutionCache::
AddName(
    IN LPCWSTR pszName
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = FindNameInCacheAndAgeOut(pszName);
    
    //
    // Not found in the cache
    //
    if (hRetval == S_FALSE) 
    {
        hRetval DBGCHK = IsIPAddress(pszName);
    
        if (hRetval == S_OK) 
        {
            //
            // We do not add IPs to our cache
            //
            hRetval DBGCHK = E_FAIL;
        }
        else
        {
            LPSTR pszAnsiName;

            hRetval DBGCHK = UnicodeToAnsiWithAlloc(pszName, &pszAnsiName);

            if (SUCCEEDED(hRetval)) 
            {
                //
                // Get IP and alternates names lists
                //
                TList<TStringNode> IPAddresses;
                TList<TStringNode> AlternateNames;
    
                hRetval DBGCHK = ResolveNameToAddress(pszAnsiName, &IPAddresses, &AlternateNames);
    
                if (hRetval == S_OK) 
                {
                    //
                    // We found IP(s) for pszName
                    //
                    hRetval DBGCHK = AddNameUsingIPList(pszName, IPAddresses);
                }
                else if (SCODE_CODE(hRetval) == WSAHOST_NOT_FOUND) 
                {
                    //
                    // Check if the name is an emulated server name
                    //
                    TString AliasedServer;
    
                    hRetval DBGCHK = GetNetBiosInfo(pszAnsiName, &AliasedServer);
    
                    if (hRetval == S_OK) 
                    {
                        hRetval DBGCHK = AddNetBiosName(AliasedServer, pszName);
                    }
                }
                
                delete [] pszAnsiName;
            }
        }
    }

    return hRetval;
}

/*++

Name:

    TNameResolutionCache::AddNetBiosName

Description:

    Searches in the cache the node called pszNode. Then it adds pszAlias to
    the list of supported names. Locks the cache.

Arguments:

    pszNode  - name of node where to add pszAlias
    pszAlias - name to be added to the Alternate names list

Return Value:

    None

--*/
HRESULT
TNameResolutionCache::
AddNetBiosName(
    IN LPCWSTR pszNode,
    IN LPCWSTR pszAlias
    )
{
    TStatusH hRetval;

    TStringNode *pStringNode = new TStringNode(pszAlias);

    hRetval DBGCHK = pStringNode ? pStringNode->Valid() : E_OUTOFMEMORY;
    
    if (SUCCEEDED(hRetval)) 
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        TList<TResolutionCacheNode>::TIterator It(&m_NodeList);
        
        hRetval DBGNOCHK = S_FALSE;

        for (It.First(); !It.IsDone(); It.Next())
        {
            if (It.Current()->IsSameName(pszNode) == S_OK)
            {
                hRetval DBGNOCHK = It.Current()->IsNameInNodeCache(pszAlias);

                //
                // We didn't find the alias in the cache
                //
                if (hRetval == S_FALSE) 
                {
                    hRetval DBGCHK = It.Current()->m_pAlternateNames->AddAtTail(pStringNode);

                    if (SUCCEEDED(hRetval)) 
                    {
                        //
                        // The cache took ownership of the node.
                        //
                        pStringNode = NULL;
                    }
                }
                
                break;
            }
        }
    }

    delete pStringNode;
    
    return hRetval;
}

/*++

Name:

    TNameResolutionCache::AddNameUsingIPList

Description:

    Searches in the cache the node called pszNode. Then it adds pszAdditionalName to
    the list of supported names. Locks the cache.

Arguments:

    pszNode  - name of node where to add pszAlias
    pszAlias - name to be added to the Alternate names list

Return Value:

    None

--*/
HRESULT
TNameResolutionCache::
AddNameUsingIPList(
    IN LPCWSTR             pszAdditionalName,
    IN TList<TStringNode>& pIPAddresses
    )
{
    TStatusH hRetval;

    TStringNode *pStringNode = new TStringNode(pszAdditionalName);

    hRetval DBGCHK = pStringNode ? pStringNode->Valid() : E_OUTOFMEMORY;
    
    if (SUCCEEDED(hRetval)) 
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        TList<TResolutionCacheNode>::TIterator ItCache(&m_NodeList);
        
        //
        // Assume success
        //
        hRetval DBGNOCHK = S_OK;

        //
        // Iterate through the list of nodes
        //
        for (ItCache.First(); !ItCache.IsDone(); ItCache.Next())
        {
            //
            // For each node in the cache we need to see if all the IPs
            // for the name to be added match the IPs of the node
            //
            TList<TStringNode>::TIterator ItAddresses(&pIPAddresses);

            for (ItAddresses.First(); !ItAddresses.IsDone(); ItAddresses.Next()) 
            {
                hRetval DBGCHK = ItCache.Current()->IsNameInNodeCache(ItAddresses.Current()->m_String);

                //
                // For clusters all IPs need to be found in the node's list of IPs
                // For local nodes, one IP must be found in the node's list f IPs
                //
                if (hRetval != S_OK && ItCache.Current()->m_bClusterNode) 
                {
                    break;
                }                
            }

            if (hRetval == S_OK) 
            {
                TStringNode *pExistingNode = NULL;

                //
                // Our IPs match the IPs of the current node. Now we need to make sure a node
                // with the name pszAdditionalName was not added while we were out of the 
                // critical section
                //
                hRetval DBGCHK = ItCache.Current()->GetStringNodeFromName(pszAdditionalName, &pExistingNode);

                if (hRetval == S_OK)
                {
                    //
                    // We do not remove the node in this case, we just update the time.
                    //
                    pExistingNode->m_Time = GetTickCount();                    
                }
                else if (hRetval == S_FALSE)
                {
                    hRetval DBGCHK = ItCache.Current()->m_pAlternateNames->AddAtTail(pStringNode);

                    if (SUCCEEDED(hRetval)) 
                    {
                        //
                        // The cache took ownership of the node.
                        //
                        pStringNode = NULL;
                    }
                }

                break;
            }
        }        
    }

    delete pStringNode;
    
    return hRetval;
}











/*++

Name:

    TStringNode::TStringNode

Description:

    Constructor

Arguments:

    pszString - name of the node

Return Value:

    None

--*/
TStringNode::
TStringNode(
    IN LPCWSTR pszString
    ) 
{
    m_hr = m_String.Update(pszString);

    m_Time = GetTickCount();
}

/*++

Name:

    TStringNode::~TStringNode

Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
TStringNode::
~TStringNode(
    VOID
    )
{
}

/*++

Name:

    TStringNode::Valid

Description:

    Valid

Arguments:

    None

Return Value:

    S_OK         - the object is valid
    any other HR - the object is invalid

--*/
HRESULT
TStringNode::
Valid(
    VOID
    ) const
{
    return m_hr;
}

/*++

Name:

    TStringNode::RefreshTimeStamp

Description:

    Refreshes the time stamp stored in the node

Arguments:

    None

Return Value:

    None

--*/
VOID
TStringNode::
RefreshTimeStamp(
    VOID
    )
{
    m_Time = GetTickCount();
}










/*++

Name:

    TResolutionCacheNode::TResolutionCacheNode

Description:

    CTOR TResolutionCacheNode. The function tries to gather information
    about the server pszName by calling getaddrinfo. 

Arguments:

    None

Return Value:

    None

--*/
TResolutionCacheNode::
TResolutionCacheNode(
    IN LPCWSTR pszName,
    IN BOOL    bClusterNode
    ) : m_bClusterNode(bClusterNode)
{
    m_hr = E_INVALIDARG;

    if (pszName && *pszName) 
    {
        m_hr = m_Name.Update(pszName);

        if (SUCCEEDED(m_hr))
        {
            m_pIPAddresses    = new NCoreLibrary::TList<TStringNode>;
            m_pAlternateNames = new NCoreLibrary::TList<TStringNode>;

            m_hr = m_pIPAddresses && m_pAlternateNames ? S_OK : E_OUTOFMEMORY;
        }
    }    
}

/*++

Name:

    TResolutionCacheNode::~TResolutionCacheNode

Description:

    TResolutionCacheNode

Arguments:

    None

Return Value:

    None

--*/
TResolutionCacheNode::
~TResolutionCacheNode(
    VOID
    )
{  
    delete m_pIPAddresses;
    delete m_pAlternateNames;
}
    
/*++

Name:

    TResolutionCacheNode::Valid

Description:

    Return m_hr.

Arguments:

    None

Return Value:

    S_OK - object is valid
    any other HR - object is not valid

--*/
HRESULT
TResolutionCacheNode::
Valid(
    VOID
    ) const
{
    return m_hr;
}

/*++

Name:

    TResolutionCacheNode::IsSameName

Description:

    Checks if pszName matches the name of the node

Arguments:

    pszName - name to look for in the node name

Return Value:

    S_OK    - same names
    S_FALSE - not same names

--*/
HRESULT
TResolutionCacheNode::
IsSameName(
    IN LPCWSTR pszName
    )
{
    HRESULT hr = S_FALSE;

    if (pszName && *pszName && !_wcsicmp(pszName, m_Name))
    {
        hr = S_OK;
    }

    return hr;
}

/*++

Name:

    TResolutionCacheNode::IsNameInNodeCache

Description:

    Checks if pszName is the IP or in the AlternateNames list for this node

Arguments:

    pszName - name to look for

Return Value:

    S_OK    - pszName found
    S_FALSE - pszName not found
    any other HR - an error occurred

--*/
HRESULT
TResolutionCacheNode::
IsNameInNodeCache(
    IN  LPCWSTR pszName
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = IsSameName(pszName);
    
    if (hRetval == S_FALSE) 
    {
        TList<TStringNode>::TIterator It(m_pIPAddresses);
        
        for (It.First(); !It.IsDone(); It.Next())
        {
            if (!_wcsicmp(pszName, (LPCWSTR)It.Current()->m_String))
            {
                hRetval DBGCHK = S_OK;
                
                break;
            }
        }
    }

    if (hRetval == S_FALSE) 
    {
        //
        // This list can age out
        //
        TList<TStringNode>::TIterator It(m_pAlternateNames);
    
        for (It.First(); !It.IsDone(); It.Next())
        {
            if (!_wcsicmp(pszName, (LPCWSTR)It.Current()->m_String))
            {                
                hRetval DBGCHK = S_OK;
    
                break;
            }
        }
    }

    return hRetval;
}

/*++

Name:

    TResolutionCacheNode::GetStringNodeFromName

Description:

    Checks if pszName is the the AlternateNames list for this node.
    Note: IsNameInNodeCache looks for both AlternateNames and IPs.
    Returns the string node that contains the pszName

Arguments:

    pszName     - name to look for
    pStringNode - pointer to string node containing the pszName

Return Value:

    S_OK    - pszName found
    S_FALSE - pszName not found
    any other HR - an error occurred

--*/
HRESULT
TResolutionCacheNode::
GetStringNodeFromName(
    IN  LPCWSTR       pszName,
    OUT TStringNode **pStringNode
    )
{
    TStatusH hRetval;

    hRetval DBGCHK = pStringNode && pszName ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        //
        // StringNode not found
        //
        hRetval DBGCHK = S_FALSE;
        
        //
        // This list can age out
        //
        TList<TStringNode>::TIterator It(m_pAlternateNames);
        
        for (It.First(); !It.IsDone(); It.Next())
        {
            if (!_wcsicmp(pszName, (LPCWSTR)It.Current()->m_String))
            {
                hRetval DBGCHK = S_OK;

                *pStringNode = It.Current();
        
                break;                
            }
        }
    }

    return hRetval;
}








/*++

Name:

    TFastCache::TFastCache

Description:

    Constructs the fast cache object

Arguments:

    TimeToLive - time to live of an element in the fast cache
    CacheSize  - number of elements in the cache
    MaxStrLen  - maximum length of strings stored in the cache

Return Value:

    None. Call IsValid before using a fast cache object

--*/
TFastCache::
TFastCache(
    IN DWORD TimeToLive,
    IN DWORD CacheSize,
    IN DWORD MaxStrLen
    ) : m_ArraySize(CacheSize),
        m_TTL(TimeToLive),
        m_MaxStrLen(MaxStrLen),
        m_CurrentCount(0)
{
    m_pArray = new TFastCacheElement[m_ArraySize];

    m_hr = m_pArray ? m_Lock.IsValid() : E_OUTOFMEMORY;    
}

/*++

Name:

    TFastCache::~TFastCache

Description:

    Destroys the fast cache object

Arguments:

    None.

Return Value:

    None.

--*/
TFastCache::
~TFastCache(
    VOID
    )
{
    delete [] m_pArray;        
}

/*++

Name:

    TFastCache::IsValid

Description:

    Checks if the object was constructed correctly

Arguments:

    None.

Return Value:

    S_OK - fast cache object can be used
    other HRESULT - do not use the cache

--*/
HRESULT
TFastCache::
IsValid(
    VOID
    )
{
    return m_hr;
}

/*++

Name:

    TFastCache::IsStringInCache

Description:

    Verifies if a string is in the cache. Takes into account the TTL.

Arguments:

    pszString - string to look for. Note that the cache does not 
                accept NULL or "" as valid strings.

Return Value:

    S_OK - pszString is in the cache
    S_FALSE - pszString is not in the cache (or TTL expired)

--*/
HRESULT
TFastCache::
IsStringInCache(
    IN PCSTR pszString
    )
{
    HRESULT hRet = S_FALSE;

    if (pszString && *pszString)
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        DWORD CurrentTick = GetTickCount();

        for (DWORD i = 0; i < m_CurrentCount; i++)
        {
            if (m_pArray[i].m_pszString                       && 
                CurrentTick - m_pArray[i].m_TimeStamp < m_TTL && 
                !_stricmp(pszString, m_pArray[i].m_pszString))
            {
                hRet = S_OK;

                break;
            }
        }    
    }

    return hRet;
}

/*++

Name:

    TFastCache::AddString

Description:

    Adds a string to the cache. Algorithm is explained below.
    
    scan the array
       if we find an emptry spot, put the string there and exit
       else if the string==string in array
                update timestamp and exit
            else if TTL os string in array is expired replace string in array and exit
                 else check how old the timestamp is
    end scan
    if we didn't place the string so far, replace the oldest element in the array                  
    
    
    Note that the function exits as soon as pszString is placed. so the function does not
    eliminate expired elemets after pszString is placed in the right spot.

Arguments:

    pszString - string to add to the cache.

Return Value:

    S_OK - string was added to the cache
    other HRESULT - string was not added to the cache

--*/
HRESULT
TFastCache::
AddString(
    IN PCSTR pszString
    )
{
    HRESULT hRet = E_INVALIDARG;

    if (pszString && *pszString && strlen(pszString) <= m_MaxStrLen)
    {
        NCoreLibrary::TCriticalSection::TLock Lock(m_Lock);

        DWORD CurrentTick     = GetTickCount();
        DWORD OldestElemIndex = 0;
        DWORD OldestAge       = 0;
        
        hRet = S_FALSE;

        for (DWORD i = 0; i < m_CurrentCount; i++)
        {
            if (m_pArray[i].m_pszString)
            {
                if (!_stricmp(pszString, m_pArray[i].m_pszString))
                {
                    m_pArray[i].m_TimeStamp = GetTickCount();

                    hRet = S_OK;

                    break;
                }
                else if (CurrentTick - m_pArray[i].m_TimeStamp > m_TTL)
                {
                    hRet = m_pArray[i].UpdateElement(pszString);

                    break;
                } 
                else if (CurrentTick - m_pArray[i].m_TimeStamp > OldestAge)
                {
                    OldestAge        = CurrentTick - m_pArray[i].m_TimeStamp;
                    OldestElemIndex  = i;
                }                
            }
            else
            {
                hRet = m_pArray[i].UpdateElement(pszString);

                break;
            }
        }

        if (hRet == S_FALSE)
        {
            if (m_CurrentCount < m_ArraySize)
            {
                hRet = m_pArray[m_CurrentCount].UpdateElement(pszString);

                if (SUCCEEDED(hRet))
                {
                    //
                    // Note that we never decrease the value of m_CurrentCount.
                    // For performance reasons, we do not have a function that
                    // checks the timestamps of the elements in the cache and then
                    // eliminates aged elements. Aged elements are always replaced,
                    // but never eliminated. Generally, we won't have more than
                    // a couple of elements in the fast cache, so m_CurrentCount
                    // does help. If you call OpenPrinter/EnumPrinters/etc at the same
                    // time (meaning all calls within a minute or whatever the TTL is) 
                    // on m_ArraySize number of server names which cannot be resolved, 
                    // then the m_CurrentCount would be equal to m_ArraySize and would 
                    // never drop. This scenario is very rare.
                    //
                    m_CurrentCount++;
                }
            }
            else
            {
                hRet = m_pArray[OldestElemIndex].UpdateElement(pszString);
            }
        }        
    }

    return hRet;
}







    


/*++

Name:

    TFastCacheElement::TFastCacheElement

Description:

    CTOR. Initilizes members of element

Arguments:

    None.

Return Value:

    None.

--*/
TFastCacheElement::
TFastCacheElement(
    VOID
    ) : m_pszString(NULL),
        m_TimeStamp(0)
{
}

/*++

Name:

    TFastCacheElement::TFastCacheElement

Description:

    DTOR. Frees the string held by element

Arguments:

    None.

Return Value:

    None.

--*/
TFastCacheElement::
~TFastCacheElement(
    VOID
    )
{
    delete [] m_pszString;
}

/*++

Name:

    TFastCacheElement::UpdateElement

Description:

    Helper function.

Arguments:

    pszString  - string to store in TFastCacheElement
    
Return Value:

    S_OK - pszString was stored in *pElement
    other HRESULT - an error occurred

--*/
HRESULT
TFastCacheElement::
UpdateElement(
    IN PCSTR pszString
    )
{
    HRESULT hRet = S_OK;

    delete [] m_pszString;

    m_pszString = new CHAR[strlen(pszString) + 1];

    if (m_pszString)
    {
        StringCchCopyA(m_pszString, strlen(pszString) + 1, pszString);

        m_TimeStamp = GetTickCount();        
    }
    else
    {
        hRet = E_OUTOFMEMORY;
    }

    return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\nullpp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    NullPP.c

Abstract:

    Implements the NULL print providor.

Author:

    Albert Ting (AlbertT)  16-Feb-95

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
NullOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return ROUTER_UNKNOWN;
}

BOOL
NullOpenPrinterEx(
    LPWSTR              pPrinterName,
    LPHANDLE            phPrinter,
    LPPRINTER_DEFAULTS  pDefault,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return ROUTER_UNKNOWN;
}

BOOL
NullSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    DWORD               dwLevel,
    LPBYTE              pPortInfo
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSetJob(
    HANDLE hPrinter,
    DWORD JobId,
    DWORD Level,
    LPBYTE pJob,
    DWORD Command
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetJob(
    HANDLE   hPrinter,
    DWORD    JobId,
    DWORD    Level,
    LPBYTE   pJob,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


HANDLE
NullAddPrinter(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return NULL;
}


HANDLE
NullAddPrinterEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pClientInfo,
    DWORD   dwLevel
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return NULL;
}


BOOL
NullDeletePrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


BOOL
NullSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


BOOL
NullGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullAddDriverCatalog(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    VOID    *pvDriverInfCatInfo,
    DWORD   dwCatalogCopyFlags
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
NullGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
NullDeletePrinterDriver(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
)
{
    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullAddPerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName,
    LPCWSTR   pPrintServer,
    LPCWSTR   pProvider
)
{
    SetLastError( ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullDeletePerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName
)
{
    SetLastError( ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullEnumPerMachineConnections(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullAddPrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDataypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

DWORD
NullStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return 0;
}

BOOL
NullStartPagePrinter(
    HANDLE  hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEndPagePrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAbortPrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSplDriverUnloadComplete(
    LPWSTR  pDriverFile
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetSpoolFileHandle(
    HANDLE    hPrinter,
    LPWSTR    *pSpoolDir,
    LPHANDLE  phFile,
    HANDLE    hSpoolerProcess,
    HANDLE    hAppProcess)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   cbCommit)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullCloseSpoolFileHandle(
    HANDLE  hPrinter)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEndDocPrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
NullGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
NullGetPrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,        // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,    // address for size of value buffer
    LPDWORD pType,            // address of buffer for type code
    LPBYTE  pData,            // address of buffer for value data
    DWORD   cbData,            // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
NullEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey        // address for size of value buffer
)
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
NullDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    return ERROR_NOT_SUPPORTED;
}



DWORD
NullSetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullWaitForPrinterChange(
    HANDLE hPrinter, DWORD Flags
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return 0;
}

BOOL
NullClosePrinter(
    HANDLE hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeleteForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumMonitors(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumPorts(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddPort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullConfigurePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeletePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

HANDLE
NullCreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW   pDevMode
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return NULL;
}

BOOL
NullPlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeletePrinterIC(
    HANDLE  hPrinterIC
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddPrinterConnection(
    LPWSTR  pName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeletePrinterConnection(
    LPWSTR pName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

DWORD
NullPrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return 0;
}

BOOL
NullAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullDeleteMonitor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullResetPrinter(
    HANDLE hPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


BOOL
NullFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pPrinterNotifyOptions,
    PVOID pPrinterNotifyInit
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullFindClosePrinterChangeNotification(
    HANDLE hPrinter
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}


BOOL
NullAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullShutDown(
    LPVOID pvReserved
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  Reserved,
    PVOID pvReserved,
    PVOID pPrinterNotifyInfo
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWrite
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullFlushPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;    
}

DWORD
NullSendRecvBidiData(
    HANDLE                    hPrinter,
    LPCTSTR                   pAction,
    PBIDI_REQUEST_CONTAINER   pReqData,
    PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    return(ERROR_NOT_SUPPORTED);
}

BOOL
NullClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullClusterSplClose(
    HANDLE  hSpooler
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullClusterSplIsAlive(
    HANDLE hSpooler
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullXcvData(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
        PDWORD  pdwStatus
)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}




//
// Note: If the providor structure changes to hold something other than
// an array of function pointers, FixupOldProvidor must be changed.
// We will get a compile time error in the definition of NullProvidor below
// if the structure changes.
//
PRINTPROVIDOR NullProvidor = {
    NullOpenPrinter,
    NullSetJob,
    NullGetJob,
    NullEnumJobs,
    NullAddPrinter,
    NullDeletePrinter,
    NullSetPrinter,
    NullGetPrinter,
    NullEnumPrinters,
    NullAddPrinterDriver,
    NullEnumPrinterDrivers,
    NullGetPrinterDriver,
    NullGetPrinterDriverDirectory,
    NullDeletePrinterDriver,
    NullAddPrintProcessor,
    NullEnumPrintProcessors,
    NullGetPrintProcessorDirectory,
    NullDeletePrintProcessor,
    NullEnumPrintProcessorDatatypes,
    NullStartDocPrinter,
    NullStartPagePrinter,
    NullWritePrinter,
    NullEndPagePrinter,
    NullAbortPrinter,
    NullReadPrinter,
    NullEndDocPrinter,
    NullAddJob,
    NullScheduleJob,
    NullGetPrinterData,
    NullSetPrinterData,
    NullWaitForPrinterChange,
    NullClosePrinter,
    NullAddForm,
    NullDeleteForm,
    NullGetForm,
    NullSetForm,
    NullEnumForms,
    NullEnumMonitors,
    NullEnumPorts,
    NullAddPort,
    NullConfigurePort,
    NullDeletePort,
    NullCreatePrinterIC,
    NullPlayGdiScriptOnPrinterIC,
    NullDeletePrinterIC,
    NullAddPrinterConnection,
    NullDeletePrinterConnection,
    NullPrinterMessageBox,
    NullAddMonitor,
    NullDeleteMonitor,
    NullResetPrinter,

    //
    // If GetPrinterDriverEx doesn't exist, we'll call the old one.
    // Don't stub out.
    //
    NULL,
    NullFindFirstPrinterChangeNotification,
    NullFindClosePrinterChangeNotification,
    NullAddPortEx,
    NullShutDown,
    NullRefreshPrinterChangeNotification,
    NullOpenPrinterEx,
    NullAddPrinterEx,
    NullSetPort,
    NullEnumPrinterData,
    NullDeletePrinterData,

    NullClusterSplOpen,
    NullClusterSplClose,
    NullClusterSplIsAlive,

    NullSetPrinterDataEx,
    NullGetPrinterDataEx,
    NullEnumPrinterDataEx,
    NullEnumPrinterKey,
    NullDeletePrinterDataEx,
    NullDeletePrinterKey,
    NullSeekPrinter,
    NullDeletePrinterDriverEx,
    NullAddPerMachineConnection,
    NullDeletePerMachineConnection,
    NullEnumPerMachineConnections,
    NullXcvData,
    NullAddPrinterDriverEx,
    NullSplReadPrinter,
    NullSplDriverUnloadComplete,
    NullGetSpoolFileHandle,
    NullCommitSpoolData,
    NullCloseSpoolFileHandle,
    NullFlushPrinter,
    NullSendRecvBidiData,
    NullAddDriverCatalog,
};


VOID
FixupOldProvidor(
    LPPRINTPROVIDOR pProvidor
    )
/*++

Routine Description:

    Fixup the providor function vector, adding stubs to any calls
    that were not implemented by the providor.

Arguments:

    pProvidor - Providor to fix up

Return Value:

Assumes:

    PRINTPROVIDOR structure is an array of function vectors, and
    nothing else.

--*/

{
    UINT i;
    FARPROC* pSource;
    FARPROC* pDest;

    for( i=0, pSource = (FARPROC*)&NullProvidor, pDest = (FARPROC*)pProvidor;
         i < sizeof( NullProvidor ) / sizeof( NullProvidor.fpOpenPrinter );
         i++, pSource++, pDest++ ){

        if( !*pDest ){

            *pDest = *pSource;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\printer.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    printer.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:
    KhaledS - 03/05/02 - New Validate Printer Name

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"
#include "clusrout.h"
#include <offsets.h>


WCHAR szNoCache[] = L",NoCache";
WCHAR szProvidorValue[] = L"Provider";
WCHAR szRegistryConnections[] = L"Printers\\Connections";
WCHAR szServerValue[] = L"Server";

WCHAR szWin32spl[] = L"win32spl.dll";


//
// Router Cache Table
//
DWORD RouterCacheSize;

PROUTERCACHE RouterCacheTable;
CRITICAL_SECTION RouterCriticalSection;


//
// Forward prototypes
//

BOOL
EnumerateConnectedPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HKEY hKeyUser);

PPRINTER_INFO_2
pGetPrinterInfo2(
    HANDLE hPrinter
    );

BOOL
SavePrinterConnectionInRegistry(
    PPRINTER_INFO_2 pPrinterInfo2,
    LPPROVIDOR pProvidor
    );

BOOL
RemovePrinterConnectionInRegistry(
    LPWSTR pName);

DWORD
FindClosePrinterChangeNotificationWorker(
    HANDLE hPrinter);

VOID
RundownPrinterNotify(
    HANDLE hNotify);



BOOL
EnumPrintersW(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DWORD   cReturned, cbStruct, cbNeeded;
    DWORD   TotalcbNeeded = 0;
    DWORD   cTotalReturned = 0;
    DWORD   Error = ERROR_SUCCESS;
    PROVIDOR *pProvidor;
    DWORD   BufferSize=cbBuf;
    HKEY    hKeyUser;
    BOOL    bPartialSuccess = FALSE;

    if (pPrinterEnum==NULL && cbBuf!=0) 
    {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    switch (Level)
    {
    case STRESSINFOLEVEL:
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (Level==4 && (Flags & PRINTER_ENUM_CONNECTIONS)) 
    {
        //
        // The router will handle info level_4 for connected printers.
        //
        Flags &= ~PRINTER_ENUM_CONNECTIONS;

        if (hKeyUser = GetClientUserHandle(KEY_READ)) 
        {
            if (!EnumerateConnectedPrinters(pPrinterEnum,
                                            BufferSize,
                                            &TotalcbNeeded,
                                            &cTotalReturned,
                                            hKeyUser)) 
            {
                Error = GetLastError();
            } 
            else 
            {
                bPartialSuccess = TRUE;
            }

            RegCloseKey(hKeyUser);

        } 
        else 
        {
            Error = GetLastError();
        }

        pPrinterEnum += cTotalReturned * cbStruct;

        if (TotalcbNeeded <= BufferSize)
            BufferSize -= TotalcbNeeded;
        else
            BufferSize = 0;
    }
    
    for (pProvidor = pLocalProvidor; pProvidor; ) 
    {
        cReturned = 0;
        cbNeeded  = 0;

        if (!(*pProvidor->PrintProvidor.fpEnumPrinters) (Flags, Name, Level,
                                                         pPrinterEnum,
                                                         BufferSize,
                                                         &cbNeeded,
                                                         &cReturned)) 
        {
            Error = GetLastError();

            if (Error==ERROR_INSUFFICIENT_BUFFER) 
            {
                TotalcbNeeded += cbNeeded;
                BufferSize     = 0;
            }            
        } 
        else 
        {
            bPartialSuccess  = TRUE;
            TotalcbNeeded   += cbNeeded;
            cTotalReturned  += cReturned;
            pPrinterEnum    += cReturned * cbStruct;
            BufferSize      -= cbNeeded;
        }
        
        if ((Flags & PRINTER_ENUM_NAME) && Name && (Error!=ERROR_INVALID_NAME))
            pProvidor = NULL;
        else
            pProvidor = pProvidor->pNext;
    }

    *pcbNeeded  = TotalcbNeeded;
    *pcReturned = cTotalReturned;

    //
    // Allow partial returns
    //
    if (bPartialSuccess)
        Error = ERROR_SUCCESS;

    if (TotalcbNeeded > cbBuf)
        Error = ERROR_INSUFFICIENT_BUFFER;

    SetLastError(Error);

    return Error==ERROR_SUCCESS;   
}

BOOL
EnumerateConnectedPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HKEY hClientKey
    )

/*++

Routine Description:

    Handles info level four enumeration.

Arguments:

Return Value:

--*/

{
    HKEY    hKey1=NULL;
    HKEY    hKeyPrinter;
    DWORD   cPrinters, cchData;
    WCHAR   PrinterName[MAX_UNC_PRINTER_NAME];
    WCHAR   ServerName[MAX_UNC_PRINTER_NAME];
    DWORD   cReturned, cbRequired, cbNeeded, cTotalReturned;
    DWORD   Error=0;
    PWCHAR  p;
    LPBYTE  pEnd;

    DWORD cbSize;
    BOOL  bInsufficientBuffer = FALSE;

    if((Error = RegOpenKeyEx(hClientKey, szRegistryConnections, 0,
                 KEY_READ, &hKey1))!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        return(FALSE);
    }

    cPrinters=0;

    cchData = COUNTOF(PrinterName);

    cTotalReturned = 0;

    cReturned = cbNeeded = 0;

    cbRequired = 0;

    pEnd = pPrinter + cbBuf;
    while (RegEnumKeyEx(hKey1, cPrinters, PrinterName, &cchData,
                        NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

        //
        // Fetch server name.  Open the key and read it
        // from the "Server" field.
        //
        Error = RegOpenKeyEx(hKey1,
                             PrinterName,
                             0,
                             KEY_READ,
                             &hKeyPrinter);

        if( Error == ERROR_SUCCESS ){

            cbSize = sizeof(ServerName);

            Error = RegQueryValueEx(hKeyPrinter,
                                    szServerValue,
                                    NULL,
                                    NULL,
                                    (LPBYTE)ServerName,
                                    &cbSize);

            RegCloseKey(hKeyPrinter);

        }

        if( Error == ERROR_SUCCESS ){

            //
            // Force NULL termination of ServerName.
            //
            ServerName[COUNTOF(ServerName)-1] = 0;

        } else {

            //
            // On error condition, try and extract the server name
            // based on the printer name.  Pretty ugly...
            //

            StringCchCopy(ServerName, COUNTOF(ServerName), PrinterName);

            p = wcschr(ServerName+2, ',');
            if (p)
                *p = 0;
        }

        FormatRegistryKeyForPrinter(PrinterName, PrinterName, COUNTOF(PrinterName));

        if (MyUNCName(PrinterName))     // don't enumerate local printers!
        {
            cPrinters++;
            cchData = COUNTOF(PrinterName);
            continue;
        }

        //
        // At this stage we don't care about opening the printers
        // We just want to enumerate the names; in effect we're
        // just reading HKEY_CURRENT_USER and returning the
        // contents; we will copy the name of the printer and we will
        // set its attributes to NETWORK and !LOCAL
        //
        cbRequired = sizeof(PRINTER_INFO_4) +
                     wcslen(PrinterName)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(ServerName)*sizeof(WCHAR) + sizeof(WCHAR);

        if (cbBuf >= cbRequired) {

            //
            // copy it in
            //
            DBGMSG(DBG_TRACE,
                   ("cbBuf %d cbRequired %d PrinterName %ws\n", cbBuf, cbRequired, PrinterName));

            pEnd = CopyPrinterNameToPrinterInfo4(ServerName,
                                                 PrinterName,
                                                 pPrinter,
                                                 pEnd);
            //
            // Fill in any in structure contents
            //
            pPrinter += sizeof(PRINTER_INFO_4);

            //
            // Increment the count of structures copied
            //
            cTotalReturned++;

            //
            // Reduce the size of the buffer by amount required
            //
            cbBuf -= cbRequired;

            //
            // Keep track of the total ammount required.
            //
        } else {

            cbBuf = 0;
            bInsufficientBuffer = TRUE;
        }

        cbNeeded += cbRequired;
        cPrinters++;
        cchData = COUNTOF(PrinterName);
    }

    RegCloseKey(hKey1);

    *pcbNeeded = cbNeeded;
    *pcReturned = cTotalReturned;

    if (bInsufficientBuffer) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}

LPBYTE
CopyPrinterNameToPrinterInfo4(
    LPWSTR pServerName,
    LPWSTR pPrinterName,
    LPBYTE  pPrinter,
    LPBYTE  pEnd)
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_4)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPPRINTER_INFO_4 pPrinterInfo=(LPPRINTER_INFO_4)pPrinter;
    DWORD   *pOffsets;

    pOffsets = PrinterInfo4Strings;

    *pSourceStrings++=pPrinterName;
    *pSourceStrings++=pServerName;

    pEnd = PackStrings(SourceStrings,
                       (LPBYTE) pPrinterInfo,
                       pOffsets,
                       pEnd);

    pPrinterInfo->Attributes = PRINTER_ATTRIBUTE_NETWORK;

    return pEnd;
}

LPPROVIDOR
FindProvidorFromConnection(
    LPWSTR pszPrinter
    )

/*++

Routine Description:

    Looks in the current user's Printer\Connections to see if a printer
    is there, and returns which provider that owns it.

    Note: this will always fail if the pszPrinter is a share name.

Arguments:

    pszPrinter - Printer to search.

Return Value:

    pProvidor - Provider that own's it.
    NULL - none found.

--*/

{
    PWCHAR pszKey = NULL;
    DWORD  cchSize = MAX_UNC_PRINTER_NAME + COUNTOF( szRegistryConnections );

    WCHAR szProvidor[MAX_PATH];
    DWORD cbProvidor;
    LPWSTR pszKeyPrinter;
    LONG Status;

    LPPROVIDOR pProvidor = NULL;

    HKEY hKeyClient = NULL;
    HKEY hKeyPrinter = NULL;

    SPLASSERT(pszPrinter);

    if ( pszPrinter && wcslen(pszPrinter) + 1 < MAX_UNC_PRINTER_NAME ) {
        
        if(pszKey = AllocSplMem(cchSize * sizeof(WCHAR))) {

            //
            // Prepare to read in
            // HKEY_CURRENT_USER:\Printer\Connections\,,server,printer
            //

            StringCchCopy( pszKey, cchSize, szRegistryConnections );

            //
            // Find the end of this key so we can append the registry-formatted
            // printer name to it.
            //
            pszKeyPrinter = &pszKey[ COUNTOF( szRegistryConnections ) - 1 ];
            *pszKeyPrinter++ = L'\\';

            FormatPrinterForRegistryKey( pszPrinter, 
                                         pszKeyPrinter, 
                                         cchSize - COUNTOF( szRegistryConnections ) - 1 - 1);

            if( hKeyClient = GetClientUserHandle(KEY_READ)){

                Status = RegOpenKeyEx( hKeyClient,
                                       pszKey,
                                       0,
                                       KEY_READ,
                                       &hKeyPrinter );

                if( Status == ERROR_SUCCESS ){
                    
                    cbProvidor = sizeof( szProvidor );

                    Status = RegQueryValueEx( hKeyPrinter,
                                              szProvidorValue,
                                              NULL,
                                              NULL,
                                              (LPBYTE)szProvidor,
                                              &cbProvidor );

                    if( Status == ERROR_SUCCESS ){                        
                        //
                        // Scan through all providers, trying to match dll string.
                        //
                        for( pProvidor = pLocalProvidor; pProvidor; pProvidor = pProvidor->pNext ){

                            if( !_wcsicmp( pProvidor->lpName, szProvidor )){
                                break;
                            }
                        } 
                    }

                    RegCloseKey( hKeyPrinter );
                }
                
                RegCloseKey( hKeyClient );

            }
            FreeSplMem(pszKey);
        }        
    }

    return pProvidor;
}


VOID
UpdateSignificantError(
    DWORD dwNewError,
    PDWORD pdwOldError
    )
/*++

Routine Description:

    Determines whether the new error code is more "important"
    than the previous one in cases where we continue routing.

Arguments:

    dwNewError - New error code that occurred.

    pdwOldError - Pointer to previous significant error.
                  This is updated if a significant error occurs

Return Value:

--*/

{
    //
    // Error code must be non-zero or else it will look
    // like success.
    //
    SPLASSERT(dwNewError);

    //
    // If we have no significant error yet and we have one now,
    // keep it.
    //
    if (*pdwOldError == ERROR_INVALID_NAME    &&
        dwNewError                            &&
        dwNewError != WN_BAD_NETNAME          &&
        dwNewError != ERROR_BAD_NETPATH       &&
        dwNewError != ERROR_NOT_SUPPORTED     &&
        dwNewError != ERROR_REM_NOT_LIST      &&
        dwNewError != ERROR_INVALID_LEVEL     &&
        dwNewError != ERROR_INVALID_PARAMETER &&
        dwNewError != ERROR_INVALID_NAME      &&
        dwNewError != WN_BAD_LOCALNAME) {

        *pdwOldError = dwNewError;
    }

    return;
}


BOOL
OpenPrinterPortW(
    LPWSTR  pPrinterName,
    HANDLE *pHandle,
    LPPRINTER_DEFAULTS pDefault
    )
/*++

Routine Description:

    This routine is exactly the same as OpenPrinterW,
    except that it doesn't call the local provider.
    This is so that the local provider can open a network printer
    with the same name as the local printer without getting
    into a loop.

Arguments:

Return Value:

--*/

{
    //
    // We will set bLocalPrintProvidor = FALSE here
    //
    return(RouterOpenPrinterW(pPrinterName,
                              pHandle,
                              pDefault,
                              NULL,
                              0,
                              FALSE));
}

BOOL
OpenPrinterW(
    LPWSTR              pPrinterName,
    HANDLE             *pHandle,
    LPPRINTER_DEFAULTS  pDefault
    )
{

    //
    // We will set bLocalPrintProvidor = TRUE here
    //
    return(RouterOpenPrinterW(pPrinterName,
                              pHandle,
                              pDefault,
                              NULL,
                              0,
                              TRUE));
}


BOOL
OpenPrinterExW(
    LPWSTR                  pPrinterName,
    HANDLE                 *pHandle,
    LPPRINTER_DEFAULTS      pDefault,
    PSPLCLIENT_CONTAINER    pSplClientContainer
    )
{
    BOOL   bReturn = FALSE;
    DWORD  dwLevel = 0;

    if (pSplClientContainer) {
        dwLevel = pSplClientContainer->Level;
    }

    //
    // We will set bLocalPrintProvidor = TRUE here
    //

    switch (dwLevel) {

    case 1:
             bReturn = RouterOpenPrinterW(pPrinterName,
                                          pHandle,
                                          pDefault,
                                          (LPBYTE) (pSplClientContainer->ClientInfo.pClientInfo1),
                                          1,
                                          TRUE);
             break;

    case 2:
             bReturn = RouterOpenPrinterW(pPrinterName,
                                          pHandle,
                                          pDefault,
                                          NULL,
                                          0,
                                          TRUE);

             if (pSplClientContainer) {
                 if (bReturn) {
                     pSplClientContainer->ClientInfo.pClientInfo2->hSplPrinter = (ULONG_PTR) *pHandle;
                 } else {
                     pSplClientContainer->ClientInfo.pClientInfo2->hSplPrinter = 0;
                 }
             }

             break;

    default:
             break;
    }

    return bReturn;
}


DWORD
TryOpenPrinterAndCache(
    LPPROVIDOR          pProvidor,
    LPWSTR              pszPrinterName,
    PHANDLE             phPrinter,
    LPPRINTER_DEFAULTS  pDefault,
    PDWORD              pdwFirstSignificantError,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )

/*++

Routine Description:

    Attempt to open the printer using the providor.  If there is
    an error, update the dwFirstSignificantError variable.  If the
    providor "knows" the printer (either a success, or ROUTER_STOP_ROUTING),
    then update the cache.

Arguments:

    pProvidor - Providor to try

    pszPrinterName - Name of printer that will be sent to the providor

    phPrinter - Receives printer handle on ROUTER_SUCCESS

    pDefault - Defaults used to open printer

    pdwFirstSignificantError - Pointer to DWORD to get updated error.
        This gets updated on ROUTER_STOP_ROUTING or ROUTER_UNKNOWN.

Return Value:

    ROUTER_* status code:

    ROUTER_SUCCESS, phPrinter holds return handle, name cached
    ROUTER_UNKNOWN, printer not recognized, error updated
    ROUTER_STOP_ROUTING, printer recognized, but failure, error updated

--*/

{
    DWORD OpenError;

    OpenError = (*pProvidor->PrintProvidor.fpOpenPrinterEx)
                                        (pszPrinterName,
                                         phPrinter,
                                         pDefault,
                                         pSplClientInfo,
                                         dwLevel);

    if (( OpenError == ROUTER_UNKNOWN && GetLastError() == ERROR_NOT_SUPPORTED ) ||
        OpenError == ERROR_NOT_SUPPORTED )

        OpenError = (*pProvidor->PrintProvidor.fpOpenPrinter)
                                        (pszPrinterName,
                                         phPrinter,
                                         pDefault);

    if( OpenError == ROUTER_SUCCESS ||
        OpenError == ROUTER_STOP_ROUTING ){

        //
        // Now add this entry into the cache.  We never cache
        // the local providor.
        //
        EnterRouterSem();

        if (!FindEntryinRouterCache(pszPrinterName)) {
            AddEntrytoRouterCache(pszPrinterName, pProvidor);
        }

        LeaveRouterSem();
    }

    if( OpenError != ROUTER_SUCCESS ){
        UpdateSignificantError(GetLastError(), pdwFirstSignificantError);
    }

    return OpenError;
}

BOOL
RouterOpenPrinterW(
    LPWSTR              pszPrinterNameIn,
    HANDLE             *pHandle,
    LPPRINTER_DEFAULTS  pDefault,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel,
    BOOL                bLocalProvidor
    )

/*++

Routine Description:

    Routes the OpenPrinter{Port} call.  This checks the local providor
    first (if bLocalProvidor TRUE), the the cache, and finally all the
    non-local providors.

    To open a printer, the following steps are taken:

        1. Check localspl
           This must be done to ensure that masq printers are handled
           correctly (see comment below in code).

        2. Check cache
           This will speed up most of the connections, since OpenPrinters
           tend to be clumped together.

        3. Check registry under connections
           If this is a connected printer, first try the providor
           that granted the connection.

        4. Check provider order
           This is the last resort, since it is the slowest.

Arguments:

    pPrinterName - Name of printer to open

    pHandle - Handle to receive open printer.  If the open was not
        successful, this value may be modified!

    pDefault - Default attributes of the open.

    pSplClientInfo - Pointer ClientInfox structure

    dwLevel - Level of the ClientInfo structure
    bLocalProvidor TRUE  = OpenPrinterW called, check localspl first.
                   FALSE = OpenPrinterPortW called, don't check localspl.

Return Value:

    TRUE = success
    FALSE = fail,  GetLastError indicates error (must be non-zero!)

--*/

{
    BOOL bReturn = TRUE;
    DWORD dwFirstSignificantError = ERROR_INVALID_NAME;
    LPPROVIDOR  pProvidor;
    LPPROVIDOR  pProvidorAlreadyTried = NULL;
    PPRINTHANDLE pPrintHandle;
    HANDLE  hPrinter;
    DWORD OpenError;
    BOOL bRemoveFromCache = FALSE;
    PRINTER_DEFAULTS Default;
    PDEVMODE pDevModeFree = NULL;
    PWSTR pszPrinterName = pszPrinterNameIn;
    PWSTR pszNoCache;

    //
    // Max name we allow for printers is MAX_UNC_PRINTER_NAME.
    // Providers can use suffixes only for OpenPrinter (not for Add/Set)
    //
    if ( pszPrinterName &&
         wcslen(pszPrinterName) + 1 > MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX ) {

        SetLastError(ERROR_INVALID_PRINTER_NAME);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    // There may be a ",NoCache" appended to the printer name.
    // We only want to send this NoCache name to win32spl, so make
    // a regular name here.
    if (pszPrinterName) {
        pszNoCache = wcsstr(pszPrinterNameIn, szNoCache);
        if (pszNoCache) {
            pszPrinterName = AllocSplStr(pszPrinterNameIn);

            if (!pszPrinterName) {
                DBGMSG(DBG_WARNING, ("RouterOpenPrinter - Failed to alloc pszPrinterName.\n"));
                return FALSE;
            }
            pszPrinterName[pszNoCache - pszPrinterNameIn] = L'\0';
        }
    }

    pPrintHandle = AllocSplMem(sizeof(PRINTHANDLE));

    if (!pPrintHandle) {

        DBGMSG(DBG_WARNING, ("RouterOpenPrinter - Failed to alloc print handle.\n"));

        if (pszPrinterName != pszPrinterNameIn) {
            FreeSplStr(pszPrinterName);
            pszPrinterName = pszPrinterNameIn;
        }
        return FALSE;
    }

    //
    // Initialize all of the static values here, this is because 
    // FreePrinterHandle assumes that the file handles have a 
    // value of INVALID_HANDLE_VALUE. Which is correct.
    //
    pPrintHandle->signature = PRINTHANDLE_SIGNATURE;
    pPrintHandle->hFileSpooler = INVALID_HANDLE_VALUE;
    pPrintHandle->szTempSpoolFile = NULL;
    pPrintHandle->dwUniqueSessionID = 0;

    if( pszPrinterName ){
        pPrintHandle->pszPrinter = AllocSplStr( pszPrinterName );

        if (!pPrintHandle->pszPrinter) {

            DBGMSG(DBG_WARNING, ("RouterOpenPrinter - Failed to alloc print name.\n"));

            if (pszPrinterName != pszPrinterNameIn) {
                FreeSplStr(pszPrinterName);
                pszPrinterName = pszPrinterNameIn;
            }

            FreePrinterHandle( pPrintHandle );
            return FALSE;
        }
    }

    //
    // Retrieve the per-user DevMode.  This must be done at the router
    // instead of the provider, since the per-user DevMode is only available
    // on the client.  It also must be here instead of client side, since
    // spooler components will make this call also.
    //
    if( !pDefault || !pDefault->pDevMode ){

        //
        // No default specified--get the per-user one.
        //
        if( bGetDevModePerUser( NULL, pszPrinterName, &pDevModeFree ) &&
            pDevModeFree ){

            if( pDefault ){

                Default.pDatatype = pDefault->pDatatype;
                Default.DesiredAccess = pDefault->DesiredAccess;

            } else {

                Default.pDatatype = NULL;
                Default.DesiredAccess = 0;

            }

            Default.pDevMode = pDevModeFree;

            //
            // Now switch to use the temp structure.
            //
            pDefault = &Default;
        }
    }

    //
    // We must check the local print providor first in
    // the masquerading case.
    //
    // For example, when a Netware printer is opened:
    //
    // 1. First OpenPrinter to the Netware printer will succeed
    //    if it has been cached.
    //
    // 2. We create a local printer masquerading as a network printer.
    //
    // 3. Second OpenPrinter must open local masquerading printer.
    //    If we hit the cache, we will go to the Netware providor,
    //    and we will never use the masquerading printer.
    //
    // For this reason, we will not cache local printers in the
    // RouterCache.  The RouterCache will only containing Network
    // Print Providers, i.e., Win32spl NwProvAu and other such providers.
    //
    // Also, we must always check the local printprovidor since
    // DeletePrinter will be called on a false connect and
    // we need to delete the local network printer rather
    // than the remote printer.  When we get rid of the false
    // connect case, we go directly to the cache.
    //
    if (bLocalProvidor) {

        pProvidor = pLocalProvidor;

        OpenError = (*pProvidor->PrintProvidor.fpOpenPrinterEx)
                        (pszPrinterName, &hPrinter, pDefault,
                         pSplClientInfo, dwLevel);

        if (OpenError == ROUTER_SUCCESS) {
            goto Success;
        }

        UpdateSignificantError(GetLastError(), &dwFirstSignificantError);

        if (OpenError == ROUTER_STOP_ROUTING) {
            goto StopRouting;
        }
    }

    //
    // Now check the cache.
    //
    EnterRouterSem();
    pProvidor = FindEntryinRouterCache(pszPrinterName);
    LeaveRouterSem();

    if (pProvidor) {

        OpenError = (*pProvidor->PrintProvidor.fpOpenPrinterEx)
                                (pszPrinterName,
                                 &hPrinter,
                                 pDefault,
                                 pSplClientInfo,
                                 dwLevel);

        if (( OpenError == ROUTER_UNKNOWN && GetLastError() == ERROR_NOT_SUPPORTED ) ||
              OpenError == ERROR_NOT_SUPPORTED ){

            OpenError = (*pProvidor->PrintProvidor.fpOpenPrinter)
                                (pszPrinterName,
                                 &hPrinter,
                                 pDefault);
        }

        if (OpenError == ROUTER_SUCCESS) {
            goto Success;
        }

        UpdateSignificantError(GetLastError(), &dwFirstSignificantError);

        if (OpenError == ROUTER_STOP_ROUTING) {
            goto StopRouting;
        }

        //
        // Wasn't claimed by above providor, so remove from cache.
        // If a providor returns ROUTER_STOP_ROUTING, then it states
        // that it is the sole owner of the printer name (i.e.,
        // it has been recognized but can't be opened, and can't
        // be accessed by other providors).  Therefore we keep
        // it in the cache.
        //
        bRemoveFromCache = TRUE;

        //
        // Don't try this providor again below.
        //
        pProvidorAlreadyTried = pProvidor;
    }

    //
    // Not in the cache.  Check if it is in the registry under
    // connections.
    //
    pProvidor = FindProvidorFromConnection( pszPrinterName );

    //
    // If we want to remove it from the cache, do so here.  Note
    // we only remove it if we failed above, AND the connection wasn't
    // originally established using the provider.
    //
    // If the connection fails, but that provider "owns" the printer
    // connection, leave it in the cache since we won't try other providers.
    //
    if( bRemoveFromCache && pProvidor != pProvidorAlreadyTried ){

        EnterRouterSem();
        DeleteEntryfromRouterCache(pszPrinterName);
        LeaveRouterSem();
    }

    if( pProvidor ){

        //
        // If we already tried this providor, don't try it again.
        //
        if( pProvidor != pProvidorAlreadyTried ){

            OpenError = TryOpenPrinterAndCache( pProvidor,
                                                pszPrinterName,
                                                &hPrinter,
                                                pDefault,
                                                &dwFirstSignificantError,
                                                pSplClientInfo,
                                                dwLevel);

            if( OpenError == ROUTER_SUCCESS ){
                goto Success;
            }
        }

        //
        // We stop routing at this point!  If a user wants to go with
        // another providor, they need to remove the connection then
        // re-establish it.
        //
        goto StopRouting;
    }

    //
    // Check all non-localspl providors.
    //
    for (pProvidor = pLocalProvidor->pNext;
         pProvidor;
         pProvidor = pProvidor->pNext) {

        if( pProvidor == pProvidorAlreadyTried ){

            //
            // We already tried this providor, and it failed.
            //
            continue;
        }

        // Use ",NoCache" only if Provider is win32spl
        OpenError = TryOpenPrinterAndCache( pProvidor,
                                            _wcsicmp(pProvidor->lpName, szWin32spl) ?
                                            pszPrinterName : pszPrinterNameIn,
                                            &hPrinter,
                                            pDefault,
                                            &dwFirstSignificantError,
                                            pSplClientInfo,
                                            dwLevel);

        switch( OpenError ) {
            case ROUTER_SUCCESS:
                goto Success;
            case ROUTER_STOP_ROUTING:
                goto StopRouting;
        }
    }

StopRouting:

    //
    // Did not find a providor, return the error.
    //
    FreePrinterHandle( pPrintHandle );

    //
    // Set using first significant error.  If there was no signifcant
    // error, we use ERROR_INVALID_PRINTER_NAME.
    //
    SPLASSERT(dwFirstSignificantError);

    if (dwFirstSignificantError == ERROR_INVALID_NAME)
        dwFirstSignificantError = ERROR_INVALID_PRINTER_NAME;

    SetLastError(dwFirstSignificantError);

    bReturn = FALSE;

Success:

    //
    // At this point we know the provider and the printer handle.
    // 
    if( bReturn ){

        pPrintHandle->pProvidor = pProvidor;
        pPrintHandle->hPrinter = hPrinter;

        *pHandle = (HANDLE)pPrintHandle;
    }

    FreeSplMem( pDevModeFree );

    if (pszPrinterName != pszPrinterNameIn)
        FreeSplStr(pszPrinterName);

    return bReturn;
}


BOOL
ResetPrinterW(
    HANDLE  hPrinter,
    LPPRINTER_DEFAULTS pDefault)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pDefault) {
        if (pDefault->pDatatype == (LPWSTR)-1 ||
            pDefault->pDevMode == (LPDEVMODE)-1) {

            if (!wcscmp(pPrintHandle->pProvidor->lpName, szLocalSplDll)) {
                return (*pPrintHandle->pProvidor->PrintProvidor.fpResetPrinter)
                                                            (pPrintHandle->hPrinter,
                                                             pDefault);
            } else {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        } else {
            return (*pPrintHandle->pProvidor->PrintProvidor.fpResetPrinter)
                                                        (pPrintHandle->hPrinter,
                                                         pDefault);
        }
    } else {
        return (*pPrintHandle->pProvidor->PrintProvidor.fpResetPrinter)
                                                    (pPrintHandle->hPrinter,
                                                     pDefault);
    }
}

HANDLE
AddPrinterExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pClientInfo,
    DWORD   dwLevel
    )
{
    LPPROVIDOR      pProvidor;
    DWORD           dwFirstSignificantError = ERROR_INVALID_NAME;
    HANDLE          hPrinter;
    PPRINTHANDLE    pPrintHandle;
    LPWSTR          pPrinterName = NULL;
    LPWSTR          pszServer = NULL;

    WaitForSpoolerInitialization();

    if ( pPrinter ) {

        switch ( Level ) {

            case 1:
                pPrinterName = ((PPRINTER_INFO_1)pPrinter)->pName;
                break;

            case 2:
                pPrinterName = ((PPRINTER_INFO_2)pPrinter)->pPrinterName;
                pszServer = ((PPRINTER_INFO_2)pPrinter)->pServerName;
                break;

            default:
                break;
        }

        //
        // Name length (plus null terminator) and server
        // name (plus backslash) length check.
        //
        if (( pPrinterName && wcslen(pPrinterName) + 1 > MAX_PRINTER_NAME ) ||
            ( pszServer && wcslen(pszServer) > (MAX_UNC_PRINTER_NAME - MAX_PRINTER_NAME - 1))) {

            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }
    }

    pPrintHandle = AllocSplMem(sizeof(PRINTHANDLE));

    if (!pPrintHandle) {

        DBGMSG( DBG_WARNING, ("Failed to alloc print handle."));
        goto Fail;
    }

    if( pPrinterName ){

        WCHAR szFullPrinterName[MAX_UNC_PRINTER_NAME];
        szFullPrinterName[0] = 0;

        if( pszServer ){
            StrNCatBuff(szFullPrinterName,
                        MAX_UNC_PRINTER_NAME,
                        pszServer,
                        L"\\",
                        NULL);
        }

        StringCchCat( szFullPrinterName, 
                      MAX_UNC_PRINTER_NAME,
                      pPrinterName );

        pPrintHandle->pszPrinter = AllocSplStr( szFullPrinterName );

        if( !pPrintHandle->pszPrinter ){
            goto Fail;
        }
    }

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        hPrinter = (HANDLE)(*pProvidor->PrintProvidor.fpAddPrinterEx)
                                           (pName,
                                            Level,
                                            pPrinter,
                                            pClientInfo,
                                            dwLevel);

        if ( !hPrinter && GetLastError() == ERROR_NOT_SUPPORTED ) {

            hPrinter = (HANDLE)(*pProvidor->PrintProvidor.fpAddPrinter)
                                                   (pName,
                                                    Level,
                                                    pPrinter);
        }

        if ( hPrinter ) {

            //
            // CLS
            //
            // !! HACK !!
            //
            // Make (HANDLE)-1 ROUTER_STOP_ROUTING.
            //
            if( hPrinter == (HANDLE)-1 ){

                UpdateSignificantError(GetLastError(), &dwFirstSignificantError);
                break;
            }

            pPrintHandle->signature = PRINTHANDLE_SIGNATURE;
            pPrintHandle->pProvidor = pProvidor;
            pPrintHandle->hPrinter = hPrinter;
            pPrintHandle->hFileSpooler = INVALID_HANDLE_VALUE;
            pPrintHandle->szTempSpoolFile = NULL;
            pPrintHandle->dwUniqueSessionID = 0;

            return (HANDLE)pPrintHandle;

        }

        UpdateSignificantError(GetLastError(), &dwFirstSignificantError);

        pProvidor = pProvidor->pNext;
    }

    UpdateSignificantError(ERROR_INVALID_PRINTER_NAME, &dwFirstSignificantError);
    SetLastError(dwFirstSignificantError);

Fail:

    if( pPrintHandle ){

        FreeSplStr( pPrintHandle->pszPrinter );
        FreeSplMem(pPrintHandle);
    }

    return FALSE;
}

HANDLE
AddPrinterW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter
    )
{

    return AddPrinterExW(pName, Level, pPrinter, NULL, 0);
}


BOOL
DeletePrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinter)(pPrintHandle->hPrinter);
}

BOOL
AddPrinterConnectionW(
    LPWSTR  pName
)
{
    DWORD dwLastError;
    HANDLE hPrinter;
    HKEY   hClientKey = NULL;
    BOOL   rc = FALSE;
    LPPRINTER_INFO_2 pPrinterInfo2;
    LPPRINTHANDLE  pPrintHandle;

    WaitForSpoolerInitialization();

    //
    // If the printer connection being made is \\server\sharename,
    // this may be different from the \\server\printername.
    // Make sure we have the real name, so that we can be consistent
    // in the registry.
    //
    if (!OpenPrinter(pName,
                     &hPrinter,
                     NULL)) {

        return FALSE;
    }

    pPrinterInfo2 = pGetPrinterInfo2( hPrinter );
    pPrintHandle = (LPPRINTHANDLE)hPrinter;

    if( pPrinterInfo2 ){

        if ((*pPrintHandle->pProvidor->PrintProvidor.
            fpAddPrinterConnection)(pPrinterInfo2->pPrinterName)) {

            if( SavePrinterConnectionInRegistry(
                pPrinterInfo2,
                pPrintHandle->pProvidor )){

                rc = TRUE;

            } else {

                dwLastError = GetLastError();
                (*pPrintHandle->pProvidor->PrintProvidor.
                    fpDeletePrinterConnection)(pPrinterInfo2->pPrinterName);

                SetLastError(dwLastError);
            }
        }
        FreeSplMem(pPrinterInfo2);
    }

    dwLastError = GetLastError();
    ClosePrinter(hPrinter);
    SetLastError(dwLastError);

    return rc;
}


BOOL
DeletePrinterConnectionW(
    LPWSTR  pName
)
{
    BOOL                bRet  = FALSE;
    BOOL                bDone = FALSE;
    HANDLE              hPrinter;

    //
    // If pName is empty string, all providers will fail with ERROR_INVALID_NAME
    // and we will delete the registry key. For empty string, it will
    // delete all subkeys under Printers\\Connections. Fix it by checking 
    // pName against empty string.
    //
    if (pName && *pName) 
    {
        WaitForSpoolerInitialization();

        //
        // Adding the code required to succeed DeletePrinterConnection
        // with a Share name
        //

        if(OpenPrinter(pName,&hPrinter,NULL))
        {
            DWORD            PrntrInfoSize=0,PrntrInfoSizeReq=0;
            PPRINTER_INFO_2  pPrinterInfo2 = NULL;

            if(!GetPrinter(hPrinter,
                           2,
                           (LPBYTE)pPrinterInfo2,
                           PrntrInfoSize,
                           &PrntrInfoSizeReq)                                                      &&
               (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                                       &&
               (pPrinterInfo2 = (PPRINTER_INFO_2)AllocSplMem((PrntrInfoSize = PrntrInfoSizeReq)))  &&
               GetPrinter(hPrinter,
                          2,
                          (LPBYTE)pPrinterInfo2,
                          PrntrInfoSize,
                          &PrntrInfoSizeReq))
            {
                PPRINTHANDLE pPrintHandle;
                pPrintHandle = (PPRINTHANDLE)hPrinter;

                if((bRet = (*pPrintHandle->
                           pProvidor->
                           PrintProvidor.
                           fpDeletePrinterConnection)(pPrinterInfo2->pPrinterName)))
                {
                    bRet  = RemovePrinterConnectionInRegistry(pPrinterInfo2->pPrinterName);
                    bDone = TRUE;
                }
            }

            if(hPrinter)
                ClosePrinter(hPrinter);

            if(pPrinterInfo2)
                FreeSplMem(pPrinterInfo2);
        }
        else
        {
            LPPROVIDOR pProvidor;
            pProvidor = pLocalProvidor;

            if (pName && (wcslen(pName) < MAX_PRINTER_NAME))
            {
                for(pProvidor=pLocalProvidor;
                    pProvidor && (GetLastError()!=ERROR_INVALID_NAME) &&!bDone;
                    pProvidor = pProvidor->pNext)

                {

                    if(bRet =  (*pProvidor->PrintProvidor.fpDeletePrinterConnection)(pName))
                    {
                        bRet = RemovePrinterConnectionInRegistry(pName);
                        bDone = TRUE;
                    }
                }
            }
            else
            {
                SetLastError(ERROR_INVALID_PRINTER_NAME);
                bDone = TRUE;
            }

        }

        //
        // If all providors failed with ERROR_INVALID_NAME then try to delete
        // from registry
        //
        if(!bDone && (GetLastError()==ERROR_INVALID_NAME))
        {
            if(!(bRet = RemovePrinterConnectionInRegistry(pName)))
            {
                SetLastError(ERROR_INVALID_PRINTER_NAME);
            }
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PRINTER_NAME);
    }
    
    return bRet;
}

BOOL
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;
    LPWSTR          pPrinterName = NULL;
    PDEVMODE        pDevModeRestore = NULL;
    BOOL bReturn;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ( pPrinter ) {

        switch (Level) {
            case 2:
                pPrinterName = ((PPRINTER_INFO_2)pPrinter)->pPrinterName;
                break;

            case 4:
                pPrinterName = ((PPRINTER_INFO_4)pPrinter)->pPrinterName;
                break;

            case 5:
                pPrinterName = ((PPRINTER_INFO_5)pPrinter)->pPrinterName;
                break;
        }

        if ( pPrinterName &&
             wcslen(pPrinterName) + 1 > MAX_PRINTER_NAME ) {

            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }
    }

    switch( Level ){
    case 8:
    {
        //
        // Setting the global DevMode.
        //
        PPRINTER_INFO_8 pPrinterInfo8 = (PPRINTER_INFO_8)pPrinter;
        PPRINTER_INFO_2 pPrinterInfo2;
        DWORD rc = FALSE;;

        if( Command != 0 ){
            SetLastError( ERROR_INVALID_PRINTER_COMMAND );
            return FALSE;
        }

        //
        // Call GetPrinter then SetPrinter.
        //
        pPrinterInfo2 = pGetPrinterInfo2( hPrinter );

        if( pPrinterInfo2 ){

            //
            // Set the DevMode, and also clear the security descriptor
            // so that the set will succeed.
            //
            pPrinterInfo2->pDevMode = pPrinterInfo8->pDevMode;
            pPrinterInfo2->pSecurityDescriptor = NULL;

            rc = (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinter) (
                     pPrintHandle->hPrinter,
                     2,
                     (PBYTE)pPrinterInfo2,
                     Command );

            FreeSplMem( pPrinterInfo2 );
        }

        return rc;
    }
    case 9:
    {
        PPRINTER_INFO_9 pPrinterInfo9 = (PPRINTER_INFO_9)pPrinter;
        
        //
        // Setting the per-user DevMode.
        //

        if( !pPrinter ){
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if( Command != 0 ){
            SetLastError( ERROR_INVALID_PRINTER_COMMAND );
            return FALSE;
        }

        if (S_OK != CheckLocalCall()) {
            SetLastError(ERROR_NOT_SUPPORTED);
            return FALSE;
        }
        
        return bSetDevModePerUser( NULL,
                                   pPrintHandle->pszPrinter,
                                   pPrinterInfo9->pDevMode );
    }
    case 2:
    {
        PPRINTER_INFO_2 pPrinterInfo2 = (PPRINTER_INFO_2)pPrinter;

        if( S_OK == CheckLocalCall() ){

            if( pPrinterInfo2 && pPrinterInfo2->pDevMode ){
                bSetDevModePerUser( NULL,
                                    pPrintHandle->pszPrinter,
                                    pPrinterInfo2->pDevMode );

                //
                // Don't set the global DevMode.
                //
                pDevModeRestore = pPrinterInfo2->pDevMode;
                pPrinterInfo2->pDevMode = NULL;
            }
        }
    }
    default:
        break;
    }

    bReturn = (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinter)
                  (pPrintHandle->hPrinter, Level, pPrinter, Command);

    if( pDevModeRestore ){
        ((PPRINTER_INFO_2)pPrinter)->pDevMode = pDevModeRestore;
    }

    return bReturn;
}

BOOL
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    PDEVMODE pDevModeSrc = NULL;
    PDEVMODE pDevModeDest = NULL;
    PDEVMODE pDevModeFree = NULL;
    BOOL bCallServer = TRUE;
    BOOL bReturnValue = FALSE;
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    DWORD cbDevModeSrc;
    DWORD Error;
    DWORD cbExtraSpace2 = 0;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pPrinter == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    switch( Level ){
    case 2:

        if( pPrintHandle->pszPrinter && S_OK == CheckLocalCall()){

            bGetDevModePerUser( NULL,
                                pPrintHandle->pszPrinter,
                                &pDevModeFree );

            if( pDevModeFree ){

                pDevModeSrc = pDevModeFree;

                cbDevModeSrc = pDevModeSrc->dmSize +
                               pDevModeSrc->dmDriverExtra;

                cbExtraSpace2 = DWORD_ALIGN_UP( cbDevModeSrc );
                cbBuf = DWORD_ALIGN_DOWN( cbBuf );
            }
        }
        break;

    case 8:
    {
        PPRINTER_INFO_8 pPrinterInfo8 = (PPRINTER_INFO_8)pPrinter;

        //
        // Handle info level 8 calls for global DevModes.
        //
        if( !pPrintHandle->pszPrinter ){

            SetLastError( ERROR_FILE_NOT_FOUND );
            return FALSE;
        }

        bCallServer = FALSE;
        *pcbNeeded = sizeof( PRINTER_INFO_8 );

        //
        // Call GetPrinter to get the real DevMode.
        //
        pPrinterInfo2 = pGetPrinterInfo2( hPrinter );

        if( pPrinterInfo2 ){

            //
            // Pickup the DevMode from pPrinterInfo2;
            // destination is after the pDevModeStructure.
            // Don't need to free pDevModeSrc since it will be
            // freed when pPrinterInfo2 is released.
            //
            pDevModeSrc = pPrinterInfo2->pDevMode;

            if( pDevModeSrc ){

                cbDevModeSrc = pDevModeSrc->dmSize +
                               pDevModeSrc->dmDriverExtra;

                *pcbNeeded += cbDevModeSrc;
            }

            if( cbBuf < *pcbNeeded ){

                //
                // Not enough space.  SetLastError and fall through
                // to the end.
                //
                SetLastError( ERROR_INSUFFICIENT_BUFFER );

            } else {

                bReturnValue = TRUE;

                if( pDevModeSrc ){

                    //
                    // Update the pointer and indicate via pDevModeDest
                    // that we need to copy the DevMode in.
                    //
                    pDevModeDest = (PDEVMODE)&pPrinterInfo8[1];
                    pPrinterInfo8->pDevMode = pDevModeDest;

                } else {

                    //
                    // No DevMode, return pointer to NULL.
                    //
                    pPrinterInfo8->pDevMode = NULL;
                }
            }
        }

        break;
    }
    case 9:
    {
        //
        // Per-user DevMode.  Use the client side one.
        //

        PPRINTER_INFO_9 pPrinterInfo9 = (PPRINTER_INFO_9)pPrinter;

        if( !pPrintHandle->pszPrinter ){
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        if( S_OK != CheckLocalCall( )){

            SetLastError( ERROR_NOT_SUPPORTED );
            return FALSE;
        }

        bCallServer = FALSE;

        *pcbNeeded = sizeof( PRINTER_INFO_9 );

        if( bGetDevModePerUserEvenForShares( NULL,
                                             pPrintHandle->pszPrinter,
                                             &pDevModeFree )){

            pDevModeSrc = pDevModeFree;

            if( pDevModeSrc ){

                cbDevModeSrc = pDevModeSrc->dmSize +
                               pDevModeSrc->dmDriverExtra;

                *pcbNeeded += cbDevModeSrc;
            }
        }

        if( cbBuf < *pcbNeeded ){

            //
            // Not enough space.  We'll fall through below
            // and fail.
            //
            SetLastError( ERROR_INSUFFICIENT_BUFFER );

        } else {

            bReturnValue = TRUE;

            if( pDevModeSrc ){

                pDevModeDest = (PDEVMODE)&pPrinterInfo9[1];
                pPrinterInfo9->pDevMode = pDevModeDest;

            } else {

                //
                // No per-user DevMode.  Return SUCCESS, but indicate
                // no DevMode available.
                //
                pPrinterInfo9->pDevMode = NULL;
            }
        }
        break;
    }
    default:
        break;
    }

    if( bCallServer ){

        DWORD cbAvailable;

        //
        // Allocate extra space at the end for the per-user DevMode,
        // in case there isn't a global devmode in the printer info 2
        // structure.
        //
        cbAvailable = ( cbBuf >= cbExtraSpace2 ) ?
                          cbBuf - cbExtraSpace2 :
                          0;

        bReturnValue = (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinter)
                           (pPrintHandle->hPrinter, Level, pPrinter,
                            cbAvailable, pcbNeeded);

        *pcbNeeded += cbExtraSpace2;
    }

    Error = GetLastError();

    if( Level == 9 && pDevModeSrc == NULL){

        PPRINTER_INFO_2 pInfo2 = (PPRINTER_INFO_2)pPrinter;

        if( pInfo2 && pInfo2->pDevMode ){

            pDevModeSrc = pInfo2->pDevMode;

        }
    }

    //
    // Special case INFO level 2, since we want to get the provider's
    // information, but then we also want the per-user DevMode.
    //
    // Only do this for local calls.
    //
    if( cbExtraSpace2 ){

        PPRINTER_INFO_2 pInfo2 = (PPRINTER_INFO_2)pPrinter;

        //
        // If we succeeded and we have a buffer, then we need to check if we
        // need to put the per-user DevMode at the end of the buffer.
        //
        if( pInfo2 && bReturnValue ){

            //
            // If we have no DevMode, or it's compatible, then we want to
            // use the per-user DevMode.
            //
            if( !pInfo2->pDevMode ||
                bCompatibleDevMode( pPrintHandle,
                                    pInfo2->pDevMode,
                                    pDevModeSrc )){

                pDevModeDest = (PDEVMODE)(pPrinter + cbBuf - cbExtraSpace2 );
                pInfo2->pDevMode = pDevModeDest;

            } else {

                //
                // !! POLICY !!
                //
                // Not compatible with per-user DevMode.  Delete the
                // per-user one.
                //
                bSetDevModePerUser( NULL, pPrintHandle->pszPrinter, NULL );
            }
        }
    }

    //
    // Check if we need to copy over a DevMode.
    //
    if( pDevModeDest ){

        //
        // Update the DevMode.
        //
        CopyMemory( (PVOID)pDevModeDest,
                    (PVOID)pDevModeSrc,
                    cbDevModeSrc );

        bReturnValue = TRUE;
    }

    FreeSplMem( pDevModeFree );
    FreeSplMem( pPrinterInfo2 );

    SetLastError( Error );

    return bReturnValue;
}


DWORD
GetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterData)(pPrintHandle->hPrinter,
                                                        pValueName,
                                                        pType,
                                                        pData,
                                                        nSize,
                                                        pcbNeeded);
}

DWORD
GetPrinterDataExW(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDataEx)(pPrintHandle->hPrinter,
                                                        pKeyName,
                                                        pValueName,
                                                        pType,
                                                        pData,
                                                        nSize,
                                                        pcbNeeded);
}

DWORD
EnumPrinterDataW(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,        // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,    // address for size of value buffer
    LPDWORD pType,            // address of buffer for type code
    LPBYTE  pData,            // address of buffer for value data
    DWORD   cbData,            // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumPrinterData)(pPrintHandle->hPrinter,
                                                        dwIndex,
                                                        pValueName,
                                                        cbValueName,
                                                        pcbValueName,
                                                        pType,
                                                        pData,
                                                        cbData,
                                                        pcbData);
}

DWORD
EnumPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumPrinterDataEx)(pPrintHandle->hPrinter,
                                                        pKeyName,
                                                        pEnumValues,
                                                        cbEnumValues,
                                                        pcbEnumValues,
                                                        pnEnumValues);
}


DWORD
EnumPrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey        // address for size of value buffer
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumPrinterKey)(pPrintHandle->hPrinter,
                                                        pKeyName,
                                                        pSubkey,
                                                        cbSubkey,
                                                        pcbSubkey);
}



DWORD
DeletePrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinterData)(pPrintHandle->hPrinter,
                                                                         pValueName);
}


DWORD
DeletePrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinterDataEx)(pPrintHandle->hPrinter,
                                                                         pKeyName,
                                                                         pValueName);
}


DWORD
DeletePrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinterKey)(pPrintHandle->hPrinter,
                                                                        pKeyName);

}



DWORD
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinterData)(pPrintHandle->hPrinter,
                                                        pValueName,
                                                        Type,
                                                        pData,
                                                        cbData);
}


DWORD
SetPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinterDataEx)(pPrintHandle->hPrinter,
                                                                        pKeyName,
                                                                        pValueName,
                                                                        Type,
                                                                        pData,
                                                                        cbData);
}



DWORD
WaitForPrinterChange(
   HANDLE   hPrinter,
   DWORD    Flags
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpWaitForPrinterChange)
                                        (pPrintHandle->hPrinter, Flags);
}

BOOL
ClosePrinter(
   HANDLE hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    EnterRouterSem();

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        LeaveRouterSem();
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Close any notifications on this handle.
    //
    // The local case cleans up the event, while the remote
    // case potentially cleans up the Reply Notification context
    // handle.
    //
    // We must close this first, since the Providor->ClosePrinter
    // call removes data structures that FindClose... relies on.
    //
    // Client side should be shutdown by winspool.drv.
    //
    if (pPrintHandle->pChange &&
        (pPrintHandle->pChange->eStatus & STATUS_CHANGE_VALID)) {

        FindClosePrinterChangeNotificationWorker(hPrinter);
    }

    LeaveRouterSem();

    if ((*pPrintHandle->pProvidor->PrintProvidor.fpClosePrinter) (pPrintHandle->hPrinter)) {

        //
        // We can't just free it, since there may be a reply waiting
        // on it.
        //
        FreePrinterHandle(pPrintHandle);
        return TRUE;

    } else

        return FALSE;
}



/* FormatPrinterForRegistryKey
 *
 * Returns a pointer to a copy of the source string with backslashes removed.
 * This is to store the printer name as the key name in the registry,
 * which interprets backslashes as branches in the registry structure.
 * Convert them to commas, since we don't allow printer names with commas,
 * so there shouldn't be any clashes.
 * If there are no backslashes, the string is unchanged.
 */
LPWSTR
FormatPrinterForRegistryKey(
    LPCWSTR pSource,       /* The string from which backslashes are to be removed. */
    LPWSTR  pScratch,      /* Scratch buffer for the function to write in;     */
    DWORD   cchScratchLen  /* must be at least as long as pSource.             */
    )                   
{
    LPWSTR p;

    if (pScratch != pSource) {

        //
        // Copy the string into the scratch buffer:
        //
        StringCchCopy(pScratch, cchScratchLen, pSource);
    }

    //
    // Check each character, and, if it's a backslash,
    // convert it to a comma:
    //
    for (p = pScratch; *p; ++p) {
        if (*p == L'\\')
            *p = L',';
    }

    return pScratch;
}


/* FormatRegistryKeyForPrinter
 *
 * Returns a pointer to a copy of the source string with backslashes added.
 * This must be the opposite of FormatPrinterForRegistryKey, so the mapping
 * _must_ be 1-1.
 *
 * If there are no commas, the string is unchanged.
 */
LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,      /* The string from which backslashes are to be added. */
    LPWSTR pScratch,     /* Scratch buffer for the function to write in;     */
    DWORD  cchScratchLen /* must be at least as long as pSource.             */
    )
{
    LPWSTR p;

    if (pScratch != pSource) 
    {
        StringCchCopy(pScratch, cchScratchLen, pSource);
    }

    //
    // Check each character, and, if it's a backslash, convert it to a comma:
    //
    for (p = pScratch; *p; p++) 
    {
        if (*p == L',')
        {    
            *p = L'\\';
        }
    }

    return pScratch;
}


/* SavePrinterConnectionInRegistry
 *
 * Saves data in the registry for a printer connection.
 * Creates a key under the current impersonation client's key
 * in the registry under \Printers\Connections.
 * The printer name is stripped of backslashes, since the registry
 * API does not permit the creation of keys with backslashes.
 * They are replaced by commas, which are invalid characters
 * in printer names, so we should never get one passed in.
 *
 *
 * *** WARNING ***
 *
 * IF YOU MAKE CHANGES TO THE LOCATION IN THE REGISTRY
 * WHERE PRINTER CONNECTIONS ARE STORED, YOU MUST MAKE
 * CORRESPONDING CHANGES IN USER\USERINIT\USERINIT.C.
 *
 */
BOOL
SavePrinterConnectionInRegistry(
    PPRINTER_INFO_2 pPrinterInfo2,
    LPPROVIDOR pProvidor
    )
{
    HKEY    hClientKey = NULL;
    HKEY    hConnectionsKey;
    HKEY    hPrinterKey;
    DWORD   Status;
    BOOL    rc = FALSE;
    LPCTSTR pszProvidor = pProvidor->lpName;
    PWSTR   pKeyName = NULL;
    DWORD   cchSize = MAX_PATH;
    DWORD   dwError;

    //
    // CLS
    //
    // If the provider is localspl, change it to win32spl.dll.
    // This is required for clustering since localspl handles printer
    // connections, but they should be "owned" by win32spl.dll.  When
    // Someone opens a printer that they are connected to, we will
    // always hit localspl.dll first before we look at this entry.
    //
    // When the cluster is remote, then they need to go through win32spl.dll.
    //
    if( pProvidor == pLocalProvidor ){
        pszProvidor = szWin32spl;
    }

    hClientKey = GetClientUserHandle(KEY_READ);

    if (hClientKey) {

        if (wcslen(pPrinterInfo2->pPrinterName) < cchSize &&
            (pKeyName = AllocSplMem(cchSize * sizeof(WCHAR)))) {

            Status = RegCreateKeyEx(hClientKey, szRegistryConnections,
                                    REG_OPTION_RESERVED, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE, NULL, &hConnectionsKey, NULL);

            if (Status == NO_ERROR) {

                /* Make a key name without backslashes, so that the
                 * registry doesn't interpret them as branches in the registry tree:
                 */
                FormatPrinterForRegistryKey(pPrinterInfo2->pPrinterName,
                                            pKeyName,
                                            cchSize);

                Status = RegCreateKeyEx(hConnectionsKey, pKeyName, REG_OPTION_RESERVED,
                                        NULL, 0, KEY_WRITE, NULL, &hPrinterKey, NULL);

                if (Status == NO_ERROR) {

                    RegSetValueEx(hPrinterKey,
                                  szServerValue,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pPrinterInfo2->pServerName,
                                  (lstrlen(pPrinterInfo2->pServerName)+1) *
                                  sizeof(pPrinterInfo2->pServerName[0]));

                    Status = RegSetValueEx(hPrinterKey,
                                           szProvidorValue,
                                           0,
                                           REG_SZ,
                                           (LPBYTE)pszProvidor,
                                           (lstrlen(pszProvidor)+1) *
                                               sizeof(pszProvidor[0]));

                    if (Status == ERROR_SUCCESS) {

                        dwError = UpdatePrinterRegUser(hClientKey,
                                                       NULL,
                                                       pPrinterInfo2->pPrinterName,
                                                       NULL,
                                                       UPDATE_REG_CHANGE);

                        if (dwError == ERROR_SUCCESS) {

                            BroadcastMessage(BROADCAST_TYPE_MESSAGE,
                                             WM_WININICHANGE,
                                             0,
                                             (LPARAM)szDevices);

                            rc = TRUE;

                        } else {

                            DBGMSG(DBG_TRACE, ("UpdatePrinterRegUser failed: Error %d\n",
                                               dwError));
                        }

                    } else {

                        DBGMSG(DBG_WARNING, ("RegSetValueEx(%ws) failed: Error %d\n",
                               pszProvidor, Status));

                        rc = FALSE;
                    }

                    RegCloseKey(hPrinterKey);

                } else {

                    DBGMSG(DBG_WARNING, ("RegCreateKeyEx(%ws) failed: Error %d\n",
                                         pKeyName, Status ));
                    rc = FALSE;
                }

                RegCloseKey(hConnectionsKey);

            } else {

                DBGMSG(DBG_WARNING, ("RegCreateKeyEx(%ws) failed: Error %d\n",
                                     szRegistryConnections, Status ));
                rc = FALSE;
            }


            if (!rc) {

                DBGMSG(DBG_WARNING, ("Error updating registry: %d\n",
                                     GetLastError())); /* This may not be the error */
                                                       /* that caused the failure.  */
                if (pKeyName)
                    RegDeleteKey(hClientKey, pKeyName);
            }

            FreeSplMem(pKeyName);
        }

        RegCloseKey(hClientKey);
    }

    return rc;
}

BOOL
RemovePrinterConnectionInRegistry(
    LPWSTR pName)
{
    HKEY    hClientKey;
    HKEY    hPrinterConnectionsKey;
    DWORD   Status = NO_ERROR;
    DWORD   i = 0;
    PWSTR   pKeyName = NULL;
    DWORD   cchSize = MAX_PATH;
    BOOL    Found = FALSE;
    BOOL    bRet = FALSE;

    if (pName && 
        wcslen(pName) < cchSize) {

        if (pKeyName = AllocSplMem(cchSize * sizeof(WCHAR))) {
        
            hClientKey = GetClientUserHandle(KEY_READ);


            if (hClientKey) {

                Status = RegOpenKeyEx(hClientKey, szRegistryConnections,
                                      REG_OPTION_RESERVED,
                                      KEY_READ | KEY_WRITE, &hPrinterConnectionsKey);

                if (Status == NO_ERROR) {

                    FormatPrinterForRegistryKey(pName, pKeyName, cchSize);
                    bRet = DeleteSubKeyTree(hPrinterConnectionsKey, pKeyName);

                    RegCloseKey(hPrinterConnectionsKey);
                }

                if ( bRet ) {

                    UpdatePrinterRegUser(hClientKey,
                                         NULL,
                                         pName,
                                         NULL,
                                         UPDATE_REG_DELETE);
                }

                RegCloseKey(hClientKey);

                if ( bRet ) {

                    BroadcastMessage(BROADCAST_TYPE_MESSAGE,
                                     WM_WININICHANGE,
                                     0,
                                     (LPARAM)szDevices);
                }
            }

            FreeSplMem(pKeyName);
        }
    }

    return bRet;
}

VOID
PrinterHandleRundown(
    HANDLE hPrinter)
{
    LPPRINTHANDLE pPrintHandle;

    if (hPrinter) {

        pPrintHandle = (LPPRINTHANDLE)hPrinter;

        switch (pPrintHandle->signature) {

        case PRINTHANDLE_SIGNATURE:

            // Log warning to detect handle free
            DBGMSG(DBG_WARNING, ("PrinterHandleRundown: 0x%x 0x%x", pPrintHandle, pPrintHandle->hPrinter));

            DBGMSG(DBG_TRACE, ("Rundown PrintHandle 0x%x\n", hPrinter));
            ClosePrinter(hPrinter);
            break;

        case NOTIFYHANDLE_SIGNATURE:

            DBGMSG(DBG_TRACE, ("Rundown NotifyHandle 0x%x\n", hPrinter));
            RundownPrinterNotify(hPrinter);
            break;

        case CLUSTERHANDLE_SIGNATURE:

            DBGMSG(DBG_TRACE, ("Rundown ClusterHandle 0x%x\n", hPrinter ));
            ClusterSplClose(hPrinter);
            break;

        default:

            //
            // Unknown type.
            //
            DBGMSG( DBG_ERROR, ("Rundown: Unknown type 0x%x\n", hPrinter ) );
            break;
        }
    }
    return;
}

/*++

    Function Description: 
        Validates the fully qualified printer name. Performs the following checks
        1) Length < MAX_UNC_PRINTER_NAME
        2) No invalid chars in the names \,!
        3) No empty names after removing trailing blanks

    Arguments: 
        pPrinterName  -  printer name

    Return Values: 
        TRUE if valid name; FALSE otherwise

--*/
BOOL
ValidatePrinterName(
    LPWSTR pPrinterName
    )
{
    BOOL    bRetVal        = TRUE;
    DWORD   PrinterNameLen = 0;

    //
    // '!' or ',' or '\' are not valid characters in the
    // server or printer names.
    // The min. allowed printer name length is 5 "\\s\p"
    //
    if (!pPrinterName                                                    ||
        ((PrinterNameLen = wcslen(pPrinterName)) < MIN_UNC_PRINTER_NAME) ||
        (PrinterNameLen >= MAX_UNC_PRINTER_NAME)                         ||
        (wcschr(pPrinterName, L','))                                     ||
        (wcschr(pPrinterName, L'!'))                                     ||
        (*pPrinterName++ != L'\\')                                       ||
        (*pPrinterName++ != L'\\'))
    {
        bRetVal = FALSE;
    }
    else
    {
        LPWSTR pWack      = NULL;
        LPWSTR pAfterWack = NULL;

        if (!(pWack = wcschr(pPrinterName, L'\\')) ||
            wcschr(pAfterWack=pWack+1, L'\\'))
        {
            bRetVal = FALSE;
        }
        else
        {
            WCHAR  szServer[MAX_UNC_PRINTER_NAME], szPrinter[MAX_UNC_PRINTER_NAME];
            size_t ServerNameLen  = 0;
            int    IndexInName    = 0;

            wcsncpy(szServer, pPrinterName, ServerNameLen = pWack-pPrinterName);
            szServer[ServerNameLen] = L'\0';

            StringCchCopy(szPrinter, MAX_UNC_PRINTER_NAME, pAfterWack); 

            for (IndexInName=ServerNameLen-1; 
                 IndexInName>=0;
                 IndexInName--)
            {
                if (szServer[IndexInName] != L' ')
                {
                    break;
                }
            }
            szServer[IndexInName+1] = L'\0';

            for (IndexInName=wcslen(szPrinter)-1;
                 IndexInName>=0;
                 IndexInName--)
            {
                if (szPrinter[IndexInName] != L' ')
                {
                    break;
                }
            }
            szPrinter[IndexInName+1] = L'\0';

            if (!szServer[0] || !szPrinter[0])
            {
                bRetVal = FALSE;
            }
        }
    }

    return bRetVal;   
}

BOOL
RouterAddPerMachineConnection(
    LPCWSTR   pPrinterNameP,
    LPCWSTR   pPrintServerP,
    LPCWSTR   pProviderP)

/*++
Function Description: RouterAddPerMachineConnection adds a subkey to HKEY_LOCAL_MACHINE\
                      SYSTEM\CurrentControlSet\Control\Print\Connections with the PrinterName.
                      The PrintServer name and the name of the dll used as a provider for
                      this connection are stored as values in the key.

Parameters:
            pPrinterNameP - pointer to the fully qualified printer name. (\\printserver\name)
            pPrintServerP - pointer to the print server name.
            pProviderP - pointer to the provider name. Currently only LanMan Print Services
                         is supported. This corresponds to win32spl.dll. NULL or szNULL value
                         defaults to this provider. Currently there is no check to enforce that
                         only LanMan Print Services is passed.

Return Value: TRUE for success
              FALSE otherwise.
--*/

{
    BOOL   bReturn = TRUE;
    DWORD  dwLocalConnection = 1, dwLastError, dwType, cbBuf;

    HKEY   hMcConnectionKey = NULL, hPrinterKey = NULL;
    HKEY   hProviderKey = NULL, hAllProviderKey = NULL;
    HANDLE hImpersonationToken = NULL;

    LPWSTR pPrintServer=NULL, pProvider=NULL, pPrinterName=NULL, pEnd;
    WCHAR  szConnData[MAX_PATH];
    WCHAR  szRegistryConnections[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";
    WCHAR  szRegistryProviders[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Providers";

   EnterRouterSem();

    // Getting the name of the library for the provider.
    if (!pProviderP || !*pProviderP) {

       pProvider = AllocSplStr(L"win32spl.dll");

    } else {

       cbBuf = sizeof(szConnData);

       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryProviders, 0,
                        KEY_READ, &hAllProviderKey) ||
           RegOpenKeyEx(hAllProviderKey, pProviderP, 0, KEY_READ,
                        &hProviderKey) ||
           RegQueryValueEx(hProviderKey, L"Name", 0, &dwType,
                           (LPBYTE)szConnData,&cbBuf))  {

            SetLastError(ERROR_INVALID_PARAMETER);
            bReturn = FALSE;
            goto CleanUp;

       } else {

            pProvider = AllocSplStr(szConnData);
       }
    }

    pPrintServer = AllocSplStr(pPrintServerP);
    pPrinterName = AllocSplStr(pPrinterNameP);

    if (!pProvider || !pPrintServer || !pPrinterName) {

        bReturn = FALSE;
        goto CleanUp;
    }

    // Check for a fully qualified printer name without commas
    if (!ValidatePrinterName(pPrinterName)) {

         SetLastError(ERROR_INVALID_PRINTER_NAME);
         bReturn = FALSE;
         goto CleanUp;
    }

    // Replacing the \'s from the Printer name with ,'s
    FormatPrinterForRegistryKey(pPrinterName, pPrinterName, wcslen(pPrinterName) + 1);

    hImpersonationToken = RevertToPrinterSelf();

    // Creating the subkey for the holding all printer connections.

    if ((dwLastError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryConnections, 0,
                                      NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE,
                                      NULL, &hMcConnectionKey, NULL)) ||
        (dwLastError = RegCreateKeyEx(hMcConnectionKey, pPrinterName, 0, NULL,
                                      REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL,
                                      &hPrinterKey, NULL))) {

         SetLastError(dwLastError);
         bReturn = FALSE;
         goto CleanUp;
    }

    // Setting the connection data.
    if ((dwLastError = RegSetValueEx(hPrinterKey, L"Server", 0, REG_SZ, (LPBYTE) pPrintServer,
                                     (wcslen(pPrintServer)+1)*sizeof(pPrintServer[0]))) ||
        (dwLastError = RegSetValueEx(hPrinterKey, L"Provider", 0, REG_SZ, (LPBYTE) pProvider,
                                     (wcslen(pProvider)+1)*sizeof(pProvider[0]))) ||
        (dwLastError = RegSetValueEx(hPrinterKey, L"LocalConnection", 0, REG_DWORD,
                                     (LPBYTE) &dwLocalConnection, sizeof(dwLocalConnection)))) {

         SetLastError(dwLastError);
         bReturn = FALSE;
    }

CleanUp:
    if (pPrintServer) {
       FreeSplStr(pPrintServer);
    }

    if (pProvider) {
       FreeSplStr(pProvider);
    }

    if (hAllProviderKey) {
       RegCloseKey(hAllProviderKey);
    }

    if (hProviderKey) {
       RegCloseKey(hProviderKey);
    }

    if (hPrinterKey) {
        RegCloseKey(hPrinterKey);
    }

    if (!bReturn) {
       if (hMcConnectionKey) RegDeleteKey(hMcConnectionKey,pPrinterName);
    }

    if (pPrinterName) {
       FreeSplStr(pPrinterName);
    }

    if (hMcConnectionKey) {
       RegCloseKey(hMcConnectionKey);
    }

    if (hImpersonationToken) {
       ImpersonatePrinterClient(hImpersonationToken);
    }

   LeaveRouterSem();

    return bReturn;
}

BOOL
AddPerMachineConnectionW(
    LPCWSTR  pServer,
    LPCWSTR  pPrinterName,
    LPCWSTR  pPrintServer,
    LPCWSTR  pProvider
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    if ((*pProvidor->PrintProvidor.fpAddPerMachineConnection)
                (pServer, pPrinterName, pPrintServer, pProvider)) {

        return RouterAddPerMachineConnection(pPrinterName,pPrintServer,pProvider);

    } else if (GetLastError() != ERROR_INVALID_NAME) {

        return FALSE;
    }

    pProvidor = pProvidor->pNext;
    while (pProvidor) {

       if ((*pProvidor->PrintProvidor.fpAddPerMachineConnection)
                (pServer, pPrinterName, pPrintServer, pProvider)) {
          return TRUE;
       }

       if (GetLastError() != ERROR_INVALID_NAME) {
          return FALSE;
       }

       pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
RouterDeletePerMachineConnection(
    LPCWSTR   pPrinterNameP
    )
/*++
Function Description: This function deletes the registry entry in HKEY_LOCAL_MACHINE\
                      SYSTEM\CurrentControlSet\Control\Print\Connections corresponding to
                      pPrinterNameP. All users will lose the connection when they logon.

Parameters: pPrinterNameP - pointer to the fully qualified name of the printer.

Return Values: TRUE for Success
               FALSE otherwise.
--*/
{
    BOOL    bReturn = TRUE, bEnteredRouterSem = FALSE;
    HANDLE  hImpersonationToken = NULL;
    HKEY    hMcConnectionKey = NULL;
    LPWSTR  pPrinterName = NULL;
    DWORD   dwLastError;
    WCHAR   szRegistryConnections[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";


    if (!(pPrinterName = AllocSplStr(pPrinterNameP))) {

        bReturn = FALSE;
        goto CleanUp;
    }

    // Convert \'s to ,'s in the printer name.
    FormatPrinterForRegistryKey(pPrinterName, pPrinterName, wcslen(pPrinterName) + 1);

    EnterRouterSem();
    bEnteredRouterSem = TRUE;

    hImpersonationToken = RevertToPrinterSelf();

    if (dwLastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryConnections, 0,
                                   KEY_ALL_ACCESS, &hMcConnectionKey)) {

        SetLastError(dwLastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (dwLastError = RegDeleteKey(hMcConnectionKey, pPrinterName)) {

        SetLastError(dwLastError);
        bReturn = FALSE;
    }

CleanUp:
    if (hMcConnectionKey) {
       RegCloseKey(hMcConnectionKey);
    }
    
    if (pPrinterName) {
       FreeSplStr(pPrinterName);
    }
    if (hImpersonationToken) {
       ImpersonatePrinterClient(hImpersonationToken);
    }
    if (bEnteredRouterSem) {
       LeaveRouterSem();
    }

    return bReturn;
}

BOOL
DeletePerMachineConnectionW(
    LPCWSTR  pServer,
    LPCWSTR  pPrinterName
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    if ((*pProvidor->PrintProvidor.fpDeletePerMachineConnection)
                (pServer, pPrinterName)) {

        return RouterDeletePerMachineConnection(pPrinterName);

    } else if (GetLastError() != ERROR_INVALID_NAME) {

        return FALSE;
    }

    pProvidor = pProvidor->pNext;
    while (pProvidor) {

       if ((*pProvidor->PrintProvidor.fpDeletePerMachineConnection)
                (pServer, pPrinterName)) {
           return TRUE;
       }

       if (GetLastError() != ERROR_INVALID_NAME) {
           return FALSE;
       }

       pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
RouterEnumPerMachineConnections(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
    )
/*++
Function Description: This function copies the PRINTER_INFO_4 structs for all the per
                      machine connections into the buffer (pPrinterEnum).

Parameters: pServer - pointer to the server name (NULL for local)
            pPrinterEnum - pointer to the buffer
            cbBuf - size of the buffer in bytes
            pcbNeeded - pointer to a variable which contains the number of bytes written
                        into the buffer/ number of bytes required (if the given buffer
                        is insufficient)
            pcReturned - pointer to the variable which contains the number of PRINTER_INFO_4
                         structs returned in the buffer.

Return Values: TRUE for success
               FALSE otherwise.

--*/
{
    DWORD     dwRegIndex, dwType, cbdata, dwNameSize, dwLastError;
    BOOL      bReturn = TRUE, bEnteredRouterSem = FALSE;
    HANDLE    hImpersonationToken = NULL;
    HKEY      hMcConnectionKey = NULL, hPrinterKey = NULL;
    LPBYTE    pStart = NULL, pEnd = NULL;

    WCHAR     szMachineConnections[]=L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";
    WCHAR     szPrinterName[MAX_UNC_PRINTER_NAME],szConnData[MAX_UNC_PRINTER_NAME];

    // Check for local machine
    if (pServer && *pServer) {

        if (!MyUNCName((LPWSTR)pServer)) {

            SetLastError(ERROR_INVALID_NAME);
            bReturn = FALSE;
            goto CleanUp;
        }
    }

   EnterRouterSem();
   bEnteredRouterSem = TRUE;

    hImpersonationToken = RevertToPrinterSelf();

    *pcbNeeded = *pcReturned = 0;

    // Open the key containing all per-machine connections.
    if (dwLastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMachineConnections, 0,
                                   KEY_READ , &hMcConnectionKey)) {

        bReturn = (dwLastError == ERROR_FILE_NOT_FOUND) ? TRUE
                                                        : FALSE;
        if (!bReturn) {
            SetLastError(dwLastError);
        }
        goto CleanUp;
    }

    // pStart and pEnd point to the start and end of the buffer respt.
    pStart = pPrinterEnum;
    pEnd = pPrinterEnum + cbBuf;

    for (dwRegIndex = 0;

         dwNameSize = COUNTOF(szPrinterName),
         ((dwLastError = RegEnumKeyEx(hMcConnectionKey, dwRegIndex, szPrinterName,
                                      &dwNameSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS);

         ++dwRegIndex) {

         // Enumerate each of the connections and copy data into the buffer
         cbdata = sizeof(szConnData);

         if ((dwLastError = RegOpenKeyEx(hMcConnectionKey, szPrinterName, 0,
                                         KEY_READ, &hPrinterKey)) ||
             (dwLastError = RegQueryValueEx(hPrinterKey, L"Server", NULL, &dwType,
                                            (LPBYTE)szConnData, &cbdata))) {

             SetLastError(dwLastError);
             bReturn = FALSE;
             goto CleanUp;
         }

         RegCloseKey(hPrinterKey);
         hPrinterKey=NULL;

         // Update the size of the required buffer
         *pcbNeeded = *pcbNeeded + sizeof(PRINTER_INFO_4) + sizeof(DWORD) +
                      (wcslen(szConnData) + 1)*sizeof(szConnData[0]) +
                      (wcslen(szPrinterName) + 1)*sizeof(szPrinterName[0]);

         // Copy data into the buffer if there is space.
         if (*pcbNeeded <= cbBuf) {

             pEnd = CopyPrinterNameToPrinterInfo4(szConnData,szPrinterName,pStart,pEnd);
             FormatRegistryKeyForPrinter(((PPRINTER_INFO_4) pStart)->pPrinterName,
                                         ((PPRINTER_INFO_4) pStart)->pPrinterName,
                                         wcslen(((PPRINTER_INFO_4) pStart)->pPrinterName) + 1);
             pStart += sizeof(PRINTER_INFO_4);
             (*pcReturned)++;
         }
    }

    if (dwLastError != ERROR_NO_MORE_ITEMS) {

        SetLastError(dwLastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (cbBuf < *pcbNeeded) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        bReturn = FALSE;
    }

CleanUp:

    if (hMcConnectionKey) {
       RegCloseKey(hMcConnectionKey);
    }
    if (hPrinterKey) {
       RegCloseKey(hPrinterKey);
    }
    if (hImpersonationToken) {
       ImpersonatePrinterClient(hImpersonationToken);
    }
    if (bEnteredRouterSem) {
       LeaveRouterSem();
    }
    if (!bReturn) {
       *pcReturned = 0;
    }

    return bReturn;
}

BOOL
EnumPerMachineConnectionsW(
    LPCWSTR  pServer,
    LPBYTE   pPrinterEnum,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
    LPPROVIDOR  pProvidor;

    if ((pPrinterEnum == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (RouterEnumPerMachineConnections(pServer, pPrinterEnum, cbBuf,
                                        pcbNeeded, pcReturned)) {

        return TRUE;

    } else if (GetLastError() != ERROR_INVALID_NAME) {

        return FALSE;
    }

    pProvidor = pLocalProvidor;
    while (pProvidor) {

       if ((*pProvidor->PrintProvidor.fpEnumPerMachineConnections)
                 (pServer, pPrinterEnum, cbBuf, pcbNeeded, pcReturned)) {

            return TRUE;
       }

       if (GetLastError() != ERROR_INVALID_NAME) {
           return FALSE;
       }

       pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

PPRINTER_INFO_2
pGetPrinterInfo2(
    HANDLE hPrinter
    )

/*++

Routine Description:

    Retrieve a printer info 2 structure from an hPrinter.  Data must
    be FreeSplMem'd by caller.

Arguments:

    hPrinter - Printer to query.

Return Value:

    PRINTER_INFO_2 - On success, a valid structure.
    NULL - On failure.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    DWORD cbPrinter = 0x1000;
    DWORD cbNeeded;
    PPRINTER_INFO_2 pPrinterInfo2;
    BOOL bSuccess = FALSE;

    if( pPrinterInfo2 = AllocSplMem( cbPrinter )){

        bSuccess = (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinter)
                         ( pPrintHandle->hPrinter,
                           2,
                           (PBYTE)pPrinterInfo2,
                           cbPrinter,
                           &cbNeeded );

        if( !bSuccess ){

            if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ){

                FreeSplMem( pPrinterInfo2 );

                if (pPrinterInfo2 = (PPRINTER_INFO_2)AllocSplMem( cbNeeded )){

                    cbPrinter = cbNeeded;
                    bSuccess = (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinter)
                                     ( pPrintHandle->hPrinter,
                                       2,
                                       (PBYTE)pPrinterInfo2,
                                       cbPrinter,
                                       &cbNeeded );
                }
            }
        }
    }

    if( !bSuccess ){
        FreeSplMem( pPrinterInfo2 );
        return NULL;
    }

    return pPrinterInfo2;
}

VOID
SplDriverUnloadComplete(
    LPWSTR   pDriverFile
    )
/*++
Function Description:  Notify the print provider that the driver is being unloaded
                       so that it may continue with any pending driver upgrades.

Parameters: pDriverFile   -- name of the library that has been unloaded

Return Values: NONE
--*/
{
    LPPROVIDOR   pProvidor;

    for (pProvidor = pLocalProvidor; pProvidor; pProvidor = pProvidor->pNext) {
         if ((*pProvidor->PrintProvidor.fpDriverUnloadComplete)(pDriverFile)) {
             break;
         }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\reghand.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation
All rights reserved

Module Name:

    reghand.c

Abstract:

    Processes that do impersonation should not attempt to open
    per-process aliases like HKEY_CURRENT_USER. HKEY_CURRENT_USER
    has meaning only for end user programs that run in the context
    of a single local user.

    Server processes should not depend on predefined handles or any
    other per process state. It should determine whether
    the user (client) being impersonated is local or remote.

Author:

    KrishnaG (20-May-93)

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

#define MAX_SID_STRING 256


//
// Function Declarations
//

BOOL
InitClientUserString(
    LPWSTR pString
    );

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    )

/*++

Routine Description:

Arguments:

Returns:

---*/

{
    HANDLE hKeyClient;
    WCHAR  String[MAX_SID_STRING];
    LONG   ReturnValue;

    if (!InitClientUserString(String)) {
        DBGMSG( DBG_WARNING, ("GetClientUserHandle InitClientUserString failed %d\n", GetLastError() ));
        return NULL ;
    }

    //
    // We now have the Unicode string representation of the
    // local client's Sid we'll use this string to open a handle
    // to the client's key in  the registry.

    ReturnValue = RegOpenKeyEx( HKEY_USERS,
                                String,
                                0,
                                samDesired,
                                &hKeyClient );

    //
    // If we couldn't get a handle to the local key
    // for some reason, return a NULL handle indicating
    // failure to obtain a handle to the key
    //

    if ( ReturnValue != ERROR_SUCCESS ) {
        DBGMSG( DBG_TRACE, ( "GetClientUserHandle failed %d\n", ReturnValue ));
        SetLastError( ReturnValue );
        return NULL;
    }

    return( hKeyClient );
}



BOOL
InitClientUserString (
    LPWSTR pString
    )

/*++

Routine Description:

Arguments:

    pString - output string of current user

Return Value:

    TRUE = success,
    FALSE = fail

    Returns in pString a ansi string if the impersonated client's
    SID can be expanded successfully into  Unicode string. If the conversion
    was unsuccessful, returns FALSE.

--*/

{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    NTSTATUS    NtStatus;
    BOOL        Status;
    DWORD       dwLastError;
    UNICODE_STRING UnicodeString;

    //
    // We can use OpenThreadToken because this server thread
    // is impersonating a client
    //
    Status = OpenThreadToken( GetCurrentThread(),
                              TOKEN_READ,
                              TRUE,                // Open as self
                              &TokenHandle
                              );

    if( Status == FALSE ) {
        DBGMSG(DBG_WARNING, ("InitClientUserString: OpenThreadToken failed: Error %d\n",
                             GetLastError()));
        return FALSE ;
    }

    //
    // Notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure
    //
    Status = GetTokenInformation( TokenHandle,
                                  TokenUser,
                                  TokenInformation,
                                  sizeof( TokenInformation ),
                                  &ReturnLength
                                   );
    dwLastError = GetLastError();
    CloseHandle( TokenHandle );

    if ( Status == FALSE ) {
        DBGMSG(DBG_WARNING, ("InitClientUserString: GetTokenInformation failed: Error %d\n",
                             dwLastError ));
        return FALSE;
    }

    //
    // Convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.
    //

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_SID_STRING;
    UnicodeString.Buffer = pString;

    NtStatus = RtlConvertSidToUnicodeString(
                 &UnicodeString,
                 ((PTOKEN_USER)TokenInformation)->User.Sid,
                 FALSE );

    if( !NT_SUCCESS( NtStatus )){
        DBGMSG( DBG_WARN,
                ( "InitClientUserString: RtlConvertSidToUnicodeString failed: Error %d\n",
                  NtStatus ));
        
	dwLastError = RtlNtStatusToDosError( NtStatus );
	SetLastError( dwLastError );

        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\reply.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    reply.h

Abstract:

    Header for RPC conversations initiated from the server to the client.

Author:

    Albert Ting (AlbertT) 04-June-94

Environment:

    User Mode -Win32

Revision History:

--*/

typedef struct _NOTIFY {
    DWORD        signature;         // Must be first (match _PRINTHANDLE) 6e6f
    PPRINTHANDLE pPrintHandle;
    PNOTIFY      pNext;
    DWORD        dwType;
} NOTIFY;


#define REPLY_TYPE_NULL         0
#define REPLY_TYPE_NOTIFICATION 1
#define REPLY_TYPE_BROWSE       2

extern  DWORD        dwRouterUniqueSessionID;

DWORD
OpenReplyRemote(
    LPWSTR pszMachine,
    PHANDLE phNotifyRemote,
    DWORD dwPrinterRemote,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer);

VOID
CloseReplyRemote(
    HANDLE hNotifyRemote);

BOOL
RouterReplyPrinter(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    DWORD dwReplyType,
    PVOID pBuffer);

VOID
FreePrinterHandleNotifys(
    PPRINTHANDLE pPrintHandle);

VOID
BeginReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType);

VOID
EndReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType);

VOID
RemoveReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType);


//
// PrinterNotifyInfo related headers:
//


VOID
ClearPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo,
    PCHANGE pChange);

VOID
SetDiscardPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo,
    PCHANGE pChange);

DWORD
AppendPrinterNotifyInfo(
    PPRINTHANDLE pPrintHandle,
    DWORD dwColor,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo);

VOID
SetupPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange);

BOOL
ReplyPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\reply.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Reply.c

Abstract:

    Handles all communication setup for RPC from the Server back
    to the Client.

    This implementation allows multiple reply handles for one print
    handle, but relies on serialized access to context handles on this
    machine.

Author:

    Albert Ting (AlbertT) 04-June-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntfytab.h"

PPRINTHANDLE pPrintHandleReplyList = NULL;
DWORD        dwRouterUniqueSessionID = 1;

DWORD
OpenReplyRemote(
    LPWSTR pszMachine,
    PHANDLE phNotifyRemote,
    DWORD dwPrinterRemote,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:

    Establishes a context handle from the server back to the client.
    RpcReplyOpenPrinter call will fail with access denied when the 
    client machine is in a different, un-trusted domain than the server.
    For that case, we'll continue impersonate and will try to make the call
    in the user context.However, if the client machine was previously joined
    the server's domain, but is now in another domain, the server can still successfully
    make the RPC call back to client.This scenario works because the client's mac address
    is still in the server's domain(even if the client's machine name changes). 
    
    We know that a call of RpcReplyOpenPrinter in the user context would succeed 
    in the case when the machines are in the same domain anyway.
    but for safety reasons we preffer to first try to make the call in the local system 
    context and only if it fails we try to make the call in user context.
      

Arguments:

    pszLocalMachine - Machine to talk to.

    phNotifyRemote - Remote context handle to set up

    dwPrinterRemote - remote printer handle we are talking to.

Return Value:

--*/

{
    DWORD  dwReturn;
    HANDLE hToken;
    BOOL   bImpersonating = FALSE;

    //
    // Stop impersonating: This prevents separate session ids from
    // being used.
    //
    hToken = RevertToPrinterSelf();

    dwReturn = hToken ? ERROR_SUCCESS : GetLastError();

    if (dwReturn == ERROR_SUCCESS)
    {
        //
        // If create a context handle to reply.
        //
        RpcTryExcept {

            dwReturn = RpcReplyOpenPrinter(
                           pszMachine,
                           phNotifyRemote,
                           dwPrinterRemote,
                           dwType,
                           cbBuffer,
                           pBuffer);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwReturn = RpcExceptionCode();

        } RpcEndExcept
    }

    //
    // Resume impersonating.
    //
    if (hToken) {
        bImpersonating = ImpersonatePrinterClient(hToken);
        if (!bImpersonating && dwReturn == ERROR_SUCCESS) {
            dwReturn = GetLastError();
        }
    }

    //
    // Try the rpc call in user context, if we failed ReplyOpenPrinter call and not in impersonation.
    //
    if (dwReturn && bImpersonating) {

        RpcTryExcept {

            dwReturn = RpcReplyOpenPrinter(
                           pszMachine,
                           phNotifyRemote,
                           dwPrinterRemote,
                           dwType,
                           cbBuffer,
                           pBuffer);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwReturn = RpcExceptionCode();

        } RpcEndExcept

    }

    return dwReturn;
}

VOID
CloseReplyRemote(
    HANDLE hNotifyRemote)
{
    HANDLE hToken;
    DWORD  dwError;

    DBGMSG(DBG_NOTIFY, ("CloseReplyRemote requested: 0x%x\n",
                        hNotifyRemote));

    if (!hNotifyRemote)
        return;

    //
    // Stop impersonating: This prevents separate session ids from
    // being used.
    //
    hToken = RevertToPrinterSelf();

    dwError = hToken ? ERROR_SUCCESS : GetLastError();

    if (dwError == ERROR_SUCCESS)
    {
        RpcTryExcept {

            dwError = RpcReplyClosePrinter(&hNotifyRemote);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwError = RpcExceptionCode();

        } RpcEndExcept
    }

    if (dwError) {

        DBGMSG(DBG_WARNING, ("FCPCN:ReplyClose error %d, DestroyClientContext: 0x%x\n",
                             dwError,
                             hNotifyRemote));

        //
        // Error trying to close down the notification,
        // clear up our context.
        //
        RpcSmDestroyClientContext(&hNotifyRemote);
    }

    //
    // Resume impersonating.
    //
    if (hToken && !ImpersonatePrinterClient(hToken)) {
            dwError = GetLastError();
    }
}


BOOL
RouterReplyPrinter(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwChangeFlags,
    PDWORD pdwResult,
    DWORD dwReplyType,
    PVOID pBuffer)

/*++

Routine Description:

    Handle the notification coming in from a remote router (as
    opposed to a print providor).

Arguments:

    hNotify -- printer that changed, notification context handle

    dwColor -- indicates color of data

    fdwChangeFlags -- flags that changed

    pdwResult -- out DWORD result

    dwReplyType -- type of reply that is coming back

    pBuffer -- data based on dwReplyType

Return Value:

    BOOL  TRUE  = success
          FALSE = fail

--*/

{
    PNOTIFY pNotify = (PNOTIFY)hNotify;
    BOOL bReturn = FALSE;

    EnterRouterSem();

    if (!pNotify ||
        pNotify->signature != NOTIFYHANDLE_SIGNATURE ||
        !pNotify->pPrintHandle) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    DBGMSG(DBG_NOTIFY, ("RRP: Remote notification received: pNotify 0x%x, pPrintHandle 0x%x\n",
                        pNotify, pNotify->pPrintHandle));

    switch (pNotify->dwType) {
    case REPLY_TYPE_NOTIFICATION:

        SPLASSERT(dwReplyType == REPLY_PRINTER_CHANGE);

        bReturn = ReplyPrinterChangeNotificationWorker(
                      pNotify->pPrintHandle,
                      dwColor,
                      fdwChangeFlags,
                      pdwResult,
                      (PPRINTER_NOTIFY_INFO)pBuffer);
        break;

    default:

        DBGMSG(DBG_ERROR, ("RRPCN: Bogus notify 0x%x type: %d\n",
                           pNotify, pNotify->dwType));

        bReturn = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

Done:
    LeaveRouterSem();

    return bReturn;
}



/*------------------------------------------------------------------------

    Routines from here down occur on the client machine.

------------------------------------------------------------------------*/

VOID
FreePrinterHandleNotifys(
    PPRINTHANDLE pPrintHandle)
{
    PNOTIFY pNotify;
    RouterInSem();

    if(pPrintHandle)
    {
        for(pNotify = pPrintHandle->pNotify;
            pNotify;
            pNotify = pNotify->pNext) {

            pNotify->pPrintHandle = NULL;
        }

        //
        // For safety, remove all replys.
        //
        RemoveReplyClient(pPrintHandle,
                          (DWORD)~0);
    }
}

VOID
BeginReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType)
{
    RouterInSem();

    DBGMSG(DBG_NOTIFY, ("BeginReplyClient called 0x%x type %x (sig=0x%x).\n",
                        pPrintHandle, fdwType, pPrintHandle->signature));

    if(pPrintHandle)
    {
        if (!pPrintHandle->fdwReplyTypes) {

            // Give a unique DWORD session ID for pPrintHandle
            while (pPrintHandle->dwUniqueSessionID == 0  ||
                   pPrintHandle->dwUniqueSessionID == 0xffffffff) {

                pPrintHandle->dwUniqueSessionID = dwRouterUniqueSessionID++;
            }

            pPrintHandle->pNext = pPrintHandleReplyList;
            pPrintHandleReplyList = pPrintHandle;
        }

        pPrintHandle->fdwReplyTypes |= fdwType;
    }
}

VOID
EndReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType)
{
    RouterInSem();
    DBGMSG(DBG_NOTIFY, ("EndReplyClient called 0x%x type %x.\n",
                        pPrintHandle, fdwType));
}

VOID
RemoveReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType)
{
    PPRINTHANDLE p;

    RouterInSem();

    DBGMSG(DBG_NOTIFY, ("RemoveReplyClient called 0x%x typed %x (sig=0x%x).\n",
                        pPrintHandle, fdwType, pPrintHandle->signature));

    if(pPrintHandle)
    {
        //
        // Remove this reply type from the print handle.
        //
        pPrintHandle->fdwReplyTypes &= ~fdwType;

        //
        // If no replys remain, remove from linked list.
        //
        if (!pPrintHandle->fdwReplyTypes) {

            // Recover the unique session ID
            pPrintHandle->dwUniqueSessionID = 0;

            //
            // Remove from linked list.
            //
            if (pPrintHandleReplyList == pPrintHandle) {

                pPrintHandleReplyList = pPrintHandle->pNext;

            } else {

                for (p = pPrintHandleReplyList; p; p=p->pNext) {

                    if (p->pNext == pPrintHandle) {

                        p->pNext = pPrintHandle->pNext;
                        return;
                    }
                }
            }
        }
    }
}


BOOL
ReplyOpenPrinter(
    DWORD dwPrinterHandle,
    PHANDLE phNotify,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:

    When sending a notification back from the print server to the
    client, we open up a notification context handle back on the client.
    This way, every time we send back a notification, we just use this
    context handle.

Arguments:

    dwPrinterHandle - printer handle valid here (on the client).  The spoolss.exe
               switches this around for us.

    phNotify - context handle to return to the remote print server.

    dwType - Type of notification

    cbBuffer - reserved for extra information passed

    pBuffer - reserved for extra information passed

Return Value:

    BOOL TRUE = success
         FALSE

--*/

{
    PPRINTHANDLE pPrintHandle;
    PNOTIFY      pNotify;
    BOOL         bReturnValue = FALSE;

    EnterRouterSem();

    //
    // Validate that we are waiting on this print handle.
    // We traverse the linked list to ensure that random bogus
    // hPrinters (which may point to garbage that looks valid)
    // are rejected.
    //

    for (pPrintHandle = pPrintHandleReplyList;
         pPrintHandle;
         pPrintHandle = pPrintHandle->pNext) {

        if (pPrintHandle->dwUniqueSessionID == dwPrinterHandle)
            break;
    }

    if (!pPrintHandle || !(pPrintHandle->fdwReplyTypes & dwType)) {

        DBGMSG(DBG_WARNING, ("ROPCN: Invalid printer handle 0x%x\n",
                             dwPrinterHandle));
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    pNotify = AllocSplMem(sizeof(NOTIFY));

    if (!pNotify) {

        goto Done;
    }

    pNotify->signature = NOTIFYHANDLE_SIGNATURE;
    pNotify->pPrintHandle = pPrintHandle;
    pNotify->dwType = dwType;

    //
    // Add us to the list of Notifys.
    //
    pNotify->pNext = pPrintHandle->pNotify;
    pPrintHandle->pNotify = pNotify;

    DBGMSG(DBG_NOTIFY, ("ROPCN: Notification 0x%x (pPrintHandle 0x%x) set up\n",
                        pNotify,
                        pPrintHandle));

    *phNotify = (HANDLE)pNotify;
    bReturnValue = TRUE;

Done:
    LeaveRouterSem();

    return bReturnValue;
}


BOOL
ReplyClosePrinter(
    HANDLE hNotify)
{
    PNOTIFY pNotify = (PNOTIFY)hNotify;
    PNOTIFY pNotifyTemp;

    BOOL bReturnValue = FALSE;

    EnterRouterSem();

    if (!pNotify || pNotify->signature != NOTIFYHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    if (pNotify->pPrintHandle) {

        //
        // Trigger a notification if the user is still watching the
        // handle.
        //
        ReplyPrinterChangeNotification(pNotify->pPrintHandle,
                                       PRINTER_CHANGE_FAILED_CONNECTION_PRINTER,
                                       NULL,
                                       NULL);
        //
        // Remove from notification list
        //
        if (pNotify->pPrintHandle->pNotify == pNotify) {

            pNotify->pPrintHandle->pNotify = pNotify->pNext;

        } else {

            for (pNotifyTemp = pNotify->pPrintHandle->pNotify;
                pNotifyTemp;
                pNotifyTemp = pNotifyTemp->pNext) {

                if (pNotifyTemp->pNext == pNotify) {
                    pNotifyTemp->pNext = pNotify->pNext;
                    break;
                }
            }
        }
    }

    DBGMSG(DBG_NOTIFY, ("RCPCN: Freeing notify: 0x%x (pPrintHandle 0x%x)\n",
                         pNotify,
                         pNotify->pPrintHandle));

    FreeSplMem(pNotify);
    bReturnValue = TRUE;

Done:
    LeaveRouterSem();

    return bReturnValue;
}


VOID
RundownPrinterNotify(
    HANDLE hNotify)

/*++

Routine Description:

    This is the rundown routine for notifications (the context handle
    for the print server -> client communication).  When the print server
    goes down, the context handle gets rundown on the client (now acting
    as an RPC server).  We should signal the user that something has
    changed.

Arguments:

    hNotify - Handle that has gone invalid

Return Value:

--*/

{
    PNOTIFY pNotify = (PNOTIFY)hNotify;

    DBGMSG(DBG_NOTIFY, ("Rundown called: 0x%x type %d\n",
                        pNotify,
                        pNotify->dwType));

    //
    // Notify the client that the printer has changed--it went away.
    // This should _always_ be a local event.
    //
    switch (pNotify->dwType) {

    case REPLY_TYPE_NOTIFICATION:

        ReplyPrinterChangeNotification((HANDLE)pNotify->pPrintHandle,
                                       PRINTER_CHANGE_FAILED_CONNECTION_PRINTER,
                                       NULL,
                                       NULL);

        ReplyClosePrinter(hNotify);
        break;

    default:

        //
        // This can legally occur on a pNotify that was reopened
        // (due to network error) and hasn't been used yet.
        // dwType should be reinitialized every time the pNotify
        // is used.
        //
        DBGMSG(DBG_ERROR, ("Rundown: unknown notify type %d\n",
                           pNotify->dwType));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\router.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Router.h

Abstract:

    Holds defs for router

Author:

    Albert Ting (AlbertT) 18-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

typedef enum _ESTATUSCHANGE {
    STATUS_CHANGE_EMPTY   = 0,      // One of these is valid,
    STATUS_CHANGE_FORMING = 1,      // but they still need x^2.
    STATUS_CHANGE_VALID   = 2,

    STATUS_CHANGE_CLOSING      =  0x000100, // bitfield
    STATUS_CHANGE_CLIENT       =  0x000200, // Event valid (local pChange)
    STATUS_CHANGE_ACTIVE       =  0x000400, // Currently processing or on LL
    STATUS_CHANGE_ACTIVE_REQ   =  0x000800, // Needs to go on Linked List
    STATUS_CHANGE_INFO         =  0x001000, // Info requested.
    STATUS_CHANGE_DISCARDED    =  0x008000, // Discard locally

    STATUS_CHANGE_DISCARDNOTED =  0x010000, // Discard noted on client
} ESTATUSCHANGE;


typedef struct _LINK *PLINK, *LPLINK;

typedef struct _LINK {
    PLINK pNext;
} LINK;

VOID
LinkAdd(
    PLINK pLink,
    PLINK* ppLinkHead);

VOID
LinkDelete(
    PLINK pLink,
    PLINK* ppLinkHead);

#define CLUSTERHANDLE_SIGNATURE 0x6262

typedef struct _PRINTHANDLE *PPRINTHANDLE, *LPPRINTHANDLE;

typedef struct _CHANGEINFO {
    LINK          Link;                  // Must be first item
    PPRINTHANDLE  pPrintHandle;
    DWORD         fdwOptions;
    DWORD         fdwFilterFlags;        // Original filter of flags to watch
    DWORD         fdwStatus;             // Status from providor
    DWORD         dwPollTime;
    DWORD         dwPollTimeLeft;
    BOOL          bResetPollTime;

    DWORD         fdwFlags;
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo;

} CHANGEINFO, *PCHANGEINFO;

typedef struct _CHANGE {
    LINK          Link;                  // Must be first item
    DWORD         signature;
    ESTATUSCHANGE eStatus;
    DWORD         dwColor;
    DWORD         cRef;
    LPWSTR        pszLocalMachine;
    CHANGEINFO    ChangeInfo;
    DWORD         dwCount;               // number of notifications
    HANDLE        hEvent;                // Event for local notification
    DWORD         fdwFlags;
    DWORD         fdwChangeFlags;        // Accumulated changes
    DWORD         dwPrinterRemote;       // Remote printer handle (ID only)
    HANDLE        hNotifyRemote;         // Remote notification handle
} CHANGE, *PCHANGE, *LPCHANGE;

#define CHANGEHANDLE_SIGNATURE 0x6368

typedef struct _NOTIFY *PNOTIFY, *LPNOTIFY;

#define NOTIFYHANDLE_SIGNATURE 0x6e6f

typedef struct _PROVIDOR {
    struct _PROVIDOR *pNext;
    LPWSTR lpName;
    HANDLE hModule;
    FARPROC fpInitialize;
    PRINTPROVIDOR PrintProvidor;
} PROVIDOR, *LPPROVIDOR;

typedef struct _PRINTHANDLE {
   DWORD        signature;       // Must be first (match _NOTIFY)
   LPPROVIDOR   pProvidor;
   HANDLE       hPrinter;
   PCHANGE      pChange;
   PNOTIFY      pNotify;
   PPRINTHANDLE pNext;           // List of handles waiting for replys
   DWORD        fdwReplyTypes;   // Types of replys being used.
   HANDLE       hFileSpooler;
   LPWSTR       szTempSpoolFile;
   LPWSTR       pszPrinter;
   DWORD        dwUniqueSessionID; // DWORD passed as a hprinter to remote machines
                                   // for notifications. Cant be 0 or 0xffffffff when in use.
} PRINTHANDLE;

#define PRINTHANDLE_SIGNATURE 0x6060

typedef struct _GDIHANDLE {
   DWORD        signature;
   LPPROVIDOR   pProvidor;
   HANDLE       hGdi;
} GDIHANDLE, *PGDIHANDLE, *LPGDIHANDLE;


#define GDIHANDLE_SIGNATURE 0x6161


typedef struct _ROUTERCACHE {
    LPWSTR   pPrinterName;
    BOOL    bAvailable;
    LPPROVIDOR pProvidor;
    SYSTEMTIME st;
} ROUTERCACHE, *PROUTERCACHE;



#define ROUTERCACHE_DEFAULT_MAX 16


LPPROVIDOR
FindEntryinRouterCache(
    LPWSTR pPrinterName
);


DWORD
AddEntrytoRouterCache(
    LPWSTR pPrinterName,
    LPPROVIDOR pProvidor
);

VOID
DeleteEntryfromRouterCache(
    LPWSTR pPrinterName
);

DWORD
RouterIsOlderThan(
    DWORD i,
    DWORD j
);

LPBYTE
CopyPrinterNameToPrinterInfo4(
    LPWSTR pServerName,
    LPWSTR pPrinterName,
    LPBYTE  pPrinter,
    LPBYTE  pEnd);

BOOL
RouterOpenPrinterW(
    LPWSTR              pPrinterName,
    HANDLE             *pHandle,
    LPPRINTER_DEFAULTS  pDefault,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel,
    BOOL                bLocalPrintProvidor
);

VOID
FixupOldProvidor(
    LPPRINTPROVIDOR pProvidor
    );

extern  BOOL     Initialized;
extern  DWORD    dwUpgradeFlag;
extern  CRITICAL_SECTION    RouterNotifySection;
extern  LPWSTR pszSelfMachine;
extern  HANDLE hEventInit;
extern  LPPROVIDOR pLocalProvidor;
extern  LPWSTR szEnvironment;
extern  LPWSTR szLocalSplDll;
extern  WCHAR *szDevices;
extern  LPWSTR szPrintKey;
extern  LPWSTR szRegistryProvidors;
extern  LPWSTR szOrder;
extern  DWORD gbFailAllocs;

#ifdef __cplusplus
extern "C" WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+3];
#else 
extern WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+3];
#endif 
extern  SERVICE_STATUS_HANDLE   ghSplHandle;

LPWSTR
AppendOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

LPWSTR
RemoveOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

BOOL
WPCInit();

VOID
WPCDestroy();


BOOL
ThreadInit();

VOID
ThreadDestroy();

VOID
RundownPrinterChangeNotification(
    HANDLE hNotify);

VOID
FreePrinterHandle(
    PPRINTHANDLE pPrintHandle);

BOOL
FreeChange(
    PCHANGE pChange);

VOID
FreePrinterChangeInfo(
    PCHANGEINFO pChangeInfo);

BOOL
DeleteSubKeyTree(
    HKEY ParentHandle,
    WCHAR SubKeyName[]
    );


BOOL
ThreadNotify(
    LPPRINTHANDLE pPrintHandle);

BOOL
NotifyNeeded(
    PCHANGE pChange);


VOID
HandlePollNotifications();

DWORD
GetNetworkIdWorker(
    HKEY hKeyDevices,
    LPWSTR pDeviceName);

VOID
UpdateSignificantError(
    DWORD dwNewError,
    PDWORD pdwOldError
    );


#define EnterRouterSem() EnterCriticalSection(&RouterNotifySection)
#define LeaveRouterSem() LeaveCriticalSection(&RouterNotifySection)

#define RouterInSem()
#define RouterOutSem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\splinit.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    SplInit.c

Abstract:

    Initialize the spooler.

Author:

Environment:

    User Mode -Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

LPWSTR szDevice = L"Device";
LPWSTR szPrinters = L"Printers";

LPWSTR szDeviceOld = L"DeviceOld";
LPWSTR szNULL = L"";

LPWSTR szPorts=L"Ports";

LPWSTR szWinspool = L"winspool";
LPWSTR szNetwork  = L"Ne";
LPWSTR szTimeouts = L",15,45";

LPWSTR szDotDefault = L".Default";

LPWSTR szRegDevicesPath = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Devices";
LPWSTR szRegWindowsPath = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows";
LPWSTR szRegPrinterPortsPath = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\PrinterPorts";
LPWSTR szCurrentVersionPath =  L"Software\\Microsoft\\Windows NT\\CurrentVersion";
LPWSTR szDevModes2Path = L"Printers\\DevModes2";
PrintSpoolerServerExports   *gpServerExports = NULL;

typedef struct INIT_REG_USER {

    HKEY hKeyUser;
    HKEY hKeyWindows;
    HKEY hKeyDevices;
    HKEY hKeyPrinterPorts;
    BOOL bFoundPrinter;
    BOOL bDefaultSearch;
    BOOL bDefaultFound;
    BOOL bFirstPrinterFound;

    DWORD dwNetCounter;

    WCHAR szFirstPrinter[MAX_PATH * 2];
    WCHAR szDefaultPrinter[MAX_PATH * 2];

} INIT_REG_USER, *PINIT_REG_USER;

//
// Prototypes
//

BOOL
SplRegCopy(
    PINIT_REG_USER pUser,
    HKEY hMcConnectionKey
    );

BOOL
InitializeRegUser(
    LPWSTR szSubKey,
    PINIT_REG_USER pUser
    );

VOID
FreeRegUser(
    PINIT_REG_USER pUser
    );

BOOL
SetupRegForUsers(
    PINIT_REG_USER pUsers,
    DWORD cUsers
    );

VOID
UpdateUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN BOOL             bFindDefault
    );

HRESULT
IsUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN PCWSTR           pszPrinterName
    );

DWORD
ReadPrinters(
    PINIT_REG_USER pUser,
    DWORD Flags,
    PDWORD pcbPrinters,
    LPBYTE* ppPrinters
    );


BOOL
UpdatePrinterInfo(
    const PINIT_REG_USER pCurUser,
    LPCWSTR pPrinterName,
    LPCWSTR pPorts,
    PDWORD pdwNetId
    );


BOOL
EnumerateConnectedPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HKEY hKeyUser
    );

VOID
RegClearKey(
    HKEY hKey
    );

LPWSTR
CheckBadPortName(
    LPWSTR pszPort
    );

BOOL
UpdateLogonTimeStamp(
    void
    );

BOOL
SpoolerInitAll(
    VOID
    )
{
    DWORD dwError;
    WCHAR szClass[MAX_PATH];
    WCHAR szSubKey[MAX_PATH];
    DWORD cUsers;
    DWORD cSubKeys;
    DWORD cchMaxSubkey;
    DWORD cchMaxClass;
    DWORD cValues;
    DWORD cbMaxValueData;
    DWORD cbSecurityDescriptor;
    DWORD cchClass;
    DWORD cchMaxValueName;
    FILETIME ftLastWriteTime;

    BOOL bSuccess;
    DWORD cchSubKey;

    PINIT_REG_USER pUsers;
    PINIT_REG_USER pCurUser;

    DWORD i;

    cchClass = COUNTOF(szClass);

    dwError = RegQueryInfoKey(HKEY_USERS,
                              szClass,
                              &cchClass,
                              NULL,
                              &cSubKeys,
                              &cchMaxSubkey,
                              &cchMaxClass,
                              &cValues,
                              &cchMaxValueName,
                              &cbMaxValueData,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime);

    if (dwError) {
        SetLastError( dwError );
        DBGMSG(DBG_WARNING, ("SpoolerIniAll failed RegQueryInfoKey HKEY_USERS error %d\n", dwError));
        return FALSE;
    }

    if (cSubKeys < 1)
        return TRUE;

    pUsers = AllocSplMem(cSubKeys * sizeof(pUsers[0]));

    if (!pUsers) {
        DBGMSG(DBG_WARNING, ("SpoolerIniAll failed to allocate pUsers error %d\n", dwError));
        return FALSE;
    }

    for (i=0, pCurUser=pUsers, cUsers=0;
        i< cSubKeys;
        i++) {

        cchSubKey = COUNTOF(szSubKey);

        dwError = RegEnumKeyEx(HKEY_USERS,
                          i,
                          szSubKey,
                          &cchSubKey,
                          NULL,
                          NULL,
                          NULL,
                          &ftLastWriteTime);
        if ( dwError ) {

            //
            // We possibly should return an error here if we fail to initiatise a
            // user.
            //
            DBGMSG( DBG_WARNING, ("SpoolerInitAll failed RegEnumKeyEx HKEY_USERS %ws %d %d\n", szSubKey, i, dwError));
            SetLastError( dwError );

        } else {

            if (!_wcsicmp(szSubKey, szDotDefault) || wcschr(szSubKey, L'_')) {
                continue;
            }

            if (InitializeRegUser(szSubKey, pCurUser)) {

                pCurUser++;
                cUsers++;
            }
        }
    }

    bSuccess = SetupRegForUsers(pUsers,
                                cUsers);

    for (i=0; i< cUsers; i++)
        FreeRegUser(&pUsers[i]);

    //
    // In case we are starting after the user has logged in, inform
    // all applications that there may be printers now.
    //
    BroadcastMessage(BROADCAST_TYPE_CHANGEDEFAULT,
                     0,
                     0,
                     0);

    FreeSplMem(pUsers);

    if ( !bSuccess ) {
        DBGMSG( DBG_WARNING, ("SpoolerInitAll failed error %d\n", GetLastError() ));
    } else {
        DBGMSG( DBG_TRACE, ("SpoolerInitAll Success\n" ));
    }

    return bSuccess;
}

BOOL
DeleteOldPerMcConnections(
    HKEY   hConnectionKey,
    HKEY   hMcConnectionKey
    )

/*++
Function Description - Deletes the existing permachine connections from hConnectionKey

Parameters - hConnectionKey - handle to hUserKey\Printers\Connections

Return Values - TRUE if success
                FALSE otherwise.

--*/

{
    BOOL   bReturn = TRUE;
    struct Node {
       struct Node *pNext;
       LPTSTR szPrinterName;
    }   *phead = NULL,*ptemp = NULL;

    LONG  lstatus;
    DWORD dwRegIndex,dwNameSize,cbdata,dwquerylocal,dwType;
    WCHAR szPrinterName[MAX_UNC_PRINTER_NAME];
    HKEY  hPrinterKey;

    // Before deleting the old permachine connections, we need to record all them into
    // a list. This is required because, the subkeys should not be deleted while they
    // are being enumerated.

    // Identifying permachine connections and saving the printernames in a list.

    for (dwRegIndex = 0;

         dwNameSize = COUNTOF(szPrinterName),
         ((lstatus = RegEnumKeyEx(hConnectionKey, dwRegIndex, szPrinterName,
                                  &dwNameSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS);

         ++dwRegIndex) {

       if (RegOpenKeyEx(hConnectionKey, szPrinterName, 0, KEY_READ, &hPrinterKey)
                  != ERROR_SUCCESS) {

          bReturn = FALSE;
          goto CleanUp;
       }

       dwquerylocal = 0;
       cbdata = sizeof(dwquerylocal);

       RegQueryValueEx(hPrinterKey, L"LocalConnection", NULL, &dwType,
                        (LPBYTE)&dwquerylocal, &cbdata);

       RegCloseKey(hPrinterKey);

       //
       // See if it's a LocalConnection, and if it exists on the current
       // machine.  We don't want to delete it if it is a per-machine
       // connection, since we want to keep the associated per-user
       // DevMode.
       //
       if( ERROR_SUCCESS == RegOpenKeyEx( hMcConnectionKey,
                                          szPrinterName,
                                          0,
                                          KEY_READ,
                                          &hPrinterKey )) {
           //
           // The per-machine key exists.  Close it and don't bother
           // deleting this connection.
           //
           RegCloseKey( hPrinterKey );

       } else {

           //
           // It's not a per-machine connection.  Prepare to delete it.
           //
           if (dwquerylocal == 1) {
               if (!(ptemp = (struct Node *) AllocSplMem(sizeof(struct Node)))) {
                   bReturn = FALSE;
                   goto CleanUp;
               }
               ptemp->pNext = phead;
               phead = ptemp;
               if (!(ptemp->szPrinterName = AllocSplStr(szPrinterName))) {
                   bReturn = FALSE;
                   goto CleanUp;
               }
           }
       }
    }

    if (lstatus != ERROR_NO_MORE_ITEMS) {
       bReturn = FALSE;
       goto CleanUp;
    }

    // Deleting old permachine connections. The printer names are stored in the
    // list pointed to by phead.

    for (ptemp = phead; ptemp != NULL; ptemp = ptemp->pNext) {
       if (RegDeleteKey(hConnectionKey,ptemp->szPrinterName) != ERROR_SUCCESS) {
          bReturn = FALSE;
          goto CleanUp;
       }
    }


CleanUp:

    while (ptemp = phead) {
       phead = phead->pNext;
       if (ptemp->szPrinterName) FreeSplStr(ptemp->szPrinterName);
       FreeSplMem(ptemp);
    }

    return bReturn;

}

BOOL
AddNewPerMcConnections(
    HKEY   hConnectionKey,
    HKEY   hMcConnectionKey
    )

/*++
Function Description - Adds per-machine connections to the user hive if the connection
                       does not already exist.

Parameters - hConnectionKey   - handle to hUserKey\Printers\Connections
             hMcConnectionKey - handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
                                          Control\Print\Connections
Return Values - TRUE if success
                FALSE otherwise.
--*/

{   DWORD dwRegIndex,dwNameSize,cbdata,dwType,dwlocalconnection = 1;
    WCHAR szPrinterName[MAX_UNC_PRINTER_NAME];
    WCHAR szConnData[MAX_UNC_PRINTER_NAME];
    LONG  lstatus;
    BOOL  bReturn = TRUE;
    HKEY  hNewConnKey = NULL, hPrinterKey = NULL;


    for (dwRegIndex = 0;

         dwNameSize = COUNTOF(szPrinterName),
         ((lstatus = RegEnumKeyEx(hMcConnectionKey, dwRegIndex, szPrinterName,
                              &dwNameSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS);

         ++dwRegIndex) {

       RegOpenKeyEx(hConnectionKey,szPrinterName,0,KEY_READ,&hNewConnKey);

       if (hNewConnKey == NULL) {

          // Connection does not exist. Add one.

          if (RegCreateKeyEx(hConnectionKey, 
                             szPrinterName, 
                             0, 
                             NULL, 
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE, 
                             NULL, 
                             &hNewConnKey, 
                             NULL) ||
               RegOpenKeyEx(hMcConnectionKey, 
                            szPrinterName, 
                            0, 
                            KEY_READ, 
                            &hPrinterKey)) {

               bReturn = FALSE;
               goto CleanUp;
          }

          cbdata = sizeof(szConnData);
          if (RegQueryValueEx(hPrinterKey,L"Server",NULL,&dwType,(LPBYTE)szConnData,&cbdata)
              || RegSetValueEx(hNewConnKey,L"Server",0,dwType,(LPBYTE)szConnData,cbdata)) {

               bReturn = FALSE;
               goto CleanUp;
          }

          cbdata = sizeof(szConnData);
          if (RegQueryValueEx(hPrinterKey,L"Provider",NULL,&dwType,(LPBYTE)szConnData,&cbdata)
              || RegSetValueEx(hNewConnKey,L"Provider",0,dwType,(LPBYTE)szConnData,cbdata)
              || RegSetValueEx(hNewConnKey,L"LocalConnection",0,REG_DWORD,
                               (LPBYTE)&dwlocalconnection,sizeof(dwlocalconnection))) {

               bReturn = FALSE;
               goto CleanUp;
          }

          RegCloseKey(hPrinterKey);
          hPrinterKey = NULL;
       }

       RegCloseKey(hNewConnKey);
       hNewConnKey = NULL;
    }

    if (lstatus != ERROR_NO_MORE_ITEMS) {
       bReturn = FALSE;
    }

CleanUp:

    if (hNewConnKey) {
       RegCloseKey(hNewConnKey);
    }
    if (hPrinterKey) {
       RegCloseKey(hPrinterKey);
    }

    return bReturn;

}

BOOL
SplRegCopy(
    PINIT_REG_USER pUser,
    HKEY   hMcConnectionKey)

/*++
Function Description - Removes old permachine connections for pUser and adds the new
                       permachine connections from hMcConnectionKey

Parameters - pUser - pointer to INIT_REG_USER which contains hUserKey.
             hMcConnectionKey - handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
                                          Control\Print\Connections

Return Values - TRUE if success
                FALSE otherwise.

--*/

{
    LONG  lstatus;
    BOOL  bReturn = TRUE;
    WCHAR szRegistryConnections[] = L"Printers\\Connections";
    HKEY  hConnectionKey = NULL;

    // Create (if not already present) and open Connections subkey
    lstatus = RegCreateKeyEx(pUser->hKeyUser,
                             szRegistryConnections,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hConnectionKey,
                             NULL);

    if (lstatus != ERROR_SUCCESS) {
       bReturn = FALSE;
       goto CleanUp;
    }

    if (!DeleteOldPerMcConnections(hConnectionKey,hMcConnectionKey)
        || !AddNewPerMcConnections(hConnectionKey,hMcConnectionKey)) {
       bReturn = FALSE;
    }

CleanUp:

    if (hConnectionKey) {
       RegCloseKey(hConnectionKey);
    }

    return bReturn;
}

BOOL
SetupRegForUsers(
    PINIT_REG_USER pUsers,
    DWORD cUsers)
{
    DWORD cbPrinters;
    DWORD cPrinters;
    PBYTE pPrinters;
    HKEY  hMcConnectionKey = NULL;
    WCHAR szMachineConnections[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";

#define pPrinters2 ((PPRINTER_INFO_2)pPrinters)
#define pPrinters4 ((PPRINTER_INFO_4)pPrinters)

    DWORD i, j;
    LPWSTR pszPort;

    //
    // Read in local printers.
    //
    cbPrinters = 1000;
    pPrinters = AllocSplMem(cbPrinters);

    if (!pPrinters)
        return FALSE;

    if (cPrinters = ReadPrinters(NULL,
                                 PRINTER_ENUM_LOCAL,
                                 &cbPrinters,
                                 &pPrinters)) {

        for (i=0; i< cUsers; i++) {

            for(j=0; j< cPrinters; j++) {

                if( pPrinters2[j].Attributes & PRINTER_ATTRIBUTE_NETWORK ){

                    //
                    // Use NeXX:
                    //
                    pszPort = NULL;

                } else {

                    pszPort = CheckBadPortName( pPrinters2[j].pPortName );
                }

                UpdatePrinterInfo( &pUsers[i],
                                   pPrinters2[j].pPrinterName,
                                   pszPort,
                                   &(pUsers[i].dwNetCounter));
            }
        }
    }

    // Open the Key containing the current list of per-machine connections.
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMachineConnections, 0,
                 KEY_READ , &hMcConnectionKey);

    for (i=0; i< cUsers; i++) {

        // Copy Per Machine Connections into the user hive
        SplRegCopy(&pUsers[i], hMcConnectionKey);

        if (cPrinters = ReadPrinters(&pUsers[i],
                                     PRINTER_ENUM_CONNECTIONS,
                                     &cbPrinters,
                                     &pPrinters)) {

            for(j=0; j< cPrinters; j++) {

                UpdatePrinterInfo(&pUsers[i],
                                  pPrinters4[j].pPrinterName,
                                  NULL,
                                  &(pUsers[i].dwNetCounter));
            }
        }
    }

    // Close the handle to Per Machine Connections.

    if (hMcConnectionKey) RegCloseKey(hMcConnectionKey);

    FreeSplMem(pPrinters);

    for (i=0; i< cUsers; i++) {

        UpdateUsersDefaultPrinter(&pUsers[i], FALSE);
    }
    return TRUE;

#undef pPrinters2
#undef pPrinters4
}


VOID
UpdateUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN BOOL             bFindDefault
    )
/*++

Routine Description:

    Updates the default printer using the information in the
    current users reg structure.  If the bFindDefault flag is
    specified then a default printer is located.  The method for this
    is first see if there is currently a default printer, then user this.
    If a default printer is not found then located the first printer in
    devices section, again if on exists.

Arguments:

    pUser           - Information about the current user, reg keys etc.
                      This routine assumes that hKeyWindows and hKeyDevices
                      are valid opened registry keys, with read access.
    bFindDefault    - TRUE located a default printer, FALSE the default
                      printer is already specified in the users reg
                      structure.

Return Value:

    Nothing.

--*/
{
    LPWSTR pszNewDefault = NULL;

    //
    // If a request to find the default printer.
    //
    if (bFindDefault) {

        DWORD   dwError = ERROR_SUCCESS;
        DWORD   cbData  = sizeof(pUser->szDefaultPrinter);

        //
        // Check if there is a default printer.
        //
        dwError = RegQueryValueEx(pUser->hKeyWindows,
                                  szDevice,
                                  NULL,
                                  NULL,
                                  (PBYTE)pUser->szDefaultPrinter,
                                  &cbData);

        //
        // If the device key was read and there is a non null string
        // as the default printer name.
        //
        if (dwError == ERROR_SUCCESS && pUser->szDefaultPrinter[0] != L'\0') {

            pUser->bDefaultFound = TRUE;

        } else {

            //
            // Default was not found.
            //
            pUser->bDefaultFound = FALSE;

            //
            // If a first printer was not found.
            //
            if (!pUser->bFirstPrinterFound)
            {
                DWORD cchPrinterLen = 0;
                WCHAR szBuffer [MAX_PATH*2];
                DWORD cbDataBuffer = sizeof(szBuffer);

                DBGMSG(DBG_TRACE, ("UpdateUsersDefaultPrinter default printer not found.\n"));

                cchPrinterLen = cbData = COUNTOF(pUser->szFirstPrinter);

                //
                // Default printer was not found, find any printer
                // in the devices section of the registry.
                //
                dwError = RegEnumValue(pUser->hKeyDevices,
                                       0,
                                       pUser->szFirstPrinter,
                                       &cbData,
                                       NULL,
                                       NULL,
                                       (PBYTE)szBuffer,
                                       &cbDataBuffer);

                if (dwError == ERROR_SUCCESS) {

                    StringCchCat(pUser->szFirstPrinter, cchPrinterLen, L",");
                    StringCchCat(pUser->szFirstPrinter, cchPrinterLen, szBuffer);

                    pUser->bFirstPrinterFound = TRUE;

                } else {

                    DBGMSG(DBG_WARNING, ("UpdateUsersDefaultPrinter no printer found in devices section.\n"));

                    pUser->bFirstPrinterFound = FALSE;
                }
            }
        }
    }

    //
    // If default wasn't present, and we did get a first printer,
    // make this the default.
    //
    if (!pUser->bDefaultFound) {

        if (pUser->bFirstPrinterFound) {

            pszNewDefault = pUser->szFirstPrinter;
        }

    } else {

        //
        // Write out default.
        //
        pszNewDefault = pUser->szDefaultPrinter;
    }

    if (pszNewDefault) {

        RegSetValueEx(pUser->hKeyWindows,
                      szDevice,
                      0,
                      REG_SZ,
                      (PBYTE)pszNewDefault,
                      (wcslen(pszNewDefault) + 1) * sizeof(pszNewDefault[0]));
    }
}

HRESULT
IsUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN PCWSTR           pszPrinterName
    )
/*++

Routine Description:

    Asks if the users default printer matched the specified
    printer name.

Arguments:

    pCurUser        - Information about the current user, reg keys etc.
                      This routine assumes that hKeyWindows is a valid
                      opened registry keys, with at least read access.
    pszPrinterName  - Printer name to check if it is the default printer.

Return Value:

    S_OK the printer name is the default, S_FALSE the printer is not the
    default, An HRESULT error code if an error occurrs attempting to
    determine the default printer.

--*/
{
    HRESULT hr = E_INVALIDARG;

    if (pszPrinterName) {

        WCHAR   szBuffer[MAX_PATH*2];
        DWORD   dwError = ERROR_SUCCESS;
        DWORD   cbData  = sizeof(szBuffer);

        //
        // Read the default printer, if one exists.
        //
        dwError = RegQueryValueEx(pUser->hKeyWindows,
                                  szDevice,
                                  NULL,
                                  NULL,
                                  (PBYTE)szBuffer,
                                  &cbData);

        if (dwError == ERROR_SUCCESS) {

            PWSTR p = wcschr(szBuffer, L',');

            if (p) {

                *p = 0;
            }

            hr = !_wcsicmp(pszPrinterName, szBuffer) ? S_OK : S_FALSE;

        } else {

            hr = HRESULT_FROM_WIN32(dwError);

        }
    }

    return hr;
}

DWORD
ReadPrinters(
    PINIT_REG_USER pUser,
    DWORD Flags,
    PDWORD pcbPrinters,
    LPBYTE* ppPrinters)
{
    BOOL   bSuccess  = FALSE;
    DWORD  cbNeeded  = 0;
    DWORD  cPrinters = 0;
    LPBYTE pPrinters = NULL;


    if (Flags == PRINTER_ENUM_CONNECTIONS) {

        bSuccess = EnumerateConnectedPrinters(*ppPrinters,
                                              *pcbPrinters,
                                              &cbNeeded,
                                              &cPrinters,
                                              pUser->hKeyUser);
    } else {

        bSuccess = EnumPrinters(Flags,
                                NULL,
                                2,
                                (PBYTE)*ppPrinters,
                                *pcbPrinters,
                                &cbNeeded,
                                &cPrinters);
    }

    if (!bSuccess && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

        //
        // If not enough space, realloc.
        //
        if (pPrinters = ReallocSplMem(*ppPrinters,
                                      0,
                                      cbNeeded)) {
            *ppPrinters = pPrinters;
            pPrinters = NULL;
            *pcbPrinters = cbNeeded;
            bSuccess = TRUE;
        }
        else {
            bSuccess = FALSE;
        }

        if (bSuccess) {
            if (Flags == PRINTER_ENUM_CONNECTIONS) {

                bSuccess = EnumerateConnectedPrinters(*ppPrinters,
                                                      *pcbPrinters,
                                                      &cbNeeded,
                                                      &cPrinters,
                                                      pUser->hKeyUser);
            } else {

                bSuccess = EnumPrinters(Flags,
                                        NULL,
                                        2,
                                        (PBYTE)*ppPrinters,
                                        *pcbPrinters,
                                        &cbNeeded,
                                        &cPrinters);
            }
        }
    }
    if (!bSuccess) {
        cPrinters = 0;
    }


    return cPrinters;
}

BOOL
UpdatePrinterInfo(
    const PINIT_REG_USER pCurUser,
    LPCWSTR pszPrinterName,
    LPCWSTR pszPort,
    PDWORD pdwNetId
    )
/*++

Routine Description:

    Updates the printer information in the registry win.ini.

Arguments:

    pCurUser - Information about the user.  The following fields are
        used by this routine:

        hKeyDevices
        hKeyPrinterPorts
        bDefaultSearch (if true, read/writes to:)
            bDefaultFound
            szDefaultPrinter
        bFirstPrinterFound (if false, writes to:)
            szFirstPrinter

    pszPort - Port name.  If NULL, generates NetId.

    pdwNetId - Pointer to NetId counter.  This value will be incremented
        if the NetId is used.

Return Value:

--*/
{
    WCHAR szBuffer[MAX_PATH * 2];
    LPWSTR p;

    DWORD dwCount = 0;
    DWORD cbLen;

    if (!pszPrinterName)
        return FALSE;

    //
    // Now we know the spooler is up, since the EnumPrinters succeeded.
    // Update all sections.
    //
    StringCchPrintf(szBuffer,
                    MAX_PATH*2,
                    L"%s,",
                    szWinspool);

    dwCount = wcslen(szBuffer);

    if( !pszPort ){

        HANDLE hToken;

        StringCchPrintf(&szBuffer[dwCount],
                        MAX_PATH*2 - dwCount,
                        L"%s%.2d:",
                        szNetwork,
                        *pdwNetId);

        (*pdwNetId)++;

        //
        // !! HACK !!
        //
        // Works 3.0b expects the printer port entry in the
        // [ports] section.
        //
        // This is in the per-machine part of the registry, but we
        // are updating it for each user.  Fix later.
        //
        // We never remove the NeXX: entries from [ports] but since
        // the same entries will be used by all users, this is ok.
        //
        hToken = RevertToPrinterSelf();

        WriteProfileString( szPorts, &szBuffer[dwCount], L"" );

        if( hToken ){
            ImpersonatePrinterClient( hToken );
        }
        //
        // End Works 3.0b HACK
        //

    } else {

        StringCchCopy(&szBuffer[dwCount],
                      MAX_PATH*2 - dwCount,
                      pszPort);

        //
        // Get the first port only.
        //
        if ( p = wcschr(&szBuffer[dwCount], L',') )
            *p = 0;
    }

    cbLen = (wcslen(szBuffer)+1) * sizeof(szBuffer[0]);

    RegSetValueEx(pCurUser->hKeyDevices,
                  pszPrinterName,
                  0,
                  REG_SZ,
                  (PBYTE)szBuffer,
                  cbLen);

    //
    // If the user has a default printer specified, then verify
    // that it exists.
    //

    if (pCurUser->bDefaultSearch) {

        pCurUser->bDefaultFound = !_wcsicmp(pszPrinterName,
                                           pCurUser->szDefaultPrinter);

        if (pCurUser->bDefaultFound) {

            StringCchPrintf(pCurUser->szDefaultPrinter,
                            COUNTOF(pCurUser->szDefaultPrinter),
                            L"%s,%s",
                            pszPrinterName,
                            szBuffer);

            pCurUser->bDefaultSearch = FALSE;
        }
    }

    if (!pCurUser->bFirstPrinterFound) {

        StringCchPrintf(pCurUser->szFirstPrinter,
                        COUNTOF(pCurUser->szFirstPrinter),
                        L"%s,%s",
                        pszPrinterName,
                        szBuffer);

        pCurUser->bFirstPrinterFound = TRUE;
    }

    StringCchCat(szBuffer, COUNTOF(szBuffer), szTimeouts);

    RegSetValueEx(pCurUser->hKeyPrinterPorts,
                  pszPrinterName,
                  0,
                  REG_SZ,
                  (PBYTE)szBuffer,
                  (wcslen(szBuffer)+1) * sizeof(szBuffer[0]));

    return TRUE;
}

VOID
SpoolerInitAsync(
    PINIT_REG_USER  pUser
    )

/*++

Routine Description: Asynchronously sets up the user's registry information

Arguments:  pUser    -  pointer to INIT_REG_USER containing user keys

Return Values: NONE

--*/

{
    if (InitializeRegUser(NULL, pUser))
    {
        SetupRegForUsers(pUser, 1);
    }

    BroadcastMessage(BROADCAST_TYPE_CHANGEDEFAULT,0,0,0);
    FreeRegUser(pUser);
    FreeSplMem(pUser);
}

BOOL
SpoolerInit(
    VOID
    )

/*++

Routine Description:  Initializes just the current user.

Arguments: NONE

Return Value: TRUE if initialized or async init thread created successfully
              FALSE otherwise

--*/

{
    BOOL           bSuccess = FALSE;
    DWORD          dwThreadId;
    HANDLE         hThread;
    PINIT_REG_USER pUser;

    UpdateLogonTimeStamp ();

    if (!(pUser = AllocSplMem(sizeof(INIT_REG_USER)))) {

        return FALSE;
    }

    //
    // Enum just the current user.
    //
    pUser->hKeyUser = GetClientUserHandle(KEY_READ|KEY_WRITE);

    if (pUser->hKeyUser)
    {
        if (!Initialized)
        {
            //
            // Process the user initialization asynchronously if the spooler
            // hasn't completed it's initialization.
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) SpoolerInitAsync,
                                   (LPVOID) pUser, 0, &dwThreadId);

            if (hThread)
            {
                //
                // We assume that the async thread will succeed.
                //
                CloseHandle(hThread);
                bSuccess = TRUE;
            }
            else
            {
                FreeRegUser(pUser);
                FreeSplMem(pUser);
            }
        }
        else
        {
            if (InitializeRegUser(NULL, pUser))
            {
                bSuccess = SetupRegForUsers(pUser, 1);
            }

            FreeRegUser(pUser);
            FreeSplMem(pUser);
        }
    }

    return bSuccess;
}

BOOL
InitializeRegUser(
    LPWSTR pszSubKey,
    PINIT_REG_USER pUser
    )
/*++

Routine Description:

    Initialize a single users structure based on a HKEY_USERS subkey.

Arguments:

    pszSubKey - if non-NULL initialize hKeyUser to this key

    pUser - structure to initialize

Return Value:

--*/
{
    HKEY                    hKey;
    LPWSTR                  p;
    BOOL                    bSecurityLoaded = FALSE, rc = FALSE;
    DWORD                   cbData, cbSD = 0, dwError, dwDisposition;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    HANDLE hToken = NULL;

    if (pszSubKey) {

        if (RegOpenKeyEx(HKEY_USERS,
                         pszSubKey,
                         0,
                         KEY_READ|KEY_WRITE,
                         &pUser->hKeyUser) != ERROR_SUCCESS) {

            DBGMSG(DBG_WARNING, ("InitializeRegUser: RegOpenKeyEx failed\n"));
            goto Fail;
        }
    }

    //
    // Now attempt to set the security on these two keys to
    // their parent key.
    //
    dwError = RegOpenKeyEx(pUser->hKeyUser,
                           szCurrentVersionPath,
                           0,
                           KEY_READ,
                           &hKey);

    if (!dwError) {

        dwError = RegGetKeySecurity(hKey,
                                    DACL_SECURITY_INFORMATION,
                                    pSD,
                                    &cbSD);

        if (dwError == ERROR_INSUFFICIENT_BUFFER) {

            pSD = AllocSplMem(cbSD);

            if (pSD) {

                if (!RegGetKeySecurity(hKey,
                                       DACL_SECURITY_INFORMATION,
                                       pSD,
                                       &cbSD)){

                    bSecurityLoaded = TRUE;

                } else {

                    DBGMSG(DBG_WARNING, ("InitializeRegUser: RegGetKeySecurity failed %d\n",
                                         GetLastError()));
                }
            }
        } else {

            DBGMSG(DBG_WARNING, ("InitializeRegUser: RegGetKeySecurity failed %d\n",
                                 dwError));
        }
        RegCloseKey(hKey);

    } else {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegOpenKeyEx CurrentVersion failed %d\n",
                             dwError));
    }


    hToken = RevertToPrinterSelf();

    //
    // Open up the right keys.
    //
    if (RegCreateKeyEx(pUser->hKeyUser,
                       szRegDevicesPath,
                       0,
                       szNULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &pUser->hKeyDevices,
                       &dwDisposition) != ERROR_SUCCESS) {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegCreateKeyEx1 failed %d\n",
                             GetLastError()));

        goto Fail;
    }

    if (bSecurityLoaded) {
        RegSetKeySecurity(pUser->hKeyDevices,
                          DACL_SECURITY_INFORMATION,
                          pSD);
    }


    if (RegCreateKeyEx(pUser->hKeyUser,
                       szRegPrinterPortsPath,
                       0,
                       szNULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &pUser->hKeyPrinterPorts,
                       &dwDisposition) != ERROR_SUCCESS) {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegCreateKeyEx2 failed %d\n",
                             GetLastError()));

        goto Fail;
    }

    if (bSecurityLoaded) {
        RegSetKeySecurity(pUser->hKeyPrinterPorts,
                          DACL_SECURITY_INFORMATION,
                          pSD);
    }

    //
    // First, attempt to clear out the keys by deleting them.
    //
    RegClearKey(pUser->hKeyDevices);
    RegClearKey(pUser->hKeyPrinterPorts);

    if (RegOpenKeyEx(pUser->hKeyUser,
                     szRegWindowsPath,
                     0,
                     KEY_READ|KEY_WRITE,
                     &pUser->hKeyWindows) != ERROR_SUCCESS) {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegOpenKeyEx failed %d\n",
                             GetLastError()));

        goto Fail;
    }

    pUser->bFoundPrinter = FALSE;
    pUser->bDefaultSearch = FALSE;
    pUser->bDefaultFound = FALSE;
    pUser->bFirstPrinterFound = FALSE;
    pUser->dwNetCounter = 0;


    cbData = sizeof(pUser->szDefaultPrinter);

    if (RegQueryValueEx(pUser->hKeyWindows,
                        szDevice,
                        NULL,
                        NULL,
                        (PBYTE)pUser->szDefaultPrinter,
                        &cbData) == ERROR_SUCCESS) {

        pUser->bDefaultSearch = TRUE;
    }

    //
    // Remove the Device= in [windows]
    //
    RegDeleteValue(pUser->hKeyWindows,
                   szDevice);

    if (!pUser->bDefaultSearch) {

        //
        // Attempt to read from saved location.
        //
        if (RegOpenKeyEx(pUser->hKeyUser,
                         szPrinters,
                         0,
                         KEY_READ,
                         &hKey) == ERROR_SUCCESS) {

            cbData = sizeof(pUser->szDefaultPrinter);

            //
            // Try reading szDeviceOld.
            //
            if (RegQueryValueEx(
                    hKey,
                    szDeviceOld,
                    NULL,
                    NULL,
                    (PBYTE)pUser->szDefaultPrinter,
                    &cbData) == ERROR_SUCCESS) {

                pUser->bDefaultSearch = TRUE;
            }

            RegCloseKey(hKey);
        }
    }

    if ( pUser->bDefaultSearch )
    {
         pUser->szDefaultPrinter[COUNTOF(pUser->szDefaultPrinter) - 1] = '\0';
         if (p = wcschr(pUser->szDefaultPrinter, L',')) 
         {
            *p = 0;
         }
    }

    rc = TRUE;

Fail:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    if (pSD) {
        FreeSplMem(pSD);
    }

    if (!rc)
        FreeRegUser(pUser);

    return rc;
}


VOID
FreeRegUser(
    PINIT_REG_USER pUser)

/*++

Routine Description:

    Free up the INIT_REG_USER structure intialized by InitializeRegUser.

Arguments:

Return Value:

--*/

{
    if (pUser->hKeyUser) {
        RegCloseKey(pUser->hKeyUser);
        pUser->hKeyUser = NULL;
    }

    if (pUser->hKeyDevices) {
        RegCloseKey(pUser->hKeyDevices);
        pUser->hKeyDevices = NULL;
    }

    if (pUser->hKeyPrinterPorts) {
        RegCloseKey(pUser->hKeyPrinterPorts);
        pUser->hKeyPrinterPorts = NULL;
    }

    if (pUser->hKeyWindows) {
        RegCloseKey(pUser->hKeyWindows);
        pUser->hKeyWindows = NULL;
    }
}


VOID
UpdatePrinterRegAll(
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL bDelete
    )
/*++

Routine Description:

    Updates everyone's [devices] and [printerports] sections (for
    local printers only).

Arguments:

    pszPrinterName - printer that has been added/deleted

    pszPort - port name; if NULL, generate NetId

    bDelete - if TRUE, delete entry instead of updating it.

Return Value:

--*/
{
    WCHAR szKey[MAX_PATH];
    DWORD cchKey;
    DWORD i;
    FILETIME ftLastWriteTime;
    DWORD dwError;

    //
    // Go through all keys and fix them up.
    //
    for (i=0; TRUE; i++) {

        cchKey = COUNTOF(szKey);

        dwError = RegEnumKeyEx(HKEY_USERS,
                               i,
                               szKey,
                               &cchKey,
                               NULL,
                               NULL,
                               NULL,
                               &ftLastWriteTime);

        if (dwError != ERROR_SUCCESS)
            break;

        if (!_wcsicmp(szKey, szDotDefault) || wcschr(szKey, L'_'))
            continue;

        UpdatePrinterRegUser(NULL,
                             szKey,
                             pszPrinterName,
                             pszPort,
                             bDelete);
    }
}


DWORD
UpdatePrinterRegUser(
    HKEY hKeyUser,
    LPWSTR pszUserKey,
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL bDelete
    )
/*++

Routine Description:

    Update one user's registry.  The user is specified by either
    hKeyUser or pszUserKey.

Arguments:

    hKeyUser - Clients user key (ignored if pszKey specified)

    pszUserKey - Clients SID (Used if supplied instead of hKeyUser)

    pszPrinterName - name of printe to add

    pszPort - port name; if NULL, generate NetId

    bDelete - if TRUE, delete entry instead of updating.

Return Value:

    NOTE: We never cleanup [ports] since it is per-user
          EITHER hKeyUser or pszUserKey must be valid, but not both.

--*/
{
    HKEY hKeyClose = NULL;
    HKEY hKeyRoot;
    DWORD dwError;
    WCHAR szBuffer[MAX_PATH];
    DWORD dwNetId;

    INIT_REG_USER InitRegUser;

    ZeroMemory(&InitRegUser, sizeof(InitRegUser));

    InitRegUser.hKeyDevices = NULL;
    InitRegUser.hKeyPrinterPorts = NULL;
    InitRegUser.bDefaultSearch = FALSE;
    InitRegUser.bFirstPrinterFound = TRUE;

    //
    // Setup the registry keys.
    //
    if (pszUserKey) {

        dwError = RegOpenKeyEx( HKEY_USERS,
                                pszUserKey,
                                0,
                                KEY_READ|KEY_WRITE,
                                &hKeyRoot );

        if (dwError != ERROR_SUCCESS) {
            goto Done;
        }

        hKeyClose = hKeyRoot;

    } else {

        hKeyRoot = hKeyUser;
    }

    dwError = RegOpenKeyEx(hKeyRoot,
                           szRegDevicesPath,
                           0,
                           KEY_READ|KEY_WRITE,
                           &InitRegUser.hKeyDevices);

    if (dwError != ERROR_SUCCESS)
        goto Done;

    dwError = RegOpenKeyEx(hKeyRoot,
                           szRegWindowsPath,
                           0,
                           KEY_READ|KEY_WRITE,
                           &InitRegUser.hKeyWindows);

    if (dwError != ERROR_SUCCESS)
        goto Done;

    //
    // Setup [PrinterPorts]
    //
    dwError = RegOpenKeyEx(hKeyRoot,
                           szRegPrinterPortsPath,
                           0,
                           KEY_WRITE,
                           &InitRegUser.hKeyPrinterPorts);

    if (dwError != ERROR_SUCCESS)
        goto Done;

    if (!bDelete) {

        pszPort = CheckBadPortName( pszPort );

        if( !pszPort ){
            dwNetId = GetNetworkIdWorker(InitRegUser.hKeyDevices,
                                         pszPrinterName);
        }

        InitRegUser.bFirstPrinterFound = FALSE;

        UpdatePrinterInfo( &InitRegUser,
                           pszPrinterName,
                           pszPort,
                           &dwNetId );

        UpdateUsersDefaultPrinter( &InitRegUser,
                                   TRUE );

    } else {

        HKEY hKeyDevMode;

        //
        // Delete the entries.
        //
        RegDeleteValue(InitRegUser.hKeyDevices, pszPrinterName);
        RegDeleteValue(InitRegUser.hKeyPrinterPorts, pszPrinterName);

        //
        // Check if the printer we are deleting is currently the
        // default printer.
        //
        if (IsUsersDefaultPrinter(&InitRegUser, pszPrinterName) == S_OK) {

            //
            // Remove the default printer from the registry.
            //
            RegDeleteValue(InitRegUser.hKeyWindows, szDevice);
        }

        //
        // Also delete DevModes2 entry from registry
        //
        dwError = RegOpenKeyEx( hKeyRoot,
                                szDevModes2Path,
                                0,
                                KEY_WRITE,
                                &hKeyDevMode );

        if (dwError == ERROR_SUCCESS) {

            //
            //  Delete the devmode value entry for the particular printer
            //
            RegDeleteValue(hKeyDevMode, pszPrinterName);
            RegCloseKey(hKeyDevMode);
        }

        //
        // Remove the per-user DevMode.
        //
        bSetDevModePerUser( hKeyRoot,
                            pszPrinterName,
                            NULL );
    }

Done:

    if( InitRegUser.hKeyDevices ){
        RegCloseKey( InitRegUser.hKeyDevices );
    }

    if( InitRegUser.hKeyWindows ){
        RegCloseKey( InitRegUser.hKeyWindows );
    }

    if( InitRegUser.hKeyPrinterPorts ){
        RegCloseKey( InitRegUser.hKeyPrinterPorts );
    }

    if( hKeyClose ){
        RegCloseKey( hKeyClose );
    }

    return dwError;
}


VOID
RegClearKey(
    HKEY hKey
    )
{
    DWORD dwError;
    WCHAR szValue[MAX_PATH];

    DWORD cchValue;

    while (TRUE) {

        cchValue = COUNTOF(szValue);
        dwError = RegEnumValue(hKey,
                               0,
                               szValue,
                               &cchValue,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (dwError != ERROR_SUCCESS) {

            if( dwError != ERROR_NO_MORE_ITEMS ){
                DBGMSG( DBG_WARN, ( "RegClearKey: RegEnumValue failed %d\n", dwError ));
            }
            break;
        }

        dwError = RegDeleteValue(hKey, szValue);

        if( dwError != ERROR_SUCCESS) {
            DBGMSG( DBG_WARN, ( "RegClearKey: RegDeleteValue failed %d\n", dwError ));
            break;
        }
    }
}


LPWSTR
CheckBadPortName(
    LPWSTR pszPort
    )
/*++

Routine Description:

    This routine checks whether a port name should be converted to
    NeXX:.  Currently if the port is NULL, or "\\*," or has a space,
    we convert to NeXX.

Arguments:

    pszPort - port to check

Return Value:

    pszPort - if port is OK.
    NULL    - if port needs to be converted

--*/

{
    //
    // If we have no pszPort,                          OR
    //     it begins with '\\' (as in \\server\share)  OR
    //     it has a space in it                        OR
    //     it's length is greater than 5 ("LPT1:")
    // Then
    //     use NeXX:
    //
    // Most 16 bit apps can't deal with long port names, since they
    // allocate small buffers.
    //
    if( !pszPort ||
        ( pszPort[0] == L'\\' && pszPort[1] == L'\\' ) ||
        wcschr( pszPort, L' ' )                        ||
        wcslen( pszPort ) > 5 ){

        return NULL;
    }
    return pszPort;
}


BOOL
UpdateLogonTimeStamp(
    void
    )
{
    long lstatus;
    HKEY hProvidersKey  = NULL;
    FILETIME   LogonTime;

    LPWSTR szPrintProviders = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Providers";
    LPWSTR szLogonTime      = L"LogonTime";

    GetSystemTimeAsFileTime (&LogonTime);

    // Create (if not already present) and open Connections subkey
    lstatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             szPrintProviders,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE,
                             NULL,
                             &hProvidersKey,
                             NULL);

    if (lstatus == ERROR_SUCCESS) {

        lstatus = RegSetValueEx (hProvidersKey,
                                 szLogonTime,
                                 0,
                                 REG_BINARY,
                                 (LPBYTE) &LogonTime,
                                 sizeof (FILETIME));

        RegCloseKey(hProvidersKey);
    }

    return lstatus == ERROR_SUCCESS;
}

/*++

Routine Name

    AllowRemoteCalls

Routine Description:

    This chains into the server and tells it to allow remote calls on the RPC
    interface. Note that this is reference counted.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT
AllowRemoteCalls(
    VOID
    )
{
    HRESULT hr = (gpServerExports && gpServerExports->FnAllowRemoteCalls) ? 
                     S_OK : 
                     E_UNEXPECTED;

    if (SUCCEEDED(hr))
    {
        hr = gpServerExports->FnAllowRemoteCalls();
    }

    return hr;
}


/*++

Routine Name

    GetServerPolicy

Routine Description:

    This chains into the server and gets a numeric policy read
    by the server.

Arguments:

    pszPolicyName - policy name
    pValue        - pointer to numeric value

Return Value:

    An HRESULT

--*/
HRESULT
GetServerPolicy(
    IN  PCWSTR   pszPolicyName,
    IN  ULONG*   pValue
    )
{
    HRESULT hr = (gpServerExports && gpServerExports->FnGetServerPolicy) ? 
                     S_OK : 
                     E_UNEXPECTED;

    if (SUCCEEDED(hr))
    {
        hr = (pValue && pszPolicyName) ? S_OK : E_POINTER;

        if (SUCCEEDED(hr))
        {
            hr = gpServerExports->FnGetServerPolicy(pszPolicyName, pValue);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\threadm.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ThreadM.c

Abstract:

    Generic thread manager for spooler.

Author:

    Albert Ting (AlbertT) 13-Feb-1994

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "threadm.h"

#define ENTER_CRITICAL(pTMStateVar) \
    EnterCriticalSection(pTMStateVar->pTMStateStatic->pCritSec)
#define LEAVE_CRITICAL(pTMStateVar) \
    LeaveCriticalSection(pTMStateVar->pTMStateStatic->pCritSec)

//
// Prototypes
//
DWORD
xTMThreadProc(
    LPVOID pVoid);


BOOL
TMCreateStatic(
    PTMSTATESTATIC pTMStateStatic)

/*++

Routine Description:

    Intialize static state.

Arguments:

    pTMStateStatic - static state to initialize

Return Value:

    TRUE = success
    FALSE = fail

--*/

{
    return TRUE;
}




VOID
TMDestroyStatic(
    PTMSTATESTATIC pTMStateStatic)

/*++

Routine Description:

    Destroys static state.

Arguments:

    pTMStateStatic - static state to destroy

Return Value:

    VOID

--*/

{
}




BOOL
TMCreate(
    PTMSTATESTATIC pTMStateStatic,
    PTMSTATEVAR pTMStateVar)

/*++

Routine Description:

    Creates a virtual TM object.

Arguments:

    pTMStateStatic - static portion of the TM object that can be
                     used multiple times for subsequent instantiations.

    pTMStateVar    - variable portion of the structure; 1 per instantiation

Return Value:

    TRUE = success
    FALSE = fail

--*/

{
    pTMStateVar->hTrigger = CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

    if (!pTMStateVar->hTrigger)
        return FALSE;

    pTMStateVar->uIdleThreads   = 0;
    pTMStateVar->uActiveThreads = 0;
    pTMStateVar->Status = TMSTATUS_NULL;
    pTMStateVar->pTMStateStatic = pTMStateStatic;

    return TRUE;
}

BOOL
TMDestroy(
    PTMSTATEVAR pTMStateVar)

/*++

Routine Description:

    Destroy TM object.  If threads are currently processing the object,
    mark it pending and return.

Arguments:

    pTMStateVar - TM Object to destroy

Return Value:

    TRUE = success
    FALSE = fail

--*/

{
    ENTER_CRITICAL(pTMStateVar);

    pTMStateVar->Status |= TMSTATUS_DESTROY_REQ;

    if (!pTMStateVar->uActiveThreads) {

        //
        // Mark as destroyed so that no more jobs are processed.
        //
        pTMStateVar->Status |= TMSTATUS_DESTROYED;

        LEAVE_CRITICAL(pTMStateVar);

        if (pTMStateVar->pTMStateStatic->pfnCloseState)
            (*pTMStateVar->pTMStateStatic->pfnCloseState)(pTMStateVar);

    } else {

        LEAVE_CRITICAL(pTMStateVar);
    }

    return TRUE;
}


BOOL
TMAddJob(
    PTMSTATEVAR pTMStateVar)
{
    DWORD dwThreadId;
    HANDLE hThread;
    BOOL rc = TRUE;

    ENTER_CRITICAL(pTMStateVar);

    if (pTMStateVar->Status & TMSTATUS_DESTROY_REQ) {

        rc = FALSE;

    } else {

        //
        // Check if we can give it to an idle thread.
        //
        if (pTMStateVar->uIdleThreads) {

            pTMStateVar->uIdleThreads--;

            DBGMSG(DBG_NOTIFY, ("Trigger event: uIdleThreads = %d\n",
                                pTMStateVar->uIdleThreads));

            SetEvent(pTMStateVar->hTrigger);

        } else if (pTMStateVar->uActiveThreads <
            pTMStateVar->pTMStateStatic->uMaxThreads) {

            //
            // We have less active threads than the max; create a new one.
            //
            DBGMSG(DBG_NOTIFY, ("Create thread: uActiveThreads = %d\n",
                                pTMStateVar->uActiveThreads));

            hThread = CreateThread(NULL,
                                   0,
                                   xTMThreadProc,
                                   pTMStateVar,
                                   0,
                                   &dwThreadId);
            if (hThread) {

                CloseHandle(hThread);

                //
                // We have successfully created a thread; up the
                // count.
                //
                pTMStateVar->uActiveThreads++;

            } else {

                rc = FALSE;
            }
        }
    }

    LEAVE_CRITICAL(pTMStateVar);

    return rc;
}

DWORD
xTMThreadProc(
    LPVOID pVoid)

/*++

Routine Description:

    Worker thread routine that calls the client to process the jobs.

Arguments:

    pVoid - pTMStateVar

Return Value:

    Ignored.

--*/

{
    PTMSTATEVAR pTMStateVar = (PTMSTATEVAR)pVoid;
    PJOB pJob;
    BOOL bQuit = FALSE;

    pJob = (*pTMStateVar->pTMStateStatic->pfnNextJob)(pTMStateVar);

    do {

        while (pJob) {

            //
            // Call back to client to process the job.
            //
            (*pTMStateVar->pTMStateStatic->pfnProcessJob)(pTMStateVar, pJob);

            //
            // If we are pending shutdown, quit now.
            //
            if (pTMStateVar->Status & TMSTATUS_DESTROY_REQ) {
                bQuit = TRUE;
                break;
            }

            pJob = (*pTMStateVar->pTMStateStatic->pfnNextJob)(pTMStateVar);
        }

        ENTER_CRITICAL(pTMStateVar);

        pTMStateVar->uIdleThreads++;
        pTMStateVar->uActiveThreads--;

        DBGMSG(DBG_NOTIFY, ("Going to sleep: uIdle = %d, uActive = %d\n",
                            pTMStateVar->uIdleThreads,
                            pTMStateVar->uActiveThreads));

        LEAVE_CRITICAL(pTMStateVar);

        if (bQuit)
            break;

        //
        // Done, now relax and go idle for a bit.  We don't care whether
        // we timeout or get triggered; in either case we check for another
        // job.
        //
        WaitForSingleObject(pTMStateVar->hTrigger,
                            pTMStateVar->pTMStateStatic->uIdleLife);

        ENTER_CRITICAL(pTMStateVar);

        if (pTMStateVar->Status & TMSTATUS_DESTROY_REQ) {

            pJob = NULL;

        } else {

            //
            // We must check here instead of relying on the return value
            // of WaitForSingleObject since someone may see uIdleThreads!=0
            // and set the trigger, but we timeout before it gets set.
            //
            pJob = (*pTMStateVar->pTMStateStatic->pfnNextJob)(pTMStateVar);

        }

        if (pJob) {

            pTMStateVar->uActiveThreads++;

            DBGMSG(DBG_NOTIFY, ("Woke and found job: uActiveThreads = %d\n",
                                pTMStateVar->uActiveThreads));
        } else {

            if (!pTMStateVar->uIdleThreads) {

                //
                // We may add a job that already is on the list, so
                // uIdleThreads gets dec'd twice, but only 1 job left.
                //
                DBGMSG(DBG_NOTIFY, ("threadm: No jobs, yet no idle threads\n"));

            } else {

                //
                // No jobs, we are going to exit, so we are no longer idle
                //
                pTMStateVar->uIdleThreads--;
            }
        }

        LEAVE_CRITICAL(pTMStateVar);

    } while (pJob);

    DBGMSG(DBG_NOTIFY, ("No active jobs: uIdleThreads = %d, uActiveThreads = %d\n",
                        pTMStateVar->uIdleThreads,
                        pTMStateVar->uActiveThreads));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\winsplc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Includes precompiled header and winspl_c.c.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "winspl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\threads.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    threads.c (thread manager)

Abstract:

    Handles the threads used to for notifications (WPC, FFPCN)

Author:

    Albert Ting (AlbertT) 25-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "threadm.h"
#include "ntfytab.h"

#define ENTER_THREAD_LIST() EnterCriticalSection(tmStateStatic.pCritSec)
#define EXIT_THREAD_LIST()  LeaveCriticalSection(tmStateStatic.pCritSec)

extern CRITICAL_SECTION RouterNotifySection;

DWORD
ThreadNotifyProcessJob(
    PTMSTATEVAR pTMStateVar,
    PJOB pJob);

PJOB
ThreadNotifyNextJob(
    PTMSTATEVAR ptmStateVar);


TMSTATESTATIC tmStateStatic = {
    10,
    2500,
    (PFNPROCESSJOB)ThreadNotifyProcessJob,
    (PFNNEXTJOB)ThreadNotifyNextJob,
    NULL,
    NULL,
    &RouterNotifySection
};

TMSTATEVAR tmStateVar;
PCHANGE pChangeList;


WCHAR szThreadMax[] = L"ThreadNotifyMax";
WCHAR szThreadIdleLife[] = L"ThreadNotifyIdleLife";
WCHAR szThreadNotifySleep[] = L"ThreadNotifySleep";

DWORD dwThreadNotifySleep = 1000;


BOOL
ThreadInit()
{
    HKEY hKey;
    DWORD dwType = REG_DWORD;
    DWORD cbData;

    if (!TMCreateStatic(&tmStateStatic))
        return FALSE;

    if (!TMCreate(&tmStateStatic, &tmStateVar))
        return FALSE;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szPrintKey,
                      0,
                      KEY_READ,
                      &hKey)) {

        cbData = sizeof(tmStateStatic.uMaxThreads);

        //
        // Ignore failure case since we default to 10.
        //
        RegQueryValueEx(hKey,
                        szThreadMax,
                        NULL,
                        &dwType,
                        (LPBYTE)&tmStateStatic.uMaxThreads,
                        &cbData);

        cbData = sizeof(tmStateStatic.uIdleLife);

        //
        // Ignore failure case since we default to 1000 (1 sec).
        //
        RegQueryValueEx(hKey,
                        szThreadIdleLife,
                        NULL,
                        &dwType,
                        (LPBYTE)&tmStateStatic.uIdleLife,
                        &cbData);

        cbData = sizeof(dwThreadNotifySleep);

        //
        // Ignore failure case since we default to 2500 (2.5 sec).
        //
        RegQueryValueEx(hKey,
                        szThreadNotifySleep,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwThreadNotifySleep,
                        &cbData);


        RegCloseKey(hKey);
    }

    return TRUE;
}



VOID
ThreadDestroy()
{
    TMDestroy(&tmStateVar);
    TMDestroyStatic(&tmStateStatic);
}


BOOL
LinkChange(
    PCHANGE pChange)

/*++

Routine Description:

    Link up the change to the list of jobs that need to be processed.
    If the call succeeded but there was an overflow at the client,
    then we won't add this to the list until it gets refreshed.

Arguments:

Return Value:

--*/

{
    if (pChange->eStatus & STATUS_CHANGE_DISCARDNOTED) {

        return FALSE;
    }
    pChange->cRef++;
    pChange->eStatus |= STATUS_CHANGE_ACTIVE;
    LinkAdd(&pChange->Link, (PLINK*)&pChangeList);

    return TRUE;
}


BOOL
ThreadNotify(
    LPPRINTHANDLE pPrintHandle)

/*++

Routine Description:

    Handles notifying the remote clients of changes.

Arguments:

    pPrintHandle - printer that requires notification

Return Value:

    TRUE = success, GetLastError() valid on FALSE.

    NOTE: Currenly only supports grouping

--*/

{
    PCHANGE pChange = pPrintHandle->pChange;

    ENTER_THREAD_LIST();

    //
    // Only add if we're not on the linked list already.
    //
    if (!(pChange->eStatus & STATUS_CHANGE_ACTIVE)) {

        DBGMSG(DBG_NOTIFY, ("TMN: link added 0x%x cRef++ %d\n",
                            pChange,
                            pChange->cRef));

        //
        // Only add ourseleves to the linked list and
        // Notify via TMAddJob if we are not on the list.
        //
        if (LinkChange(pChange))
            TMAddJob(&tmStateVar);

    } else {

        pChange->eStatus |= STATUS_CHANGE_ACTIVE_REQ;
        DBGMSG(DBG_NOTIFY, ("TMN: In LL already 0x%x cRef %d\n",
                            pChange,
                            pChange->cRef));
    }


    EXIT_THREAD_LIST();

    return TRUE;
}


PJOB
ThreadNotifyNextJob(
    PTMSTATEVAR ptmStateVar)

/*++

Routine Description:

    Callback to get the next job.

Arguments:

    ptmStateVar - ignored.

Return Value:

    pJob (pChange)

--*/

{
    PCHANGE pChange;

    ENTER_THREAD_LIST();

    //
    // If there are no jobs left, quit.
    //
    pChange = (PCHANGE)pChangeList;

    DBGMSG(DBG_NOTIFY, ("ThreadNotifyNextJob: Removing pChange 0x%x\n",
                        pChange));

    if (pChange) {
        LinkDelete(&pChange->Link, (PLINK*)&pChangeList);
    }

    EXIT_THREAD_LIST();

    return (PJOB)pChange;
}

DWORD
ThreadNotifyProcessJob(
    PTMSTATEVAR pTMStateVar,
    PJOB pJob)

/*++

Routine Description:

    Does the actual RPC call to notify the client.

Arguments:

    pJob = pChange structure

Return Value:

--*/

{
    PCHANGE pChange = (PCHANGE)pJob;
    DWORD fdwChangeFlags;
    HANDLE hNotifyRemote;
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo;
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfoNew;
    RPC_V2_UREPLY_PRINTER Reply;

    DWORD dwReturn;
    DWORD dwResult = 0;
    DWORD dwColor;

    ENTER_THREAD_LIST();

    if (pChange->eStatus & STATUS_CHANGE_CLOSING) {

        //
        // Abort this job
        //
        dwReturn = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    fdwChangeFlags = pChange->fdwChangeFlags;
    pChange->fdwChangeFlags = 0;

    //
    // We must save out this copy in case we have some more info
    // while we are RPCing.  Turn off LL_REQ because we are about
    // to process this batch.
    //
    pPrinterNotifyInfo = pChange->ChangeInfo.pPrinterNotifyInfo;

    pChange->ChangeInfo.pPrinterNotifyInfo = NULL;
    pChange->eStatus &= ~STATUS_CHANGE_ACTIVE_REQ;
    dwColor = pChange->dwColor;

    //
    // We were already marked in use when the job was added.
    // If another thread wants to delete it, they should OR in
    // STATUS_CHANGE_CLOSING, which we will pickup.
    //

    EXIT_THREAD_LIST();

    if (pChange->hNotifyRemote) {

        DBGMSG(DBG_NOTIFY, (">> Remoting pChange 0x%x hNotifyRemote 0x%x\n",
                            pChange,
                            pChange->hNotifyRemote));

        RpcTryExcept {

            //
            // Note:
            //
            // We should not be impersonating at this stage since
            // we will get a separate session id.
            //
            if (pPrinterNotifyInfo) {

                Reply.pInfo = (PRPC_V2_NOTIFY_INFO)pPrinterNotifyInfo;

                //
                // Remote case; bind and call the remote router.
                //
                dwReturn = RpcRouterReplyPrinterEx(
                               pChange->hNotifyRemote,
                               dwColor,
                               fdwChangeFlags,
                               &dwResult,
                               REPLY_PRINTER_CHANGE,
                               Reply);
            } else {

                dwReturn = RpcRouterReplyPrinter(
                               pChange->hNotifyRemote,
                               fdwChangeFlags,
                               1,
                               (PBYTE)&pPrinterNotifyInfo);
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwReturn = RpcExceptionCode();

        } RpcEndExcept

    } else {

        dwReturn = ERROR_INVALID_HANDLE;
        DBGMSG(DBG_WARNING, ("ThreadNotifyProcessJob: no hNotifyRemote\n"));
    }

    if (dwReturn) {

        DBGMSG(DBG_WARNING, ("ThreadNotifyProcessJob: RPC error %d\npChange 0x%x, hNotifyRemote 0x%x, hPrinterRemote 0x%x\n",
                             dwReturn,
                             pChange,
                             pChange->hNotifyRemote,
                             pChange->dwPrinterRemote));

        //
        // On error, close and retry
        //
        CloseReplyRemote(pChange->hNotifyRemote);

        if (OpenReplyRemote(pChange->pszLocalMachine,
                            &pChange->hNotifyRemote,
                            pChange->dwPrinterRemote,
                            REPLY_TYPE_NOTIFICATION,
                            0,
                            NULL)) {

            pChange->hNotifyRemote = NULL;
        }
    }

    Sleep(dwThreadNotifySleep);

    ENTER_THREAD_LIST();

    pPrinterNotifyInfoNew = pChange->ChangeInfo.pPrinterNotifyInfo;

    //
    // Keep dwResult only if the color is current.
    //
    // The avoids the problem when the server sends a discard (RPC1),
    // then the client refreshes (RPC2).  RPC2 returns first, clearing
    // the client's discard bit.  The server overflows the new
    // buffer.  RPC1 completes, and returns discardnoted, which is
    // incorrect since it is stale.  If the color isn't checked, then
    // the server thinks that the discard has been noted when it really
    // has not.
    //
    if (dwColor != pChange->dwColor) {
        dwResult = 0;
    }

    if (pPrinterNotifyInfo) {

        //
        // Handle different error states from RPC.  Each case/default
        // block must either update or pChange->ChangeInfo.pPrinterNotifyInfo
        // and free the old or the new if both exist.
        //
        switch (dwReturn) {
        case ERROR_SUCCESS:

            //
            // On success, see if the client saw the info but couldn't
            // store it since they overflowed.  In this case, we note
            // this and never RPC to them again until they refresh.
            //
            if (dwResult & PRINTER_NOTIFY_INFO_DISCARDNOTED) {
                pChange->eStatus |= (STATUS_CHANGE_DISCARDED |
                                     STATUS_CHANGE_DISCARDNOTED);
            }

            //
            // If new buffer allocated, free our old one, else reuse buffer.
            //
            if (!pPrinterNotifyInfoNew) {

                //
                // Clear it since we are reusing it.
                //
                ClearPrinterNotifyInfo(pPrinterNotifyInfo, pChange);
                pChange->ChangeInfo.pPrinterNotifyInfo = pPrinterNotifyInfo;

            } else {

                //
                // Free the old one since we are using the new one now.
                //
                RouterFreePrinterNotifyInfo(pPrinterNotifyInfo);
            }

            pChange->ChangeInfo.pPrinterNotifyInfo->Flags |= dwResult;
            break;

        case RPC_S_CALL_FAILED_DNE:

            //
            // On DNE, keep the notification info.  We are guarenteed by
            // rpc that this means no part of the call executed.
            //
            if (pPrinterNotifyInfoNew) {

                //
                // We already have some info.  Merge it in
                // with the exiting data.
                //
                pChange->ChangeInfo.pPrinterNotifyInfo = pPrinterNotifyInfo;

                if (pChange->ChangeInfo.pPrintHandle) {

                    AppendPrinterNotifyInfo(pChange->ChangeInfo.pPrintHandle,
                                            dwColor,
                                            pPrinterNotifyInfoNew);
                }
                RouterFreePrinterNotifyInfo(pPrinterNotifyInfoNew);
            }
            break;

        default:

            //
            // Did it succeed?  Maybe, maybe not.  Fail it by freeing
            // the current one if it exists, then clear the current one
            // and set the discard bit.
            //
            pChange->ChangeInfo.pPrinterNotifyInfo = pPrinterNotifyInfo;
            ClearPrinterNotifyInfo(pPrinterNotifyInfo, pChange);

            SetDiscardPrinterNotifyInfo(pPrinterNotifyInfo, pChange);

            //
            // Free the new buffer since we are reusing the old one.
            //
            if (pPrinterNotifyInfoNew) {

                RouterFreePrinterNotifyInfo(pPrinterNotifyInfoNew);
            }
        }
    }

    pChange->eStatus &= ~STATUS_CHANGE_ACTIVE;

    //
    // STATUS_CHANGE_ACTIVE_REQ set, then some notifications came in
    // while we were out.  Check that we actually do have information
    // (it might have been sent with the last RPC) and we aren't closing.
    //
    if ((pChange->eStatus & STATUS_CHANGE_ACTIVE_REQ) &&
        NotifyNeeded(pChange) &&
        !(pChange->eStatus & STATUS_CHANGE_CLOSING)) {

        DBGMSG(DBG_NOTIFY, ("ThreadNotifyProcessJob: delayed link added 0x%x cRef++ %d\n",
                            pChange,
                            pChange->cRef));

        pChange->eStatus &= ~STATUS_CHANGE_ACTIVE_REQ;

        LinkChange(pChange);

        //
        // No need to call TMAddJob(&tmStateVar) since this
        // thread will pickup the job.  If there is a job already waiting,
        // then that means it already has a thread spawning to pick it up.
        //
    }

Done:
    //
    // Mark ourselves no longer in use.  If we were in use when someone
    // tried to delete the notify, we need to delete it once we're done.
    //
    pChange->cRef--;

    DBGMSG(DBG_NOTIFY, ("ThreadNotifyProcessJob: Done 0x%x cRef-- %d\n",
                        pChange,
                        pChange->cRef));


    if (pChange->eStatus & STATUS_CHANGE_CLOSING) {

        hNotifyRemote = pChange->hNotifyRemote;
        pChange->hNotifyRemote = NULL;

        //
        // Free the Change struct and close the hNotifyRemote
        //
        FreeChange(pChange);

        EXIT_THREAD_LIST();

        CloseReplyRemote(hNotifyRemote);

    } else {

        EXIT_THREAD_LIST();
    }

    return 0;
}


//
// Usually a macro
//
#ifndef LINKADDFAST
VOID
LinkAdd(
    PLINK pLink,
    PLINK* ppLinkHead)

/*++

Routine Description:

    Adds the item to linked list.

Arguments:

    pLink - item to add

    ppLinkHead - linked list head pointer

Return Value:

    VOID

NOTE: This appends to the tail of the list; the macro must be changed also.

--*/

{
    //
    // First check if its in the list
    //
    PLINK pLinkT;
    PLINK pLinkLast = NULL;

    for(pLinkT=*ppLinkHead; pLinkT; pLinkT=pLinkT->pNext) {

        if (pLinkT == pLink) {

            DBGMSG(DBG_ERROR, ("LinkAdd: Duplicate link adding!\n"));
        }
        pLinkLast = pLinkT;
    }

    if (pLinkLast) {
        pLinkLast->pNext = pLink;
    } else {
        pLink->pNext = *ppLinkHead;
        *ppLinkHead = pLink;
    }
}
#endif


VOID
LinkDelete(
    PLINK pLink,
    PLINK* ppLinkHead)

/*++

Routine Description:

    Removes item from list

Arguments:

    pLink - Item to delete

    ppLinkHead - pointer to link head

Return Value:

    VOID

--*/

{
    PLINK pLink2 = *ppLinkHead;

    if (!pLink)
        return;

    //
    // Check head case first
    //
    if (pLink2 == pLink) {

        *ppLinkHead = pLink->pNext;

    } else {

        //
        // Scan list to delete
        //
        for(;
            pLink2;
            pLink2=pLink2->pNext) {

            if (pLink == pLink2->pNext) {

                pLink2->pNext = pLink->pNext;
                break;
            }
        }
    }

    pLink->pNext = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Routing Layer and
    the local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

#include <winddiui.h>
#include <winsock2.h>
#include <wininet.h>


LPWSTR *ppszOtherNames = NULL;  // Contains szMachineName, DNS name, and all other machine name forms
DWORD   cOtherNames = 0;        // Number of other names

WCHAR *gszDrvConvert = L",DrvConvert";


//
// Lowercase, just like win31 for WM_WININICHANGE
//
WCHAR *szDevices=L"devices";
WCHAR *szWindows=L"windows";

#define NUM_INTERACTIVE_RIDS            1

extern DWORD    RouterCacheSize;
extern PROUTERCACHE RouterCacheTable;

typedef struct _DEVMODECHG_INFO {
    DWORD           signature;
    HANDLE          hDrvModule;
    FARPROC         pfnConvertDevMode;
} DEVMODECHG_INFO, *PDEVMODECHG_INFO;

#define DMC_SIGNATURE   'DMC'   /* 'DMC' is the signature value */

DWORD
RouterIsOlderThan(
    DWORD i,
    DWORD j
);

VOID
FreeOtherNames(LPWSTR **ppszMyOtherNames, DWORD *cOtherNames);

LPWSTR
AnsiToUnicodeStringWithAlloc(LPSTR   pAnsi);


BOOL
DeleteSubKeyTree(
    HKEY ParentHandle,
    WCHAR SubKeyName[]
)
{
    LONG        Error;
    DWORD       Index;
    HKEY        KeyHandle;
    BOOL        RetValue = TRUE;
    PWSTR       pszChildKeyName = NULL;

    if(pszChildKeyName = AllocSplMem( sizeof(WCHAR)*MAX_PATH ))
    {
        Error = RegOpenKeyEx(ParentHandle,
                             SubKeyName,
                             0,
                             KEY_READ | KEY_WRITE,
                             &KeyHandle);

        if (Error != ERROR_SUCCESS)
        {
            SetLastError(Error);
            RetValue = FALSE;
        }
        else
        {
            DWORD   ChildKeyNameLength = MAX_PATH;
            //
            // Don't increment this Index
            //
            Index = 0;

            while ((Error = RegEnumKeyEx(KeyHandle,
                                         Index,
                                         pszChildKeyName,
                                         &ChildKeyNameLength,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL
                                         )) == ERROR_SUCCESS)
            {

                RetValue = DeleteSubKeyTree( KeyHandle, pszChildKeyName );

                if (RetValue == FALSE)
                {
                    //
                    // Error -- couldn't delete the sub key
                    //
                    break;
                }

                ChildKeyNameLength = MAX_PATH;
            }

            Error = RegCloseKey(KeyHandle);

            if(RetValue)
            {
                if (Error != ERROR_SUCCESS)
                {
                   RetValue = FALSE;
                }
                else
                {
                    Error = RegDeleteKey(ParentHandle,
                                         SubKeyName);

                    if (Error != ERROR_SUCCESS)
                    {
                       RetValue = FALSE;
                    }
                }
            }
        }
        FreeSplMem(pszChildKeyName);
    }
    else
    {
        RetValue = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

   return(RetValue);
}

LPWSTR RemoveOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
)
{
    LPWSTR lpMem, psz, temp;

    if (szOrderString == NULL) {
        *pcbBytesReturned = 0;
        return(NULL);
    }
    if (lpMem = AllocSplMem( cbStringSize)) {

        DWORD cchStringLen = cbStringSize/sizeof(WCHAR);

        temp = szOrderString;
        psz = lpMem;

        while (*temp)
        {
            DWORD cchTempStrLen = 0;

            if (!lstrcmpi(temp, szOrderEntry))
            // we need to remove
            // this entry in Order
            {
                temp += lstrlen(temp)+1;
                continue;
            }

            if((cchTempStrLen = lstrlen(temp)+1) > cchStringLen)
            {
                break;
            }
            else
            {
                StringCchCopy(psz,cchStringLen,temp);

                cchStringLen -= cchTempStrLen;
                psz          += cchTempStrLen;
                temp         += cchTempStrLen;
            }
        }

        *psz = L'\0';
        *pcbBytesReturned = (DWORD) ((psz - lpMem)+1)*sizeof(WCHAR);

        return(lpMem);
    }
    *pcbBytesReturned = 0;
    return(lpMem);
}



LPWSTR AppendOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
)
{
    LPWSTR  lpMem,
            temp,
            psz;
    DWORD   cb        = 0;
    DWORD   cchStrLen = 0;
    BOOL    bExists   = FALSE;

    if ((szOrderString == NULL) && (szOrderEntry == NULL)) {
        *pcbBytesReturned = 0;
        return(NULL);
    }
    if (szOrderString == NULL) {
        cb = wcslen(szOrderEntry)*sizeof(WCHAR)+ sizeof(WCHAR) + sizeof(WCHAR);
        if (lpMem = AllocSplMem(cb)){
           StringCbCopy(lpMem, cb, szOrderEntry);
           *pcbBytesReturned = cb;
        } else {
            *pcbBytesReturned = 0;
        }
        return lpMem;
    }

    cchStrLen = cbStringSize + wcslen(szOrderEntry) + 1;

    if (lpMem = AllocSplMem(cchStrLen * sizeof(WCHAR))){

         temp = szOrderString;
         psz = lpMem;

         while (*temp)
         {
             DWORD cchTempStrLen = 0;

             if (!lstrcmpi(temp, szOrderEntry))
             {
                 //
                 // Make sure we don't
                 // duplicate entries
                 //
                 bExists = TRUE;
             }

             if((cchTempStrLen = lstrlen(temp)+1) > cchStrLen)
             {
                 break;
             }
             else
             {
                 StringCchCopy(psz,cchStrLen,temp);

                 cchStrLen -= cchTempStrLen;
                 psz       += cchTempStrLen;
                 temp      += cchTempStrLen;
             }
         }

         if (!bExists)
         {
            //
            // if it doesn't exist
            // add the entry
            //
            StringCchCopy(psz, cchStrLen, szOrderEntry);
            psz  += min(cchStrLen,(DWORD)(lstrlen(szOrderEntry)+1));
         }
         *psz = L'\0';          // the second null character

         *pcbBytesReturned = (DWORD) ((psz - lpMem) + 1)* sizeof(WCHAR);
     }
     return(lpMem);

}


typedef struct {
    DWORD   dwType;
    DWORD   dwMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} MESSAGE, *PMESSAGE;

VOID
SendMessageThread(
    PMESSAGE    pMessage);


BOOL
BroadcastMessage(
    DWORD   dwType,
    DWORD   dwMessage,
    WPARAM  wParam,
    LPARAM  lParam)
{
    HANDLE  hThread;
    DWORD   ThreadId;
    PMESSAGE   pMessage;
    BOOL bReturn = FALSE;

    pMessage = AllocSplMem(sizeof(MESSAGE));

    if (pMessage) {

        pMessage->dwType = dwType;
        pMessage->dwMessage = dwMessage;
        pMessage->wParam = wParam;
        pMessage->lParam = lParam;

        //
        // We should have a queue of events to broadcast and then have a
        // single thread pulling them off the queue until there is nothing
        // left and then that thread could go away.
        //
        // The current design can lead to a huge number of threads being
        // created and torn down in both this and csrss process.
        //
        hThread = CreateThread(NULL, 0,
                               (LPTHREAD_START_ROUTINE)SendMessageThread,
                               (LPVOID)pMessage,
                               0,
                               &ThreadId);

        if (hThread) {

            CloseHandle(hThread);
            bReturn = TRUE;

        } else {

            FreeSplMem(pMessage);
        }
    }

    return bReturn;
}


//  The Broadcasts are done on a separate thread, the reason it CSRSS
//  will create a server side thread when we call user and we don't want
//  that to be pared up with the RPC thread which is in the spooss server.
//  We want it to go away the moment we have completed the SendMessage.
//  We also call SendNotifyMessage since we don't care if the broadcasts
//  are syncronous this uses less resources since usually we don't have more
//  than one broadcast.

VOID
SendMessageThread(
    PMESSAGE    pMessage)
{
    switch (pMessage->dwType) {

    case BROADCAST_TYPE_MESSAGE:

        SendNotifyMessage(HWND_BROADCAST,
                          pMessage->dwMessage,
                          pMessage->wParam,
                          pMessage->lParam);
        break;

    case BROADCAST_TYPE_CHANGEDEFAULT:

        //
        // Same order and strings as win31.
        //
        SendNotifyMessage(HWND_BROADCAST,
                          WM_WININICHANGE,
                          0,
                          (LPARAM)szDevices);

        SendNotifyMessage(HWND_BROADCAST,
                          WM_WININICHANGE,
                          0,
                          (LPARAM)szWindows);
        break;
    }

    FreeSplMem(pMessage);

    ExitThread(0);
}


BOOL
IsNamedPipeRpcCall(
    VOID
    )
{
    unsigned int    uType;

    //
    //
    //
    return ERROR_SUCCESS == I_RpcBindingInqTransportType(NULL, &uType)  &&
           uType != TRANSPORT_TYPE_LPC;

}

/*++

Name:

    CheckLocalCall

Description:

    This function checks whether the current thread is handling a local
    or a remote call. Definiton of a remote call:
    -the call came via a transport different from LPC or
    -the came came via LPC, but the thread's security token includes the SECURITY_NETWORK_RID

Arguments:

    None.

Return Value:

    S_OK     - local call
    S_FALSE  - remote call
    other HR - an error occurred and the call type could not be determined

--*/
HRESULT
CheckLocalCall(
    VOID
    )
{
    HRESULT      hResult       = S_OK;
    DWORD        SaveLastError = GetLastError();
    unsigned int uType;

    DWORD Error = I_RpcBindingInqTransportType(NULL, &uType);

    switch (Error)
    {
        case RPC_S_NO_CALL_ACTIVE:
        {
            //
            // KM call
            //
            hResult = S_OK;
            break;
        }

        case ERROR_SUCCESS:
        {
            if (uType != TRANSPORT_TYPE_LPC)
            {
                //
                // Not LRPC so call is remote
                //
                hResult = S_FALSE;
            }
            else
            {
                HANDLE hToken;

                if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
                {
                    SID_IDENTIFIER_AUTHORITY sia      = SECURITY_NT_AUTHORITY;
                    PSID                     pTestSid = NULL;
                    BOOL                     bMember;

                    if (AllocateAndInitializeSid(&sia,
                                                 1,
                                                 SECURITY_NETWORK_RID,
                                                 0, 0, 0, 0, 0, 0, 0,
                                                 &pTestSid))
                    {
                        if (CheckTokenMembership(hToken, pTestSid, &bMember))
                        {
                            hResult = bMember ? S_FALSE : S_OK;
                        }
                        else
                        {
                            hResult = GetLastErrorAsHResult();
                        }

                        FreeSid(pTestSid);
                    }
                    else
                    {
                        hResult = GetLastErrorAsHResult();
                    }

                    CloseHandle(hToken);
                }
                else
                {
                    hResult = GetLastErrorAsHResult();

                    //
                    // The following call originates from the print processor. There are port monitors which
                    // will revert to spooler self before calling open printer. In this case, OpenThreadToken
                    // fails. We need to treat ERROR_NO_TOKEN as call coming from the local machine.
                    //
                    // localspl!SplOpenPrinter
                    // localspl!LocalOpenPrinterEx+0x7b
                    // SPOOLSS!RouterOpenPrinterW+0x13f
                    // SPOOLSS!OpenPrinterW+0x17
                    // SOMEPORTMON!pfnStartDocPort
                    // localspl!PrintingDirectlyToPort+0x199
                    // localspl!LocalStartDocPrinter+0x4e
                    // SPOOLSS!StartDocPrinterW+0x21
                    // spoolsv!YStartDocPrinter+0xaf
                    // spoolsv!RpcStartDocPrinter+0x13
                    // RPCRT4!something
                    //
                    if (hResult == HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
                    {
                        hResult = S_OK;
                    }
                }
            }

            break;
        }

        default:
        {
            hResult = HRESULT_FROM_WIN32(Error);
        }

    }

    SetLastError(SaveLastError);

    return hResult;
}



LPPROVIDOR
FindEntryinRouterCache(
    LPWSTR pPrinterName
)
{
    DWORD i;

    if (!pPrinterName)
        return NULL;

    DBGMSG(DBG_TRACE, ("FindEntryinRouterCache with %ws\n", pPrinterName));

    if (RouterCacheSize == 0 ) {
        DBGMSG(DBG_TRACE, ("FindEntryInRouterCache with %ws returning -1 (zero cache)\n", pPrinterName));
        return NULL;
    }

    for (i = 0; i < RouterCacheSize; i++ ) {

        if (RouterCacheTable[i].bAvailable) {
            if (!_wcsicmp(RouterCacheTable[i].pPrinterName, pPrinterName)) {

                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&RouterCacheTable[i].st);

                //
                //
                //
                DBGMSG(DBG_TRACE, ("FindEntryinRouterCache returning with %d\n", i));
                return RouterCacheTable[i].pProvidor;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("FindEntryinRouterCache returning with -1\n"));
    return NULL;
}


DWORD
AddEntrytoRouterCache(
    LPWSTR pPrinterName,
    LPPROVIDOR pProvidor
)
{
    DWORD LRUEntry = (DWORD)-1;
    DWORD i;
    DBGMSG(DBG_TRACE, ("AddEntrytoRouterCache with %ws\n", pPrinterName));

    if (RouterCacheSize == 0 ) {
        DBGMSG(DBG_TRACE, ("AddEntrytoRouterCache with %ws returning -1 (zero cache)\n", pPrinterName));
        return (DWORD)-1;
    }

    for (i = 0; i < RouterCacheSize; i++ ) {

        if (!RouterCacheTable[i].bAvailable) {

            //
            // Found an available entry; use it
            // fill in the name of the printer and the providor
            // that supports this printer.
            //
            break;

        } else {

            if ((LRUEntry == -1) || (i == RouterIsOlderThan(i, LRUEntry))){
                LRUEntry = i;
            }
        }

    }

    if (i == RouterCacheSize) {

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //
        FreeSplStr(RouterCacheTable[LRUEntry].pPrinterName);
        RouterCacheTable[LRUEntry].bAvailable = FALSE;

        i = LRUEntry;
    }


    if ((RouterCacheTable[i].pPrinterName = AllocSplStr(pPrinterName)) == NULL){

        //
        // Alloc failed so we're kinda hosed so return -1
        //
        return (DWORD)-1;
    }


    RouterCacheTable[i].bAvailable = TRUE;
    RouterCacheTable[i].pProvidor = pProvidor;

    //
    // update the time stamp so that we know when this entry was made
    //
    GetSystemTime(&RouterCacheTable[i].st);
    DBGMSG(DBG_TRACE, ("AddEntrytoRouterCache returning with %d\n", i));
    return i;
}


VOID
DeleteEntryfromRouterCache(
    LPWSTR pPrinterName
)
{
    DWORD i;

    if (RouterCacheSize == 0) {
        DBGMSG(DBG_TRACE, ("DeleteEntryfromRouterCache with %ws returning -1 (zero cache)\n", pPrinterName));
        return;
    }

    DBGMSG(DBG_TRACE, ("DeleteEntryFromRouterCache with %ws\n", pPrinterName));
    for (i = 0; i < RouterCacheSize; i++ ) {
        if (RouterCacheTable[i].bAvailable) {
            if (!_wcsicmp(RouterCacheTable[i].pPrinterName, pPrinterName)) {
                //
                //  reset the available flag on this node
                //
                FreeSplStr(RouterCacheTable[i].pPrinterName);

                RouterCacheTable[i].pProvidor = NULL;
                RouterCacheTable[i].bAvailable = FALSE;

                DBGMSG(DBG_TRACE, ("DeleteEntryFromRouterCache returning after deleting the %d th entry\n", i));
                return;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("DeleteEntryFromRouterCache returning after not finding an entry to delete\n"));
}



DWORD
RouterIsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    DBGMSG(DBG_TRACE, ("RouterIsOlderThan entering with i %d j %d\n", i, j));
    pi = &(RouterCacheTable[i].st);
    pj = &(RouterCacheTable[j].st);
    DBGMSG(DBG_TRACE, ("Index i %d - %d:%d:%d:%d:%d:%d:%d\n",
        i, pi->wYear, pi->wMonth, pi->wDay, pi->wHour, pi->wMinute, pi->wSecond, pi->wMilliseconds));


    DBGMSG(DBG_TRACE,("Index j %d - %d:%d:%d:%d:%d:%d:%d\n",
        j, pj->wYear, pj->wMonth, pj->wDay, pj->wHour, pj->wMinute, pj->wSecond, pj->wMilliseconds));

    if (pi->wYear < pj->wYear) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
            return(i);
        } else {
            DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
            return(j);
        }
    }
}


/*++

Routine Name

    ImpersonationToken

Routine Description:

    This routine checks if a token is a primary token or an impersonation
    token.

Arguments:

    hToken - impersonation token or primary token of the process

Return Value:

    TRUE, if the token is an impersonation token
    FALSE, otherwise.

--*/
BOOL
ImpersonationToken(
    IN HANDLE hToken
    )
{
    BOOL       bRet = TRUE;
    TOKEN_TYPE eTokenType;
    DWORD      cbNeeded;
    DWORD      LastError;

    //
    // Preserve the last error. Some callers of ImpersonatePrinterClient (which
    // calls ImpersonationToken) rely on the fact that ImpersonatePrinterClient
    // does not alter the last error.
    //
    LastError = GetLastError();

    //
    // Get the token type from the thread token.  The token comes
    // from RevertToPrinterSelf. An impersonation token cannot be
    // queried, because RevertToPRinterSelf doesn't open it with
    // TOKEN_QUERY access. That's why we assume that hToken is
    // an impersonation token by default
    //
    if (GetTokenInformation(hToken,
                            TokenType,
                            &eTokenType,
                            sizeof(eTokenType),
                            &cbNeeded))
    {
        bRet = eTokenType == TokenImpersonation;
    }

    SetLastError(LastError);

    return bRet;
}

/*++

Routine Name

    RevertToPrinterSelf

Routine Description:

    This routine will revert to the local system. It returns the token that
    ImpersonatePrinterClient then uses to imersonate the client again. If the
    current thread doesn't impersonate, then the function merely returns the
    primary token of the process. (instead of returning NULL) Thus we honor
    a request for reverting to printer self, even if the thread is not impersonating.

Arguments:

    None.

Return Value:

    NULL, if the function failed
    HANDLE to token, otherwise.

--*/
HANDLE
RevertToPrinterSelf(
    VOID
    )
{
    HANDLE   NewToken, OldToken;
    NTSTATUS Status;

    NewToken = NULL;

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_IMPERSONATE,
                               TRUE,
                               &OldToken);

    if (NT_SUCCESS(Status))
    {
        //
        // We are currently impersonating
        //
        Status = NtSetInformationThread(NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID)&NewToken,
                                        (ULONG)sizeof(HANDLE));
    }
    else if (Status == STATUS_NO_TOKEN)
    {
        //
        // We are not impersonating
        //
        Status = NtOpenProcessToken(NtCurrentProcess(),
                                    TOKEN_QUERY,
                                    &OldToken);

    }

    if (!NT_SUCCESS(Status))
    {
        SetLastError(Status);
        return NULL;
    }

    return OldToken;
}

/*++

Routine Name

    ImpersonatePrinterClient

Routine Description:

    This routine attempts to set the passed in hToken as the token for the
    current thread. If hToken is not an impersonation token, then the routine
    will simply close the token.

Arguments:

    hToken - impersonation token or primary token of the process

Return Value:

    TRUE, if the function succeeds in setting hToken
    FALSE, otherwise.

--*/
BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    NTSTATUS    Status;

    //
    // Check if we have an impersonation token
    //
    if (ImpersonationToken(hToken))
    {
        Status = NtSetInformationThread(NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID)&hToken,
                                        (ULONG)sizeof(HANDLE));
        if (!NT_SUCCESS(Status))
        {
            SetLastError(Status);
            return FALSE;
        }
    }

    NtClose(hToken);

    return TRUE;
}

HANDLE
LoadDriver(
    LPWSTR  pDriverFile)
{
    UINT                uOldErrorMode;
    fnWinSpoolDrv       fnList;
    HANDLE              hReturn = NULL;

    if (!pDriverFile || !*pDriverFile) {
        // Nothing to load
        return hReturn;
    }

    uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    if (SplInitializeWinSpoolDrv(&fnList)) {

        hReturn = (*(fnList.pfnRefCntLoadDriver))(pDriverFile,
                                                  LOAD_WITH_ALTERED_SEARCH_PATH,
                                                  0, FALSE);
    }

    (VOID)SetErrorMode(uOldErrorMode);

    return hReturn;
}

VOID
UnloadDriver(
    HANDLE  hModule
    )
{
    fnWinSpoolDrv       fnList;

    if (SplInitializeWinSpoolDrv(&fnList)) {
        (* (fnList.pfnRefCntUnloadDriver))(hModule, TRUE);
    }
}

VOID
UnloadDriverFile(
    IN OUT HANDLE    hDevModeChgInfo
    )
/*++

Description:
    Does a FreeLibrary on the driver file and frees memory

Arguments:
    hDevModeChgInfo - A handle returned by LoadDriverFiletoConvertDevmode

Return Value:
    None

--*/
{
    PDEVMODECHG_INFO    pDevModeChgInfo = (PDEVMODECHG_INFO) hDevModeChgInfo;

    SPLASSERT(pDevModeChgInfo &&
              pDevModeChgInfo->signature == DMC_SIGNATURE);

    if ( pDevModeChgInfo && pDevModeChgInfo->signature == DMC_SIGNATURE ) {

        if ( pDevModeChgInfo->hDrvModule ) {
            UnloadDriver(pDevModeChgInfo->hDrvModule);
        }
        FreeSplMem((LPVOID)pDevModeChgInfo);
    }
}

HANDLE
LoadDriverFiletoConvertDevmode(
    IN  LPWSTR      pDriverFile
    )
/*++

Description:
    Does a LoadLibrary on the driver file given. This will give a handle
    which can be used to do devmode conversion later using
    CallDrvDevModeConversion.

    Caller should call UnloadDriverFile to do a FreeLibrary and free memory

    Note: Driver will call OpenPrinter to spooler

Arguments:
    pDriverFile - Full path of the driver file to do a LoadLibrary

Return Value:
    A handle value to be used to make calls to CallDrvDevModeConversion,
    NULL on error

--*/
{
    PDEVMODECHG_INFO    pDevModeChgInfo = NULL;
    BOOL                bFail = TRUE;
    DWORD               dwNeeded;

    SPLASSERT(pDriverFile != NULL);

    pDevModeChgInfo = (PDEVMODECHG_INFO) AllocSplMem(sizeof(*pDevModeChgInfo));

    if ( !pDevModeChgInfo ) {

        DBGMSG(DBG_WARNING, ("printer.c: Memory allocation failed for DEVMODECHG_INFO\n"));
        goto Cleanup;
    }

    pDevModeChgInfo->signature = DMC_SIGNATURE;

    pDevModeChgInfo->hDrvModule = LoadDriver(pDriverFile);

    if ( !pDevModeChgInfo->hDrvModule ) {

        DBGMSG(DBG_WARNING,("LoadDriverFiletoConvertDevmode: Can't load driver file %ws\n", pDriverFile));
        goto Cleanup;
    }

    //
    // Some third party driver may not be providing DrvConvertDevMode
    //
    pDevModeChgInfo->pfnConvertDevMode = GetProcAddress(pDevModeChgInfo->hDrvModule,
                                                        "DrvConvertDevMode");
    if ( !pDevModeChgInfo->pfnConvertDevMode )
        goto Cleanup;

    bFail = FALSE;

Cleanup:

    if ( bFail ) {

        if ( pDevModeChgInfo ) {
            UnloadDriverFile((HANDLE)pDevModeChgInfo);
        }
        return (HANDLE) NULL;

    } else {

        return (HANDLE) pDevModeChgInfo;
    }
}

DWORD
CallDrvDevModeConversion(
    IN     HANDLE               hDevModeChgInfo,
    IN     LPWSTR               pszPrinterName,
    IN     LPBYTE               pDevMode1,
    IN OUT LPBYTE              *ppDevMode2,
    IN OUT LPDWORD              pdwOutDevModeSize,
    IN     DWORD                dwConvertMode,
    IN     BOOL                 bAlloc
    )
/*++

Description:
    Does deve mode conversion by calling driver

    If bAlloc is TRUE routine will do the allocation using AllocSplMem

    Note: Driver is going to call OpenPrinter.

Arguments:
    hDevModeChgInfo - Points to DEVMODECHG_INFO

    pszPrinterName  - Printer name

    pInDevMode      - Input devmode (will be NULL for CDM_DRIVER_DEFAULT)

    *pOutDevMode    - Points to output devmode

    pdwOutDevModeSize - Output devmode size on succesful return
                        if !bAlloc this will give input buffer size

    dwConvertMode   - Devmode conversion mode to give to driver

    bAllocate   - Tells the routine to do allocation to *pOutPrinter
                  If bAllocate is TRUE and no devmode conversion is required
                  call will fail.

Return Value:
    Returns last error

--*/
{
    DWORD               dwBufSize, dwSize, dwLastError = ERROR_SUCCESS;
    LPDEVMODE           pInDevMode = (LPDEVMODE)pDevMode1,
                        *ppOutDevMode = (LPDEVMODE *) ppDevMode2;
    PDEVMODECHG_INFO    pDevModeChgInfo = (PDEVMODECHG_INFO) hDevModeChgInfo;
    PWSTR               pszDrvConvert = pszPrinterName;


    if ( !pDevModeChgInfo ||
         pDevModeChgInfo->signature != DMC_SIGNATURE ||
         !pDevModeChgInfo->pfnConvertDevMode ) {

        SPLASSERT(pDevModeChgInfo &&
                  pDevModeChgInfo->signature == DMC_SIGNATURE &&
                  pDevModeChgInfo->pfnConvertDevMode);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // We decorate the pszPrinterName with ",DrvConvert" to prevent drivers from
    // infinitely recursing by calling GetPrinter inside ConvertDevMode
    //
    if (wcsstr(pszPrinterName, gszDrvConvert)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!(pszDrvConvert = AutoCat(pszPrinterName, gszDrvConvert))) {
        return GetLastError();
    }

    DBGMSG(DBG_INFO,("Convert DevMode %d\n", dwConvertMode));


#if DBG
#else
    try {
#endif

        if ( bAlloc ) {

            //
            // If we have to do allocation first find size neeeded
            //
            *pdwOutDevModeSize  = 0;
            *ppOutDevMode        = NULL;

            (*pDevModeChgInfo->pfnConvertDevMode)(pszDrvConvert,
                                                  pInDevMode,
                                                  NULL,
                                                  pdwOutDevModeSize,
                                                  dwConvertMode);

            dwLastError = GetLastError();
            if ( dwLastError != ERROR_INSUFFICIENT_BUFFER ) {

                DBGMSG(DBG_WARNING,
                       ("CallDrvDevModeConversion: Unexpected error %d\n",
                        GetLastError()));

                if (dwLastError == ERROR_SUCCESS) {

                    SPLASSERT(dwLastError != ERROR_SUCCESS);
                    // if driver doesn't fail the above call, it is a broken driver and probably
                    // failed a HeapAlloc, which doesn't SetLastError()
                    SetLastError(dwLastError = ERROR_NOT_ENOUGH_MEMORY);
                }
#if DBG
                goto Cleanup;
#else
                leave;
#endif
            }

            *ppOutDevMode = AllocSplMem(*pdwOutDevModeSize);
            if ( !*ppOutDevMode ) {

                dwLastError = GetLastError();
#if DBG
                goto Cleanup;
#else
                leave;
#endif
            }
        }

        dwBufSize = *pdwOutDevModeSize;

        if ( !(*pDevModeChgInfo->pfnConvertDevMode)(
                                    pszDrvConvert,
                                    pInDevMode,
                                    ppOutDevMode ? *ppOutDevMode
                                                 : NULL,
                                    pdwOutDevModeSize,
                                    dwConvertMode) ) {

            dwLastError = GetLastError();
            if (dwLastError == ERROR_SUCCESS) {

                SPLASSERT(dwLastError != ERROR_SUCCESS);
                // if driver doesn't fail the above call, it is a broken driver and probably
                // failed a HeapAlloc, which doesn't SetLastError()
                SetLastError(dwLastError = ERROR_NOT_ENOUGH_MEMORY);
            }
        } else {

            dwLastError = StatusFromHResult(SplIsValidDevmodeW(*ppOutDevMode, *pdwOutDevModeSize));
        }

#if DBG
    Cleanup:
#else
    } except(1) {

        DBGMSG(DBG_ERROR,
               ("CallDrvDevModeConversion: Exception from driver\n"));
        dwLastError = GetExceptionCode();
        SetLastError(dwLastError);
    }
#endif

    //
    // If we allocated mmeory free it and zero the pointer
    //
    if (  dwLastError != ERROR_SUCCESS && bAlloc && *ppOutDevMode ) {

        FreeSplMem(*ppOutDevMode);
        *ppOutDevMode = 0;
        *pdwOutDevModeSize = 0;
    }

    if ( dwLastError != ERROR_SUCCESS &&
         dwLastError != ERROR_INSUFFICIENT_BUFFER ) {

        DBGMSG(DBG_WARNING, ("DevmodeConvert unexpected error %d\n", dwLastError));
    }

    if ( dwLastError == ERROR_SUCCESS ) {

        dwSize = (*ppOutDevMode)->dmSize + (*ppOutDevMode)->dmDriverExtra;

        //
        // Did the driver return correct size as per the devmode?
        //
        if ( *pdwOutDevModeSize != dwSize ) {

            DBGMSG(DBG_ERROR,
                   ("Driver says outsize is %d, really %d\n",
                      *pdwOutDevModeSize, dwSize));

            *pdwOutDevModeSize = dwSize;
        }

        //
        // Is it a valid devmode which did not overwrite the buffer?
        //
        if ( *pdwOutDevModeSize < MIN_DEVMODE_SIZEW     ||
             *pdwOutDevModeSize > dwBufSize ) {

            DBGMSG(DBG_ERROR,
                   ("Bad devmode from the driver size %d, buffer %d",
                      *pdwOutDevModeSize, dwBufSize));
            dwLastError = ERROR_INVALID_PARAMETER;

            if ( bAlloc ) {

                FreeSplMem(*ppOutDevMode);
                *ppOutDevMode = NULL;
            }
            *pdwOutDevModeSize = 0;
        }
    }

    FreeSplMem(pszDrvConvert);

    return dwLastError;
}

BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszMyOtherNames,
    DWORD   *cOtherNames
    )

/*++

Routine Description:
    This routine builds list of names other than the machine name that
    can be used to call spooler APIs.

--*/
{
    HANDLE              hModule;
    struct hostent     *HostEnt, *(*Fngethostbyname)(LPTSTR);
    struct in_addr     *ptr;
    INT                 (*FnWSAStartup)(WORD, LPWSADATA);
    DWORD               Index, Count;
    WSADATA             WSAData;
    VOID                (*FnWSACleanup)();
    LPSTR               (*Fninet_ntoa)(struct in_addr);
    WORD                wVersion;
    BOOL                bRet = FALSE;
    DWORD               dwRet;


    SPLASSERT(cOtherNames && ppszMyOtherNames);

    *cOtherNames  = 0;

    wVersion = MAKEWORD(1, 1);


    dwRet = WSAStartup(wVersion, &WSAData);
    if (dwRet) {
        DBGMSG(DBG_WARNING, ("BuildOtherNamesFromMachineName: WSAStartup failed\n"));
        SetLastError(dwRet);
        return FALSE;
    }

    HostEnt = gethostbyname(NULL);

    if (HostEnt) {

        for (*cOtherNames  = 0 ; HostEnt->h_addr_list[*cOtherNames] ; ++(*cOtherNames))
            ;

        *cOtherNames += 2;   // Add one for DNS and one for machine name

        *ppszMyOtherNames = (LPWSTR *) AllocSplMem(*cOtherNames*sizeof *ppszMyOtherNames);
        if ( !*ppszMyOtherNames ) {
            *cOtherNames = 0;
            goto Cleanup;
        }

        (*ppszMyOtherNames)[0] = AllocSplStr(szMachineName + 2); // Exclude the leading double-backslash
        (*ppszMyOtherNames)[1] = AnsiToUnicodeStringWithAlloc(HostEnt->h_name);

        for (Index = 0 ; HostEnt->h_addr_list[Index] ; ++Index) {
            ptr = (struct in_addr *) HostEnt->h_addr_list[Index];
            (*ppszMyOtherNames)[Index+2] = AnsiToUnicodeStringWithAlloc(inet_ntoa(*ptr));
        }

        // check for allocation failures
        for (Index = 0 ; Index < *cOtherNames ; ++Index) {
            if ( !(*ppszMyOtherNames)[Index] ) {
                FreeOtherNames(ppszMyOtherNames, cOtherNames);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Cleanup;
            }
        }

        bRet = TRUE;

    } else {
        DBGMSG(DBG_WARNING, ("BuildOtherNamesFromMachineName: gethostbyname failed for with %d\n", GetLastError()));
    }


Cleanup:
    WSACleanup();

    return bRet;
}


VOID
FreeOtherNames(LPWSTR **ppszMyOtherNames, DWORD *cOtherNames)
{
    DWORD i;

    for( i = 0 ; i < *cOtherNames ; ++i)
        FreeSplMem((*ppszMyOtherNames)[i]);

    FreeSplMem(*ppszMyOtherNames);
}



LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    )
/*++

Description:
    Convert ANSI string to UNICODE. Routine allocates memory from the heap
    which should be freed by the caller.

Arguments:
    pAnsi    - Points to the ANSI string

Return Vlaue:
    Pointer to UNICODE string

--*/
{
    LPWSTR  pUnicode;
    DWORD   rc;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             NULL,
                             0);

    rc *= sizeof(WCHAR);
    if ( !rc || !(pUnicode = (LPWSTR) AllocSplMem(rc)) )
        return NULL;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             pUnicode,
                             rc);

    if ( rc )
        return pUnicode;
    else {
        FreeSplMem(pUnicode);
        return NULL;
    }
}


/*++

Routine Description

    Determines whether or not a machine name contains the local machine name.

    Localspl enum calls fail if pName != local machine name (\\Machine).
    Remote enum provider is then called.  The remote enum provider must check
    if the UNC name refers to the local machine, and fail if it does to avoid
    endless recursion.

Arguments:

    LPWSTR pName - UNC name.

Return Value:

    TRUE:   pName == \\szMachineName\...
                  - or -
            pName == \\szMachineName

    FALSE:  anything else

Author: swilson

 --*/

BOOL
MyUNCName(
    LPWSTR   pNameStart
)
{
    PWCHAR pMachine = szMachineName;
    LPWSTR pName;
    DWORD i;
    extern LPWSTR *ppszOtherNames;   // Contains szMachineName, DNS name, and all other machine name forms
    extern DWORD cOtherNames;


    if (!pNameStart || !*pNameStart)      // This differs from MyName(), which returns TRUE
        return FALSE;

    if (*pNameStart == L'\\' && *(pNameStart + 1) == L'\\') {
        for (i = 0 , pName = pNameStart + 2 ; i < cOtherNames ; ++i , pName = pNameStart + 2) {
            for(pMachine = ppszOtherNames[i] ;
                *pName && towupper(*pName) == towupper(*pMachine) ;
                ++pName, ++pMachine)
                ;

            if(!*pMachine && (!*pName || *pName == L'\\'))
                return TRUE;
        }
    }

    return FALSE;
}

BOOL
SplIsUpgrade(
    VOID
    )
{
    return dwUpgradeFlag;

}


PWSTR
AutoCat(
    PCWSTR pszInput,
    PCWSTR pszCat
)
{
    PWSTR   pszOut;

    if (!pszCat) {

        pszOut =  AllocSplStr(pszInput);

    } else if (pszInput) {

        DWORD cchOutStr = wcslen(pszInput) + wcslen(pszCat) + 1;

        pszOut = AllocSplMem(cchOutStr * sizeof(WCHAR));

        if (pszOut)
        {
            StrNCatBuff(pszOut,
                        cchOutStr,
                        pszInput,
                        pszCat,
                        NULL);
        }

    } else {

        pszOut = AllocSplStr(pszCat);

    }

    return pszOut;
}

PBIDI_RESPONSE_CONTAINER
RouterAllocBidiResponseContainer(
    DWORD Count
)
{
    DWORD MemSize = 0;
    //
    // Add the size of the container - the size of the first data element
    //
    MemSize += (sizeof(BIDI_RESPONSE_CONTAINER) - sizeof(BIDI_RESPONSE_DATA));
    //
    // Add the size of all the returned RESPONSE_DATA elements
    //
    MemSize += (Count * sizeof(BIDI_RESPONSE_DATA));

    return((PBIDI_RESPONSE_CONTAINER) MIDL_user_allocate(MemSize));
}

/*++

Routine Name

    GetAPDPolicy

Routine Description:

    This function reads a DWORD value from the location
    HKEY\pszRelPath\pszValueName. We use this function for
    preserving the AddPrinterDrivers policy value when the
    LanMan Print Services print provider is deleted from
    the system.

Arguments:

    hKey         - key tree
    pszRelPath   - relative path of the value to be get
    pszValueName - value name
    pValue       - pointer to memory to store a dword value

Return Value:

    ERROR_SUCCESS    - the value was retrieved
    Win32 error code - an error occured

--*/
DWORD
GetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN LPDWORD pValue
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (hKey && pszRelPath && pszValueName && pValue)
    {
        HKEY   hRelKey = NULL;

        *pValue = 0;

        //
        // Check if we have a value in the new location already
        //
        if ((Error = RegOpenKeyEx(hKey,
                                  pszRelPath,
                                  0,
                                  KEY_READ,
                                  &hRelKey)) == ERROR_SUCCESS)
        {
            DWORD cbData = sizeof(DWORD);

            Error = RegQueryValueEx(hRelKey,
                                    pszValueName,
                                    NULL,
                                    NULL,
                                    (LPBYTE)pValue,
                                    &cbData);

            RegCloseKey(hRelKey);
        }
    }

    return Error;
}

/*++

Routine Name

    SetAPDPolicy

Routine Description:

    This function writes a DWORD value to the location
    HKEY\pszRelPath\pszValueName. We use this function for
    preserving the AddPrinterDrivers policy value when the
    LanMan Print Services print provider is deleted from
    the system.

Arguments:

    hKey         - key tree
    pszRelPath   - relative path of the value to be set
    pszValueName - value name to be set
    Value        - dword value to be set

Return Value:

    ERROR_SUCCESS    - the value was set sucessfully
    Win32 error code - an error occured and the value was not set

--*/
DWORD
SetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN DWORD   Value
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (hKey && pszRelPath && pszValueName)
    {
        HKEY   hRelKey = NULL;

        //
        // Check if we have a value in the new location already
        //
        if ((Error = RegCreateKeyEx(hKey,
                                    pszRelPath,
                                    0,
                                    NULL,
                                    0,
                                    KEY_SET_VALUE,
                                    NULL,
                                    &hRelKey,
                                    NULL)) == ERROR_SUCCESS)
        {
            Error = RegSetValueEx(hRelKey,
                                  pszValueName,
                                  0,
                                  REG_DWORD,
                                  (LPBYTE)&Value,
                                  sizeof(DWORD));

            RegCloseKey(hRelKey);
        }
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\spooler.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    spooler.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "winsprlp.h"
//
// RPC Buffer size 64K
//
#define BUFFER_SIZE  0x10000


DWORD
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpStartDocPrinter)
                                                    (pPrintHandle->hPrinter,
                                                     Level, pDocInfo);
}

BOOL
StartPagePrinter(
   HANDLE hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpStartPagePrinter)
                                                    (pPrintHandle->hPrinter);
}

BOOL
SplCommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)

/*++
Function Description: Commits data written into the spool file. creates a new temp
                      file handle for remote printing.

Parameters: hPrinter       - printer handle
            hAppProcess    - application process handle
            cbCommit       - number of bytes to commit (incremental)
            dwLevel        - spoolfileinfo level
            pSpoolFileInfo - pointer to buffer
            cbBuf          - buffer size
            pcbNeeded      - pointer to return required buffer size

Return Values: TRUE if sucessful;
               FALSE otherwise
--*/

{
    BOOL   bReturn = FALSE;
    DWORD  cbTotalWritten, cbWritten, cbRead, cbToRead;
    BYTE   *Buffer = NULL;
    HANDLE hFile, hSpoolerProcess = NULL, hFileApp = INVALID_HANDLE_VALUE;

    PSPOOL_FILE_INFO_1  pSpoolFileInfo1;
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;

    // Check Handle validity
    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return bReturn;
    }

    // Check for valid level and sufficient buffer
    switch (dwLevel) {
    case 1:
       if (cbBuf < si