inDisplayedHelp && (sc.ToHr() != S_OK))
        sc = ScHelpTopics ();

    if (sc)
        TraceError (_T("CAMCView::ScContextHelp"), sc);

    return (sc);
}


void CAMCView::OnSnapInHelp()
{
    SendGenericNotify(NCLBK_SNAPINHELP);
}

void CAMCView::OnSnapinAbout()
{
    DECLARE_SC(sc, TEXT("CAMCView::OnSnapinAbout"));

    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers((void*) hNode, E_UNEXPECTED);
    if (sc)
        return;

    INodeCallback *pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
        return;

    sc = pNC->ShowAboutInformation(hNode);
    if (sc)
        return;

    return;
}

void CAMCView::OnHelpTopics()
{
    ScHelpTopics();
}


SC CAMCView::ScHelpWorker (LPCTSTR pszHelpTopic)
{
    DECLARE_SC (sc, _T("CAMCView::ScShowSnapinHelpTopic"));
    USES_CONVERSION;

    /*
     * generation of the help collection might take a while, so display
     * a wait cursor
     */
    CWaitCursor wait;

    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);

    CAMCDoc* pdoc = GetDocument();

    // Point helpdoc info to current console file path
    if (pdoc->GetPathName().IsEmpty())
        pdoc->GetHelpDocInfo()->m_pszFileName = NULL;
    else
        pdoc->GetHelpDocInfo()->m_pszFileName = T2COLE(pdoc->GetPathName());

    /*
     * smart pointer for automatic deletion of the help file name
     */
    CCoTaskMemPtr<WCHAR> spszHelpFile;

    sc = pNC->Notify (0, NCLBK_GETHELPDOC,
                         reinterpret_cast<LPARAM>(pdoc->GetHelpDocInfo()),
                         reinterpret_cast<LPARAM>(&spszHelpFile));

    if (sc)
        return (sc);

    CAMCApp* pAMCApp = AMCGetApp();
    if (NULL == pAMCApp)
        return (sc = E_UNEXPECTED);

    sc = pAMCApp->ScShowHtmlHelp(W2T(spszHelpFile), (DWORD_PTR) pszHelpTopic);

    return (sc);
}

SC CAMCView::ScHelpTopics ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    return (ScHelpWorker (NULL));
}


SC CAMCView::ScShowSnapinHelpTopic (LPCTSTR pszHelpTopic)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    CString strTopicPath;

    // Add protocol prefix to topic string
    if (pszHelpTopic != NULL)
    {
        strTopicPath = _T("ms-its:");
        strTopicPath += pszHelpTopic;
    }

    SC sc = ScHelpWorker (strTopicPath);

    if (!sc)
        m_fSnapinDisplayedHelp = true;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::UpdateSnapInHelpMenus
//
//  Synopsis:    Update the following Help menu items
//                a) Help on <Snapin> (if snapin does not support HTML help)
//                b) About <Snapin>   (if snapin supports about object)
//
//  Arguments:   [pMenu]  - The help popup menu.
//
//--------------------------------------------------------------------
void CAMCView::UpdateSnapInHelpMenus(CMenu* pMenu)
{
    DECLARE_SC(sc, TEXT("CAMCView::UpdateSnapInHelpMenus"));
    sc = ScCheckPointers(pMenu);
    if (sc)
        return;

    ASSERT_VALID (this);

    HNODE hNode = GetSelectedNode();

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(hNode, pNC, E_UNEXPECTED);
    if (sc)
        goto Error;

    // Empty block for goto's
    {
        // First Make sure this is not a dummy substitute snapin.
        bool bDummySnapin = false;
        sc = pNC->IsDummySnapin (hNode, bDummySnapin);
        if (sc)
            goto Error;

        if (bDummySnapin)
            goto Error;

        // Get the snapin name for "Help on <SnapinName>" or "About <SnapinName>" menus
        CCoTaskMemPtr<WCHAR> spszName;
        CString strMenu;

        // Try to get name of snap-in for custom menu item
        bool bSnapinNameValid = false;
        sc = pNC->GetSnapinName(hNode, &spszName, bSnapinNameValid);
        if (sc)
            goto Error;

        ASSERT( spszName != NULL || bSnapinNameValid );

        USES_CONVERSION;

        // if snapin supports html help, don't give it it's own help command
        bool bStandardHelpExists = false;
        sc = pNC->DoesStandardSnapinHelpExist(hNode, bStandardHelpExists);
        if (sc)
            goto Error;

        if (bStandardHelpExists)
        {
            pMenu->DeleteMenu(ID_HELP_SNAPINHELP, MF_BYCOMMAND);
        }
        else
        {
            if (bSnapinNameValid)
            {
                // "Help on <SnapinName>"
                LoadString(strMenu, IDS_HELP_ON);
                AfxFormatString1(strMenu, IDS_HELP_ON, OLE2T(spszName));
            }
            else
            {
                // ""Help on Snap-in"
                LoadString(strMenu, IDS_HELP_ON_SNAPIN);
            }

            // Either add or modify the custom help menu item
            if (pMenu->GetMenuState(ID_HELP_SNAPINHELP, MF_BYCOMMAND) == (UINT)-1)
            {
                pMenu->InsertMenu(ID_HELP_HELPTOPICS, MF_BYCOMMAND|MF_ENABLED, ID_HELP_SNAPINHELP, strMenu);
            }
            else
            {
                pMenu->ModifyMenu(ID_HELP_SNAPINHELP, MF_BYCOMMAND|MF_ENABLED, ID_HELP_SNAPINHELP, strMenu);
            }
        }

        /* Now add the About <Snapin> menu*/
        bool bAboutExists = false;
        SC scNoTrace = pNC->DoesAboutExist(hNode, &bAboutExists);
        if ( (scNoTrace.IsError()) || (!bAboutExists) )
        {
            pMenu->DeleteMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND);
            return;
        }

        if (bSnapinNameValid)
        {
            // "About on <SnapinName>"
            AfxFormatString1(strMenu, IDS_ABOUT_ON, OLE2T(spszName));
        }
        else
        {
            // Cant get name just delete & return
            pMenu->DeleteMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND);
            return;
        }

        if (pMenu->GetMenuState(ID_SNAPIN_ABOUT, MF_BYCOMMAND) == (UINT)-1)
        {
            pMenu->InsertMenu(-1, MF_BYPOSITION|MF_ENABLED, ID_SNAPIN_ABOUT, strMenu);
        }
        else
        {
            pMenu->ModifyMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND|MF_ENABLED, ID_SNAPIN_ABOUT, strMenu);
        }
    }

Cleanup:
    return;
Error:
    pMenu->DeleteMenu(ID_HELP_SNAPINHELP, MF_BYCOMMAND);
    pMenu->DeleteMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND);
    goto Cleanup;
}

#ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)
/*
 * Displays errors from the list save function and cleans up the file if necessary
 */

void CAMCView::ListSaveErrorMes(EListSaveErrorType etype, HANDLE hfile, LPCTSTR lpFileName)
{
    CString strMessage;

    switch (etype)
    {

    case LSaveCantCreate:
        //"ERROR: Unable to create file."
        FormatString1 (strMessage, IDS_LISTSAVE_ER1, lpFileName);
        break;

    case LSaveCantWrite:
        // ERROR: Created file but encountered an error while writing to it
        FormatString1 (strMessage, IDS_LISTSAVE_ER2, lpFileName);
        break;

    case LSaveReadOnly:
        //"ERROR: File to be overwritten is read only."
        FormatString1 (strMessage, IDS_LISTSAVE_ER3, lpFileName);
        break;

    default:
        // Should not make it here
        ASSERT(0);
    }
    MMCMessageBox (strMessage);
}


// Saves a list and performs necessary dialog boxes and error checking
SC CAMCView::ScSaveList()
{
    DECLARE_SC(sc, _T("ScSaveList"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    sc = ScExportListWorker();
    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetExportListFile
//
//  Synopsis:    Get the filename, flags for save list.
//
//  Arguments:   [strFileName]       - File Name retval.
//               [bUnicode]          - Unicode or ansi.
//               [bTabDelimited]     - Tab or Comma delimited.
//               [bSelectedRowsOnly] - selected items only or all items.
//
//  Returns:     SC, S_FALSE if user cancels dialog.
//
//--------------------------------------------------------------------
SC CAMCView::ScGetExportListFile (CString& strFileName,
                                  bool& bUnicode,
                                  bool& bTabDelimited,
                                  bool& bSelectedRowsOnly)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetExportListFile"));

    CString strFilter;
    LoadString(strFilter, IDS_ANSI_FILE_TYPE);

#ifdef UNICODE
    {   // limit the lifetime of strUniFilter
        CString strUniFilter;
        LoadString(strUniFilter, IDS_UNICODE_FILE_TYPE);
        strFilter += strUniFilter;
    }
#endif

    // End of Filter char
    strFilter += "|";

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // See if there are any items selected else disable the "Selected items only" check-box.
    CListCtrl& ctlList = m_pListCtrl->GetListCtrl();
    int iItem = ctlList.GetNextItem( -1,LVNI_SELECTED);

    bool bSomeRowSelected = (-1 != iItem);

    // Create the dialog. File extensions are not localized.
    CSaveFileDialog dlgFile(false, _T("txt"), NULL,
                            OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLESIZING,
                            strFilter, bSomeRowSelected);

    // Display the dialog
    if (dlgFile.DoModal() == IDCANCEL)
       return S_FALSE; // S_FALSE if user cancels dialog.

    // Create a wait cursor and redraw the screen (necessary in saving big files)
    CWaitCursor wait;
    AfxGetMainWnd()->RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW );

    // Retrieve the filename
    strFileName = dlgFile.GetPathName();
    bSelectedRowsOnly = (dlgFile.Getflags() & SELECTED);

    switch (dlgFile.GetFileType())
    {
    case FILE_ANSI_TEXT:
        bTabDelimited = true; // Tab delimited.
        bUnicode = false;
        break;

    case FILE_ANSI_CSV:
        bTabDelimited = false; // Comma delimited.
        bUnicode = false;
        break;

#ifdef UNICODE
    case FILE_UNICODE_TEXT:
        bTabDelimited = true; // tab delimited.
        bUnicode = true;
        break;

    case FILE_UNICODE_CSV:
        bTabDelimited = false; // comma delimited.
        bUnicode = true;
        break;
#endif

    default:
        sc = E_UNEXPECTED;
        break;
    }


    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCreateExportListFile
//
//  Synopsis:    Create a file with given name & path. Write unicode marker if needed.
//
//  Arguments:   [strFileName]       - file to create.
//               [bUnicode]          - unicode or ansi file.
//               [bShowErrorDialogs] - Show error dialogs or not.
//               [hFile]             - Retval, handle to file.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCreateExportListFile(const CString& strFileName, bool bUnicode,
                                    bool  bShowErrorDialogs, HANDLE& hFile)
{
    DECLARE_SC(sc, _T("CAMCView::ScCreateExportListFile"));

    // Create a file according to specs
    hFile = CreateFile(strFileName, GENERIC_WRITE,
                       0, NULL, CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD dwAttrib = GetFileAttributes(strFileName);

    // If it did not fail and the file is read-only
    // Not required. Used to determine if the file being overwritten is read only and display appropriate message
    if ((dwAttrib != 0xFFFFFFFF) &&
        (dwAttrib & FILE_ATTRIBUTE_READONLY))
    {
        if (bShowErrorDialogs)
            ListSaveErrorMes(LSaveReadOnly, hFile, strFileName);

        return (sc = E_FAIL);
    }

    // Creation failed
    if (hFile == INVALID_HANDLE_VALUE)
    {
        if (bShowErrorDialogs)
            ListSaveErrorMes(LSaveCantCreate, NULL, strFileName);
        sc.FromWin32(::GetLastError());
        return sc;
    }

    /*
     * for Unicode files, write the Unicode prefix
     */
    if (bUnicode)
    {
        const WCHAR chPrefix = 0xFEFF;
        const DWORD cbToWrite = sizeof (chPrefix);
        DWORD       cbWritten;

        if (!WriteFile (hFile, &chPrefix, cbToWrite, &cbWritten, NULL) ||
            (cbToWrite != cbWritten))
        {
            CloseHandle(hFile);
            DeleteFile( strFileName );

            if (bShowErrorDialogs)
                ListSaveErrorMes(LSaveCantWrite, hFile, strFileName);

            return (sc = E_FAIL);
        }
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExportListWorker
//
//  Synopsis:    Prompt for a file name & write the ListView data to it.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExportListWorker()
{
    DECLARE_SC(sc, _T("CAMCView::ScExportListWorker"));

    CString strFileName;
    bool    bUnicode = false;
    bool    bTabDelimited = false;
    bool    bSelectedRowsOnly = false;

    sc = ScGetExportListFile(strFileName, bUnicode, bTabDelimited, bSelectedRowsOnly);

    if (sc.ToHr() == S_FALSE) // if user cancels dialog.
        return sc;

    sc = ScWriteExportListData(strFileName, bUnicode, bTabDelimited, bSelectedRowsOnly);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScWriteExportListData
//
//  Synopsis:    Write ListView data to given file.
//
//  Arguments:   [strFileName]       - File to create & write to.
//               [bUnicode]          - Unicode or ansi.
//               [bTabDelimited]     - Tab or Comma separated values.
//               [bSelectedRowsOnly] - like Selected rows only.
//               [bShowErrorDialogs] - Show error dialogs or not.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScWriteExportListData (const CString& strFileName,
                                    bool bUnicode,
                                    bool bTabDelimited,
                                    bool bSelectedRowsOnly,
                                    bool bShowErrorDialogs /*true*/)
{
    DECLARE_SC(sc, _T("CAMCView::ScWriteExportListData"));

    // Get number of rows and columns
    const int cRows = m_pListCtrl->GetItemCount();
    const int cCols = m_pListCtrl->GetColCount();

    // If there are no columns inserted then there cannot be any
    // items inserted into the listview. So error out.

    if (cCols <= 0)
        return (sc = E_UNEXPECTED);

    HANDLE hFile = NULL;
    sc = ScCreateExportListFile(strFileName, bUnicode, bShowErrorDialogs, hFile);
    if (sc)
        return sc;

    // Retrieve the flags
    CString strEol( _T("\r\n") );

    LPCTSTR pszSeparator = _T("\t");
    if (!bTabDelimited)
        pszSeparator = _T(",");

    // Determine how many columns must be printed
    int      printcols   = 1;

    struct ColInfo
    {
        CString strColName;
        BOOL    bHidden;
    };

    ColInfo*  rgColumns = NULL;
    int*     pnColOrder  = NULL;

    // If it is LVS_REPORT, get the list of column names, order
    // and hidden or not flag.
    if ( (m_pListCtrl->GetViewMode() == LVS_REPORT) ||
         (m_pListCtrl->GetViewMode() == MMCLV_VIEWSTYLE_FILTERED) )
    {
        printcols = cCols;

        // Allocate mem to store col names, order, hidden states
        rgColumns = new ColInfo[printcols];
        if (! rgColumns)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        pnColOrder = new int[printcols];
        if (! pnColOrder)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        CHeaderCtrl* pHeader = m_pListCtrl->GetHeaderCtrl();
        sc = ScCheckPointers(pHeader, E_UNEXPECTED);
        if (sc)
            goto Error;

        // Get the order
        if (!Header_GetOrderArray(pHeader->GetSafeHwnd(), printcols, pnColOrder))
        {
            goto Error;
        }

        // Get the name and hidden state of cols
        for (int i = 0; i < printcols ; i++)
        {
            TCHAR   szColName[MAX_PATH * 2];
            HDITEM  hdItem;

            hdItem.mask       = HDI_TEXT | HDI_LPARAM;
            hdItem.pszText    = szColName;
            hdItem.cchTextMax = countof (szColName);

            if (pHeader->GetItem (i, &hdItem))
            {
                CHiddenColumnInfo hci (hdItem.lParam);

                rgColumns[i].strColName = hdItem.pszText;
                rgColumns[i].bHidden    = hci.fHidden;
            }
            else
            {
                goto Error;
            }
        }

       for (int i = 0; i < printcols ; i++)
       {
           // Print the column name according to the order

           if (rgColumns[pnColOrder[i]].bHidden)
               continue;

           if ( (!Write2File(hFile, rgColumns[pnColOrder[i]].strColName, bUnicode)) ||
               ((i < printcols - 1) && (!Write2File(hFile, pszSeparator, bUnicode))))
           {
               goto CantWriteError;
           }
       }

       // Write an EOL character if necessary
       if (!Write2File(hFile, strEol, bUnicode))
       {
          goto CantWriteError;
       }
    }

    {
        // Data for use in the writing stage
        CString strData;
        CListCtrl& ctlList = m_pListCtrl->GetListCtrl();

        // Set iNextType to 0 if all items will be saved or LVNI_SELECTED if only selected ones will be saved
        int iNextType = 0;
        if (bSelectedRowsOnly)
            iNextType = LVNI_SELECTED;

        // Find the first item in the list
        int iItem = ctlList.GetNextItem( -1,iNextType);

        // Iterate until there are no more items to save
        while (iItem != -1)
        {
            for(int ind2 = 0; ind2 < printcols ; ind2++)
            {
                if (rgColumns)
                {
                    // If not hidden get the item
                    if (rgColumns[pnColOrder[ind2]].bHidden)
                        continue;
                    else
                        strData = ctlList.GetItemText( iItem, pnColOrder[ind2]);
                }
                else
                    strData = ctlList.GetItemText( iItem, ind2);

                // Write the text and if necessary a comma
                // If either one fails, then delete the file and return
                if ( (!Write2File(hFile, strData, bUnicode)) ||
                    ((ind2 < printcols - 1) && (!Write2File(hFile, pszSeparator, bUnicode))))
                {
                    goto CantWriteError;

                }
            }

            // Write an EOL character if necessary
            if (!Write2File(hFile, strEol, bUnicode))
            {
                goto CantWriteError;
            }
            // Find the next item to save
            iItem = ctlList.GetNextItem( iItem, iNextType);
        }
    }

Cleanup:
    if (rgColumns)
        delete[] rgColumns;

    if (pnColOrder)
        delete[] pnColOrder;

    CloseHandle(hFile);
    return (sc);

CantWriteError:
    if (bShowErrorDialogs)
        ListSaveErrorMes(LSaveCantWrite, hFile, strFileName);

Error:
    DeleteFile( strFileName );
    goto Cleanup;
}

// Write out a string to the given file
// Used as a separate function to preserve memory
// Returns true if successful, false otherwise
bool CAMCView::Write2File(HANDLE hfile, LPCTSTR strwrite, BOOL fUnicode)
{
	DECLARE_SC(sc, TEXT("CAMCView::Write2File"));

	// parameter check;
	sc = ScCheckPointers( strwrite );
	if (sc)
		return false;

    // Initializes Macro
    USES_CONVERSION;

    // The number of bytes written
    DWORD cbWritten;
    DWORD cbToWrite;

    if (fUnicode)
    {
        // Convert the string to Unicode and write it to hfile
        LPCWSTR Ustring = T2CW( strwrite );
        cbToWrite = wcslen (Ustring) * sizeof (WCHAR);
        WriteFile(hfile, Ustring, cbToWrite, &cbWritten, NULL);
    }
    else
    {
        // Convert the string to ANSI and write it to hfile
        const unsigned char* Astring = (const unsigned char*) T2CA( strwrite );
        cbToWrite = _mbsnbcnt (Astring, _mbslen (Astring));
        WriteFile(hfile, Astring, cbToWrite, &cbWritten, NULL);
    }

    // Make sure that the correct number of bytes were written
    return (cbWritten == cbToWrite);
}
#endif  // IMPLEMENT_LIST_SAVE        See nodemgr.idl (t-dmarm)

// Refreshes all panes and HTML
void CAMCView::OnRefresh()
{
    HWND hwnd = ::GetFocus();

    if (IsVerbEnabled(MMC_VERB_REFRESH))
    {
        ScConsoleVerb(evRefresh);
    }
    else if (HasWebBrowser())
    {
        ScWebCommand(eWeb_Refresh);
    }
    ::SetFocus(hwnd);
}

void CAMCView::OnVerbAccelKey(UINT nID)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnVerbAccelKey"));

    switch (nID)
    {
    case ID_MMC_CUT:
        if (IsVerbEnabled(MMC_VERB_CUT))
            sc = ScConsoleVerb(evCut);
        break;

    case ID_MMC_COPY:
        if (IsVerbEnabled(MMC_VERB_COPY))
            sc = ScConsoleVerb(evCopy);
        break;

    case ID_MMC_PASTE:
        if (IsVerbEnabled(MMC_VERB_PASTE))
        {
            // Check if the dataobject in clipboard can be
            // pasted into the selected node.
            // Then only we send MMCN_PASTE notification to snapin.

            HNODE  hNode  = NULL;
            LPARAM lvData = NULL;
            bool   bScope = FALSE;
            sc = ScGetFocusedItem(hNode, lvData, bScope);
            if (sc)
                break;

            INodeCallback* pNC = GetNodeCallback();
            sc = ScCheckPointers(pNC, hNode, E_UNEXPECTED);
            if (sc)
                break;

            bool bPasteAllowed = false;
            sc = pNC->QueryPasteFromClipboard(hNode, bScope, lvData, bPasteAllowed);

            if (sc)
                break;

            if (bPasteAllowed)
                sc = ScConsoleVerb(evPaste);
        }
        break;

    case ID_MMC_PRINT:
        if (IsVerbEnabled(MMC_VERB_PRINT))
            sc = ScConsoleVerb(evPrint);
        break;

    case ID_MMC_RENAME:
        if (IsVerbEnabled(MMC_VERB_RENAME))
            sc = ScConsoleVerb(evRename);
        break;

    case ID_MMC_REFRESH:
        OnRefresh();
        break;

    default:
        ASSERT(FALSE);
    }

    if (sc)
        return;
}

//
// Handle accelerator keys shared by result and scope panes
//
BOOL CAMCView::OnSharedKeyDown(WORD wVKey)
{
    BOOL bReturn = TRUE;

    if (::GetKeyState(VK_CONTROL) < 0)
    {
        switch (wVKey)
        {
            case 'C':
            case 'c':
            case VK_INSERT:
                OnVerbAccelKey(ID_MMC_COPY);   // Ctrl-C, Ctrl-Insert
                break;

            case 'V':
            case 'v':
                OnVerbAccelKey(ID_MMC_PASTE);  // Ctrl-V
                break;

            case 'X':
            case 'x':
                OnVerbAccelKey(ID_MMC_CUT);    // Ctrl-X
                break;

            default:
                bReturn = FALSE;
         }
     }
     else if (::GetKeyState(VK_SHIFT) < 0)
     {
        switch (wVKey)
        {
            case VK_DELETE:
                OnVerbAccelKey(ID_MMC_CUT);    // Shift-Delete
                break;

            case VK_INSERT:
                OnVerbAccelKey(ID_MMC_PASTE);  // Shift -Insert
                break;

            default:
                bReturn = FALSE;
        }

    }
    else
    {
        switch (wVKey)
        {
            case VK_F2:
                OnVerbAccelKey(ID_MMC_RENAME);   // F2
                break;

            default:
                bReturn = FALSE;
        }
    }

    return bReturn;
}


//+-------------------------------------------------------------------
//
//  Member:      ScConsoleVerb
//
//  Synopsis:    Execute the Console verb.
//
//  Arguments:   [nVerb]  - The verb to be executed.
//
//  Note:        The verb is executed in the context of
//               currently focused item (scope or result).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScConsoleVerb (int nVerb)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT_VALID (this);

    DECLARE_SC (sc, _T("CAMCView::ScConsoleVerb"));

    HNODE  hNode = NULL;
    LPARAM lvData = 0;
    bool   bScope = false;

    // Get the focused item to process the console verb.
    sc = ScGetFocusedItem(hNode, lvData, bScope);
    if (sc)
        return sc;

    sc = ScProcessConsoleVerb(hNode, bScope, lvData, nVerb);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScProcessConsoleVerb
//
//  Synopsis:    Execute the Console verb with given context.
//
//  Arguments:   [hNode]  - The tree node context.
//               [bScope] - Scope or Result pane.
//               [lvData] - LPARAM of result item (if result pane has focus).
//               [nVerb]  - The verb to be executed.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScProcessConsoleVerb(HNODE hNode, bool bScope, LPARAM lvData, int nVerb)
{
    DECLARE_SC (sc, _T("CAMCView::ScProcessConsoleVerb"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT_VALID (this);

    // To maintain compatibility with MMC1.2 (This is init to LVERROR which
    // nodemgr process differently).
    if (bScope)
        lvData = 0;

    if (lvData == LVDATA_BACKGROUND)
    {
        switch (nVerb)
        {
        case evCut:
        case evCopy:
        case evDelete:
        case evRename:
            sc = E_UNEXPECTED;
            return sc;
        }
    }

    NCLBK_NOTIFY_TYPE nclbk = NCLBK_NONE;

    switch (nVerb)
    {
    case evCut:          nclbk = NCLBK_CUT;          break;
    case evCopy:         nclbk = NCLBK_COPY;         break;
    case evDelete:       nclbk = NCLBK_DELETE;       break;
    case evProperties:   nclbk = NCLBK_PROPERTIES;   break;
    case evPrint:        nclbk = NCLBK_PRINT;        break;

    case evPaste:
        {
            INodeCallback* pNC = GetNodeCallback();
            sc = ScCheckPointers(pNC, E_UNEXPECTED);
            if (sc)
                return sc;

            sc = pNC->Paste(hNode, bScope, lvData);

            if (sc)
                return sc;

            sc = ScPaste ();
            if (sc)
                return sc;

            break;
        }

    case evRefresh:
        // if web page on view, send it a refresh first
        if (HasWebBrowser())
            sc = ScWebCommand(eWeb_Refresh);
        if (sc)
            return sc;

        nclbk = NCLBK_REFRESH;
        break;

    case evRename:
        // Enable edit for the item.
        if (bScope == TRUE)
        {
            if (sc = ScCheckPointers(m_pTreeCtrl, E_UNEXPECTED))
                return sc;

            HTREEITEM hti = m_pTreeCtrl->GetSelectedItem();
            if (sc = ScCheckPointers(hti, E_UNEXPECTED))
                return sc;

            m_pTreeCtrl->EditLabel(hti);
        }
        else
        {
            if ( sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED))
                return sc;

            CAMCListView* pListView = m_pListCtrl->GetListViewPtr();
            if (NULL == pListView)
            {
                sc = E_UNEXPECTED;
                return sc;
            }

            int iItem = _GetLVSelectedItemData(&lvData);
            ASSERT(iItem >= 0);
            CListCtrl& listCtrl = pListView->GetListCtrl();
            listCtrl.EditLabel(iItem);
        }
        break;

    default:
        sc = E_UNEXPECTED;
        return sc;
    }

    if (nclbk != NCLBK_NONE)
    {
        // Ask the nodemgr to process the verb.
        INodeCallback* pNC = GetNodeCallback();
        if (pNC == NULL)
        {
            sc = E_UNEXPECTED;
            return sc;
        }

        sc = pNC->Notify(hNode, nclbk, bScope, lvData);
        if (sc)
            return sc;
    }

    if (nclbk == NCLBK_CUT)
        sc = ScCut (bScope ? m_pTreeCtrl->GetSelectedItem() : 0);

    if (sc)
        return sc;


    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScListViewSelectionActivate
//
//  Synopsis:    Only the list(/Web/OCX) or the tree can be "active" from the point
//               of view of selected items and MMCN_SELECT. This is not
//               the same as the MFC concept of "active view". There are a couple
//               of views that cannot be active in this sense, such as the taskpad
//               and tab views.
//               When the active view (according to this definition) changes, this
//               function is called. Thus, ScTreeViewSelectionActivate and
//               ScListViewSelectionActivate/ScSpecialResultpaneSelectionActivate
//               are always called in pairs when the activation changes, one to handle
//               deactivation, and one to handle activation.
//
//               Consider the following scenario
//               1) The tree view has (MFC/windows style) focus.
//               2) The user clicks on the taskpad view
//                   Result - selection activation does not change from the tree. All verbs
//                   still correspond to the selected tree item.
//               3) The user clicks on the folder view
//                   Result - once again, selection activation does not chang
//               4) The user clicks on one of the result views eg the list
//                   Result - ScTreeViewSelectionActivate(false) and ScListViewSelectionActivate(true)
//                   Thus verbs and the toolbar now correspond to the selected list item(s).
//               5) The user clicks on the taskpad view.
//                   Result - as in step 2, nothing happens
//               6) The user clicks on the result view
//                   Result - because the active view has not changed, nothing happens.
//
//  Arguments:   [bActivate] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScListViewSelectionActivate(bool bActivate)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScListViewSelectionActivate"));

    if (m_pListCtrl == NULL)
        return sc;

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
    {
        sc.TraceAndClear();
        return sc;
    }

    HNODE hNodeSel = GetSelectedNode();

    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));
    selInfo.m_bScope = FALSE;
    selInfo.m_bDueToFocusChange = TRUE;

#ifdef DBG
    if (bActivate == TRUE)
    {
        ASSERT(m_bProcessMultiSelectionChanges == false);
    }
#endif // DBG

    /*
     * The below block can never execute. When m_bProcessMultiSelectionChanges is
     * set to true messages are posted to handle multiselection changes. So the
     * handler OnProcessMultiSelectionChanges should have processed the message and the
     * m_bProcessMultiSelectionChanges should have been reset by now. If there is
     * some unknown way to make de-activate the listview before processing the message
     * then below block will be executed that will send de-select notification.
     *
     * The below block sends a de-select multi-select items.
     */
    if (m_bProcessMultiSelectionChanges)
    {
        ASSERT(false); // Would like to know when this block is hit.

        ASSERT(bActivate == false);

        m_bProcessMultiSelectionChanges = false;

        sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

        // Focus change so appropriately enable std-toolbar buttons
        // back, forward, export-list, up-one-level, show/hide-scope, help
        sc = ScUpdateStandardbarMMCButtons();
        if (sc)
            sc.TraceAndClear();
    }

    bool bSelect = bActivate;

    do
    {
        //
        // Multi select
        //

        int cSelected = m_pListCtrl->GetSelectedCount();

        if (cSelected > 1)
        {
            sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, bSelect, 0);
            if (sc)
                sc.TraceAndClear(); // ignore & continue;

            m_bLastSelWasMultiSel = bSelect;
            break;
        }


        //
        // Zero or Single select
        //

        if (cSelected == 0)
        {
            selInfo.m_bBackground = TRUE;
            selInfo.m_lCookie     = LVDATA_BACKGROUND;
        }
        else
        {
#include "pushwarn.h"
#pragma warning(disable: 4552)      // ">=" operator has no effect
            VERIFY(_GetLVSelectedItemData(&selInfo.m_lCookie) >= 0);
#include "popwarn.h"
        }

        ASSERT(cSelected >= 0);
        ASSERT(cSelected <= 1);
        sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, bSelect, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

    } while (0);

    return sc;
}


void CAMCView::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CView::OnShowWindow(bShow, nStatus);
}

int CAMCView::_GetLVItemData(LPARAM *plParam, UINT flags)
{
    HWND hwnd = m_pListCtrl->GetListViewHWND();
    int iItem = ::SendMessage(hwnd, LVM_GETNEXTITEM, (WPARAM) (int) -1,
                              MAKELPARAM(flags, 0));
    if (iItem >= 0)
    {
        if (IsVirtualList())
        {
            *plParam = iItem;
        }
        else
        {
            LV_ITEM lvi;
            ZeroMemory(&lvi, sizeof(lvi));
            lvi.iItem  = iItem;
            lvi.mask = LVIF_PARAM;

#include "pushwarn.h"
#pragma warning(disable: 4553)      // "==" operator has no effect
            VERIFY(::SendMessage(hwnd, LVM_GETITEM, 0, (LPARAM)&lvi) == TRUE);
#include "popwarn.h"

            *plParam = lvi.lParam;
        }
    }

    return iItem;
}

int CAMCView::_GetLVFocusedItemData(LPARAM *plParam)
{
    return (_GetLVItemData (plParam, LVNI_FOCUSED));
}

int CAMCView::_GetLVSelectedItemData(LPARAM *plParam)
{
    return (_GetLVItemData (plParam, LVNI_SELECTED));
}


void CAMCView::SetListViewMultiSelect(BOOL bMultiSelect)
{
    long lStyle = m_pListCtrl->GetListStyle();
    if (bMultiSelect == FALSE)
        lStyle |= LVS_SINGLESEL;
    else
        lStyle &= ~LVS_SINGLESEL;

    m_pListCtrl->SetListStyle(lStyle);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnItemDeselected
 *
 * PURPOSE: Tree observer method. Called when a tree item is deselected.
 *
 * PARAMETERS:
 *    HNODE  hNode : The node that was deselected.
 *
 * NOTE: This function can be merged with the next.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnItemDeselected(HNODE hNode)
{
    DECLARE_SC (sc, TEXT("CAMCView::ScOnItemDeselected"));

    DeSelectResultPane(hNode);

    if (!hNode)
        return sc;

    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));

    // Ask the SnapIn to cleanup any items it has inserted.
    INodeCallback* spNodeCallBack = GetNodeCallback();
    ASSERT(spNodeCallBack != NULL);

    selInfo.m_bScope = TRUE;
    selInfo.m_pView = NULL;

    Dbg(DEB_USER6, _T("T1. CAMCTreeView::OnDeSelectNode<1, 0>\n"));
    sc = ScNotifySelect (spNodeCallBack, hNode, false /*fMultiSelect*/, false, &selInfo);
    if (sc)
        sc.TraceAndClear(); // ignore & continue;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::DeSelectResultPane
 *
 * PURPOSE: Deselects the result pane and sets the view type to invalid.
 *
 * PARAMETERS:
 *    HNODE  hNodeSel :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::DeSelectResultPane(HNODE hNodeSel)
{
    DECLARE_SC(sc, TEXT("CAMCView::DeSelectResultPane"));

    if (m_spTaskPadHost.GetInterfacePtr() != NULL)
    {
        CTaskPadHost *pTaskPadHost = dynamic_cast<CTaskPadHost *>(m_spTaskPadHost.GetInterfacePtr());
        m_spTaskPadHost = NULL;
    }

    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);

    if (hNodeSel == 0)
        return;

    // If there was no list view being displayed return.
    if (HasListOrListPad())
    {
        // if we were in ListPad-mode, undo that.
        if (m_pListCtrl->IsListPad())
        {
            sc = m_pListCtrl->ScAttachToListPad (NULL, NULL);
            if(sc)
                sc.TraceAndClear(); //ignore
        }

        // If we are in edit mode cancel it.
        m_pListCtrl->GetListCtrl().EditLabel(-1);

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = FALSE;

        /*
         * The below block can never execute. When m_bProcessMultiSelectionChanges is
         * set to true messages are posted to handle multiselection changes. So the
         * handler OnProcessMultiSelectionChanges should have processed the message and the
         * m_bProcessMultiSelectionChanges should have been reset by now. If there is
         * some unknown way to make select different node (to deselect result pane)
         * before processing the message then below block will be executed that will
         * send de-select notification.
         *
         * The below block sends a de-select multi-select items.
         */
        if (m_bProcessMultiSelectionChanges)
        {
            ASSERT(false); // Would like to know when this block is hit.

            m_bProcessMultiSelectionChanges = false;

            sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
            if (sc)
                sc.TraceAndClear(); // ignore & continue;
        }
        else
        {
            UINT cSel = m_pListCtrl->GetSelectedCount();
            if (cSel == 1)
            {
                if (cSel)
                {
                    int iItem = _GetLVSelectedItemData(&selInfo.m_lCookie);
                    ASSERT(iItem != -1);
                    sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, false, &selInfo);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;
                }
            }
            else if (cSel > 1)
            {
                sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
                if (sc)
                    sc.TraceAndClear(); // ignore & continue;

                m_bLastSelWasMultiSel = false;
            }
        }
    }
    else
    {
        // If it is OCX or Web send de-select notifications.
        sc = ScSpecialResultpaneSelectionActivate(FALSE);
    }
}


LRESULT CAMCView::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
       // NATHAN
        case WM_NOTIFYFORMAT:
        {
            int id = ::GetDlgCtrlID ((HWND)wParam);
            //if (m_pTreeCtrl == NULL || ((HWND)wParam != m_pTreeCtrl->m_hWnd))
            if (id == IDC_ListView)
                 return NFR_UNICODE;
        }
        break;
#ifdef DBG
        case WM_KEYUP:
        {
            switch (wParam)
            {
            case VK_SHIFT:
            case VK_CONTROL:
                // We removed some code that will work if m_bProcessMultiSelectionChanges
                // is true. I dont see any way the bool being true. Still let us have below
                // assert. If this gets fired then we should call OnProcessMultiSelectionChanges.
                ASSERT(m_bProcessMultiSelectionChanges == false);
                break;
            }
            break;
        }
        break;
#endif
    }

    return CView::WindowProc(message, wParam, lParam);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ChangePane
 *
 * Moves the activation from pane to pane.  The (forward) tab order is
 *
 *      Scope pane (either tree or favorites)
 *      Result pane
 *      Task view (if visible)
 *--------------------------------------------------------------------------*/


class CTabOrderEntry
{
public:
    CView* const        m_pView;
    const bool          m_bValid; // is this entry valid

    CTabOrderEntry(CView *pView)
        :   m_pView  (pView),
            m_bValid ((pView != NULL) && IsWindowVisible (pView->m_hWnd))
    {}
};


void CAMCView::ChangePane(AMCNavDir eDir)
{
    ASSERT_VALID (this);

    CFrameWnd* pFrame      = GetParentFrame();
    CView*     pActiveView = pFrame->GetActiveView();
    HWND       hWndActive  = ::GetFocus();


    CTabOrderEntry rgOrderEntry[] =
    {
        CTabOrderEntry(GetPaneView(ePane_ScopeTree)),   // tree has focus
        CTabOrderEntry(GetPaneView(ePane_Results)),     // results has focus - note the value of INDEX_RESULTS_PANE below.
        CTabOrderEntry(m_pViewExtensionCtrl),           // view extension web page has focus
        CTabOrderEntry(m_pResultFolderTabView),         // result tab control has focus
    };

    /*
     * this is the index of the result pane entry in rgOrderEntry,
     * used for default focus placement if something unexpected happens
     */
    const int INDEX_RESULTS_PANE = 1;
    ASSERT (rgOrderEntry[INDEX_RESULTS_PANE].m_pView == GetPaneView(ePane_Results));

    // Get the navigator if one exists. If so, use it and bail.
    CAMCNavigator* pNav = dynamic_cast<CAMCNavigator*>(pActiveView);
    if (pNav && pNav->ChangePane(eDir))
        return;

    int cEntries = (sizeof(rgOrderEntry) / sizeof(rgOrderEntry[0]));

    // get the currently active entry.
    for(int i = 0; i< cEntries; i++)
    {
        if( (rgOrderEntry[i].m_pView  == pActiveView) )
            break;
    }

    ASSERT(i < cEntries);
    if(i>= cEntries)
    {
        // if we don't know where we are, a bit of defensive coding puts the focus back
        // on the results pane, ie into a known state.
        i = INDEX_RESULTS_PANE;
    }

    int iPrev = i;

    // at this point we've found the right entry.
    int increment   =  (eDir==AMCNAV_PREV) ? -1 : 1;
    int sanityCount = 0;
    while(true)
    {
        i = (i+increment+cEntries) % cEntries;
        if(rgOrderEntry[i].m_bValid)
            break;

        sanityCount++;
        if(sanityCount == cEntries)
        {
            ASSERT(0 && "Something's seriously messed up!!");
            return;
        }
    }

    // update the active view
    if (i != iPrev)
        pFrame->SetActiveView(rgOrderEntry[i].m_pView);
    else
    {
        // if view retains focus and has a navigator,
        // tell navigator to take the focus
        if (pNav)
            pNav->TakeFocus(eDir);
    }

    // if there is a special focus handler, call it.
    CFocusHandler *pFocusHandler = dynamic_cast<CFocusHandler *>(rgOrderEntry[i].m_pView);
    if(pFocusHandler != NULL)
    {
        pFocusHandler->OnKeyboardFocus (LVIS_FOCUSED | LVIS_SELECTED,
                                        LVIS_FOCUSED | LVIS_SELECTED);
    }

}


void CAMCView::OnNextPane()
{
    ChangePane(AMCNAV_NEXT);
}

void CAMCView::OnPrevPane()
{
    ChangePane(AMCNAV_PREV);
}

void CAMCView::OnUpdateNextPane(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}

void CAMCView::OnUpdatePrevPane(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


void RestrictPointToWindow (CWnd* pwnd, CPoint* ppt)
{
    CRect rectWnd;

    pwnd->GetClientRect (rectWnd);

    if (ppt->x < rectWnd.left)
        ppt->x = rectWnd.left;
    else if (ppt->x > rectWnd.right)
        ppt->x = rectWnd.right;

    if (ppt->y < rectWnd.top)
        ppt->y = rectWnd.top;
    else if (ppt->y > rectWnd.bottom)
        ppt->y = rectWnd.bottom;
}


void CAMCView::OnShiftF10()
{
    CRect rect;
    CWnd* pwndFocus = GetFocus();
    CListCtrl& lc = m_pListCtrl->GetListCtrl();

    ASSERT_VALID (this);

    if (pwndFocus == &lc)
    {
        int iItem = lc.GetNextItem (-1, LVNI_SELECTED);
        CPoint pt = 0;

        if (iItem != -1)
        {
            VERIFY (lc.GetItemRect (iItem, rect, LVIR_ICON));
            pt = rect.CenterPoint ();
        }
        else
        {
            CHeaderCtrl* pHeader = m_pListCtrl->GetHeaderCtrl();

            if (pHeader != NULL && pHeader->IsWindowVisible())
            {
                pHeader->GetClientRect(&rect);
                pt.y = rect.Height();
                ASSERT (pt.y >= 0);
            }
        }

        /*
         * make sure the context menu doesn't show up outside the window
         */
        RestrictPointToWindow (&lc, &pt);

        m_pListCtrl->GetListViewPtr()->ClientToScreen(&pt);
        OnListContextMenu(pt);
    }

    else if (pwndFocus == m_pTreeCtrl)
    {
        HTREEITEM hTreeItem = m_pTreeCtrl->GetSelectedItem();
        if (hTreeItem == NULL)
            return;

        m_pTreeCtrl->GetItemRect (hTreeItem, rect, TRUE);

        CPoint ptClient (rect.left, rect.bottom-1);

        /*
         * make sure the context menu doesn't show up outside the window
         */
        RestrictPointToWindow (m_pTreeCtrl, &ptClient);

        CPoint ptScreen = ptClient;

        m_pTreeCtrl->ClientToScreen(&ptScreen);
        OnTreeContextMenu(ptScreen, ptClient, hTreeItem);
    }
}

void CAMCView::OnUpdateShiftF10(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


BOOL CAMCView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    if (nHitTest == HTCLIENT && pWnd == this && !IsTracking())
    {
        CPoint pt (GetMessagePos());
        ScreenToClient (&pt);

        if (m_rectVSplitter.PtInRect (pt))
        {
            SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZEWE));
            return TRUE;
        }
    }


    return CWnd::OnSetCursor(pWnd, nHitTest, message);
}



SC CAMCView::ScCut (HTREEITEM htiCut)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScCut"));

    CMainFrame* pMain = AMCGetMainWnd();
    sc = ScCheckPointers (pMain, E_UNEXPECTED);
    if (sc)
        return (sc);

    pMain->SetWindowToNotifyCBChange(m_hWnd);

    if (htiCut)
        m_pTreeCtrl->SetItemState (htiCut, TVIS_CUT, TVIS_CUT);
    else
        m_pListCtrl->CutSelectedItems (TRUE);

    m_htiCut = htiCut;

    return (S_OK);
}

SC CAMCView::ScPaste ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScPaste"));

    if (!m_htiCut)
        m_pListCtrl->CutSelectedItems(FALSE);

    CMainFrame* pMain = AMCGetMainWnd();
    sc = ScCheckPointers (pMain, E_UNEXPECTED);
    if (sc)
        return (sc);

    pMain->SetWindowToNotifyCBChange(NULL);

    return (S_OK);
}


HRESULT CAMCView::SendGenericNotify(NCLBK_NOTIFY_TYPE nclbk)
{
    BOOL bScope = TRUE;
    MMC_COOKIE lCookie = 0;
    int iItem = -1;

    ASSERT_VALID (this);

    if (m_pListCtrl && m_pListCtrl->GetListViewHWND() == ::GetFocus())
    {
        iItem = _GetLVSelectedItemData(&lCookie);
        if (iItem != -1)
            bScope = FALSE;
    }

    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);
    if (pNC == NULL)
        return E_FAIL;

    HNODE hNodeSel = GetSelectedNode();
    ASSERT(hNodeSel != NULL);
    if (hNodeSel == NULL)
        return E_FAIL;

    // selection notifications should use ScNotifySelect()
    ASSERT ((nclbk != NCLBK_SELECT) && (nclbk != NCLBK_MULTI_SELECT));

    return pNC->Notify(hNodeSel, nclbk, bScope, lCookie);
}

void CAMCView::SaveStartingSelectedNode()
{
    m_htiStartingSelectedNode = m_pTreeCtrl->GetSelectedItem();
}

bool CAMCView::HasNodeSelChanged()
{
    return (m_pTreeCtrl->GetSelectedItem() != m_htiStartingSelectedNode);
}


//+---------------------------------------------------------------------------
//
//  Function:   OnSysKeyDown
//
//  Synopsis:   Handles WM_SYSKEYDOWN message.
//              CAMCTreeView::OnSysKeyDown handles the Tree view so
//              here we handle only the list view (or Result pane)
//
//  Returns:    none
//
//+---------------------------------------------------------------------------
void CAMCView::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
        case VK_LEFT:
            ScWebCommand(eWeb_Back);
            break;

        case VK_RIGHT:
            ScWebCommand(eWeb_Forward);
            break;
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnAppCommand
 *
 * WM_APPCOMMAND handler for CAMCView.  This is used to handle to forward
 * and backward buttons on the IntelliMouse Explorer and the Microsoft
 * Natural Keyboards
 *--------------------------------------------------------------------------*/

LRESULT CAMCView::OnAppCommand(WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC (sc, _T("CAMCView::OnAppCommand"));

    switch (GET_APPCOMMAND_LPARAM (lParam))
    {
        case APPCOMMAND_BROWSER_BACKWARD:
            sc = ScWebCommand (eWeb_Back);
            if (sc)
                break;

            return (TRUE);      // handled here

        case APPCOMMAND_BROWSER_FORWARD:
            sc = ScWebCommand (eWeb_Forward);
            if (sc)
                break;

            return (TRUE);      // handled here

        case APPCOMMAND_BROWSER_REFRESH:
            OnRefresh ();
            return (TRUE);      // handled here
    }

    return (Default());
}


void CAMCView::OnPaletteChanged(CWnd* pwndFocus)
{
    // if displaying a web page, forward the palette change to the shell
    if (HasWebBrowser() && m_pWebViewCtrl != NULL)
    {
        if (m_pWebViewCtrl->m_hWnd != NULL)
        {
            HWND hwndShell = ::GetWindow(m_pWebViewCtrl->m_hWnd, GW_CHILD);

            if (hwndShell != NULL)
                ::SendMessage(hwndShell, WM_PALETTECHANGED, (WPARAM)pwndFocus->m_hWnd, (LPARAM)0);
        }
    }
}


BOOL CAMCView::OnQueryNewPalette()
{
    // if displaying a web page, forward the palette query to the shell
    if (HasWebBrowser() && m_pWebViewCtrl != NULL)
    {
        if (m_pWebViewCtrl->m_hWnd != NULL)
        {
            HWND hwndShell = ::GetWindow(m_pWebViewCtrl->m_hWnd, GW_CHILD);

            if (hwndShell != NULL)
                return ::SendMessage(hwndShell, WM_QUERYNEWPALETTE, (WPARAM)0, (LPARAM)0);
        }
    }

    return 0;
}


BOOL CAMCView::OwnsResultList(HTREEITEM hti)
{
    if (hti == NULL)
        return (false);

    // if result list is active
    if (HasListOrListPad())
    {
        // Get selected node and query node
        HNODE hnodeSelected = GetSelectedNode();
        HNODE hnode = m_pTreeCtrl ? m_pTreeCtrl->GetItemNode(hti) : NULL;

        if (hnodeSelected && hnode)
        {
            INodeCallback* pNC = GetNodeCallback();
            ASSERT(pNC != NULL);

            // See if the selected node uses the query node as a target
            //  S_OK    - yes
            //  S_FALSE - uses a different target node
            //  E_FAIL  - doesn't use a target node
            HRESULT hr = pNC->IsTargetNodeOf(hnodeSelected, hnode);
            if (hr == S_OK)
                return TRUE;
            else if (hr == S_FALSE)
                return FALSE;
            else
                return (hnodeSelected == hnode);
        }
    }

    return FALSE;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnSysColorChange
 *
 * WM_SYSCOLORCHANGE handler for CAMCView.
 *--------------------------------------------------------------------------*/

void CAMCView::OnSysColorChange()
{
    CView::OnSysColorChange();

    /*
     * the list control isn't a window but rather a wrapper on a window,
     * so we need to manually forward on the WM_SYSCOLORCHANGE
     */
    m_pListCtrl->OnSysColorChange();
}


/*+-------------------------------------------------------------------------*
 * TrackerCallback function
 *
 * Called by CViewTracker when tracking of splitter bar is completed. This
 * function applies the changes if the AcceptChange flag is set.
 *--------------------------------------------------------------------------*/

void CALLBACK TrackerCallback(
    TRACKER_INFO*   pInfo,
    bool            bAcceptChange,
    bool            bSyncLayout)
{
    DECLARE_SC (sc, _T("TrackerCallback"));

    if (bAcceptChange)
    {
        CAMCView* pView = dynamic_cast<CAMCView*>(pInfo->pView);
        sc = ScCheckPointers (pView, E_UNEXPECTED);
        if (sc)
            return;

        // Set new width and recompute layout
        pView->m_PaneInfo[CConsoleView::ePane_ScopeTree].cx = pInfo->rectTracker.left;
        pView->SetDirty();

        if (bSyncLayout)
        {
            Trace (tagSplitterTracking, _T("Synchronous layout"));
            pView->RecalcLayout();
            pView->UpdateWindow();
        }
        else
        {
            Trace (tagSplitterTracking, _T("Deferred layout"));
            pView->DeferRecalcLayout();
        }
    }
}


/*+-------------------------------------------------------------------------*
 * PtInWindow
 *
 * Test if point is in a window (pt is in screen coordinates)
 *--------------------------------------------------------------------------*/

BOOL PtInWindow(CWnd* pWnd, CPoint pt)
{
    if (!pWnd->IsWindowVisible())
        return FALSE;

    CRect rect;
    pWnd->GetWindowRect(&rect);

    return rect.PtInRect(pt);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScJiggleListViewFocus
 *
 * Bug 345402:  Make sure the focus rect is on the list control (if it
 * actually has the focus) to wake up any accessibility tools that might
 * be watching for input and focus changes.
 *
 * We post a message here rather than doing it synchronously so we can
 * allow any other processing in the list (like sorting) to happen
 * before we put the focus on the 1st item.  If we didn't wait until after
 * the sort, the item we put the focus on might not be the first item
 * in the list.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScJiggleListViewFocus ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    PostMessage (m_nJiggleListViewFocusMsg);

    return (S_OK);
}


LRESULT CAMCView::OnJiggleListViewFocus (WPARAM, LPARAM)
{
    CAMCListView* pListView = m_pListCtrl->GetListViewPtr();

    /*
     * If the focus is on the list control, make sure that at least one item
     * has the focus rect.  Doing this will wake up any accessibility tools
     * that might be watching (Bug 345402).
     */
    if ((GetFocusedPane() == ePane_Results) &&
        (GetResultView()  == pListView))
    {
        pListView->OnKeyboardFocus (LVIS_FOCUSED, LVIS_FOCUSED);
    }

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnDeferRecalcLayout
 *
 * CAMCView::m_nDeferRecalcLayoutMsg registered message handler for CAMCView.
 *
 * Parameters:
 *     bDoArrange - if non-zero need to call Arrange on list-view so that
 *                  common-control can layout items properly.
 *
 *--------------------------------------------------------------------------*/

LRESULT CAMCView::OnDeferRecalcLayout (WPARAM bDoArrange, LPARAM)
{
    Trace (tagLayout, _T("CAMCView::OnDeferRecalcLayout"));
    RecalcLayout();

    if (bDoArrange && m_pListCtrl)
    {
        int  nViewMode = m_pListCtrl->GetViewMode();

        // Arrange is only for large & small icon modes.
        if ( (nViewMode == MMCLV_VIEWSTYLE_ICON) ||
             (nViewMode == MMCLV_VIEWSTYLE_SMALLICON) )
            m_pListCtrl->Arrange(LVA_DEFAULT);
    }

    return (0);
}

/*+-------------------------------------------------------------------------*
 * CDeferredPageBreak
 *
 *
 * PURPOSE: Used to delay sending a web page break until an idle timeout.
 *          This used to be sent via PostMessage, but resulted in multiple
 *          ScDoPageBreak calls on the same stack, since the latter has
 *          its own message loop. By using the idle timer, we guarantee that
 *          there are no reentrant problems.
 *
 *+-------------------------------------------------------------------------*/
class CDeferredPageBreak : public CIdleTask
{
public:
    CDeferredPageBreak(UINT nAddPageBreakAndNavigateMsg, HWND hWnd, WPARAM wParam, LPCTSTR szURL) :
        m_atomTask (AddAtom (_T("CDeferredPageBreak"))),
        m_nAddPageBreakAndNavigateMsg(nAddPageBreakAndNavigateMsg),
        m_hWnd(hWnd),
        m_wParam(wParam),
        m_strURL(szURL ? szURL : _T(""))
    {
    }

   ~CDeferredPageBreak() {}

    // IIdleTask methods
    SC ScDoWork()
    {
        DECLARE_SC (sc, TEXT("CDeferredPageBreak::ScDoWork"));

        ::SendMessage(m_hWnd, m_nAddPageBreakAndNavigateMsg, m_wParam,
                      reinterpret_cast<LPARAM>( m_strURL.data() )); // do this synchronously
        return sc;
    }

    SC ScGetTaskID(ATOM* pID)
    {
        DECLARE_SC (sc, TEXT("CDeferredPageBreak::ScGetTaskID"));
        sc = ScCheckPointers(pID);
        if(sc)
            return sc;

        *pID = m_atomTask;
        return sc;
    }

    SC ScMerge(CIdleTask* pitMergeFrom) {return S_FALSE /*do not merge*/;}

private:
    const ATOM      m_atomTask;
    const UINT      m_nAddPageBreakAndNavigateMsg;
    const HWND      m_hWnd;
    const WPARAM    m_wParam;
    const tstring   m_strURL;
};

/*+-------------------------------------------------------------------------*
 * CAMCView::ScAddPageBreakAndNavigate
 *
 * Adds a page break to the history list.  This needs to occur asynchronously,
 * so we post a private message to ourselves and return.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScAddPageBreakAndNavigate (bool fAddPageBreak, bool fNavigate, LPCTSTR szURL)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState()); // not sure if we need this, but doesn't hurt to have it in here.

    DECLARE_SC (sc, TEXT("CAMCView::ScAddPageBreakAndNavigate"));

    CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
    sc = ScCheckPointers(pIdleTaskQueue, E_UNEXPECTED);
    if(sc)
        return sc;

    if ( fNavigate && szURL == NULL )
        return sc = E_INVALIDARG;

    /*
     * create the deferred page break task
     */
    CAutoPtr<CDeferredPageBreak> spDeferredPageBreak (new CDeferredPageBreak (m_nAddPageBreakAndNavigateMsg, m_hWnd,
                                                                              MAKEWPARAM(fAddPageBreak, fNavigate),
                                                                              szURL));
    sc = ScCheckPointers(spDeferredPageBreak, E_OUTOFMEMORY);
    if(sc)
        return sc;

    /*
     * put the task in the queue, which will take ownership of it
     */
    sc = pIdleTaskQueue->ScPushTask (spDeferredPageBreak, ePriority_Normal);
    if (sc)
        return sc;

    /*
     * if we get here, the idle task queue owns the idle task, so
     * we can detach it from our smart pointer
     */
    spDeferredPageBreak.Detach();

    /*
     * jiggle the message pump so that it wakes up and checks idle tasks
     */
    PostMessage (WM_NULL);

    return (S_OK);
}


/***************************************************************************\
 *
 * METHOD:  CAMCView::OnAddPageBreakAndNavigate
 *
 * PURPOSE: Puts a page break and/or navigates to a new webapge
 *          This method will be called to perfor 3 kinds of the jobs:
 *          1. Add a pagebreak (used when selection changes from the web page to list view)
 *          2. Add a pagebreak and navigate
 *              (a. when selection changes from web page to another web page)
 *              (b. when selection changes from list view to the webpage
 *                  and it is the first web page in the history)
 *          3. Navigate only. ( when navigating from list view to the webpage -
 *              if pagebreak had to be added when leaving the previos web page)
 *
 * PARAMETERS:
 *    LOWORD(wParam)  - nonzero if page break needs to be added
 *    HIWORD(wParam)  - nonzero if navigation should take place
 *    LPARAM lParam  - not used
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
LRESULT CAMCView::OnAddPageBreakAndNavigate (WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnAddPageBreakAndNavigate"));

    BOOL bAddPageBreak = (BOOL)LOWORD(wParam);
    BOOL bNavigate = (BOOL)HIWORD(wParam);

    // check the pointer we will need here
    CHistoryList* pHistoryList = GetHistoryList();
    sc = ScCheckPointers( pHistoryList, m_pWebViewCtrl, E_UNEXPECTED);
    if (sc)
        return 0;

    if (bAddPageBreak)
    {
        sc = pHistoryList->ScDoPageBreak();
        if (sc)
            return 0;
    }

    if (bNavigate)
    {
        LPCTSTR szURL = reinterpret_cast<LPCTSTR>(lParam);

        sc = ScCheckPointers( szURL );
        if (sc)
            return 0;

        m_pWebViewCtrl->Navigate( szURL, NULL );
    }

    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CViewTemplate
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CViewTemplateList::Persist
 *
 * PURPOSE: Used when loading XML. Persist enough information to create a view
 *          The rest of view peristence is dome by CAMCView
 *
 * PARAMETERS:
 *    CPersistor& persistor - persistor to load from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CViewTemplateList::Persist(CPersistor& persistor)
{
    // the view should be stored instead
    ASSERT (persistor.IsLoading());
    // delegate to the base class
    XMLListCollectionBase::Persist(persistor);
}

/***************************************************************************\
 *
 * METHOD:  CViewTemplateList::OnNewElement
 *
 * PURPOSE: Called by XMLListCollectionBase to request persisting of new element
 *          Each new element is created and persisted in this function.
 *
 * PARAMETERS:
 *    CPersistor& persistor - persisto from which the element should be loaded
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CViewTemplateList::OnNewElement(CPersistor& persistor)
{
    CBookmark bm;
    int       iViewId = -1;
    // load information byte for new view
    CPersistor persistorView(persistor, CAMCView::_GetXMLType());
    persistorView.Persist(bm, XML_NAME_ROOT_NODE);
    persistorView.PersistAttribute(XML_ATTR_VIEW_ID, iViewId);

    // store information to the list
    m_ViewsList.push_back(ViewTempl_Type(iViewId, ViewTemplB_Type(bm, persistorView)));
}

//+-------------------------------------------------------------------
//
//  Member:     ScUpdateStandardbarMMCButtons
//
//  Synopsis:   Appropriately enable/disable std-toolbar buttons
//              that are owned by MMC (not verb buttons that snapins own) like
//              back, forward, export-list, up-one-level, show/hide-scope, help.
//
//  Arguments:  None.
//
//--------------------------------------------------------------------
SC CAMCView::ScUpdateStandardbarMMCButtons()
{
    DECLARE_SC (sc, _T("CAMCView::ScUpdateStandardbarMMCButtons"));

    // Get the standard toolbar and change the states.
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    if (NULL == pStdToolbar)
        return (sc = E_UNEXPECTED);

    CAMCDoc *pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return sc;

    // If view is not customizable then hide the "Show/Hide scope tree" button.
    sc = pStdToolbar->ScEnableScopePaneBtn(IsScopePaneAllowed() && pDoc->AllowViewCustomization());

    if (sc)
        sc.TraceAndClear();

    sc = pStdToolbar->ScEnableContextHelpBtn(true);
    if (sc)
        sc.TraceAndClear();


    sc = pStdToolbar->ScEnableExportList(GetListSize() > 0 /*Enable only if LV has items*/);
    if (sc)
        sc.TraceAndClear();


    // Enable/Disable Up-One Level button.
    BOOL bEnableUpOneLevel = !m_pTreeCtrl->IsRootItemSel();
    sc = pStdToolbar->ScEnableUpOneLevel(bEnableUpOneLevel);
    if (sc)
        sc.TraceAndClear();

    // Now update history related buttons.
    sc = ScCheckPointers(m_pHistoryList, E_UNEXPECTED);
    if (sc)
        return sc;

    m_pHistoryList->MaintainWebBar();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScUpdateMMCMenus
//
//  Synopsis:    Show or Hide MMC menus depending on if they are allowed
//               or not. Should do this only if our view owns the menus
//               that is we are the active view.  (Action/View/Favs)
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScUpdateMMCMenus ()
{
    DECLARE_SC(sc, _T("CAMCView::ScUpdateMMCMenus"));

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    if (this != pMainFrame->GetActiveAMCView())
        return (sc = S_OK); // we are not active view so it is ok.

    // We are active view so tell mainframe to update the menus.
    sc = pMainFrame->ScShowMMCMenus(m_ViewData.IsStandardMenusAllowed());
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCreateToolbarObjects
//
//  Synopsis:    Create the CAMCViewToolbars that manages all toolbar data
//               for this view & CStandardToolbar objects.
//
//  Arguments:   None.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCreateToolbarObjects ()
{
    DECLARE_SC(sc, _T("CAMCView::ScCreateToolbarObjects"));

    CMainFrame *pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    // Create the toolbars for this view.
    CMMCToolBar *pMainToolbar = pMainFrame->GetMainToolbar();
    sc = ScCheckPointers(pMainToolbar, E_OUTOFMEMORY);
    if (sc)
        return sc;

    m_spAMCViewToolbars = std::auto_ptr<CAMCViewToolbars>(new CAMCViewToolbars(pMainToolbar, this));
    sc = ScCheckPointers(m_spAMCViewToolbars.get(), E_FAIL);
    if (sc)
        return sc;

    m_ViewData.SetAMCViewToolbarsMgr(m_spAMCViewToolbars.get() );
    sc = m_spAMCViewToolbars->ScInit();
    if (sc)
        return sc;

    // This CAMCViewToolbars is interested in view activation/de-activation/destruction events.
    AddObserver( (CAMCViewObserver&) (*m_spAMCViewToolbars) );

    // Main toolbar UI is interested in the active CAMCViewToolbars.
    m_spAMCViewToolbars->AddObserver( *static_cast<CAMCViewToolbarsObserver *>(pMainToolbar) );

    // MMC application is interested in the toolbar event, since it needs to inform the script
    CAMCApp *pCAMCApp = AMCGetApp();
    if ( pCAMCApp )
         m_spAMCViewToolbars->AddObserver( *static_cast<CAMCViewToolbarsObserver *>(pCAMCApp) );

    // Create standard toolbar.
    m_spStandardToolbar = std::auto_ptr<CStandardToolbar>(new CStandardToolbar());
    sc = ScCheckPointers(m_spStandardToolbar.get(), E_OUTOFMEMORY);
    if (sc)
        return sc;

    m_ViewData.SetStdVerbButtons(m_spStandardToolbar.get());

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * class CMMCViewFrame
 *
 *
 * PURPOSE: The COM 0bject that exposes the Frame interface off the View object.
 *
 *+-------------------------------------------------------------------------*/
class CMMCViewFrame :
    public CMMCIDispatchImpl<Frame>,
    public CTiedComObject<CAMCView>
{
    typedef CAMCView         CMyTiedObject;
    typedef CMMCViewFrame    ThisClass;

public:
    BEGIN_MMC_COM_MAP(ThisClass)
    END_MMC_COM_MAP()

    //Frame interface
public:
    MMC_METHOD0( Maximize );
    MMC_METHOD0( Minimize );
    MMC_METHOD0( Restore );

    MMC_METHOD1( get_Left, LPINT );
    MMC_METHOD1( put_Left, INT );

    MMC_METHOD1( get_Right, LPINT );
    MMC_METHOD1( put_Right, INT );

    MMC_METHOD1( get_Top, LPINT );
    MMC_METHOD1( put_Top, INT );

    MMC_METHOD1( get_Bottom, LPINT );
    MMC_METHOD1( put_Bottom, INT );
};


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetFrame
 *
 * PURPOSE: Returns a pointer to the COM object that implements the
 *          Frame interface.
 *
 * PARAMETERS:
 *    Frame **ppFrame :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_Frame(Frame **ppFrame)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetFrame") );

    if(!ppFrame)
    {
        sc = E_POINTER;
        return sc;
    }

    // init out parameter
    *ppFrame = NULL;

    // create a CMMCApplicationFrame if not already done so.
    sc = CTiedComObjectCreator<CMMCViewFrame>::ScCreateAndConnect(*this, m_spFrame);
    if(sc)
        return sc;

    if(m_spFrame == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spFrame->AddRef();
    *ppFrame = m_spFrame;

    return sc;
}


/***************************************************************************\
|           Frame interface                                                 |
\***************************************************************************/

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScMaximize
 *
 * PURPOSE: Maximizes frame window of the view
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScMaximize ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScMaximize"));

    CChildFrame *pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    pFrame->ShowWindow(SW_MAXIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScMinimize
 *
 * PURPOSE: Minimizes frame window of the view
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScMinimize ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScMinimize"));

    CChildFrame *pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    pFrame->ShowWindow(SW_MINIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScRestore
 *
 * PURPOSE: Restores frame window of the view
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScRestore ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScRestore"));

    CChildFrame *pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    pFrame->ShowWindow(SW_RESTORE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetFrameCoord
 *
 * PURPOSE: Helper method. Returns specified coordinate of the parent frame
 *
 * PARAMETERS:
 *    LPINT pCoord   - storage for return value
 *    coord_t eCoord - which coordinate to return (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScGetFrameCoord ( LPINT pCoord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetFrameCoord"));

    // get & check frame ptr
    CChildFrame *pFrame = GetParentFrame();
    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    CWnd *pParent = pFrame->GetParent();
        sc = ScCheckPointers (pParent, E_FAIL);
        if (sc)
                return (sc);

    // get coordinates of frame window relative to its parent
    CWindowRect rcFrame (pFrame);
    pParent->ScreenToClient(rcFrame);

    // assign to result
        sc = ScGetRectCoord (rcFrame, pCoord, eCoord);
        if (sc)
                return (sc);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetFrameCoord
 *
 * PURPOSE: Helper method. Sets specified coordinate of the parent frame
 *
 * PARAMETERS:
 *    INT coord      - new value to set
 *    coord_t eCoord - which coordinate to modify (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScSetFrameCoord ( INT coord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetFrameCoord"));

    CChildFrame *pFrame = GetParentFrame();
    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    CWnd *pParent = pFrame->GetParent();
        sc = ScCheckPointers (pParent, E_FAIL);
        if (sc)
                return (sc);

    // get coordinates of frame window relative to its parent
    CWindowRect rcFrame (pFrame);
    pParent->ScreenToClient(rcFrame);

        // change the rectangle's specified coordinate
        sc = ScSetRectCoord (rcFrame, coord, eCoord);
        if (sc)
                return (sc);

    // move the window
    pFrame->MoveWindow (rcFrame);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetRectCoord
 *
 * PURPOSE: Helper method. Returns specified coordinate of the given rectangle
 *
 * PARAMETERS:
 *    const RECT& rect - rectangle to query
 *    LPINT pCoord     - storage for return value
 *    coord_t eCoord   - which coordinate to return (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScGetRectCoord ( const RECT& rect, LPINT pCoord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetRectCoord"));

    // check parameters
    sc = ScCheckPointers(pCoord);
    if (sc)
        return sc;

    // assign to result
    switch (eCoord)
    {
        case LEFT:      *pCoord = rect.left;    break;
        case RIGHT:     *pCoord = rect.right;   break;
        case TOP:       *pCoord = rect.top;     break;
        case BOTTOM:    *pCoord = rect.bottom;  break;

        default:
            *pCoord = 0;
            sc = E_INVALIDARG;
            break;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetRectCoord
 *
 * PURPOSE: Helper method. Sets specified coordinate of the given rectangle
 *
 * PARAMETERS:
 *        RECT& rect     - rectangle to modify
 *    INT coord      - new value to set
 *    coord_t eCoord - which coordinate to modify (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScSetRectCoord ( RECT& rect, INT coord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetRectCoord"));

    // assign coordinate
    switch (eCoord)
    {
        case LEFT:      rect.left   = coord;    break;
        case RIGHT:     rect.right  = coord;    break;
        case TOP:       rect.top    = coord;    break;
        case BOTTOM:    rect.bottom = coord;    break;
        default:        sc = E_INVALIDARG;      break;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Left
 *
 * PURPOSE: Implements Frame.Left property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Left ( LPINT pCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Left"));

    sc = ScGetFrameCoord( pCoord, LEFT );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Left
 *
 * PURPOSE: Implements Frame.Left property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Left ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Left"));

    sc = ScSetFrameCoord( coord, LEFT );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Right
 *
 * PURPOSE: Implements Frame.Right property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Right ( LPINT pCoord)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Right"));

    sc = ScGetFrameCoord( pCoord, RIGHT );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Right
 *
 * PURPOSE: Implements Frame.Right property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Right ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Right"));

    sc = ScSetFrameCoord( coord, RIGHT );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Top
 *
 * PURPOSE: Implements Frame.Top property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Top  ( LPINT pCoord)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Top"));

    sc = ScGetFrameCoord( pCoord, TOP );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Top
 *
 * PURPOSE: Implements Frame.Top property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Top  ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Top"));

    sc = ScSetFrameCoord( coord, TOP );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Bottom
 *
 * PURPOSE: Implements Frame.Bottom property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Bottom ( LPINT pCoord)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Bottom"));


    sc = ScGetFrameCoord( pCoord, BOTTOM );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Bottom
 *
 * PURPOSE: Implements Frame.Bottom property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Bottom ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Bottom"));

    sc = ScSetFrameCoord( coord, BOTTOM );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetViewExtensionFrame
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    INT  top :
 *    INT  left :
 *    INT  bottom :
 *    INT  right :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScSetViewExtensionFrame(bool bShowListView, INT top, INT left, INT bottom, INT right)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetViewExtensionFrame"))


    /*
     * this method is only available while a view extension is active
     */
    if (!m_fViewExtended)
        return sc; // return silently. NOTE: This method will be removed shortly, as will the view extension hosted frame object,
                   // once mmc moves the mmcview behavior into the web host's element factory.


    /*
     * figure out the maximum bounding rectangle for the hosted view,
     * mapped to view extension-relative coordinates
     */
    CRect rectBound;
    CalcMaxHostedFrameRect (rectBound);

#ifdef DBG
    CString strDebugMsg;
    strDebugMsg.Format (_T("CAMCView::ScSetViewExtFrameCoord  bound=(l=%d,t=%d,r=%d,b=%d), new = (l=%d,t=%d,r=%d,b=%d)"),
                        rectBound.left, rectBound.top, rectBound.right, rectBound.bottom,
                        left,           top,           right,           bottom
                        );
#endif

    /*
     * make sure the requested coordinate is withing the permitted area
     */
    if (left < rectBound.left)
        left = rectBound.left;
    if (right > rectBound.right)
        right = rectBound.right;
    if (top < rectBound.top)
        top = rectBound.top;
    if (bottom > rectBound.bottom)
        bottom = rectBound.bottom;


    /*
     * if we get here, the view extension-relative coordinate supplied
     * is within the acceptable range, now we need to convert it to
     * CAMCView-relative coordinates
     */
    CPoint pointTopLeft(left, top);
    CPoint pointBottomRight(right, bottom);

	if ( GetExStyle() & WS_EX_LAYOUTRTL )
	{
		// IE does not change left/right order on the RTL locales
		// thus we need to mirror it's coordinates
		// see windows bug #195094 ntbugs9 11/30/00
		pointTopLeft.x	   = rectBound.left + (rectBound.right - right);
		pointBottomRight.x = rectBound.left + (rectBound.right - left);
	}

    MapHostedFramePtToViewPt (pointTopLeft);
    MapHostedFramePtToViewPt (pointBottomRight);

    /*
     * set the coordinates
     */
    CRect rectViewExtHostedFrame;

    rectViewExtHostedFrame.left   = pointTopLeft.x;
    rectViewExtHostedFrame.right  = pointBottomRight.x;
    rectViewExtHostedFrame.top    = pointTopLeft.y;
    rectViewExtHostedFrame.bottom = pointBottomRight.y;

    // move the window to the correct location
    CWnd* pwndResult = GetPaneView(ePane_Results);

    sc = ScCheckPointers(pwndResult);
    if(sc)
        return sc;

	if (bShowListView)
		pwndResult->ShowWindow(SW_SHOW);

    ::MoveWindow(*pwndResult, rectViewExtHostedFrame.left, rectViewExtHostedFrame.top,
                 rectViewExtHostedFrame.right - rectViewExtHostedFrame.left,
                 rectViewExtHostedFrame.bottom - rectViewExtHostedFrame.top,
                 TRUE /*bRepaint*/);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CalcMaxHostedFrameRect
 *
 * Returns the maximum rectangle that can be occupied by a view extension's
 * hosted frame, normalized around (0,0).
 *--------------------------------------------------------------------------*/

void CAMCView::CalcMaxHostedFrameRect (CRect& rect)
{
    /*
     * start with the result frame rectangle and inset it a little so
     * we'll see the client edge provided by the view extension's web
     * host view
     */
    rect = m_rectResultFrame;
    rect.DeflateRect (m_sizEdge);

    /*
     * now normalize around (0,0)
     */
    rect.OffsetRect (-rect.TopLeft());
}


/*+-------------------------------------------------------------------------*
 * CAMCView::MapViewPtToHostedFramePt
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::MapViewPtToHostedFramePt (CPoint& pt)
{
    PointMapperWorker (pt, true);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::MapHostedFramePtToViewPt
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::MapHostedFramePtToViewPt (CPoint& pt)
{
    PointMapperWorker (pt, false);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::MapHostedFramePtToViewPt
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::PointMapperWorker (CPoint& pt, bool fViewToHostedFrame)
{
    int nMultiplier = (fViewToHostedFrame) ? -1 : 1;

    /*
     * adjust to the origin of the result frame rectangle and for the
     * web host view's client edge
     */
	pt.Offset (nMultiplier * (m_rectResultFrame.left + m_sizEdge.cx),
			   nMultiplier * (m_rectResultFrame.top  + m_sizEdge.cy));
}


/***************************************************************************\
 *
 * METHOD:  CXMLWindowPlacement::Persist
 *
 * PURPOSE: Persists window placement settings
 *
 * PARAMETERS:
 *    CPersistor &persistor
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLWindowPlacement::Persist(CPersistor &persistor)
{
    // create wrapper to persist flag values as strings
    CXMLBitFlags wpFlagsPersistor(m_rData.flags, mappedWPFlags, countof(mappedWPFlags));
    // persist the wrapper
    persistor.PersistAttribute( XML_ATTR_WIN_PLACEMENT_FLAGS, wpFlagsPersistor );

    // persist show command as literal
    // create wrapper to persist enumeration values as strings
    CXMLEnumeration showCmdPersistor(m_rData.showCmd, mappedSWCommands, countof(mappedSWCommands));
    // persist the wrapper
    persistor.PersistAttribute( XML_ATTR_SHOW_COMMAND,    showCmdPersistor );

    persistor.Persist( XMLPoint( XML_NAME_MIN_POSITION,   m_rData.ptMinPosition ) );
    persistor.Persist( XMLPoint( XML_NAME_MAX_POSITION,   m_rData.ptMaxPosition ) );
    persistor.Persist( XMLRect( XML_NAME_NORMAL_POSITION, m_rData.rcNormalPosition ) );
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_Document
 *
 * PURPOSE: implements View.Document property in object model
 *
 * PARAMETERS:
 *    PPDOCUMENT ppDocument [out] document to which the view belongs
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_Document( PPDOCUMENT ppDocument )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Document"));

    // parameter check
    sc = ScCheckPointers(ppDocument);
    if (sc)
        return sc;

    // get the document
    CAMCDoc* pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return sc;

    // construct com object
    sc = pDoc->ScGetMMCDocument(ppDocument);
    if (sc)
        return sc;

    return (sc);
}

/*******************************************************\
|  helper function to avoid too many stack allocations
\*******************************************************/
static tstring W2T_ForLoop(const std::wstring& str)
{
#if defined(_UNICODE)
    return str;
#else
    USES_CONVERSION;
    return W2CA(str.c_str());
#endif
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScAddFolderTabs
 *
 * PURPOSE: Collects view extensions and taskpads and displays them as tabs
 *
 * PARAMETERS:
 *    HNODE hNode                   - selected scope node
 *    const CLSID &guidTabToSelect  - tab to select
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScAddFolderTabs( HNODE hNode, const CLSID& guidTabToSelect )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAddFolderTabs"));

    sc = ScCheckPointers(m_pResultFolderTabView, E_UNEXPECTED);
    if (sc)
        return sc;

    // cleanup urls
    m_ViewExtensionURLs.clear();

    // cleanup view tabs before we do anything else
    m_pResultFolderTabView->DeleteAllItems();

    // get the callback
    INodeCallback* pNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallBack, m_pResultFolderTabView, E_UNEXPECTED);
    if (sc)
        return sc;

    // collect view extensions
    CViewExtCollection      vecExtensions;
    CViewExtInsertIterator  itExtensions(vecExtensions, vecExtensions.begin());

    sc = pNodeCallBack->GetNodeViewExtensions(hNode, itExtensions);
    if (sc)
    {
        sc.TraceAndClear();
        vecExtensions.clear();
        // continue anyway
    }

    // check if there is something to show
    if(vecExtensions.size() == 0) // no tabs to show.
    {
        m_pResultFolderTabView->SetVisible(false);
    }
    else
    {
        bool bAddDefaultTab = true;

        // add extensions
        CViewExtCollection::iterator iterVE;
        for(iterVE = vecExtensions.begin(); iterVE != vecExtensions.end(); ++iterVE)
        {
            tstring strName( W2T_ForLoop(iterVE->strName) );
            m_pResultFolderTabView->AddItem(strName.c_str(), iterVE->viewID);
            m_ViewExtensionURLs[iterVE->viewID] = W2T_ForLoop(iterVE->strURL);
            // do not add the "normal" tab if we have a valid replacement for it
            if (iterVE->bReplacesDefaultView)
                bAddDefaultTab = false;
        }

        // add the default item.
        if (bAddDefaultTab)
        {
            CStr strNormal;
            strNormal.LoadString(GetStringModule(), IDS_NORMAL);
            m_pResultFolderTabView->AddItem(strNormal, GUID_NULL);
        }

        // select required item and show tabs
        int iIndex = m_pResultFolderTabView->SelectItemByClsid(guidTabToSelect);
        if (iIndex < 0)
            TraceError(_T("CAMCView::ScAddFolderTabs - failed to select requested folder"), SC(E_FAIL));

        // no need for cotrol if we only have one tab
        bool bMoreThanOneTab = (m_pResultFolderTabView->GetItemCount() > 1);
        m_pResultFolderTabView->SetVisible(bMoreThanOneTab);
    }

    // lookup view extension URL
    CViewExtensionURLs::iterator itVE = m_ViewExtensionURLs.find(guidTabToSelect);
    LPCTSTR url = (itVE != m_ViewExtensionURLs.end()) ? itVE->second.c_str() : NULL;

    // apply URL
    sc = ScApplyViewExtension(url);
    if (sc)
        sc.TraceAndClear();

    RecalcLayout();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_ControlObject
 *
 * PURPOSE: returns IDispatch of embeded OCX control
 *          implements View.ControlObject property
 *
 * PARAMETERS:
 *    PPDISPATCH ppControl [out] control's interface
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_ControlObject( PPDISPATCH ppControl)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ControlObject"));

    // parameter check
    sc = ScCheckPointers(ppControl);
    if (sc)
        return sc;

    // init out param
    *ppControl = NULL;

    // have a OCX view?
    if ( (! HasOCX()) || (m_pOCXHostView == NULL))
        return sc.FromMMC( MMC_E_NO_OCX_IN_VIEW );

    // get the control's interface
    CComQIPtr<IDispatch> spDispatch = m_pOCXHostView->GetIUnknown();
    if (spDispatch == NULL)
        return sc = E_NOINTERFACE;

    // return the pointer
    *ppControl = spDispatch.Detach();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScTreeViewSelectionActivate
//
//  Synopsis:    Only the list(/Web/OCX) or the tree can be "active" from the point
//               of view of selected items and MMCN_SELECT. This is not
//               the same as the MFC concept of "active view". There are a couple
//               of views that cannot be active in this sense, such as the taskpad
//               and tab views.
//               When the active view (according to this definition) changes, this
//               function is called. Thus, ScTreeViewSelectionActivate and
//               ScListViewSelectionActivate/ScSpecialResultpaneSelectionActivate
//               are always called in pairs when the activation changes, one to handle
//               deactivation, and one to handle activation.
//
//               Consider the following scenario
//               1) The tree view has (MFC/windows style) focus.
//               2) The user clicks on the taskpad view
//                   Result - selection activation does not change from the tree. All verbs
//                   still correspond to the selected tree item.
//               3) The user clicks on the folder view
//                   Result - once again, selection activation does not chang
//               4) The user clicks on one of the result views eg the list
//                   Result - ScTreeViewSelectionActivate(false) and ScListViewSelectionActivate(true)
//                   Thus verbs and the toolbar now correspond to the selected list item(s).
//               5) The user clicks on the taskpad view.
//                   Result - as in step 2, nothing happens
//               6) The user clicks on the result view
//                   Result - because the active view has not changed, nothing happens.
//
//  Arguments:   [bActivate] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScTreeViewSelectionActivate (bool bActivate)
{
    DECLARE_SC(sc, _T("CAMCView::ScTreeViewSelectionActivate"));

    sc = ScCheckPointers(m_pTreeCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // 1. Setup the SELECTINFO
    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));
    selInfo.m_bScope            = TRUE;
    selInfo.m_pView             = NULL;
    selInfo.m_bDueToFocusChange = TRUE;

    if (HasOCX())
    {
        selInfo.m_bResultPaneIsOCX  = true;
        selInfo.m_lCookie           = LVDATA_CUSTOMOCX;
    }
    else if (HasWebBrowser())
    {
        selInfo.m_bResultPaneIsWeb = TRUE;
        selInfo.m_lCookie = LVDATA_CUSTOMWEB;
    }

    HTREEITEM   htiSelected   = m_pTreeCtrl->GetSelectedItem();
    HNODE       hSelectedNode = (htiSelected != NULL) ? m_pTreeCtrl->GetItemNode (htiSelected) : NULL;

    // insure that this is the active view when we have the focus
    ASSERT ( ( (bActivate)  && (GetParentFrame()->GetActiveView () == m_pTreeCtrl) ) ||
             ( (!bActivate) && (GetParentFrame()->GetActiveView () != m_pTreeCtrl) ) );

    if (hSelectedNode != NULL)
    {
        // Send select notification.
        sc = ScNotifySelect ( GetNodeCallback(), hSelectedNode,
                              false /*fMultiSelect*/, bActivate, &selInfo);
        if (sc)
            return sc;
    }
    else if ( (htiSelected == NULL) && (bActivate) )
    {
        m_pTreeCtrl->SelectItem (m_pTreeCtrl->GetRootItem());
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnTreeViewActivated
//
//  Synopsis:    Observer implementation for tree-view activation.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnTreeViewActivated ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnTreeViewActivated"));

    if (m_eCurrentActivePane == eActivePaneScope) // Scope pane is already active so return.
        return sc;

#ifdef DBG
    Trace (tagViewActivation, _T("Deactivate %s in result pane Activate Scope pane\n"),
                              HasListOrListPad() ? _T("ListView") : (HasOCX() ? _T("OCX") : _T("WebBrowser")));
#endif

    if (m_eCurrentActivePane == eActivePaneResult)
    {
        // Send deactivate to result.
        if (HasListOrListPad())
            sc = ScListViewSelectionActivate (false);
        else if (HasOCX() || HasWebBrowser())
            sc = ScSpecialResultpaneSelectionActivate(false);
        else
            return (sc = E_UNEXPECTED);

        if (sc)
            sc.TraceAndClear();
    }

    // Send select to scope.
    m_eCurrentActivePane = eActivePaneScope;
    sc = ScTreeViewSelectionActivate(true);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnListViewActivated
//
//  Synopsis:    Observer implementation for list-view activation.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnListViewActivated ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnListViewActivated"));

    if (m_eCurrentActivePane == eActivePaneResult) // Result pane is already active so return.
        return sc;

#ifdef DBG
    Trace (tagViewActivation, _T("Deactivate Scope pane Activate ListView in Result pane\n"));
#endif

    if (m_eCurrentActivePane == eActivePaneScope)
    {
        // Send deactivate to scope.
        sc = ScTreeViewSelectionActivate(false);
        if (sc)
            sc.TraceAndClear();
    }

    // Send activate to list.
    m_eCurrentActivePane = eActivePaneResult;
    ASSERT(HasListOrListPad());

    sc = ScListViewSelectionActivate (true);
    if (sc)
        sc.TraceAndClear();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnListViewItemUpdated
 *
 * PURPOSE: called when an item is updated. This method fires an event to all COM observers.
 *
 * PARAMETERS:
 *    int  nIndex :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnListViewItemUpdated (int nIndex)
{
    DECLARE_SC(sc, _T("CAMCView::ScOnListViewItemUpdated"));

    // fire event
    sc = ScFireEvent(CAMCViewObserver::ScOnListViewItemUpdated, this, nIndex);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnOCXHostActivated
//
//  Synopsis:    Observer implementation for ocx or web view activation.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnOCXHostActivated ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnOCXHostActivated"));

    if (m_eCurrentActivePane == eActivePaneResult) // Result pane is already active so return.
        return sc;

#ifdef DBG
    Trace (tagViewActivation, _T("Deactivate Scope pane Activate %s in Result pane\n"),
                              HasOCX() ? _T("OCX") : _T("WebBrowser"));
#endif

    if (m_eCurrentActivePane == eActivePaneScope)
    {
        // Send deactivate to scope.
        sc = ScTreeViewSelectionActivate(false);
        if (sc)
            sc.TraceAndClear();
    }

    // Send select to ocx or web view.
    m_eCurrentActivePane = eActivePaneResult;
    ASSERT(HasOCX() || HasWebBrowser());

    sc = ScSpecialResultpaneSelectionActivate(true);
    if (sc)
        sc.TraceAndClear();

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcview.h
//
//--------------------------------------------------------------------------

// AMCView.h : interface of the CAMCView class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __AMCVIEW_H__
#define __AMCVIEW_H__


#ifndef __CONTROLS_H__
#include "controls.h"
#endif

// this is needed for inline CAMCView::GetScopeTreePtr below
#ifndef AMCDOC_H__
#include "amcdoc.h"
#endif

// this is needed for CAMCView::GetParentFrame below
#ifndef CHILDFRM_H
#include "childfrm.h"
#endif

#include "amcpriv.h"
#include "cclvctl.h"
#include "amcnav.h"
#include "conview.h"            // for CConsoleView

#include "treeobsv.h"
#include "stdbar.h"

#define UNINIT_VALUE    -1      // Unitialised value
#define BORDERPADDING   4       // Some multiple that stops the splitter from
                                // being pushed into the right border

#define AMC_LISTCTRL_CLSID  _T("{1B3C1394-D68B-11CF-8C2B-00AA003CA9F6}")


// REVIEW embed this in the class so it's hidden
// NOTE struct added to protected section

// Forward declarations
class CAMCDoc;
class CAMCTreeView;
class CAMCGenericOcxCtrl;
class CAMCWebViewCtrl;
class CAMCView;
class CListViewSub;
class CCCListViewCtrl;
class COCXHostView;
class CHistoryList;
class CChildFrame;
class CViewTracker;
class CBookmark;
class CTaskPadHost;
class CMemento;
class CViewSettings;
class CFolderTabView;
class CMMCToolBar;
class CAMCViewToolbars;
class CStandardToolbar;

struct NMFOLDERTAB;

struct TRACKER_INFO;
struct SViewUpdateInfo;
typedef CList<HMTNODE, HMTNODE> CHMTNODEList;

#ifdef DBG
extern CTraceTag tagSplitterTracking;
#endif


//____________________________________________________________________________
//
//  class:      ViewSettings
//____________________________________________________________________________
//

class ViewSettings
{
public:
    struct ScopeSettings
    {
        int cxWidth;
        int cxMin;
    };
    explicit ViewSettings(CAMCView* v);
    ~ViewSettings()
    {
    }
    int GetViewID() const
    {
        return m_nViewID;
    }
    BOOL IsDescriptionbarVisible() const
    {
        return m_bDescriptionbarVisible;
    }
    int GetViewMode() const
    {
        return m_nViewMode;
    }
    long GetListViewStyle() const
    {
        return m_nListViewStyle;
    }
    const ScopeSettings& GetScopeSettings() const
    {
        return m_Scope;
    }
    BOOL IsScopePaneVisible() const
    {
        return m_bScopePaneVisible;
    }
    void GetDefaultColumnWidths(int w[2])
    {
        w[0] = m_DefaultColumnWidths[0];
        w[1] = m_DefaultColumnWidths[1];
    }
    long GetDefaultLVStyle()
    {
        return m_DefaultLVStyle;
    }
private:
    int m_nViewID;
    BOOL m_bDescriptionbarVisible;
    int m_nViewMode;
    long m_nListViewStyle;
    ScopeSettings m_Scope;
    BOOL m_bScopePaneVisible;
    long m_DefaultLVStyle;
    int m_DefaultColumnWidths[2];
};

/*+-------------------------------------------------------------------------*
 * class CAMCView
 *
 *
 * PURPOSE: The console view UI class
 *
 *+-------------------------------------------------------------------------*/
class CAMCView: public CView, public CConsoleView, public CTiedObject,
                public CXMLObject, public CEventSource<CAMCViewObserver>,
                public CTreeViewObserver, public CListViewActivationObserver,
                public COCXHostActivationObserver, public CAMCDocumentObserver,
                public CListViewObserver
{
    friend class CMainFrame;
    friend void CALLBACK TrackerCallback(TRACKER_INFO* pinfo, bool bAcceptChange, bool fSyncLayout);

    // Object model related
private:
    ViewPtr m_spView;
public:
    // View interface
    //#######################################################################
    //#######################################################################
    //
    //  Item and item collection related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_ActiveScopeNode( PPNODE   ppNode);
    SC      Scput_ActiveScopeNode( PNODE    pNode);
    SC      Scget_Selection(       PPNODES  ppNodes);
    SC      Scget_ListItems(       PPNODES  ppNodes);
    SC      ScSnapinScopeObject( VARIANT& varScopeNode, PPDISPATCH ScopeNodeObject);
    SC      ScSnapinSelectionObject( PPDISPATCH SelectedObject);

    //#######################################################################
    //#######################################################################

    SC      ScIs          (PVIEW pView, VARIANT_BOOL *pbTheSame);
    SC      Scget_Document( PPDOCUMENT ppDocument );

    //#######################################################################
    //#######################################################################
    //
    //  Selection changing methods
    //
    //#######################################################################
    //#######################################################################
    SC      ScSelectAll();
    SC      ScSelect(               PNODE   pNode);
    SC      ScDeselect(             PNODE   pNode);
    SC      ScIsSelected(           PNODE   pNode,  PBOOL pIsSelected);

    //#######################################################################
    //#######################################################################
    //
    //  Verb and selection related methods
    //
    //#######################################################################
    //#######################################################################
    SC      ScDisplayScopeNodePropertySheet(VARIANT& varScopeNode);
    SC      ScDisplaySelectionPropertySheet();
    SC      ScCopyScopeNode(        VARIANT& varScopeNode);
    SC      ScCopySelection();
    SC      ScDeleteScopeNode(      VARIANT& varScopeNode);
    SC      ScDeleteSelection();
    SC      ScRenameScopeNode(      BSTR    bstrNewName, VARIANT& varScopeNode);
    SC      ScRenameSelectedItem(   BSTR    bstrNewName);
    SC      Scget_ScopeNodeContextMenu( VARIANT& varScopeNode, PPCONTEXTMENU ppContextMenu, bool bMatchGivenNode = false);
    SC      Scget_SelectionContextMenu( PPCONTEXTMENU ppContextMenu);
    SC      ScRefreshScopeNode(      VARIANT& varScopeNode);
    SC      ScRefreshSelection();
    SC      ScExecuteSelectionMenuItem(BSTR MenuItemPath);
    SC      ScExecuteScopeNodeMenuItem(BSTR MenuItemPath, VARIANT& varScopeNode  /* = ActiveScopeNode */);
    SC      ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState);

    //#######################################################################
    //#######################################################################
    //
    //  Frame and view related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_Frame( PPFRAME ppFrame);
    SC      ScClose();
    SC      Scget_ScopeTreeVisible( PBOOL pbVisible );
    SC      Scput_ScopeTreeVisible( BOOL bVisible );
    SC      ScBack();
    SC      ScForward();
    SC      Scput_StatusBarText(BSTR StatusBarText);
    SC      Scget_Memento(PBSTR Memento);
    SC      ScViewMemento(BSTR Memento);

    //#######################################################################
    //#######################################################################
    //
    //  List related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_Columns( PPCOLUMNS Columns);
    SC      Scget_CellContents( PNODE Node,  long Column, PBSTR CellContents);
    SC      ScExportList( BSTR bstrFile, ExportListOptions exportoptions /* = ExportListOptions_Default*/);
    SC      Scget_ListViewMode( PLISTVIEWMODE pMode);
    SC      Scput_ListViewMode( ListViewMode mode);

    //#######################################################################
    //#######################################################################
    //
    //  ActiveX control related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_ControlObject( PPDISPATCH Control);

    // helper functions
    SC      ScGetOptionalScopeNodeParameter(VARIANT &varScopeNode, PPNODE ppNode, bool& bMatchedGivenNode);
    SC      ScExecuteMenuItem(PCONTEXTMENU pContextMenu, BSTR MenuItemPath);

    SC      ScGetMMCView(View **ppView);

    // Frame interface
    SC      ScMaximize ();
    SC      ScMinimize ();
    SC      ScRestore ();

    SC      Scget_Left ( LPINT pCoord );
    SC      Scput_Left ( INT coord );

    SC      Scget_Right ( LPINT pCoord);
    SC      Scput_Right ( INT coord );

    SC      Scget_Top  ( LPINT pCoord);
    SC      Scput_Top  ( INT coord );

    SC      Scget_Bottom ( LPINT pCoord);
    SC      Scput_Bottom ( INT coord );

    // Frame interface for the view extension hosted frame
    SC      ScSetViewExtensionFrame(bool bShowListView, INT top, INT left, INT bottom, INT right);

    // Frame int helpers

    enum    coord_t { LEFT, TOP, RIGHT, BOTTOM };
    SC      ScGetFrameCoord        (LPINT pCoord, coord_t eCoord );
    SC      ScSetFrameCoord        (INT coord,    coord_t eCoord );
    SC      ScGetRectCoord         (const RECT& rect, LPINT pCoord, coord_t eCoord );
    SC      ScSetRectCoord         (RECT& rect,       INT coord,    coord_t eCoord );

    // Node locating helpers (used from view control)
    SC      ScFindResultItemForScopeNode( PNODE pNode, HRESULTITEM &itm );
    SC      ScGetScopeNode( HNODE hNode,  PPNODE ppNode );

    SC      ScNotifySelect (INodeCallback* pCallback, HNODE hNode, bool fMultiSelect,
                            bool fSelect, SELECTIONINFO* pSelInfo);

protected: // create from serialization only
    CAMCView();
    DECLARE_DYNCREATE(CAMCView);

// Helper methods.
private:
    enum EListSaveErrorType  {LSaveReadOnly, LSaveCantCreate, LSaveCantWrite};
    bool Write2File(HANDLE hfile, TCHAR const * strwrite, int type);
    void ListSaveErrorMes(EListSaveErrorType etype, HANDLE hfile = NULL, LPCTSTR lpFileName = NULL);
    SC   ScExportListWorker();
    SC   ScGetExportListFile (CString& strFileName, bool& bUnicode,
                              bool& bTabDelimited, bool& bSelectedRowsOnly);
    SC   ScCreateExportListFile(const CString& strFileName, bool bUnicode,
                                bool bShowErrorDialogs, HANDLE& hFile);
    SC   ScWriteExportListData (const CString& strFileName, bool bUnicode,
                                bool bTabDelimited, bool bSelectedRowsOnly,
                                bool bShowErrorDialogs = true);

    SC ScUpdateStandardbarMMCButtons();
    void SetScopePaneVisible(bool bVisible);


   // tree observer methods
    virtual SC ScOnItemDeselected(HNODE hNode);
    virtual SC ScOnTreeViewActivated ();

    // ListViewActivationObserver methods.
    virtual SC ScOnListViewActivated ();
    virtual SC ScOnListViewItemUpdated (int nIndex); // called when an item is updated

    // OCX or Web HostActivationObserver mthods.
    virtual SC ScOnOCXHostActivated ();

    // AMCDoc observer
    virtual SC  ScDocumentLoadCompleted (CAMCDoc *pDoc);

// Persistence related methods.
public:
    DEFINE_XML_TYPE(XML_TAG_VIEW);
    virtual void Persist(CPersistor& persistor);

    // Loads all of the local data previously saved by Save().  Restores
    // the window to the original state.
    // Returns true if the data and window state is successfully restored.
    bool Load(IStream& stream);

    bool IsDirty();
    void SetDirty (bool bDirty = true)
    {
        m_bDirty = bDirty;
//      m_pDocument->SetModifiedFlag (bDirty);
    }

// Information set and get methods
public:
    // Enum types for args
    // NOTE: Enum values are relevant!
    enum EUIStyleType   {uiClientEdge,uiNoClientEdge};

    CAMCDoc* GetDocument();
    CHistoryList* GetHistoryList() { return m_pHistoryList; }

    void GetPaneInfo(ViewPane ePane, int* pcxCur,int* pcxMin);
    void SetPaneInfo(ViewPane ePane, int cxCur, int cxMin);

    CView* GetPaneView(ViewPane ePane);

    // what's in the view?
    bool HasList            () const        { return m_ViewData.HasList();            }
    bool HasOCX             () const        { return m_ViewData.HasOCX();             }
    bool HasWebBrowser      () const        { return m_ViewData.HasWebBrowser();      }
    bool HasListPad         () const;
    bool HasListOrListPad   () const;

    DWORD GetListOptions() const            { return m_ViewData.GetListOptions();}
    DWORD GetHTMLOptions() const            { return m_ViewData.GetHTMLOptions();}
    DWORD GetOCXOptions()  const            { return m_ViewData.GetOCXOptions();}
    DWORD GetMiscOptions() const            { return m_ViewData.GetMiscOptions();}

    CDescriptionCtrl& GetRightDescCtrl(void) { return m_RightDescCtrl; }

    BOOL IsVerbEnabled(MMC_CONSOLE_VERB verb);

    void GetDefaultColumnWidths(int columnWidth[2]);
    void SetDefaultColumnWidths(int columnWidth[2], BOOL fUpdate = TRUE);

    CStandardToolbar* GetStdToolbar() const;

    INodeCallback*  GetNodeCallback();    // returns a reference to view's callback interface
    IScopeTreeIter* GetScopeIterator();   // returns a reference to view's scope tree interator
    IScopeTree*     GetScopeTree();       // returns a reference to scope tree

    friend ViewSettings;
    void            GetTaskpadID(GUID &guidID);
    ViewSettings* GetViewSettings()
    {
        ViewSettings* pVS = new ViewSettings(this);
        ASSERT(pVS != NULL);
        return pVS;
    }

    CAMCTreeView* GetTreeCtrl() { return m_pTreeCtrl; }
    void SetUsingDefColumns(bool bDefColumns) { m_bDefColumns = bDefColumns; }
    bool UsingDefColumns() { return m_bDefColumns; }

    bool IsScopePaneVisible(void) const;

    UINT GetViewID(void);
    void SetViewID(UINT id) { m_nViewID = m_ViewData.m_nViewID = id; }

    SViewData* GetViewData() { return &m_ViewData; }
    bool IsVirtualList()  { return (m_ViewData.IsVirtualList()); }

    bool AreStdToolbarsAllowed() const
    {
        return !(m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOTOOLBARS);
    }
    bool IsScopePaneAllowed() const
    {
        return !(m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOSCOPEPANE);
    }

    bool HasCustomTitle() const
    {
        return (m_ViewData.m_lWindowOptions & MMC_NW_OPTION_CUSTOMTITLE);
    }
    bool IsPersisted() const
    {
        return (!(m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOPERSIST) &&
                !m_fRootedAtNonPersistedDynamicNode);
    }

    bool IsAuthorModeView() const
    {
        return m_bAuthorModeView;
    }

    void SetAuthorModeView(bool fAuthorMode)
    {
        m_bAuthorModeView = fAuthorMode;
    }

    static CAMCView* CAMCView::GetActiveView();
        // Returns the most recently activated CAMCView.

    bool IsTracking() const;

    long GetDefaultListViewStyle() const;
    void SetDefaultListViewStyle(long style);

    int GetViewMode() const;

private:
    BOOL IsSelectingNode() { return (m_nSelectNestLevel > 0); }

    SC   ScSpecialResultpaneSelectionActivate(bool bActivate);
    SC   ScTreeViewSelectionActivate(bool bActivate);
    SC   ScListViewSelectionActivate(bool bActivate);

    bool CanInsertScopeItemInResultPane();

// Operations
public:
    SC  ScUpdateWindowTitle();
    SC  ScActivate();
    SC  ScOnMinimize(bool fMinimized);
    SC  ScOnSize(UINT nType, int cx, int cy);

    SC  ScApplyViewExtension (LPCTSTR pszURL);


    // Scope Pane : Tree View.
    UINT GetTreeItem(CHMTNODEList* pNodeList, HTREEITEM* phItem);
    HTREEITEM FindChildNode(HTREEITEM hti, DWORD dwItemDataKey);
    HTREEITEM FindHTreeItem(HMTNODE hMTNode, HTREEITEM htiFirst);
    BOOL QueryForReName(TV_DISPINFO* ptvdi, LRESULT* pResult);
    void SetRootNode(HMTNODE hMTNode);
    HNODE GetRootNode(void);
    HRESULT GetNodePath(HTREEITEM hti, HTREEITEM htiRoot, CBookmark* pbm);
    HRESULT GetRootNodePath(CBookmark* pbm);
    HRESULT GetSelectedNodePath(CBookmark* pbm);
    void SelectNode(MTNODEID ID, GUID &guidTaskpad);

    // Result Pane.
    SC   ScInitDefListView(LPUNKNOWN pUnkResultsPane);
    SC   ScAddDefaultColumns();
    SC   ScOnSelectNode(HNODE hNode, BOOL &bAddSubFolders);
    SC   ScSetResultPane(HNODE hNode, CResultViewType rvt, int viewMode, bool bUsingHistory);


    SC   ScGetProperty(int iIndex, BSTR bstrPropertyName, PBSTR pbstrPropertyValue);
    SC   ScGetNodetype(int iIndex, PBSTR Nodetype);

    LPUNKNOWN GetPaneUnknown(ViewPane ePane);
    void OpenResultItem(HNODE hNode);
    BOOL OnListCtrlItemDblClk(void);
    BOOL DispatchListCtrlNotificationMsg(LPARAM lParam, LRESULT* pResult);
    BOOL CreateListCtrl(int nID, CCreateContext* pContext);
    void SetListViewOptions(DWORD dwListOptions);
    SC   ScAttachListViewAsResultPane();
    SC   ScAttachWebViewAsResultPane();
    SC   ScAttachOCXAsResultPane(HNODE hNode);
    void ShowResultPane(CView * pWnd, EUIStyleType nStyle);
    long GetListViewStyle();
    CView* GetResultView () const;
    void SetListViewMultiSelect(BOOL bMultiSelect);
    bool CanDoDragDrop();
    void DeSelectResultPane(HNODE hNodeSel);
    HRESULT NotifyListPad (BOOL b);

    // General (both) view related.
    LPCTSTR GetWindowTitle(void);
    BOOL RenameItem(HNODE hNode, BOOL bScopeItem, MMC_COOKIE lResultItemCookie, LPWSTR pszText, LRESULT* pResult);
    void CloseView();
    void DeleteView();

    // REVIEW int's are not enum!
    void SetPane(ViewPane ePane, CView* pView, EUIStyleType nStyle=uiClientEdge);

    bool DeflectActivation (BOOL fActivate, CView* pDeactivatingView);
    void SetChildFrameWnd(HWND m_hChildFrameWnd);
    void SetPaneFocus();
    void SetPaneWithFocus(UINT pane);

    SC   ScDeferSettingFocusToResultPane();
    SC   ScSetFocusToResultPane();

    // Other helpers.
    void OnActionMenu(CPoint pt, LPCRECT prcExclude);
    void OnViewMenu(CPoint pt, LPCRECT prcExclude);
    void OnFavoritesMenu(CPoint point, LPCRECT prcExclude);
    void UpdateSnapInHelpMenus(CMenu* pMenu);
    void OnRefresh();
    void OnUpdatePasteBtn();

    SC ScShowScopePane (bool fShow, bool fForce = false);
    SC ScConsoleVerb (int nVerb);
    SC ScProcessConsoleVerb (HNODE hNode, bool bScope, LPARAM lResultCookie, int nVerb);

    SC ScUpOneLevel                 ();
    SC ScWebCommand                 (WebCommand eCommand);
    SC ScAddPageBreakAndNavigate    (bool fAddPageBreak, bool fNavigate, LPCTSTR szURL);

    void OnDeleteEmptyView();

    SC   ScUpdateMMCMenus();

    // Columns helpers
    SC   ScColumnInfoListChanged(const CColumnInfoList& colInfoList);
    SC   ScGetPersistedColumnInfoList(CColumnInfoList *pColInfoList);
    SC   ScDeletePersistedColumnData();

    /*
     * Message Handlers.
     */

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCView)
public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnInitialUpdate();
protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL
    virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );


// Generated message map functions
protected:
    //{{AFX_MSG(CAMCView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint pt);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnDestroy();
    afx_msg void OnUpdateFileSnapinmanager(CCmdUI* pCmdUI);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg void OnContextHelp();
    afx_msg void OnSnapInHelp();
    afx_msg void OnSnapinAbout();
    afx_msg void OnHelpTopics();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnPaletteChanged(CWnd* pwndFocus);
    afx_msg BOOL OnQueryNewPalette( );
    afx_msg void OnSysColorChange();
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG

    // keep these outside the AFX_MSG markers so ClassWizard won't munge them
    afx_msg void OnUpdateNextPane(CCmdUI* pCmdUI);
    afx_msg void OnUpdatePrevPane(CCmdUI* pCmdUI);
    afx_msg void OnUpdateShiftF10(CCmdUI* pCmdUI);
    afx_msg void OnVerbAccelKey(UINT nID);
    afx_msg void OnShiftF10();

    afx_msg void OnAmcNodeNew(UINT nID);
    afx_msg void OnAmcNodeNewUpdate(CCmdUI* pCmdUI);
    afx_msg void OnDrawClipboard();
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LRESULT OnProcessMultiSelectionChanges(WPARAM, LPARAM);
    afx_msg LRESULT OnJiggleListViewFocus (WPARAM, LPARAM);
    afx_msg LRESULT OnDeferRecalcLayout (WPARAM, LPARAM);
    afx_msg LRESULT OnConnectToCIC (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnConnectToTPLV(WPARAM wParam, LPARAM lParam)   {return ScOnConnectToTPLV(wParam, lParam).ToHr();}
    SC              ScOnConnectToTPLV(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnShowWebContextMenu (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetDescriptionBarText (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddPageBreakAndNavigate(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetIconInfoForSelectedNode(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAppCommand(WPARAM wParam, LPARAM lParam);

    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);

    // result based tabs.
    afx_msg void    OnChangedResultTab(NMHDR *nmhdr, LRESULT *pRes);

public:
    DECLARE_MESSAGE_MAP()

// Implementation
public:
    virtual ~CAMCView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    int                     m_nSelectNestLevel;
    UINT                    m_nViewID;
    HMTNODE                 m_hMTNode;              // root node for this view
    IScopeTreeIterPtr       m_spScopeTreeIter;      // view's iterator to scope tree
    INodeCallbackPtr        m_spNodeCallback;       // view's callback interface
    bool                    m_bAuthorModeView;      // Saved in author mode (user can't close)

    bool                    m_bDefColumns;
    long                    m_DefaultLVStyle;
    int                     m_columnWidth[2];


    // Last selection
    bool                    m_bLastSelWasMultiSel;

    enum eCurrentActivePane
    {
        eActivePaneNone,   // No pane is active.
        eActivePaneScope,
        eActivePaneResult,
    };

    eCurrentActivePane      m_eCurrentActivePane; // Tells if scope or result was the active pane.

    // Check for sel-change data
    bool                    m_bProcessMultiSelectionChanges;

    CDescriptionCtrl     m_RightDescCtrl; // control bar embedded members

    IScopeTree* GetScopeTreePtr();
        // The document may release the scope tree without notifying the view.
        // The view should always go through this function to obtain a pointer
        // to the the scope tree.

private:
    HNODE m_ListPadNode;
    int  m_iFocusedLV;
    bool m_bLVItemSelected;
    int  m_nReleaseViews;


// Attributes
protected:

    //---------------------------------------------------------------------
    // NOTE: ePane_Tasks is defined to have a pane identifier for the
    // task view pane. Currently no task view information is stored
    // in the pane info array, so the use of ePane_Tasks as an index is
    // of limited value.
    //----------------------------------------------------------------------

    // Pane information implementation structure
    struct PaneInfo
    {
        CView*  pView;          // Pointer to the view
        int     cx;             // 0 means hidden
        int     cxIdeal;        // user set size or size before hidden
        int     cxMin;          // below that try not to show
    };


    // child window IDs
    enum
    {
        /*
         * Bug 344422: these IDs should be maintained for compatibility
         * with automated tests
         */
        IDC_TreeView       = 12785,
        IDC_ListView       = 12786,
        IDC_GenericOCXCtrl = 12787,
        IDC_WebViewCtrl    = 12788,

        IDC_OCXHostView,
        IDC_TaskView,
        IDC_RightDescBar,
        IDC_TaskpadTitle,
        IDC_ListCaption,
        IDC_ResultTabCtrl,
        IDC_ViewExtensionView,
    };


    // Pointers to actual controls
    CAMCTreeView *          m_pTreeCtrl;            // Tree control
    CCCListViewCtrl *       m_pListCtrl;            // Default list control
    CAMCWebViewCtrl *       m_pWebViewCtrl;         // Private web view control
    CAMCWebViewCtrl *       m_pViewExtensionCtrl;   // Private web view control for view extensions
    COCXHostView *          m_pOCXHostView;         // host for OCX's
    CFolderTabView *        m_pResultFolderTabView;

    // current state information
    PaneInfo        m_PaneInfo[ePane_Count];       // Array of panes
    int             m_nViewMode;                   // current listview mode for all node that use listviews in this view
    bool            m_bRenameListPadItem;

protected:
    CChildFrame* GetParentFrame() const;

    void SetDescBarVisible(bool b)
        { m_ViewData.SetDescBarVisible (b); }

    bool IsDescBarVisible(void) const
        { return m_ViewData.IsDescBarVisible(); }

    void SetStatusBarVisible(bool bVisible)
    {
        if (bVisible)
            m_ViewData.m_dwToolbarsDisplayed |=  STATUS_BAR;
        else
            m_ViewData.m_dwToolbarsDisplayed &= ~STATUS_BAR;
    }

    bool IsStatusBarVisible(void) const
        { return ((m_ViewData.m_dwToolbarsDisplayed & STATUS_BAR) != 0); }

    void SetTaskpadTabsAllowed(bool b)
        { m_ViewData.SetTaskpadTabsAllowed(b); }

    bool AreTaskpadTabsAllowed(void) const
        { return m_ViewData.AreTaskpadTabsAllowed(); }

    // implementation attributes which control layout of the splitter
    static const CSize  m_sizEdge;             // 3-D edge
    static const int    m_cxSplitter;          // amount of space between panes

    // splitter bar and hit test enums
    enum ESplitType     {splitBox, splitBar, splitIntersection, splitBorder};
    enum HitTestValue {hitNo, hitSplitterBox, hitSplitterBar};

    bool m_bDirty;
    HTREEITEM m_htiStartingSelectedNode;

    bool m_fRootedAtNonPersistedDynamicNode;
    bool m_fSnapinDisplayedHelp;
    bool m_fActivatingSpecialResultPane;
    bool m_fViewExtended;

    HTREEITEM m_htiCut;

// implementation routines
public:
    void AdjustTracker (int cx, int cy);

    void SaveStartingSelectedNode();
    bool HasNodeSelChanged();

    // layout methods
    void DeferRecalcLayout(bool fUseIdleTaskQueue = true, bool bArrangeIcons = false);
    void RecalcLayout(void);
    void LayoutResultFolderTabView  (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutScopePane            (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutResultPane           (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutResultDescriptionBar (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutResultView           (CDeferWindowPos& dwp, const CRect& rectRemaining);

public:
    // CConsoleView methods
    virtual SC ScCut                        (HTREEITEM htiCut);
    virtual SC ScPaste                      ();
    virtual SC ScToggleStatusBar            ();
    virtual SC ScToggleDescriptionBar       ();
    virtual SC ScToggleScopePane            ();
    virtual SC ScToggleTaskpadTabs          ();
    virtual SC ScContextHelp                ();
    virtual SC ScHelpTopics                 ();
    virtual SC ScShowSnapinHelpTopic        (LPCTSTR pszTopic);
    virtual SC ScSaveList                   ();
    virtual SC ScGetFocusedItem             (HNODE& hNode, LPARAM& lCookie, bool& fScope);
    virtual SC ScSetFocusToPane             (ViewPane ePane);
    virtual SC ScSelectNode                 (MTNODEID id, bool bSelectExactNode = false); // Select the given node.
    virtual SC ScExpandNode                 (MTNODEID id, bool fExpand, bool fExpandVisually);
    virtual SC ScShowWebContextMenu         ();
    virtual SC ScSetDescriptionBarText      (LPCTSTR pszDescriptionText);
    virtual SC ScViewMemento                (CMemento* pMemento);
    virtual SC ScChangeViewMode             (int nNewMode);
    virtual SC ScJiggleListViewFocus        ();
    virtual SC ScRenameListPadItem          ();
    virtual SC ScOrganizeFavorites          (); // bring up the "Organize Favorites" dialog.
    virtual SC ScLineUpIcons                (); // line up the icons in the list
    virtual SC ScAutoArrangeIcons           (); // auto arrange the icons in the list
    virtual SC ScOnRefresh                  (HNODE hNode, bool bScope, LPARAM lResultItemParam); // refreshes the view
    virtual SC ScOnRename                   (CContextMenuInfo *pContextInfo); // allows the user to rename the specified item
    virtual SC ScRenameScopeNode            (HMTNODE hMTNode); // put the specified scope node into rename mode.
    virtual SC ScGetStatusBar               (CConsoleStatusBar **ppStatusBar);
    virtual SC ScAddViewExtension           (const CViewExtensionData& ved);


    virtual ViewPane GetFocusedPane         ();
    virtual int      GetListSize            ();
    virtual HNODE    GetSelectedNode        ();
    virtual HWND     CreateFavoriteObserver (HWND hwndParent, int nID);

private:
    /*
     * CDeferredLayout - deferred layout object
     */
    class CDeferredLayout : public CIdleTask
    {
    public:
        CDeferredLayout(CAMCView* pAMCView);
       ~CDeferredLayout();

        // IIdleTask methods
        SC ScDoWork();
        SC ScGetTaskID(ATOM* pID);
        SC ScMerge(CIdleTask* pitMergeFrom);

        bool Attach (CAMCView* pwndAMCView);

    private:
        typedef std::set<HWND>  WindowCollection;

        WindowCollection    m_WindowsToLayout;
        const ATOM          m_atomTask;
    };

protected:
    // Tracking and and hit testing methods
    int HitTestPane(CPoint& pointTreeCtrlCoord);

    void OnTreeContextMenu(CPoint& point, CPoint& pointTreeCtrlCoord, HTREEITEM htiRClicked);
    void OnListContextMenu(CPoint& point);
    void OnContextMenuForTreeItem(int iIndex, HNODE hNode, CPoint& point,
                          DATA_OBJECT_TYPES type_of_pane = CCT_SCOPE,
                          HTREEITEM htiRClicked = NULL,
                          MMC_CONTEXT_MENU_TYPES eMenuType = MMC_CONTEXT_MENU_DEFAULT,
                          LPCRECT prcExclude = NULL,
                          bool bAllowDefaultItem = true);
    void OnContextMenuForListItem(int iIndex, HRESULTITEM hHitTestItem,
                                  CPoint& point,
                                  MMC_CONTEXT_MENU_TYPES eMenuType = MMC_CONTEXT_MENU_DEFAULT,
                                  LPCRECT prcExclude = NULL,
                                  bool bAllowDefaultItem = true);

// Internal functions and data
private:
    UINT ClipPath(CHMTNODEList* pNodeList, POSITION& rpos, HNODE hNode);
    SC   ScInitializeMemento(CMemento &memento);
    void OnAddToFavorites();
    void OnAdd(SViewUpdateInfo *pvui);
    void OnUpdateSelectionForDelete(SViewUpdateInfo* pvui);
    void OnDelete(SViewUpdateInfo *pvui);
    void OnModify(SViewUpdateInfo *pvui);
    void OnUpdateTaskpadNavigation(SViewUpdateInfo *pvui);
    void ChangePane(AMCNavDir eDir);
    int _GetLVItemData(LPARAM *lParam, UINT flags);
    int _GetLVSelectedItemData(LPARAM *lParam);
    int _GetLVFocusedItemData(LPARAM *lParam);
    HRESULT SendGenericNotify(NCLBK_NOTIFY_TYPE nclbk);
    void IdentifyRootNode();

    void CalcMaxHostedFrameRect (CRect& rect);
    void MapViewPtToHostedFramePt (CPoint& pt);
    void MapHostedFramePtToViewPt (CPoint& pt);
    void PointMapperWorker (CPoint& pt, bool fViewToHostedFrame);

    SC   ScOnLeftOrRightMouseClickInListView();
    bool OnListItemChanged  (NM_LISTVIEW* pnmlv);
    int  OnVirtualListItemsStateChanged(LPNMLVODSTATECHANGE lpStateChange );
    SC   ScPostMultiSelectionChangesMessage();

    SC ScCompleteInitialization();


    HMTNODE GetHMTNode(HTREEITEM hti);
    BOOL OwnsResultList(HTREEITEM hti);

    void OnContextMenuForTreeBackground(CPoint& point, LPCRECT prcExclude = NULL, bool bAllowDefaultItem = true);
    void ArrangeIcon(long style);

    void PrivateChangeListViewMode(int nMode);
    BOOL CommonListViewUpdate()
    {
        if (!HasList())
            return FALSE;

        if (m_pListCtrl == NULL)
        {
            TRACE(_T("View is supposed to be a listview but the member is NULL!"));
            ASSERT(FALSE);
            return FALSE;
        }
        return TRUE;
    }

    //LRESULT OnLVDeleteKeyPressed(WPARAM wParam, LPARAM lParam);
    LRESULT HandleLVMessage(UINT message, WPARAM wParam, LPARAM lParam);
    BOOL OnSharedKeyDown(WORD mVKey);


    CView* CreateView (CCreateContext* pContext, int nID, DWORD dwStyle);
    bool CreateView (int nID);
    bool CreateFolderCtrls();
    SC   ScCreateToolbarObjects ();

    typedef std::vector<TREEITEMID> TIDVector;
    void AddFavItemsToCMenu(CMenu& menu, CFavorites* pFavs, TREEITEMID tid, TIDVector& vItemIDs);
    SC   ScHelpWorker (LPCTSTR pszHelpTopic);

    SC   ScGetSelectedLVItem(LPARAM& lvData);
    SC   ScGetHNodeFromPNode(const PNODE& pNode, HNODE& hNode);

    SC   ScExecuteScopeItemVerb (MMC_CONSOLE_VERB verb, VARIANT& varScopeNode, BSTR bstrNewName);
    SC   ScExecuteResultItemVerb(MMC_CONSOLE_VERB verb, BSTR bstrNewName);

    SC   ScAddFolderTabs( HNODE hNode , const CLSID& tabToSelect );

    SC   ScCreateTaskpadHost(); // for snapin taskpads

private:
    CString         m_strWindowTitle;
    SViewData       m_ViewData;
    CRect           m_rectResultFrame;
    CRect           m_rectVSplitter;

    CHistoryList*   m_pHistoryList;
    CViewTracker*   m_pTracker;

    ITaskPadHostPtr m_spTaskPadHost;
    FramePtr        m_spFrame;
    FramePtr        m_spViewExtFrame; // a frame pointer for the internal view extension hosted frame containing the primary snapin's view.

    // Toolbars related to this view.
    std::auto_ptr<CAMCViewToolbars>   m_spAMCViewToolbars;
    std::auto_ptr<CStandardToolbar>   m_spStandardToolbar;

    // map with view extension URL addresses
    typedef std::map<GUID, tstring> CViewExtensionURLs;
    CViewExtensionURLs m_ViewExtensionURLs;

private:
    /*
     * private, registered window messages
     */
    static const UINT m_nShowWebContextMenuMsg;
    static const UINT m_nProcessMultiSelectionChangesMsg;
    static const UINT m_nAddPageBreakAndNavigateMsg;
    static const UINT m_nJiggleListViewFocusMsg;
    static const UINT m_nDeferRecalcLayoutMsg;
};

#ifndef _DEBUG  // debug version in AMCView.cpp
inline CAMCDoc* CAMCView::GetDocument()
{
    return (CAMCDoc*)m_pDocument;
}
#endif


CAMCView* GetAMCView (CWnd* pwnd);

/*+-------------------------------------------------------------------------*
 * class CViewTemplateList
 *
 *
 * PURPOSE: Used as the helper to persist CAMCView objects, when loading
 *          Since CAMCView need small ammount of data to be known prior to
 *          creating it (and thus prior to persisting CAMCView),
 *          we persist a CViewTemplateList to collect all data.
 *          Afterwards we create views using that list and persist them
 *
 *+-------------------------------------------------------------------------*/
class CViewTemplateList : public XMLListCollectionBase
{
public:
    // defines data to be stored as std::pair objects
    typedef std::pair< CBookmark, CPersistor > ViewTemplB_Type;
    typedef std::pair< int /*nViewID*/, ViewTemplB_Type > ViewTempl_Type;
    // defines collection to be used for storing data about views
    typedef std::vector< ViewTempl_Type > List_Type;

    // creator must provide a XML type
    CViewTemplateList(LPCTSTR strXmlType) : m_strXmlType(strXmlType) {}

    // accessory to get the list of gathered data
    inline List_Type& GetList()  { return m_ViewsList; }

    // Pesistence staff used from CPersistor
    virtual void Persist(CPersistor& persistor);
    virtual void OnNewElement(CPersistor& persistor);
    virtual LPCTSTR GetXMLType() { return m_strXmlType; }
private:
    List_Type   m_ViewsList;
    LPCTSTR     m_strXmlType;
};

/*+-------------------------------------------------------------------------*
 * class CXMLWindowPlacement
 *
 *
 * PURPOSE: class persists WINDOWPLACEMENT to xml
 *
 *+-------------------------------------------------------------------------*/
class CXMLWindowPlacement : public CXMLObject
{
    WINDOWPLACEMENT& m_rData;
public:
    CXMLWindowPlacement(WINDOWPLACEMENT& rData) : m_rData(rData) {}
protected:
    DEFINE_XML_TYPE(XML_TAG_WINDOW_PLACEMENT);
    virtual void    Persist(CPersistor &persistor);
};

#include "amcview.inl"

#endif // __AMCVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcview.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      amcview.inl
 *
 *  Contents:  Inline functions for CAMCView class.
 *
 *  History:   29-Oct-99 AnandhaG     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef AMCVIEW_INL
#define AMCVIEW_INL
#pragma once

//+-------------------------------------------------------------------
//
//  Member:      SetScopePaneVisible
//
//  Synopsis:    Sets the flag in the view data that indicates whether
//               the scope pane is visible or not.  The window is
//               physically shown by ScShowScopePane.
//
//  Arguments:   [bVisible]        -
//
//  Returns:     None
//
//--------------------------------------------------------------------
inline void CAMCView::SetScopePaneVisible(bool bVisible)
{
    /*
     * we should only be marking the scope pane visible if it is
     * allowed on this view
     */
    ASSERT (!bVisible || IsScopePaneAllowed());
    m_ViewData.SetScopePaneVisible (bVisible);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::IsScopePaneVisible
 *
 * Returns true if the scope pane is visible in this view, false otherwise
 *--------------------------------------------------------------------------*/

inline bool CAMCView::IsScopePaneVisible(void) const
{
    bool fVisible = m_ViewData.IsScopePaneVisible();

    /*
     * the scope pane should only be visible if it is
     * permitted on this view
     */
    ASSERT (IsScopePaneAllowed() || !fVisible);

    return (fVisible);
}


//+-------------------------------------------------------------------
//
//  Member:      SetRootNode
//
//  Synopsis:    Set the root node.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::SetRootNode(HMTNODE hMTNode)
{
    ASSERT(hMTNode != 0);
    ASSERT(m_hMTNode == 0);
    m_hMTNode = hMTNode;

}

//+-------------------------------------------------------------------
//
//  Member:      GetNodeCallback
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline INodeCallback*  CAMCView::GetNodeCallback()
{
    return m_spNodeCallback;
}

//+-------------------------------------------------------------------
//
//  Member:      GetScopeIterator
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline IScopeTreeIter* CAMCView::GetScopeIterator()
{
    return m_spScopeTreeIter;
}

//+-------------------------------------------------------------------
//
//  Member:      DeleteView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::DeleteView()
{
    GetParentFrame()->PostMessage(WM_SYSCOMMAND, SC_CLOSE, 0);
}

//+-------------------------------------------------------------------
//
//  Member:      GetScopeTreePtr
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Note:       The document may release the scope tree without
//              notifying the view. The view should always go
//              through this function to obtain a pointer to the
//              the scope tree.
//
//--------------------------------------------------------------------
inline IScopeTree* CAMCView::GetScopeTreePtr()
{
    CAMCDoc* const pDoc = GetDocument();
    ASSERT(pDoc);
    if (!pDoc)
        return NULL;
    IScopeTree* const pScopeTree = pDoc->GetScopeTree();
    return pScopeTree;
}

//+-------------------------------------------------------------------
//
//  Member:      GetScopeTree
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline IScopeTree* CAMCView::GetScopeTree()
{
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    return pScopeTree;
}

//+-------------------------------------------------------------------
//
//  Member:      SetChildFrameWnd
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::SetChildFrameWnd(HWND hwndChildFrame)
{
    if (hwndChildFrame == NULL || !::IsWindow(hwndChildFrame))
    {
        ASSERT(FALSE); // Invalid Arguments
        return;
    }

    m_ViewData.m_hwndChildFrame = hwndChildFrame;
}

//+-------------------------------------------------------------------
//
//  Member:      GetParentFrame
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline CChildFrame* CAMCView::GetParentFrame () const
{
    CChildFrame* pFrame = dynamic_cast<CChildFrame*>(CView::GetParentFrame());
    ASSERT (pFrame != NULL);
    ASSERT_VALID (pFrame);
    ASSERT_KINDOF (CChildFrame, pFrame);

    return (pFrame);
}

//+-------------------------------------------------------------------
//
//  Member:      IsTracking
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline bool CAMCView::IsTracking () const
{
    return (m_pTracker != NULL);
}


//+-------------------------------------------------------------------
//
//  Member:      IsVerbEnabled
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline BOOL CAMCView::IsVerbEnabled(MMC_CONSOLE_VERB verb)
{
    BOOL bFlag = FALSE;
    if (m_ViewData.m_spVerbSet != NULL)
    {
        HRESULT hr = m_ViewData.m_spVerbSet->GetVerbState(verb, ENABLED, &bFlag);
        if (FAILED(hr))
            bFlag = FALSE;
    }
    return bFlag;
}

//+-------------------------------------------------------------------
//
//  Member:      GetDefaultColumnWidths
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::GetDefaultColumnWidths(int columnWidth[2])
{
    columnWidth[0] = m_columnWidth[0];
    columnWidth[1] = m_columnWidth[1];
}


//+-------------------------------------------------------------------
//
//  Member:      SetDefaultColumnWidths
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::SetDefaultColumnWidths(int columnWidth[2], BOOL fUpdate)
{
    // Bug 157408:  remove the "Type" column for static nodes
    columnWidth[1] = 0;

    m_columnWidth[0] = columnWidth[0];
    m_columnWidth[1] = columnWidth[1];

    if (fUpdate == TRUE && m_pListCtrl != NULL)
    {
        CListCtrl& lc = m_pListCtrl->GetListCtrl();

        lc.SetColumnWidth(0, m_columnWidth[0]);
        lc.SetColumnWidth(1, m_columnWidth[1]);
    }

    SetDirty();
}

//+-------------------------------------------------------------------
//
//  Member:      GetDefaultListViewStyle
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline long CAMCView::GetDefaultListViewStyle() const
{
    return m_DefaultLVStyle;
}

//+-------------------------------------------------------------------
//
//  Member:      SetDefaultListViewStyle
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline void CAMCView::SetDefaultListViewStyle(long style)
{
    m_DefaultLVStyle = style;
}

//+-------------------------------------------------------------------
//
//  Member:      GetViewMode
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline int CAMCView::GetViewMode() const
{
    return m_nViewMode;
}

//+-------------------------------------------------------------------
//
//  Member:      CanDoDragDrop
//
//  Synopsis:    if there are posted messages for multiselection changes
//               to be processed then do not do drag&drop.
//
//--------------------------------------------------------------------
inline bool CAMCView::CanDoDragDrop()
{
    if (m_pListCtrl && m_pListCtrl->IsListPad())
        return false;
    return !m_bProcessMultiSelectionChanges;
}


//+-------------------------------------------------------------------
//
//  Member:      HasListOrListPad
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline bool CAMCView::HasListOrListPad() const
{
    return (HasList() || HasListPad());
}


//+-------------------------------------------------------------------
//
//  Member:      HasListPad
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline bool CAMCView::HasListPad() const
{
    if (m_pListCtrl)
        return m_pListCtrl->IsListPad();

    return false;
}

//+-------------------------------------------------------------------
//
//  Member:      GetStdToolbar
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline CStandardToolbar* CAMCView::GetStdToolbar() const
{
    return dynamic_cast<CStandardToolbar*>(m_ViewData.GetStdVerbButtons());
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScColumnInfoListChanged
//
//  Synopsis:    The column-info-list (width/order/hiddeness) for currently
//               selected node has changed ask nodemgr to persist the new data.
//
//  Arguments:   [colInfoList] - new data
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCView::ScColumnInfoListChanged (const CColumnInfoList& colInfoList)
{
    DECLARE_SC(sc, _T("CAMCView::ScColumnInfoListChanged"));

    INodeCallback* spNodeCallback = GetNodeCallback();
    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers(spNodeCallback, hNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = spNodeCallback->SaveColumnInfoList(hNode, colInfoList);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetPersistedColumnInfoList
//
//  Synopsis:    The list-view requests the column-data (no sort data) to setup the headers
//               before any items are inserted into the list-view. Forward this
//               request to nodemgr.
//
//  Arguments:   [pColInfoList] - [out param]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCView::ScGetPersistedColumnInfoList (CColumnInfoList *pColInfoList)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetPersistedColumnInfoList"));

    INodeCallback* spNodeCallback = GetNodeCallback();
    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers(spNodeCallback, hNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = spNodeCallback->GetPersistedColumnInfoList(hNode, pColInfoList);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDeletePersistedColumnData
//
//  Synopsis:    The column data for currently selected node is invalid,
//               ask nodemgr to remove it.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCView::ScDeletePersistedColumnData ()
{
    DECLARE_SC(sc, _T("CAMCView::ScDeletePersistedColumnData"));

    INodeCallback* spNodeCallback = GetNodeCallback();
    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers(spNodeCallback, hNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = spNodeCallback->DeletePersistedColumnData(hNode);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CanInsertScopeItemInResultPane
//
//  Synopsis:    Can we insert child scope items of currently selected scope
//               item in the listview.
//
//--------------------------------------------------------------------
inline bool CAMCView::CanInsertScopeItemInResultPane()
{
    // Can insert only if
    // a) it is a non-virtual result list,
    // b) Don't add the item if a node select is in progress
    //    because the tree control will automatically add all
    //    scope items as part of the select procedure.
    // c) view-option to exclude scope items in result pane is not specified.

    return (!IsVirtualList() && !IsSelectingNode() && !(GetListOptions() & RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST) );
}


#endif  // AMCVIEW_INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcdoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcdoc.h
//
//--------------------------------------------------------------------------

// AMCDoc.h : interface of the CAMCDoc class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef AMCDOC_H__
#define AMCDOC_H__

#include "mmcdata.h"
#include "amc.h"            // for AMCGetApp
#include "picon.h"          // for CPersistableIcon
#include "tstring.h"        // for CStringTableStringBase
#include "condoc.h"

#define EXPLICIT_SAVE    0x1

class CAMCView;
class ViewSettings;
class CMasterStringTable;
class CFavorites;
class CMMCDocument;
struct Document;

/*+-------------------------------------------------------------------------*
 * CStringTableString
 *
 *
 *--------------------------------------------------------------------------*/

class CStringTableString : public CStringTableStringBase
{
    typedef CStringTableStringBase BaseClass;

public:
    CStringTableString (IStringTablePrivate* pstp)
        : BaseClass (pstp) {}

    CStringTableString (const CStringTableString& other)
        : BaseClass (other) {}

    CStringTableString (const tstring& str)
        : BaseClass (GetStringTable(), str) {}

    CStringTableString& operator= (const CStringTableString& other)
        { BaseClass::operator=(other); return (*this); }

    CStringTableString& operator= (const tstring& str)
        { BaseClass::operator=(str); return (*this); }

    CStringTableString& operator= (LPCTSTR psz)
        { BaseClass::operator=(psz); return (*this); }

private:
    IStringTablePrivate* GetStringTable() const;

};


/*+-------------------------------------------------------------------------*
 * CAMCViewPosition
 *
 * This class abstracts a POSITION.  It can be used to iterate through a
 * CAMCDoc's CAMCView objects using GetFirstAMCViewPosition and
 * GetNextAMCView.
 *
 * It exists to guard against using GetFirstViewPosition with GetNextAMCView
 * or GetFirstAMCViewPosition with GetNextView.
 *--------------------------------------------------------------------------*/

class CAMCViewPosition
{
public:
    CAMCViewPosition() : m_pos(NULL)
        {}

    POSITION& GetPosition ()        // returns non-const reference
        { return (m_pos); }

    void SetPosition (POSITION pos)
        { m_pos = pos; }

    /*
     * for comparison to NULL
     */
    bool operator==(int null) const
    {
        ASSERT (null == 0);     // *only* support comparison to NULL
        return (m_pos == NULL);
    }

    bool operator!=(int null) const
    {
        ASSERT (null == 0);     // *only* support comparison to NULL
        return (m_pos != NULL);
    }

private:
    POSITION    m_pos;
};


/*+-------------------------------------------------------------------------*
 * class CAMCDoc
 *
 *
 *--------------------------------------------------------------------------*/

class CAMCDoc :
    public CDocument,
    public CTiedObject,
    public CXMLObject,
    public CConsoleDocument,
    public CConsoleFilePersistor,
    public CEventSource<CAMCDocumentObserver>
{
    enum SaveStatus
    {
        eStat_Failed,
        eStat_Succeeded,
        eStat_Cancelled
    };

protected: // create from serialization only
    CAMCDoc();
    DECLARE_DYNCREATE(CAMCDoc)

// Attributes
public:
    virtual BOOL IsModified();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    SC           ScOnOpenDocument(LPCTSTR lpszPathName); // SC version of the above method.
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
    virtual void DeleteContents();
    virtual void OnCloseDocument();
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL


    // object model related methods.
    // hand over an automation object - CHANGE to use smart pointers.
    SC      ScGetMMCDocument(Document **ppDocument);

    // Document interface
    SC      ScSave();
    SC      ScSaveAs(         BSTR bstrFilename);
    SC      ScClose(          BOOL bSaveChanges);
    SC      ScCreateProperties( PPPROPERTIES ppProperties);

    // properties
    SC      Scget_Views(      PPVIEWS   ppViews);
    SC      Scget_SnapIns(    PPSNAPINS ppSnapIns);
    SC      Scget_ActiveView( PPVIEW    ppView);
    SC      Scget_Name(       PBSTR     pbstrName);
    SC      Scput_Name(       BSTR      bstrName);
    SC      Scget_Location(   PBSTR     pbstrLocation);
    SC      Scget_IsSaved(    PBOOL     pBIsSaved);
    SC      Scget_Mode(       PDOCUMENTMODE pMode);
    SC      Scput_Mode(       DocumentMode mode);
    SC      Scget_RootNode(   PPNODE     ppNode);
    SC      Scget_ScopeNamespace( PPSCOPENAMESPACE  ppScopeNamespace);
    SC      Scget_Application(PPAPPLICATION  ppApplication);

    // Views interface
    SC      Scget_Count(  PLONG pCount);
    SC      ScAdd(        PNODE pNode, ViewOptions fViewOptions /* = ViewOption_Default*/ );
    SC      ScItem(       long  Index, PPVIEW ppView);

    // views enumerator
    SC      ScEnumNext(CAMCViewPosition &pos, PDISPATCH & pDispatch);
    SC      ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, CAMCViewPosition &pos);
    SC      ScEnumReset(CAMCViewPosition &pos);


public:
    // to iterate through the AMCViews only (not all child views)
    // similar to GetNextView and GetFirstViewPosition.
    CAMCView *       GetNextAMCView(CAMCViewPosition &pos) const;
    CAMCViewPosition GetFirstAMCViewPosition()     const;


public:
    // CXMLObject overrides
    DEFINE_XML_TYPE(XML_TAG_MMC_CONSOLE_FILE);
    virtual void    Persist(CPersistor& persistor);
    void            PersistFrame(CPersistor& persistor);
    void            PersistViews(CPersistor& persistor);
    SC              ScCreateAndLoadView(CPersistor& persistor, int nViewID, const CBookmark& rootNode);
    void            PersistCustomData (CPersistor &persistor);

    IScopeTree* GetScopeTree()
    {
        return m_spScopeTree;
    }

    CAMCView* CreateNewView(bool visible, bool bEmitScriptEvents = true);

    static CAMCDoc* GetDocument()
    {
        return m_pDoc;
    }

    MTNODEID GetMTNodeIDForNewView()
    {
        return m_MTNodeIDForNewView;
    }

    void SetMTNodeIDForNewView(MTNODEID id)
    {
        m_MTNodeIDForNewView = id;
    }

    int GetViewIDForNewView()
    {
        return m_ViewIDForNewView;
    }

    long GetNewWindowOptions()
    {
        return m_lNewWindowOptions;
    }

    HELPDOCINFO* GetHelpDocInfo()
    {
        return &m_HelpDocInfo;
    }

    void SetNewWindowOptions(long lOptions)
    {
        m_lNewWindowOptions = lOptions;
    }

    void SetMode (ProgramMode eMode);
    ProgramMode GetMode () const
    {
        return (m_ConsoleData.GetConsoleMode());
    }

    bool IsFrameModified () const
    {
        return (m_fFrameModified);
    }

    void SetFrameModifiedFlag (bool fFrameModified = TRUE)
    {
        m_fFrameModified = fFrameModified;
    }

    // implements CConsoleDocument for document access from node manager
    virtual SC ScOnSnapinAdded       (PSNAPIN pSnapIn);
    virtual SC ScOnSnapinRemoved     (PSNAPIN pSnapIn);
    virtual SC ScSetHelpCollectionInvalid();


public:

// Implementation
    virtual ~CAMCDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    virtual BOOL DoFileSave();
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
    virtual HMENU GetDefaultMenu(); // get menu depending on state

    SConsoleData* GetConsoleData() { return &m_ConsoleData; }

public:
    HRESULT InitNodeManager();
    void ShowStatusBar (bool fVisible);

/*
 * Custom data stuff
 */
private:
    bool LoadCustomData      (IStorage* pStorage);
    bool LoadCustomIconData  (IStorage* pStorage);
    bool LoadCustomTitleData (IStorage* pStorage);
    bool LoadStringTable     (IStorage* pStorage);
/*
 * Custom icon stuff
 */
public:
    HICON GetCustomIcon (bool fLarge, CString* pstrIconFile = NULL, int* pnIconIndex = NULL) const;
    void  SetCustomIcon (LPCTSTR pszIconFile, int nIconIndex);

    bool  HasCustomIcon () const
        { return (m_CustomIcon); }

private:
    CPersistableIcon m_CustomIcon;


/*
 * Custom title stuff
 */
public:
    bool HasCustomTitle () const;
    CString GetCustomTitle () const;
    void SetCustomTitle (CString strNewTitle);
    IStringTablePrivate* GetStringTable() const;

private:
    CComPtr<IStringTablePrivate>    m_spStringTable;
    CStringTableString *            m_pstrCustomTitle;

/*
 * Favorites stuff
 */
 public:
    CFavorites* GetFavorites() { return m_pFavorites; }

private:
    bool LoadFavorites();
    CFavorites* m_pFavorites;

private:
    static CAMCDoc* m_pDoc;
    // the one and only document for the application

    IScopeTreePtr m_spScopeTree;
    // master namespace for document

    IPersistStoragePtr m_spScopeTreePersist;
    // master namespace IPersistStorage interface

    IStoragePtr m_spStorage;
    // the currently opened storage

    MTNODEID m_MTNodeIDForNewView;
    // the node id to be used when creating the next view

    int m_ViewIDForNewView;
    // the node id to be used when creating the next view

    SConsoleData   m_ConsoleData;

    long m_lNewWindowOptions;
    bool m_bReadOnlyDoc;
    bool m_fFrameModified;
    SaveStatus m_eSaveStatus;

    DWORD m_dwFlags;

    HELPDOCINFO m_HelpDocInfo;

    void ReleaseNodeManager();
    bool LoadViews();
    bool LoadFrame();
    bool LoadAppMode();

    bool NodeManagerIsInitialized();
    bool NodeManagerIsLoaded();
    bool AssertNodeManagerIsInitialized();
    bool AssertNodeManagerIsLoaded();
    BOOL OnNewDocumentFailed();
    void SetConsoleFlag (ConsoleFlags eFlag, bool fSet);
    void DeleteHelpFile ();

    SC   ScGetViewSettingsPersistorStream(IPersistStream **pIPersistStreamViewSettings);

private:
    bool GetDocumentMode(DocumentMode* pMode);
    bool SetDocumentMode(DocumentMode docMode);

public:
    // Is this save called implicitly or is it a result of exiting a modified file?
    bool IsExplicitSave() const
        { return (0 != (m_dwFlags & EXPLICIT_SAVE)); }

    void SetExplicitSave(bool bNewVal)
    {
        if (bNewVal)
            m_dwFlags |= EXPLICIT_SAVE;
        else
            m_dwFlags &= ~EXPLICIT_SAVE;
    }

    bool AllowViewCustomization() const
        { return ((m_ConsoleData.m_dwFlags & eFlag_PreventViewCustomization) == 0); }

    bool IsLogicalReadOnly() const
        { return ((m_ConsoleData.m_dwFlags & eFlag_LogicalReadOnly) != 0); }

    bool IsPhysicalReadOnly() const
        { return (m_bReadOnlyDoc); }

    // physical ReadOnly does not apply to user mode - it is not saving to original console
    // anyway.
    bool IsReadOnly() const
        { return ((IsPhysicalReadOnly() && (AMCGetApp()->GetMode() == eMode_Author)) ||
                  (IsLogicalReadOnly() && (AMCGetApp()->GetMode() != eMode_Author))) ; }

    void SetPhysicalReadOnlyFlag (bool fPhysicalReadOnly)
        { m_bReadOnlyDoc = fPhysicalReadOnly; }

    void SetLogicalReadOnlyFlag (BOOL fLogicalReadOnly)
        { SetConsoleFlag (eFlag_LogicalReadOnly, fLogicalReadOnly); }

    void AllowViewCustomization (BOOL fAllowCustomization)
        { SetConsoleFlag (eFlag_PreventViewCustomization, !fAllowCustomization); }

    int GetNumberOfViews();
    int GetNumberOfPersistedViews();

private:
    //{{AFX_MSG(CAMCDoc)
    afx_msg void OnUpdateFileSave(CCmdUI* pCmdUI);
    afx_msg void OnConsoleAddremovesnapin();
    afx_msg void OnUpdateConsoleAddremovesnapin(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    DocumentPtr  m_sp_Document;
    ViewsPtr     m_spViews;
};

inline bool CAMCDoc::NodeManagerIsInitialized()
{
    return m_spScopeTree != NULL && m_spScopeTreePersist != NULL;
}

inline bool CAMCDoc::NodeManagerIsLoaded()
{
    return NodeManagerIsInitialized() && m_spStorage != NULL;
}

inline bool CAMCDoc::AssertNodeManagerIsInitialized()
{
    bool const bInited = NodeManagerIsInitialized();
    ASSERT(bInited);
    return bInited;
}

inline bool CAMCDoc::AssertNodeManagerIsLoaded()
{
    bool const bLoaded = NodeManagerIsLoaded();
    ASSERT(bLoaded);
    return bLoaded;
}

inline BOOL CAMCDoc::OnNewDocumentFailed()
{
    ReleaseNodeManager();
    return FALSE;
}

inline bool CAMCDoc::GetDocumentMode(DocumentMode* pMode)
{
    if (! pMode)
        return false;

    switch(GetMode())
    {
    case eMode_Author:
        *pMode = DocumentMode_Author;
        break;

    case eMode_User:
        *pMode = DocumentMode_User;
        break;

    case eMode_User_MDI:
        *pMode = DocumentMode_User_MDI;
        break;

    case eMode_User_SDI:
        *pMode = DocumentMode_User_SDI;
        break;

    default:
        ASSERT(FALSE && _T("Unknown program mode"));
        return false;
        break;
    }

    return true;
}


inline bool CAMCDoc::SetDocumentMode(DocumentMode docMode)
{
    switch(docMode)
    {
    case DocumentMode_Author:
        SetMode(eMode_Author);
        break;

    case DocumentMode_User:
        SetMode(eMode_User);
        break;

    case DocumentMode_User_SDI:
        SetMode(eMode_User_SDI);
        break;

    case DocumentMode_User_MDI:
        SetMode(eMode_User_MDI);
        break;

    default:
        return false; // Unknown mode.
        break;
    }

    return true;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::ScGetViewSettingsPersistorStream
//
//  Synopsis:    helper to get the IPersistStream interface for
//               CViewSettingsPersistor object.
//
//  Arguments:   [pIPersistStreamViewSettings] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCDoc::ScGetViewSettingsPersistorStream (/*[out]*/IPersistStream **pIPersistStreamViewSettings)
{
    DECLARE_SC(sc, _T("CAMCDoc::ScGetViewSettingsPersistorStream"));
    sc = ScCheckPointers(pIPersistStreamViewSettings);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    INodeCallbackPtr spNodeCallback;
    sc = m_spScopeTree->QueryNodeCallback(&spNodeCallback);
    if (sc)
        return sc;

    sc = ScCheckPointers(spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spNodeCallback->QueryViewSettingsPersistor(pIPersistStreamViewSettings);
    if (sc)
        return sc;

    sc = ScCheckPointers(pIPersistStreamViewSettings, E_UNEXPECTED);
    if (sc)
        return sc;

    return (sc);
}


int DisplayFileOpenError (SC sc, LPCTSTR pszFilename);


/////////////////////////////////////////////////////////////////////////////

#endif // AMCDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\archpicker.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      archpicker.cpp
 *
 *  Contents:  Implementation file for CArchitecturePicker
 *
 *  History:   1-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

// ArchPicker.cpp : implementation file
//

#include "stdafx.h"

#ifdef _WIN64		// this class is only required on 64-bit platforms

#include "amc.h"
#include "ArchPicker.h"

//#ifdef _DEBUG
//#define new DEBUG_NEW
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#endif

/////////////////////////////////////////////////////////////////////////////
// CArchitecturePicker dialog


/*+-------------------------------------------------------------------------*
 * CArchitecturePicker::CArchitecturePicker
 *
 * Constructs a CArchitecturePicker object.
 *--------------------------------------------------------------------------*/

CArchitecturePicker::CArchitecturePicker (
	CString					strFilename,		// I:name of console file
	CAvailableSnapinInfo&	asi64,				// I:available 64-bit snap-ins
	CAvailableSnapinInfo&	asi32,				// I:available 32-bit snap-ins
	CWnd*					pParent /*=NULL*/)	// I:dialog's parent window
	:	CDialog       (CArchitecturePicker::IDD, pParent),
		m_asi64       (asi64),
		m_asi32       (asi32),
		m_strFilename (strFilename),
		m_eArch       (eArch_64bit)
{
	//{{AFX_DATA_INIT(CArchitecturePicker)
	//}}AFX_DATA_INIT

	ASSERT (!asi64.m_f32Bit);
	ASSERT ( asi32.m_f32Bit);
}


void CArchitecturePicker::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArchitecturePicker)
	DDX_Control(pDX, IDC_SnapinList64, m_wndSnapinList64);
	DDX_Control(pDX, IDC_SnapinList32, m_wndSnapinList32);
	//}}AFX_DATA_MAP

	DDX_Radio(pDX, IDC_64Bit, reinterpret_cast<int&>(m_eArch));
}


BEGIN_MESSAGE_MAP(CArchitecturePicker, CDialog)
	//{{AFX_MSG_MAP(CArchitecturePicker)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArchitecturePicker message handlers

BOOL CArchitecturePicker::OnInitDialog()
{
	/*
	 * these must be consecutive and match the order of radio buttons on
	 * the dialog
	 */
	ASSERT (eArch_64bit == 0);
	ASSERT (eArch_32bit == 1);
	ASSERT (GetNextDlgGroupItem(GetDlgItem(IDC_64Bit))                 != NULL);
	ASSERT (GetNextDlgGroupItem(GetDlgItem(IDC_64Bit))->GetDlgCtrlID() == IDC_32Bit);

	/*
	 * if there are more 32-bit snap-ins than 64-bit snap-ins, default
	 * to running 32-bit; otherwise, default to running 64-bit
	 * (do this before calling CDialog::OnInitDialog so the state of
	 * the radio button will be set correctly when CDialog::OnInitDialog
	 * calls UpdateData)
	 */
	if (m_asi32.m_vAvailableSnapins.size() > m_asi64.m_vAvailableSnapins.size())
		m_eArch = eArch_32bit;
	
	CDialog::OnInitDialog();

	/*
	 * put the filename on the dialog
	 */
	SetDlgItemText (IDC_ConsoleFileName, m_strFilename);

	/*
	 * put formatted messages in the info windows
	 */
	FormatMessage (IDC_SnapinCount64, m_asi64);
	FormatMessage (IDC_SnapinCount32, m_asi32);

	/*
	 * populate the lists
	 */
	PopulateList (m_wndSnapinList64, m_asi64);
	PopulateList (m_wndSnapinList32, m_asi32);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/*+-------------------------------------------------------------------------*
 * CArchitecturePicker::FormatMessage
 *
 * Retrieves the format text from the given control, formats the message
 * with the information contained in the given CArchitecturePicker, and
 * replaces the text in the control with the result.
 *--------------------------------------------------------------------------*/

void CArchitecturePicker::FormatMessage (
	UINT					idControl,		/* I:control to update			*/
	CAvailableSnapinInfo&	asi)			/* I:data to use in formatting	*/
{
	DECLARE_SC (sc, _T("CArchitecturePicker::FormatMessage"));

	/*
	 * get the control
	 */
	CWnd* pwnd = GetDlgItem (idControl);
	if (pwnd == NULL)
	{
		sc.FromLastError();
		return;
	}

	/*
	 * get the format string from the control
	 */
	CString strFormat;
	pwnd->GetWindowText (strFormat);

	/*
	 * format the text
	 */
	CString strText;
	strText.FormatMessage (strFormat, asi.m_vAvailableSnapins.size(), asi.m_cTotalSnapins);

	/*
	 * put the text in the window
	 */
	pwnd->SetWindowText (strText);
}


/*+-------------------------------------------------------------------------*
 * CArchitecturePicker::PopulateList
 *
 * Puts the names of each snap-in in asi into the given list control.
 *--------------------------------------------------------------------------*/

void CArchitecturePicker::PopulateList (
	CListCtrl&				wndList,		/* I:control to update			*/
	CAvailableSnapinInfo&	asi)			/* I:data to use in formatting	*/
{
	/*
	 * put a single, full-width column in the list
	 */
	CRect rect;
	wndList.GetClientRect (rect);
	int cxColumn = rect.Width() - GetSystemMetrics (SM_CXVSCROLL);
	wndList.InsertColumn (0, NULL, LVCFMT_LEFT, cxColumn);

	/*
	 * Give the list the imagelist.  The imagelist is owned by the
	 * CAvailableSnapinInfo, so make sure the list has LVS_SHAREIMAGELISTS
	 * so it won't delete the image list when it's destroyed.
	 */
	ASSERT (wndList.GetStyle() & LVS_SHAREIMAGELISTS);
	wndList.SetImageList (CImageList::FromHandle (asi.m_himl), LVSIL_SMALL);

	/*
	 * put each item in the list
	 */
	std::vector<CBasicSnapinInfo>::iterator it;

	for (it  = asi.m_vAvailableSnapins.begin();
		 it != asi.m_vAvailableSnapins.end();
		 ++it)
	{
		wndList.InsertItem (-1, it->m_strName.data(), it->m_nImageIndex);
	}
}


#endif	// _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\atlconui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      atlconui.h
//
//  Contents:  Support for ATL in an MFC project
//
//  History:   15-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------
#include <atlbase.h>
// We can implement the MFC/ATL lock count interaction in two different ways
// (you may comment/uncomment the one you want to try)

// ATL can blindly delegate all the ATL Lock()/Unlock() calls to MFC
/*
class CAtlGlobalModule : public CComModule
{
public:
    LONG Lock()
    {
        AfxOleLockApp();
        return 0;
    }
    LONG Unlock()
    {
        AfxOleUnlockApp();
        return 0;
    }
};
*/


#ifdef DBG
extern CTraceTag tagATLLock;
#endif

class CAtlGlobalModule : public CComModule
{
public:
    LONG Lock()
    {
        LONG l = CComModule::Lock();
        Trace(tagATLLock, TEXT("Lock:   count = %d"), l);
        return l;
    }
    LONG Unlock()
    {
        LONG l = CComModule::Unlock();
        Trace(tagATLLock, TEXT("Unlock: count = %d"), l);
        return l;
    }
};

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CAtlGlobalModule _Module;
#include <atlcom.h>


// Needed because MFC creates a macro for this which ATL doesn't like.                     
#undef SubclassWindow

#undef WM_OCC_LOADFROMSTREAM          
#undef WM_OCC_LOADFROMSTORAGE         
#undef WM_OCC_INITNEW                 
#undef WM_OCC_LOADFROMSTREAM_EX       
#undef WM_OCC_LOADFROMSTORAGE_EX      

// This prevents the ATL activeX host from locking the app.
#define _ATL_HOST_NOLOCK

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>
#include <sitebase.h>
#include <axhostwindow2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\caption.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      caption.h
 *
 *  Contents:  Interface file for caption helper functions
 *
 *  History:   19-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CAPTION_H
#define CAPTION_H
#pragma once


bool DrawFrameCaption (CFrameWnd* pwndFrame, bool fActive);


#endif /* CAPTION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\caption.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      caption.cpp
 *
 *  Contents:  Implementation file for caption helper functions
 *
 *  History:   19-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "caption.h"
#include "fontlink.h"
#include "util.h"


static void ComputeCaptionRects (CFrameWnd* pwnd, CRect& rectFullCaption,
                                 CRect& rectCaptionText, NONCLIENTMETRICS* pncm);
static bool GradientFillRect (HDC hdc, LPCRECT pRect, bool fActive);
static bool GradientFillRect (HDC hdc, LPCRECT pRect,
                              COLORREF clrGradientLeft,
                              COLORREF clrGradientRight);


/*+-------------------------------------------------------------------------*
 * DrawFrameCaption
 *
 *
 *--------------------------------------------------------------------------*/

bool DrawFrameCaption (CFrameWnd* pwndFrame, bool fActive)
{
	/*
	 * whistler always does the right thing, so short out if we're running there
	 */
	if (IsWhistler())
		return (false);

    CWindowDC dc(pwndFrame);

    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

    /*
     * create the caption font and select it into the DC
     */
    CFont font;
    font.CreateFontIndirect (&ncm.lfCaptionFont);
    CFont* pOldFont = dc.SelectObject (&font);

    /*
     * get the text to draw
     */
    CString strCaption;
    pwndFrame->GetWindowText (strCaption);

    /*
     * create CFontLinker and CRichText objects to determine if we
     * need to draw the text ourselves
     */
    USES_CONVERSION;
    CRichText   rt (dc, T2CW (strCaption));
    CFontLinker fl;

    if (!fl.ComposeRichText(rt) || rt.IsDefaultFontSufficient())
    {
        dc.SelectObject (pOldFont);
        return (false);
    }

    /*-------------------------------------------------------*/
    /* if we get here, the default drawing isn't sufficient; */
    /* draw the caption ourselves                            */
    /*-------------------------------------------------------*/

    /*
     * get the bounding rects for the full caption and the text portion
     */
    CRect rectFullCaption;
    CRect rectCaptionText;
    ComputeCaptionRects (pwndFrame, rectFullCaption, rectCaptionText, &ncm);

    /*
     * clip output to the caption text rect, to minimize destruction
     * in the event that something dire happens
     */
    dc.IntersectClipRect (rectCaptionText);

    /*
     * gradient-fill the full caption rect (not just the title rect)
     * so the gradient will overlay seamlessly
     */
    if (!GradientFillRect (dc, rectFullCaption, fActive))
    {
        const int nBackColorIndex = (fActive) ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION;
        dc.FillSolidRect (rectCaptionText, GetSysColor (nBackColorIndex));
    }

    /*
     * set up text colors and background mix mode
     */
    const int nTextColorIndex = (fActive) ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT;
    COLORREF clrText = dc.SetTextColor (GetSysColor (nTextColorIndex));
    int      nBkMode = dc.SetBkMode (TRANSPARENT);

    /*
     * draw the text
     */
    rt.Draw (rectCaptionText, fl.GetDrawTextFlags ());

    /*
     * restore the DC
     */
    dc.SetTextColor (clrText);
    dc.SetBkMode    (nBkMode);
    dc.SelectObject (pOldFont);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * ComputeCaptionRects
 *
 *
 *--------------------------------------------------------------------------*/

static void ComputeCaptionRects (
    CFrameWnd*          pwnd,
    CRect&              rectFullCaption,
    CRect&              rectCaptionText,
    NONCLIENTMETRICS*   pncm)
{
    /*
     * start with the full window rect, normalized around (0,0)
     */
    pwnd->GetWindowRect (rectFullCaption);
    rectFullCaption.OffsetRect (-rectFullCaption.left, -rectFullCaption.top);

    /*
     * assume sizing border
     */
    rectFullCaption.InflateRect (-GetSystemMetrics (SM_CXSIZEFRAME),
                                 -GetSystemMetrics (SM_CYSIZEFRAME));

    /*
     * correct the height
     */
    rectFullCaption.bottom = rectFullCaption.top + pncm->iCaptionHeight;

    /*
     * assume a system menu
     */
    rectCaptionText = rectFullCaption;
    rectCaptionText.left += pncm->iCaptionWidth + 2;

    /*
     * assume min, max, close buttons
     */
    rectCaptionText.right -= pncm->iCaptionWidth * 3;
}


/*+-------------------------------------------------------------------------*
 * GradientFillRect
 *
 *
 *--------------------------------------------------------------------------*/

static bool GradientFillRect (HDC hdc, LPCRECT pRect, bool fActive)
{
#if (WINVER < 0x0500)
    #define COLOR_GRADIENTACTIVECAPTION     27
    #define COLOR_GRADIENTINACTIVECAPTION   28
#endif

    int nLeftColor  = (fActive) ? COLOR_ACTIVECAPTION         : COLOR_INACTIVECAPTION;
    int nRightColor = (fActive) ? COLOR_GRADIENTACTIVECAPTION : COLOR_GRADIENTINACTIVECAPTION;

    return (GradientFillRect (hdc, pRect,
                              GetSysColor (nLeftColor),
                              GetSysColor (nRightColor)));
}


/*+-------------------------------------------------------------------------*
 * GradientFillRect
 *
 *
 *--------------------------------------------------------------------------*/

static bool GradientFillRect (HDC hdc, LPCRECT pRect, COLORREF clrGradientLeft, COLORREF clrGradientRight)
{
#if (WINVER < 0x0500)
    #define SPI_GETGRADIENTCAPTIONS         0x1008
#endif
    typedef BOOL (WINAPI* GradientFillFuncPtr)( HDC hdc,  CONST PTRIVERTEX pVertex,  DWORD dwNumVertex,
                                        CONST PVOID pMesh,  DWORD dwNumMesh,  DWORD dwMode);

    // Query if gradient caption enabled, if query fails assume disabled
    BOOL bGradientEnabled;
    if (!SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, &bGradientEnabled, 0))
        bGradientEnabled = FALSE;

    if (!bGradientEnabled)
        return (false);

    static GradientFillFuncPtr pfnGradientFill = NULL;
    static bool fAttemptedGetProcAddress = false;

    // Locate GradientFill function
    if (!fAttemptedGetProcAddress)
    {
        fAttemptedGetProcAddress = true;

        HINSTANCE hInst = LoadLibrary(TEXT("msimg32.dll"));

        if (hInst)
            pfnGradientFill = (GradientFillFuncPtr)GetProcAddress(hInst, "GradientFill");
    }

    if (pfnGradientFill == NULL)
        return (false);

    // Do gradient fill
    TRIVERTEX vert[2] ;
    vert [0].x      = pRect->left;
    vert [0].y      = pRect->top;
    vert [0].Red    = (clrGradientLeft << 8) & 0xff00;
    vert [0].Green  = (clrGradientLeft)      & 0xff00;
    vert [0].Blue   = (clrGradientLeft >> 8) & 0xff00;
    vert [0].Alpha  = 0x0000;

    vert [1].x      = pRect->right;
    vert [1].y      = pRect->bottom;
    vert [1].Red    = (clrGradientRight << 8) & 0xff00;
    vert [1].Green  = (clrGradientRight)      & 0xff00;
    vert [1].Blue   = (clrGradientRight >> 8) & 0xff00;
    vert [1].Alpha  = 0x0000;

    GRADIENT_RECT gRect[1];
    gRect[0].UpperLeft  = 0;
    gRect[0].LowerRight = 1;

    (*pfnGradientFill) (hdc, vert,  countof (vert),
                             gRect, countof (gRect), GRADIENT_FILL_RECT_H);
    return (true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\archpicker.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      archpicker.h
 *
 *  Contents:  Interface file for CArchitecturePicker
 *
 *  History:   1-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_ARCHPICKER_H__4502E3CD_5EB7_4708_A765_8DAF3D03773F__INCLUDED_)
#define AFX_ARCHPICKER_H__4502E3CD_5EB7_4708_A765_8DAF3D03773F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ArchPicker.h : header file
//

enum eArchitecture
{
	eArch_64bit,	// force 64-bit version to run
	eArch_32bit,	// force 32-bit version to run
	eArch_Any,		// any architecture is acceptable
	eArch_None,		// no architecture is acceptable (i.e. abort)
};

#ifdef _WIN64		// this class is only required on 64-bit platforms

class CAvailableSnapinInfo;


/////////////////////////////////////////////////////////////////////////////
// CArchitecturePicker dialog

class CArchitecturePicker : public CDialog
{
// Construction
public:
	CArchitecturePicker(
		CString					strFilename,		// I:name of console file
		CAvailableSnapinInfo&	asi64,				// I:available 64-bit snap-ins
		CAvailableSnapinInfo&	asi32,				// I:available 32-bit snap-ins
		CWnd*					pParent = NULL);	// I:dialog's parent window

	eArchitecture GetArchitecture() const	{ return (m_eArch); }

// Dialog Data
	//{{AFX_DATA(CArchitecturePicker)
	enum { IDD = IDD_ArchitecturePicker };
	CListCtrl	m_wndSnapinList64;
	CListCtrl	m_wndSnapinList32;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArchitecturePicker)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CArchitecturePicker)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void FormatMessage (UINT idControl,     CAvailableSnapinInfo& asi);
	void PopulateList  (CListCtrl& wndList, CAvailableSnapinInfo& asi);

private:
	CAvailableSnapinInfo&	m_asi64;
	CAvailableSnapinInfo&	m_asi32;
	CString					m_strFilename;
	eArchitecture			m_eArch;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif	// _WIN64

#endif // !defined(AFX_ARCHPICKER_H__4502E3CD_5EB7_4708_A765_8DAF3D03773F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\childfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      childfrm.cpp
//
//  Contents:  Child frame implementation
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Add code to switch views
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"
#include "ChildFrm.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "treectrl.h"
#include "afxpriv.h"
#include "mainfrm.h"
#include "amcpriv.h"
#include "sysmenu.h"
#include "amcmsgid.h"
#include "caption.h"
#include "strings.h"
#include "menubtns.h"

bool CanCloseDoc(void);


/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_DESTROY()
    ON_WM_CLOSE()
    ON_WM_MDIACTIVATE()
    ON_COMMAND(ID_CUSTOMIZE_VIEW, OnCustomizeView)
    ON_WM_NCPAINT()
    ON_WM_NCACTIVATE()
    ON_WM_SYSCOMMAND()
    ON_WM_INITMENUPOPUP()
    //}}AFX_MSG_MAP

    ON_MESSAGE(WM_SETTEXT, OnSetText)
    ON_MESSAGE(WM_GETICON, OnGetIcon)
    ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString)
    ON_COMMAND_RANGE(ID_MMC_MAXIMIZE, ID_MMC_RESTORE, OnMaximizeOrRestore)
    ON_UPDATE_COMMAND_UI(ID_CUSTOMIZE_VIEW, OnUpdateCustomizeView)

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
    m_pAMCView            = NULL;
    m_fDestroyed          = false;
    m_fCurrentlyMinimized = false;
    m_fCurrentlyActive    = false;
    m_fCreateVisible      = true;
}

CChildFrame::~CChildFrame()
{
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bSuccess=FALSE;

    // Let default implementation fill in most of the details
    if (!CMDIChildWnd::PreCreateWindow(cs))
        return (FALSE);

    // Remove the edge from the window so the splitter can paint it.
    cs.dwExStyle &=~WS_EX_CLIENTEDGE;

    WNDCLASS wc;
    LPCTSTR pszChildFrameClassName = g_szChildFrameClassName;

    if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
    {
        // Clear the H and V REDRAW flags
        wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
        wc.hIcon = AfxGetApp()->LoadIcon(IDR_AMCTYPE);
        wc.lpszClassName = pszChildFrameClassName;

        // Register this new style;
        bSuccess=AfxRegisterClass(&wc);
    }


    // Use the new child frame window class
    cs.lpszClass = pszChildFrameClassName;
    //cs.style &= ~FWS_ADDTOTITLE;

    // force maximized if in SDI User mode
    if (AMCGetApp()->GetMode() == eMode_User_SDI)
        cs.style |= WS_MAXIMIZE;

    // do not paint over the children
    cs.style |= WS_CLIPCHILDREN;

    return bSuccess;
}

/*+-------------------------------------------------------------------------*
 *
 * CChildFrame::OnUpdateFrameTitle
 *
 * PURPOSE: Sets the window title. It might be possible to short out this
 *          function.
 *
 * PARAMETERS:
 *    BOOL  bAddToTitle :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CChildFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    DECLARE_SC(sc,TEXT("CChildFrame::OnUpdateFrameTitle"));

    if ((GetStyle() & FWS_ADDTOTITLE) == 0)
        return;     // leave child window alone!

    CDocument* pDocument = GetActiveDocument();
    if (bAddToTitle && pDocument != NULL)
    {
        sc = ScCheckPointers(m_pAMCView, E_UNEXPECTED);
        if(sc)
            return;

        sc = ScCheckPointers(m_pAMCView->GetWindowTitle());
        if(sc)
            return;

        // set title if changed, but don't remove completely
        AfxSetWindowText(m_hWnd, m_pAMCView->GetWindowTitle());
    }

    // update our parent window last
    GetMDIFrame()->OnUpdateFrameTitle(bAddToTitle);
}

int CChildFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    static UINT anIndicators[] =
    {
        ID_SEPARATOR,           // status line indicator
        IDS_PROGRESS,           // place holder for progress bar
        IDS_STATUS_STATIC,      // place holder for static control
    };

    DECLARE_SC (sc, _T("CChildFrame::OnCreate"));

    if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
    {
        sc = E_UNEXPECTED;
        return -1;
    }

	/*
	 * status bar should be themed (block controls the scope of activator)
	 */
	{
		CThemeContextActivator activator;

		// Create the status bar and panes
		m_wndStatusBar.Create(this, WS_CHILD|WS_VISIBLE|SBARS_SIZEGRIP, 0x1003);
		m_wndStatusBar.CreatePanes(anIndicators, countof(anIndicators));
	}

    // Add the control to the dock site
    m_StatusDockSite.Create(CDockSite::DSS_BOTTOM);
    m_StatusDockSite.Attach(&m_wndStatusBar);
    m_StatusDockSite.Show();

    // Tell the dock manager about the site.
    m_DockingManager.Attach(&m_StatusDockSite);

    CAMCView* const pAMCView = GetAMCView();
    if (pAMCView == NULL)
    {
        sc = E_UNEXPECTED;
        return -1;
    }

    pAMCView->SetChildFrameWnd(m_hWnd);

    SViewData* pVD = pAMCView->GetViewData();
    if (NULL == pVD)
    {
        sc = E_UNEXPECTED;
        return -1;
    }

    // Create the menubuttons manager and toolbars manager (one per view).
    m_spMenuButtonsMgr = std::auto_ptr<CMenuButtonsMgrImpl>(new CMenuButtonsMgrImpl());
    if (NULL == m_spMenuButtonsMgr.get())
    {
        sc = E_UNEXPECTED;
        return -1;
    }

    // Let SViewData be aware of the CMenuButtonsMgr.
    pVD->SetMenuButtonsMgr(static_cast<CMenuButtonsMgr*>(m_spMenuButtonsMgr.get()));

    CMainFrame* pFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pFrame, E_UNEXPECTED);
    if (sc)
        return -1;

    ASSERT_KINDOF (CMainFrame, pFrame);

    // Init the CMenuButtonsMgr.
    sc = m_spMenuButtonsMgr->ScInit(pFrame, this);
    if (sc)
        return -1;

    // Create the Standard toolbar UI.
    pVD->m_spNodeManager->InitViewData(reinterpret_cast<LONG_PTR>(pVD));
    ASSERT(pVD->m_spVerbSet != NULL);

    AppendToSystemMenu (this, eMode_User_SDI);
    RenderDockSites();

    return 0;
}


void CChildFrame::RenderDockSites()
{
    CRect clientRect;
    GetClientRect(&clientRect);

    CWnd* pWnd=GetWindow(GW_CHILD);

    if(pWnd)
    {
        m_DockingManager.BeginLayout();
        m_DockingManager.RenderDockSites(pWnd->m_hWnd, clientRect);
        m_DockingManager.EndLayout();
    }

}


bool CChildFrame::IsCustomizeViewEnabled()
{
    bool fEnable = false;
    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    if (pDoc != NULL)
    {
        fEnable = (AMCGetApp()->GetMode() == eMode_Author) ||
                  pDoc->AllowViewCustomization();
    }

    return (fEnable);
}

void CChildFrame::OnUpdateCustomizeView(CCmdUI* pCmdUI)
{
    pCmdUI->Enable (IsCustomizeViewEnabled());
}

// Display Customize View dialog
// When a child window is maximized, then it becomes a CMainFrame so the handler is
// necessary here to process the Scope Pane command on the system menu
void CChildFrame::OnCustomizeView()
{
    CAMCView* pView = GetAMCView();

    if (pView != NULL)
    {
        INodeCallback*  pCallback = pView->GetNodeCallback();
        SViewData*      pViewData = pView->GetViewData();

        ASSERT (pCallback != NULL);
        ASSERT (pViewData != NULL);

        pCallback->OnCustomizeView (reinterpret_cast<LONG_PTR>(pViewData));
    }
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnInitMenuPopup
 *
 * WM_INITMENUPOPUP handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
    /*
     * Bug 201113:  don't allow child system menus in SDI mode
     */
    if (bSysMenu && (AMCGetApp()->GetMode() == eMode_User_SDI))
    {
        SendMessage (WM_CANCELMODE);
        return;
    }

    CMDIChildWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);

    /*
     * CFrameWnd::OnInitMenuPopup doesn't do UI updates for system menus,
     * so we have to do it here
     */
    if (bSysMenu)
    {
        int nEnable = IsCustomizeViewEnabled() ? MF_ENABLED : MF_GRAYED;
        pPopupMenu->EnableMenuItem (ID_CUSTOMIZE_VIEW, MF_BYCOMMAND | nEnable);
    }
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSize
 *
 * WM_SIZE handler for CChildFrame.
 *--------------------------------------------------------------------------*/
void CChildFrame::OnSize(UINT nType, int cx, int cy)
{
    DECLARE_SC(sc, TEXT("CChildFrame::OnSize"));

    // bypass CMDIChildWnd::OnSize so we won't get MFC's docking stuff
    // (we still need to call Default so Windows' MDI stuff will work right)
    CWnd::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
    {
        RenderDockSites();
        CAMCView* pAMCView = GetAMCView();
        ASSERT (pAMCView != NULL);

        if (pAMCView)
            pAMCView->AdjustTracker (cx, cy);
    }


    // update our parent frame - in case we are now maximized or not
    CMDIFrameWnd*   pwndMDIFrame = GetMDIFrame();

    if (pwndMDIFrame)
        pwndMDIFrame->OnUpdateFrameTitle(TRUE);

    /*
     * If we're moving to or from the minimized state, notify snap-ins.
     * We don't need to send the notification if we're only creating a
     * temporary view that will never be shown.
     */
    if (m_fCurrentlyMinimized != (nType == SIZE_MINIMIZED) && m_fCreateVisible)
    {
        m_fCurrentlyMinimized = (nType == SIZE_MINIMIZED);
        SendMinimizeNotification (m_fCurrentlyMinimized);
    }

    // send the size notification to the view.
    if(GetAMCView())
    {
        sc = GetAMCView()->ScOnSize(nType, cx, cy);
        if(sc)
            return;
    }

}

BOOL CChildFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext)
{
    if (pParentWnd == NULL)
    {
        CWnd* pMainWnd = AfxGetThread()->m_pMainWnd;
        ASSERT(pMainWnd != NULL);
        ASSERT_KINDOF(CMDIFrameWnd, pMainWnd);
        pParentWnd = (CMDIFrameWnd*)pMainWnd;
    }
    ASSERT(::IsWindow(pParentWnd->m_hWndMDIClient));

    // first copy into a CREATESTRUCT for PreCreate
    CREATESTRUCT cs;
    cs.dwExStyle = 0L;
    cs.lpszClass = lpszClassName;
    cs.lpszName = lpszWindowName;
    cs.style = dwStyle;
    cs.x = rect.left;
    cs.y = rect.top;
    cs.cx = rect.right - rect.left;
    cs.cy = rect.bottom - rect.top;
    cs.hwndParent = pParentWnd->m_hWnd;
    cs.hMenu = NULL;
    cs.hInstance = AfxGetInstanceHandle();
    cs.lpCreateParams = (LPVOID)pContext;

    if (!PreCreateWindow(cs))
    {
        PostNcDestroy();
        return FALSE;
    }
    // extended style must be zero for MDI Children (except under Win4)
//  ASSERT(afxData.bWin4 || cs.dwExStyle == 0);
    ASSERT(cs.hwndParent == pParentWnd->m_hWnd);    // must not change

    // now copy into a MDICREATESTRUCT for real create
    MDICREATESTRUCT mcs;
    mcs.szClass = cs.lpszClass;
    mcs.szTitle = cs.lpszName;
    mcs.hOwner = cs.hInstance;
    mcs.x = cs.x;
    mcs.y = cs.y;
    mcs.cx = cs.cx;
    mcs.cy = cs.cy;
    mcs.style = cs.style & ~(WS_MAXIMIZE | WS_VISIBLE);
    mcs.lParam = reinterpret_cast<LPARAM>(cs.lpCreateParams);

    // create the window through the MDICLIENT window
    AfxHookWindowCreate(this);
    HWND hWnd = (HWND)::SendMessage(pParentWnd->m_hWndMDIClient,
        WM_MDICREATE, 0, (LPARAM)&mcs);
    if (!AfxUnhookWindowCreate())
        PostNcDestroy();        // cleanup if MDICREATE fails too soon

    if (hWnd == NULL)
        return FALSE;

    // special handling of visibility (always created invisible)
    if (cs.style & WS_VISIBLE)
    {
        // place the window on top in z-order before showing it
        ::BringWindowToTop(hWnd);

        // show it as specified
        if (cs.style & WS_MINIMIZE)
            ShowWindow(SW_SHOWMINIMIZED);
        else if (cs.style & WS_MAXIMIZE)
            ShowWindow(SW_SHOWMAXIMIZED);
        else
            ShowWindow(SW_SHOWNORMAL);

        // make sure it is active (visibility == activation)
        pParentWnd->MDIActivate(this);

        // refresh MDI Window menu
        ::SendMessage(pParentWnd->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
    }

    ASSERT(hWnd == m_hWnd);
    return TRUE;
}

void CChildFrame::OnDestroy()
{
    // NOTE - The un-hooking of the dock manager stops the rebar sending a height change
    // when the rebar goes away.
    m_DockingManager.RemoveAll();

    m_fDestroyed = true;

    CMDIChildWnd::OnDestroy();
}

void CChildFrame::OnMaximizeOrRestore(UINT nID)
{
    ASSERT(nID == ID_MMC_MAXIMIZE || nID == ID_MMC_RESTORE);

    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    GetWindowPlacement(&wp);

    UINT newShowCmd = (nID == ID_MMC_MAXIMIZE) ? SW_SHOWMAXIMIZED : SW_SHOWNORMAL;

    if (wp.showCmd != newShowCmd)
    {
       wp.showCmd = newShowCmd;
       SetWindowPlacement(&wp);
    }
}


void CChildFrame::OnClose()
{
    CAMCDoc* pDoc = CAMCDoc::GetDocument();
    ASSERT(pDoc != NULL);
    if (pDoc)
    {
        int cViews = 0;
        CAMCViewPosition pos = pDoc->GetFirstAMCViewPosition();
        while (pos != NULL)
        {
            CAMCView* pView = pDoc->GetNextAMCView(pos);

            if ((pView != NULL) && ++cViews >= 2)
                break;
        }

        if (cViews == 1)
        {
            if (!CanCloseDoc())
                return;
        }
        else
        {
            // if not closing last view, then give it
            // a chance to clean up first.
            // (if whole doc is closing CAMCDoc will handle
            //  closing all the views.)
            CAMCView* pView = GetAMCView();
            if (pView != NULL)
            {
                CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();

                /*
                 * Don't allow the user to close the last persisted view.
                 */
                if (pView->IsPersisted() &&
                    (pAMCDoc != NULL) &&
                    (pAMCDoc->GetNumberOfPersistedViews() == 1))
                {
                    MMCMessageBox (IDS_CantCloseLastPersistableView);
                    return;
                }

                pView->CloseView();
            }
        }
    }

    CMDIChildWnd::OnClose();
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnUpdateFrameMenu
 *
 * WM_UPDATEFRAMEMENU handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnUpdateFrameMenu(BOOL bActivate, CWnd* pActivateWnd,
    HMENU hMenuAlt)
{
    ASSERT_VALID (this);
    DECLARE_SC (sc, _T("CChildFrame::OnUpdateFrameMenu"));

    // let the base class select the right menu
    CMDIChildWnd::OnUpdateFrameMenu (bActivate, pActivateWnd, hMenuAlt);

    // make sure the child has the WS_SYSMENU bit
    // (it won't if it's created maximized)
    ModifyStyle (0, WS_SYSMENU);

    // by now, the right menu is selected; reflect it to the toolbar
    CMainFrame* pFrame = static_cast<CMainFrame *>(GetParentFrame ());
    ASSERT_KINDOF (CMainFrame, pFrame);
    pFrame->NotifyMenuChanged ();

    // Add the menubuttons only on activate, the CMenubar
    // removes all menus during deactivate.
    if (bActivate)
    {
        ASSERT(NULL != m_spMenuButtonsMgr.get());
        if (NULL != m_spMenuButtonsMgr.get())
        {
            // Now add the menu buttons to main menu
            sc = m_spMenuButtonsMgr->ScAddMenuButtonsToMainMenu();
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnGetIcon
 *
 * WM_GETICON handler for CChildFrame.
 *
 * NOTE: the control over the icon remains with the callee - it is responsible
 *       for releasing the resource. Coller should never release the returned
 *       handle
 *--------------------------------------------------------------------------*/

LRESULT CChildFrame::OnGetIcon (WPARAM wParam, LPARAM lParam)
{
    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    /*
     * use the custom icon if we have one
     */
    if ((pDoc != NULL) && pDoc->HasCustomIcon())
        return ((LRESULT) pDoc->GetCustomIcon ((wParam == ICON_BIG)));

    /*
     * no custom icon, use the default icon
     */
    const int cxIcon = GetSystemMetrics ((wParam == ICON_BIG) ? SM_CXICON : SM_CXSMICON);
    const int cyIcon = GetSystemMetrics ((wParam == ICON_BIG) ? SM_CYICON : SM_CYSMICON);

    // use cached copy - it never changes
    // do not delete this ever - since we only have one copy,
    // we do not leak. releassing is expensive and does not pay off
    static HICON s_hMMCIcon = (HICON)::LoadImage (AfxGetResourceHandle(),
                                                  MAKEINTRESOURCE (IDR_AMCTYPE),
                                                  IMAGE_ICON, cxIcon, cyIcon, 0);

    return (LRESULT)s_hMMCIcon;
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSysCommand
 *
 * WM_SYSCOMMAND handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID)
    {
        case ID_CUSTOMIZE_VIEW:
            OnCustomizeView();
            break;

        case SC_CLOSE:
        {
            // eat Ctrl+F4 in SDI simulation mode...
            if (AMCGetApp()->GetMode() == eMode_User_SDI)
                break;

            // ...or if Close is disabled or doesn't exist on the system menu
            CMenu*  pSysMenu    = GetSystemMenu (FALSE);
            UINT    nCloseState = pSysMenu->GetMenuState (SC_CLOSE, MF_BYCOMMAND);

            if ((nCloseState == 0xFFFFFFFF) ||
                (nCloseState & (MF_GRAYED | MF_DISABLED)))
                break;

            // all systems go, let MDI have it
            CMDIChildWnd::OnSysCommand(nID, lParam);
            break;
        }

        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
            // eat Ctrl+(Shift+)Tab and Ctrl+(Shift+)F6 in SDI simulation mode
            if (AMCGetApp()->GetMode() != eMode_User_SDI)
                CMDIChildWnd::OnSysCommand(nID, lParam);
            break;

        default:
            CMDIChildWnd::OnSysCommand(nID, lParam);
            break;
    }

}


/*+-------------------------------------------------------------------------*
 * CChildFrame::GetDefaultAccelerator
 *
 *
 *--------------------------------------------------------------------------*/

HACCEL CChildFrame::GetDefaultAccelerator()
{
    // use document specific accelerator table ONLY
    // Dont use CFrameWnd::m_hAccel, because we don't base accelerators
    // on document type but rather on mode. This is taken care of
    // in CAMCDoc.
    return (NULL);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSetMessageString
 *
 * WM_SETMESSAGESTRING handler for CChildFrame.
 *--------------------------------------------------------------------------*/

LRESULT CChildFrame::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
    /*
     * if this we're going to set the idle message string and we've
     * been given a custom status line string, use that one instead
     */
    if ((wParam == AFX_IDS_IDLEMESSAGE) && !m_strStatusText.IsEmpty())
    {
        ASSERT (lParam == 0);
        wParam = 0;
        lParam = (LPARAM)(LPCTSTR) m_strStatusText;
    }

    // sometimes we'll get a WM_SETMESSAGESTRING after being destroyed,
    // don't pass it through or we'll crash inside the status bar code
    if (m_fDestroyed)
        return (0);

    return (CMDIChildWnd::OnSetMessageString (wParam, lParam));
}

void CChildFrame::ToggleStatusBar ()
{
    m_StatusDockSite.Toggle();
    RenderDockSites();

    if (m_StatusDockSite.IsVisible())
        UpdateStatusText ();
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnMDIActivate
 *
 * WM_MDIACTIVATE handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd)
{
    DECLARE_SC (sc, _T("CChildFrame::OnMDIActivate"));
    SetChildFrameActive(bActivate);

    CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

    sc = ScCheckPointers(m_pAMCView, E_UNEXPECTED);
    if (sc)
        return;

    if (bActivate)
    {
        // If the window being de-activated is not of childframe type then this
        // is the first active view (childframe).
        bool bFirstActiveView = pDeactivateWnd ? (FALSE == pDeactivateWnd->IsKindOf (RUNTIME_CLASS (CChildFrame)))
                                               : true;
        sc = m_pAMCView->ScFireEvent(CAMCViewObserver::ScOnActivateView, m_pAMCView, bFirstActiveView);

        // if activation changes - need to set frame to dirty
        CAMCDoc* pDoc = CAMCDoc::GetDocument ();

        if (pDoc == NULL)
            (sc = E_UNEXPECTED).TraceAndClear();
        else
        {
            pDoc->SetFrameModifiedFlag (true);
        }
    }
    else
    {
        // If the window being activated is not of childframe type then this is
        // the last active view (childframe).
        bool bLastActiveView = pActivateWnd ? (FALSE == pActivateWnd->IsKindOf (RUNTIME_CLASS (CChildFrame)))
                                            : true;
        sc = m_pAMCView->ScFireEvent(CAMCViewObserver::ScOnDeactivateView, m_pAMCView, bLastActiveView);
    }

    if (sc)
        return;

    /*
     * Notify snap-ins of an activation change
     */
    NotifyCallback (NCLBK_ACTIVATE, bActivate, 0);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::SendMinimizeNotification
 *
 *
 *--------------------------------------------------------------------------*/

void CChildFrame::SendMinimizeNotification (bool fMinimized) const
{
        if(m_pAMCView != NULL)
            m_pAMCView->ScOnMinimize(m_fCurrentlyMinimized);

}


/*+-------------------------------------------------------------------------*
 * CChildFrame::NotifyCallback
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CChildFrame::NotifyCallback (
    NCLBK_NOTIFY_TYPE   event,
    LONG_PTR            arg,
    LPARAM              param) const
{
    if (m_pAMCView == NULL)
        return (E_FAIL);

    HNODE hNode = m_pAMCView->GetSelectedNode();

    if (hNode == NULL)
        return (E_FAIL);

    INodeCallback*  pNodeCallback = m_pAMCView->GetNodeCallback();

    if (pNodeCallback == NULL)
        return (E_FAIL);

    return (pNodeCallback->Notify (hNode, event, arg, param));
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnNcPaint
 *
 * WM_NCPAINT handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnNcPaint()
{
    Default();
    DrawFrameCaption (this, m_fCurrentlyActive);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnNcActivate
 *
 * WM_NCACTIVATE handler for CChildFrame.
 *--------------------------------------------------------------------------*/

BOOL CChildFrame::OnNcActivate(BOOL bActive)
{
    BOOL rc = CMDIChildWnd::OnNcActivate(bActive);

    m_fCurrentlyActive = bActive;
    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSetText
 *
 * WM_SETTEXT handler for CChildFrame.
 *--------------------------------------------------------------------------*/

LRESULT CChildFrame::OnSetText (WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = Default();
    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::ActivateFrame
 *
 *
 *--------------------------------------------------------------------------*/

void CChildFrame::ActivateFrame(int nCmdShow /*= -1*/)
{
    if ((nCmdShow == -1) && !m_fCreateVisible)
        nCmdShow = SW_SHOWNOACTIVATE;
    /*
     * When this flag [m_fCreateVisible] is set, the frame will show itself with the
     * SW_SHOWMINNOACTIVE flag instead of the default flag.  Doing this will
     * avoid the side effect of restoring the currently active child frame
     * if it is maximized at the time the new frame is created invisibly.
     */
    // The SW_SHOWMINNOACTIVE was changed to SW_SHOWNOACTIVATE.
    // It does preserve the active window from mentioned side effect,
    // plus it also allows scripts (using Object Moded) to create invisible views,
    // position and then show them as normal (not minimized) windows,
    // thus providing same result as creating visible and then hiding the view.
    // While minimized window must be restored first in order to change their position.

    CMDIChildWnd::ActivateFrame (nCmdShow);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::SetCreateVisible
 *
 *
 *--------------------------------------------------------------------------*/

bool CChildFrame::SetCreateVisible (bool fCreateVisible)
{
    bool fOldState = m_fCreateVisible;
    m_fCreateVisible = fCreateVisible;

    return (fOldState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\cclvctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cclvctl.cpp
//
//--------------------------------------------------------------------------

// cclvctl.cpp : implementation file
//

#include "stdafx.h"
#include "cclvctl.h"
#include <malloc.h>
#include <wtypes.h>
#include "amcdoc.h"
#include "amcview.h"
#include "mmcres.h"
#include "treectrl.h"
#include "util.h"
#include "amcpriv.h"
#include "rsltitem.h"
#include "columninfo.h"
#include "bitmap.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//############################################################################
//############################################################################
//
// Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagList(TEXT("List View"), TEXT("List View"));
CTraceTag tagListImages(_T("Images"), _T("List view (draw when changed)"));
CTraceTag tagColumn(TEXT("Columns"), TEXT("Columns"));
#endif //DBG



DEBUG_DECLARE_INSTANCE_COUNTER(CAMCListView);


//############################################################################
//############################################################################
//
//  Implementation of class CColumnsBase
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CColumnsBase
 *
 *
 * PURPOSE: Implements the Columns automation interface.
 *
 *+-------------------------------------------------------------------------*/
class CColumnsBase :
    public CMMCIDispatchImpl<Columns>,
    public CTiedComObject<CCCListViewCtrl>,
    public CTiedObject      // this is for enumerators
{
protected:

    typedef CCCListViewCtrl CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CColumnsBase)
    END_MMC_COM_MAP()

    // Columns interface
public:
    MMC_METHOD2(Item,           long /*Index*/, PPCOLUMN /*ppColumn*/);

    // properties
    MMC_METHOD1(get_Count, PLONG /*pCount*/);
};


// this typedefs the real CColumns class. Implements get__NewEnum using CMMCEnumerator
typedef CMMCNewEnumImpl<CColumnsBase, int> CColumns;


/*+-------------------------------------------------------------------------*
 * class CColumn
 *
 *
 * PURPOSE: Implements the Node automation interface, for a result node
 *
 *+-------------------------------------------------------------------------*/
class CColumn :
    public CMMCIDispatchImpl<Column>,
    public CTiedComObject<CCCListViewCtrl>,
    public CListViewObserver
{
protected:

    typedef CCCListViewCtrl CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CColumn)
    END_MMC_COM_MAP()

    // Column methods
public:
    MMC_METHOD1_PARAM( Name, /*[out, retval]*/ BSTR* /*Name*/ , m_iIndex);
    MMC_METHOD1_PARAM( get_Width, /*[out, retval]*/ PLONG /*Width*/, m_iIndex);
    MMC_METHOD1_PARAM( put_Width, /*[in]*/ long /*Width*/, m_iIndex);
    MMC_METHOD1_PARAM( get_DisplayPosition, /*[out, retval]*/ PLONG /*DisplayPosition*/, m_iIndex);
    MMC_METHOD1_PARAM( put_DisplayPosition, /*[in]*/ long /*Index*/, m_iIndex);
    MMC_METHOD1_PARAM( get_Hidden, /*[out, retval]*/ PBOOL /*Hidden*/, m_iIndex );
    MMC_METHOD1_PARAM( put_Hidden, /*[in]*/ BOOL /*Hidden*/ , m_iIndex );
    MMC_METHOD1_PARAM( SetAsSortColumn, /*[in]*/ ColumnSortOrder /*SortOrder*/, m_iIndex);
    MMC_METHOD1_PARAM( IsSortColumn, PBOOL /*IsSortColumn*/, m_iIndex);

    CColumn() : m_iIndex(-1)  { }
    void SetIndex(int iIndex) { m_iIndex = iIndex; }

    // observed events
    // called when column is inserted to listview
    virtual ::SC ScOnListViewColumnInserted (int nIndex);
    // called when column is deleted from listview
    virtual ::SC ScOnListViewColumnDeleted (int nIndex);

private: // implementation
    int  m_iIndex;
};

/////////////////////////////////////////////////////////////////////////////
// CAMCHeaderCtrl
// This class is defined just to intercept the header's set focus

BEGIN_MESSAGE_MAP(CAMCHeaderCtrl, CHeaderCtrl)
    ON_WM_SETFOCUS()
	ON_WM_SETCURSOR()
END_MESSAGE_MAP()

void CAMCHeaderCtrl::OnSetFocus(CWnd *pOldWnd)
{
    // Make sure list view is made active, but don't steal focus from header
    CAMCListView* pwndParent = dynamic_cast<CAMCListView*>(GetParent());
    ASSERT(pwndParent != NULL);
    pwndParent->GetParentFrame()->SetActiveView(pwndParent, FALSE);

    CHeaderCtrl::OnSetFocus(pOldWnd);
}

//+-------------------------------------------------------------------
//
//  Member:     CAMCHeaderCtrl::OnSetCursor
//
//  Synopsis:   If the cursor is on hidden column do not show the divider
//              cursor. WM_SETCURSOR handler.
//
//  Arguments:  [pWnd]     - window which generated the message.
//              [nHitTest] - hittest flag.
//              [message]  -
//
//  Returns:    BOOL, TRUE stop processing further.
//
//--------------------------------------------------------------------
BOOL CAMCHeaderCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    // 1. If the mouse is on the header window.
	if ( (nHitTest == HTCLIENT) && (pWnd == this) )
	{
        // 2. Get its position.
		CPoint pt (GetMessagePos());
		ScreenToClient (&pt);

        // 3. Do a hit test
		HDHITTESTINFO hitinfo;
		ZeroMemory(&hitinfo, sizeof(hitinfo));
		hitinfo.pt = pt;

		if (SendMessage(HDM_HITTEST, 0, reinterpret_cast<LPARAM>(&hitinfo) ) != -1)
		{
            // 4. If the mouse is on a column of zero width and it is hidden do not
            //    process the message further.

            // 4.a) HHT_ONDIVOPEN : pt is on the divider of an item that has a width of zero.
            //   b) HHT_ONDIVIDER : pt is on the divider between two header items.
		    if ( ( (HHT_ONDIVOPEN | HHT_ONDIVIDER) & hitinfo.flags) &&
				 (IsColumnHidden(hitinfo.iItem /*column index*/)) )
			{
                // Set default arrow cursor.
                ::SetCursor(::LoadCursor(NULL, IDC_ARROW) );
				return TRUE;
			}
		}

	}

    return CHeaderCtrl::OnSetCursor(pWnd, nHitTest, message);
}

//+-------------------------------------------------------------------
//
//  Member:     CAMCHeaderCtrl::IsColumnHidden
//
//  Synopsis:   Is the given column hidden?
//
//  Arguments:  [iCol]     - given column
//
//  Returns:    bool
//
//--------------------------------------------------------------------
bool CAMCHeaderCtrl::IsColumnHidden(int iCol)
{
    // Get param to determine if column is hidden.
    HDITEM hdItem;
    ZeroMemory(&hdItem, sizeof(hdItem));
    hdItem.mask    = HDI_LPARAM;

    if (GetItem(iCol, &hdItem))
	{
		CHiddenColumnInfo hci (hdItem.lParam);

		if (hci.fHidden)
			return true;
	}
	
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// CAMCListView

const UINT CAMCListView::m_nColumnPersistedDataChangedMsg   = ::RegisterWindowMessage (_T("CAMCListView::OnColumnPersistedDataChanged"));

BEGIN_MESSAGE_MAP(CAMCListView, CListView)
    //{{AFX_MSG_MAP(CAMCListView)
    ON_WM_CREATE()
    ON_WM_KEYUP()
    ON_WM_KEYDOWN()
    ON_WM_SYSKEYDOWN()
    ON_WM_SYSCHAR()
    ON_NOTIFY_REFLECT(LVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(LVN_BEGINRDRAG, OnBeginRDrag)
    ON_WM_MOUSEACTIVATE()
    ON_WM_SETFOCUS()
    ON_WM_PAINT()
    ON_WM_SIZE()
    ON_NOTIFY(HDN_BEGINTRACK, 0, OnBeginTrack)
    //}}AFX_MSG_MAP

    ON_REGISTERED_MESSAGE (m_nColumnPersistedDataChangedMsg, OnColumnPersistedDataChanged)

END_MESSAGE_MAP()

BOOL CAMCListView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |= WS_BORDER |
                WS_CLIPSIBLINGS |
                WS_CLIPCHILDREN |
                LVS_SHAREIMAGELISTS |
                LVS_SINGLESEL |
                LVS_EDITLABELS |
                LVS_SHOWSELALWAYS |
                LVS_REPORT;

    return CListView::PreCreateWindow(cs);
}

int CAMCListView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, TEXT("CAMCListView::OnCreate"));

    if (CListView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // Get parent's CWnd for command routing
    m_pAMCView = ::GetAMCView (this);

    /*
     * add extended list view styles (these can't be handled in PreCreateWindow)
     */
    SetExtendedListViewStyle (LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP |
                              LVS_EX_LABELTIP);

    sc = ScRegisterAsDropTarget(m_hWnd);
    if (sc)
        return (-1);

	AddObserver(static_cast<CListViewActivationObserver &>(*m_pAMCView));

    return 0;
}

void CAMCListView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if ((VK_CONTROL == nChar) || (VK_SHIFT == nChar))
    {
        ASSERT (m_pAMCView != NULL);
        m_pAMCView->SendMessage (WM_KEYUP, nChar, MAKELPARAM (nRepCnt, nFlags));
        return;
    }

    CListView::OnKeyUp(nChar, nRepCnt, nFlags);
}

//+-------------------------------------------------------------------
//
//  Member:     OnKeyDown
//
//  Synopsis:   Handle any non-system keys (Without ALT).
//              (Below handle Ctrl+A to multi-select
//               all items in list view).
//
//  Arguments:
//
//  Returns:    None.
//
//
//--------------------------------------------------------------------
void CAMCListView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
    case 'A':
    {
        // Check if LV is multi-sel enabled.
		if (GetStyle() & LVS_SINGLESEL)
			break;

        SHORT nKeyState = GetKeyState(VK_CONTROL);
        // Key is down if higher order bits are set in nKeyState.
        nKeyState = nKeyState >> sizeof(SHORT) * 4;
        if (nKeyState == 0)
            break;

        // Ctrl+A --> Select all items in list view.
        LV_ITEM lvi;
        lvi.stateMask = lvi.state = LVIS_SELECTED;
        for (int i = 0; i < GetListCtrl().GetItemCount(); ++i)
        {
            // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
            if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(i), (LPARAM)(LV_ITEM FAR *)&lvi))
                return;
        }

        return;
    }

    default:
        break;
    }

    CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCListView::OnSysKeyDown
 *
 * PURPOSE: Handle the WM_SYSCHAR message.
 *
 * PARAMETERS:
 *    UINT  nChar :
 *    UINT  nRepCnt :
 *    UINT  nFlags :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCListView::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if ((VK_LEFT == nChar) || (VK_RIGHT == nChar))
    {
        ASSERT (m_pAMCView != NULL);
        m_pAMCView->SendMessage (WM_SYSKEYDOWN, nChar, MAKELPARAM (nRepCnt, nFlags));
        return;
    }

    CListView::OnSysKeyDown(nChar, nRepCnt, nFlags);
}


void CAMCListView::OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (VK_RETURN == nChar)
    {
        return; // don't call base class, otherwise a beep occurs. Handled by LVN_KEYDOWN
    }


    CListView::OnSysChar(nChar, nRepCnt, nFlags);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCListView::OnPaint
 *
 * PURPOSE: Displays a default message when no items are present in the list.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCListView::OnPaint()
{
    Default();

    if (NeedsCustomPaint())
    {
        COLORREF clrText = ::GetSysColor(COLOR_WINDOWTEXT);
        COLORREF clrTextBk = ::GetSysColor(COLOR_WINDOW);

        CClientDC dc(this);
        // Save dc state
        int nSavedDC = dc.SaveDC();

        CRect rc;
        GetClientRect(&rc);

        CHeaderCtrl* pHC = GetHeaderCtrl();
        if (pHC != NULL &&  ((GetListCtrl().GetStyle() & (LVS_REPORT | LVS_LIST | LVS_SMALLICON | LVS_ICON)) ==LVS_REPORT) ) // make sure that the style is report
        {
            CRect rcH;
            pHC->GetItemRect(0, &rcH);
            rc.top += rcH.bottom;
        }
        rc.top += 10;

        CString strText;
        strText.LoadString(IDS_EMPTY_LIST_MESSAGE); // The message

        // create the font - we do not cache it.
        LOGFONT lf;
        CFont font;
        SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);
        font.CreateFontIndirect(&lf);

        dc.SelectObject(&font); // select the font
        dc.SetTextColor(clrText);
        dc.SetBkColor(clrTextBk);
        dc.FillRect(rc, &CBrush(clrTextBk));

        dc.DrawText(strText, -1, rc, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_NOCLIP);

        // Restore dc
        dc.RestoreDC(nSavedDC);
    }

    // Do not call CListCtrl::OnPaint() for painting messages (Default was called above)
}



/*+-------------------------------------------------------------------------*
 * CAMCListView::OnSize
 *
 * WM_SIZE handler for CAMCListView.
 *--------------------------------------------------------------------------*/

void CAMCListView::OnSize(UINT nType, int cx, int cy)
{
        CListView::OnSize(nType, cx, cy);

        /*
         * if we're custom painting, we need to redraw the list
         * because we need to keep the text horizontally centered
         */
        if (NeedsCustomPaint())
                Invalidate ();
}


/*+-------------------------------------------------------------------------*
 * CAMCListView::NeedsCustomPaint
 *
 * Determines whether we want to draw "There are no items..." in the list
 * view.
 *--------------------------------------------------------------------------*/

bool CAMCListView::NeedsCustomPaint()
{
    CHeaderCtrl* pHC = GetHeaderCtrl();

        // we check the column counts because there is a transition state when no columns are
        // present during which we shouldn't draw anything.

    return (GetListCtrl().GetItemCount() <= 0 && (pHC != NULL) && pHC->GetItemCount()>0);
}


BOOL CAMCListView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (CListView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view did't handle it, give parent view a chance
    if (m_pAMCView != NULL)
    {
        // OnCmdMsg is public in CCmdTarget, but protected in CView
        // cast around it (arghhh!)
        return ((CWnd*)m_pAMCView)->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    }

    return FALSE;
}

void CAMCListView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    if (lHint == VIEW_UPDATE_DELETE_EMPTY_VIEW)
        m_pAMCView->OnDeleteEmptyView();
}

int CAMCListView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
    // see CAMCTreeView::OnMouseActivate for an explanation of focus churn
    // avoidance.
    return (MA_ACTIVATE);
}

void CAMCListView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    DECLARE_SC(sc, TEXT("CAMCListView::OnActivateView"));

    #ifdef DBG
    Trace(tagList, _T("ListView::OnActivateView (%s, pAct=0x%08x, pDeact=0x%08x))\n"),
         (bActivate) ? _T("true") : _T("false"), pActivateView, pDeactiveView);
    #endif

    if ( (pActivateView != pDeactiveView) &&
         (bActivate) )
    {
        sc = ScFireEvent(CListViewActivationObserver::ScOnListViewActivated);
        if (sc)
            sc.TraceAndClear();
    }

    CListView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

void CAMCListView::OnSetFocus(CWnd* pOldWnd)
{
    /*
     * if this view has the focus, it should be the active view
     */
    CFrameWnd *pParentFrame = GetParentFrame();

    if(pParentFrame != NULL)
        pParentFrame->SetActiveView (this);

    CListView::OnSetFocus(pOldWnd);

    // If we are currently reparented, then we need to send a setfocus notify
    // to our current parent. This is needed because the listview control caches its
    // parent window on creation and continues to sends all notifications to it.
    if (dynamic_cast<CAMCView*>(GetParent()) == NULL)
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = m_hWnd;
        nmhdr.idFrom   = GetDlgCtrlID();
        nmhdr.code     = NM_SETFOCUS;

        ::SendMessage(GetParent()->m_hWnd, WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCListView::OnKeyboardFocus
 *
 * PURPOSE: Whenever the user switches focus using the TAB keys ONLY, to the
 *          list view control, make sure that at least one item is highlighted.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCListView::OnKeyboardFocus(UINT nState, UINT nStateMask)
{
    CListCtrl &lc = GetListCtrl();

    // Make sure an item has the focus (unless the list is empty)
    if (lc.GetNextItem(-1,LVNI_FOCUSED) == -1 && lc.GetItemCount() > 0)
    {
        /*
         * It would be convenient to use
         *
         *      CListCtrl::SetItemState (int nIndex, UINT nState, UINT nMask)
         *
         * here, but MFC uses LVM_SETITEM for that overload, which
         * doesn't work for virtual lists.  For the overload we use
         * here, MFC uses LVM_SETITEMSTATE, which works fine for
         * virtual lists.
         */
        LV_ITEM lvi;
        lvi.stateMask = nStateMask;
        lvi.state     = nState;

        lc.SetItemState (0, &lvi);
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::OnBeginTrack
//
//  Synopsis:    HDN_BEGINTRACK handler, due to our improper message routing
//               (handling all messages to CAMCView) this message gets lost
//               (CAMCListView::OnCmdMsg passes it to underlying view which
//               handles it & so we handle it here separately.
//
//  Arguments:   [pNotifyStruct] -
//               [result]        -
//
//--------------------------------------------------------------------
void CAMCListView::OnBeginTrack(NMHDR * pNotifyStruct, LRESULT * result)
{
	if (!pNotifyStruct || !result)
		return;

	*result = FALSE;

    NMHEADER* nmh = (NMHEADER*)pNotifyStruct;

    SC sc = ScOnColumnsAttributeChanged(nmh, HDN_BEGINTRACK);
    if (sc)
    {
        sc.TraceAndClear();
        return;
    }

	// S_FALSE : dont allow the change
    if (sc == SC(S_FALSE))
        *result = TRUE;

	return;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::IsColumnHidden
//
//  Synopsis:    Get the LPARAM and check if given column is hidden.
//
//  Arguments:   [iCol] -
//
//  Returns:     bool
//
//--------------------------------------------------------------------
bool CAMCListView::IsColumnHidden(int iCol) const
{
    CAMCHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();

    if (pHeaderCtrl)
		return pHeaderCtrl->IsColumnHidden(iCol);

    return false;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScGetColumnInfoList
//
//  Synopsis:    Get the CColumnInfoList from current list-view.
//
//  Arguments:   [pColumnsList] - [out param], ptr to CColumnsInfoList*
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScGetColumnInfoList (CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CAMCListView::ScGetColumnInfoList"));
    sc = ScCheckPointers(pColumnsList);
    if (sc)
        return sc;

    pColumnsList->clear();

    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;
    int cColumns = pHeader->GetItemCount();

    typedef std::auto_ptr<int> IntArray;

    IntArray spColOrder = IntArray(new int[cColumns]);
    int *pColOrder = spColOrder.get();  // Use a non-smart ptr for ease of use.
    sc = ScCheckPointers(pColOrder, E_OUTOFMEMORY);
    if (sc)
        return sc;

    sc = pHeader->GetOrderArray(pColOrder, cColumns) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    for (int i = 0; i < cColumns; i++)
    {
        // Get the data from header control.
        HDITEM hdItem;
        ZeroMemory(&hdItem, sizeof(hdItem));
        hdItem.mask = HDI_WIDTH | HDI_LPARAM;
        sc = pHeader->GetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
        if (sc)
            return sc;

        // Save the visual index of the ith col
        CColumnInfo colInfo;
        colInfo.SetColIndex(pColOrder[i]);

        // Save the width
		CHiddenColumnInfo hci (hdItem.lParam);

        if (hci.fHidden)
        {
            colInfo.SetColHidden();
            colInfo.SetColWidth(hci.cx);
        }
        else
            colInfo.SetColWidth(hdItem.cxy);

        pColumnsList->push_back(colInfo);
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScModifyColumns
//
//  Synopsis:    Modify the header-control columns with given CColumnsInfoList.
//
//  Arguments:   [colInfoList] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScModifyColumns (const CColumnInfoList& colInfoList)
{
    DECLARE_SC(sc, _T("CAMCListView::ScModifyColumns"));
    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    CAMCView *pAMCView = GetAMCView();
    sc = ScCheckPointers(pHeader, pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // This method is called due to following conditions:
    // 1. Just before inserting first item into list-view.
    // 2. If there are no items in list-view then it is empty LV,
    //    in that case this method is called during OnPaint.
    // 3. The IHeaderCtrlPrivate on CNodeInitObject can also call this method.

    // Once a node is selected & result-pane is setup, case1 or case2 above
    // should happen only once. To avoid multiple calls we use below flag which
    // says that we have attempted to restore the columns from given data.
    // case1 & case2 use this to determine whether to call this method.
    SetColumnsNeedToBeRestored();

    // Check for column consistency. If persisted # of cols & actual # of cols
    // inserted are different then ask column-data to be deleted.
    int cColumns = pHeader->GetItemCount();
    if (colInfoList.size() != cColumns)
    {
        sc = pAMCView->ScDeletePersistedColumnData();
        return sc;
    }

    typedef std::auto_ptr<int> IntArray;

    IntArray spColOrder = IntArray(new int[cColumns]);
    int *pColOrder = spColOrder.get();  // Use a non-smart ptr for ease of use.
    sc = ScCheckPointers(pColOrder, E_OUTOFMEMORY);
    if (sc)
        return sc;

    // Now restore the headers.
    {
        m_bColumnsBeingRestored = true;    // should set this false before leaving this funcion.

        CColumnInfoList::iterator itColInfo;
        int i = 0;

        // Get width/order of each column.
        for (itColInfo = colInfoList.begin(), i = 0;
             itColInfo != colInfoList.end();
             ++itColInfo, i++)
        {
            pColOrder[i] = itColInfo->GetColIndex();

            // First set/reset the lparam
            HDITEM hdItem;
            ZeroMemory(&hdItem, sizeof(hdItem));

            if (itColInfo->IsColHidden())
            {
                // We set the width first and then LPARAM because
                // If we set lparam first then when we set width
                // CAMCView::Notify HDN_ITEMCHANGING. Now we
                // examine the lparam of the item to see if it is hidden.
                // So setting lparam first and then setting width
                // for hiding columns will not work.
                hdItem.mask = HDI_WIDTH;
                hdItem.cxy = 0;
                sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                if (sc)
                    goto Error;

				CHiddenColumnInfo hci (itColInfo->GetColWidth(), true);

                hdItem.mask = HDI_LPARAM;
                hdItem.lParam = hci.lParam;
                sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                if (sc)
                    goto Error;
            }
            else
            {
				CHiddenColumnInfo hci (itColInfo->GetColWidth(), false);

                // Here we need to clear the hidden flag in lParam
                // before changing width So that hidden columns will be made visible.
                hdItem.mask = HDI_LPARAM;
                hdItem.lParam = hci.lParam;
                sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                if (sc)
                    goto Error;

                if ( AUTO_WIDTH == itColInfo->GetColWidth())
                {
                    // If the column is hidden and made visible we do not know its width.
                    // With ListView_SetColumnWidth passing AUTO_WIDTH for width calculates
                    // width automatically. Header_SetItem cannot do this.
                    sc = ListView_SetColumnWidth(GetSafeHwnd(),
                                                 pColOrder[i],
                                                 LVSCW_AUTOSIZE_USEHEADER) ? S_OK : E_FAIL;
                    if (sc)
                        goto Error;
                }
                else
                {
                    hdItem.mask = HDI_WIDTH;
                    hdItem.cxy = itColInfo->GetColWidth();
                    sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                    if (sc)
                        goto Error;
                }
            }
        }

        // Set the order
        sc = pHeader->SetOrderArray(cColumns, pColOrder) ? S_OK : E_FAIL;
        if (sc)
            goto Error;

		// Now redraw the list view
		InvalidateRect(NULL, TRUE);
    }


Cleanup:
    m_bColumnsBeingRestored = false;

    return (sc);
Error:
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScGetDefaultColumnInfoList
//
//  Synopsis:    Get the default column settings.
//
//  Arguments:   [columnInfoList] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScGetDefaultColumnInfoList (CColumnInfoList& columnInfoList)
{
    DECLARE_SC(sc, _T("CAMCListView::ScRestoreDefaultColumnSettings"));
    if (m_defaultColumnInfoList.size() <= 0)
        return (sc = E_UNEXPECTED);

    columnInfoList = m_defaultColumnInfoList;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScSaveColumnInfoList
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScSaveColumnInfoList ()
{
    DECLARE_SC(sc, _T("CAMCListView::ScSaveColumnInfoList"));

    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    CAMCView *pAMCView = GetAMCView();
    sc = ScCheckPointers(pHeader, pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the column data & give it to CAMCView so that it can
    // inform NodeMgr (thro NodeCallback) about new data.
    CColumnInfoList colInfoList;
    sc = ScGetColumnInfoList (&colInfoList);
    if (sc)
        return sc;

    sc = pAMCView->ScColumnInfoListChanged(colInfoList);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScOnColumnsAttributeChanged
//
//  Synopsis:    Column width/order has changed so get the column data
//               and ask the nodemgr to persist it.
//
//  Arguments:   NMHEADER* - the header change information.
//               code      - the HDN_* notification.
//
//  Returns:     SC, S_OK     - allow the change.
//                   S_FALSE  - dont allow the change.
//
//--------------------------------------------------------------------
SC CAMCListView::ScOnColumnsAttributeChanged (NMHEADER *pNMHeader, UINT code)
{
    DECLARE_SC(sc, _T("CAMCListView::ScOnColumnsAttributeChanged"));
    Trace (tagColumn, _T("CAMCListView::ScOnColumnsAttributeChanged"));

    // If we are applying persisted column data to the header control
    // so allow those changes.
    if (m_bColumnsBeingRestored)
        return sc;

	sc = ScCheckPointers(pNMHeader, pNMHeader->pitem);
	if (sc)
		return sc;

    // User is trying to drag a column make sure it is not a hidden column.
    if ( (code == HDN_BEGINTRACK) && (pNMHeader->pitem->mask & HDI_WIDTH) )
    {
        sc = IsColumnHidden(pNMHeader->iItem) ? S_FALSE : S_OK;
        return sc;
    }

    /*
     * At this point the code is HDN_ENDTRACK (width change completed) or
     * during HDN_ENDDRAG (order changing but not completed).
	 * During both these messages header-control has not updated internal
	 * data, so we post a message & save on message handler.
     */
    if ((code == HDN_ENDDRAG) || (code == HDN_ENDTRACK))
    {
        PostMessage(m_nColumnPersistedDataChangedMsg);
        return sc;
    }

	// Too risky to return error instead at this point, enable this for Blackcomb Beta1.
	// sc = E_FAIL;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::OnColumnPersistedDataChanged
//
//  Synopsis:    CAMCListView::m_nColumnDataChangedMsg registered message handler.
//               Column width/order has changed so get the column data
//               and ask the nodemgr to persist it.
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CAMCListView::OnColumnPersistedDataChanged (WPARAM, LPARAM)
{
    DECLARE_SC(sc, _T("CAMCListView::OnColumnPersistedDataChanged"));
    Trace (tagColumn, _T("CAMCListView::OnColumnPersistedDataChanged"));

    if (m_bColumnsBeingRestored)
        return 0;

    sc = ScSaveColumnInfoList();
    if (sc)
        return 0;

    return (0);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScRestoreColumnsFromPersistedData
//
//  Synopsis:    Get the persisted data for current list-view headers
//               and apply them.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScRestoreColumnsFromPersistedData ()
{
    DECLARE_SC(sc, _T("CAMCListView::ScRestoreColumnsFromPersistedData"));
    Trace (tagColumn, _T("CAMCListView::ScRestoreColumnsFromPersistedData"));

    if (! AreColumnsNeedToBeRestored())
        return sc;

    /*
     * When a node is selected the snapin initially inserts columns with
     * some initial settings which is the default settings. At this point
     * the list view has the default settings, save it before applying
     * the persisted data.
     */
    sc = ScGetColumnInfoList(&m_defaultColumnInfoList);
    if (sc)
        return sc;

    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    CAMCView *pAMCView = GetAMCView();
    sc = ScCheckPointers(pHeader, pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the column data.
    CColumnInfoList colInfoList;
    sc = pAMCView->ScGetPersistedColumnInfoList(&colInfoList);

    // Whether there is data or not we tried to restore columns.
    SetColumnsNeedToBeRestored();

    if (sc.IsError() || (sc == SC(S_FALSE)) )
        return sc;

    // Modify headers.
    sc = ScModifyColumns(colInfoList);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScResetColumnStatusData
//
//  Synopsis:    Reset the data used to keep track of hidden column state,
//               columns-restored state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScResetColumnStatusData ()
{
    DECLARE_SC(sc, _T("CAMCListView::ScResetColumnStatusData"));

    SetColumnsNeedToBeRestored(true);
    m_defaultColumnInfoList.clear();

    return (sc);
}


BOOL CAMCListView::ChangePane(AMCNavDir eDir)
{
    /*
     * NOTE: We need to get the header control before we get the focus window.
     *
     * The first time GetHeaderCtrl is called, it will subclass the non-MFC
     * header window with an MFC class.  Doing this will put an entry for the
     * header in the permanent window map.  Before GetHeaderCtrl is called,
     * MFC will have never seen the header before, so GetFocus will put an
     * entry in the temporary map.  Temporary CWnd pointers will never match
     * permanent CWnd pointers, even though they wrap the same HWND, so we
     * need to make sure the header is in the permanent map before we do
     * any comparisons.
     */
    CWnd* pwndHeader     = GetHeaderCtrl();
    CWnd* pwndFocus      = GetFocus();
    bool  fFocusOnList   = (pwndFocus == this);
    bool  fFocusOnHeader = (pwndFocus == pwndHeader);

    /*
     * It can't be that both the list and the focus have the focus,
     * although it is possible that neither has the focus.
     */
    ASSERT (!(fFocusOnList && fFocusOnHeader));

    /*
     * If either the list or the header has the focus, then this had
     * better be the active view; if not, it had better not.
     */
    if(!fFocusOnList && !fFocusOnHeader)
        return FALSE;

    /*
     * Set the focus to the header if:
     *
     * 1.  the focus is currently on the list, and
     * 2.  we're moving forward (Tab), and
     * 3.  we're in filter mode
     */
    if (fFocusOnList && (eDir == AMCNAV_NEXT) && IsInFilteredReportMode())
    {
        GetHeaderCtrl()->SetFocus();
        return TRUE;
    }

    /*
     * Otherwise, set the focus to the list if:
     *
     * 1.  the focus is not currently on the list, and
     * 2.  we're moving backward (Shift+Tab)
     */
    // if focus not on list and we're moving backward
    else if (!fFocusOnList && (eDir == AMCNAV_PREV))
    {
        ActivateSelf();
        return TRUE;
    }

    /*
     * didn't change the focus
     */
    return FALSE;
}


BOOL CAMCListView::TakeFocus(AMCNavDir eDir)
{
    if ((eDir == AMCNAV_PREV) && IsInFilteredReportMode())
        GetHeaderCtrl()->SetFocus();
    else
        ActivateSelf();

    ASSERT (GetParentFrame()->GetActiveView() == this);

    return TRUE;
}


/*+-------------------------------------------------------------------------*
 * CAMCListView::ActivateSelf
 *
 * If this isn't currently the active view, then this function makes it the
 * active view; the focus will be set to the list implicitly.
 *
 * If it's already the active view, calling SetActiveView won't set the
 * focus, because it shorts out if the active view isn't changing.  In
 * that case, we have to set the focus ourselves.
 *
 * This function returns true if the list view was made the active view,
 * false if it was already the active view.
 *--------------------------------------------------------------------------*/

bool CAMCListView::ActivateSelf (bool fNotify /* =true */)
{
    CFrameWnd* pwndFrame = GetParentFrame();
    ASSERT (pwndFrame != NULL);

    bool fChangeActiveView = (pwndFrame->GetActiveView() != this);

    if (fChangeActiveView)
        pwndFrame->SetActiveView (this, fNotify);
    else
        SetFocus();

    return (fChangeActiveView);
}


CAMCHeaderCtrl* CAMCListView::GetHeaderCtrl() const
{
    // Is there a header ?
    if (m_header.m_hWnd)
        return (&m_header);

    // if not, try getting it now
    HWND hwndHdr = reinterpret_cast<HWND>(::SendMessage (m_hWnd, LVM_GETHEADER, 0, 0));

    if (hwndHdr != NULL)
    {
        m_header.SubclassWindow(hwndHdr);
        return (&m_header);
    }

    return (NULL);
}


void CAMCListView::SelectDropTarget(int iDropTarget)
{
    if (m_iDropTarget == iDropTarget)
        return;

    CListCtrl& lc = GetListCtrl();

    if (m_iDropTarget != -1)
    {
        // remove hiliting from all items
        // do not use m_iDropTarget - item order and count may be changed already
        int iIndex = -1;
        while ( 0 <= ( iIndex = ListView_GetNextItem(lc, iIndex, LVIS_DROPHILITED) ) )
            ListView_SetItemState(lc, iIndex, 0, LVIS_DROPHILITED);
    }

    if (iDropTarget != -1)
        ListView_SetItemState(lc, iDropTarget, LVIS_DROPHILITED, LVIS_DROPHILITED);

    m_iDropTarget = iDropTarget;
}

/////////////////////////////////////////////////////////////////////////////
// CCCListViewCtrl

DEBUG_DECLARE_INSTANCE_COUNTER(CCCListViewCtrl);

CCCListViewCtrl::CCCListViewCtrl() :
    m_itemCount(0),
    m_nScopeItems(0),
    m_colCount(0),
    m_headerIL (AfxGetResourceHandle(), IDB_SORT),
    m_FontLinker (this)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CCCListViewCtrl);

    // Sort Stuff
    m_sortParams.bAscending = TRUE;
    m_sortParams.nCol = 0;
    m_sortParams.lpListView = this;
    m_sortParams.spResultCompare = NULL;
    m_sortParams.spResultCompareEx = NULL;
    m_sortParams.lpUserParam = NULL;
    m_sortParams.bLexicalSort = FALSE;
    m_sortParams.hSelectedNode = NULL;

    // Start as standard list
    m_bVirtual = FALSE;
    m_bFiltered = FALSE;
    m_pStandardList = new CAMCListView;
    m_pVirtualList = NULL;
    m_bEnsureFocusVisible = FALSE;
    m_bLoading = FALSE;
    m_bDeferredSort = FALSE;

    m_SavedHWND = NULL;
    ZeroMemory (&m_wp, sizeof(WINDOWPLACEMENT));

    m_pListView = m_pStandardList;
}


CCCListViewCtrl::~CCCListViewCtrl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CCCListViewCtrl);

    if (m_SavedHWND != NULL) {
        // change back
        ::SetParent (m_pListView->m_hWnd, m_SavedHWND);
        if (m_wp.length != 0)
            ::SetWindowPlacement (m_pListView->m_hWnd, &m_wp);

        // clear saved window
        m_SavedHWND = NULL;
    }

}


/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::ScInitialize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CCCListViewCtrl::ScInitialize()
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScInitialize"));

    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers(pAMCView, E_FAIL);
    if (sc)
        return sc;

    AddObserver(static_cast<CListViewObserver&>(*pAMCView));

    return sc;
}



//---------------------------------------------------- Utility functions


void CCCListViewCtrl::CutSelectedItems(BOOL bCut)
{
    CListCtrl& lc    = GetListCtrl();
    int nSearchFlags = (bCut) ? LVNI_SELECTED : LVNI_CUT;
    int nNewState    = (bCut) ? LVIS_CUT      : 0;
    int nItem        = -1;

    while ((nItem = lc.GetNextItem (nItem, nSearchFlags)) >= 0)
    {
        lc.SetItemState (nItem, nNewState, LVIS_CUT);
    }
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::IndexToResultItem
 *
 * Returns the CResultItem pointer for a given index.
 *--------------------------------------------------------------------------*/

CResultItem* CCCListViewCtrl::IndexToResultItem (int nItem)
{
    HRESULTITEM hri = GetListCtrl().GetItemData (nItem);

    if (IS_SPECIAL_LVDATA (hri))
        return (NULL);

    return (CResultItem::FromHandle (hri));
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::ResultItemToIndex
 *
 * Returns the index of an item given its CResultItem pointer.  This does a
 * linear search.  If the speed of this function needs to be improved,
 * we'll need a separate CResultItem-to-index map.
 *--------------------------------------------------------------------------*/

int CCCListViewCtrl::ResultItemToIndex (CResultItem* pri) const
{
    /*
     * if this is a virtual list, the CResultItem "pointer" is actually
     * the item index, so convert it.  Note that CResultItem::ToHandle is
     * safe to call with a NULL pointer.
     */
    if (IsVirtual())
        return (CResultItem::ToHandle(pri));

    /*
     * No items have NULL CResultItem pointers, don't bother looking.
     */
    if (pri == NULL)
        return (-1);

    /*
     * Let the list find the matching item.
     */
    LV_FINDINFO lvfi;
    lvfi.flags  = LVFI_PARAM;
    lvfi.lParam = CResultItem::ToHandle(pri);

    return (GetListCtrl().FindItem (&lvfi, -1));
}

/////////////////////////////////////////////////////////////////////////////
// CCCListViewCtrl message handlers


HRESULT CCCListViewCtrl::InsertItem(
    LPOLESTR    str,
    long        iconNdx,
    LPARAM      lParam,
    long        state,
    COMPONENTID ownerID,
    long        itemIndex,
    CResultItem*& priInserted)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::InsertItem"));

    /*
     * init the output parameter
     */
    priInserted = NULL;

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    if (str != MMC_TEXTCALLBACK)
        return (sc = E_INVALIDARG).ToHr();

    // Ask the CAMCListViewCtrl to setup headers.
    sc = ScCheckPointers(m_pListView, E_UNEXPECTED);
    if (! sc.IsError())
        sc = m_pListView->ScRestoreColumnsFromPersistedData();

    if (sc)
        sc.TraceAndClear();

    USES_CONVERSION;

    LV_ITEM     lvi;
    lvi.iSubItem = 0;
    lvi.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.pszText  = LPSTR_TEXTCALLBACK;

    // If the user has specified an icon index, map it and put it in the LV_ITEM struct
    int nMapping = 0;

    if ((iconNdx != MMCLV_NOICON) &&
        m_resultIM.Lookup(&CImageIndexMapKey(ownerID,iconNdx), nMapping))
    {
        lvi.iImage = nMapping;
    }
    else
    {
        lvi.iImage = MMCLV_NOICON;
        iconNdx    = MMCLV_NOICON;
    }

    /*
     * allocate and initialize a CResultItem for this item
     */
    sc = ScAllocResultItem (priInserted, ownerID, lParam, iconNdx);
    if (sc)
        return (sc.ToHr());

    sc = ScCheckPointers (priInserted, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());


    // If the user has specified a state, put it in the LV_ITEM struct
    if (state != MMCLV_NOPARAM)
    {
        lvi.mask     |= LVIF_STATE;
        lvi.state     = state;
        lvi.stateMask = 0xFFFFFFFF;
    }


    // if scope item
    if (priInserted->IsScopeItem())
    {
        // if no index provided add to end of unsorted items
        lvi.iItem = (itemIndex == -1) ? m_nScopeItems : itemIndex;

        // if decending sort, offset from end instead of start
        if (!m_sortParams.bAscending)
            lvi.iItem += (m_itemCount - m_nScopeItems);
    }
    else
    {
        // Add sorted items to end of list (or before unsorted items, if reverse sorting)
        lvi.iItem = m_sortParams.bAscending ? m_itemCount : m_itemCount - m_nScopeItems;
    }

    lvi.lParam = CResultItem::ToHandle(priInserted);

    int nIndex = GetListCtrl().InsertItem (&lvi);

#if (defined(DBG) && defined(DEBUG_LIST_INSERTIONS))
    static int cInserted = 0;
    TRACE3 ("%4d:Inserted item: index=%d, lParam=0x%08x\n", ++cInserted, nIndex, lvi.lParam);
#endif

    if (nIndex == -1 )
    {
        sc = E_FAIL;
        ScFreeResultItem (priInserted);   // ignore failures
        priInserted = NULL;
    }
    else
    {
        // The insert succeeded, increase the internal item counts
        m_itemCount++;

        // we invalidate the rectangle when transitioning from zero to one item because otherwise the
        // empty list message is not erased completely.
        if(m_itemCount == 1)
            GetListCtrl().InvalidateRect(NULL);

        if (priInserted->IsScopeItem())
            m_nScopeItems++;

        // if ensure focus visible style and focus set, force item into view
        if (m_bEnsureFocusVisible && state != MMCLV_NOPARAM && (state & LVIS_FOCUSED))
            GetListCtrl().EnsureVisible(nIndex, FALSE);
    }

    if (sc)
        return sc.ToHr();

    // we have inserted an Item! - broadcast the good message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewItemInserted, nIndex);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


HRESULT CCCListViewCtrl::DeleteItem(HRESULTITEM itemID, long nCol)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::DeleteItem"));

    if (nCol != 0)
        return E_INVALIDARG;

    CListCtrl& lc = GetListCtrl();

    int nItem = IsVirtual() ? static_cast<int>(itemID)
                            : ResultItemToIndex( CResultItem::FromHandle(itemID) );

#if (defined(DBG) && defined(DEBUG_LIST_INSERTIONS))
    static int cDeletes = 0;
    TRACE3 ("%4d:Deleted item:  index=%d, lParam=0x%08x", ++cDeletes, nItem, priDelete);
#endif

    if (nItem < 0 || nItem >= m_itemCount)
    {
        ASSERT(FALSE);
#if (defined(DEBUG_LIST_INSERTIONS))
        TRACE0 ("  (failed)\n");
#endif
        return E_INVALIDARG;
    }

#if (defined(DEBUG_LIST_INSERTIONS))
    TRACE0 ("\n");
#endif

    if (!lc.DeleteItem (nItem))
    {
        sc = E_FAIL;
    }
    else
    {
        // Delete was successful, decrement the ItemCount
        ASSERT(m_itemCount > 0);
        m_itemCount--;

        if (!IsVirtual())
        {
            CResultItem *priDelete = CResultItem::FromHandle(itemID);
            sc = ScCheckPointers (priDelete, E_UNEXPECTED);
            if (sc)
                return (sc.ToHr());

            if (priDelete->IsScopeItem())
                m_nScopeItems--;

            sc = ScFreeResultItem (priDelete);
            if (sc)
                return (sc.ToHr());
        }
    }

    if (sc)
        return sc.ToHr();

    // select the focused item ( this will save a lot of snapins from the confusion
    // since they are not prepared to handle 'no items selected' scenario.
    // Note: we only guard single selection lists - for multiple selection the situation
    // must be handled by snapin, since user can easily unselect the item.
    if ( (::GetFocus() == lc.m_hWnd) && (lc.GetStyle() & LVS_SINGLESEL) )
    {
        // check if focused item is selected
        int iMarkedItem = lc.GetSelectionMark();
        if ( (iMarkedItem >= 0) && !( lc.GetItemState( iMarkedItem, LVIS_SELECTED ) & LVIS_SELECTED ) )
        {
            // NOTE: do not use lc.SetItemState - it uses SetItem which is not supported for virtual lists
            LV_ITEM lvi;
            lvi.stateMask = lvi.state = LVIS_SELECTED;
            if (!lc.SendMessage( LVM_SETITEMSTATE, WPARAM(iMarkedItem), (LPARAM)(LV_ITEM FAR *)&lvi))
                (sc = E_FAIL).TraceAndClear(); // trace is enough - ignore and continue
        }
    }

    // we have deleted an Item! - broadcast the message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewItemDeleted, nItem);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::UpdateItem
//
//  Synopsis:    Update the given item.
//
//  Arguments:   [itemID] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CCCListViewCtrl::UpdateItem(HRESULTITEM itemID)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::UpdateItem"));

    int nIndex = -1;
    sc = ScGetItemIndexFromHRESULTITEM(itemID, nIndex);
    if (sc)
        return sc.ToHr();

    if(nIndex < 0 || nIndex >= m_itemCount)
        return (sc = E_INVALIDARG).ToHr();

	CListCtrl& lc = GetListCtrl();

    /*
     * Since Common Control does not hold any data about virtual list view
     * items they would not know what to invalidate. So we need to invalidate
     * for virtual list views.
     */
	if (IsVirtual())
	{
		RECT rc;

		lc.GetItemRect(nIndex, &rc, LVIR_BOUNDS);
		lc.InvalidateRect(&rc);
	}
	else
	{
		sc = ScRedrawItem(nIndex);
		if (sc)
			return (sc.ToHr());
	}

	lc.UpdateWindow();


    // we have updated an item - broadcast the message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewItemUpdated, nIndex);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScGetItemIndexFromHRESULTITEM
//
//  Synopsis:    Given HRESULTITEM get the index of that item.
//               For virtual listview the itemid is the index.
//
//  Arguments:   [itemID] - [in param]
//               [nIndex] - [out param]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScGetItemIndexFromHRESULTITEM (const HRESULTITEM& itemID, int& nIndex)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScGetItemIndexFromHRESULTITEM"));

    nIndex = -1;

    if (IsVirtual())
	{
        nIndex = itemID;
		return sc;
	}

    CResultItem *pri = CResultItem::FromHandle(itemID);
    sc = ScCheckPointers(pri, E_UNEXPECTED);
    if (sc)
        return sc;

    nIndex = ResultItemToIndex(pri);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScRedrawItem
//
//  Synopsis:    Redraw the given item in listview.
//
//  Arguments:   [nIndex] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScRedrawItem(int nIndex)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::RedrawItem"));

    if(nIndex < 0 || nIndex >= m_itemCount)
        return (sc = E_INVALIDARG);

    if (!GetListCtrl().RedrawItems (nIndex, nIndex))
        return (sc = E_FAIL);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     Sort
//
//  Synopsis:   Sort the list view with given data.
//
//  Arguments:  [lpUserParam]    - Snapin supplied user param.
//              [lParms]         - ptr to CCLVSortParams struct.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
HRESULT CCCListViewCtrl::Sort(LPARAM lUserParam, long* lParms)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Sort"));

    if (IsVirtual())
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    BOOL bResult = FALSE;
    CCLVSortParams* lpParams = reinterpret_cast<CCLVSortParams*>(lParms);
    ASSERT(lpParams != NULL);

    // Note: the hwnd should only be initialize in ::Create
    m_sortParams.bAscending = lpParams->bAscending;
    m_sortParams.nCol = lpParams->nCol;
    m_sortParams.spResultCompare = lpParams->lpResultCompare;
    m_sortParams.spResultCompareEx = lpParams->lpResultCompareEx;
    m_sortParams.lpUserParam = lUserParam;

    // Do not sort on hidden columns.
    if (IsColumnHidden(m_sortParams.nCol))
        return (sc.ToHr());

    {
        // Check view options for scope item sorting
        CAMCView* pAMCView = m_pListView->GetAMCView();
        sc = ScCheckPointers(pAMCView, E_FAIL);
        if (sc)
            return (sc.ToHr());

        SViewData* pViewData = pAMCView->GetViewData();
        sc = ScCheckPointers(pViewData, E_FAIL);
        if (sc)
            return (sc.ToHr());

        m_sortParams.bLexicalSort = ((pViewData->GetListOptions() & RVTI_LIST_OPTIONS_LEXICAL_SORT) != 0);

        LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
        sc = ScCheckPointers(pNodeCallback, E_FAIL);
        if (sc)
            return (sc.ToHr());

        // Do not need to refcount this, because it is being passed to a method that returns.
        m_sortParams.lpNodeCallback = pNodeCallback;

        // Get component ID of node that owns the result view
        HNODE hnodeOwner = pAMCView->GetSelectedNode();
        sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
        if (sc)
            return (sc.ToHr());

        m_sortParams.hSelectedNode = hnodeOwner;

        sc = pNodeCallback->GetNodeOwnerID(hnodeOwner, &m_sortParams.OwnerID);
        if (sc)
            return (sc.ToHr());

        if (m_bLoading)
        {
            bResult = TRUE;
            m_bDeferredSort = TRUE;
        }
        else
        {
			/*
			 * the sort could take awhile, so show a wait cursor
			 */
			CWaitCursor wait;

            // It is lexical sort if
            // 1. LV option specifies lexical sort option or
            // 2. Snapin does not implement IResultDataCompare
            //    or IResultDataCompareEx interfaces.
            BOOL bLexicalSort = ( m_sortParams.bLexicalSort ||
                                  ( (NULL == m_sortParams.spResultCompare) &&
                                    (NULL == m_sortParams.spResultCompareEx) ) );

            if (bLexicalSort)
            {
                bResult = GetListCtrl().SortItems (DefaultCompare, (DWORD_PTR)&m_sortParams);
            }
            else
            {
                bResult = GetListCtrl().SortItems (SortCompareFunc, (DWORD_PTR)&m_sortParams);
            }
        }

        sc = (bResult == TRUE) ? S_OK : E_FAIL;
        if (sc)
            return (sc.ToHr());

        // we have sorted Items! - cannot keep track of them currently
        sc = ScFireEvent(CListViewObserver::ScOnListViewIndexesReset);
        if (sc)
            return (sc.ToHr());
    }

    return sc.ToHr();
}

HRESULT CCCListViewCtrl::FindItemByLParam(COMPONENTID ownerID, LPARAM lParam, CResultItem*& priFound)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::FindItemByLParam"));

    /*
     * init output parameter
     */
    priFound = NULL;

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    /*
     * find a CResultItem that matches the given owner and lParam.
     */
    for (int i = GetListCtrl().GetItemCount()-1; i >= 0; i--)
    {
        CResultItem* pri = IndexToResultItem (i);

        if ((pri != NULL) &&
            (pri->GetOwnerID() == ownerID) &&
            (pri->GetSnapinData() == lParam))
        {
            priFound = pri;
            break;
        }
    }

    if (priFound == NULL)
        return ((sc = E_FAIL).ToHr());

    return sc.ToHr();
}


HRESULT CCCListViewCtrl::GetListStyle()
{
    LONG result;
    ASSERT(::IsWindow(GetListViewHWND()));

    // return the Style masked by the List View Style mask.
    result = ::GetWindowLong(GetListViewHWND(),GWL_STYLE) & 0xffff;

    return result;
}


HRESULT CCCListViewCtrl::SetListStyle(long nNewValue)
{
    ASSERT(::IsWindow(GetListViewHWND()));

    // Protect style bits that shouldn't be changed
    // Use SetViewMode to change the mode, so filtering is properly updated
    const long PRESERVE_MASK = LVS_OWNERDATA | LVS_SHAREIMAGELISTS | 0xffff0000;

    DWORD curStyle = ::GetWindowLong(GetListViewHWND(), GWL_STYLE);
    DWORD newStyle = (curStyle & PRESERVE_MASK) | (nNewValue & ~PRESERVE_MASK);

    // Verify not changing the view mode
    ASSERT( ((curStyle ^ newStyle) & LVS_TYPEMASK) == 0);

    // verify OWNERDATA style is what we think it is
    ASSERT((curStyle & LVS_OWNERDATA) && m_bVirtual || !(curStyle & LVS_OWNERDATA) && !m_bVirtual);

    // Save state of MMC defined "ensure focus visible" syle
    m_bEnsureFocusVisible = (nNewValue & MMC_LVS_ENSUREFOCUSVISIBLE) != 0;

    if (curStyle != newStyle)
    {
        // Apply style changes
        ::SetWindowLong(GetListViewHWND(), GWL_STYLE, newStyle);

        /*
         * The list control does not pass changes to the LVS_NOSORTHEADER flag on to the
         * HeaderCtrl. This section directly accesses the underlying HeaderCtrl and
         * changes the HDS_BUTTONS flag which is the equivalent.
         */
        if ((nNewValue & LVS_NOSORTHEADER) ^ (curStyle & LVS_NOSORTHEADER) && GetHeaderCtrl())
        {
            if (nNewValue & LVS_NOSORTHEADER)
                GetHeaderCtrl()->ModifyStyle (HDS_BUTTONS, 0); // Add the style
            else
                GetHeaderCtrl()->ModifyStyle (0, HDS_BUTTONS); // Remove the style
        }
    }

    return S_OK;
}


HRESULT CCCListViewCtrl::GetViewMode()
{
    ASSERT(::IsWindow(GetListViewHWND()));

    long nViewMode;

    if (m_bFiltered)
        nViewMode = MMCLV_VIEWSTYLE_FILTERED;
    else
        nViewMode = ::GetWindowLong(GetListViewHWND(), GWL_STYLE) & LVS_TYPEMASK;

    return nViewMode;
}


#include "histlist.h"
HRESULT CCCListViewCtrl::SetViewMode(long nViewMode)
{
    ASSERT(nViewMode >= 0 && nViewMode <= MMCLV_VIEWSTYLE_FILTERED);

    CListCtrl& lc = GetListCtrl();

    if (nViewMode < 0 && nViewMode > MMCLV_VIEWSTYLE_FILTERED)
        return E_INVALIDARG;

    CAMCView* pAMCView = dynamic_cast<CAMCView*>(m_pParentWnd);
    if (pAMCView)
        pAMCView->GetHistoryList()->SetCurrentViewMode (nViewMode);

    BOOL bFiltered = FALSE;
    if (nViewMode == MMCLV_VIEWSTYLE_FILTERED)
    {
        bFiltered = TRUE;
        nViewMode = LVS_REPORT;
    }

    lc.ModifyStyle (LVS_TYPEMASK, nViewMode);

    HRESULT hr = S_OK;

    // set filter style
    CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
    ASSERT(NULL != pHeaderCtrl);

    if (bFiltered != m_bFiltered && pHeaderCtrl)
    {
        if (bFiltered)
            pHeaderCtrl->ModifyStyle (0, HDS_FILTERBAR);
        else
            pHeaderCtrl->ModifyStyle (HDS_FILTERBAR, 0);

        m_bFiltered = bFiltered;

        // The header size has changed with the addition/removal of filter.
        // We hide and show the header which will force the list
        // control to recalculate the size, position of new header
        // and list view and display it.
        lc.ModifyStyle(0, LVS_NOCOLUMNHEADER, 0);
        lc.ModifyStyle(LVS_NOCOLUMNHEADER, 0, 0);
    }

    return S_OK;
}


HRESULT CCCListViewCtrl::SetVirtualMode(BOOL bVirtual)
{
    ASSERT(::IsWindow(GetListViewHWND()));

    HRESULT hr = S_OK;

    // force param to TRUE or FALSE
    bVirtual = bVirtual ? TRUE : FALSE;

    if (bVirtual != m_bVirtual)
    {
        do // false loop
        {
             // list must be empty to switch
            if (m_itemCount != 0)
            {
               ASSERT(FALSE);
               hr = E_FAIL;
               break;
            }

            // get styles to copy to new control
            long curStyle = ::GetWindowLong(GetListViewHWND(), GWL_STYLE) ^ LVS_OWNERDATA;
            long curStyleEx = ::GetWindowLong(GetListViewHWND(), GWL_EXSTYLE);

            long curHdrStyle = 0;

            if (GetHeaderCtrl())
                curHdrStyle = GetHeaderCtrl()->GetStyle();

            if (bVirtual && !m_pVirtualList)
            {
                m_pVirtualList = new CAMCListView;
                m_pVirtualList->SetVirtual();
            }

            CAMCListView* pNewList = bVirtual ? m_pVirtualList : m_pStandardList;
            CAMCListView* pOldList = m_pListView;

            // Make sure new control has been created
            if (pNewList->m_hWnd == NULL)
            {
                /*
                 * MFC will issue a warning about creating a pane with
                 * no document.  That's OK, since CAMCView::AttachListView-
                 * AsResultPane will patch thing up later.
                 */
                ASSERT (pOldList != NULL);
                if (!Create(curStyle, g_rectEmpty, m_pParentWnd, pOldList->GetDlgCtrlID()))
                {
                    ASSERT(FALSE);
                    hr = E_FAIL;
                    break;
                }
            }

            // update member variables (this switches to the new control)
            m_bVirtual = bVirtual;
            m_pListView = bVirtual ? m_pVirtualList : m_pStandardList;

            // Set current styles on new control
            ::SetWindowLong(GetListViewHWND(), GWL_STYLE, curStyle);
            ::SetWindowLong(GetListViewHWND(), GWL_EXSTYLE, curStyleEx);

            // Note we have switched to the other control by now so this is getting the
            // header of the new list
            if (GetHeaderCtrl())
                ::SetWindowLong(GetHeaderCtrl()->m_hWnd, GWL_STYLE, curHdrStyle);

             // hide the old list control and show the new one
            ::ShowWindow(pOldList->m_hWnd, SW_HIDE);
            ::ShowWindow(m_pListView->m_hWnd, SW_SHOWNA);
        }
        while (0);
    }

    return hr;
}



HRESULT CCCListViewCtrl::InsertColumn(int nCol, LPCOLESTR str, long nFormat, long width)
{
    // Cannot change a column that is not in the list.
    if(!str || !*str)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    LV_COLUMN newCol;
    void* pvoid = &newCol;

    // Cannot insert a column with any items in the list.
    if(m_itemCount)
    {
        hr = E_FAIL;
    }
    else
    {
        newCol.mask=0;

        USES_CONVERSION;

        // if the user specified a string, put it in the struct.
        if(str!=MMCLV_NOPTR)
        {
            newCol.mask|=LVCF_TEXT;
            newCol.pszText=OLE2T((LPOLESTR)str);
        }

        // if the user specified a format, put it in the struct.
        if(nFormat!=MMCLV_NOPARAM)
        {
            newCol.mask|=LVCF_FMT;
            newCol.fmt=nFormat;
        }

        // if the user specified a width, put it in the struct.
        if(width!=MMCLV_NOPARAM)
        {
            newCol.mask|=LVCF_WIDTH;
            // if the user requested auto-width, calculate the width.
            // else just store the passed width.
            if(width==MMCLV_AUTO)
            {
                // if the user did pass a string, calculate the width based off the string.
                // else the width is 0.
                if(str!=MMCLV_NOPTR)
                {
                    CSize sz(0,0);
                    CClientDC dc( m_pListView );
                    dc.SelectObject( m_pListView->GetFont());
                    sz=dc.GetTextExtent(OLE2CT((LPOLESTR)str),_tcslen(OLE2T((LPOLESTR)
                    str)));
                    newCol.cx=sz.cx+CCLV_HEADERPAD;
                }
                else
                {
                    newCol.cx=0;
                }
            }
            else
            {
                newCol.cx=width;
            }
        }

        int nRet = GetListCtrl().InsertColumn (nCol, &newCol);

        if (-1 == nRet)
            hr = E_FAIL;
        else
        {
            // set lparam (HDI_HIDDEN flag) if the width is HIDE_COLUMN
            if (HIDE_COLUMN == width)
            {
				CHiddenColumnInfo hci (0, true);

                HDITEM hdItem;
                ::ZeroMemory(&hdItem, sizeof(hdItem));
                hdItem.mask    = HDI_LPARAM;
                hdItem.lParam  = hci.lParam;

                // We do not care if this call fails
                if (GetHeaderCtrl())
                    GetHeaderCtrl()->SetItem(nRet, &hdItem);
            }
            else
            {
				CHiddenColumnInfo hci (newCol.cx, false);

                // set lparam with the width.
                HDITEM hdItem;
                ::ZeroMemory(&hdItem, sizeof(hdItem));
                hdItem.mask    = HDI_LPARAM;
                hdItem.lParam  = hci.lParam;

                // We do not care if this call fails
                if (GetHeaderCtrl())
                    GetHeaderCtrl()->SetItem(nRet, &hdItem);
            }

            // insert was successful, increment the column count.
            m_colCount++;
        }

    }

    // we have inserted a column! - broadcast the message to observers
    if (SUCCEEDED(hr))
    {
        SC sc = ScFireEvent(CListViewObserver::ScOnListViewColumnInserted, nCol);
        if (sc)
            return sc.ToHr();
    }

    return hr;
}

HRESULT CCCListViewCtrl::DeleteColumn(int nCol)
{
    if (nCol < 0 || nCol >= m_colCount)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    // Cannot delete a column if there are items in the list.
    if(m_itemCount)
    {
        hr = E_FAIL;
    }
    else
    {

        if (!GetListCtrl().DeleteColumn (nCol))
            hr = E_FAIL;
        else
            // Successful delete, decrement the column count.
            m_colCount--;
    }

    // we have deleteded a column! - broadcast the message to observers
    if (SUCCEEDED(hr))
    {
        SC sc = ScFireEvent(CListViewObserver::ScOnListViewColumnDeleted, nCol);
        if (sc)
            return sc.ToHr();
    }

    return hr;
}

HRESULT CCCListViewCtrl::GetColumnCount(int* pnColCnt)
{
    *pnColCnt =  m_colCount;
    return S_OK;
}

HRESULT CCCListViewCtrl::DeleteAllItems(COMPONENTID ownerID)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::DeleteAllItems"));

    CListCtrl& lc = GetListCtrl();

    const bool bHasItemsToDelete = (m_itemCount > 0);
    // Nothing in the list -> nothing to do.
    if (bHasItemsToDelete)
    {
        if (IsVirtual())
        {
            if (lc.DeleteAllItems ())
                m_itemCount = 0;
            else
                sc = E_FAIL;
        }
        else if (ownerID == TVOWNED_MAGICWORD)
        {
            /*
             * free all of the CResultItem objects
             */
            for (int i = m_itemCount - 1; i >= 0; i--)
            {
                CResultItem* pri = IndexToResultItem (i);

                if (pri != NULL)
                {
                    sc = ScFreeResultItem(pri);
                    if (sc)
                        return (sc.ToHr());
                }
            }

            if (lc.DeleteAllItems ())
            {
                // Delete all succeded, ItemCount is now 0;
                m_itemCount = 0;
                m_nScopeItems = 0;
            }

            else
                sc = E_FAIL;
        }
        else
        {
            for(int i = m_itemCount - 1; i >= 0; i--)
            {
                CResultItem* pri = IndexToResultItem (i);

                if ((pri != NULL) && (pri->GetOwnerID() == ownerID))
                {
                    if (lc.DeleteItem (i))
                    {
                        m_itemCount--;

                        sc = ScFreeResultItem(pri);
                        if (sc)
                            return (sc.ToHr());
                    }

                    else
                        sc = E_FAIL;
                }
            }
        }
    }

    if (sc)
        return sc.ToHr();

    if (bHasItemsToDelete)
    {
        // we have deleted all Items! - broadcast the message to observers
        sc = ScFireEvent(CListViewObserver::ScOnListViewIndexesReset);
        if (sc)
            return sc.ToHr();
    }

    return sc.ToHr();
}

HRESULT CCCListViewCtrl::SetColumn(long nCol, LPCOLESTR str, long nFormat, long width)
{
    // Cannot change a column that is not in the list.
    if((nCol + 1) > m_colCount)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    LV_COLUMN newCol;
    newCol.mask=0;

    USES_CONVERSION;

    // if the user specified a string, put it in the struct.
    if(str!=MMCLV_NOPTR)
    {
        newCol.mask|=LVCF_TEXT;
        newCol.pszText=OLE2T((LPOLESTR)str);
    }

    // if the user specified a format, put it in the struct.
    if(nFormat!=MMCLV_NOPARAM)
    {
        newCol.mask|=LVCF_FMT;
        newCol.fmt=nFormat;
    }

    // if the user specified a width, put it in the struct.
    if(width!=MMCLV_NOPARAM)
    {
        newCol.mask|=LVCF_WIDTH;
        // if the user requested auto-width, calculate the width.
        // else just store the passed width.
        if(width==MMCLV_AUTO)
        {
            // if the user did pass a string, calculate the width based off the string.
            // else the width is 0.
            if(str!=MMCLV_NOPTR)
            {
                CSize sz(0,0);
                CClientDC dc( m_pListView );
                dc.SelectObject( m_pListView->GetFont() );
                sz=dc.GetTextExtent(OLE2T((LPOLESTR)str),_tcslen(OLE2T((LPOLESTR)str)));
                newCol.cx=sz.cx+15;
            }
            else
            {
                newCol.cx=0;
            }
        }
        else
        {
            newCol.cx=width;
        }

        // Get the lParam to see if this is a hidden column.
        HDITEM hdItem;
        ::ZeroMemory(&hdItem, sizeof(hdItem));
        hdItem.mask    = HDI_LPARAM;
        ASSERT(GetHeaderCtrl());
        BOOL bRet = GetHeaderCtrl()->GetItem(nCol, &hdItem);
        ASSERT(bRet);

		CHiddenColumnInfo hciOld (hdItem.lParam);
		CHiddenColumnInfo hci (0);

        ::ZeroMemory(&hdItem, sizeof(hdItem));
        hdItem.mask    = HDI_LPARAM;

        // If the column is to be hidden then
        // remember the (Old width) and (HIDDEN_FLAG).
        if (HIDE_COLUMN == newCol.cx)
        {
			hci.cx      = hciOld.cx;
			hci.fHidden = true;
        }

        // If the column was hidden then
        // remember the (New width supplied) and (HIDDEN_FLAG).
        if (hciOld.fHidden)
        {
			hci.cx      = newCol.cx;
			hci.fHidden = true;
        }

		hdItem.lParam = hci.lParam;

        // We do not care if this call fails
        GetHeaderCtrl()->SetItem(nCol, &hdItem);

        // Common control does not know anything about hidden
        // columns, so if the column is hidden clear the
		// width mask.
		if (hci.fHidden)
		{
			newCol.mask = newCol.mask & (~LVCF_WIDTH);
		}
    }

    if (!GetListCtrl().SetColumn (nCol, &newCol))
        hr = E_FAIL;

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::GetColumn
 *
 * PURPOSE: Returns information about the nCol'th column
 *
 * PARAMETERS:
 *    long      nCol :      the column index
 *    LPOLESTR* str :       if non-NULL, points to column name on exit
 *    LPLONG    nFormat :   [out] the column format
 *    int *     width:      [out] the width of the column
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CCCListViewCtrl::GetColumn(long nCol, LPOLESTR* str, LPLONG nFormat, int FAR *width)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::GetColumn"));

#ifdef DBG
    if((nCol+1)>m_colCount)
        return E_INVALIDARG;
#endif

    LV_COLUMN col;

    UINT                 cBufferSize  = 25; // grows as needed. The size here is actually half the initially allocated size
    CAutoArrayPtr<TCHAR> buffer;  // we use CAutoArrayPtr because the destructor calls delete[]
    // Set up the mask to select the values we are interested in.
    UINT   mask         = (nFormat!=MMCLV_NOPTR?LVCF_FMT:0)|(width!=MMCLV_NOPTR?LVCF_WIDTH:0);

    do
    {
        // If the user requested a string, reflect this in the struct.
        if(str!=NULL)
        {
            buffer.Delete(); // get rid of the old buffer, if any

            cBufferSize *= 2; // twice the previous size.
            buffer.Attach(new TCHAR[cBufferSize]);
            if(buffer==NULL)
                return(sc = E_OUTOFMEMORY).ToHr();

            mask|=LVCF_TEXT;
            col.cchTextMax=cBufferSize;
            col.pszText=buffer;
        }

        col.mask = mask;

        sc = GetListCtrl().GetColumn (nCol, &col) ? S_OK : E_FAIL;
        if(sc)
            return sc.ToHr();

    }   while(str!=NULL && (cBufferSize == _tcslen(buffer) + 1) ); //loop if the string filled up the buffer.
    // This is conservative - even if the buffer was just big enough, we loop again.

    // Success! fill in the requested args and return.
    USES_CONVERSION;
    if(str!=MMCLV_NOPTR)
        *str = ::CoTaskDupString(T2OLE(buffer));

    if(nFormat!=MMCLV_NOPTR)
        *nFormat=col.fmt;

    if(width!=MMCLV_NOPTR)
        *width=col.cx;

    return sc.ToHr();
}

HRESULT CCCListViewCtrl::SetItem(int nItem,
                               CResultItem* pri,
                               long nCol,
                               LPOLESTR str,
                               long nImage,
                               LPARAM lParam,
                               long nState,
                               COMPONENTID ownerID)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::SetItem"));

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    ASSERT(pri != NULL || nItem >= 0);

    // if this is a debug build, perform validity checks on the args. else leave it to the user.
    if (nCol<0 || nCol >= m_colCount || (str != MMCLV_NOPTR && str != MMC_TEXTCALLBACK))
        return (sc = E_INVALIDARG).ToHr();

    if (pri != NULL)
    {
        nItem = ResultItemToIndex(pri);
        if (nItem == -1)
            return (sc = E_INVALIDARG).ToHr();
    }

    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask=0;
    lvi.iItem = nItem;
    USES_CONVERSION;
    lvi.mask|=LVIF_TEXT;
    lvi.pszText=LPSTR_TEXTCALLBACK;

    // If the user has specified an icon index, put it in the LV_ITEM struct
    if((nImage!=MMCLV_NOICON)&&(m_resultIM.Lookup(&CImageIndexMapKey((COMPONENTID)ownerID,nImage), lvi.iImage)))
        lvi.mask|=LVIF_IMAGE;

    // If the user requested a state.  put it in the LV_ITEM struct.
    if(nState!=MMCLV_NOPARAM)
    {
        lvi.mask|=LVIF_STATE;
        lvi.stateMask=0xFFFFFFFF;
        lvi.state=nState;
    }

    lvi.iSubItem=nCol;

    CListCtrl& lc = GetListCtrl();

    if (!lc.SetItem (&lvi))
        sc = E_FAIL;

    // If the user has specified an lParam or image, and the Set was succesful,
    // put the lParam and the image's back index in the mapping.
    if (!sc.IsError())
    {
        if ((pri == NULL) && ((pri = IndexToResultItem (nItem)) == NULL))
            sc = E_FAIL;

        if (!sc.IsError())
        {
            if (lParam != MMCLV_NOPARAM)
                pri->SetSnapinData (lParam);

            if (nImage != MMCLV_NOICON)
                pri->SetImageIndex (nImage);
        }

        // if ensure focus visible style and focus set, force item into view
        if (m_bEnsureFocusVisible && nState != MMCLV_NOPARAM && (nState & LVIS_FOCUSED))
            lc.EnsureVisible(nItem, FALSE);
    }

    return (sc.ToHr());
}


HRESULT CCCListViewCtrl::GetNextItem(COMPONENTID ownerID, long nIndex,
                                   UINT nState, CResultItem*& priNextItem, long& nIndexNextItem)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::GetNextItem"));

    CListCtrl& lc = GetListCtrl();

    priNextItem    = 0;
    nIndexNextItem = -1;

    while (1)
    {
        nIndex = lc.GetNextItem (nIndex, nState);

        if (nIndex == -1)
            break;

        if (IsVirtual())
        {
            nIndexNextItem = nIndex;
            break;
        }

        CResultItem* pri = IndexToResultItem (nIndex);

        if ((pri != NULL) && ((pri->GetOwnerID() == ownerID) || (pri->IsScopeItem())))
        {
            priNextItem    = pri;
            nIndexNextItem = nIndex;
            break;
        }
    }

    return (sc = (nIndexNextItem != -1) ? S_OK : S_FALSE).ToHr();
}

HRESULT CCCListViewCtrl::GetItem(
    int         nItem,
    CResultItem*& pri,
    long        nCol,
    LPOLESTR*   str,
    int*        pnImage,
    LPARAM*     pLParam,
    UINT*       pnState,
    BOOL*       pbScopeItem)
{
    USES_CONVERSION;
    if ((nCol < 0) || (nCol >= m_colCount))
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    CListCtrl& lc = GetListCtrl();

    if (IsVirtual())
    {
        //Virtual list can only be queried for state
        if ((pri != NULL) || (nItem < 0) || (nItem >= m_itemCount) ||
            (str != MMCLV_NOPTR) || (pnImage != MMCLV_NOPTR) || (pLParam != MMCLV_NOPTR))
        {
            ASSERT(FALSE);
            hr = E_INVALIDARG;
        }
        else if (pnState != MMCLV_NOPTR)
        {
            *pnState = lc.GetItemState (nItem, 0xFFFFFFFF);

            // for virtual list, it's never a scope item
            if (pbScopeItem != NULL)
                *pbScopeItem = FALSE;
        }
    }
    else
    {
        if (pri != 0)
            nItem = ResultItemToIndex(pri);

        if (nItem < 0 || nItem >= m_itemCount)
            hr = E_INVALIDARG;

        else
        {
            pri = IndexToResultItem (nItem);
			if ( pri == NULL )
				return E_UNEXPECTED;

            // if the text was requested, get that seperatly so that we can use GETITEMTEXT to
            // dynamically size the buffer.
            if (str != MMCLV_NOPTR)
            {
                CString strText = lc.GetItemText (nItem, nCol);
                *str = ::CoTaskDupString (T2COLE (strText));
            }


            // get the state if requested
            if (pnState != MMCLV_NOPTR)
                *pnState = lc.GetItemState (nItem, 0xFFFFFFFF);

            // Nodemgr will unravel pri & get required data (lparam & image index).
            if (pri->IsScopeItem())
                return hr;

            // get the image, pLParam, or scope item,  if requested
            if ((pnImage  != MMCLV_NOPTR) ||
                (pLParam  != MMCLV_NOPTR) ||
                (pbScopeItem != NULL))
            {
                if (pri != NULL)
                {
                    if (pnImage != MMCLV_NOPTR)
                        *pnImage = pri->GetImageIndex();

                    if (pLParam != MMCLV_NOPTR)
                        *pLParam = pri->GetSnapinData();

                    // set the scope item flag
                    if (pbScopeItem != NULL)
                        *pbScopeItem = pri->IsScopeItem();
                }
                else
                    hr = E_FAIL;

            }
        }
    }

    return hr;
}


HRESULT CCCListViewCtrl::GetLParam(long nItem, CResultItem*& pri)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::GetLParam"));

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    pri = IndexToResultItem (nItem);
    if (pri == NULL)
        sc = E_FAIL;

    return (sc.ToHr());
}

HRESULT CCCListViewCtrl::ModifyItemState(long nItem, CResultItem* pri,
                                       UINT add, UINT remove)
{
    ASSERT(((pri != 0) && !IsVirtual()) || (nItem >= 0));

    // Can only set focus and selected states for virtual item
    if (IsVirtual() && ((add | remove) & ~(LVIS_FOCUSED | LVIS_SELECTED)))
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    HRESULT hr = E_FAIL;

    if (pri != 0 && !IsVirtual())
        nItem = ResultItemToIndex(pri);

    if (nItem >= 0)
    {
        LV_ITEM lvi;
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.iItem     = nItem;
        lvi.mask      = LVIF_STATE;
        lvi.stateMask = add | remove;
        lvi.state     = add;

        hr = (GetListCtrl().SetItemState (nItem, &lvi)) ? S_OK : E_FAIL;

        // if ensure focus visible style and focus set, force item into view
        if (m_bEnsureFocusVisible && (add & LVIS_FOCUSED))
            GetListCtrl().EnsureVisible(nItem, FALSE);
    }

    return hr;
}


HRESULT CCCListViewCtrl::SetIcon(long ownerID, HICON hIcon, long nLoc)
{
	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());

    /*
     * pick the flags out of nLoc
     */
    bool fChangeLargeIcon = nLoc & ILSIF_LEAVE_SMALL_ICON;
    bool fChangeSmallIcon = nLoc & ILSIF_LEAVE_LARGE_ICON;
    nLoc &= ~ILSIF_LEAVE_MASK;

    /*
     * make sure the XOR below will work
     */
    ASSERT ((fChangeLargeIcon == 0) || (fChangeLargeIcon == 1));
    ASSERT ((fChangeSmallIcon == 0) || (fChangeSmallIcon == 1));

    CImageIndexMapKey searchKey((COMPONENTID)ownerID, nLoc);
    int nNdx1;
    int nNdx2;

    HRESULT hr = S_OK;

    BOOL fExists = m_resultIM.Lookup(&searchKey, nNdx1);

    /*
     * are we changing the large or small icon only?
     */
    if (fChangeSmallIcon ^ fChangeLargeIcon)
    {
        /*
         * there must be an icon at nLoc already
         */
        if (!fExists)
            hr = E_INVALIDARG;

        /*
         * changing the large icon?
         */
        else if (fChangeLargeIcon)
        {
            if (m_largeIL.Replace(nNdx1, hIcon) != nNdx1)
                hr = E_FAIL;
        }

        /*
         * otherwise, changing the small icon?
         */
        else
        {
            if (m_smallIL.Replace(nNdx1, hIcon) != nNdx1)
                hr = E_FAIL;
        }
    }
    else if (fExists)
    {
        nNdx2 = m_smallIL.Replace(nNdx1, hIcon);

        if (nNdx2 == -1)
        {
            hr = E_FAIL;
        }
        else
        {
            if(nNdx2 != nNdx1)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                nNdx2 = m_largeIL.Replace(nNdx1, hIcon);
                if(nNdx2 != nNdx1)
                    hr = E_UNEXPECTED;
            }
        }
    }
    else
    {
        // Insert items and store indices in large and small
        nNdx1 = m_smallIL.Add(hIcon);

        if (nNdx1 != -1)
            nNdx2 = m_largeIL.Add(hIcon);

        if (nNdx1 == -1)
        {
            hr = E_FAIL;
        }
        else if (nNdx2 == -1)
        {
            m_smallIL.Remove (nNdx1);
            hr = E_FAIL;
        }
        else if(nNdx1 != nNdx2)
        {
            m_smallIL.Remove (nNdx1);
            m_largeIL.Remove (nNdx2);
            hr = E_UNEXPECTED;
        }
        else
        {
            // Generate a new key and store the values in the maps
            PImageIndexMapKey pKey = new CImageIndexMapKey((COMPONENTID)ownerID, nLoc);
            m_resultIM[pKey] = nNdx1;
        }
    }

#ifdef DBG
	if (tagListImages.FAny())
	{
		DrawOnDesktop (m_smallIL, 0, 0);
		DrawOnDesktop (m_largeIL, 0, 32);
	}
#endif

	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
    return hr;
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::SetImageStrip
 *
 * Adds one or more images to the imagelist.  Bitmaps are owned (and
 * released) by the caller.
 *--------------------------------------------------------------------------*/

HRESULT CCCListViewCtrl::SetImageStrip (
	long	ownerID,
	HBITMAP	hbmSmall,
	HBITMAP	hbmLarge,
	long 	nStartLoc,
	long	cMask)
{
	DECLARE_SC (sc, _T("CCCListViewCtrl::SetImageStrip"));
	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());

	/*
	 * valid start index?
	 */
    if (nStartLoc < 0)
		return ((sc = E_INVALIDARG).ToHr());

	/*
	 * valid bitmaps?
	 */
	sc = ScCheckPointers (hbmSmall, hbmLarge);
	if (sc)
		return (sc.ToHr());

    BITMAP bmSmall;
    if (!GetObject (hbmSmall, sizeof(BITMAP), &bmSmall))
		return (sc.FromLastError().ToHr());

    BITMAP bmLarge;
    if (!GetObject (hbmLarge, sizeof(BITMAP), &bmLarge))
		return (sc.FromLastError().ToHr());

	/*
	 * are the small and large bitmaps of the integral dimensions,
	 * and do they have the same number of images?
	 */
    if ( (bmSmall.bmHeight != 16) || (bmLarge.bmHeight != 32) ||
		 (bmSmall.bmWidth   % 16) || (bmLarge.bmWidth   % 32) ||
		((bmSmall.bmWidth   / 16) != (bmLarge.bmWidth   / 32)))
    {
		return ((sc = E_INVALIDARG).ToHr());
    }

	const int cEntries = bmSmall.bmWidth / 16;

	/*
	 * make copies of the input bitmaps because CImageList::Add (which calls
	 * ImageList_AddMasked) will screw up the background color
	 */
	CBitmap bmpSmall, bmpLarge;
	bmpSmall.Attach (CopyBitmap (hbmSmall));
	bmpLarge.Attach (CopyBitmap (hbmLarge));

	if ((bmpSmall.GetSafeHandle() == NULL) || (bmpLarge.GetSafeHandle() == NULL))
		return (sc.FromLastError().ToHr());

	/*
	 * add the small image
	 */
    const int nFirstNewIndexSmall = m_smallIL.Add (&bmpSmall, cMask);
	if (nFirstNewIndexSmall == -1)
		return (sc.FromLastError().ToHr());

	/*
	 * add the large image
	 */
    const int nFirstNewIndexLarge = m_largeIL.Add (&bmpLarge, cMask);
    if (nFirstNewIndexLarge == -1)
    {
		/*
		 * Images can be added many at a time, but only removed one at
		 * a time.  Remove each entry we added.
		 */
		for (int i = 0; i < cEntries; i++)
			m_smallIL.Remove (nFirstNewIndexSmall);

		ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
		return (sc.FromLastError().ToHr());
    }

	/*
	 * if the starting indices of the large and small images aren't
	 * the same, we screwed
	 */
    if (nFirstNewIndexSmall != nFirstNewIndexLarge)
    {
		/*
		 * Images can be added many at a time, but only removed one at
		 * a time.  Remove each entry we added.
		 */
		for (int i = 0; i < cEntries; i++)
		{
			m_smallIL.Remove (nFirstNewIndexSmall);
			m_largeIL.Remove (nFirstNewIndexLarge);
		}

		ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
		return ((sc = E_UNEXPECTED).ToHr());
    }

	// Keep the map updated for each newly inserted image.
	for(int i=0; i < cEntries; i++)
	{
		CImageIndexMapKey searchKey((COMPONENTID)ownerID, nStartLoc+i);

		// if the item exists in the map, replace the value, else create a new
		// key and set the value.

		int nIndex = nFirstNewIndexSmall;
		// use copy of nFirstNewIndexSmall as Lookup modifies nIndex.
		if(m_resultIM.Lookup(&searchKey, nIndex))
			m_resultIM[&searchKey] = nFirstNewIndexSmall+i;
		else
			m_resultIM[new CImageIndexMapKey((COMPONENTID)ownerID, nStartLoc+i)] = nFirstNewIndexSmall+i;
	}

#ifdef DBG
	if (tagListImages.FAny())
	{
		DrawOnDesktop (m_smallIL, 0,  0);
		DrawOnDesktop (m_largeIL, 0, 32);
	}
#endif

	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
	return (sc.ToHr());
}

HRESULT CCCListViewCtrl::MapImage(long ownerID, long nLoc, int far *pResult)
{
    CImageIndexMapKey searchKey((COMPONENTID)ownerID, nLoc);
    HRESULT hr = S_OK;

    ASSERT(pResult);

    if(!(m_resultIM.Lookup(&searchKey, *((int *)pResult))))
        hr = E_FAIL;

    return hr;
}


HRESULT CCCListViewCtrl::Reset()
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::Reset"));

    // Note: we must call this->DeleteAllItems(TVOWNED_MAGICWORD) & not
    // GetListCtrl().DeleteAllItems() to ensure that all internal data
    // is cleaned up.
    DeleteAllItems(TVOWNED_MAGICWORD);

    ASSERT(GetListCtrl().GetItemCount() == 0);
    ASSERT(m_itemCount == 0);
    ASSERT(m_nScopeItems == 0);

    m_resultIM.RemoveAll();

    m_smallIL.DeleteImageList();
    m_largeIL.DeleteImageList();

    sc = ScSetImageLists();
    if (sc)
        return (sc.ToHr());

    // Delete all columns
    while (SUCCEEDED (DeleteColumn(0))) {};

    if (m_pListView)
        sc = m_pListView->ScResetColumnStatusData();

    if (sc)
        sc.TraceAndClear();

    // reset lexical sorting until Sort is called again
    m_sortParams.bLexicalSort = FALSE;

    // release the snap-in's compare interfaces
    m_sortParams.spResultCompare = NULL;
    m_sortParams.spResultCompareEx = NULL;

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:     SortCompareFunc
//
//  Synopsis:   Compare two items, called by list control sort.
//
//  Arguments:  [lParam1]      - Item1's lparam.
//              [lParam2]      - Item2's lparam.
//              [pSortParams_] - ptr to SortParams.
//
//  Note:       If snapin wants lexical sort do default-compare.
//              Else if snapin has IResultDataCompare[Ex] then call it
//              Else do default-compare.
//
//  Returns:    -1 : item1 < item2
//               0 : item1 == item2
//              +1 : item1 > item2
//
//--------------------------------------------------------------------
int CALLBACK CCCListViewCtrl::SortCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams_)
{
    SortParams*  pSortParams = reinterpret_cast<SortParams*>(pSortParams_);
    ASSERT (pSortParams != NULL);

    CCCListViewCtrl* pListView   = reinterpret_cast<CCCListViewCtrl*>(pSortParams->lpListView);
    ASSERT (pListView != NULL);

    CResultItem* pri1 = CResultItem::FromHandle (lParam1);
    CResultItem* pri2 = CResultItem::FromHandle (lParam2);

    if (pri1 == NULL || pri2 == NULL)
    {
        ASSERT(FALSE);
        return 0;
    }

    BOOL bScope1 = pri1->IsScopeItem();
    BOOL bScope2 = pri2->IsScopeItem();

    int iResult;

    // if snap-in provides extended compare method
    if (pSortParams->spResultCompareEx != NULL)
    {
        ASSERT(pSortParams->lpNodeCallback);
        if (NULL == pSortParams->lpNodeCallback)
            return 0;             // Error

        COMPONENTID ItemID;
        BOOL bOwned1 = !bScope1 ||
                        ((pSortParams->lpNodeCallback->GetNodeOwnerID(pri1->GetScopeNode(), &ItemID) == S_OK) &&
                         (ItemID == pSortParams->OwnerID));

        BOOL bOwned2 = !bScope2 ||
                        ((pSortParams->lpNodeCallback->GetNodeOwnerID(pri2->GetScopeNode(), &ItemID) == S_OK) &&
                         (ItemID == pSortParams->OwnerID));

        // let snap-in order all items that it owns (scope and result)
        // put rest of items items after owned items
        if (bOwned1 && bOwned2)
            iResult = SnapinCompareEx(pSortParams, pri1, pri2);
        else if (bOwned1 || bOwned2)
            iResult = bOwned1 ? -1 : 1;
        else
			// DefaultCompare flips results depending on ascending or descending.
            return DefaultCompare(lParam1, lParam2, pSortParams_);
    }
    // do default sorting
    else
    {
        // pass result items to original compare method if provided, else to default sort
        if (!bScope1 && !bScope2)
        {
            if (pSortParams->spResultCompare != NULL)
                iResult = SnapinCompare(pSortParams, pri1, pri2);
            else
                // DefaultCompare flips results depending on ascending or descending.
                return DefaultCompare(lParam1, lParam2, pSortParams_);
        }
        // do not order scope items, just put them ahead of result items
        else
        {
            iResult = (bScope1 && bScope2) ? 0 : (bScope1 ? -1 : 1);
        }
    }

    // flip order for descending sort
    return pSortParams->bAscending ? iResult : -iResult;
}


//+-------------------------------------------------------------------
//
//  Member:     DefaultCompare
//
//  Synopsis:   Compare two items, called by list control sort.
//              This is used if snapin wants default compare or
//              if it does not implement IResultDataCompare or
//              IResultDataCompareEx interfaces
//
//  Arguments:  [lParam1]      - Item1's lparam.
//              [lParam2]      - Item2's lparam.
//              [pSortParams] - ptr to SortParams.
//
//  Note:       If one is scope item and other is result item
//                          place scope item before result item.
//              Else get the text for both items and do string compare.
//
//  Returns:    -1 : item1 < item2
//               0 : item1 == item2
//              +1 : item1 > item2
//
//--------------------------------------------------------------------
int CALLBACK CCCListViewCtrl::DefaultCompare(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams_)
{
    SortParams*  pSortParams = reinterpret_cast<SortParams*>(pSortParams_);
    ASSERT(NULL != pSortParams);
    if (NULL == pSortParams)
        return 0;

    CResultItem* pri1 = CResultItem::FromHandle (lParam1);
    CResultItem* pri2 = CResultItem::FromHandle (lParam2);
    ASSERT( (NULL != pri1) && (NULL != pri2));
    if ( (NULL == pri1) || (NULL == pri2) )
        return 0;

    bool bScope1 = pri1->IsScopeItem();
    bool bScope2 = pri2->IsScopeItem();

    // If one of the item is scope pane item
    // scope item goes before result item.
    if (bScope1 != bScope2)
	{
		int iResult = bScope1 ? -1 : 1;
		return pSortParams->bAscending ? iResult : -iResult;
	}

    LPNODECALLBACK lpNodeCallback = pSortParams->lpNodeCallback;
    ASSERT(lpNodeCallback);
    if (NULL == lpNodeCallback)
         return 0;

    HRESULT hr = E_FAIL;
    CString strText1;
    CString strText2;

    if (bScope1)
    {
        // Both scope items, get the text for each item.
        HNODE hNode1 = pri1->GetScopeNode();
        HNODE hNode2 = pri2->GetScopeNode();

        USES_CONVERSION;
		tstring strName;

        // GetDisplayName uses a static array to return name so no need to free it.
        hr = lpNodeCallback->GetDisplayName(hNode1, strName);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
            strText1 = strName.data();

        hr = lpNodeCallback->GetDisplayName(hNode2, strName);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
            strText2 = strName.data();
    }
    else // both items are result items.
    {
        ASSERT(!bScope1 && ! bScope2);
        CCCListViewCtrl* pListView   = reinterpret_cast<CCCListViewCtrl*>(pSortParams->lpListView);
        ASSERT (pListView != NULL);
        ASSERT(pListView->IsVirtual() == FALSE); // Virtual list sort should not come here.

        LV_ITEMW lvi;
        ZeroMemory(&lvi, sizeof(LV_ITEMW));
        lvi.mask       = LVIF_TEXT;
        lvi.iSubItem   = pSortParams->nCol;
        lvi.cchTextMax = MAX_PATH;
        WCHAR szTemp[MAX_PATH+1];
        lvi.pszText    = szTemp;

        ASSERT(NULL != pSortParams->hSelectedNode);
        if (NULL != pSortParams->hSelectedNode)
        {
            lvi.lParam = lParam1;
            hr = lpNodeCallback->GetDispInfo(pSortParams->hSelectedNode, &lvi);
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                strText1 = lvi.pszText;

            lvi.lParam = lParam2;
            hr = lpNodeCallback->GetDispInfo(pSortParams->hSelectedNode, &lvi);
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                strText2 = lvi.pszText;
        }

    }

    if (strText1.IsEmpty() && strText2.IsEmpty())
        return (0);

	int rc = 0;

	/*
	 * Bug 9595: Do locale-sensitive, case-insensitive comparison
	 */
	switch (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, strText1, -1, strText2, -1))
	{
		case CSTR_LESS_THAN:
			rc = -1;
			break;

		case CSTR_EQUAL:
			rc = 0;
			break;

		case CSTR_GREATER_THAN:
			rc = 1;
			break;

		default:
			/*
			 * if an error occurred, fall back to locale-insensitive,
			 * case-insensitive comparison
			 */
			rc = _tcsicmp (strText1, strText2);
			break;
	}

	return pSortParams->bAscending ? rc: -rc;
}


int CCCListViewCtrl::SnapinCompare(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2)
{
    ASSERT(pSortParams->spResultCompare != NULL);

    // Set nResult to the current column
    int nResult = pSortParams->nCol;

    HRESULT hr = pSortParams->spResultCompare->Compare(pSortParams->lpUserParam, pri1->GetSnapinData(), pri2->GetSnapinData(), &nResult);

    return SUCCEEDED(hr) ? nResult : 0;
}

int CCCListViewCtrl::SnapinCompareEx(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2)
{
    ASSERT(pSortParams->spResultCompareEx != NULL);

    RDITEMHDR rdch1;
    RDITEMHDR rdch2;

    if (pri1->IsScopeItem())
    {
        rdch1.dwFlags = RDCI_ScopeItem;
        pSortParams->lpNodeCallback->GetNodeCookie(pri1->GetScopeNode(), &rdch1.cookie);
    }
    else
    {
        rdch1.dwFlags = 0;
        rdch1.cookie = pri1->GetSnapinData();
    }

    if (pri2->IsScopeItem())
    {
        rdch2.dwFlags = RDCI_ScopeItem;
        pSortParams->lpNodeCallback->GetNodeCookie(pri2->GetScopeNode(), &rdch2.cookie);
    }
    else
    {
        rdch2.dwFlags = 0;
        rdch2.cookie = pri2->GetSnapinData();
    }

    rdch1.lpReserved = 0;
    rdch2.lpReserved = 0;

    RDCOMPARE rdc;
    rdc.cbSize = sizeof(rdc);
    rdc.dwFlags = 0;
    rdc.nColumn = pSortParams->nCol;
    rdc.lUserParam = pSortParams->lpUserParam;
    rdc.prdch1 = &rdch1;
    rdc.prdch2 = &rdch2;

    int nResult = 0;
    HRESULT hr = pSortParams->spResultCompareEx->Compare(&rdc, &nResult);

    return SUCCEEDED(hr) ? nResult : 0;
}


HRESULT CCCListViewCtrl::Arrange(long style)
{
    return ((GetListCtrl().Arrange (style)) ? S_OK : S_FALSE);
}


HRESULT CCCListViewCtrl::Repaint(BOOL bErase)
{
    m_pListView->Invalidate(bErase);
    return S_OK;
}



HRESULT CCCListViewCtrl::SetItemCount(int iItemCount, DWORD dwOptions)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::SetItemCount"));

    ASSERT(iItemCount >= 0);
    ASSERT((dwOptions & ~(LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL)) == 0);

    // Ask the CAMCListViewCtrl to setup headers & set the flag.
    sc = ScCheckPointers(m_pListView, E_UNEXPECTED);
    if (! sc.IsError())
        sc = m_pListView->ScRestoreColumnsFromPersistedData();

    if (sc)
        sc.TraceAndClear();

    int iTop = ListView_GetTopIndex(GetListCtrl());

    if (ListView_SetItemCountEx (GetListCtrl(), iItemCount, dwOptions))
    {
        // if virtual list, update the item count
        // if not virtual, SetItemCount just reserves space for new items
        if (IsVirtual())
            m_itemCount = iItemCount;
    }
    else
    {
        ASSERT(FALSE);
        sc = E_FAIL;
    }

    iTop = ListView_GetTopIndex(GetListCtrl());

    if (sc)
        return sc.ToHr();

    // we cannot track any items any more - broadcast the message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewIndexesReset);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


HRESULT CCCListViewCtrl::SetChangeTimeOut(ULONG lTimeout)
{
    BOOL bStat = FALSE;
    if (GetHeaderCtrl())
        bStat = ::SendMessage(GetHeaderCtrl()->m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)lTimeout);

    return (bStat ? S_OK : E_FAIL);
}


HRESULT CCCListViewCtrl::SetColumnFilter(int nCol, DWORD dwType, MMC_FILTERDATA* pFilterData)
{
    HRESULT hr = S_OK;

    USES_CONVERSION;

    HD_ITEM item;

    do // not a loop
    {
        if (GetHeaderCtrl() == NULL)
        {
            hr = E_FAIL;
            break;
        }

        DWORD dwTypeOnly = dwType & ~MMC_FILTER_NOVALUE;
        BOOL bHasValue = !(dwType & MMC_FILTER_NOVALUE);

        // Validate filter type
        ASSERT(dwTypeOnly == MMC_INT_FILTER || dwTypeOnly == MMC_STRING_FILTER);
        if (!(dwTypeOnly == MMC_INT_FILTER || dwTypeOnly == MMC_STRING_FILTER))
        {
            hr = E_INVALIDARG;
            break;
        }

        // Check for non-null filterdata and pszText
        if ( ((dwType == MMC_STRING_FILTER || bHasValue) && pFilterData == NULL) ||
            (dwType == MMC_STRING_FILTER && bHasValue && pFilterData->pszText == NULL) )
        {
            ASSERT(FALSE);
            hr = E_POINTER;
            break;
        }

        ZeroMemory(&item, sizeof(item));
        item.mask = HDI_FILTER;
        item.type = dwType;

        HD_TEXTFILTER textFilter;

        switch (dwTypeOnly)
        {
        case MMC_INT_FILTER:
            item.pvFilter = &pFilterData->lValue;
            break;

        case MMC_STRING_FILTER:
            {
                item.pvFilter = &textFilter;
                textFilter.cchTextMax = pFilterData->cchTextMax;

                if (bHasValue)
                    textFilter.pszText = OLE2T(pFilterData->pszText);
                break;
            }

        default:
            ASSERT(FALSE);
       }


       if (!GetHeaderCtrl()->SetItem(nCol, &item))
       {
            ASSERT(FALSE);
            hr = E_FAIL;
        }
    }
    while(0);

    return hr;
}


HRESULT CCCListViewCtrl::GetColumnFilter(int nCol, DWORD* pdwType, MMC_FILTERDATA* pFilterData)
{

    HRESULT hr = S_OK;

    USES_CONVERSION;
    HD_ITEM item;


    do  // not a loop
    {
        if (GetHeaderCtrl() == NULL)
        {
            hr = E_FAIL;
            break;
        }

        ASSERT(pdwType != NULL);
        if (pdwType == NULL)
        {
            hr = E_POINTER;
            break;
        }

        ASSERT(*pdwType == MMC_INT_FILTER || *pdwType == MMC_STRING_FILTER);
        if (!(*pdwType == MMC_INT_FILTER || *pdwType == MMC_STRING_FILTER))
        {
            hr = E_INVALIDARG;
            break;
        }

        ASSERT(!(*pdwType == MMC_STRING_FILTER && pFilterData != NULL && pFilterData->pszText == NULL));
        if ((*pdwType == MMC_STRING_FILTER && pFilterData != NULL && pFilterData->pszText == NULL))
        {
            hr = E_INVALIDARG;
            break;
        }

        ZeroMemory(&item, sizeof(item));
        item.mask = HDI_FILTER;
        item.type = *pdwType;

        HD_TEXTFILTER textFilter;

        if (pFilterData != 0)
        {
            switch (*pdwType)
            {
            case MMC_INT_FILTER:
                item.pvFilter = &pFilterData->lValue;
                break;

            case MMC_STRING_FILTER:
                {
                    item.pvFilter = &textFilter;
                    textFilter.pszText = (LPTSTR)alloca((pFilterData->cchTextMax + 1) * sizeof(TCHAR));
                    textFilter.pszText[0] = 0;
                    textFilter.cchTextMax = pFilterData->cchTextMax;
                    break;
                }

            default:
                ASSERT(FALSE);
            }
        }

        BOOL bStat = GetHeaderCtrl()->GetItem(nCol, &item);
        if (!bStat)
            hr = E_FAIL;

        // NOTE: GetHeaderCtrl()->GetItem() fails when a string filter is empty
        // Until this is fixed, assume that the error is caused by this
        // and fake an empty string result
        if (hr == E_FAIL && item.type == MMC_STRING_FILTER)
        {
            item.type |= HDFT_HASNOVALUE;
            hr = S_OK;
        }

        // if requested string filter value, convert to caller's buffer
        if (hr == S_OK && item.type == MMC_STRING_FILTER && pFilterData != NULL)
        {
            ocscpy(pFilterData->pszText, T2OLE(textFilter.pszText));
        }

        *pdwType = item.type;
    }
    while(0);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnSortIcon
//
//  Synopsis:   Set sort arrow if needed.
//
//  Arguments:  [nNewCol]      - The column for which arrow should be set.
//              [nOldCol]      - The previous column, remove sort arrow.
//              [bAscending]   - Ascending/Descending.
//              [bSetSortIcon] - If arrow is needed or not.
//
//  Returns:    S_OK.
//
//  History:    04-01-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
HRESULT CCCListViewCtrl::SetColumnSortIcon(int nNewCol, int nOldCol,
                                           BOOL bAscending, BOOL bSetSortIcon)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::SetColumnSortIcon"));

    LVCOLUMN lvcol, lvOriginalCol;
    ZeroMemory(&lvcol, sizeof(lvcol));
    lvcol.mask = LVCF_FMT | LVCF_IMAGE;
    ZeroMemory(&lvOriginalCol, sizeof(lvOriginalCol));
    lvOriginalCol.mask = LVCF_FMT;

    // update the old column
    if ( nOldCol >= 0 )
    {
        // retrieve old frmt settings
        if ( !GetListCtrl().GetColumn(nOldCol, &lvOriginalCol) )
            return (sc = E_FAIL).ToHr();

        // make the new format settings
        // transfer old values such as LVCFMT_CENTER, which we do not want to change
        // see windows bugs (ntbug09) #153029 10/09/00
        lvcol.fmt = lvOriginalCol.fmt & ~(LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);

        // Reset the previous column's sort icon with blank icon.
        lvcol.iImage = -1;
        if ( !GetListCtrl().SetColumn(nOldCol, &lvcol) )
            return (sc = E_FAIL).ToHr();
    }

    // We have to add sort icon only if LV items can be sorted.
    // This is possible only if any of following condition is true.
    //    a. there are any result items in result pane         OR
    //    b. snapin supports IResultDataCompare                OR
    //    c. snapin supports IResultDataCompareEx              OR
    //    d. snapin wants default lexical sort                 OR
    //    e. snapin has virtual list

    BOOL bCanSortListView = (0 != (m_itemCount - m_nScopeItems))     ||
                            (NULL != m_sortParams.spResultCompare)   ||
                            (NULL != m_sortParams.spResultCompareEx) ||
                            (TRUE == m_sortParams.bLexicalSort)      ||
                            (IsVirtual());

    if ( bCanSortListView && bSetSortIcon)
    {
        // retrieve old frmt settings
        if ( !GetListCtrl().GetColumn(nNewCol, &lvOriginalCol) )
            return (sc = E_FAIL).ToHr();

        // make the new format settings
        // transfer old values such as LVCFMT_CENTER, which we do not want to change
        // see windows bugs (ntbug09) #153029 10/09/00
        lvcol.fmt = lvOriginalCol.fmt | LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT;

        // Set the sort icon for new column.
        lvcol.iImage = (bAscending) ? 0 : 1;
        if ( !GetListCtrl().SetColumn(nNewCol, &lvcol) )
            return (sc = E_FAIL).ToHr();
    }

    // De-select all the items in virtual list.
    if (IsVirtual())
    {
        int nItem = -1;
        LV_ITEM lvi;
        lvi.stateMask = LVIS_SELECTED;
        lvi.state     = ~LVIS_SELECTED;

       while ( (nItem = GetListCtrl().GetNextItem(nItem, LVNI_SELECTED)) != -1)
       {
          GetListCtrl().SetItemState(nItem, &lvi);
       }
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScRedrawHeader
//
//  Synopsis:    Need to send WM_SETREDRAW to headers to reduce flicker
//               when persisted column data is applied.
//               Turn it off before sending MMCN_SHOW to snapins and turn
//               it on after MMCN_SHOW returns.
//
//  Arguments:   [bRedraw] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScRedrawHeader (bool bRedraw)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScRedrawHeader"));

    CAMCHeaderCtrl* pHeader = GetHeaderCtrl();
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    int nViewMode  = GetViewMode();

    // Turn off/on the header only if it is report or filtered mode.

    // If turned on in other modes comctl does not take care of different
    // mode and will show headers (eg: in large icon mode).

    if ( (nViewMode != MMCLV_VIEWSTYLE_REPORT) && (nViewMode != MMCLV_VIEWSTYLE_FILTERED) )
		return sc;

    pHeader->SetRedraw(bRedraw);

    // If redraw is true then repaint the control.
    if (bRedraw)
        pHeader->InvalidateRect(NULL);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::SetLoadMode
 *
 * PURPOSE:  Turn on/off redraw on list control & header control when
 *           persisted list view settings (columns...) are applied.
 *
 * PARAMETERS:
 *    BOOL bState - load state, true -> turn-off redraw, false -> turn-on redraw
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CCCListViewCtrl::SetLoadMode(BOOL bState)
{
	DECLARE_SC(sc, TEXT("CCCListViewCtrl::SetLoadMode"));

    if (bState == m_bLoading)
        return (sc.ToHr());

    if (bState)
    {
        // turn off drawing during loading

		// 1. Turn off header.
        sc = ScRedrawHeader(false);
        if (sc)
            sc.TraceAndClear();

		// 2. Turn off the listcontrol.
		GetListCtrl().SetRedraw(false);
    }
    else
    {
        sc = ScCheckPointers(m_pListView, E_UNEXPECTED);
        if (sc)
            sc.TraceAndClear();
        else
        {
            sc = m_pListView->ScRestoreColumnsFromPersistedData();
            if (sc)
                sc.TraceAndClear();
        }

        // if sort requested while loading, sort the loaded items now
        if (m_bDeferredSort)
        {
			/*
			 * the sort could take awhile, so show a wait cursor
			 */
			CWaitCursor wait;

            GetListCtrl().SortItems (SortCompareFunc, (DWORD_PTR)&m_sortParams);
            m_bDeferredSort = FALSE;
        }

		// 1. Important, first turn on list and then header else header will not be redrawn.
		GetListCtrl().SetRedraw(true);

		// 2. Turn on the header.
        sc = ScRedrawHeader(true);
        if (sc)
            sc.TraceAndClear();
    }

    m_bLoading = bState;

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::GetColumnInfoList
//
//  Synopsis:    Get the current column settings.
//
//  Arguments:   [pColumnsList] - [out param], ptr to CColumnsInfoList.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CCCListViewCtrl::GetColumnInfoList (CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::GetColumnInfoList"));
    sc = ScCheckPointers(pColumnsList);
    if (sc)
        return sc.ToHr();

    CAMCListView *pAMCListView = GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pAMCListView->ScGetColumnInfoList(pColumnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ModifyColumns
//
//  Synopsis:    Modify the columns with given data.
//
//  Arguments:   [columnsList] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CCCListViewCtrl::ModifyColumns (const CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ModifyColumns"));
    CAMCListView *pAMCListView = GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pAMCListView->ScModifyColumns(columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::GetDefaultColumnInfoList
//
//  Synopsis:    Get the default column settings
//
//  Arguments:   [columnInfoList] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CCCListViewCtrl::GetDefaultColumnInfoList (CColumnInfoList& columnInfoList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetDefaultColumnInfoList"));
    CAMCListView *pAMCListView = GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pAMCListView->ScGetDefaultColumnInfoList(columnInfoList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::RenameItem
 *
 * PURPOSE: Puts the specified result item into rename mode.
 *
 * PARAMETERS:
 *    CResultItem* pri :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CCCListViewCtrl::RenameItem(HRESULTITEM itemID)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::RenameItem"));

    int nIndex = -1;
    sc = ScGetItemIndexFromHRESULTITEM(itemID, nIndex);
    if (sc)
        return sc.ToHr();

    if(nIndex < 0 || nIndex >= m_itemCount)
        return (sc = E_INVALIDARG).ToHr();

    // must have the focus to rename
    if (::GetFocus()!= GetListCtrl())
        SetFocus(GetListCtrl());

    // if the rename failed, E_FAIL is returned.
    if(NULL==GetListCtrl().EditLabel(nIndex))
        return (sc=E_FAIL).ToHr();

    return sc.ToHr();
}



HRESULT CCCListViewCtrl::OnModifyItem(CResultItem* pri)
{
    HRESULT hr = S_OK;

    int nItem = ResultItemToIndex(pri);
    if(nItem < 0 || nItem >= m_itemCount)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    LV_ITEM     lvi;
    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask        = LVIF_TEXT | LVIF_IMAGE;
    lvi.iItem       = nItem;
    lvi.pszText     = LPSTR_TEXTCALLBACK;
    lvi.iImage      = I_IMAGECALLBACK;

    GetListCtrl().SetItem( &lvi );

    if (!GetListCtrl().RedrawItems (nItem, nItem))
        hr = E_FAIL;
    CHECK_HRESULT(hr);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScSelectAll
//
//  Synopsis:    Select all the items in the list view.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScSelectAll ()
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScSelectAll"));

    LV_ITEM lvi;
    lvi.stateMask = lvi.state = LVIS_SELECTED;
    for (int i = 0; i < GetListCtrl().GetItemCount(); ++i)
    {
        // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
        if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(i), (LPARAM)(LV_ITEM FAR *)&lvi))
            return (sc = E_FAIL);
    }

    return (sc);
}


//-------------------------------------------------- Windows Hooks

BOOL CCCListViewCtrl::Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext /*=NULL*/ )
{
	DECLARE_SC (sc, _T("CCCListViewCtrl::Create"));
    ASSERT(pParentWnd != NULL && IsWindow(pParentWnd->m_hWnd));

    BOOL bRet = FALSE;

    // standard or virtual ?
    CAMCListView* pListView = (dwStyle & LVS_OWNERDATA) ? m_pVirtualList : m_pStandardList;

    ASSERT(pListView->m_hWnd == NULL);

    if (pListView->Create(NULL, NULL, dwStyle, rect, pParentWnd, nID, pContext))
    {
        // Attach image lists
        sc = ScSetImageLists ();
		if (sc)
		{
			pListView->DestroyWindow();
			return (false);
		}

        // update member variables
        m_bVirtual   = (dwStyle & LVS_OWNERDATA) ? TRUE : FALSE;
        m_pListView  = pListView;
        m_pParentWnd = pParentWnd;

        bRet = TRUE;
    }

    int iTop = ListView_GetTopIndex(GetListCtrl());

    return bRet;
}

SC CCCListViewCtrl::ScSetImageLists ()
{
	DECLARE_SC (sc, _T("CCCListViewCtrl::ScSetImageLists"));
    CListCtrl& lc = GetListCtrl();

    /*
     * if we need to create one list, we should need to create both
     */
    ASSERT ((m_smallIL.GetSafeHandle() == NULL) == (m_largeIL.GetSafeHandle() == NULL));

    /*
     * create the image lists, if necessary
     */
    if (m_smallIL.GetSafeHandle() == NULL)
    {
        if (!m_smallIL.Create(16, 16, ILC_COLORDDB | ILC_MASK, 20, 10) ||
			!m_largeIL.Create(32, 32, ILC_COLORDDB | ILC_MASK, 20, 10))
		{
			goto Error;
		}

        // Add standard MMC bitmaps
        CBitmap bmSmall;
        CBitmap bmLarge;
        if (!bmSmall.LoadBitmap(IDB_AMC_NODES16) || !bmLarge.LoadBitmap(IDB_AMC_NODES32))
			goto Error;

        sc = SetImageStrip (TVOWNED_MAGICWORD, bmSmall, bmLarge, 0, RGB(255,0,255));
		if (sc)
			goto Error;
    }

    /*
     * attach them to the list control
     */
    lc.SetImageList (&m_smallIL, LVSIL_SMALL);
    lc.SetImageList (&m_largeIL, LVSIL_NORMAL);

    /*
     * setting the small image list for the list control overwrites
     * the image list for the header control; fix it up
     */
	{
		CWnd* pwndHeader = GetHeaderCtrl();
		if (pwndHeader != NULL)
			Header_SetImageList (*pwndHeader, (HIMAGELIST) m_headerIL);
	}
	
	return (sc);

Error:
	/*
	 * DeleteImageList is safe to call on uncreated CImageLists
	 */
	m_smallIL.DeleteImageList();
	m_largeIL.DeleteImageList();

	/*
	 * If we haven't filled in the SC with an error code, try last error.
	 * Some (many) APIs fail without setting the last error, so if we still
	 * don't have an error code, give it a generic E_FAIL.
	 */
	if (!sc.IsError())
	{
		sc.FromLastError();

		if (!sc.IsError())
			sc = E_FAIL;
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::OnSysColorChange
 *
 * WM_SYSCOLORCHANGE handler for CCCListViewCtrl.
 *--------------------------------------------------------------------------*/

void CCCListViewCtrl::OnSysColorChange()
{
    m_headerIL.OnSysColorChange();

    CWnd* pwndHeader = GetHeaderCtrl();
    if (pwndHeader != NULL)
        Header_SetImageList (*pwndHeader, (HIMAGELIST) m_headerIL);
}

/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::ScAttachToListPad
 *
 * PURPOSE: Attaches/Detaches the list view to the listpad window. The listpad
 *          window is an IE frame. Attaching occurs by reparenting the list view.
 *
 * PARAMETERS:
 *    HWND  hwnd :  The new parent window, or NULL to detach
 *    HWND* phwnd : 1) non-NULL phwnd: The list view window handle is returned as
 *                     an out parameter
 *                  2) NULL phwnd: Detaches the list view control from the list pad.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
SC
CCCListViewCtrl::ScAttachToListPad (HWND hwnd, HWND* phwnd)
{
    DECLARE_SC (sc, TEXT("CCCListViewCtrl::ScAttachToListPad"));

    CAMCView* pAMCView = dynamic_cast<CAMCView*>(m_pParentWnd); // pointer is checked before usage, no need to test here.

    if (phwnd)
    {
        // attaching

        // are we still attached?
        if (m_SavedHWND)
        {
            //Attaching to ListPad when already attached - just make window exactly the same size as (new) parent
            RECT r;
            ::GetWindowRect (hwnd, &r);

            m_pListView->SetWindowPos (NULL, 0, 0,
                                       r.right-r.left,
                                       r.bottom-r.top, SWP_NOZORDER | SWP_NOACTIVATE);

            return sc;
        }
        else
        {
            // save current parent hwnd and its state
            m_SavedHWND = ::GetParent (m_pListView->m_hWnd);
            m_wp.length = sizeof(WINDOWPLACEMENT);
            ::GetWindowPlacement (m_pListView->m_hWnd, &m_wp);

            // switch to new one
            ::SetParent (m_pListView->m_hWnd, hwnd);
            m_pListView->ShowWindow (SW_SHOW);

            // make window exactly the same size as (new) parent
            RECT r;
            ::GetWindowRect (hwnd, &r);
            m_pListView->SetWindowPos (NULL, 0, 0,
                                       r.right-r.left,
                                       r.bottom-r.top, SWP_NOZORDER);

            // return back my window
            *phwnd = m_pListView->m_hWnd;

            // notify snapin of attach
            if (pAMCView)
                pAMCView->NotifyListPad (phwnd != NULL);
        }
    }
    else
    {
        // detaching
        if (m_SavedHWND == NULL)    // this may get called repeatedly...
            return S_OK;

        // notify snapin of detach
        if (pAMCView)
            pAMCView->NotifyListPad (phwnd != NULL);

        // change back parent window and its state
        HWND hWndNewParent = m_pListView->m_hWnd;

        ::SetParent (m_pListView->m_hWnd, m_SavedHWND);
        if (m_wp.length != 0)
        {
            m_wp.showCmd = SW_HIDE;
            ::SetWindowPlacement (m_pListView->m_hWnd, &m_wp);
        }

        // clear saved window and state
        m_SavedHWND = NULL;
        ZeroMemory (&m_wp, sizeof(WINDOWPLACEMENT));
        Reset();
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::OnCustomDraw
 *
 * NM_CUSTOMDRAW handler for CCCListViewCtrl.
 *--------------------------------------------------------------------------*/

LRESULT CCCListViewCtrl::OnCustomDraw (NMLVCUSTOMDRAW* plvcd)
{
    ASSERT (CWnd::FromHandle (plvcd->nmcd.hdr.hwndFrom) == m_pListView);

    return (m_FontLinker.OnCustomDraw (&plvcd->nmcd));
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::UseFontLinking
 *
 *
 *--------------------------------------------------------------------------*/

bool CCCListViewCtrl::UseFontLinking () const
{
    CAMCView* pAMCView = m_pListView->GetAMCView();
    ASSERT (pAMCView != NULL);

    DWORD dwListOptions = pAMCView->GetViewData()->GetListOptions();
    return (dwListOptions & RVTI_LIST_OPTIONS_USEFONTLINKING);
}

/*+-------------------------------------------------------------------------*
 * CListFontLinker::GetItemText
 *
 *
 *--------------------------------------------------------------------------*/

std::wstring CListFontLinker::GetItemText (NMCUSTOMDRAW* pnmcd) const
{
    NMLVCUSTOMDRAW* plvcd = reinterpret_cast<NMLVCUSTOMDRAW *>(pnmcd);

    int iItem     = pnmcd->dwItemSpec;
    int iSubItem  = (pnmcd->dwDrawStage & CDDS_SUBITEM) ? plvcd->iSubItem : 0;
    CListCtrl& lc = m_pListCtrl->GetListViewPtr()->GetListCtrl();

    USES_CONVERSION;
    return (std::wstring (T2CW (lc.GetItemText (iItem, iSubItem))));
}


/*+-------------------------------------------------------------------------*
 * CListFontLinker::IsAnyItemLocalizable
 *
 *
 *--------------------------------------------------------------------------*/

bool CListFontLinker::IsAnyItemLocalizable () const
{
    return (m_pListCtrl->UseFontLinking ());
}

//############################################################################
//############################################################################

class CMMCResultNode;

/*+-------------------------------------------------------------------------*
 * class CNodes
 *
 *
 * PURPOSE: base class for Nodes collections. Implements most of required methods
 *
 *+-------------------------------------------------------------------------*/
class CNodes :
    public CMMCIDispatchImpl<Nodes>,
    public CTiedComObject<CCCListViewCtrl>, // is tied to CCCListViewCtrl
    public CTiedObject,                     // enumerators are tied to it
    public CListViewObserver
{
protected:
    typedef CCCListViewCtrl CMyTiedObject; // tied to CCCListViewCtrl
private:
    // define collection type for cached Nodes
    typedef std::pair<int /*index*/, CMMCResultNode * /*pNode*/> col_entry_t;
    typedef std::vector<col_entry_t> col_t;

    // define comparison functor for b-search in a collection
    struct index_less : public std::binary_function<col_entry_t, int, bool>
    {
        bool operator()(const col_entry_t& x, const int& y) const { return (x.first < y); }
    };

public:
    BEGIN_MMC_COM_MAP(CNodes)
    END_MMC_COM_MAP()

    // returning self as tied object
    // class implements enumerator methods itself, but it is used as a base

    // we need to tell all node we are going down
    virtual ~CNodes() { InvalidateConnectedNodes(); }
    // Nodes interface
public:
    // methods forwarded to the list control
    STDMETHODIMP get_Count( PLONG pCount );
    STDMETHODIMP Item( long Index, PPNODE ppNode );

public:
    // observed events
    virtual ::SC ScOnListViewIndexesReset();
    virtual ::SC ScOnListViewItemInserted(int iIndex);
    virtual ::SC ScOnListViewItemDeleted (int iIndex);


    // Nodes enumeration impl
    ::SC ScEnumReset (int &pos);
    ::SC ScEnumNext  (int &pos, PDISPATCH & pDispatch);
    ::SC ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, int &pos);

    // node object helpers
    ::SC ScGetDisplayName(int iItem, CComBSTR& bstrName);
    ::SC ScUnadviseNodeObj(CMMCResultNode *node); // called from ~CMMCResultNode()

    // asked by ListControl [forwarded by Node] to check if Node belongs to it.
    // false if unconnected, else tries to match the owner
    bool IsTiedToThisList(CCCListViewCtrl *pvc);

    // returns Node representing the item (may reuse/create/forward-to-scope-tree)
    ::SC ScGetNode (int iItem, PPNODE ppNode );
    ::SC ScGetListCtrl(CCCListViewCtrl **ppListCtrl); // returns the tied list control

private:  // implementation helpers
    ::SC ScAdvancePosition( int& pos, unsigned nItems ); // returns S_FALSE if adv. less than req.
    // initializators
    void SetSelectedItemsOnly(bool bSelOnly)        { m_bSelectedItemsOnly = bSelOnly; }

    // breaks connection between Nodes and any Node object
    void InvalidateConnectedNodes();

    // data members
    bool            m_bSelectedItemsOnly;
    col_t           m_Nodes;

    friend class CCCListViewCtrl;
};

// this typedefs the CNodesEnum class. Implements get__NewEnum using CMMCEnumerator and a _Positon object
typedef CMMCNewEnumImpl<CNodes, int, CNodes> CNodesEnum;

//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CMMCResultNode
 *
 *
 * PURPOSE: Implements the Node automation interface, for a result node
 *
 *+-------------------------------------------------------------------------*/
class CMMCResultNode :
    public CMMCIDispatchImpl<Node>
{
public:
    BEGIN_MMC_COM_MAP(CMMCResultNode)
    END_MMC_COM_MAP()

    // Node methods
public:
    STDMETHODIMP get_Name( PBSTR  pbstrName);
    STDMETHODIMP get_Property( BSTR PropertyName,  PBSTR  PropertyValue);
    STDMETHODIMP get_Bookmark( PBSTR pbstrBookmark);
    STDMETHODIMP IsScopeNode(PBOOL pbIsScopeNode);
    STDMETHODIMP get_Nodetype(PBSTR Nodetype);

    CMMCResultNode();
    ~CMMCResultNode();

    SC  ScGetListCtrl(CCCListViewCtrl **ppListCtrl);

    int GetIndex() { return m_iIndex; }
    // asked by ListControl to check if Node belongs to it. false if orphan,
    // forwarded to Nodes else
    bool IsTiedToThisList(CCCListViewCtrl *pvc) { return (m_pNodes != NULL && m_pNodes->IsTiedToThisList(pvc)); }
private: // implementation
    ::SC      ScGetAMCView(CAMCView **ppAMCView);
    void    Invalidate() { m_iIndex = -1; m_pNodes = NULL; }
    int     m_iIndex;
    CNodes  *m_pNodes;

    friend class CNodes;
};
//############################################################################
//############################################################################
//
//  CCCListViewCtrl methods managing Node & Nodes objects
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScFindResultItem
 *
 * PURPOSE: finds the index in ListView for item identified by Node [helper]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to examine
 *    int &iItem    - storage for resulting index
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScFindResultItem( PNODE pNode, int &iItem )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSelect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    iItem = -1;

    // what type of node do we have
    BOOL bScopeNode = FALSE;
    sc = pNode->IsScopeNode(&bScopeNode);
    if (sc)
        return sc;

    if (bScopeNode) // scope node
    {
        // we do not have scope items in virtual lists
        if (IsVirtual())
            return sc = ScFromMMC(MMC_E_RESULT_ITEM_NOT_FOUND);

        // find the result item (with the help of the owner class)

        // check for view
        sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
        if (sc)
            return sc;

        // get AMCView
        CAMCView* pAMCView = m_pListView->GetAMCView();
        sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
        if (sc)
            return sc;

        // forward the request
        HRESULTITEM itm;
        sc = pAMCView->ScFindResultItemForScopeNode( pNode, itm );
        if (sc)
            return sc;

        // get the index of item
        iItem = ResultItemToIndex(CResultItem::FromHandle(itm));

        if (iItem < 0)
            return sc = E_UNEXPECTED; // shouldn't be so
    }
    else // result node
    {
        // convert the pointer
        CMMCResultNode *pResNode = dynamic_cast<CMMCResultNode *>(pNode);
        sc = ScCheckPointers(pResNode); // invalid param. isn't it ?
        if (sc)
            return sc;

        // now check if it's actually comming from this list
        if (!pResNode->IsTiedToThisList(this))
            return sc = E_INVALIDARG;

        iItem = pResNode->GetIndex();
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScSelect
 *
 * PURPOSE: selects item identified by node [implements View.Select()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to select
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScSelect( PNODE pNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSelect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // find the result item
    int nIdxToSelect = -1;
    sc = ScFindResultItem( pNode, nIdxToSelect );
    if (sc)
        return sc;

    // perform the action on list control
    // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
    LV_ITEM lvi;
    lvi.stateMask = lvi.state = LVIS_SELECTED;
    if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(nIdxToSelect), (LPARAM)(LV_ITEM FAR *)&lvi))
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScDeselect
 *
 * PURPOSE: deselects item identified by node [implements View.Deselect()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to deselect
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScDeselect( PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScDeselect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // find the result item
    int nIdxToSelect = -1;
    sc = ScFindResultItem( pNode, nIdxToSelect );
    if (sc)
        return sc;

    // perform the action on list control
    // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
    LV_ITEM lvi;
    lvi.stateMask = LVIS_SELECTED;
    lvi.state = 0;
    if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(nIdxToSelect), (LPARAM)(LV_ITEM FAR *)&lvi))
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScIsSelected
 *
 * PURPOSE: checks the status of item identified by node [implements View.IsSelected]
 *
 * PARAMETERS:
 *    PNODE pNode       - node to examine
 *    PBOOL pIsSelected - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScIsSelected( PNODE pNode,  PBOOL pIsSelected)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScIsSelected"));

    // parameter check
    sc = ScCheckPointers(pNode, pIsSelected);
    if (sc)
        return sc;

    *pIsSelected = FALSE;

    // find the result item
    int nIdxToSelect = -1;
    sc = ScFindResultItem( pNode, nIdxToSelect );
    if (sc)
        return sc;

    // perform the action on list control
    if ( 0 != (GetListCtrl().GetItemState( nIdxToSelect, LVIS_SELECTED ) & LVIS_SELECTED ))
        *pIsSelected = TRUE;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_ListItems
 *
 * PURPOSE:   returns Nodes enumeration including all list items
 *
 * PARAMETERS:
 *    PPNODES ppNodes - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_ListItems( PPNODES ppNodes )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_ListItems"));

    // get proper enumeration
    const bool bSelectedItemsOnly = false;
    sc = ScGetNodesEnum(bSelectedItemsOnly, ppNodes);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_SelectedItems
 *
 * PURPOSE:   returns Nodes enumeration including selected list items
 *
 * PARAMETERS:
 *    PPNODES ppNodes - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_SelectedItems( PPNODES ppNodes)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_SelectedItems"));

    // get proper enumeration
    const bool bSelectedItemsOnly = true;
    sc = ScGetNodesEnum(bSelectedItemsOnly, ppNodes);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScValidateItem
 *
 * PURPOSE: helper function inspecting the index validity and node type
 *
 * PARAMETERS:
 *    int  iItem        - item to inspect
 *    bool &bScopeNode  - result: is it a scope node
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScValidateItem( int  iItem, bool &bScopeNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScValidateItem"));

    // check the index
    if (iItem < 0 || iItem >= GetListCtrl().GetItemCount())
        return sc = E_INVALIDARG;


    bScopeNode = false; // its always false for virtual lists
    if (!IsVirtual())
    {
        // now try to guess what kind of result item we have
        CResultItem* pri = IndexToResultItem (iItem);
        sc = ScCheckPointers(pri, E_UNEXPECTED);
        if (sc)
            return sc;

        bScopeNode = pri->IsScopeItem();
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScGetNodesEnum
 *
 * PURPOSE: returns [creates if needed] com object Nodes
 *
 * PARAMETERS:
 *    EnumType enumType - type of enumeration requested [all items/selected items]
 *    PPNODES ppNodes   - storage for the result (addref'ed for the caller)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScGetNodesEnum(bool bSelectedItemsOnly, PPNODES ppNodes)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetNodesEnum"));

    // parameter check
    sc = ScCheckPointers ( ppNodes );
    if (sc)
        return sc;

    // result initialization
    *ppNodes = NULL;

    // get a reference to proper variable
    NodesPtr& rspNodes = bSelectedItemsOnly ? m_spSelNodes : m_spAllNodes;

    if (rspNodes == NULL) // don't we have it ready?
    {
        // create a CNodesEnum object
        sc = CTiedComObjectCreator<CNodesEnum>::ScCreateAndConnect(*this, rspNodes);
        if (sc)
            return (sc);

        // get the actual object
        typedef CComObject<CNodesEnum> CNodesEnumObj;
        CNodesEnumObj *pNodesEnum = dynamic_cast<CNodesEnumObj*>(rspNodes.GetInterfacePtr());

        // check the pointer
        sc = ScCheckPointers( pNodesEnum, E_UNEXPECTED );
        if(sc)
            return sc;

        // update internal data
        pNodesEnum->SetSelectedItemsOnly(bSelectedItemsOnly);
        // add new object as an observer to the view
        AddObserver(static_cast<CListViewObserver&>(*pNodesEnum));
    }

    // addref and return the pointer for the client.
    *ppNodes = rspNodes;
    (*ppNodes)->AddRef();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScGetScopeNodeForItem
 *
 * PURPOSE: transit point for Scope Node request - comes from enumeration, forwarded
 *          to AMCView and further to ScopeTree
 *
 * PARAMETERS:
 *    int  iItem        - node index to retrieve
 *    PPNODE ppNode     - result storage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScGetScopeNodeForItem( int iItem,  PPNODE ppNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetScopeNodeForItem"));

    // check the parameters
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;

    // initialize the result
    *ppNode = NULL;

    // now try to guess what kind of result item we have
    CResultItem* pri = IndexToResultItem(iItem);
    sc = ScCheckPointers(pri, E_UNEXPECTED);
    if (sc)
        return sc;

    // get the hNode
    HNODE hNode = pri->GetScopeNode();

    // check for view
    sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
    if (sc)
        return sc;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward the request
    sc = pAMCView->ScGetScopeNode( hNode, ppNode );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::ScGetAMCView
 *
 * PURPOSE: Returns a pointer to the parent CAMCView
 *
 * PARAMETERS:
 *    CAMCView ** ppAMCView :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CCCListViewCtrl::ScGetAMCView(CAMCView **ppAMCView)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetAMCView"));

    sc = ScCheckPointers(ppAMCView);
    if(sc)
        return sc;

    *ppAMCView = NULL;

    // check for view
    sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
    if (sc)
        return sc;

    // get AMCView
    *ppAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers(*ppAMCView, E_UNEXPECTED);

    return sc;
}

//############################################################################
//############################################################################
//
//  Implementation of class CNodes
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CNodes::ScEnumReset
 *
 * PURPOSE: resets position for Nodes enumeration
 *
 * PARAMETERS:
 *    int &pos  - position to reset
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScEnumReset(int &pos)
{
    DECLARE_SC(sc, TEXT("CNodes::ScEnumReset"));

    pos = -1;
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNodes::ScGetListCtrl
 *
 * PURPOSE: Returns a pointer to the list control
 *
 * GUARANTEE: if the function succeeds, the list control pointer is valid.
 *
 * PARAMETERS:
 *    CCCListViewCtrl ** ppListCtrl :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNodes::ScGetListCtrl(CCCListViewCtrl **ppListCtrl)
{
    DECLARE_SC(sc, TEXT("CNodes::ScGetListCtrl"));

    sc = ScCheckPointers(ppListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    *ppListCtrl = NULL;
    sc = ScGetTiedObject(*ppListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(*ppListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CNodes::ScAdvancePosition
 *
 * PURPOSE: advances position (index) of item depending on collection type
 *
 * PARAMETERS:
 *    int& pos   - position to update
 *    int nItems - count of items to skip
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScAdvancePosition( int& pos, unsigned nItems )
{
    DECLARE_SC(sc, TEXT("CNodes::ScAdvancePosition"));

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // inspect if we aren't behind the end
    int nCount = pListCtrl->GetListCtrl().GetItemCount();
    if (pos >= nCount)
        return sc = E_FAIL; // we did not got a valid position

    // advance depending on collection type
    if (m_bSelectedItemsOnly)
    {
        // we only can do it by iterating
        for (int i = 0; i < nItems; i++)
        {
            int iItem = pListCtrl->GetListCtrl().GetNextItem( pos, LVNI_SELECTED );
            if (iItem < 0)
                return sc = S_FALSE; // we didn't advance as much as requested
            pos = iItem;
        }
    }
    else // all_items selection
    {
        pos += nItems;
        if (pos >= nCount)
        {
            pos = nCount - 1;
            return sc = S_FALSE; // we didn't advance as much as requested
        }
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScEnumNext
 *
 * PURPOSE: Retrieves next item from enumeration [ Implements Nodes.Next ]
 *
 * PARAMETERS:
 *    int &pos                  - position to start from
 *    IDispatch * &pDispatch    - resulting item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScEnumNext(int &pos, IDispatch * &pDispatch)
{
    DECLARE_SC(sc, TEXT("CNodes::ScEnumNext"));

    // get the index of next item
    sc = ScAdvancePosition( pos, 1 /*nItems*/ );
    if (sc.IsError() || sc == SC(S_FALSE))
        return sc;

    // get the result node for the index
    PNODE pNode = NULL;
    sc = ScGetNode( pos, &pNode );
    if (sc)
        return sc;

    // assign to result
    pDispatch = pNode;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScEnumSkip
 *
 * PURPOSE: skips items in enumeration [implements Nodes.Skip method]
 *
 * PARAMETERS:
 *    unsigned long celt            - positions to skip
 *    unsigned long &celtSkipped    - result: positions skiped
 *    int &pos                      - position to update
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScEnumSkip(unsigned long celt,unsigned long &celtSkipped, int &pos)
{
    DECLARE_SC(sc, TEXT("CNodes::ScEnumSkip"));

    // init val.
    celtSkipped = 0;

    // save the position for evaluation
    int org_pos = pos;

    // advance the position
    sc = ScAdvancePosition( pos, celt );
    if (sc)
        return sc;

    // calculate items skipped
    celtSkipped = pos - org_pos;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CNodes::get_Count
 *
 * PURPOSE: returns count of object in enumeration [Implements Nodes.Count]
 *
 * PARAMETERS:
 *    PLONG pCount  - storage for result
 *
 * RETURNS:
 *    HRESULT  - result code
 *
\***************************************************************************/
STDMETHODIMP CNodes::get_Count( PLONG pCount )
{
    DECLARE_SC(sc, TEXT("CNodes::get_Count"));

    // parameter check
    sc = ScCheckPointers ( pCount );
    if (sc)
        return sc.ToHr();

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    // get count from the control
    if (m_bSelectedItemsOnly)
        *pCount = pListCtrl->GetListCtrl().GetSelectedCount();
    else
        *pCount = pListCtrl->GetListCtrl().GetItemCount();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodes::Item
 *
 * PURPOSE: - returns Item from enumeration [Implements Nodes.Item]
 *
 * PARAMETERS:
 *    long Index    - Index of item to retrieve
 *    PPNODE ppNode - storage for resulting node ptr
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
STDMETHODIMP CNodes::Item( long Index, PPNODE ppNode )
{
    DECLARE_SC(sc, TEXT("CNodes::Item"));

    // parameter check
    sc = ScCheckPointers ( ppNode );
    if (sc)
        return sc.ToHr();

    *ppNode = NULL;

    // check the index
    if (Index <= 0)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    int iPos = -1; // just before the first item at start
    // get to the right item
    sc = ScAdvancePosition(iPos, Index);
    if (sc == SC(S_FALSE))    // didn't get far enough?
        sc = E_INVALIDARG;   // means we've got the wrong Index
    if (sc) // got an error?
        return sc.ToHr();

    // now get the node
    sc = ScGetNode( iPos, ppNode );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScGetNode
 *
 * PURPOSE: Retrieves cached or creates new Node object
 *
 * PARAMETERS:
 *    int iIndex        - index of result item
 *    PPNODE ppNode     - storage for resulting node
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScGetNode(int iItem, PPNODE ppNode)
{
    DECLARE_SC(sc, TEXT("CNodes::ScGetNode"));

    // parameter check
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;

    // initial return value
    *ppNode = NULL;

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // inspect what kind of item we have
    bool bScopeNode;
    sc = pListCtrl->ScValidateItem( iItem, bScopeNode );
    if (sc)
        return sc;

    if (bScopeNode)
    {
        // do not handle this - pass to the owner
        sc = pListCtrl->ScGetScopeNodeForItem ( iItem, ppNode );
        if (sc)
            return sc;

        return sc;
    }

    // "normal" list item (not a scope node) - we can handle ourselves

    // find either the entry or the place to insert
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iItem, index_less());

    if (it!= m_Nodes.end() && it->first == iItem)
    {
        // we already have it!!! , recheck!
        sc = ScCheckPointers(it->second, E_UNEXPECTED);
        if (sc)
            return sc;

        // return it!
        *ppNode = it->second;
        (*ppNode)->AddRef();
        return sc;
    }

    // doesn't exist - need to create one

    typedef CComObject<CMMCResultNode> CResultNode;
    CResultNode *pResultNode = NULL;
    CResultNode::CreateInstance(&pResultNode);

    sc = ScCheckPointers(pResultNode, E_OUTOFMEMORY);
    if(sc)
        return sc;

    // update the information on the node
    pResultNode->m_iIndex = iItem;
    pResultNode->m_pNodes = this;

    m_Nodes.insert(it, col_entry_t(iItem, pResultNode));
    // return it!
    *ppNode = pResultNode;
    (*ppNode)->AddRef();

    return sc;
}
/***************************************************************************\
 *
 * METHOD:  CNodes::ScGetDisplayName
 *
 * PURPOSE:     retrievs the display name of the Node
 *
 * PARAMETERS:
 *    int iIndex            - index of the result item
 *    CComBSTR& bstrName    - storage for resulting text
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScGetDisplayName(int iItem, CComBSTR& bstrName)
{
    DECLARE_SC(sc, TEXT("CNodes::ScGetDisplayName"));

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // check the index
    if (iItem < 0 || iItem >= pListCtrl->GetListCtrl().GetItemCount())
        return sc = E_INVALIDARG;

    // get the text
    bstrName = pListCtrl->GetListCtrl().GetItemText( iItem, 0 /*column*/);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScUnadviseNodeObj
 *
 * PURPOSE: Remove Node from collection. called from ~CMMCResultNode()
 *
 * PARAMETERS:
 *    CMMCResultNode *node - node to remove
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScUnadviseNodeObj(CMMCResultNode *node)
{
    DECLARE_SC(sc, TEXT("CNodes::ScUnadviseNodeObj"));

    // parameter check
    sc = ScCheckPointers(node);
    if (sc)
        return sc;

    // index of the node
    int iIndex = node->m_iIndex;

    // find the entry by index
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iIndex, index_less());

    if (it== m_Nodes.end() || it->first != iIndex)
    {
        // we do not have it ???
        sc = E_UNEXPECTED;
        return sc;
    }

    // remove from collection
    m_Nodes.erase(it);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScOnListViewIndexesReset
 *
 * PURPOSE: Fired Event handler. Wipes the cached info
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScOnListViewIndexesReset()
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnListViewIndexesReset"));

    InvalidateConnectedNodes();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::InvalidateConnectedNodes
 *
 * PURPOSE: wipes out the cache. invalidates alive nodes
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CNodes::InvalidateConnectedNodes()
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnListViewIndexesReset"));

    // orphan all alive nodes - we do not keep pointers
    col_t::iterator it;
    for (it = m_Nodes.begin(); it != m_Nodes.end(); ++it)
    {
        // get the pointer to com object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_POINTER);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }
        // reset the container info
        pNode->Invalidate();
    }

    // clear the collection;
    m_Nodes.clear();
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScOnListViewItemInserted
 *
 * PURPOSE: Fired Event handler. shifts index info
 *
 * PARAMETERS:
 *    int iIndex - index of newly inserted item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScOnListViewItemInserted(int iIndex)
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnListViewItemInserted"));

    // find the insertion point
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iIndex, index_less());

    // increment all the entries following it
    while (it != m_Nodes.end())
    {
        // increment index in own collection
        ++(it->first);
        // get the pointer to com object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc;
        // increment member on com object
        ++(pNode->m_iIndex);
        // get to the next item
        ++it;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScOnListViewItemDeleted
 *
 * PURPOSE: Fired Event handler. shifts index info
 *
 * PARAMETERS:
 *    int iIndex - index of removed item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScOnListViewItemDeleted (int iIndex)
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnlistViewItemDeleted"));

    // find the insertion point
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iIndex, index_less());

    // if we have an object at the position, get rid of it!
    if (it != m_Nodes.end() && it->first == iIndex)
    {
        // get pointer to the object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc;
        // reset the container info
        pNode->Invalidate();
        it = m_Nodes.erase(it);
    }

    // decrement all the entries following it
    while (it != m_Nodes.end())
    {
        // decrement index in own collection
        --(it->first);
        // get the pointer to com object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc;
        // decrement member on com object
        --(pNode->m_iIndex);
        // get to the next item
        ++it;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::IsTiedToThisList
 *
 * PURPOSE: this method is called from node which needs to know if it
 *          belongs to the the this list (as a result item on it)
 *
 * PARAMETERS:
 *    CCCListViewCtrl *pvc
 *
 * RETURNS:
 *    false if unconnected or belongs to other list
 *
\***************************************************************************/
bool CNodes::IsTiedToThisList(CCCListViewCtrl *pvc)
{
    DECLARE_SC(sc, TEXT("CNodes::IsTiedToThisList"));

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return false;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return false;

    return (pListCtrl == pvc);
}

//############################################################################
//############################################################################
//
//  Implementation of class CMMCResultNode
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::CMMCResultNode
 *
 * PURPOSE: default constructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCResultNode::CMMCResultNode() : m_pNodes(NULL), m_iIndex(-1)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::CMMCResultNode"));
    Invalidate();
}

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::~CMMCResultNode
 *
 * PURPOSE: Destructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCResultNode::~CMMCResultNode()
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::~CMMCResultNode"));

    // informing container about desruction
    if (m_pNodes)
    {
        sc = m_pNodes->ScUnadviseNodeObj(this);
        if (sc)
            sc.TraceAndClear();
    }
}

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::get_Name
 *
 * PURPOSE: Returns the display name of the node.
 *
 * PARAMETERS:
 *    PBSTR  pbstrName - result (name)
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCResultNode::get_Name( PBSTR  pbstrName)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Name"));

    // check the parameters
    sc = ScCheckPointers( pbstrName );
    if (sc)
        return sc.ToHr();

    // initialize output
    *pbstrName = NULL;

    // check the container
    sc = ScCheckPointers( m_pNodes, E_FAIL );
    if (sc)
        return sc.ToHr();

    // ask owner about the name
    CComBSTR bstrResult;
    sc = m_pNodes->ScGetDisplayName(m_iIndex, bstrResult);
    if (sc)
        return sc.ToHr();

    // return the result result
    *pbstrName = bstrResult.Detach();

    // recheck pointer before return
    sc = ScCheckPointers( *pbstrName, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CMMCResultNode::ScGetAMCView
 *
 * PURPOSE: Returns a pointer to the view.
 *
 * PARAMETERS:
 *    CAMCView ** ppAMCView :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMMCResultNode::ScGetAMCView(CAMCView **ppAMCView)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::ScGetAMCView"));

    // check parameters
    sc = ScCheckPointers(ppAMCView);
    if(sc)
        return sc;

    // init out parameter
    *ppAMCView = NULL;

   // check the container
    sc = ScCheckPointers( m_pNodes, E_FAIL );
    if (sc)
        return sc;

    CCCListViewCtrl *pListCtrl = NULL;

    sc = m_pNodes->ScGetListCtrl(& pListCtrl);
    if(sc)
        return sc;

    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = pListCtrl->ScGetAMCView(ppAMCView);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCResultNode::get_Property
 *
 * PURPOSE: Returns the specified clipboard format data (must be a text
 *          format) for the node.
 *
 * PARAMETERS:
 *    BSTR   PropertyName :
 *    PBSTR  PropertyValue :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCResultNode::get_Property( BSTR PropertyName,  PBSTR  PropertyValue)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Property"));

    CAMCView *pAMCView = NULL;

    sc = ScGetAMCView(&pAMCView);
    if(sc)
        return sc.ToHr();


    sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();


    sc = pAMCView->ScGetProperty(m_iIndex, PropertyName, PropertyValue);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CMMCResultNode::get_Nodetype
 *
 * PURPOSE: Returns the GUID nodetype identifier for the node.
 *
 * PARAMETERS:
 *    PBSTR  Nodetype : [out] the nodetype identifier.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCResultNode::get_Nodetype(PBSTR Nodetype)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Nodetype"));

    CAMCView *pAMCView = NULL;

    sc = ScGetAMCView(&pAMCView);
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pAMCView->ScGetNodetype(m_iIndex, Nodetype);

    return sc.ToHr();
}



/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::get_Bookmark
 *
 * PURPOSE: Returns error always - not valid for result items
 *
 * PARAMETERS:
 *    PBSTR pbstrBookmark
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCResultNode::get_Bookmark( PBSTR pbstrBookmark )
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Bookmark"));

    // check the parameters
    sc = ScCheckPointers( pbstrBookmark );
    if (sc)
        return sc.ToHr();

    // initialize output
    *pbstrBookmark = NULL;

    // report the error - always
    sc = ScFromMMC( MMC_E_NO_BOOKMARK );
    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::IsScopeNode
 *
 * PURPOSE: returns TRUE if it's a scope node ( i.e. always returns FALSE)
 *
 * PARAMETERS:
 *    PBOOL pbIsScopeNode
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCResultNode::IsScopeNode(PBOOL pbIsScopeNode)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::IsScopeNode"));

    sc = ScCheckPointers( pbIsScopeNode );
    if(sc)
        return sc.ToHr();

    // if it's here it's for sure not a scope node
   *pbIsScopeNode = FALSE;

   return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::ScAllocResultItem
 *
 * Allocates a CResultItem for a list control item.
 *--------------------------------------------------------------------------*/

SC CCCListViewCtrl::ScAllocResultItem (
    CResultItem*& pri,                  /* O:new list item                  */
    COMPONENTID id,                     /* I:owning component ID            */
    LPARAM      lSnapinData,            /* I:snap-in's data for this item   */
    int         nImage)                 /* I:image index                    */
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::ScAllocResultItem"));

    pri = new CResultItem (id, lSnapinData, nImage);

    sc = ScCheckPointers (pri, E_OUTOFMEMORY);
    if (sc)
        return (sc);

    return (sc);
}



/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::ScFreeResultItem
 *
 * Frees a CResultItem that was allocated with ScAllocResultItem.
 *--------------------------------------------------------------------------*/

SC CCCListViewCtrl::ScFreeResultItem (
    CResultItem*  priFree)                /* I:list item to free              */
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::ScFreeResultItem"));

    sc = ScCheckPointers (priFree, E_UNEXPECTED);
    if (sc)
        return (sc);

    delete priFree;

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Columns
 *
 * PURPOSE: returns pointer to Columns object; create one if required
 *
 * PARAMETERS:
 *    PPCOLUMNS ppColumns   - resulting pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_Columns(PPCOLUMNS ppColumns)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Columns"));

    // Check received parameters
    sc = ScCheckPointers(ppColumns);
    if (sc)
        return sc;

    // initialize
    *ppColumns = NULL;

    // create the object when required
    sc = CTiedComObjectCreator<CColumns>::ScCreateAndConnect(*this, m_spColumns);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(m_spColumns, E_UNEXPECTED);
    if (sc)
        return sc;

    // return the pointer
    *ppColumns = m_spColumns;
    (*ppColumns)->AddRef();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Count
 *
 * PURPOSE: returns the count of columns in LV
 *
 * PARAMETERS:
 *    PLONG pCount
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_Count( PLONG pCount )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Count"));

    // Check received parameters
    sc = ScCheckPointers(pCount);
    if (sc)
        return sc;

    // return the result
    *pCount = GetColCount();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScEnumNext
 *
 * PURPOSE:     advances position pointer for Columns enum. returns the object at the pos
 *
 * PARAMETERS:
 *    int &iZeroBasedPos    - position to modify
 *    PDISPATCH & pDispatch - resulting pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScEnumNext(int &iZeroBasedPos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScEnumNext"));

    // initialize
    pDispatch = NULL;

    // advance;
    iZeroBasedPos++;

    // recheck the pos
    if (iZeroBasedPos < 0)
        return sc = E_UNEXPECTED;

    // no more columns?
    if (iZeroBasedPos >= GetColCount())
        return sc = S_FALSE;

    // retrieve the column
    ColumnPtr spColumn;
    // ScItem accepts 1-based index
    sc = ScItem( iZeroBasedPos + 1, &spColumn );
    if (sc)
        return sc;

    //return the interface.
    pDispatch = spColumn.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScEnumSkip
 *
 * PURPOSE: skips several items for Columns enum
 *
 * PARAMETERS:
 *    unsigned long celt
 *    unsigned long& celtSkipped
 *    int &iZeroBasedPos
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, int &iZeroBasedPos)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScEnumSkip"));

    // init [out] param
    celtSkipped = 0;

    // recheck the pos
    if (iZeroBasedPos < -1)
        return sc = E_UNEXPECTED;

    // already past the end?
    if (iZeroBasedPos >= GetColCount())
        return sc = S_FALSE;

    // how far can we advance ?;
    celtSkipped = GetColCount() - iZeroBasedPos;
    if (celtSkipped > celt)
        celtSkipped = celt;

    // advance
    iZeroBasedPos += celtSkipped;

    return sc = ((celtSkipped == celt) ? S_OK : S_FALSE);
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScEnumReset
 *
 * PURPOSE:     resets position index for Columns enum
 *
 * PARAMETERS:
 *    int &iZeroBasedPos  position to modify
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScEnumReset(int &iZeroBasedPos)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScEnumReset"));

    iZeroBasedPos = -1;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScItem
 *
 * PURPOSE:     returns Column com object from Columns collection
 *
 * PARAMETERS:
 *    long lOneBasedIndex - [in] - column index (1 based)
 *    PPCOLUMN ppColumn   - [out] - resulting object
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScItem( long lOneBasedIndex, PPCOLUMN ppColumn )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScItem"));

    // Check received parameters
    sc = ScCheckPointers(ppColumn);
    if (sc)
        return sc;

    // initialize output
    *ppColumn = NULL;

    // check the index
    int iZeroBasedIndex = lOneBasedIndex - 1;
    if (iZeroBasedIndex < 0 || iZeroBasedIndex >= GetColCount())
        return sc = ::ScFromMMC(MMC_E_INVALID_COLUMN_INDEX);

    // construct the object
    typedef CComObject<CColumn> CComColumn;
    ColumnPtr /*CComPtr<CComColumn>*/ spColumn;

    // create the object when required
    sc = CTiedComObjectCreator<CColumn>::ScCreateAndConnect(*this, spColumn);
    if (sc)
        return sc;

    // get 'raw' pointer
    CComColumn *pColumn = dynamic_cast<CComColumn *>(spColumn.GetInterfacePtr());

    // recheck the pointer
    sc = ScCheckPointers(pColumn, E_UNEXPECTED);
    if (sc)
        return sc;

    // initialize the object
    pColumn->SetIndex(iZeroBasedIndex);

    // let it observe what's going on and manage its own index
    AddObserver(static_cast<CListViewObserver&>(*pColumn));

    // return the pointer
    *ppColumn = spColumn;
    (*ppColumn)->AddRef();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScName
 *
 * PURPOSE:         Returns column name. Implements Column.Name property
 *
 * PARAMETERS:
 *    BSTR *Name                - the returned name
 *    int iZeroBasedColIndex    - index of column of interest
 *
 * RETURNS:
 *    SC    - result code
 *
 \***************************************************************************/
SC CCCListViewCtrl::ScName( /*[out, retval]*/ BSTR *Name, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScName"));

    // Check received parameters
    sc = ScCheckPointers(Name);
    if (sc)
        return sc;

    // initialize output
    *Name = NULL;

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    LPOLESTR pstrName = NULL;
    sc = GetColumn(iZeroBasedColIndex, &pstrName, MMCLV_NOPTR, MMCLV_NOPTR);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pstrName, E_UNEXPECTED);
    if (sc)
        return sc;

    *Name = ::SysAllocString(pstrName);
    ::CoTaskMemFree(pstrName);

    // recheck the result
    sc = ScCheckPointers(*Name, E_OUTOFMEMORY);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScGetColumnData
 *
 * PURPOSE:     helper for Column com object implementation
 *              - checks column index
 *              - retrieves information about the column
 *
 * PARAMETERS:
 *    int iZeroBasedColIndex        - column index
 *    ColumnData *pColData          - storage for resulting data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScGetColumnData( int iZeroBasedColIndex, ColumnData *pColData )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetColumnData"));

    // Check received parameters (its internal function, so it's unexpected if the params are bad)
    sc = ScCheckPointers(pColData, E_UNEXPECTED);
    if (sc)
        return sc;

    // init the structure;
    pColData->Init();

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    // need to get the header control for managing columns
    CAMCHeaderCtrl* pHeader = GetHeaderCtrl();

    // check!
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    // get the lParam
    HDITEM hdItem;
    ::ZeroMemory(&hdItem, sizeof(hdItem));
    hdItem.mask    = HDI_LPARAM | HDI_WIDTH | HDI_ORDER;
    BOOL bRet = pHeader->GetItem(iZeroBasedColIndex, &hdItem);
    if (!bRet)
        return sc = E_FAIL;

	CHiddenColumnInfo hci (hdItem.lParam);

    pColData->iColumnOrder =    hdItem.iOrder;
    pColData->bIsHidden =       hci.fHidden;
    pColData->iColumnWidth =    hdItem.cxy;
    if (pColData->bIsHidden)    // special case for hidden columns
        pColData->iColumnWidth = hci.cx;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScSetColumnData
 *
 * PURPOSE:     helper for Column com object implementation
 *              - modifies column
 *              NOTE - not to be used for SHOW/HIDE operations
 *
 * PARAMETERS:
 *    int iZeroBasedColIndex        - column index
 *    const ColumnData& rColData    - modified column data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScSetColumnData( int iZeroBasedColIndex, const ColumnData& rColData )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSetColumnData"));

    ColumnData oldColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &oldColData );
    if (sc)
        return sc;

    // check if anything  has changed
    if (oldColData == rColData)
        return sc;

    // the visibility of column cannot be changed directly
    // the snapin has be notified about that.
    // the request should never come here
    if (rColData.bIsHidden != oldColData.bIsHidden)
        return sc = E_UNEXPECTED;

    // need to get the header control for managing columns
    CAMCHeaderCtrl* pHeader = GetHeaderCtrl();

    // check!
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    // now set the new data
    HDITEM hdItem;
    ::ZeroMemory(&hdItem, sizeof(hdItem));

    // set the width properly (no mater if colum is hidden)
    if (rColData.bIsHidden)
    {
		CHiddenColumnInfo hci (rColData.iColumnWidth, true);

        hdItem.lParam = hci.lParam;
        hdItem.mask   = HDI_LPARAM;
    }
    else
    {
        hdItem.mask = HDI_WIDTH;
        hdItem.cxy = rColData.iColumnWidth;
    }

    // set the order info
    hdItem.mask   |= HDI_ORDER;
    hdItem.iOrder = rColData.iColumnOrder;

    // set the column data
    BOOL bRet = pHeader->SetItem(iZeroBasedColIndex, &hdItem);
    if (!bRet)
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Width
 *
 * PURPOSE:     Returns width of column. Implements get for Column.Width
 *
 * PARAMETERS:
 *    PLONG Width               - resulting width
 *    int iZeroBasedColIndex    - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
 \***************************************************************************/
SC CCCListViewCtrl::Scget_Width( /*[out, retval]*/ PLONG Width, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Width"));

    // Check received parameters
    sc = ScCheckPointers(Width);
    if (sc)
        return sc;

    // initialize output
    *Width = 0;

    // retrieve data for column (this also checks the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    *Width = strColData.iColumnWidth;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scput_Width
 *
 * PURPOSE:     Sets width of column. Implements put for Column.Width
 *
 * PARAMETERS:
 *    LONG Width                - new width
 *    int iZeroBasedColIndex    - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
 \***************************************************************************/
SC CCCListViewCtrl::Scput_Width( /*[in]*/ long Width, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scput_Width"));

    ColumnData strColData;
    // retrieve current column data
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // change the width
    strColData.iColumnWidth = Width;

    // set modified column data
    sc = ScSetColumnData( iZeroBasedColIndex, strColData );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_DisplayPosition
 *
 * PURPOSE:  Returns display position of column. Imnplements get for Column.DisplayPosition
 *
 * PARAMETERS:
 *    PLONG DisplayPosition          - display position ( 1 based )
 *    int iZeroBasedColIndex         - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_DisplayPosition( /*[out, retval]*/ PLONG DisplayPosition, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_DisplayPosition"));

    // Check received parameters
    sc = ScCheckPointers(DisplayPosition);
    if (sc)
        return sc;

    // initialize
    *DisplayPosition = 0;

    // retrieve data for column (this also checks the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // it's not legal for hidden columns ( or unfair at least :-)
    if (strColData.bIsHidden)
        return sc = E_UNEXPECTED;

    int iColumnOrder = strColData.iColumnOrder;
    int iDisplayPosition = iColumnOrder + 1;

    // that would be it. BUT we may have hidden columns with smaller order numbers
    // we need ti iteratre to find it out

    int nColumnCount = GetColCount();
    for (int i = 0; i <nColumnCount; i++)
    {
        // retrieve data for column (this also checks the index)
        sc = ScGetColumnData( i, &strColData );
        if (sc)
            return sc;

        // we will not take into account any hidden column
        if (strColData.iColumnOrder < iColumnOrder && strColData.bIsHidden)
        {
            // decrement position, since hidden columns do not affect visual position
            iDisplayPosition --;
        }
    }

    // return the display position
    *DisplayPosition = iDisplayPosition;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scput_DisplayPosition
 *
 * PURPOSE: Moves column (visually) to specified position
 *          Implements put for Column.DisplayPosition
 *
 * PARAMETERS:
 *   long lVisualPosition    - Position to move to (1 based)
 *   int iZeroBasedColIndex  - column index to move
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scput_DisplayPosition( /*[in]*/ long lVisualPosition, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scput_DisplayPosition"));

    // check the params
    if (lVisualPosition < 1)
        return sc = E_INVALIDARG;

    // retrieve current column data (this will check the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // we need to iterate and see what index and iOrder represents the requested position

    int nColumnCount = GetColCount();

    // will create a map from iOrder to visual status to make life easier
    // and benefit from the fact that items get sorted when inserting
    std::map<int,bool> mapColumnsByDisplayPos;
    for (int i = 0; i <nColumnCount; i++)
    {
        ColumnData strCurrColData;
        sc = ScGetColumnData( i, &strCurrColData );
        if (sc)
            return sc;

        // insert to the map
        mapColumnsByDisplayPos[strCurrColData.iColumnOrder] = strCurrColData.bIsHidden;
    }

    // now find out the right iOrder for the new position
    std::map<int,bool>::iterator it;
    int iNewOrder = 1;
    int nCurrPos = 0;
    for (it = mapColumnsByDisplayPos.begin(); it != mapColumnsByDisplayPos.end(); ++it)
    {
        iNewOrder = it->first;
        bool bHidden = it->second;

        // olny visible items are counted when it comes to display position
        if (!bHidden)
            ++nCurrPos;

        if (nCurrPos == lVisualPosition)
            break; // we've found the good place to move in
    }
    // note - if position is not found - iNewOrder will mark the last column.
    // good - that's a reasonable place for insertion to default to.
    // that means column will go to the end if given index was bigger than count
    // of visible columns

    strColData.iColumnOrder = iNewOrder;
    sc = ScSetColumnData( iZeroBasedColIndex, strColData );
    if (sc)
        return sc;

    // Now redraw the list view
    InvalidateRect(GetListCtrl(), NULL, TRUE);

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Hidden
 *
 * PURPOSE:  Returns hidden status for collumn. Implements get for Column.Hidden
 *
 * PARAMETERS:
 *    PBOOL Hidden           - resulting status
 *    int iZeroBasedColIndex - index of the column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_Hidden( /*[out, retval]*/ PBOOL pHidden, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Hidden"));

    // check parameters
    sc = ScCheckPointers(pHidden);
    if (sc)
        return sc;

    // initialize
    *pHidden = FALSE;

    // retrieve current column data (this will check the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // return the hidden status
    *pHidden = strColData.bIsHidden;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scput_Hidden
 *
 * PURPOSE: Hides or shows the column. Implements put for Column.Hidden
 *
 * PARAMETERS:
 *    BOOL Hidden            - new status for column
 *    int iZeroBasedColIndex - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scput_Hidden( /*[in]*/ BOOL Hidden , int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scput_Hidden"));

    // retrieve current column data (this will check the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // check if we do have a change in status
    if (strColData.bIsHidden == (bool)Hidden)
        return sc;

    // will never hide the 0 column!!!
    if (Hidden && iZeroBasedColIndex == 0)
        return sc = ::ScFromMMC(MMC_E_ZERO_COLUMN_INVISIBLE);

    // check for view
    sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
    if (sc)
        return sc;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get component node that owns the result view
    HNODE hnodeOwner = pAMCView->GetSelectedNode();
    sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
    if (sc)
        return sc.ToHr();

    LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // forward the request to CEnumeratedNode - owner of the view
    sc = pNodeCallback->ShowColumn(hnodeOwner, iZeroBasedColIndex, !Hidden);
    if (sc)
        return sc.ToHr();

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScSetAsSortColumn
 *
 * PURPOSE:  Sorts LV by specified column. Implements Column.SetAsSortColumn
 *
 * PARAMETERS:
 *    ColumnSortOrder SortOrder - sort order requested
 *    int iZeroBasedColIndex    - index of sort column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScSetAsSortColumn( /*[in]*/ ColumnSortOrder SortOrder, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSetAsSortColumn"));

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get component node that owns the result view
    HNODE hnodeOwner = pAMCView->GetSelectedNode();
    sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
    if (sc)
        return sc.ToHr();


    LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // forward the request to CEnumeratedNode - owner of the view
    sc = pNodeCallback->SetSortColumn(hnodeOwner, iZeroBasedColIndex, SortOrder == SortOrder_Ascending);
    if (sc)
        return sc.ToHr();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScIsSortColumn
 *
 * PURPOSE: Checks if the column is the one LV is sorted by
 *          Implements Column.IsSortColumn
 *
 * PARAMETERS:
 *    PBOOL IsSortColumn        - result (TRUE/FALSE)
 *    int iZeroBasedColIndex    - column index
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScIsSortColumn( PBOOL IsSortColumn, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScIsSortColumn"));

    // check the param
    sc = ScCheckPointers(IsSortColumn);
    if (sc)
        return sc;

    // initialize
    *IsSortColumn = FALSE;

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get component node that owns the result view
    HNODE hnodeOwner = pAMCView->GetSelectedNode();
    sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
    if (sc)
        return sc.ToHr();


    LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // forward the request to CEnumeratedNode - owner of the view
    int iSortCol = -1;
    sc = pNodeCallback->GetSortColumn(hnodeOwner, &iSortCol);
    if (sc)
        return sc.ToHr();

    // see if this column is the one LV is sorted by
    *IsSortColumn = (iSortCol == iZeroBasedColIndex);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CColumn::ScOnListViewColumnInserted
 *
 * PURPOSE: Handler for event fired by LV, informing that new column was inserted
 *
 * PARAMETERS:
 *    int nIndex    - index of newly inserted column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CColumn::ScOnListViewColumnInserted (int nIndex)
{
    DECLARE_SC(sc, TEXT("CColumn::ScOnListViewColumnInserted "));

    // increment own index if column inserted ahead
    if (m_iIndex >= nIndex)
        m_iIndex++;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CColumn::ScOnListViewColumnDeleted
 *
 * PURPOSE: Handler for event fired by LV, informing that new column was deleted
 *
 * PARAMETERS:
 *    int nIndex - index of deleted column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CColumn::ScOnListViewColumnDeleted (int nIndex)
{
    DECLARE_SC(sc, TEXT("CColumn::ScOnListViewColumnDeleted "));

    // decrement own index if column deleted ahead
    if (m_iIndex > nIndex)
        m_iIndex--;
    // disconnect from world if it's me who just died
    else if (m_iIndex == nIndex)
    {
        // I'm hit. I'm hit. I'm hit.
        m_iIndex = -1;
        // disconnect from the tied object
        if (IsTied())
        {
            CMyTiedObject *pTied = NULL;
            sc = ScGetTiedObject(pTied);
            if (sc)
                return sc;

            sc = ScCheckPointers(pTied, E_UNEXPECTED);
            if (sc)
                return sc;

            // break the connection
            pTied->RemoveFromList(this);
            Unadvise();
        }
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\childfrm.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      childfrm.inl
 *
 *  Contents:  Inline functions for CChildFrame class.
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CHILDFRM_INL
#define CHILDFRM_INL
#pragma once


/*+-------------------------------------------------------------------------*
 * CChildFrame::ScSetStatusText
 *
 * 
 *--------------------------------------------------------------------------*/

inline SC CChildFrame::ScSetStatusText (LPCTSTR pszText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    m_strStatusText = pszText;
    UpdateStatusText ();

    return (SC());
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::UpdateStatusText 
 *
 *
 *--------------------------------------------------------------------------*/

inline void CChildFrame::UpdateStatusText ()
{
    SendMessage (WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
}


#endif /* CHILDFRM_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\childfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       childfrm.h
//
//--------------------------------------------------------------------------

// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef CHILDFRM_H
#define CHILDFRM_H

#include "statbar.h"
#include "constatbar.h"     // for CConsoleStatusBar

class CAMCView;
class CMenuButtonsMgrImpl;

class CChildFrame : public CMDIChildWnd, public CConsoleStatusBar
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

protected:  // control bar embedded members
    CDockManager<CDockSite> m_DockingManager;
    CDockSite               m_StatusDockSite;

protected:
    CAMCStatusBar       m_wndStatusBar;

// Operations
public:
    void ToggleStatusBar();
    void RenderDockSites();
    void SendMinimizeNotification (bool fMinimized) const;
    bool SetCreateVisible (bool fCreateVisible);
    bool IsCustomizeViewEnabled ();

public:
    // CConsoleStatusBar methods
    virtual SC ScSetStatusText    (LPCTSTR pszText);

//Operations
protected:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    public:
    virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

    virtual CWnd* GetMessageBar()
        { return (&m_wndStatusBar); }

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
        HMENU hMenuAlt);
    virtual HACCEL GetDefaultAccelerator();
    virtual void ActivateFrame(int nCmdShow = -1);

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnDestroy();
    afx_msg void OnClose();
    afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
    afx_msg void OnCustomizeView();
    afx_msg void OnNcPaint();
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    //}}AFX_MSG

    afx_msg void OnMaximizeOrRestore(UINT nId);
    afx_msg void OnUpdateCustomizeView(CCmdUI* pCmdUI);
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetIcon(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);

public:
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);

    DECLARE_MESSAGE_MAP()

private:
    CAMCView* m_pAMCView;
    CString m_strStatusText;
    bool    m_fDestroyed;
    bool    m_fCurrentlyMinimized;
    bool    m_fCurrentlyActive;
    bool    m_fCreateVisible;
    bool    m_fChildFrameActive;

    std::auto_ptr<CMenuButtonsMgrImpl>  m_spMenuButtonsMgr;

protected:
    void UpdateStatusText();
    HRESULT NotifyCallback (NCLBK_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param) const;


public:
    void SetAMCView(CAMCView* pView)
        { m_pAMCView = pView; }

    CAMCView* GetAMCView() const
        { return m_pAMCView; }

    void SetChildFrameActive(bool bActive = true) { m_fChildFrameActive = bActive; }
    bool IsChildFrameActive() { return m_fChildFrameActive;}

    CMenuButtonsMgrImpl* GetMenuButtonsMgr() { return (m_spMenuButtonsMgr.get()) ; }
};


#include "childfrm.inl"


#endif /* CHILDFRM_H */

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\cclvctl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cclvctl.h
//
//--------------------------------------------------------------------------

#ifndef _CCLVCTL_H_
#define _CCLVCTL_H_

// cclvctl.h : header file
//
#include <objbase.h>
#include <atlbase.h>
#include <atlcom.h>
#include "imagemap.h"
#include "ndmgr.h"
#include "fontlink.h"
#include "amcnav.h"
#include "dd.h"
#include "columninfo.h"

// Don't let macro override CWnd method
#undef SubclassWindow

class CAMCView;
class CCCListViewCtrl;
class CResultItem;

class CListFontLinker : public CFontLinker
{
public:
    CListFontLinker (CCCListViewCtrl* pListCtrl) : m_pListCtrl (pListCtrl)
        { ASSERT (m_pListCtrl != NULL); }

protected:
    virtual bool IsAnyItemLocalizable () const;
    virtual std::wstring GetItemText (NMCUSTOMDRAW* pnmcd) const;

private:
    CCCListViewCtrl* const m_pListCtrl;
};


class CSysColorImageList : public CImageList
{
public:
    CSysColorImageList (HINSTANCE hInst, UINT nID)
        :   m_hInst  (hInst),
            m_hRsrc  (::FindResource (m_hInst, MAKEINTRESOURCE (nID), RT_BITMAP))
    {
        CreateSysColorImageList();
    }

    void OnSysColorChange ()
    {
        DeleteImageList();
        CreateSysColorImageList();
    }

    operator HIMAGELIST() const
    {
        return (CImageList::operator HIMAGELIST());
    }

private:
    void CreateSysColorImageList ()
    {
        CBitmap bmp;
        bmp.Attach (AfxLoadSysColorBitmap (m_hInst, m_hRsrc));

        /*
         * get the dimensions of the bitmap
         */
        BITMAP bm;
        bmp.GetBitmap (&bm);

        /*
         * assume square images (cx == cy)
         */
        Create (bm.bmHeight, bm.bmHeight, ILC_COLORDDB, bm.bmWidth / bm.bmHeight, 2);
        Add (&bmp, CLR_NONE);
    }

    HINSTANCE   m_hInst;
    HRSRC       m_hRsrc;
};


class CAMCHeaderCtrl : public CHeaderCtrl
{
public:
	bool IsColumnHidden(int iCol);

protected:
    afx_msg void OnSetFocus(CWnd *pOldWnd);
	afx_msg BOOL OnSetCursor( CWnd* pWnd, UINT nHitTest, UINT message );

    DECLARE_MESSAGE_MAP()
};


class CFocusHandler
{
public:
    virtual void OnKeyboardFocus(UINT nState, UINT nStateMask) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CAMCListView

class CAMCListView :
    public CListView,
    public CAMCNavigator,
    public CFocusHandler,
    public CMMCViewDropTarget,
    public CEventSource<CListViewActivationObserver>
{
// Construction
public:
    CAMCListView() :
        m_bVirtual(false),
        m_iDropTarget(-1),
        m_pAMCView(NULL),
        m_bColumnsNeedToBeRestored(true),
        m_bColumnsBeingRestored(false)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CAMCListView);
	}
    ~CAMCListView()
    {
        if (m_header.m_hWnd)
            m_header.UnsubclassWindow();

        DEBUG_DECREMENT_INSTANCE_COUNTER(CAMCListView);
    }

// CFocusHandler implementation
    virtual void OnKeyboardFocus(UINT nState, UINT nStateMask);

// CAMCNavigator implementation
    virtual BOOL ChangePane(AMCNavDir eDir);
    virtual BOOL TakeFocus(AMCNavDir eDir);

    SC ScOnColumnsAttributeChanged(NMHEADER *pNMHeader, UINT code);

    // Setup header width/order/hiddenness from columninfolist data.
    SC ScRestoreColumnsFromPersistedData();

    SC ScGetColumnInfoList(CColumnInfoList *pColumnsList);
    SC ScModifyColumns(const CColumnInfoList& colInfoList);
    SC ScSaveColumnInfoList();
    SC ScGetDefaultColumnInfoList(CColumnInfoList& columnsList);

    SC ScResetColumnStatusData();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCListView)
    public:
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );
    protected:
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

public:

    virtual SC ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint pt, bool& bCopyOperation);
    virtual void RemoveDropTargetHiliting();

    void SetVirtual()
    {
        m_bVirtual = true;
    }

    bool IsInLargeIconMode() const
    {
        return (GetMode() == LVS_ICON);
    }

    bool IsInSmallIconMode() const
    {
        return (GetMode() == LVS_SMALLICON);
    }

    bool IsInListMode() const
    {
        return (GetMode() == LVS_LIST);
    }

    bool IsInReportMode() const
    {
        return (GetMode() == LVS_REPORT);
    }

    bool IsInFilteredReportMode() const
    {
        if (!IsInReportMode())
            return (false);

        CWnd* pwndHeader = GetHeaderCtrl();
        if (pwndHeader == NULL)
            return (false);

        return (pwndHeader->GetStyle() & HDS_FILTERBAR);
    }

    DWORD SetExtendedListViewStyle (DWORD dwExStyle, DWORD dwExMask = 0)
    {
        return (SendMessage (LVM_SETEXTENDEDLISTVIEWSTYLE, dwExMask, dwExStyle));
    }

    CAMCView* GetAMCView() const
    {
        return (m_pAMCView);
    }

    CAMCHeaderCtrl* GetHeaderCtrl() const;

    bool AreColumnsNeedToBeRestored() const { return m_bColumnsNeedToBeRestored;}
    void SetColumnsNeedToBeRestored(bool b = false) {m_bColumnsNeedToBeRestored = b;}

    bool IsColumnHidden(int iCol) const;

protected:
    //{{AFX_MSG(CAMCListView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnPaint();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnBeginTrack(NMHDR * pNotifyStruct, LRESULT * result);
     //}}AFX_MSG

    afx_msg LRESULT OnColumnPersistedDataChanged (WPARAM, LPARAM);

    DECLARE_MESSAGE_MAP()

private:
    bool                    m_bVirtual;

    CAMCView*               m_pAMCView;
    mutable CAMCHeaderCtrl  m_header;           // mutable so GetHeaderCtrl can call CWnd::SubclassWindow
    int                     m_iDropTarget;
    CColumnInfoList         m_defaultColumnInfoList;


    INodeCallback* GetNodeCallback();
    HNODE GetScopePaneSelNode();
    void SelectDropTarget(int iDropTarget);
    bool ActivateSelf (bool fNotify = true);
    bool NeedsCustomPaint ();

    SC ScGetDropTarget(const CPoint& point, HNODE& hNode, bool& bScope, LPARAM& lvData, int& iDrop);

    DWORD GetMode () const
    {
        return (GetStyle() & LVS_TYPEMASK);
    }

private:
    // For columns
    static const UINT m_nColumnPersistedDataChangedMsg;

    // To allow hidden column width changes.
    bool              m_bColumnsBeingRestored;

    // We dont care if restore is success or failure.
    bool              m_bColumnsNeedToBeRestored;
};


/////////////////////////////////////////////////////////////////////////////
// CCCListViewCtrl window

class CCCListViewCtrl :
    public IMMCListView,
    public CComObjectRoot,
    public CEventSource<CListViewObserver>,
    public CTiedObject
{
// Construction
public:
    CCCListViewCtrl();
    virtual ~CCCListViewCtrl();

    // initialization
    SC ScInitialize();

BEGIN_COM_MAP(CCCListViewCtrl)
    COM_INTERFACE_ENTRY(IMMCListView)
END_COM_MAP()

typedef struct _SortParams
{
    BOOL                    bAscending;         // sort direction
    BOOL                    bLexicalSort;       // apply default sort to all items
    int                     nCol;               // Which column to sort on.
    COMPONENTID             OwnerID;
    void *                  lpListView;         // CCCListViewCtrl *
    IResultDataComparePtr   spResultCompare;    // Snap-in component interface
    IResultDataCompareExPtr spResultCompareEx;  //   "
    LPNODECALLBACK          lpNodeCallback;
    LPARAM                  lpUserParam;        // parameter user passes in
    HNODE                   hSelectedNode;      // Currently selected node in scope pane.
} SortParams;


//DECLARE_AGGREGATABLE(CCCListViewCtrl)
//DECLARE_REGISTRY(CNodeInitObject, _T("NODEMGR.NodeInitObject.1"), _T("NODEMGR.NodeInitObject.1"), IDS_NODEINIT_DESC, THREADFLAGS_BOTH)

// Operations
public:
    #ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)
    long GetColCount()  const                { return m_colCount; }
    long GetItemCount() const                { return m_itemCount; }
    #endif

    CAMCListView*   GetListViewPtr() const   { return m_pListView; }
    CListCtrl&      GetListCtrl()    const   { return m_pListView->GetListCtrl(); }
    CAMCHeaderCtrl* GetHeaderCtrl()  const   { return m_pListView->GetHeaderCtrl(); }

    bool AreColumnsNeedToBeRestored() const { return m_pListView->AreColumnsNeedToBeRestored();}
    void SetColumnsNeedToBeRestored(bool b = true) {m_pListView->SetColumnsNeedToBeRestored(b);}

    bool IsColumnHidden(int iCol) const {return m_pListView->IsColumnHidden(iCol);}

    SC  ScGetAMCView(CAMCView **ppAMCView);

    HWND GetListViewHWND() const             { return m_pListView->GetSafeHwnd(); }

    BOOL IsVirtual() const { return m_bVirtual; }
    BOOL Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext=NULL);

    SC   ScAttachToListPad (HWND hwnd, HWND* phwnd);  // NULL hwnd == detach
    BOOL    IsListPad () const { return m_SavedHWND != NULL; }

    LRESULT OnCustomDraw (NMLVCUSTOMDRAW* plvcd);
    void OnSysColorChange();

    // IMMCListView Methods
    STDMETHOD(GetListStyle)       ();
    STDMETHOD(SetListStyle)       (long nNewValue);
    STDMETHOD(GetViewMode)        ();
    STDMETHOD(SetViewMode)        (long nViewMode);
    STDMETHOD(InsertItem)         (LPOLESTR str, long iconNdx, LPARAM lParam, long state, COMPONENTID ownerID, long itemIndex, CResultItem*& pri);
    STDMETHOD(DeleteItem)         (HRESULTITEM itemID, long nCol);
    STDMETHOD(FindItemByLParam)   (COMPONENTID ownerID, LPARAM lParam, CResultItem*& pri);
    STDMETHOD(InsertColumn)       (int nCol, LPCOLESTR str, long nFormat, long width);
    STDMETHOD(DeleteColumn)       (int nCol);
    STDMETHOD(DeleteAllItems)     (COMPONENTID ownerID);
    STDMETHOD(SetColumn)          (long nCol, LPCOLESTR str, long nFormat, long width);
    STDMETHOD(GetColumn)          (long nCol, LPOLESTR* str, LPLONG nFormat, int FAR* width);
    STDMETHOD(GetColumnCount)     (int* pnColCnt);
    STDMETHOD(SetItem)            (int nIndex, CResultItem*  pri, long nCol, LPOLESTR str, long nImage, LPARAM lParam, long nState, COMPONENTID ownerID);
    STDMETHOD(GetItem)            (int nIndex, CResultItem*& pri, long nCol, LPOLESTR* str, int FAR *nImage, LPARAM* lParam, unsigned int FAR *nState, BOOL* pbScopeItem);
    STDMETHOD(GetNextItem)        (COMPONENTID ownerID, long nIndex, UINT nState, CResultItem*& pri, long& nIndexNextItem);
    STDMETHOD(GetLParam)          (long nItem, CResultItem*& pri);
    STDMETHOD(ModifyItemState)    (long nItem, CResultItem* pri, UINT add, UINT remove);
    STDMETHOD(SetIcon)            (long nID, HICON hIcon, long nLoc);
    STDMETHOD(SetImageStrip)      (long nID, HBITMAP hbmSmall, HBITMAP hbmLarge, long nStartLoc, long cMask);
    STDMETHOD(MapImage)           (COMPONENTID nID, long nLoc, int far *pResult);
    STDMETHOD(Reset)              ();
    STDMETHOD(Arrange)            (long style);
    STDMETHOD(UpdateItem)         (HRESULTITEM itemID);
    STDMETHOD(Sort)               (LPARAM lUserParam, long* lpParams);
    STDMETHOD(SetItemCount)       (int nItemCount, DWORD dwOptions);
    STDMETHOD(SetVirtualMode)     (BOOL bVirtual);
    STDMETHOD(Repaint)            (BOOL bErase);
    STDMETHOD(SetChangeTimeOut)   (ULONG lTimeout);
    STDMETHOD(SetColumnFilter)    (int nCol, DWORD dwType, MMC_FILTERDATA* pFilterData);
    STDMETHOD(GetColumnFilter)    (int nCol, DWORD* dwType, MMC_FILTERDATA* pFilterData);
    STDMETHOD(SetColumnSortIcon)  (int nNewCol, int nOldCol, BOOL bAscending, BOOL bSetSortIcon);
    STDMETHOD(SetLoadMode)        (BOOL bState);
    STDMETHOD(GetColumnInfoList)  (CColumnInfoList *pColumnsList);
    STDMETHOD(ModifyColumns)      (const CColumnInfoList& columnsList);
    STDMETHOD(RenameItem)         (HRESULTITEM itemID);
    STDMETHOD(GetDefaultColumnInfoList)( CColumnInfoList& columnsList);


    STDMETHOD(OnModifyItem)(CResultItem* pri);

    void CutSelectedItems(BOOL b);
    bool UseFontLinking() const;

    UINT GetSelectedCount()
        { return (GetListCtrl().GetSelectedCount()); }

    // these methods implement access to enumerations for AMCView
    SC Scget_ListItems( PPNODES ppNodes );
    SC Scget_SelectedItems( PPNODES ppNodes);
    SC ScSelect( PNODE pNode);
    SC ScDeselect( PNODE pNode);
    SC ScIsSelected( PNODE pNode, PBOOL pIsSelected);
    SC ScSelectAll();

    // method used from Nodes collections
    SC ScValidateItem( int  iItem, bool &bScopeNode );

    // method transfering requests from Nodes to AMCView (for scope nodes only)
    SC ScGetScopeNodeForItem ( int  iItem, PPNODE ppNode );

    // Columns access methods
    SC Scget_Columns( PPCOLUMNS Columns );
    SC ScItem( long Index, PPCOLUMN ppColumn );
    SC Scget_Count( PLONG pCount );
    SC ScEnumNext(int &pos, PDISPATCH & pDispatch); // should return the next element.
    SC ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, int &pos);
    SC ScEnumReset(int &pos);
    // methods called from Column instances
    SC ScName( /*[out, retval]*/ BSTR *Name, int iColIndex );
    SC Scget_Width( /*[out, retval]*/ PLONG Width, int iColIndex );
    SC Scput_Width( /*[in]*/ long Width, int iColIndex );
    SC Scget_DisplayPosition( /*[out, retval]*/ PLONG DisplayPosition, int iColIndex );
    SC Scput_DisplayPosition( /*[in]*/ long Index, int iColIndex );
    SC Scget_Hidden( /*[out, retval]*/ PBOOL Hidden, int iColIndex );
    SC Scput_Hidden( /*[in]*/ BOOL Hidden , int iColIndex );
    SC ScSetAsSortColumn( /*[in]*/ ColumnSortOrder SortOrder, int iColIndex );
    SC ScIsSortColumn( PBOOL IsSortColumn, int iColIndex );
    // Column/Columns implementation helpers
    struct ColumnData
    {
        int     iColumnWidth;
        int     iColumnOrder;
        bool    bIsHidden;
        // initialization
        void Init()  { iColumnWidth = 0; iColumnOrder = -1; bIsHidden = false; }
        ColumnData() { Init(); }
        // comparison
        bool operator == (const ColumnData& other) const
                     { return ( 0 == memcmp(this, &other, sizeof(ColumnData)) ); }
    };
    SC ScGetColumnData( int iZeroBasedColIndex, ColumnData *pColData );
    SC ScSetColumnData( int iZeroBasedColIndex, const ColumnData& ColData );

    SC ScFindResultItem ( PNODE pNode, int &iItem );

private:
    // helper methods
    SC ScGetNodesEnum   ( bool bSelectedItemsOnly, PPNODES ppNodes );
    SC ScAllocResultItem  ( CResultItem*& pResultItem, COMPONENTID id, LPARAM lSnapinData, int nImage);
    SC ScFreeResultItem   ( CResultItem* pResultItem);

    SC ScRedrawItem       (int nIndex);
    SC ScGetItemIndexFromHRESULTITEM(const HRESULTITEM& itemID, int& nIndex);

    SC ScRedrawHeader(bool bRedraw);

protected:
    CAMCListView* m_pListView;       // current list (points to m_StandardList or m_VirtualList)
    CAMCListView* m_pStandardList;
    CAMCListView* m_pVirtualList;

    HWND m_SavedHWND;
    WINDOWPLACEMENT m_wp;

    CWnd*         m_pParentWnd;

    //void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

    long m_itemCount;      // internal item counter
    long m_nScopeItems; // scope item count
    long m_colCount;       // internal column counter

    // ImageList members
    CImageList      m_smallIL;
    CImageList      m_largeIL;
    CImageIndexMap  m_resultIM;

    // Header Sorting (Up/Down arrow) Icons.
    CSysColorImageList  m_headerIL;

    // Sorting members
    SortParams  m_sortParams;
    static int CALLBACK SortCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams);
    static int SnapinCompare(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2);
    static int SnapinCompareEx(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2);
    static int CALLBACK DefaultCompare(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams);

private:
    CListFontLinker    m_FontLinker;
    NodesPtr           m_spAllNodes;
    NodesPtr           m_spSelNodes;
    ColumnsPtr         m_spColumns;

    BOOL m_bVirtual;
    BOOL m_bFiltered;           // filtering on now
    BOOL m_bEnsureFocusVisible; // force focused item to be visible
    BOOL m_bLoading;
    BOOL m_bDeferredSort;

    void SetFilterHeader(void);
    SC ScSetImageLists ();
    int ResultItemToIndex (CResultItem* pri) const;
    CResultItem* IndexToResultItem (int nItem);
};


////////////////////////////////////////////////////////////////////////////
// CQFilterDll
//
// This class dynamically loads and initializes the quickfilter DLL.
// A single instance of the class should be declared at the global level.
//
class CQFilterDll
{
public:
    CQFilterDll()
    {
        m_hModule = LoadLibrary(_T("qfctrl.dll"));

        if (m_hModule != NULL)
        {
            void (*pfnInitQuickFilter)();
            pfnInitQuickFilter = (void (*)())GetProcAddress(m_hModule, "InitQuickFilter");

            if (pfnInitQuickFilter != NULL)
                (*pfnInitQuickFilter)();
        }
    }

    CQFilterDll::~CQFilterDll()
    {
        if (m_hModule != NULL)
            FreeLibrary(m_hModule);
    }

private:
    HMODULE m_hModule;
};



/*+-------------------------------------------------------------------------*
 * CHiddenColumnInfo
 *
 * Contains information about a hidden column in report view: a flag
 * indicating it's hidden and its width when it's not hidden.
 *
 * This class is stored in HDITEM.lParam for hidden columns, so it *must*
 * be the same size as an LPARAM.
 *--------------------------------------------------------------------------*/

class CHiddenColumnInfo
{
public:
	CHiddenColumnInfo (LPARAM lParam_) : lParam (lParam_)
	{
		COMPILETIME_ASSERT (sizeof(CHiddenColumnInfo) == sizeof(LPARAM));
	}

	CHiddenColumnInfo (int cx_, bool fHidden_) : cx (cx_), fHidden (fHidden_)
	{
		COMPILETIME_ASSERT (sizeof(CHiddenColumnInfo) == sizeof(LPARAM));
	}

	union
	{
		LPARAM	lParam;
		struct
		{
			int	cx      : 16;
			int	fHidden : 1;
		};
	};
};


#endif _CCLVCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\controls.cpp ===
// Controls.cpp : implementation file
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      Controls.cpp
//
//  Contents:  General window controls used in the slate AMC console
//
//  History:   19-Dec-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "docksite.h"
#include "Controls.h"
#include "resource.h"
#include "amc.h"
#include "tbtrack.h"
#include "mainfrm.h"
#include "fontlink.h"
#include "menubar.h"
#include <oleacc.h>
#include "guidhelp.h"
#include "util.h"		// StripTrailingWhitespace

/*
 * if we're supporting old platforms, we need to get MSAA definitions
 * from somewhere other than winuser.h
 */
#if (_WINNT_WIN32 < 0x0500)
	#include <winable.h>
#endif


#ifdef DBG
CTraceTag  tagToolbarAccessibility (_T("Accessibility"), _T("Toolbar"));
#endif


/*+-------------------------------------------------------------------------*
 * CMMCToolBarAccServer
 *
 * Proxy for the accessibility interface IAccPropServer for CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

class CMMCToolBarAccServer :
	public IAccPropServer,
	public CComObjectRoot,
    public CComObjectObserver,
    public CTiedComObject<CMMCToolBarCtrlEx>
{
    typedef CMMCToolBarAccServer	ThisClass;
    typedef CMMCToolBarCtrlEx		CMyTiedObject;

protected:
	CMMCToolBarAccServer()
	{
		Trace (tagToolbarAccessibility, _T("Creating CMMCToolBarAccServer (0x%p)"), this);

        // add itself as an observer for com object events
        GetComObjectEventSource().AddObserver(*static_cast<CComObjectObserver*>(this));
	}

   ~CMMCToolBarAccServer()
	{
		Trace (tagToolbarAccessibility, _T("Destroying CMMCToolBarAccServer (0x%p)"), this);
	}

   /***************************************************************************\
	*
	* METHOD:  ScOnDisconnectObjects
	*
	* PURPOSE: invoked when observed event (request to disconnect) occures
	*          Disconnects from external connections
	*
	* PARAMETERS:
	*
	* RETURNS:
	*    SC    - result code
	*
   \***************************************************************************/
   virtual ::SC ScOnDisconnectObjects()
   {
	   DECLARE_SC(sc, TEXT("CMMCIDispatchImpl<_ComInterface>::ScOnDisconnectObjects"));

	   // QI for IUnknown
	   IUnknownPtr spUnknown = this;

	   // sanity check
	   sc = ScCheckPointers( spUnknown, E_UNEXPECTED );
	   if (sc)
		   return sc;

	   // cutt own references
	   sc = CoDisconnectObject( spUnknown, 0/*dwReserved*/ );
	   if (sc)
		   return sc;

	   return sc;
   }

public:
    BEGIN_COM_MAP(ThisClass)
		COM_INTERFACE_ENTRY(IAccPropServer)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

public:
    // *** IAccPropServer methods ***
    MMC_METHOD5 (GetPropValue, const BYTE* /*pIDString*/, DWORD /*dwIDStringLen*/, MSAAPROPID /*idProp*/, VARIANT* /*pvarValue*/, BOOL* /*pfGotProp*/)
};


/////////////////////////////////////////////////////////////////////////////
// CDescriptionCtrl

CDescriptionCtrl::CDescriptionCtrl() :
    m_cxMargin   (0),
    m_cyText     (0),
    m_cyRequired (0)
{
}

CDescriptionCtrl::~CDescriptionCtrl()
{
}


BEGIN_MESSAGE_MAP(CDescriptionCtrl, CStatic)
    //{{AFX_MSG_MAP(CDescriptionCtrl)
    ON_WM_NCHITTEST()
    ON_WM_CREATE()
    ON_WM_SETTINGCHANGE()
    ON_WM_DESTROY()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP

    ON_WM_DRAWITEM_REFLECT()
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CDescriptionCtrl message handlers


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::PreCreateWindow
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CDescriptionCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style     |= SS_NOPREFIX | SS_CENTERIMAGE | SS_ENDELLIPSIS |
                    SS_LEFTNOWORDWRAP | SS_OWNERDRAW | WS_CLIPSIBLINGS;
    cs.dwExStyle |= WS_EX_STATICEDGE;

    return (CStatic::PreCreateWindow (cs));
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnCreate
 *
 * WM_CREATE handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

int CDescriptionCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CStatic::OnCreate(lpCreateStruct) == -1)
        return -1;

    CreateFont();

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnDestroy
 *
 * WM_DESTROY handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::OnDestroy()
{
    CStatic::OnDestroy();
    DeleteFont();
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnNcHitTest
 *
 * WM_NCHITTEST handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

UINT CDescriptionCtrl::OnNcHitTest(CPoint point)
{
    return (HTCLIENT);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    CStatic::OnSettingChange(uFlags, lpszSection);

    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        DeleteFont ();
        CreateFont ();
    }
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnSize
 *
 * WM_SIZE handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::OnSize(UINT nType, int cx, int cy)
{
	CStatic::OnSize(nType, cx, cy);
	
	/*
	 * Completely redraw when the size changes, so the ellipsis will
	 * be drawn correctly.  Another way to do this would be to use
	 * CS_HREDRAW | CS_VREDRAW, but it's too big a pain to re-register
	 * the static control.  This'll do just fine.
	 */
	InvalidateRect (NULL);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::DrawItem
 *
 * WM_DRAWITEM handler for CDescriptionCtrl.
 *
 * The description control needs to be ownerdraw for a couple of reasons:
 *
 *  1.  If any of the text contains characters that can't be rendered by
 *      the default font, we won't draw them correctly.
 *
 *  2.  If any of the text contains right-to-left reading text (e.g. Arabic
 *      or Hebrew), system mirroring code will incorrectly mix the console
 *      and snap-in text (bug 365469).  The static control will draw the text
 *      in one fell swoop, but we can get around the problem if we draw
 *      the text ourselves in two steps: first console text, then snap-in
 *      text.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::DrawItem(LPDRAWITEMSTRUCT lpdis)
{
    /*
     * Bug 410450:  When the system is under stress, we might not get a
     * valid DC.  If we don't there's nothing we can do, so short out (and
     * avoid an AV when we later dereference a NULL CDC*).
     */
    CDC* pdcWindow = CDC::FromHandle (lpdis->hDC);
	if (pdcWindow == NULL)
		return;

    /*
     * if we don't have any text, just clear the background
     */
    bool fHasConsoleText = !m_strConsoleText.IsEmpty();
    bool fHasSnapinText  = !m_strSnapinText.IsEmpty();

    if (!fHasConsoleText && !fHasSnapinText)
	{
		FillRect (lpdis->hDC, &lpdis->rcItem, GetSysColorBrush (COLOR_3DFACE));
        return;
	}

    /*
     * figure out the text rectangle; it will be one line high, vertically
     * centered within the window
     */
    CRect rectClient;
    GetClientRect (rectClient);
	const int cxClient = rectClient.Width();
	const int cyClient = rectClient.Height();

    CRect rectText  = rectClient;
    rectText.left  += m_cxMargin;
    rectText.bottom = m_cyText;

    rectText.OffsetRect (0, (cyClient - rectText.Height()) / 2);

    const DWORD dwFlags = DT_LEFT | DT_TOP | DT_SINGLELINE |
                          DT_NOPREFIX | DT_END_ELLIPSIS;

    USES_CONVERSION;
    CFontLinker fl;

	/*
	 * double-buffer drawing for flicker-free redraw
	 */
	CDC dcMem;
	dcMem.CreateCompatibleDC (pdcWindow);
	if (dcMem.GetSafeHdc() == NULL)
		return;

	CBitmap bmpMem;
	bmpMem.CreateCompatibleBitmap (&dcMem, cxClient, cyClient);
	if (bmpMem.GetSafeHandle() == NULL)
		return;

    /*
     * put the right font in the DC, and clear it out
     */
    CFont*  	pOldFont   = dcMem.SelectObject (&m_font);
	CBitmap*	pOldBitmap = dcMem.SelectObject (&bmpMem);
	dcMem.PatBlt (0, 0, cxClient, cyClient, WHITENESS);

    /*
     * if we have console text draw it and update the text rectangle
     * so snap-in text (if any) will be drawn in the right place
     */
    if (fHasConsoleText)
    {
        /*
         * create a CRichText object for the console text and let
         * the font linker parse it into bite-size chunks
         */
        CRichText rt (dcMem, T2CW (static_cast<LPCTSTR>(m_strConsoleText)));
        bool fComposed = fl.ComposeRichText (rt);

        /*
         * draw the console text and adjust the text rectancle in
         * preparation for drawing the snap-in text
         */
        if (fComposed && !rt.IsDefaultFontSufficient())
        {
            CRect rectRemaining;
            rt.Draw (rectText, dwFlags, rectRemaining);

            rectText.left = rectRemaining.left;
        }
        else
        {
            dcMem.DrawText (m_strConsoleText, rectText, dwFlags | DT_CALCRECT);
            dcMem.DrawText (m_strConsoleText, rectText, dwFlags);

            rectText.left  = rectText.right;
            rectText.right = rectClient.right;
        }

        /*
         * leave some space between the console text and the snap-in text
         */
        rectText.left += 2*m_cxMargin;
    }

    /*
     * draw the snap-in text, if any
     */
    if (fHasSnapinText)
    {
        /*
         * create a CRichText object for the console text and let
         * the font linker parse it into bite-size chunks
         */
        CRichText rt (dcMem, T2CW (static_cast<LPCTSTR>(m_strSnapinText)));
        bool fComposed = fl.ComposeRichText (rt);

        /*
         * draw the snap-in text
         */
        if (fComposed && !rt.IsDefaultFontSufficient())
            rt.Draw (rectText, dwFlags);
        else
            dcMem.DrawText (m_strSnapinText, rectText, dwFlags);
    }

	/*
	 * blt to the screen
	 */
	pdcWindow->BitBlt (0, 0, cxClient, cyClient, &dcMem, 0, 0, SRCCOPY);

    /*
     * restore the original font
     */
    dcMem.SelectObject (pOldFont);
    dcMem.SelectObject (pOldBitmap);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::CreateFont
 *
 *
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::CreateFont ()
{
    /*
     * create a copy of the icon title font
     */
    LOGFONT lf;
    SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);

    m_font.CreateFontIndirect (&lf);

    /*
     * figure out how much space we need to fully display our text
     */
    TCHAR ch = _T('0');
    CWindowDC dc(this);
    CFont*  pFont  = dc.SelectObject (&m_font);
    m_cyText = dc.GetTextExtent(&ch, 1).cy;

    ch = _T(' ');
    m_cxMargin = 2 * dc.GetTextExtent(&ch, 1).cx;

    CRect rectRequired (0, 0, 0, m_cyText + 2*GetSystemMetrics(SM_CYEDGE));
    AdjustWindowRectEx (rectRequired, GetStyle(), false, GetExStyle());
    m_cyRequired = rectRequired.Height();

    dc.SelectObject (pFont);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::DeleteFont
 *
 *
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::DeleteFont ()
{
    m_font.DeleteObject();
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::ScOnSelectedItemTextChanged
 *
 * This method observes the text of the selected item in the tree control.
 * The text is reflected in the description bar.
 *--------------------------------------------------------------------------*/

SC CDescriptionCtrl::ScOnSelectedItemTextChanged (LPCTSTR pszSelectedItemText)
{
    if (m_strConsoleText != pszSelectedItemText)
    {
        m_strConsoleText = pszSelectedItemText;
        Invalidate();
    }

	return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::SetSnapinText
 *
 *
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::SetSnapinText (const CString& strSnapinText)
{
    if (m_strSnapinText != strSnapinText)
    {
        m_strSnapinText = strSnapinText;
        Invalidate();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrlEx

CToolBarCtrlEx::CToolBarCtrlEx()
{
    m_sizeBitmap.cx = 16;
    m_sizeBitmap.cy = 16;   // docs say 15, but code in toolbar.c says 16

    m_fMirrored = false;

    m_pRebar = NULL;
    m_cx     = 0;
}

CToolBarCtrlEx::~CToolBarCtrlEx()
{
}


BEGIN_MESSAGE_MAP(CToolBarCtrlEx, CToolBarCtrlEx::BaseClass)
    //{{AFX_MSG_MAP(CToolBarCtrlEx)
    ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrlEx message handlers

BOOL CToolBarCtrlEx::Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
    BOOL bRtn=FALSE;

    if (!pParentWnd)
    {
        ASSERT(pParentWnd); // Invalid Parent
    }
    else
    {
        // Initialise the new common controls
        INITCOMMONCONTROLSEX icex;

        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC   = ICC_BAR_CLASSES;

        if (InitCommonControlsEx(&icex))
        {
            // Add toolbar styles to the dwstyle
            dwStyle |=  WS_CHILD | TBSTYLE_FLAT | WS_CLIPCHILDREN |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE;


            if (CWnd::CreateEx(WS_EX_TOOLWINDOW | WS_EX_NOPARENTNOTIFY,
                                   TOOLBARCLASSNAME,
                                   lpszWindowName,
                                   dwStyle,
                                   rect,
                                   pParentWnd,
                                   nID))
            {
                bRtn=TRUE;

                //See if toolbar is mirrored or not
                m_fMirrored = GetExStyle() & WS_EX_LAYOUTRTL;

                // Tells the toolbar what version we are.
                SetButtonStructSize(sizeof(TBBUTTON));

                //REVIEW This may not need to be here.  I'm defaulting buttons w/ text
                //to only have one row.  This may need to be configurable.
                SetMaxTextRows(1);

                CRebarDockWindow* pRebarDock = (CRebarDockWindow*) pParentWnd;
                if (pRebarDock)
                    m_pRebar = pRebarDock->GetRebar();
            }
        }
    }

    return bRtn;
}


void CToolBarCtrlEx::UpdateToolbarSize(void)
{
    /*
     * get the right edge of the right-most visible button
     */
    int cx = 0;
    for (int i = GetButtonCount()-1; i >= 0; i--)
    {
        RECT rcButton;

        if (GetItemRect (i, &rcButton))
        {
            cx = rcButton.right;
            break;
        }
    }

    ASSERT (IsWindow (m_pRebar->GetSafeHwnd()));

    /*
     * if the width has changed, update the band
     */
    if (m_cx != cx)
    {
        m_cx = cx;

        // Set values unique to the band with the toolbar;
        REBARBANDINFO   rbBand;
        rbBand.cbSize     = sizeof (rbBand);
        rbBand.fMask      = RBBIM_SIZE | RBBIM_CHILDSIZE;
        rbBand.cx         = m_cx;
        rbBand.cxMinChild = m_cx;
        rbBand.cyMinChild = HIWORD (GetButtonSize());

        int iBand = GetBandIndex();
        if (iBand != -1)
            m_pRebar->SetBandInfo (iBand, &rbBand);
    }
}


bool CToolBarCtrlEx::IsBandVisible()
{
    return (GetBandIndex() != -1);
}

int CToolBarCtrlEx::GetBandIndex()
{
    REBARBANDINFO rbBand;
    rbBand.cbSize = sizeof(REBARBANDINFO);
    rbBand.fMask  = RBBIM_CHILD;

	if ( m_pRebar == NULL )
		return (-1);

    int nBands = m_pRebar->GetBandCount ();

    for (int i = 0; i < nBands; i++)
    {
        if (m_pRebar->GetBandInfo (i, &rbBand) && (rbBand.hwndChild == m_hWnd))
            return (i);
    }

    return (-1);
}


void CToolBarCtrlEx::Show(BOOL bShow, bool bAddToolbarInNewLine)
{
    if ((m_pRebar == NULL) || !::IsWindow(m_pRebar->m_hWnd))
    {
        ASSERT(FALSE);  // Invalid rebar window handle
        return;
    }


    if (bShow)
    {
        if (false == IsBandVisible())
        {
            REBARBANDINFO rbBand;
            ZeroMemory(&rbBand, sizeof(rbBand));
            rbBand.cbSize     = sizeof(REBARBANDINFO);
            rbBand.fMask      = RBBIM_CHILD | RBBIM_SIZE | RBBIM_CHILDSIZE | RBBIM_ID | RBBIM_STYLE;
            rbBand.hwndChild  = m_hWnd;
            rbBand.wID        = GetWindowLong (m_hWnd, GWL_ID);
            rbBand.cx         = m_cx;
            rbBand.cxMinChild = m_cx;
            rbBand.cyMinChild = HIWORD (GetButtonSize());
            rbBand.fStyle     = RBBS_NOGRIPPER;

            if (bAddToolbarInNewLine)
            {
                // Insert this toolbar in new line.
                rbBand.fStyle |= RBBS_BREAK;
            }

            m_pRebar->InsertBand (&rbBand);
        }
    }
    else
    {
        int iBand = GetBandIndex();
        ASSERT(iBand != -1);
        if (iBand != -1)
            m_pRebar->DeleteBand (iBand);
    }
}


void CToolBarCtrlEx::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
    CToolCmdUIEx state;
    state.m_pOther = this;

    state.m_nIndexMax = (UINT)DefWindowProc(TB_BUTTONCOUNT, 0, 0);
    for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax; state.m_nIndex++)
    {
        // get buttons state
        TBBUTTON button;
        memset(&button, 0, sizeof(TBBUTTON));
        GetButton(state.m_nIndex, &button);
        state.m_nID = button.idCommand;

        // ignore separators
        if (!(button.fsStyle & TBSTYLE_SEP))
        {
            // allow the toolbar itself to have update handlers
            if (CWnd::OnCmdMsg(state.m_nID, CN_UPDATE_COMMAND_UI, &state, NULL))
                continue;

            // allow the owner to process the update
            state.DoUpdate(pTarget, bDisableIfNoHndler);
        }
    }

    // update the dialog controls added to the toolbar
    UpdateDialogControls(pTarget, bDisableIfNoHndler);
}


LRESULT CToolBarCtrlEx::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
    /*
    // handle delay hide/show
    BOOL bVis = GetStyle() & WS_VISIBLE;
    UINT swpFlags = 0;
    if ((m_nStateFlags & delayHide) && bVis)
        swpFlags = SWP_HIDEWINDOW;
    else if ((m_nStateFlags & delayShow) && !bVis)
        swpFlags = SWP_SHOWWINDOW;
    m_nStateFlags &= ~(delayShow|delayHide);
    if (swpFlags != 0)
    {
        SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
            SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    }
    */

    // The code below updates the menus (especially the child-frame
    // system menu when the frame is maximized).

    // the style must be visible and if it is docked
    // the dockbar style must also be visible
    if ((GetStyle() & WS_VISIBLE))
    {
        CFrameWnd* pTarget = (CFrameWnd*)GetOwner();
        if (pTarget == NULL || !pTarget->IsFrameWnd())
            pTarget = GetParentFrame();
        if (pTarget != NULL)
            OnUpdateCmdUI(pTarget, (BOOL)wParam);
    }

    return 0L;

}


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CRebarWnd

CRebarWnd::CRebarWnd() : m_fRedraw(true)
{
}

CRebarWnd::~CRebarWnd()
{
}

BEGIN_MESSAGE_MAP(CRebarWnd, CWnd)
    //{{AFX_MSG_MAP(CRebarWnd)
    ON_WM_CREATE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_ERASEBKGND()
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_SETREDRAW, OnSetRedraw)
    ON_NOTIFY_REFLECT(RBN_AUTOSIZE, OnRebarAutoSize)
    ON_NOTIFY_REFLECT(RBN_HEIGHTCHANGE, OnRebarHeightChange)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRebarWnd message handlers


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnCreate
 *
 * WM_CREATE handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

int CRebarWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    SetTextColor (GetSysColor (COLOR_BTNTEXT));
    SetBkColor   (GetSysColor (COLOR_BTNFACE));

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnSysColorChange
 *
 * WM_SYSCOLORCHANGE handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

void CRebarWnd::OnSysColorChange()
{
    CWnd::OnSysColorChange();

    SetTextColor (GetSysColor (COLOR_BTNTEXT));
    SetBkColor   (GetSysColor (COLOR_BTNFACE));
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnEraseBkgnd
 *
 * WM_ERASEBKGND handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

BOOL CRebarWnd::OnEraseBkgnd(CDC* pDC)
{
    /*
     * If redraw is turned on, forward this on the the window.  If it's
     * not on, we want to prevent erasing the background to minimize
     * flicker.
     */
    if (m_fRedraw)
        return CWnd::OnEraseBkgnd(pDC);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnSetRedraw
 *
 * WM_SETREDRAW handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

LRESULT CRebarWnd::OnSetRedraw (WPARAM wParam, LPARAM)
{
    m_fRedraw = (wParam != FALSE);
    return (Default ());
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnRebarAutoSize
 *
 * RBN_REBARAUTOSIZE handler for CRebarWnd.
 *
 * We want to keep the menu band on a row by itself, without any other
 * toolbars.  To do this, each time the rebar resizes we'll make sure that
 * the first visible band after the menu band starts a new row.
 *
 * A more foolproof way to do this would be to have a separate rebar
 * for the menu.  If we do that, we'll need to insure that tabbing between
 * toolbars (Ctrl+Tab) still works.
 *--------------------------------------------------------------------------*/

void CRebarWnd::OnRebarAutoSize(NMHDR* pNotify, LRESULT* result)
{
    /*
     * insure that the band following the menu is on a new line
     */
    CMainFrame* pFrame = AMCGetMainWnd();
    if (pFrame == NULL)
        return;

    CToolBarCtrlEx* pMenuBar = pFrame->GetMenuBar();
    if (pMenuBar == NULL)
        return;

    int iMenuBand = pMenuBar->GetBandIndex();
    if (iMenuBand == -1)
        return;

    /*
     * if the menu band is the last band on the rebar, we're done
     */
    int cBands = GetBandCount();
    if (iMenuBand == cBands-1)
        return;

    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof (rbbi);
    rbbi.fMask  = RBBIM_STYLE;

    /*
     * if the first visible band following the menu band isn't
     * on a new line, make it so
     */
    for (int iBand = iMenuBand+1; iBand < cBands; iBand++)
    {
        if (GetBandInfo (iBand, &rbbi) && !(rbbi.fStyle & RBBS_HIDDEN))
        {
            if (!(rbbi.fStyle & RBBS_BREAK))
            {
                rbbi.fStyle |= RBBS_BREAK;
                SetBandInfo (iBand, &rbbi);
            }

            break;
        }
    }
}


//+-------------------------------------------------------------------
//
//  Member:     OnRebarHeightChange
//
//  Synopsis:   RBN_HEIGHTCHANGE notification handler.
//
//              When the rebar changes its height, we need to allow the
//              docking host to resize to accomodate it.
//
//  Arguments:  Not used.
//
//--------------------------------------------------------------------
void CRebarWnd::OnRebarHeightChange(NMHDR* pNotify, LRESULT* result)
{
    CRebarDockWindow* pRebarWnd = (CRebarDockWindow*) GetParent();
    if (pRebarWnd && IsWindow(pRebarWnd->m_hWnd))
        pRebarWnd->UpdateWindowSize();
}


CRect CRebarWnd::CalculateSize(CRect maxRect)
{
    CRect rect;
    GetClientRect(&rect);
//    TRACE(_T("rc.bottom=%d\n"),rect.bottom);

    rect.right=maxRect.Width();

    return rect;

}

BOOL CRebarWnd::Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
    BOOL bResult = FALSE;
    ASSERT_VALID(pParentWnd);   // must have a parent

    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_COOL_CLASSES;

    if (!InitCommonControlsEx(&icex))
        return bResult;

    dwStyle |= WS_BORDER | /*WS_CLIPCHILDREN | WS_CLIPSIBLINGS |*/
               CCS_NODIVIDER | CCS_NOPARENTALIGN |
               RBS_VARHEIGHT | RBS_BANDBORDERS;

    if (CWnd::CreateEx (WS_EX_TOOLWINDOW,
                           REBARCLASSNAME,
                           lpszWindowName,
                           dwStyle,
                           rect,
                           pParentWnd,
                           nID))
    {
        // Initialize and send the REBARINFO structure.
        REBARINFO rbi;
        rbi.cbSize = sizeof(REBARINFO);
        rbi.fMask  = 0;
        rbi.himl   = NULL;

        if (SetBarInfo (&rbi))
            bResult=TRUE;
    }


    return bResult;
}


BOOL CRebarWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
    if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return (TRUE);

    return (FALSE);
}


LRESULT CRebarWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    // this is required for Action, View drop-downs
    if ((WM_COMMAND == message) && IsWindow ((HWND) lParam))
        return ::SendMessage((HWND)lParam, message, wParam, lParam);

    return CWnd::WindowProc(message, wParam, lParam);
}



/////////////////////////////////////////////////////////////////////////////
// CToolBar idle update through CToolCmdUI class


void CToolCmdUIEx::Enable(BOOL bOn)
{
    m_bEnableChanged = TRUE;
    CToolBarCtrlEx* pToolBar = (CToolBarCtrlEx*)m_pOther;
    ASSERT(pToolBar != NULL);
    ASSERT(m_nIndex < m_nIndexMax);

    UINT nNewStyle = pToolBar->GetState(m_nID);
    if (!bOn)
    {
        nNewStyle  &= ~TBSTATE_ENABLED;
        // WINBUG: If a button is currently pressed and then is disabled
        // COMCTL32.DLL does not unpress the button, even after the mouse
        // button goes up!  We work around this bug by forcing TBBS_PRESSED
        // off when a button is disabled.
        nNewStyle &= ~TBBS_PRESSED;
    }
    else
    {
        nNewStyle |= TBSTATE_ENABLED;
    }
    //ASSERT(!(nNewStyle & TBBS_SEPARATOR));
    pToolBar->SetState(m_nID, nNewStyle);
}

void CToolCmdUIEx::SetCheck(int nCheck)
{
    ASSERT(nCheck >= 0 && nCheck <= 2); // 0=>off, 1=>on, 2=>indeterminate
    CToolBarCtrlEx* pToolBar = (CToolBarCtrlEx*)m_pOther;
    ASSERT(pToolBar != NULL);
    ASSERT(m_nIndex < m_nIndexMax);

    UINT nNewStyle = pToolBar->GetState(m_nID) &
                ~(TBBS_CHECKED | TBBS_INDETERMINATE | TBBS_CHECKBOX);


    if (nCheck == 1)
        nNewStyle |= TBBS_CHECKED | TBBS_CHECKBOX;
    else if (nCheck == 2)
        nNewStyle |= TBBS_INDETERMINATE;

    pToolBar->SetState(m_nID, nNewStyle);
}

void CToolCmdUIEx::SetText(LPCTSTR)
{

}

void CToolCmdUIEx::SetHidden(BOOL bHidden)
{

    m_bEnableChanged = TRUE;
    CToolBarCtrlEx* pToolBar = (CToolBarCtrlEx*)m_pOther;
    ASSERT(pToolBar != NULL);
    ASSERT(m_nIndex < m_nIndexMax);

    pToolBar->HideButton(m_nID, bHidden);

    pToolBar->UpdateToolbarSize();

}



/////////////////////////////////////////////////////////////////////////////
// CMMCToolBarCtrlEx


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetTrackAccel
 *
 * Manages the accelerator table singleton for CMMCToolBarCtrlEx
 *--------------------------------------------------------------------------*/

const CAccel& CMMCToolBarCtrlEx::GetTrackAccel ()
{
    static ACCEL aaclTrack[] = {
        {   FVIRTKEY,           VK_RETURN,  CMMCToolBarCtrlEx::ID_MTBX_PRESS_HOT_BUTTON   },
        {   FVIRTKEY,           VK_RIGHT,   CMMCToolBarCtrlEx::ID_MTBX_NEXT_BUTTON              },
        {   FVIRTKEY,           VK_LEFT,    CMMCToolBarCtrlEx::ID_MTBX_PREV_BUTTON              },
        {   FVIRTKEY,           VK_ESCAPE,  CMMCToolBarCtrlEx::ID_MTBX_END_TRACKING             },
        {   FVIRTKEY,           VK_TAB,     CMMCToolBarCtrlEx::ID_MTBX_NEXT_BUTTON              },
        {   FVIRTKEY | FSHIFT,  VK_TAB,     CMMCToolBarCtrlEx::ID_MTBX_PREV_BUTTON              },
    };

    static const CAccel TrackAccel (aaclTrack, countof (aaclTrack));
    return (TrackAccel);
}


CMMCToolBarCtrlEx::CMMCToolBarCtrlEx()
{
    m_fTrackingToolBar  = false;
	m_fFakeFocusApplied = false;
}

CMMCToolBarCtrlEx::~CMMCToolBarCtrlEx()
{
}


BEGIN_MESSAGE_MAP(CMMCToolBarCtrlEx, CToolBarCtrlEx)
    //{{AFX_MSG_MAP(CMMCToolBarCtrlEx)
    ON_NOTIFY_REFLECT(TBN_HOTITEMCHANGE, OnHotItemChange)
    ON_WM_LBUTTONDOWN()
    ON_WM_MBUTTONDOWN()
    ON_WM_RBUTTONDOWN()
	ON_WM_DESTROY()
    ON_COMMAND(ID_MTBX_NEXT_BUTTON, OnNextButton)
    ON_COMMAND(ID_MTBX_PREV_BUTTON, OnPrevButton)
    ON_COMMAND(ID_MTBX_END_TRACKING, EndTracking)
    ON_COMMAND(ID_MTBX_PRESS_HOT_BUTTON, OnPressHotButton)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMMCToolBarCtrlEx message handlers

BOOL CMMCToolBarCtrlEx::PreTranslateMessage(MSG* pMsg)
{
    if (CToolBarCtrlEx::PreTranslateMessage (pMsg))
        return (TRUE);

    if ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST))
    {
        const CAccel& TrackAccel = GetTrackAccel();
        ASSERT (TrackAccel != NULL);

        // ...or try to handle it here.
        if (m_fTrackingToolBar && TrackAccel.TranslateAccelerator (m_hWnd, pMsg))
            return (TRUE);
    }

    return (FALSE);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnCreate
 *
 * WM_CREATE handler for CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::OnCreate"));

	if (CToolBarCtrlEx::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	/*
	 * Create our accessibility object so accessibility tools can follow
	 * keyboard access to the toolbar.  If we can't, some accessibility
	 * tools (those that are super paranoid about confirming that objects
	 * for which they receive EVENT_OBJECT_FOCUS have a state of
	 * STATE_SYSTEM_FOCUSED) may not be able to follow along with toolbar
	 * tracking, but we can continue.
	 */
	sc = ScInitAccessibility();
	if (sc)
		sc.TraceAndClear();
	
	return 0;
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnDestroy
 *
 * WM_DESTROY handler for CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnDestroy()
{
	CToolBarCtrlEx::OnDestroy();
	
	/*
	 * if we provided an IAccPropServer to oleacc.dll, revoke it now
	 */
	if (m_spAccPropServices != NULL)
	{
		m_spAccPropServices->ClearHwndProps (m_hWnd, OBJID_CLIENT, CHILDID_SELF,
											 &PROPID_ACC_STATE, 1);
		m_spAccPropServices.Release();
	}
}

/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnLButtonDown
 *
 * Allows the tracker to turn off when someone clicks elsewhere
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnLButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
        EndTracking();
    else
        CToolBarCtrlEx::OnLButtonDown(nFlags, point );
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnMButtonDown
 *
 * Allows the tracker to turn off when someone clicks elsewhere
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnMButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
        EndTracking();
    else
        CToolBarCtrlEx::OnMButtonDown(nFlags, point );
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnRButtonDown
 *
 * Allows the tracker to turn off when someone clicks elsewhere
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnRButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
        EndTracking();
    else
        CToolBarCtrlEx::OnRButtonDown(nFlags, point );
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnNextButton
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnNextButton ()
{
    // In a mirrored toolbar swap left and right keys.
    if (m_fMirrored)
        SetHotItem (GetPrevButtonIndex (GetHotItem ()));
    else
        SetHotItem (GetNextButtonIndex (GetHotItem ()));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnPrevButton
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnPrevButton ()
{
    // In a mirrored toolbar swap left and right keys.
    if (m_fMirrored)
        SetHotItem (GetNextButtonIndex (GetHotItem ()));
    else
        SetHotItem (GetPrevButtonIndex (GetHotItem ()));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::BeginTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::BeginTracking ()
{
    BeginTracking2 (GetMainAuxWnd());
}

void CMMCToolBarCtrlEx::BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
    if (!m_fTrackingToolBar)
    {
        m_fTrackingToolBar = true;
        SetHotItem (GetFirstButtonIndex ());

        // Captures the mouse
        // This prevents the mouse from activating something else without
        // first giving us a chance to deactivate the tool bar.
        SetCapture();
        // make sure to set standard corsor since we've stolen the mouse
        // see BUG 28458 MMC: Mouse icon does not refresh when menu is activated by pressing ALT key
        ::SetCursor( ::LoadCursor( NULL, IDC_ARROW ) );

        if (pAuxWnd != NULL)
            pAuxWnd->TrackToolbar (this);
    }
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::EndTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::EndTracking ()
{
    EndTracking2 (GetMainAuxWnd());
}

void CMMCToolBarCtrlEx::EndTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::EndTracking2"));

	/*
	 * tell accessibility tools that the "focus" went back to the real
	 * focus window
	 */
	sc = ScRestoreAccFocus();
	if (sc)
		sc.TraceAndClear();

    if (m_fTrackingToolBar)
    {
        SetHotItem (-1);
        m_fTrackingToolBar = false;

        // Releases the mouse This gives us a chance to deactivate the tool bar
        // before anything else is activated.
        ReleaseCapture();

        if (pAuxWnd != NULL)
            pAuxWnd->TrackToolbar (NULL);
    }
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnPressHotButton
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnPressHotButton ()
{
    int nHotIndex = GetHotItem();
    ASSERT (m_fTrackingToolBar);
    ASSERT (nHotIndex != -1);

    TBBUTTON    tb;
    GetButton (nHotIndex, &tb);

    // press the button and pause to show the press
    PressButton (tb.idCommand, true);
    UpdateWindow ();
    Sleep (50);

    // EndTracking for surrogate windows will detach the window,
    // so remember everything that we'll need later
    HWND hwnd = m_hWnd;
    CWnd* pwndOwner = SetOwner (NULL);
    SetOwner (pwndOwner);

    // release the button
    PressButton (tb.idCommand, false);
    EndTracking ();

    /*-----------------------------------------------------------------*/
    /* WARNING:  don't use any members of this class beyond this point */
    /*-----------------------------------------------------------------*/

    // make sure drawing is completed
    ::UpdateWindow (hwnd);

    // send a command to our owner
    pwndOwner->SendMessage (WM_COMMAND, MAKEWPARAM (tb.idCommand, BN_CLICKED),
                            (LPARAM) hwnd);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetFirstButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetFirstButtonIndex ()
{
    return (GetNextButtonIndex (-1));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetNextButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetNextButtonIndex (
    int     nStartIndex,
    int     nCount /* = 1 */)
{
    return (GetNextButtonIndexWorker (nStartIndex, nCount, true));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetPrevButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetPrevButtonIndex (
    int nStartIndex,
    int nCount /* = 1 */)
{
    return (GetNextButtonIndexWorker (nStartIndex, nCount, false));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetNextButtonIndexWorker
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetNextButtonIndexWorker (
    int     nStartIndex,
    int     nCount,
    bool    fAdvance)
{
    ASSERT (nCount >= 0);

    if (!fAdvance)
        nCount = -nCount;

    int  cButtons   = GetButtonCount ();
    int  nNextIndex = nStartIndex;
    bool fIgnorable;

    if (0 == cButtons)
        return nStartIndex;

    /*
     * loop until we find a next index that we don't want to
     * ignore, or until we've checked each of the buttons
     */
    do
    {
        nNextIndex = (nNextIndex + cButtons + nCount) % cButtons;
        fIgnorable = IsIgnorableButton (nNextIndex);

        if (fIgnorable)
            nCount = fAdvance ? 1 : -1;

        // prevent an infinite loop finding the first button
        if ((nStartIndex == -1) && (nNextIndex == cButtons-1))
            nNextIndex = nStartIndex;

    } while (fIgnorable && (nNextIndex != nStartIndex));

    return (nNextIndex);
}


/*+-------------------------------------------------------------------------*
 * IsIgnorableButton
 *
 * Determines if a toolbar button is "ignorable" from a UI perspective,
 * i.e. whether it is hidden, disabled, or a separator.
 *--------------------------------------------------------------------------*/

bool CMMCToolBarCtrlEx::IsIgnorableButton (int nButtonIndex)
{
    TBBUTTON tb;
    GetButton (nButtonIndex, &tb);

    return (::IsIgnorableButton (tb));
}

bool IsIgnorableButton (const TBBUTTON& tb)
{
    if (tb.fsStyle & TBSTYLE_SEP)
        return (true);

    if (tb.fsState & TBSTATE_HIDDEN)
        return (true);

    if (!(tb.fsState & TBSTATE_ENABLED))
        return (true);

    return (false);
}



/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnHotItemChange
 *
 * Reflected TBN_HOTITEMCHANGE handler for void CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnHotItemChange (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);
    CToolbarTrackerAuxWnd*	pAuxWnd = GetMainAuxWnd();
	LPNMTBHOTITEM			ptbhi   = (LPNMTBHOTITEM) pHdr;

	Trace (tagToolbarAccessibility, _T("TBN_HOTITEMCHANGE: idOld=%d idNew=%d"), ptbhi->idOld, ptbhi->idNew);

    /*
     * if we're not in tracking mode, hot item change is OK
     */
    if (pAuxWnd == NULL)
        *pResult = 0;

    /*
     * if we're tracking, but this isn't the tracked toolbar,
     * the hot item change isn't OK
     */
    else if (!IsTrackingToolBar())
        *pResult = 1;

    /*
     * prevent mouse movement over empty portions of
     * the bar from changing the hot item
     */
    else
    {
        const DWORD dwIgnoreFlags = (HICF_MOUSE | HICF_LEAVING);
        *pResult = ((ptbhi->dwFlags & dwIgnoreFlags) == dwIgnoreFlags);
    }

	/*
	 * If we're allowing the hot item change while we're keyboard tracking
	 * the toolbar (to exclude changes due to mouse tracking), send a focus
	 * event so accessibility tools like Magnifier and Narrator can follow
	 * the change.  This fake-focus effect is undone in ScRestoreAccFocus.
	 */
	int idChild;
	if (IsTrackingToolBar()		&&
		(*pResult == 0)			&&
		(ptbhi->idNew != 0)		&&	
		((idChild = CommandToIndex(ptbhi->idNew)) != -1))
	{
		Trace (tagToolbarAccessibility, _T("Sending focus event for button %d"), idChild+1);
		NotifyWinEvent (EVENT_OBJECT_FOCUS, m_hWnd, OBJID_CLIENT, idChild+1 /*1-based*/);
		m_fFakeFocusApplied = true;
	}
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScInitAccessibility
 *
 * Creates the IAccPropServer object that will fool accessibility tools into
 * thinking that this toolbar really has the focus when we're in tracking
 * mode, even though it really doesn't
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScInitAccessibility ()
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScInitAccessibility"));

	/*
	 * if we've already initialized, just return
	 */
	if (m_spAccPropServices != NULL)
		return (sc);

	/*
	 * create a CLSID_AccPropServices provided by the MSAA runtime (oleacc.dll)
	 * This is a new feature in oleacc.dll, so trace failure as an informational
	 * message rather than an error.
	 */
	SC scNoTrace = m_spAccPropServices.CoCreateInstance (CLSID_AccPropServices);
	if (scNoTrace)
	{
#ifdef DBG
		TCHAR szErrorText[256];
		sc.GetErrorMessage (countof(szErrorText), szErrorText);
		StripTrailingWhitespace (szErrorText);

		Trace (tagToolbarAccessibility, _T("Failed to create CLSID_AccPropServices"));
		Trace (tagToolbarAccessibility, _T("SC = 0x%08X = %d = \"%s\""),
			   sc.GetCode(), LOWORD(sc.GetCode()), szErrorText);
#endif	// DBG

		return (sc);
	}

	sc = ScCheckPointers (m_spAccPropServices, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * create the property server
	 */
    sc = CTiedComObjectCreator<CMMCToolBarAccServer>::ScCreateAndConnect(*this, m_spAccPropServer);
	if (sc)
		return (sc);

	sc = ScCheckPointers (m_spAccPropServer, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * collect the properties we'll be providing, insuring there
	 * are no duplicates
	 */
	sc = ScInsertAccPropIDs (m_vPropIDs);
	if (sc)
		return (sc);

	std::sort (m_vPropIDs.begin(), m_vPropIDs.end());	// std::unique needs a sorted range
	m_vPropIDs.erase (std::unique (m_vPropIDs.begin(), m_vPropIDs.end()),
					  m_vPropIDs.end());

	/*
	 * insure m_vPropIDs contains no duplicates (IAccPropServices::SetHwndPropServer
	 * depends on it)
	 */
#ifdef DBG
	for (int i = 0; i < m_vPropIDs.size()-1; i++)
	{
		ASSERT (m_vPropIDs[i] < m_vPropIDs[i+1]);
	}
#endif

	/*
	 * Enable our property server for this window.  We should be able to
	 * hook all properties in one fell swoop, but there's a bug in oleacc.dll
	 * that prevents this.  Hooking the properties one at a time works fine.
	 */
#if 0
	sc = m_spAccPropServices->SetHwndPropServer (m_hWnd,
												 OBJID_CLIENT,
												 CHILDID_SELF,
												 m_vPropIDs.begin(),
												 m_vPropIDs.size(),
												 m_spAccPropServer,
												 ANNO_CONTAINER);
	if (sc)
	{
		Trace (tagToolbarAccessibility, _T("SetHwndPropServer failed"));
		return (sc);
	}
#else
	for (int i = 0; i < m_vPropIDs.size(); i++)
	{
		sc = m_spAccPropServices->SetHwndPropServer (m_hWnd,
													 OBJID_CLIENT,
													 CHILDID_SELF,
													 &m_vPropIDs[i],
													 1,
													 m_spAccPropServer,
													 ANNO_CONTAINER);
		if (sc)
		{
#ifdef DBG
			USES_CONVERSION;
			WCHAR wzPropID[40];
			StringFromGUID2 (m_vPropIDs[i], wzPropID, countof(wzPropID));
			Trace (tagToolbarAccessibility, _T("SetHwndPropServer failed for %s"), W2T(wzPropID));
#endif
			sc.TraceAndClear();	
		}
	}
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScInsertAccPropIDs
 *
 * Inserts the IDs of the accessibility properties supported by
 * CMMCToolBarCtrlEx (see ScGetPropValue).
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScInsertAccPropIDs (PropIDCollection& v)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScInsertAccPropIDs"));
	v.push_back (PROPID_ACC_STATE);
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScGetPropValue
 *
 * Implements IAccPropServer::GetPropValue for CMMCToolBarCtrlEx.  If this
 * funtion is asked for PROPID_ACC_STATE for the currently hot button while
 * we're in tracking mode, it'll return a state that mimics the state
 * returned by a plain toolbar when it really has the focus.
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScGetPropValue (
	const BYTE*	pIDString,
	DWORD		dwIDStringLen,
	MSAAPROPID	idProp,
	VARIANT *	pvarValue,
	BOOL *		pfGotProp)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScGetPropValue"));

	sc = ScCheckPointers (pIDString, pvarValue, pfGotProp);
	if (sc)
		return (sc);

	/*
	 * assume no prop returned
	 */
	*pfGotProp      = false;
	V_VT(pvarValue) = VT_EMPTY;

	sc = ScCheckPointers (m_spAccPropServer, E_UNEXPECTED);	
	if (sc)
		return (sc);

	/*
	 * extract the child ID from the identity string
	 */
	HWND hwnd;
	DWORD idObject, idChild;
	sc = m_spAccPropServices->DecomposeHwndIdentityString (pIDString, dwIDStringLen,
														   &hwnd, &idObject, &idChild);
	if (sc)
		return (sc);

#ifdef DBG
	#define DEFINE_PDI(p)	PropDebugInfo (p, _T(#p))

	static const struct PropDebugInfo {
		// constructor used to get around nested structure initialization weirdness
		PropDebugInfo(const MSAAPROPID& id, LPCTSTR psz) : idProp(id), pszProp(psz) {}

		const MSAAPROPID&	idProp;
		LPCTSTR				pszProp;
	} rgpdi[] = {
		DEFINE_PDI (PROPID_ACC_NAME            ),
		DEFINE_PDI (PROPID_ACC_VALUE           ),
		DEFINE_PDI (PROPID_ACC_DESCRIPTION     ),
		DEFINE_PDI (PROPID_ACC_ROLE            ),
		DEFINE_PDI (PROPID_ACC_STATE           ),
		DEFINE_PDI (PROPID_ACC_HELP            ),
		DEFINE_PDI (PROPID_ACC_KEYBOARDSHORTCUT),
		DEFINE_PDI (PROPID_ACC_DEFAULTACTION   ),
		DEFINE_PDI (PROPID_ACC_HELPTOPIC       ),
		DEFINE_PDI (PROPID_ACC_FOCUS           ),
		DEFINE_PDI (PROPID_ACC_SELECTION       ),
		DEFINE_PDI (PROPID_ACC_PARENT          ),
		DEFINE_PDI (PROPID_ACC_NAV_UP          ),
		DEFINE_PDI (PROPID_ACC_NAV_DOWN        ),
		DEFINE_PDI (PROPID_ACC_NAV_LEFT        ),
		DEFINE_PDI (PROPID_ACC_NAV_RIGHT       ),
		DEFINE_PDI (PROPID_ACC_NAV_PREV        ),
		DEFINE_PDI (PROPID_ACC_NAV_NEXT        ),
		DEFINE_PDI (PROPID_ACC_NAV_FIRSTCHILD  ),
		DEFINE_PDI (PROPID_ACC_NAV_LASTCHILD   ),
		DEFINE_PDI (PROPID_ACC_VALUEMAP        ),
		DEFINE_PDI (PROPID_ACC_ROLEMAP         ),
		DEFINE_PDI (PROPID_ACC_STATEMAP        ),
	};

	/*
	 * dump the requested property
	 */
	for (int i = 0; i < countof(rgpdi); i++)
	{
		if (rgpdi[i].idProp == idProp)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: %s requested for child %d"), rgpdi[i].pszProp, idChild);
			break;
		}
	}

	if (i == countof(rgpdi))
	{
		USES_CONVERSION;
		WCHAR wzPropID[40];
		StringFromGUID2 (idProp, wzPropID, countof(wzPropID));
		Trace (tagToolbarAccessibility, _T("GetPropValue: Unknown property ID %s"), W2T(wzPropID));
	}

	/*
	 * insure m_vPropIDs is sorted (std::lower_bound depends on it)
	 */
	for (int i = 0; i < m_vPropIDs.size()-1; i++)
	{
		ASSERT (m_vPropIDs[i] < m_vPropIDs[i+1]);
	}
#endif

	/*
	 * if we're asked for a property we didn't claim to support, don't return
	 * anything
	 */
	if (m_vPropIDs.end() == std::lower_bound (m_vPropIDs.begin(), m_vPropIDs.end(), idProp))
	{
		Trace (tagToolbarAccessibility, _T("GetPropValue: Unexpected property request"));
		return (sc);
	}

	/*
	 * get the property
	 */
	sc = ScGetPropValue (hwnd, idObject, idChild, idProp, *pvarValue, *pfGotProp);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScGetPropValue
 *
 * Returns accessibility properties supported by CMMCToolBarCtrlEx.
 *
 * If a property is returned, fGotProp is set to true.  If it is not
 * returned, the value of fGotProp is unchanged, since the property might
 * have been provided by a base/derived class.
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScGetPropValue (
	HWND				hwnd,		// I:accessible window
	DWORD				idObject,	// I:accessible object
	DWORD				idChild,	// I:accessible child object
	const MSAAPROPID&	idProp,		// I:property requested
	VARIANT&			varValue,	// O:returned property value
	BOOL&				fGotProp)	// O:was a property returned?
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScGetPropValue"));

	/*
	 * handle requests for state
	 */
	if (idProp == PROPID_ACC_STATE)
	{
		/*
		 * only override the property for child elements, not the control itself;
		 * don't return a property
		 */
		if (idChild == CHILDID_SELF)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: no state for CHILDID_SELF"));
			return (sc);
		}

		/*
		 * if we're not in tracking mode, don't return a property
		 */
		if (!IsTrackingToolBar())
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: not in tracking mode, no state returned"));
			return (sc);
		}

		/*
		 * if the current hot item isn't the child we're asked for, don't return a property
		 */
		int nHotItem = GetHotItem();
		if (nHotItem != (idChild-1) /*0-based*/)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: hot item is %d, no state returned"), nHotItem);
			return (sc);
		}

		/*
		 * if we get here, we're asked for state for the current hot item;
		 * return STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED to match
		 * what a truly focused toolbar would return
		 */
		V_VT(&varValue) = VT_I4;
		V_I4(&varValue) = STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED | STATE_SYSTEM_FOCUSABLE;
		fGotProp        = true;
		Trace (tagToolbarAccessibility, _T("GetPropValue: Returning 0x%08x"), V_I4(&varValue));
	}

	return (sc);
}



/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScRestoreAccFocus
 *
 * Sends a fake EVENT_OBJECT_FOCUS event to send accessibility tools back
 * to the true focus window, undoing the effect of our fake focus events
 * in OnHotItemChange.
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScRestoreAccFocus()
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScRestoreAccFocus"));

	/*
	 * if we haven't applied fake-focus, we don't need to restore anything
	 */
	if (!m_fFakeFocusApplied)
		return (sc);

	/*
	 * who has the focus now?
	 */
	HWND hwndFocus = ::GetFocus();
	if (hwndFocus == NULL)
		return (sc);

	/*
	 * default to sending the focus for CHILDID_SELF
	 */
	int idChild = CHILDID_SELF;

	/*
	 * get the accessible object for the focus window (don't abort on
	 * failure -- don't convert this HRESULT to SC)
	 */
	CComPtr<IAccessible> spAccessible;
	HRESULT hr = AccessibleObjectFromWindow (hwndFocus, OBJID_CLIENT,
											 IID_IAccessible,
											 (void**) &spAccessible);

	if (hr == S_OK)		// not "SUCCEEDED(hr)", per Accessibility spec
	{
		/*
		 * ask the accessible object which
		 */
		CComVariant varFocusID;
		hr = spAccessible->get_accFocus (&varFocusID);

		if (hr == S_OK)		// not "SUCCEEDED(hr)", per Accessibility spec
		{
			switch (V_VT(&varFocusID))
			{
				case VT_I4:
					idChild = V_I4(&varFocusID);
					break;

				case VT_EMPTY:
					/*
					 * Windows thinks the window has the focus, but its
					 * IAccessible thinks it doesn't.  Trust Windows.
					 */
					Trace (tagToolbarAccessibility, _T("Windows and IAccessible::get_accFocus don't agree on who has the focus"));
					break;

				case VT_DISPATCH:
					Trace (tagToolbarAccessibility, _T("IAccessible::get_accFocus returned VT_DISPATCH, ignoring"));
					break;

				default:
					Trace (tagToolbarAccessibility, _T("IAccessible::get_accFocus returned unexpected VARIANT type (%d)"), V_VT(&varFocusID));
					break;
			}
		}
		else
		{
			Trace (tagToolbarAccessibility, _T("IAccessible::get_accFocus failed, hr=0x%08x"), hwndFocus, hr);
		}
	}
	else
	{
		Trace (tagToolbarAccessibility, _T("Can't get IAccessible from hwnd=0x%p (hr=0x%08x)"), hwndFocus, hr);
	}

	Trace (tagToolbarAccessibility, _T("Sending focus event back to hwnd=0x%p, idChild=%d"), hwndFocus, idChild);
	NotifyWinEvent (EVENT_OBJECT_FOCUS, hwndFocus, OBJID_CLIENT, idChild);
	m_fFakeFocusApplied = false;

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\controls.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      controls.inl
 *
 *  Contents:  Inline functions for controls.h
 *
 *  History:   7-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*+-------------------------------------------------------------------------*
 * CToolBarCtrlBase inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline CImageList* CToolBarCtrlBase::GetImageList_(int msg)
{
    return (CImageList::FromHandle ((HIMAGELIST) SendMessage (msg)));
}

// Toolbar with multiple imagelists.
inline CImageList* CToolBarCtrlBase::SetImageList_(int msg, CImageList* pImageList, int idImageList)
{
    return (CImageList::FromHandle ((HIMAGELIST) SendMessage (msg, idImageList, (LPARAM)pImageList->GetSafeHandle())));
}

inline CImageList* CToolBarCtrlBase::GetImageList()
{
    return (GetImageList_(TB_GETIMAGELIST));
}

// Toolbar with multiple imagelists.
inline CImageList* CToolBarCtrlBase::SetImageList(CImageList* pImageList, int idImageList)
{
    return (SetImageList_(TB_SETIMAGELIST, pImageList, idImageList));
}

inline CImageList* CToolBarCtrlBase::GetHotImageList()
{
    return (GetImageList_(TB_GETHOTIMAGELIST));
}

inline CImageList* CToolBarCtrlBase::SetHotImageList(CImageList* pImageList)
{
    return (SetImageList_(TB_SETHOTIMAGELIST, pImageList));
}

inline CImageList* CToolBarCtrlBase::GetDisabledImageList()
{
    return (GetImageList_(TB_GETDISABLEDIMAGELIST));
}

inline CImageList* CToolBarCtrlBase::SetDisabledImageList(CImageList* pImageList)
{
    return (SetImageList_(TB_SETDISABLEDIMAGELIST, pImageList));
}

inline void CToolBarCtrlBase::SetMaxTextRows(int iMaxRows)
{
    SendMessage (TB_SETMAXTEXTROWS, iMaxRows);
}

inline void CToolBarCtrlBase::SetButtonWidth(int cxMin, int cxMax)
{
    SendMessage (TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
}

inline DWORD CToolBarCtrlBase::GetButtonSize(void)
{
    return SendMessage (TB_GETBUTTONSIZE);
}

inline CWnd* CToolBarCtrlBase::SetOwner(CWnd* pwndNewParent)
{
    return (CWnd::FromHandle ((HWND) SendMessage (TB_SETPARENT, (WPARAM) pwndNewParent->GetSafeHwnd())));
}

#if (_WIN32_IE >= 0x0400)
inline int CToolBarCtrlBase::GetHotItem ()
{
    return (SendMessage (TB_GETHOTITEM));
}

inline int CToolBarCtrlBase::SetHotItem (int iHot)
{
    return (SendMessage (TB_SETHOTITEM, iHot));
}

inline CSize CToolBarCtrlBase::GetPadding ()
{
    return (CSize (SendMessage (TB_GETPADDING)));
}

inline CSize CToolBarCtrlBase::SetPadding (CSize size)
{
    return (CSize (SendMessage (TB_SETPADDING, 0, MAKELPARAM (size.cx, size.cy))));
}

inline bool CToolBarCtrlBase::GetButtonInfo (int iID, LPTBBUTTONINFO ptbbi)
{
    return (SendMessage (TB_GETBUTTONINFO, iID, (LPARAM) ptbbi) != 0);
}

inline bool CToolBarCtrlBase::SetButtonInfo (int iID, LPTBBUTTONINFO ptbbi)
{
    return (SendMessage (TB_SETBUTTONINFO, iID, (LPARAM) ptbbi) != 0);
}
#endif  // _WIN32_IE >= 0x0400



/*+-------------------------------------------------------------------------*
 * CToolBarCtrlEx inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline BOOL CToolBarCtrlEx::SetBitmapSize(CSize sz)
{
    if (!BaseClass::SetBitmapSize(sz))
        return (FALSE);

    m_sizeBitmap = sz;
    return (TRUE);
}

inline CSize CToolBarCtrlEx::GetBitmapSize(void)
{
    return m_sizeBitmap;
}


/*+-------------------------------------------------------------------------*
 * CTabCtrlEx inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline void CTabCtrlEx::DeselectAll (bool fExcludeFocus)
{
    SendMessage (TCM_DESELECTALL, fExcludeFocus);
}

inline bool CTabCtrlEx::HighlightItem (UINT nItem, bool fHighlight)
{
    return (SendMessage (TCM_HIGHLIGHTITEM, nItem, MAKELONG (fHighlight, 0)) ? true : false);
}

inline DWORD CTabCtrlEx::GetExtendedStyle ()
{
    return (SendMessage (TCM_GETEXTENDEDSTYLE));
}

inline DWORD CTabCtrlEx::SetExtendedStyle (DWORD dwExStyle, DWORD dwMask /* =0 */)
{
    return (SendMessage (TCM_SETEXTENDEDSTYLE, dwMask, dwExStyle));
}

inline bool CTabCtrlEx::GetUnicodeFormat ()
{
    return (SendMessage (TCM_GETUNICODEFORMAT) ? true : false);
}

inline bool CTabCtrlEx::SetUnicodeFormat (bool fUnicode)
{
    return (SendMessage (TCM_SETUNICODEFORMAT, fUnicode) ? true : false);
}

inline void CTabCtrlEx::SetCurFocus (UINT nItem)
{
    SendMessage (TCM_SETCURFOCUS, nItem);
}

inline bool CTabCtrlEx::SetItemExtra (UINT cbExtra)
{
    return (SendMessage (TCM_SETITEMEXTRA, cbExtra) ? true : false);
}

inline int CTabCtrlEx::SetMinTabWidth (int cx)
{
    return (SendMessage (TCM_SETMINTABWIDTH, 0, cx));
}



/*+-------------------------------------------------------------------------*
 * CRebarWnd inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline LRESULT CRebarWnd::SetBarInfo(REBARINFO* prbi)
{
    ASSERT (prbi != NULL);
    return SendMessage (RB_SETBARINFO, 0, (LPARAM)prbi);
}

inline LRESULT CRebarWnd::GetBarInfo(REBARINFO* prbi)
{
    ASSERT (prbi != NULL);
    return SendMessage (RB_GETBARINFO, 0, (LPARAM)prbi);
}

inline LRESULT CRebarWnd::InsertBand(LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    return SendMessage (RB_INSERTBAND, -1, (LPARAM)lprbbi);
}

inline LRESULT CRebarWnd::SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    return SendMessage (RB_SETBANDINFO, uBand, (LPARAM)lprbbi);
}

inline LRESULT CRebarWnd::GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    return SendMessage (RB_GETBANDINFO, uBand, (LPARAM)lprbbi);
}

inline LRESULT CRebarWnd::DeleteBand(UINT uBand)
{
    return SendMessage (RB_DELETEBAND, uBand);
}

inline CWnd* CRebarWnd::SetParent(CWnd* pwndParent)
{
    return CWnd::FromHandle((HWND)SendMessage (RB_SETPARENT, (WPARAM) pwndParent->GetSafeHwnd()));
}

inline UINT CRebarWnd::GetBandCount()
{
    return SendMessage (RB_GETBANDCOUNT);
}

inline UINT CRebarWnd::GetRowCount()
{
    return SendMessage (RB_GETROWCOUNT);
}

inline UINT CRebarWnd::GetRowHeight(UINT uRow)
{
    return SendMessage (RB_GETROWHEIGHT);
}

#if (_WIN32_IE >= 0x0400)
inline int CRebarWnd::HitTest (LPRBHITTESTINFO lprbht)
{
    ASSERT (lprbht != NULL);
    return SendMessage (RB_HITTEST, 0, (LPARAM) lprbht);
}

inline BOOL CRebarWnd::GetRect (UINT uBand, LPRECT lprc)
{
    ASSERT (lprc != NULL);
    return SendMessage (RB_GETRECT, uBand, (LPARAM) lprc);
}

inline int CRebarWnd::IdToIndex (UINT uBandID)
{
    return SendMessage (RB_IDTOINDEX, uBandID);
}

inline CWnd* CRebarWnd::GetToolTips ()
{
    return CWnd::FromHandle ((HWND)SendMessage (RB_GETTOOLTIPS));
}

inline void CRebarWnd::SetToolTips (CWnd* pwndTips)
{
    SendMessage (RB_SETTOOLTIPS, (WPARAM) pwndTips->GetSafeHwnd());
}

inline COLORREF CRebarWnd::GetBkColor ()
{
    return SendMessage (RB_GETBKCOLOR);
}

inline COLORREF CRebarWnd::SetBkColor (COLORREF clrBk)
{
    return SendMessage (RB_SETBKCOLOR, 0, clrBk);
}

inline COLORREF CRebarWnd::GetTextColor ()
{
    return SendMessage (RB_GETTEXTCOLOR);
}

inline COLORREF CRebarWnd::SetTextColor (COLORREF clrText)
{
    return SendMessage (RB_SETTEXTCOLOR, 0, clrText);
}

inline LRESULT CRebarWnd::SizeToRect (LPRECT lprc)
{
    ASSERT (lprc != NULL);
    return SendMessage (RB_SIZETORECT, 0, (LPARAM) lprc);
}

inline void CRebarWnd::BeginDrag (UINT uBand, CPoint point)
{
    BeginDrag (uBand, MAKELONG (point.x, point.y));
}

inline void CRebarWnd::BeginDrag (UINT uBand, DWORD dwPos)
{
    SendMessage (RB_BEGINDRAG, uBand, dwPos);
}

inline void CRebarWnd::EndDrag ()
{
    SendMessage (RB_ENDDRAG);
}

inline void CRebarWnd::DragMove (CPoint point)
{
    DragMove (MAKELONG (point.x, point.y));
}

inline void CRebarWnd::DragMove (DWORD dwPos)
{
    SendMessage (RB_BEGINDRAG, 0, dwPos);
}

inline UINT CRebarWnd::GetBarHeight()
{
    return SendMessage (RB_GETBARHEIGHT);
}

inline void CRebarWnd::MinimizeBand(UINT uBand)
{
    SendMessage (RB_MINIMIZEBAND, uBand);
}

inline void CRebarWnd::MaximizeBand(UINT uBand, BOOL fIdeal /* =false */)
{
    SendMessage (RB_MAXIMIZEBAND, uBand, fIdeal);
}

inline void CRebarWnd::GetBandBorders(UINT uBand, LPRECT lprc)
{
    ASSERT (lprc != NULL);
    SendMessage (RB_GETBANDBORDERS, uBand, (LPARAM) lprc);
}

inline LRESULT CRebarWnd::ShowBand(UINT uBand, BOOL fShow)
{
    return SendMessage (RB_SHOWBAND, uBand, fShow);
}

inline CPalette* CRebarWnd::GetPalette()
{
    return CPalette::FromHandle((HPALETTE) SendMessage (RB_GETPALETTE));
}

inline CPalette* CRebarWnd::SetPalette(CPalette * ppal)
{
    return CPalette::FromHandle((HPALETTE)SendMessage (RB_SETPALETTE, 0, (LPARAM)ppal->GetSafeHandle()));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\controls.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       controls.h
//
//--------------------------------------------------------------------------

// Controls.h
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONTROLS_H__
#define __CONTROLS_H__
#pragma once

#include "conuiobservers.h"		// for CTreeViewObserver
#include <initguid.h>
#include <oleacc.h>

#ifdef DBG
extern CTraceTag tagToolbarAccessibility;
#endif


bool IsIgnorableButton (const TBBUTTON& tb);

class CRebarWnd;
class CAccel;
class CToolbarTrackerAuxWnd;

/////////////////////////////////////////////////////////////////////////////
// CDescriptionCtrl window

class CDescriptionCtrl : public CStatic, public CTreeViewObserver
{
// Construction
public:
    CDescriptionCtrl();

// Attributes
public:
    void SetSnapinText (const CString& strSnapinText);

    const CString& GetSnapinText () const
        { return (m_strSnapinText); }

    int GetHeight() const
        { return (m_cyRequired); }

	/*
	 * handlers for events fired to tree view observers
	 */
    virtual SC ScOnSelectedItemTextChanged (LPCTSTR pszNewText);

private:
    void CreateFont();
    void DeleteFont();

private:
    CString m_strConsoleText;
    CString m_strSnapinText;
    CFont   m_font;
    int     m_cxMargin;
    int     m_cyText;
    int     m_cyRequired;


// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDescriptionCtrl)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDescriptionCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CDescriptionCtrl)
    afx_msg UINT OnNcHitTest(CPoint point);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG

    afx_msg void DrawItem(LPDRAWITEMSTRUCT lpdis);

    DECLARE_MESSAGE_MAP()

//Attributes
protected:

};

/////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// CToolBarCtrlBase window


/*+-------------------------------------------------------------------------*
 * CToolBarCtrlBase
 *
 * This class only exists to provide simple wrappers around new toolbar
 * control messages that the version of MFC we use doesn't support.  It
 * will be removed when MFC supports the new messages.
 *
 * If you need functionality other than that, derive a class from
 * CToolBarCtrlBase.
 *--------------------------------------------------------------------------*/

class CToolBarCtrlBase : public CToolBarCtrl
{
private:
    CImageList* GetImageList_(int msg);
    CImageList* SetImageList_(int msg, CImageList* pImageList, int idImageList = 0);

public:
    CImageList* GetImageList();
    CImageList* SetImageList(CImageList* pImageList, int idImageList = 0);
    CImageList* GetHotImageList();
    CImageList* SetHotImageList(CImageList* pImageList);
    CImageList* GetDisabledImageList();
    CImageList* SetDisabledImageList(CImageList* pImageList);

    /*
     * CToolBarCtrl::SetOwner doesn't return the previous parent
     * and doesn't handle a NULL owner
     */
    CWnd* SetOwner (CWnd* pwndNewOwner);

    void SetMaxTextRows(int iMaxRows);
    void SetButtonWidth(int cxMin, int cxMax);
    DWORD GetButtonSize(void);

    #if (_WIN32_IE >= 0x0400)
        int GetHotItem ();
        int SetHotItem (int iHot);
        CSize GetPadding ();
        CSize SetPadding (CSize size);
        bool GetButtonInfo (int iID, LPTBBUTTONINFO ptbbi);
        bool SetButtonInfo (int iID, LPTBBUTTONINFO ptbbi);
    #endif  // _WIN32_IE >= 0x0400
};


///////////////////////////////////////////////////////////////////////////
// CToolBarCtrlEx window

class CToolBarCtrlEx : public CToolBarCtrlBase
{
	typedef CToolBarCtrlBase BaseClass;

// Construction
public:
    CToolBarCtrlEx();

// Attributes
public:
    CSize GetBitmapSize(void);

// Operations
public:
    void Show(BOOL bShow, bool bAddToolbarInNewLine = false);
    bool IsBandVisible();
    int  GetBandIndex();
    void UpdateToolbarSize(void);
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CToolBarCtrlEx)
    public:
    virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
    virtual BOOL SetBitmapSize(CSize sz);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CToolBarCtrlEx();

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);


    // Generated message map functions
protected:
    //{{AFX_MSG(CToolBarCtrlEx)
    afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()


protected:
    CSize       m_sizeBitmap;
    CRebarWnd*  m_pRebar;
    int         m_cx;  // Current Width
    bool        m_fMirrored;

};

////////////////////////////////////////////////////////////////////////////
// CRebarWnd window

class CRebarWnd : public CWnd
{
// Construction
public:
    CRebarWnd();

// Attributes
public:

// Operations
public:
    CRect CalculateSize(CRect maxRect);

    LRESULT GetBarInfo(REBARINFO* prbi);
    LRESULT SetBarInfo(REBARINFO* prbi);
    LRESULT InsertBand(LPREBARBANDINFO lprbbi);
    LRESULT SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);
    LRESULT GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);
    LRESULT DeleteBand(UINT uBand);
    CWnd *  SetParent(CWnd* pwndParent);
    UINT GetBandCount ();
    UINT GetRowCount ();
    UINT GetRowHeight (UINT uRow);

    #if (_WIN32_IE >= 0x0400)
        int  HitTest (LPRBHITTESTINFO lprbht);
        BOOL GetRect (UINT uBand, LPRECT lprc);
        int IdToIndex (UINT uBandID);
        CWnd* GetToolTips ();
        void  SetToolTips (CWnd* pwndTips);
        COLORREF GetBkColor ();
        COLORREF SetBkColor (COLORREF clrBk);
        COLORREF GetTextColor ();
        COLORREF SetTextColor (COLORREF clrBack);
        LRESULT SizeToRect (LPRECT lprc);

        // for manual drag control
        // lparam == cursor pos
                // -1 means do it yourself.
                // -2 means use what you had saved before
        void BeginDrag (UINT uBand, CPoint point);
        void BeginDrag (UINT uBand, DWORD dwPos);
        void EndDrag ();
        void DragMove (CPoint point);
        void DragMove (DWORD dwPos);
        UINT GetBarHeight ();
        void MinimizeBand (UINT uBand);
        void MaximizeBand (UINT uBand, BOOL fIdeal = false);
        void GetBandBorders (UINT uBand, LPRECT lprc);
        LRESULT ShowBand (UINT uBand, BOOL fShow);
        LRESULT MoveBand (UINT uBandFrom, UINT uBandTo);
        CPalette* GetPalette ();
        CPalette* SetPalette (CPalette* ppal);
    #endif      // _WIN32_IE >= 0x0400

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRebarWnd)
    public:
    virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
    protected:
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRebarWnd();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRebarWnd)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSysColorChange();
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    //}}AFX_MSG
    afx_msg LRESULT OnSetRedraw(WPARAM, LPARAM);
    afx_msg void OnRebarAutoSize(NMHDR* pNotify, LRESULT* result);
    afx_msg void OnRebarHeightChange(NMHDR* pNotify, LRESULT* result);
    DECLARE_MESSAGE_MAP()

private:
    bool    m_fRedraw;
};


////////////////////////////////////////////////////////////////////////////
// CTabCtrlEx window


/*+-------------------------------------------------------------------------*
 * CTabCtrlEx
 *
 * This class only exists to provide simple wrappers around new tab
 * control messages that the version of MFC we use doesn't support.  It
 * will be removed when MFC supports the new messages.
 *
 * If you need functionality other than that, derive a class from
 * CTabCtrlEx.
 *--------------------------------------------------------------------------*/

class CTabCtrlEx : public CTabCtrl
{
public:
    void  DeselectAll (bool fExcludeFocus);
    bool  HighlightItem (UINT nItem, bool fHighlight);
    DWORD GetExtendedStyle ();
    DWORD SetExtendedStyle (DWORD dwExStyle, DWORD dwMask = 0);
    bool  GetUnicodeFormat ();
    bool  SetUnicodeFormat (bool fUnicode);
    void  SetCurFocus (UINT nItem);
    bool  SetItemExtra (UINT cbExtra);
    int   SetMinTabWidth (int cx);
};



/////////////////////////////////////////////////////////////////////////////
// CToolBar idle update through CToolCmdUIEx class

class CToolCmdUIEx : public CCmdUI        // class private to this file !
{
public: // re-implementations only
    virtual void Enable(BOOL bOn);
    virtual void SetCheck(int nCheck);
    virtual void SetText(LPCTSTR lpszText);
    void SetHidden(BOOL bHidden);
};



/////////////////////////////////////////////////////////////////////////////
// CMMCToolBarCtrlEx window

class CMMCToolBarCtrlEx : public CToolBarCtrlEx, public CTiedObject
{
    static const CAccel& GetTrackAccel();

    bool    m_fTrackingToolBar;
	bool	m_fFakeFocusApplied;	// have we send fake OBJ_FOCUS events?

// Construction
public:
    CMMCToolBarCtrlEx();

// Attributes
public:
    enum
    {
        ID_MTBX_NEXT_BUTTON = 0x5400,   // could be anything
        ID_MTBX_PREV_BUTTON,
        ID_MTBX_PRESS_HOT_BUTTON,
        ID_MTBX_END_TRACKING,

        ID_MTBX_FIRST = ID_MTBX_NEXT_BUTTON,
        ID_MTBX_LAST  = ID_MTBX_END_TRACKING,
    };

    bool IsTrackingToolBar () const
    {
        return (m_fTrackingToolBar);
    }


// Operations
public:
    virtual int GetFirstButtonIndex ();
    int GetNextButtonIndex (int nStartIndex, int nIncrement = 1);
    int GetPrevButtonIndex (int nStartIndex, int nIncrement = 1);

private:
    int GetNextButtonIndexWorker (int nStartIndex, int nIncrement, bool fAdvance);

protected:
    bool IsIgnorableButton (int nButtonIndex);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMCToolBarCtrlEx)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMMCToolBarCtrlEx();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMMCToolBarCtrlEx)
    afx_msg void OnHotItemChange(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG

    afx_msg void OnNextButton ();
    afx_msg void OnPrevButton ();
    afx_msg void OnPressHotButton ();
    DECLARE_MESSAGE_MAP()

public:
    afx_msg void BeginTracking ();
    afx_msg void EndTracking   ();

    virtual void BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd);
    virtual void EndTracking2   (CToolbarTrackerAuxWnd* pAuxWnd);

	// *** IAccPropServer methods ***
	SC ScGetPropValue (
		const BYTE*			pIDString,
		DWORD				dwIDStringLen,
		MSAAPROPID			idProp,
		VARIANT *			pvarValue,
		BOOL *				pfGotProp);

protected:
	typedef std::vector<MSAAPROPID> PropIDCollection;

	/*
	 * Derived classes can override this to handle properties they support.
	 * The base class should always be called first.
	 */
	virtual SC ScGetPropValue (
		HWND				hwnd,		// I:accessible window
		DWORD				idObject,	// I:accessible object
		DWORD				idChild,	// I:accessible child object
		const MSAAPROPID&	idProp,		// I:property requested
		VARIANT&			varValue,	// O:returned property value
		BOOL&				fGotProp);	// O:was a property returned?

	virtual SC ScInsertAccPropIDs (PropIDCollection& v);

private:
	// Accessibility stuff
	SC ScInitAccessibility ();
	SC ScRestoreAccFocus ();

	CComPtr<IAccPropServices>	m_spAccPropServices;
	CComPtr<IAccPropServer>		m_spAccPropServer;
	PropIDCollection			m_vPropIDs;
};


#include "controls.inl"

#endif //__CONTROLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\conuiptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       conuiptrs.h
//
//--------------------------------------------------------------------------

#pragma once
        
#ifndef CONUIPTRS_H
#define CONUIPTRS_H

#include <comptr.h>

DEFINE_CIP(_Application);
DEFINE_CIP(Document);
DEFINE_CIP(Views);
DEFINE_CIP(View);
DEFINE_CIP(SnapIns);
DEFINE_CIP(SnapIn);
DEFINE_CIP(ScopeNamespace);
DEFINE_CIP(Frame);
DEFINE_CIP(Nodes);
DEFINE_CIP(Node);
DEFINE_CIP(ContextMenu);
DEFINE_CIP(MenuItem);
DEFINE_CIP(ViewEvents);

#endif // CONUIPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\dd.h ===
#pragma once
#ifndef DD_H_INCLUDED
#define DD_H_INCLUDED

/*
    Classes participating in Drag-And-Drop:
        CMMCDropSource
            1.  Implements IDropSource interface and the created instance of this class
                is given to OLE for d&d operation
            2.  Implements static member ScDoDragDrop which creates the instance and starts d&d
                by calling OLE Api function
        CMMCDropTarget ( TiedComObject tied to CMMCViewDropTarget )
            Implements interface IDropTarget interface and the created instance of this class
            is given to OLE for d&d operation. Its instances are tied to CMMCViewDropTarget instance
            and it places the call to this class in respond to method invocations made by OLE
        CMMCViewDropTarget
            Adds d&d support to the view by creating the instance of CMMCDropTarget (TiedComObject)
            and registering it with OLE, responding to method calls made by that instance and invoking
            virtual methods on derived class to do the HitTest/Drop. 
            Registration in done by invoking protected method ScRegisterAsDropTarget.
            Target is revoke on destructor.
        CAMCTreeView
            Derives from CMMCViewDropTarget. Registers after window is created.
            Implements virtual methods to HitTest / Perform the Drop.
        CAMCListView
            Derives from CMMCViewDropTarget. Registers after window is created.
            Implements virtual methods to HitTest / Perform the Drop.
*/

/***************************************************************************\
 *
 * CLASS:  CMMCViewDropTarget
 *
 * PURPOSE: Defines common behavior for D&D-enabled view,
 *          Also defines the interface for HitTest function
 *
 * USAGE:   Derive your view from this class (CAMCListView and CAMCTreeView does)
 *          Implement virtual methods ScDropOnTarget and RemoveDropTargetHiliting in your class
 *          Add a call to ScRegisterAsDropTarget() after the window is created
 *
\***************************************************************************/
class CMMCViewDropTarget : public CTiedObject
{
protected: 
    
    // these methods should only be used by the derived class

    // construction - destruction
    CMMCViewDropTarget();
    ~CMMCViewDropTarget();

    // drop target registration
    SC ScRegisterAsDropTarget(HWND hWnd);

public:

    // interface methods the derived class must implement
    virtual SC   ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint pt, bool& bCopyOperation) = 0;
    virtual void RemoveDropTargetHiliting() = 0;


    // accessory used by tied com object to display the context menu
    HWND GetWindowHandle() { return m_hwndOwner; }

private:
    // implementation helper - creates tied com object
    SC ScCreateTarget(IDropTarget **ppTarget);

    IDropTargetPtr m_spTarget;  // tied com object
    HWND           m_hwndOwner; // window handle of the wiew
};

#endif DD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "..\inc\StdDbg.h"

#ifdef DBG
    DECLARE_DEBUG(AMCConUI)
    #define DBG_COMP    AMCConUIInfoLevel
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\conuiobservers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      conuiobservers.h
//
//  Contents:  Observer interface class definitions used by all conui.
//
//  History:   24-Nov-99 VivekJ  Created
//
//

#pragma once

class CAMCView;
class CAMCViewToolbars;
class CAMCDoc;

/*+-------------------------------------------------------------------------*
 * class CTreeViewObserver
 *
 *
 * PURPOSE: The general interface for a class that observes a scope tree
 *          control.
 *
 *+-------------------------------------------------------------------------*/
class CTreeViewObserver : public CObserverBase
{
public:
    virtual SC ScOnItemAdded     (TVINSERTSTRUCT *pTVInsertStruct, HTREEITEM hti, HMTNODE hMTNode)  {DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnItemDeleted   (HNODE hNode, HTREEITEM hti)                                       {DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnItemDeselected(HNODE hNode)                                                      {DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnSelectedItemTextChanged (LPCTSTR pszNewText)										{DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnTreeViewActivated ()										                        {DEFAULT_OBSERVER_METHOD;}
};


/*+-------------------------------------------------------------------------*
 * class CAMCViewObserver
 *
 *
 * PURPOSE: Interface for observers of CAMCView
 *
 *+-------------------------------------------------------------------------*/
class CAMCViewObserver : public CObserverBase
{
public:
    virtual SC  ScOnViewCreated     (CAMCView *pAMCView) {DEFAULT_OBSERVER_METHOD;} // called when a view is created.
    virtual SC  ScOnViewDestroyed   (CAMCView *pAMCView) {DEFAULT_OBSERVER_METHOD;} // called when a view is destroyed
    virtual SC  ScOnViewResized     (CAMCView *pAMCView, UINT nType, int cx, int cy) {DEFAULT_OBSERVER_METHOD;} // called when a view is resized
    virtual SC  ScOnViewTitleChanged(CAMCView *pAMCView) {DEFAULT_OBSERVER_METHOD;} // called when the view title changes.
    virtual SC  ScOnActivateView    (CAMCView *pAMCView, bool bFirstActiveView) {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
    virtual SC  ScOnDeactivateView  (CAMCView *pAMCView, bool bLastActiveView)  {DEFAULT_OBSERVER_METHOD;} // called when the view is de-activated.
    virtual SC  ScOnCloseView       (CAMCView *pView )  {DEFAULT_OBSERVER_METHOD;} // called before view is closed.
    virtual SC  ScOnViewChange      (CAMCView *pView, HNODE hNode )  {DEFAULT_OBSERVER_METHOD;} // called when scope node selection changes.
    virtual SC  ScOnResultSelectionChange(CAMCView *pView )  {DEFAULT_OBSERVER_METHOD;} // called when the result selection on view changes.
    virtual SC  ScOnListViewItemUpdated(CAMCView *pView , int nIndex)  {DEFAULT_OBSERVER_METHOD;} // called when a list view item is updated.
};

/*+-------------------------------------------------------------------------*
 * class CListViewObserver
 *
 *
 * PURPOSE: Interface for observers of CListView
 *
 *+-------------------------------------------------------------------------*/
class CListViewObserver : public CObserverBase
{
public:
    // observed events
    virtual SC ScOnListViewIndexesReset()              { DEFAULT_OBSERVER_METHOD } // called when result contents is removed or reordered (sort) so no indexes can be considered valid after it
    virtual SC ScOnListViewItemInserted(int nIndex)    { DEFAULT_OBSERVER_METHOD } // called when item is inserted to result data    
    virtual SC ScOnListViewItemDeleted (int nIndex)    { DEFAULT_OBSERVER_METHOD } // called when item is deleted from result data    
    virtual SC ScOnListViewColumnInserted (int nIndex) { DEFAULT_OBSERVER_METHOD } // called when column is inserted to listview    
    virtual SC ScOnListViewColumnDeleted (int nIndex)  { DEFAULT_OBSERVER_METHOD } // called when column is deleted from listview
    virtual SC ScOnListViewItemUpdated (int nIndex)    { DEFAULT_OBSERVER_METHOD } // called when an item is updated
};

//+-------------------------------------------------------------------
//
//  Class:      CAMCViewToolbarsObserver
//
//  Synopsis:   For any one to take note of active CAMCViewToolbars object
//              The main toolbar observes for which CAMCViewToolbar
//              is active so that that object can receive toolbutton
//              clicked & tooltip events.
//
//+-------------------------------------------------------------------
class CAMCViewToolbarsObserver : public CObserverBase
{
public:
    virtual SC  ScOnActivateAMCViewToolbars   (CAMCViewToolbars *pAMCViewToolbars) {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
    virtual SC  ScOnDeactivateAMCViewToolbars ()                                   {DEFAULT_OBSERVER_METHOD;} // called when the view is de-activated.
    virtual SC  ScOnToolbarButtonClicked      ()                                   {DEFAULT_OBSERVER_METHOD;} // called when the view is de-activated.
};

//+-------------------------------------------------------------------
//
//  Class:      CListViewActivationObserver
//
//  Synopsis:   For any one to observe when the CAMCListView being activated or deactivated.
//
//+-------------------------------------------------------------------
class CListViewActivationObserver : public CObserverBase
{
public:
    virtual SC  ScOnListViewActivated () {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
};


//+-------------------------------------------------------------------
//
//  Class:      COCXHostActivationObserver
//
//  Synopsis:   For any one to observe when the OCX or WEB host being activated or deactivated.
//
//+-------------------------------------------------------------------
class COCXHostActivationObserver : public CObserverBase
{
public:
    virtual SC  ScOnOCXHostActivated () {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
};

//+-------------------------------------------------------------------
//
//  Class:      CAMCDocumentObserver
//
//  Synopsis:   Observes the document object.
//
//+-------------------------------------------------------------------
class CAMCDocumentObserver : public CObserverBase
{
public:
    virtual SC  ScDocumentLoadCompleted (CAMCDoc *pDoc) {DEFAULT_OBSERVER_METHOD;} // called when the document is loaded.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\dd.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dd.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8/3/1997   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"


#include "AMCDoc.h"         // AMC Console Document
#include "amcview.h"
#include "TreeCtrl.h"
#include "cclvctl.h"
#include "amcpriv.h"
#include "mainfrm.h"
#include "rsltitem.h"
#include "conview.h"

/***************************************************************************\
 *
 * CLASS:  CMMCDropSource
 *
 * PURPOSE: Implements everything required for drop source:
 *          a) com object to register with OLE
 *          b) static method to perform drag&drop operation
 *
 * USAGE:   All you need is to invoke CMMCDropSource::ScDoDragDrop static method
 *
\***************************************************************************/
class CMMCDropSource :
public IDropSource,
public CComObjectRoot
{
public:

BEGIN_COM_MAP(CMMCDropSource)
    COM_INTERFACE_ENTRY(IDropSource)
END_COM_MAP()

    // IDropSource methods
    STDMETHOD(QueryContinueDrag)( BOOL fEscapePressed,  DWORD grfKeyState );
    STDMETHOD(GiveFeedback)( DWORD dwEffect );

    // method to perform D&D
    static SC ScDoDragDrop(IDataObject *pDataObject, bool bCopyAllowed, bool bMoveAllowed);
};

/***************************************************************************\
 *
 * CLASS:  CMMCDropTarget
 *
 * PURPOSE: Implements com object to be osed by OLE for drop target operations
 *
 * USAGE:   Used by CMMCViewDropTarget, which creates and registers it with OLE
 *          to be invoked on OLE D&D opeartions on the window (target)
 *
\***************************************************************************/
class CMMCDropTarget :
public CTiedComObject<CMMCViewDropTarget>,
public IDropTarget,
public CComObjectRoot
{
public:
    typedef CMMCViewDropTarget MyTiedObject;

BEGIN_COM_MAP(CMMCDropTarget)
    COM_INTERFACE_ENTRY(IDropTarget)
END_COM_MAP()

    // IDropTarget methods

    STDMETHOD(DragEnter)( IDataObject * pDataObject, DWORD grfKeyState,
                          POINTL pt, DWORD * pdwEffect );
    STDMETHOD(DragOver)( DWORD grfKeyState, POINTL pt, DWORD * pdwEffect );
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)( IDataObject * pDataObject, DWORD grfKeyState,
                     POINTL pt, DWORD * pdwEffect  );
private:

    // implementation helpers

    SC ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, POINTL pt, bool& bCopyOperation);
    SC ScRemoveDropTargetHiliting();
    static SC ScAddMenuString(CMenu& menu, DWORD id, UINT idString);
    SC ScDisplayDropMenu(POINTL pt, DWORD dwEffectsAvailable, DWORD& dwSelected);
    DWORD CalculateEffect(DWORD dwEffectsAvailable, DWORD grfKeyState, bool bCopyPreferred);

private:
    IDataObjectPtr m_spDataObject;      // cached data object
    bool           m_bRightDrag;        // operation is right click drag
    bool           m_bCopyByDefault;    // if default operation is copy (not move)
};

//////////////////////////////////////////////////////////////////////////////
////////// CAMCTreeView methods for supporting d&d ///////////////////////////
//////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::ScDropOnTarget
 *
 * PURPOSE: called to hittest or perform drop operation
 *
 * PARAMETERS:
 *    bool bHitTestOnly         [in] - HitTest / drop
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    CPoint point              [in] - current cursor position
 *    bool& bCopyOperation      [in/out]
 *                                 [in] -  operation to perform (HitTest == false)
 *                                 [out] - default op. (HitTest == true)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCTreeView::ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint point, bool& bCopyOperation)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScDropOnTarget"));

    // 1. see where it falls
    CTreeCtrl& ctc = GetTreeCtrl();
    UINT flags;
    HTREEITEM htiDrop = ctc.HitTest(point, &flags);

    if (flags & TVHT_NOWHERE)
        return sc = S_FALSE; // not an error, but no paste;

    // 2. if we missed the tree item...
    if (!htiDrop)
    {
        // really mad if it was a paste
        if (! bHitTestOnly)
            MessageBeep(0);

        return sc = S_FALSE; // not an error, but no paste;
    }

    // 3. get the target node

    HNODE hNode = (HNODE) ctc.GetItemData(htiDrop);

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
        return sc;

    // 4. ask what snapin thinks about this paste
    bool bGetDataObjectFromClipboard = false;
    bool bPasteAllowed = false;
    bool bIsCopyDefaultOperation = false;
    sc = pNC->QueryPaste(hNode, /*bScope*/ true, /*LVDATA*/ NULL,
                         pDataObject, bPasteAllowed, bIsCopyDefaultOperation);
    if (sc)
        return sc;

    if (!bPasteAllowed)
        return sc = S_FALSE; // not an error, but no paste;

    // 5. visual effect
    ctc.SelectDropTarget(htiDrop);

    // 6. OK so far. If it was a test - we passed
    if (bHitTestOnly)
    {
        bCopyOperation = bIsCopyDefaultOperation;
        return sc;
    }

    // 7. do paste NOW
    sc = pNC->Drop(hNode, /*bScope*/TRUE, /*LVDATA*/NULL, pDataObject, !bCopyOperation);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::RemoveDropTargetHiliting
 *
 * PURPOSE: called to remove hiliting put for drop target
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCTreeView::RemoveDropTargetHiliting()
{
    CTreeCtrl& ctc = GetTreeCtrl();
    ctc.SelectDropTarget(NULL);
}

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::OnBeginRDrag
 *
 * PURPOSE: called when the drag operation is initiated with right mouse button
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCTreeView::OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    OnBeginDrag(pNMHDR, pResult);
}

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::OnBeginDrag
 *
 * PURPOSE: called when the drag operation is initiated with
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CAMCTreeView::OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnBeginDrag"));

    // 1. parameter check
    sc = ScCheckPointers( pNMHDR, pResult );
    if (sc)
        return;

    *pResult = 0;

    // 2. get node calback
    CTreeCtrl& ctc = GetTreeCtrl();
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    HNODE hNode = (HNODE) ctc.GetItemData(pNMTreeView->itemNew.hItem);

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers( pNC, E_UNEXPECTED );
    if (sc)
        return;

    // 3. get data object
    IDataObjectPtr spDO;
    bool bCopyAllowed = false;
    bool bMoveAllowed = false;
    sc = pNC->GetDragDropDataObject(hNode, TRUE, 0, 0, &spDO, bCopyAllowed, bMoveAllowed);
    if ( sc != S_OK || spDO == NULL)
        return;

    // 4. start d&d
    sc = CMMCDropSource::ScDoDragDrop(spDO, bCopyAllowed, bMoveAllowed);
    if (sc)
        return;
}

//////////////////////////////////////////////////////////////////////////////
////////// CAMCListView methods for supporting d&d ///////////////////////////
//////////////////////////////////////////////////////////////////////////////

// helpers

INodeCallback* CAMCListView::GetNodeCallback()
{
    ASSERT (m_pAMCView != NULL);
    return (m_pAMCView->GetNodeCallback());
}

HNODE CAMCListView::GetScopePaneSelNode()
{
    ASSERT (m_pAMCView != NULL);
    return (m_pAMCView->GetSelectedNode());
}

/***************************************************************************\
 *
 * METHOD:  CAMCListView::ScDropOnTarget
 *
 * PURPOSE: called to hittest or perform drop operation
 *
 * PARAMETERS:
 *    bool bHitTestOnly         [in] - HitTest / drop
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    CPoint point              [in] - current cursor position
 *    bool& bCopyOperation      [in/out]
 *                                 [in] -  operation to perform (HitTest == false)
 *                                 [out] - default op. (HitTest == true)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCListView::ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint point, bool& bCopyOperation)
{
    DECLARE_SC(sc, TEXT("CAMCListView::ScDropOnTarget"));

    // 1. sanity check
    sc = ScCheckPointers( m_pAMCView , E_UNEXPECTED );
    if (sc)
        return sc;

    // 2. see if view does not have a paste tabu (listpads do)
    if (!m_pAMCView->CanDoDragDrop())
        return sc = (bHitTestOnly ? S_FALSE : E_FAIL); // not an error if testing

    // 3. HitTest the target
    HNODE  hNode  = NULL;
    bool   bScope = false;
    LPARAM lvData = NULL;
    int    iDrop  = -1;

    sc = ScGetDropTarget(point, hNode, bScope, lvData, iDrop);
    if (sc.IsError() || (sc == SC(S_FALSE)))
        return sc;

    // 4. get the callback
    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
        return sc;

    // 5. ask what snapin thinks about this paste
    const bool bGetDataObjectFromClipboard = false;
    bool bPasteAllowed = false;
    bool bIsCopyDefaultOperation = false;
    sc = pNC->QueryPaste(hNode, bScope, lvData,
                         pDataObject, bPasteAllowed, bIsCopyDefaultOperation);
    if (sc)
        return sc;

    if (!bPasteAllowed)
        return sc = S_FALSE; // not an error, but no paste;

    // 6. visual effect
    SelectDropTarget(iDrop);

    // 7. OK so far. If it was a test - we passed
    if (bHitTestOnly)
    {
        bCopyOperation = bIsCopyDefaultOperation;
        return sc;
    }

    // 8. do paste NOW
    sc = pNC->Drop(hNode, bScope, lvData, pDataObject, !bCopyOperation);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCListView::RemoveDropTargetHiliting
 *
 * PURPOSE: called to remove target hiliting
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCListView::RemoveDropTargetHiliting()
{
    SelectDropTarget(-1);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScGetDropTarget
//
//  Synopsis:    Get the drop target item (result item or scope item).
//
//  Arguments:   [point]  - where the drop is done.
//               [hNode]  - Owner node of result pane.
//               [bScope] - scope or result selected.
//               [lvData] - If result the LPARAM of result item.
//               [iDrop]  - index of the lv item that is drop target.
//
//  Returns:     SC, S_FALSE means no drop target item.
//
//--------------------------------------------------------------------
SC CAMCListView::ScGetDropTarget(const CPoint& point, HNODE& hNode, bool& bScope, LPARAM& lvData, int& iDrop)
{
    DECLARE_SC(sc, _T("CAMCListView::ScGetDropTarget"));

    hNode = NULL;
    bScope = false;
    lvData = NULL;
    iDrop  = -1;

    CListCtrl& lc = GetListCtrl();
    UINT flags;
    iDrop = lc.HitTest(point, &flags);

    // background is drop target.
    if (iDrop < 0)
    {
        hNode = GetScopePaneSelNode();
        bScope = true;
        return sc;
    }

    // Need to change this to LVIS_DROPHILITED.
    if (lc.GetItemState(iDrop, LVIS_SELECTED) & LVIS_SELECTED)
    {
        HWND hWnd = ::GetForegroundWindow();
        if (hWnd && (hWnd == m_hWnd))
            return (sc = S_FALSE);
    }

	/*
	 * virtual list?  lvData is the item index, hNode is the item selected
	 * in the scope pane
	 */
	if (m_bVirtual)
	{
		hNode  = GetScopePaneSelNode();
		lvData = iDrop;
		bScope = false;
	}
	else
	{
		LPARAM  lParam = lc.GetItemData(iDrop);
		ASSERT (lParam != 0);
		if (lParam == 0)
			return (sc = S_FALSE);

		CResultItem* pri = CResultItem::FromHandle(lParam);

		if (pri == NULL)
			return (sc = S_FALSE);

		if (pri->IsScopeItem())
		{
			hNode = pri->GetScopeNode();
			bScope = true;
		}
		else
		{
			hNode = GetScopePaneSelNode();
			lvData = lParam;
		}
	}

    sc = ScCheckPointers(hNode, E_UNEXPECTED);
    if (sc)
        return sc;

    return (sc);
}


/***************************************************************************\
 *
 * METHOD:  CAMCListView::OnBeginRDrag
 *
 * PURPOSE: called when the drag operation is initiated with right mouse button
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCListView::OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    OnBeginDrag(pNMHDR, pResult);
}

/***************************************************************************\
 *
 * METHOD:  CAMCListView::OnBeginDrag
 *
 * PURPOSE: called when the drag operation is initiated
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCListView::OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCListView::OnBeginDrag"));

    // 1. parameter check
    sc = ScCheckPointers( pNMHDR, pResult );
    if (sc)
        return;

    *pResult = 0;

    // 2. sanity check
    sc = ScCheckPointers( m_pAMCView, E_UNEXPECTED );
    if (sc)
        return;

    // 3. see if view does not have a paste tabu (listpads do)
    if (!m_pAMCView->CanDoDragDrop())
        return;

    // 4. get selected items
    CListCtrl& lc = GetListCtrl();
    UINT cSel = lc.GetSelectedCount();
    if (cSel <= 0)
    {
        sc = E_UNEXPECTED;
        return;
    }

    // 5. get node callback
    HNODE hNode = GetScopePaneSelNode();
    long iSel = lc.GetNextItem(-1, LVIS_SELECTED);
    LONG_PTR lvData = m_bVirtual ? iSel : lc.GetItemData(iSel);

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers( pNC, E_UNEXPECTED );
    if (sc)
        return;

    // 6. retrieve data object
    IDataObjectPtr spDO;
    bool bCopyAllowed = false;
    bool bMoveAllowed = false;
    sc = pNC->GetDragDropDataObject(hNode, FALSE, (cSel > 1), lvData, &spDO, bCopyAllowed, bMoveAllowed);
    if ( sc != S_OK || spDO == NULL)
	{
		/*
		 * Problem: 
		 * If snapin does not return dataobject then drag & drop is not possible.
		 * Assume focus in on tree, user downclick's and drags a result item
		 * At this time common control sends LVN_ITEMCHANGED to mmc. MMC translates
		 * this to MMCN_SELECT and tells snapin that result item is selected.
		 * Now when user releases the mouse the tree item still has focus & selection,
		 * but the snapin thinks result item is selected (also verbs correspond to 
		 * result item). 
		 *
		 * Solution:
		 * So we will set focus to the result pane.
		 */
		sc = m_pAMCView->ScSetFocusToPane(CConsoleView::ePane_Results);
        return;
	}

    // 7. do d&d
    sc = CMMCDropSource::ScDoDragDrop(spDO, bCopyAllowed, bMoveAllowed);
    if (sc)
        return;

	/*
	 * Problem:
	 * If a result item is dropped into another result item or another
	 * scope item in list-view then focus disappears from that item.
	 * But there should be always an item selected after any de-select. 
	 * We cannot change the focus to result pane because if focus is already
	 * in result pane, this change focus does nothing and no item is selected.
	 * So we change the focus to scope pane. For this we first change the focus
	 * to result pane and then to scope pane. Because if tree already has focus, 
	 * setting focus to tree does nothing (CAMCView::ScOnTreeViewActivated).
	 *
	 * Solution:
	 * So we change the focus to result pane and then to scope pane.
	 */
	sc = m_pAMCView->ScSetFocusToPane(CConsoleView::ePane_Results);
	if (sc)
		return;

	sc = m_pAMCView->ScSetFocusToPane(CConsoleView::ePane_ScopeTree);
	if (sc)
		return;

	return;
}

//////////////////////////////////////////////////////////////////////////////
///////////////////// CMMCViewDropTarget methods /////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::CMMCViewDropTarget
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCViewDropTarget::CMMCViewDropTarget() : m_hwndOwner(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::~CMMCViewDropTarget
 *
 * PURPOSE: destructor. Revokes drop target for derived view class
 *
\***************************************************************************/
CMMCViewDropTarget::~CMMCViewDropTarget()
{
    DECLARE_SC(sc, TEXT("CViewDropTarget::~CViewDropTarget"));

    if (m_hwndOwner != NULL)
        sc = RevokeDragDrop(m_hwndOwner);
}

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::ScRegisterAsDropTarget
 *
 * PURPOSE: This method is called by the derived class after the view window
 *          is created. Method registers the drop target for the window.
 *
 * PARAMETERS:
 *    HWND hWnd [in] - drop target view handle
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCViewDropTarget::ScRegisterAsDropTarget(HWND hWnd)
{
    DECLARE_SC(sc, TEXT("CMMCViewDropTarget::ScRegister"));

    // 1. parameter check
    if (hWnd == NULL)
        return sc = E_INVALIDARG;

    // 2. sanity check - should not come here twice
    if (m_spTarget != NULL)
        return sc = E_UNEXPECTED;

    // 3. create a drop target com object
    IDropTargetPtr spTarget;
    sc = ScCreateTarget(&spTarget);
    if (sc)
        return sc;

    // 4. recheck
    sc = ScCheckPointers(spTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 5. register with OLE
    sc = RegisterDragDrop(hWnd, spTarget);
    if (sc)
        return sc;

    // 6. store info into members
    m_spTarget.Attach( spTarget.Detach() );
    m_hwndOwner = hWnd;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::ScCreateTarget
 *
 * PURPOSE: helper. creates tied com object to regiter with OLE
 *
 * PARAMETERS:
 *    IDropTarget **ppTarget [out] tied com object
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCViewDropTarget::ScCreateTarget(IDropTarget **ppTarget)
{
    DECLARE_SC(sc, TEXT("CMMCViewDropTarget::ScCreateTarget"));

    // 1. check parameters
    sc = ScCheckPointers(ppTarget);
    if (sc)
        return sc;

    // 2. init out parameter
    *ppTarget = NULL;

    // 3. create com object to register as target
    IDropTargetPtr spDropTarget;
    sc = CTiedComObjectCreator<CMMCDropTarget>::ScCreateAndConnect(*this, spDropTarget);
    if (sc)
        return sc;

    sc = ScCheckPointers(spDropTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 4. pass reference to client
    *ppTarget = spDropTarget.Detach();

    return sc;
}

/*---------------------------------------------------------------------------*\
|                   class CMMCDropSource methods                              |
\*---------------------------------------------------------------------------*/

/***************************************************************************\
 *
 * METHOD:  CMMCDropSource::QueryContinueDrag
 *
 * PURPOSE: implements IDropSource::QueryContinueDrag interface used bu OLE
 *
 * PARAMETERS:
 *    BOOL fEscapePressed   [in] - ESC was pressed
 *    DWORD grfKeyState     [in] - mouse & control button state
 *
 * RETURNS:
 *    HRESULT  - error or  S_OK(continue), DRAGDROP_S_CANCEL(cancel), DRAGDROP_S_DROP(drop)
 *
\***************************************************************************/
STDMETHODIMP CMMCDropSource::QueryContinueDrag( BOOL fEscapePressed,  DWORD grfKeyState )
{
    DECLARE_SC(sc, TEXT("CMMCDropSource::QueryContinueDrag"));

    // 1. quit on cancel
    if (fEscapePressed)
        return (sc = DRAGDROP_S_CANCEL).ToHr();

    // 2. inspect mouse buttons
    DWORD mButtons = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON) );
    if ( mButtons == 0 ) // all released?
        return (sc = DRAGDROP_S_DROP).ToHr();

    // 3. quit also if more than one mouse button is pressed
    if ( mButtons != MK_LBUTTON && mButtons != MK_RBUTTON && mButtons != MK_MBUTTON )
        return (sc = DRAGDROP_S_CANCEL).ToHr();

    // 4. else just continue ...

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropSource::GiveFeedback
 *
 * PURPOSE: Gives feedback for d&d operations
 *
 * PARAMETERS:
 *    DWORD dwEffect
 *
 * RETURNS:
 *    DRAGDROP_S_USEDEFAULTCURSORS
 *
\***************************************************************************/
STDMETHODIMP CMMCDropSource::GiveFeedback( DWORD dwEffect )
{
    // nothing special by now
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropSource::ScDoDragDrop
 *
 * PURPOSE: Performs DragAndDrop operation
 *          This is static method to be used to initiate drag and drop
 *
 * PARAMETERS:
 *    IDataObject *pDataObject [in] data object to copy/move
 *    bool bCopyAllowed        [in] if copy is allowed
 *    bool bMoveAllowed        [in] if move is allowed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropSource::ScDoDragDrop(IDataObject *pDataObject, bool bCopyAllowed, bool bMoveAllowed)
{
    DECLARE_SC(sc, TEXT("CMMCDropSource::ScDoDragDrop"));

    // 1. cocreate com object for OLE
    typedef CComObject<CMMCDropSource> ComCMMCDropSource;
    ComCMMCDropSource *pSource;
    sc = ComCMMCDropSource::CreateInstance(&pSource);
    if (sc)
        return sc;

    // 2. recheck
    sc = ScCheckPointers(pSource, E_UNEXPECTED);
    if (sc)
        return sc;

    // 3. QI for IDropSource interface
    IDropSourcePtr spDropSource = pSource;
    sc = ScCheckPointers(spDropSource, E_UNEXPECTED);
    if (sc)
    {
        delete pSource;
        return sc;
    }

    // 4. perform DragDrop
    DWORD dwEffect = DROPEFFECT_NONE;
    const DWORD dwEffectAvailable = (bCopyAllowed ? DROPEFFECT_COPY : 0)
                                   |(bMoveAllowed ? DROPEFFECT_MOVE : 0);
    sc = DoDragDrop(pDataObject, spDropSource, dwEffectAvailable, &dwEffect);
    if (sc)
        return sc;

    return sc;
}

/*---------------------------------------------------------------------------*\
|                   class CMMCDropTarget methods                              |
\*---------------------------------------------------------------------------*/

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::DragEnter
 *
 * PURPOSE: Invoked by OLE when d&d cursor enters the window for which
 *          this target was registered.
 *
 * PARAMETERS:
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    DWORD grfKeyState         [in] - current key state
 *    POINTL pt                 [in] - current cursor position
 *    DWORD * pdwEffect         [out] - operations supported
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::DragEnter( IDataObject * pDataObject, DWORD grfKeyState,
                                        POINTL pt, DWORD * pdwEffect )
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::DragEnter"));

    // 1. cache for drag over
    m_spDataObject = pDataObject;

    // 2. parameter check
    sc = ScCheckPointers(pDataObject, pdwEffect);
    if (sc)
        return sc.ToHr();

    // 3. let it happen - will do more exact filtering on DragOver
    *pdwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::DragOver
 *
 * PURPOSE: called continuosly while cursor is drgged over the window
 *
 * PARAMETERS:
 *    DWORD grfKeyState         [in] - current key state
 *    POINTL pt                 [in] - current cursor position
 *    DWORD * pdwEffect         [out] - operations supported
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::DragOver( DWORD grfKeyState, POINTL pt, DWORD * pdwEffect )
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::DragOver"));

    // 1. parameter check
    sc = ScCheckPointers(pdwEffect);
    if (sc)
        return sc.ToHr();

    // 2. sanity check
    sc = ScCheckPointers(m_spDataObject, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    bool bCopyByDefault = false; // initially we are to move

    // 3. ask the view to estimate what can be done in this position
    sc = ScDropOnTarget( true /*bHitTestOnly*/, m_spDataObject, pt, bCopyByDefault );
    if ( sc == S_OK )
        *pdwEffect = CalculateEffect( *pdwEffect, grfKeyState, bCopyByDefault );
    else
        *pdwEffect = DROPEFFECT_NONE; // no-op on failure or S_FALSE

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::DragLeave
 *
 * PURPOSE: called when cursor leave the window
 *
 * PARAMETERS:
 *    void
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::DragLeave(void)
{
    DECLARE_SC(sc, TEXT("DragLeave"));

    // 1. release data object
    m_spDataObject = NULL;

    // 2. ask the view to remove hiliting it put on target
    sc = ScRemoveDropTargetHiliting();
    if (sc)
        sc.TraceAndClear();

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::Drop
 *
 * PURPOSE: Called when data is dropped on target
 *
 * PARAMETERS:
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    DWORD grfKeyState         [in] - current key state
 *    POINTL pt                 [in] - current cursor position
 *    DWORD * pdwEffect         [out] - operation performed
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::Drop( IDataObject * pDataObject, DWORD grfKeyState,
                                   POINTL pt, DWORD * pdwEffect  )
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::DragEnter"));

    // 1. release in case we have anything
    m_spDataObject = NULL;

    // 2. parameter check
    sc = ScCheckPointers(pDataObject, pdwEffect);
    if (sc)
        return sc.ToHr();

    // 3. init operation with cached value
    bool bCopyOperation = m_bCopyByDefault;

    // 4. see what operation to perform
    if (m_bRightDrag)
    {
        // 4.1. give user the choice
        DWORD dwSelected = ( m_bCopyByDefault ? DROPEFFECT_COPY : DROPEFFECT_MOVE );
        sc = ScDisplayDropMenu( pt, *pdwEffect, dwSelected );
        if (sc)
            return sc.ToHr();

        *pdwEffect = dwSelected;
    }
    else
    {
        // 4.2. inspect keyboard
        *pdwEffect = CalculateEffect(*pdwEffect, grfKeyState, bCopyOperation);
    }

    // 5. perform
    if (*pdwEffect != DROPEFFECT_NONE) // not canceled yet?
    {
        // now the final decision - copy or move
        bCopyOperation = ( *pdwEffect & DROPEFFECT_COPY );

        // Let it happen. Drop.
        sc = ScDropOnTarget( false /*bHitTestOnly*/, pDataObject, pt, bCopyOperation );
        if ( sc != S_OK )
            *pdwEffect = DROPEFFECT_NONE;
    }

    // 6. remove hiliting. reuse DragLeave (don't care about the results)
    DragLeave();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScDropOnTarget
 *
 * PURPOSE: helper, forwarding calls to the view
 *          Called as a request to hittest / perform drop operation
 *
 * PARAMETERS:
 *    bool bHitTestOnly         [in] - HitTest / drop
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    POINTL pt                 [in] - current cursor position
 *    bool& bCopyOperation      [in/out]
 *                                 [in] -  operation to perform (HitTest == false)
 *                                 [out] - default op. (HitTest == true)
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, POINTL pt, bool& bCopyOperation)
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScDropOnTarget"));

    // 1. get tied object - view
    CMMCViewDropTarget *pTarget = NULL;
    sc = ScGetTiedObject(pTarget);
    if (sc)
        return sc;

    // 2. recheck
    sc = ScCheckPointers(pTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 3. calculate client coordinates
    CPoint point(pt.x, pt.y);
    ScreenToClient(pTarget->GetWindowHandle(), &point);

    // 4. forward to the view
    sc = pTarget->ScDropOnTarget( bHitTestOnly, pDataObject, point, bCopyOperation );
    if ( sc != S_OK )
        ScRemoveDropTargetHiliting(); // remove hiliting if missed the traget
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScRemoveDropTargetHiliting
 *
 * PURPOSE: helper, forwarding calls to the view
 *          Called to cancel visual effects on target
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScRemoveDropTargetHiliting()
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScRemoveDropTargetHiliting"));

    // `. get tied object - view
    CMMCViewDropTarget *pTarget = NULL;
    sc = ScGetTiedObject(pTarget);
    if (sc)
        return sc;

    sc = ScCheckPointers(pTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 2. forward to the view
    pTarget->RemoveDropTargetHiliting();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScAddMenuString
 *
 * PURPOSE: Helper. Adds resource string to paste context menu
 *
 * PARAMETERS:
 *    CMenu& menu   [in] - menu to modify
 *    DWORD id      [in] - menu command
 *    UINT idString [in] - id of resource string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScAddMenuString(CMenu& menu, DWORD id, UINT idString)
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScAddMenuString"));

    // 1. load the string
    CString strItem;
    bool bOK = LoadString( strItem, idString );
    if ( !bOK )
        return sc = E_FAIL;

    // 2. add to the menu
    bOK = menu.AppendMenu( MF_STRING, id, strItem );
    if ( !bOK )
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScDisplayDropMenu
 *
 * PURPOSE: Helper. Displays paste context menu
 *
 * PARAMETERS:
 *    POINTL pt                 [in] - point where the menu should appear
 *    DWORD dwEffectsAvailable  [in] - available commands
 *    DWORD& dwSelected         [in] - selected command
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScDisplayDropMenu(POINTL pt, DWORD dwEffectsAvailable, DWORD& dwSelected)
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScDisplayDropMenu"));

    CMenu menu;

    // 0. create the menu
    bool bOK = menu.CreatePopupMenu();
    if ( !bOK )
        return sc = E_FAIL;

    // 1. add choice for copy
    if ( dwEffectsAvailable & DROPEFFECT_COPY )
    {
        sc = ScAddMenuString(menu, DROPEFFECT_COPY, IDS_DragDrop_CopyHere);
        if (sc)
            return sc;
    }

    // 2. add choice for move
    if ( dwEffectsAvailable & DROPEFFECT_MOVE )
    {
        sc = ScAddMenuString(menu, DROPEFFECT_MOVE, IDS_DragDrop_MoveHere);
        if (sc)
            return sc;
    }

    // 3. add separator if copy or paste was added
    if ( dwEffectsAvailable & ( DROPEFFECT_COPY | DROPEFFECT_MOVE ) )
    {
        bool bOK = menu.AppendMenu( MF_SEPARATOR );
        if ( !bOK )
            return sc = E_FAIL;
    }

    // 4. always add choice for cancel
    sc = ScAddMenuString(menu, DROPEFFECT_NONE, IDS_DragDrop_Cancel);
    if (sc)
        return sc;

    // 5. set the default item
    if ( dwSelected != DROPEFFECT_NONE )
    {
        bool bOK = menu.SetDefaultItem( dwSelected );
        if ( !bOK )
            return sc = E_FAIL;
    }

    // 6. find the tied object
    CMMCViewDropTarget *pTarget = NULL;
    sc = ScGetTiedObject(pTarget);
    if (sc)
        return sc;

    sc = ScCheckPointers(pTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 7. display the menu
    dwSelected = menu.TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
                                     pt.x, pt.y, CWnd::FromHandlePermanent( pTarget->GetWindowHandle() ) );

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::CalculateEffect
 *
 * PURPOSE: Helper. calculates drop effect by combining:
 *          a) available operations
 *          b) the default operation
 *          c) keyboard key combination
 *
 * PARAMETERS:
 *    DWORD dwEffectsAvailable [in] available operations
 *    DWORD grfKeyState        [in] keyboard / mouse state
 *    bool  bCopyPreferred      [in] default operation
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
DWORD CMMCDropTarget::CalculateEffect(DWORD dwEffectsAvailable, DWORD grfKeyState, bool bCopyPreferred)
{
    const bool bShiftPressed =   (grfKeyState & MK_SHIFT);
    const bool bControlPressed = (grfKeyState & MK_CONTROL);
    const bool bRightClickDrag  = (grfKeyState & MK_RBUTTON);

    m_bRightDrag = bRightClickDrag;
    m_bCopyByDefault = bCopyPreferred;

    if (!bRightClickDrag) // affected by keyboard only in non-right-drag
    {
        // do nothing if user holds on shift+control
        if ( bShiftPressed && bControlPressed )
            return DROPEFFECT_NONE;

        // modify by user interactive preferences
        if ( bShiftPressed )
        {
            // if user cannot get what he wants to - indicate it
            if ( !(dwEffectsAvailable & DROPEFFECT_MOVE) )
                return DROPEFFECT_NONE;

            bCopyPreferred = false;
        }
        else if ( bControlPressed )
        {
            // if user cannot get what he wants to - indicate it
            if ( !(dwEffectsAvailable & DROPEFFECT_COPY) )
                return DROPEFFECT_NONE;

            bCopyPreferred = true;
        }
    }

    // return preferred, if available
    if ( bCopyPreferred && (dwEffectsAvailable & DROPEFFECT_COPY) )
        return DROPEFFECT_COPY;

    if ( !bCopyPreferred && (dwEffectsAvailable & DROPEFFECT_MOVE) )
        return DROPEFFECT_MOVE;

    // preferred not available - return what is available

    if ( dwEffectsAvailable & DROPEFFECT_COPY )
    {
        m_bCopyByDefault = true;
        return DROPEFFECT_COPY;
    }
    else if ( dwEffectsAvailable & DROPEFFECT_MOVE )
    {
        m_bCopyByDefault = false;
        return DROPEFFECT_MOVE;
    }

    return DROPEFFECT_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\docksite.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       docksite.cpp
//
//--------------------------------------------------------------------------

// DockSite.cpp : implementation file
//

#include "stdafx.h"
#include "amc.h"
#include "DockSite.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "commctrl.h"


/////////////////////////////////////////////////////////////////////////////
// CDockSite

CDockSite::CDockSite() : m_rect(0, 0, 0, 0)
{
    m_pManagedWindows = NULL;
    m_style = DSS_TOP;
    m_bVisible = FALSE;
}

BOOL CDockSite::Create(DSS_STYLE style)
{
    // Not supported
    ASSERT(style != DSS_LEFT && style != DSS__RIGHT);

    m_pManagedWindows = new CList<CDockWindow*, CDockWindow*>;
    m_style = style;

    return TRUE;
}


CDockSite::~CDockSite()
{
    delete m_pManagedWindows;
}

/////////////////////////////////////////////////////////////////////////////
// Operations

BOOL CDockSite::Attach(CDockWindow* pWnd)
{
    ASSERT(pWnd != NULL);
    m_pManagedWindows->AddTail(pWnd);

    return TRUE;
}


BOOL CDockSite::Detach(CDockWindow* pWnd)
{
    ASSERT(pWnd != NULL);
    return TRUE;
}

void CDockSite::Show(BOOL bState)
{
    // insure its 0 or 1
    BOOL b = (bState & 0x1);

    ASSERT(m_pManagedWindows != NULL);

    if (b == m_bVisible || m_pManagedWindows == NULL)
        return ;

    m_bVisible = b;


    POSITION pos;
    CDockWindow* pWindow;

    pos = m_pManagedWindows->GetHeadPosition();

    while(pos)
    {
        pWindow = m_pManagedWindows->GetNext(pos);

        if (pWindow != NULL)
            pWindow->Show(b);
    }
}

void CDockSite::RenderLayout(HDWP& hdwp, CRect& clientRect, CPoint& xyLocation)
{
    // No support for other styles
    ASSERT(m_style == DSS_TOP || m_style == DSS_BOTTOM);
    ASSERT(hdwp != 0);

    CRect siteRect(0,0,0,0);
    CRect controlRect(0,0,0,0);

    CDockWindow* pWindow;

    if (m_bVisible == TRUE)
    {

        POSITION pos;
        pos = m_pManagedWindows->GetHeadPosition();

        // Default point for the DSS_TOP
        int x = 0, y = xyLocation.y;

        while (pos)
        {
            pWindow = m_pManagedWindows->GetNext(pos);

            if ((pWindow != NULL) && pWindow->IsVisible ())
            {
                // Compute the size of the dockwindow rect
                controlRect = pWindow->CalculateSize(clientRect);

                siteRect += controlRect;
                if (m_style == DSS_BOTTOM)
                    y = xyLocation.y - siteRect.Height();

                DeferWindowPos(hdwp, pWindow->m_hWnd, NULL , x, y,
                               clientRect.Width(), controlRect.Height(),
                               SWP_NOZORDER|SWP_NOACTIVATE);

                if (m_style == DSS_TOP)
                    y += siteRect.Height();

            }
        }
    }

    clientRect.bottom -= siteRect.Height();
}

/////////////////////////////////////////////////////////////////////////////
// CDockWindow

IMPLEMENT_DYNAMIC(CDockWindow, CWnd)

CDockWindow::CDockWindow()
{
    m_bVisible = FALSE;
}

CDockWindow::~CDockWindow()
{
}

void CDockWindow::Show(BOOL bState)
{
    bool state = (bState != FALSE);

    if (state != IsVisible())
    {
        SetVisible(state);
        ShowWindow(state ? SW_SHOWNORMAL : SW_HIDE);
    }
}

BEGIN_MESSAGE_MAP(CDockWindow, CWnd)
    //{{AFX_MSG_MAP(CDockWindow)
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

LRESULT CDockWindow::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    ASSERT_VALID(this);

    LRESULT lResult;
    switch (message)
    {
    case WM_NOTIFY:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_DELETEITEM:
    case WM_COMPAREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        // send these messages to the owner if not handled
        if (OnWndMsg(message, wParam, lParam, &lResult))
            return lResult;
        else
            return GetOwner()->SendMessage(message, wParam, lParam);
        break;

    case WM_COMMAND:
        if (OnWndMsg(message, wParam, lParam, &lResult))
            return lResult;
        else
        {
            CRebarDockWindow* pRebar = dynamic_cast<CRebarDockWindow*>(this);
            ASSERT(NULL != pRebar);
            if (pRebar)
            {
                // In case of tool-button click, send this message to
                // the owner (the toolbar).
                return pRebar->GetRebar()->SendMessage(message, wParam, lParam);
            }
            else
            {
                // We want to know when this code is hit. Below is a
                // benign assert for this purpose.
                ASSERT(FALSE);

                // send these messages to the owner if there is no rebar.
                return GetOwner()->SendMessage(message, wParam, lParam);
            }
        }
        break;

    }

    // otherwise, just handle in default way
    lResult = CWnd::WindowProc(message, wParam, lParam);
    return lResult;


}


/////////////////////////////////////////////////////////////////////////////
// CDockWindow message handlers

void CDockWindow::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CWnd::OnShowWindow(bShow, nStatus);

    // keep our visibility flag in sync with the true visibility state of the window
    m_bVisible = bShow;
}


/////////////////////////////////////////////////////////////////////////////
// CStatBar

IMPLEMENT_DYNAMIC(CStatBar, CDockWindow)

CStatBar::CStatBar()
{
    m_nCount = 10;
    m_pPaneInfo = new STATUSBARPANE[10] ;
}

CStatBar::~CStatBar()
{
    delete [] m_pPaneInfo;
}


#define USE_CCS_NORESIZE    0

CRect CStatBar::CalculateSize(CRect maxRect)
{
    // default rect is 0,0 for hidden windows
    CRect rect(0,0,0,0);

    if (IsVisible())
    {
#if USE_CCS_NORESIZE
        CClientDC dc(this);
        CFont* pOldFont = dc.SelectObject(GetFont());
        TEXTMETRIC tm;

        // Compute the height for the status bar based on the font it is using
        // Note: tm.tmInternalLeading is added for spacing
        dc.GetTextMetrics(&tm);
        //rect.SetRect(0, 0,maxRect.Width(), tm.tmHeight+tm.tmInternalLeading);
        rect.SetRect(0, 0,50, tm.tmHeight+tm.tmInternalLeading);
        dc.SelectFont (pOldFont);
#else
        /*
         * Bug 188319: if we let the status bar handle its own sizing
         * (~CCS_NORESIZE), we can just use the client rect here
         */
        GetClientRect (rect);
#endif
    }

    return rect;
};

void CStatBar::GetItemRect(int nIndex, LPRECT lpRect)
{
    SendMessage(SB_GETRECT, (WPARAM)nIndex, (LPARAM)lpRect);
}

void CStatBar::SetPaneStyle(int nIndex, UINT nStyle)
{
    ASSERT(nIndex >=0 && nIndex < m_nCount);
    ASSERT(m_pPaneInfo != NULL);

    m_pPaneInfo[nIndex].m_style = nStyle;
    SendMessage(SB_SETTEXT, (WPARAM)(nIndex | nStyle), (LPARAM)((LPCTSTR)m_pPaneInfo[nIndex].m_paneText));
}

void CStatBar::SetPaneText(int nIndex, LPCTSTR lpszText, BOOL bUpdate)
{
    m_pPaneInfo[nIndex].m_paneText = lpszText;
    SetPaneStyle(nIndex, m_pPaneInfo[nIndex].m_style);

    if (bUpdate == TRUE)
    {
        CRect rect;
        GetItemRect(nIndex, &rect);
        InvalidateRect(rect, TRUE);
    }
}


BEGIN_MESSAGE_MAP(CStatBar, CDockWindow)
    //{{AFX_MSG_MAP(CStatBar)
    ON_WM_SIZE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CStatBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
    ASSERT_VALID(pParentWnd);   // must have a parent


    /*
     * Bug 188319: let the status bar handle its own sizing (~CCS_NORESIZE)
     */
    dwStyle |=  WS_CLIPSIBLINGS
                | CCS_NOPARENTALIGN
                | CCS_NOMOVEY
#if USE_CCS_NORESIZE
                | CCS_NORESIZE
#endif
                | CCS_NODIVIDER;


    // create status window
    CRect rect(0,0,0,0);
    CWnd::Create(STATUSCLASSNAME, _T("Ready"), dwStyle, rect, pParentWnd, nID);

    return TRUE;
}

BOOL CStatBar::CreatePanes(UINT* pIndicatorArray, int nCount)
{
    ASSERT(nCount <= 10);        // Note: No realloc implemented.  If needed, do it.
    UINT array[10] = {0};
    int nTotal = 0;

    CClientDC dc(this);

    // Default to 1 pane the full width of the status bar
    if (pIndicatorArray == NULL)
        m_nCount = 1;

    m_nCount = nCount;


    for (int i = 0; i < m_nCount; i++)
    {
        // Load the string from the resource and determine its width
        CString s;
        CSize sz;

        if (pIndicatorArray[i] != ID_SEPARATOR)
        {
            LoadString(s, pIndicatorArray[i]);
            GetTextExtentPoint32(dc.m_hDC, (LPCTSTR)s, s.GetLength(), &sz);
            m_pPaneInfo[i].m_width = sz.cx+3;
            array[i] = m_pPaneInfo[i].m_width;
            nTotal += array[i];
        }

        // Reset values in-case LoadString fails
        sz.cx = 0;
        s = _T("");
    }

    return SendMessage(SB_SETPARTS, (WPARAM) m_nCount,
        (LPARAM)array);
}

/*
    UpdateAllPanes - Assumes the first pane is the one that is stretchy
    This means only m_pPaneInfo[nCount].m_width == -1 and the rest have
    a 0 or greater width.
*/
void CStatBar::UpdateAllPanes(int clientWidth)
{
    enum
    {
        eBorder_cyHorzBorder,
        eBorder_cxVertBorder,
        eBorder_cxGutter,

        eBorder_Count
    };

    int anBorders[eBorder_Count];
    int anPartWidths[10] = {0};

    ASSERT(m_nCount <= countof(anPartWidths));
    ASSERT(m_nCount > 0);

    // Get the border widths.  anBorders[2] is the border width between rectangles
    SendMessage(SB_GETBORDERS, 0, (LPARAM)anBorders);

    // Starting from right to left
    // The right-most pane is ends at the client width
    int nCount = m_nCount - 1;
    clientWidth -= anBorders[eBorder_cxVertBorder]; // substract vertical border from right side

    anPartWidths[nCount] = clientWidth;
    clientWidth -= m_pPaneInfo[nCount].m_width;
    clientWidth -= anBorders[eBorder_cxGutter]; // substract between pane border

    --nCount;

    for (int i = nCount; i >= 0; i--)
    {
        if (clientWidth >= 0)
            anPartWidths[i] = clientWidth;

        //TRACE(_T("Pane#:%d currentWidth: %d"));
        clientWidth -= m_pPaneInfo[i].m_width;
        clientWidth -= anBorders[eBorder_cxGutter]; // substract between pane border
    }

    SendMessage (SB_SETPARTS, m_nCount, (LPARAM)anPartWidths);
}

/////////////////////////////////////////////////////////////////////////////
// CStatBar message handlers
void CStatBar::OnSize(UINT nType, int cx, int cy)
{
    if (cx > 0)
        UpdateAllPanes(cx);

    CDockWindow::OnSize(nType, cx, cy);
}


/////////////////////////////////////////////////////////////////////////////
// CRebarDockWindow

BEGIN_MESSAGE_MAP(CRebarDockWindow, CDockWindow)
    //{{AFX_MSG_MAP(CRebarDockWindow)
    ON_WM_CREATE()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SIZE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CRebarDockWindow::CRebarDockWindow()
{
    m_bTracking = false;
}

CRebarDockWindow::~CRebarDockWindow()
{
}

BOOL CRebarDockWindow::PreCreateWindow(CREATESTRUCT& cs)
{
     BOOL bSuccess=FALSE;

     // Let default implementation fill in most of the details
    CWnd::PreCreateWindow(cs);

    WNDCLASS wc;
    if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
    {
        // Clear the H and V REDRAW flags
        wc.style        &= ~(CS_HREDRAW | CS_VREDRAW);
        wc.lpszClassName = SIZEABLEREBAR_WINDOW;
        wc.hCursor       = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
        wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
        // Register this new style;
        bSuccess=AfxRegisterClass(&wc);
    }

    // Use the new child frame window class
    cs.lpszClass = SIZEABLEREBAR_WINDOW;

    return bSuccess;
}


BOOL CRebarDockWindow::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{

    ASSERT_VALID(pParentWnd);   // must have a parent

    return CWnd::Create(NULL,NULL,dwStyle, g_rectEmpty, pParentWnd, nID);
}


CRect CRebarDockWindow::CalculateSize(CRect maxRect)
{
    CRect rect(0,0,0,0);

    if (IsVisible())
    {
        rect = m_wndRebar.CalculateSize(maxRect);
        rect.bottom += SIZEABLEREBAR_GUTTER;
    }

    return rect;
}

/////////////////////////////////////////////////////////////////////////////
// CRebarDockWindow message handlers


int CRebarDockWindow::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CDockWindow::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndRebar.Create (NULL, WS_VISIBLE | WS_CHILD | RBS_AUTOSIZE,
                            g_rectEmpty, this, ID_REBAR))
        return (-1);

    return 0;
}

void CRebarDockWindow::UpdateWindowSize(void)
{
    CFrameWnd*  pFrame = GetParentFrame();

    if (pFrame->IsKindOf (RUNTIME_CLASS (CChildFrame)))
        static_cast<CChildFrame*>(pFrame)->RenderDockSites();

    else if (pFrame->IsKindOf (RUNTIME_CLASS (CMainFrame)))
        static_cast<CMainFrame*>(pFrame)->RenderDockSites();
}


void CRebarDockWindow::OnLButtonDown(UINT nFlags, CPoint point)
{
    // set the tracking flag on
    m_bTracking=TRUE;

    // capture the mouse
    SetCapture();
}

void CRebarDockWindow::OnLButtonUp(UINT nFlags, CPoint point)
{
    // set the tracking flag off
    m_bTracking=FALSE;

    // release mouse capture
    ReleaseCapture();
}

void CRebarDockWindow::OnMouseMove(UINT nFlags, CPoint point)
{
    // Reposition Bands
    if (m_bTracking)
        UpdateWindowSize();
    else
        CDockWindow::OnMouseMove(nFlags, point);
}


BOOL CRebarDockWindow::InsertBand(LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    BOOL bReturn=FALSE;

    if (IsWindow(m_wndRebar.m_hWnd))
        bReturn = m_wndRebar.InsertBand(lprbbi);

    return bReturn;
}


LRESULT CRebarDockWindow::SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    BOOL bReturn=FALSE;

    if (IsWindow(m_wndRebar.m_hWnd))
        bReturn = m_wndRebar.SetBandInfo(uBand, lprbbi);

    return bReturn;
}

void CRebarDockWindow::OnSize(UINT nType, int cx, int cy)
{
    CDockWindow::OnSize(nType, cx, cy);
    m_wndRebar.MoveWindow (0, 0, cx, cy - SIZEABLEREBAR_GUTTER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\evtsink.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       evtsink.h
//
//--------------------------------------------------------------------------

#ifndef _EVT_SINK_H
#define _EVT_SINK_H

class CAMCStatusBarText;
class CHistoryList;
class CAMCWebViewCtrl;
class CAMCProgressCtrl;

/*+-------------------------------------------------------------------------*
 * class CWebEventSink
 * 
 *
 * PURPOSE: Receives notifications from a web browser. There is only one
 *          place where a CWebEventSink object is created - within CWebCtrl
 *          ::Create.
 *
 *          The notifications received by this object can be used to activate
 *          other events and states.
 *+-------------------------------------------------------------------------*/
class CWebEventSink : 
    public IDispatchImpl<IWebSink, &IID_IWebSink, &LIBID_MMCInternalWebOcx>,
    public CComObjectRoot
{
public:
    CWebEventSink();
   ~CWebEventSink();
   SC ScInitialize(CAMCWebViewCtrl *pWebViewControl);

   BEGIN_COM_MAP(CWebEventSink)
       COM_INTERFACE_ENTRY(IDispatch)
       COM_INTERFACE_ENTRY(IWebSink)
   END_COM_MAP()

   DECLARE_NOT_AGGREGATABLE(CWebEventSink)

    // DWebBrowserEvents methods
public:
    STDMETHOD_(void, BeforeNavigate)(BSTR URL, long Flags,
           BSTR TargetFrameName, VARIANT* PostData,
           BSTR Headers, VARIANT_BOOL* Cancel);

    STDMETHOD_(void, CommandStateChange)(int Command, VARIANT_BOOL Enable);
    STDMETHOD_(void, DownloadBegin)();
    STDMETHOD_(void, DownloadComplete)();
    STDMETHOD_(void, FrameBeforeNavigate)(BSTR URL, long Flags,
           BSTR TargetFrameName, VARIANT* PostData,
           BSTR Headers, VARIANT_BOOL* Cancel);


    STDMETHOD_(void, FrameNavigateComplete)(BSTR URL);
    STDMETHOD_(void, FrameNewWindow)(BSTR URL, long Flags, BSTR TargetFrameName,
            VARIANT* PostData, BSTR Headers, VARIANT_BOOL* Processed);

    STDMETHOD_(void, NavigateComplete)(BSTR URL);
    STDMETHOD_(void, NewWindow)(BSTR URL, long Flags, BSTR TargetFrameName,
                        VARIANT* PostData, BSTR Headers, BSTR Referrer);

    STDMETHOD_(void, Progress)(long Progress, long ProgressMax);
    STDMETHOD_(void, PropertyChange)(BSTR szProperty);
    STDMETHOD_(void, Quit)(VARIANT_BOOL* pCancel);

    STDMETHOD_(void, StatusTextChange)(BSTR bstrText);
    STDMETHOD_(void, TitleChange)(BSTR Text);
    STDMETHOD_(void, WindowActivate)();
    STDMETHOD_(void, WindowMove)();
    STDMETHOD_(void, WindowResize)();

private:
    bool IsPageBreak(BSTR URL);

// Window activation helper
public:
    void SetActiveTo(BOOL bState);

// Attributes
private:
    CAMCWebViewCtrl  *  m_pWebViewControl;

// Status bar members
    CConsoleStatusBar*  m_pStatusBar;
    CAMCProgressCtrl*   m_pwndProgressCtrl;
    CHistoryList*       m_pHistoryList;
    bool                m_fLastTextWasEmpty;
    bool                m_bBrowserForwardEnabled;
    bool                m_bBrowserBackEnabled;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\evtsink.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       evtsink.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "winnls.h"

#include "AMC.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "histlist.h"
#include "exdisp.h" // for the IE dispatch interfaces.
#include "websnk.h"
#include "evtsink.h"
#include "WebCtrl.h"
#include "cstr.h"
#include "constatbar.h"

#ifdef DBG
CTraceTag tagWebEventSink(TEXT("Web View"), TEXT("Web Event Sink"));
#endif // DBG
                                 
CWebEventSink::CWebEventSink()
:   m_bBrowserBackEnabled(false), m_bBrowserForwardEnabled(false), 
    m_pWebViewControl(NULL), m_pStatusBar(NULL), m_pwndProgressCtrl(NULL), 
    m_pHistoryList(NULL)
{
}

SC
CWebEventSink::ScInitialize(CAMCWebViewCtrl *pWebViewControl)
{
    DECLARE_SC(sc, TEXT("CWebEventSink::ScInitialize"));

    sc = ScCheckPointers(pWebViewControl);
    if(sc)
        return sc;

    m_pWebViewControl = pWebViewControl;

    CAMCView* pAMCView         = dynamic_cast<CAMCView*>(pWebViewControl->GetParent());
    CFrameWnd* pwndParentFrame = pWebViewControl->GetParentFrame();

    sc = ScCheckPointers(pAMCView, pwndParentFrame);
    if(sc)
        return sc;

    m_pHistoryList = pAMCView->GetHistoryList();
    sc = ScCheckPointers(m_pHistoryList);
    if(sc)
        return sc;

    // Create the status bar for this instance of the web control
    m_pStatusBar = dynamic_cast<CConsoleStatusBar*>(pwndParentFrame);
    sc = ScCheckPointers(m_pStatusBar, E_UNEXPECTED);
    if(sc)
        return sc;
    
    // find the progress control on the status bar for the parent frame
    CAMCStatusBar* pwndStatusBar =
            reinterpret_cast<CAMCStatusBar*>(pwndParentFrame->GetMessageBar());
    sc = ScCheckPointers(pwndStatusBar);
    if(sc)
        return sc;

    ASSERT_KINDOF (CAMCStatusBar, pwndStatusBar);
    m_pwndProgressCtrl = pwndStatusBar->GetStatusProgressCtrlHwnd();

    m_fLastTextWasEmpty = false;

    return sc;
}

CWebEventSink::~CWebEventSink()
{
    /*
     * clear the status bar text
     */
    if (m_pStatusBar != NULL)
        m_pStatusBar->ScSetStatusText(NULL);
}

void CWebEventSink::SetActiveTo(BOOL /*bState*/)
{
}


STDMETHODIMP_(void) CWebEventSink::BeforeNavigate(BSTR URL, long Flags, BSTR TargetFrameName, VARIANT* PostData,
                    BSTR Headers, VARIANT_BOOL* Cancel)
{
    Trace(tagWebEventSink, TEXT("BeginNavigate(URL:%s, flags:%0X, targetfrm:%s, headers:%s)\n"), URL, Flags, TargetFrameName, Headers);

    bool bPageBreak = IsPageBreak(URL);
    m_pHistoryList->OnPageBreakStateChange(bPageBreak);

    m_pHistoryList->UpdateWebBar (HB_STOP, TRUE);  // turn on "stop" button
}

STDMETHODIMP_(void) CWebEventSink::CommandStateChange(int Command, VARIANT_BOOL Enable)
{
    if(Command == CSC_NAVIGATEFORWARD)
    {
        m_bBrowserForwardEnabled = Enable;
    }
    else if(Command == CSC_NAVIGATEBACK)
    {
        m_bBrowserBackEnabled = Enable;
    }

}

STDMETHODIMP_(void) CWebEventSink::DownloadBegin()
{
    Trace(tagWebEventSink, TEXT("DownloadBegin()"));
}

STDMETHODIMP_(void) CWebEventSink::DownloadComplete()
{
    Trace(tagWebEventSink, TEXT("DownloadComplete()"));
}

STDMETHODIMP_(void) CWebEventSink::FrameBeforeNavigate(BSTR URL, long Flags, BSTR TargetFrameName, VARIANT* PostData,
                    BSTR Headers, VARIANT_BOOL* Cancel)
{
    m_pHistoryList->UpdateWebBar (HB_STOP, TRUE);  // turn on "stop" button
}

STDMETHODIMP_(void) CWebEventSink::FrameNavigateComplete(BSTR URL)
{
}

STDMETHODIMP_(void) CWebEventSink::FrameNewWindow(BSTR URL, long Flags, BSTR TargetFrameName,   VARIANT* PostData,
                    BSTR Headers, VARIANT_BOOL* Processed)
{
}

bool CWebEventSink::IsPageBreak(BSTR URL)
{
    USES_CONVERSION;
    CStr  strURL = OLE2T(URL);
    strURL.MakeLower();

    bool bPageBreak = (_tcsstr(strURL, PAGEBREAK_URL) != NULL);
    return bPageBreak;
}

STDMETHODIMP_(void) CWebEventSink::NavigateComplete(BSTR URL)
{
    Trace(tagWebEventSink, TEXT("NavigateComplete()\n"));

    // Set progress bar position to 0
    m_pwndProgressCtrl->SetPos (0);

    bool bPageBreak = IsPageBreak(URL);
    m_pHistoryList->OnPageBreakStateChange(bPageBreak);

    // send the browser state across AFTER sending the OnPageBreakStateChange and BEFORE
    // the OnPageBreak.
    m_pHistoryList->OnBrowserStateChange(m_bBrowserForwardEnabled, m_bBrowserBackEnabled);
    
    if(bPageBreak)
    {
        m_pHistoryList->ScOnPageBreak();
    }

    // special handling:  selecting "Stop" causes this
    if (!wcscmp ((LPOLESTR)URL, L"about:NavigationCanceled"))
        return;

}

STDMETHODIMP_(void) CWebEventSink::NewWindow(BSTR URL, long Flags, BSTR TargetFrameName,
                VARIANT* PostData, BSTR Headers, BSTR Referrer)
{
}

STDMETHODIMP_(void) CWebEventSink::Progress(long Progress, long ProgressMax)
{
    Trace(tagWebEventSink, TEXT("Progress(Progress:%ld ProgressMax:%ld)\n"), Progress, ProgressMax);

    // display progress only if the web view is visible.
    if(m_pWebViewControl && m_pWebViewControl->IsWindowVisible())
    {
        m_pwndProgressCtrl->SetRange (0, ProgressMax);
        m_pwndProgressCtrl->SetPos (Progress);
    }


    // maintain "stop" button
    m_pHistoryList->UpdateWebBar (HB_STOP, ProgressMax != 0);
}

STDMETHODIMP_(void) CWebEventSink::PropertyChange(BSTR szProperty)
{
}

STDMETHODIMP_(void) CWebEventSink::Quit(VARIANT_BOOL* pCancel)
{
    Trace(tagWebEventSink, TEXT("Quit()"));
}

STDMETHODIMP_(void) CWebEventSink::StatusTextChange(BSTR bstrText)
{
    // display progress only if the web view is visible.
    if(m_pWebViewControl && m_pWebViewControl->IsWindowVisible())
    {
        bool fThisTextIsEmpty = ((bstrText == NULL) || (bstrText[0] == 0));

        if (m_fLastTextWasEmpty && fThisTextIsEmpty)
            return;

        m_fLastTextWasEmpty = fThisTextIsEmpty;

        Trace(tagWebEventSink, TEXT("StatusTextChange(%s)"), bstrText);

        USES_CONVERSION;
        m_pStatusBar->ScSetStatusText(W2T( bstrText));
    }
}

STDMETHODIMP_(void) CWebEventSink::TitleChange(BSTR Text)
{
    Trace(tagWebEventSink, TEXT("TitleChange(%s)"), Text);
}

STDMETHODIMP_(void) CWebEventSink::WindowActivate()
{
}

STDMETHODIMP_(void) CWebEventSink::WindowMove()
{
}

STDMETHODIMP_(void) CWebEventSink::WindowResize()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\docksite.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       docksite.h
//
//--------------------------------------------------------------------------

#ifndef __DOCKSITE_H__
#define __DOCKSITE_H__

#include "controls.h"
// DockSite.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDockSite window

// Forward references
class CDockWindow;
class CDockSite;
class CReBar;

template <class T>
class CDockManager
{
// Construction
public:
    CDockManager();
    ~CDockManager();

//Operations
public:
    // Add a site
    BOOL Attach(T* pSite);
    BOOL Detach(T* pSite);
    void RemoveAll();
    virtual void BeginLayout(int nWindows = 5);
    virtual void EndLayout();
    virtual void RenderDockSites(HWND hView, CRect& clientRect);

protected:
    CList<T*, T*>*   m_pManagedSites;   // Array of View's that have docksite
    HDWP             m_hDWP;            // Handle for BeginDeferWindowPos
};

template <class T>
CDockManager<T>::CDockManager()
{
    m_pManagedSites = new CList<T*, T*>;
    m_hDWP = 0;
}

template <class T>
CDockManager<T>::~CDockManager()
{
    delete m_pManagedSites;
}

template <class T>
BOOL CDockManager<T>::Attach(T* pView)
{
    ASSERT(pView != NULL);
    return (m_pManagedSites->AddTail(pView) != NULL);
}


template <class T>
BOOL CDockManager<T>::Detach(T* pView)
{
    ASSERT(pView != NULL);
    POSITION pos = m_pManagedSites->Find(pView);

    if (pos == NULL)
        return FALSE;

    return m_pManagedSites->RemoveAt(pos);
}

template <class T>
void CDockManager<T>::RemoveAll()
{
    m_pManagedSites->RemoveAll();
}

template <class T>
void CDockManager<T>::BeginLayout(int nWindows)
{
    m_hDWP = ::BeginDeferWindowPos(nWindows);
}

template <class T>
void CDockManager<T>::EndLayout()
{
    ::EndDeferWindowPos(m_hDWP);
    m_hDWP = 0;
}

template <class T>
void CDockManager<T>::RenderDockSites(HWND hView, CRect& clientRect)
{
    ASSERT(m_hDWP != 0);

    T* pDockSite;
    POSITION pos = m_pManagedSites->GetHeadPosition();

    // No sites in to manage
    if (pos == NULL)
        return ;

    // Save a copy of the full client rect
    CRect  savedClient;
    CRect  totalSite(0,0,0,0);
    CPoint point(0, 0);
    
    int yTop = 0;
    int yBottom = clientRect.bottom;

    savedClient.CopyRect(&clientRect);

    while (pos)
    {
        pDockSite = m_pManagedSites->GetNext(pos);

        ASSERT(pDockSite != NULL);

        // Set the y coordinate for the site layout logic
        if (pDockSite->GetStyle() == CDockSite::DSS_TOP)
            point.y = yTop;
        else
            point.y = yBottom;

        pDockSite->RenderLayout(m_hDWP, clientRect, point);

        // totalSite = saveRect - clientRect
        totalSite = savedClient;
        totalSite -= clientRect;

        // Adjust the y coordinate for the next site in the list
        if (pDockSite->GetStyle() == CDockSite::DSS_TOP)
            yTop += totalSite.Height();
        else
            yBottom -= totalSite.Height();

        // client rect before the site adjusts it
        savedClient = clientRect;
    }

    // Position the view window
    ::DeferWindowPos(m_hDWP, hView, NULL, savedClient.left,     // x
                                          savedClient.top+yTop, //y
                                          savedClient.Width(), 
                                          savedClient.Height(), 
                                        SWP_NOZORDER|SWP_NOACTIVATE);
}

class CDockSite
{
// Construction
public:

    enum DSS_STYLE
    {
        DSS_TOP = 0,    // Locate site at the window top
        DSS_BOTTOM,     // Locate site at the window bottom 
        DSS_LEFT,       // Locate site at the window left-side
        DSS__RIGHT,     // 
    };

public:
    CDockSite();

    // Create this site for the parent window pParent and allocate room for 10 CDockWindows.
    BOOL Create(DSS_STYLE style=DSS_TOP);


// Operations
public:

public:
    // Add a window to be docked to this site
    BOOL Attach(CDockWindow* pWnd);

    // Remove a window from the site
    BOOL Detach(CDockWindow* pWnd);

    // Compute all the regions sizes for layout
    bool IsVisible();
    void Toggle();
    DSS_STYLE GetStyle();

    virtual void RenderLayout(HDWP& hdwp, CRect& clientRect, CPoint& xyLocation);
    virtual void Show(BOOL bState = TRUE);

// Attributes
private:
    CList<CDockWindow*, CDockWindow*>*   m_pManagedWindows;  // Array of CDockWindow
    CWnd*                   m_pParentWnd;       // Window that contains the docksite
    DSS_STYLE               m_style;            // Style of the site
    CRect                   m_rect;             // Rectangle for the docksite size
    BOOL                    m_bVisible;         // Docksite visible or hidded

// Implementation
public:
    virtual ~CDockSite();
};

/////////////////////////////////////////////////////////////////////////////
inline CDockSite::DSS_STYLE CDockSite::GetStyle()
{
    return m_style;
}

inline bool CDockSite::IsVisible()
{
    return (m_bVisible != FALSE);
}

inline void CDockSite::Toggle()
{
    Show(!m_bVisible);
}


/////////////////////////////////////////////////////////////////////////////
// CDockWindow window

class CDockWindow : public CWnd
{
    DECLARE_DYNAMIC (CDockWindow)

    enum DWS_STYLE
    {
        DWS_HORIZONTAL, // Place window horizontally within the site
        DWS_VERTICAL,   // Place window vetically within the site
    };

// Construction
public:
    CDockWindow();

// Attributes
public:

// Operations
public:
    // Given the maxRect, determine the toolwindow size and calculate size
    virtual CRect CalculateSize(CRect maxRect) = 0;

    // Top level create to initialize the CDockWindow and control
    virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID) = 0;

    // Make visible/hidden
    virtual void Show(BOOL bState);
    bool IsVisible();
    void SetVisible(BOOL bState);

private:
    BOOL m_bVisible;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDockWindow)
    protected:
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDockWindow();

    // Generated message map functions
protected:
    //{{AFX_MSG(CDockWindow)
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


inline bool CDockWindow::IsVisible()
{
    return (m_bVisible != FALSE);
};

inline void CDockWindow::SetVisible(BOOL bState)
{
    m_bVisible = bState & 0x1;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CStatBar window

struct STATUSBARPANE
{
    // default to sunken text with stretchy width
    STATUSBARPANE() { m_style = 0; m_width = -1; }

    int         m_width;
    UINT        m_style;
    CString     m_paneText;
};

class CStatBar : public CDockWindow
{
    DECLARE_DYNAMIC(CStatBar)

// Construction
public:
    CStatBar();

// Attributes
public:

private:
    int              m_nCount;      // number of panes
    STATUSBARPANE*   m_pPaneInfo;   // array of pane structures, default is 10, no realloc implemented

// Operations
public:
    BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
    CRect CalculateSize(CRect maxRect);    

    void GetItemRect(int nIndex, LPRECT lpRect);
    void SetPaneStyle(int nIndex, UINT nStyle);

    BOOL CreatePanes(UINT* pIndicatorArray=NULL, int nCount=10);
    void SetPaneText(int nIndex, LPCTSTR lpszText, BOOL bUpdate = TRUE);
    void UpdateAllPanes(int clientWidth);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStatBar)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStatBar();

    // Generated message map functions
protected:
    //{{AFX_MSG(CStatBar)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
};


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRebarDockWindow window

#define SIZEABLEREBAR_GUTTER 6
#define SIZEABLEREBAR_WINDOW _T("SizeableRebar")

class CRebarDockWindow : public CDockWindow
{
// Construction
public:
    CRebarDockWindow();

// Attributes
public:

private:
    enum { ID_REBAR = 0x1000 };

    CRebarWnd   m_wndRebar;
    bool        m_bTracking;

// Operations
public:
    BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
    CRect CalculateSize(CRect maxRect);
    void UpdateWindowSize(void);
    BOOL InsertBand(LPREBARBANDINFO lprbbi);
    LRESULT SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);

    CRebarWnd* GetRebar ()
        { return &m_wndRebar; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRebarDockWindow)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRebarDockWindow();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRebarDockWindow)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __DOCKSITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\favorite.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favorite.cpp
//
//--------------------------------------------------------------------------

// favorite.cpp

#include "stdafx.h"
#include "amcdoc.h"
#include "favorite.h"
#include "favui.h"


//############################################################################
//############################################################################
//
//  Implementation of class CFavObject
//
//############################################################################
//############################################################################

CFavObject::CFavObject(bool bIsGroup)
: m_pFavParent(NULL), m_pFavNext(NULL), m_pFavChild(NULL), m_bIsGroup(bIsGroup), m_strName(_T("")),
  m_strPath(_T(""))
{
}

CFavObject::~CFavObject()
{
    // delete siblings iteratively
    CFavObject* pFavSib = GetNext();
    while(pFavSib)
    {
        CFavObject* pFavNext = pFavSib->GetNext();
        pFavSib->SetNext(NULL);

        delete pFavSib;
        pFavSib = pFavNext;
    }

    // delete children recursively
    if (GetChild())
        delete GetChild();
}


int
CFavObject::GetImage()
{
    return ( IsGroup() ? eStockImage_Folder : eStockImage_Favorite);
}

int
CFavObject::GetOpenImage()
{
    return ( IsGroup() ? eStockImage_OpenFolder: eStockImage_Favorite);
}



DWORD
CFavObject::GetChildCount()
{
    ASSERT(IsGroup());
    DWORD dwCount = 0;
    CFavObject *pObject = m_pFavChild;

    while(pObject != NULL)
    {
        dwCount++;
        pObject = pObject->GetNext();
    }

    return dwCount;
}

void CFavObject::AddChild(CFavObject* pFavNew, CFavObject* pFavPrev)
{
    ASSERT(IsGroup());
    ASSERT(pFavNew != NULL);

    // if adding to end, locate last child
    if (pFavPrev == LAST_FAVORITE)
    {
        pFavPrev = GetChild();
        if (pFavPrev != NULL)
            while (pFavPrev->GetNext()) pFavPrev = pFavPrev->GetNext();
    }

    // if no previous object
    if (pFavPrev == NULL)
    {
        // add as first child
        pFavNew->SetNext(GetChild());
        SetChild(pFavNew);
    }
    else
    {
        // add after previous
        pFavNew->SetNext(pFavPrev->GetNext());
        pFavPrev->SetNext(pFavNew);
    }

    // always set self as parent
    pFavNew->SetParent(this);
}

void CFavObject::RemoveChild(CFavObject* pFavDelete)
{
    ASSERT(pFavDelete != NULL);
    ASSERT(pFavDelete->GetParent() == this);

    if (GetChild() == pFavDelete)
    {
        SetChild(pFavDelete->GetNext());
    }
    else
    {
        CFavObject* pFavPrev = GetChild();
        while(pFavPrev != NULL && pFavPrev->GetNext() != pFavDelete)
            pFavPrev = pFavPrev->GetNext();

        ASSERT(pFavPrev != NULL);
        pFavPrev->SetNext(pFavDelete->GetNext());
    }

    pFavDelete->SetNext(NULL);
}

void CFavObject::SetPath(LPCTSTR pszPath)
{
    // Drop first part of path (because it is always the console root)
    // unless the shortcut is to the root itself
    TCHAR* pSep = _tcschr(pszPath, _T('\\'));
    m_strPath = (pSep != NULL) ? CharNext(pSep) : pszPath;
}


HRESULT
CFavObject::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (nVersion == 1)
    {
        try
        {
            stm >> m_bIsGroup;
            stm >> m_strName;

            if(IsGroup())
            {
                DWORD cChildren = 0;
                stm >> cChildren;

                for(int i = 0; i< cChildren; i++)
                {
                    CFavObject *pObject = new CFavObject(true);   // the true parameter gets overwritten.
                    hr = pObject->ReadSerialObject(stm, nVersion);
                    if(FAILED(hr))
                    {
                        delete pObject;
                        pObject = NULL;
                        return hr;
                    }

                    AddChild(pObject);
                }

                hr = S_OK;
            }
            else // is an item
            {
                hr = m_memento.Read(stm);
                stm >> m_strPath;
            }
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return hr;
}


//############################################################################
//############################################################################
//
//  Implementation of class CFavorites
//
//############################################################################
//############################################################################
CFavorites::CFavorites() : m_pFavRoot(NULL)
{
    // create root group
    CString strName;
    LoadString(strName, IDS_FAVORITES);

    m_pFavRoot = new CFavObject(true /*bIsGroup*/);
    m_pFavRoot->m_strName = strName;
}


CFavorites::~CFavorites()
{
    // delete the entire tree
    if (m_pFavRoot != NULL)
        delete m_pFavRoot;
}


/////////////////////////////////////////////////////////
// CTreeSource methods

TREEITEMID CFavorites::GetRootItem()
{
    return TIDFromFavObj(m_pFavRoot);
}


TREEITEMID CFavorites::GetParentItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return TIDFromFavObj(pFav->GetParent());
}


TREEITEMID CFavorites::GetChildItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);
    return TIDFromFavObj(pFav->GetChild());
}


TREEITEMID CFavorites::GetNextSiblingItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return TIDFromFavObj(pFav->GetNext());
}


LPARAM CFavorites::GetItemParam(TREEITEMID tid)
{
    return 0;
}

void CFavorites::GetItemName(TREEITEMID tid, LPTSTR pszName, int cchMaxName)
{
    ASSERT(pszName != NULL);

    CFavObject* pFav = FavObjFromTID(tid);

    lstrcpyn(pszName, pFav->GetName(), cchMaxName);
}

void CFavorites::GetItemPath(TREEITEMID tid, LPTSTR pszPath, int cchMaxPath)
{
    ASSERT(pszPath != NULL);

    CFavObject* pFav = FavObjFromTID(tid);

    lstrcpyn(pszPath, pFav->GetPath(), cchMaxPath);
}

int CFavorites::GetItemImage(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return pFav->GetImage();
}

int CFavorites::GetItemOpenImage(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return pFav->GetOpenImage();
}



BOOL CFavorites::IsFolderItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return pFav->IsGroup();
}


///////////////////////////////////////////////////////////////////////////
// CFavorites methods

HRESULT CFavorites::AddFavorite(TREEITEMID tidParent, LPCTSTR strName,
                                CFavObject** ppFavRet)
{
    ASSERT(tidParent != NULL && strName != NULL);
    ASSERT(FavObjFromTID(tidParent)->IsGroup());

    CFavObject* pFavParent = reinterpret_cast<CFavObject*>(tidParent);

    // Create a favorite item
    CFavObject* pFavItem = new CFavObject(false /*bIsGroup*/);
    if (pFavItem == NULL)
        return E_OUTOFMEMORY;

    pFavItem->m_strName = strName;

    // Add to end of group
    pFavParent->AddChild(pFavItem);

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemAdded(TIDFromFavObj(pFavItem));
    }

    if (ppFavRet)
        *ppFavRet = pFavItem;

    return S_OK;
}


HRESULT CFavorites::AddGroup(TREEITEMID tidParent, LPCTSTR strName, CFavObject** ppFavRet)
{
    ASSERT(tidParent != NULL && strName != NULL);
    ASSERT(FavObjFromTID(tidParent)->IsGroup());

    CFavObject* pFavParent = reinterpret_cast<CFavObject*>(tidParent);

    CFavObject* pFavGrp = new CFavObject(true /*bIsGroup*/);
    if (pFavGrp == NULL)
        return E_OUTOFMEMORY;

    pFavGrp->m_strName = strName;

    pFavParent->AddChild(pFavGrp);

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemAdded(TIDFromFavObj(pFavGrp));
    }

    if (ppFavRet)
        *ppFavRet = pFavGrp;

    return S_OK;
}


HRESULT CFavorites::DeleteItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    CFavObject* pFavParent = pFav->GetParent();

    if (pFavParent)
        pFavParent->RemoveChild(pFav);
    else
        m_pFavRoot = NULL;

    delete pFav;

    // Notify all observers of deletion
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemRemoved((TREEITEMID)pFavParent, tid);
    }

    return S_OK;
}

HRESULT CFavorites::MoveItem(TREEITEMID tid, TREEITEMID tidNewGroup, TREEITEMID tidPrev)
{
    CFavObject* pFav = FavObjFromTID(tid);
    CFavObject* pFavPrev = FavObjFromTID(tidPrev);

    ASSERT(FavObjFromTID(tidNewGroup)->IsGroup());
    CFavObject* pFavNewGroup = reinterpret_cast<CFavObject*>(tidNewGroup);

    // Verify not moving item into itself or under itself
    CFavObject* pFavTemp = pFavNewGroup;
    while (pFavTemp != NULL)
    {
        if (pFavTemp == pFav)
            return E_FAIL;
        pFavTemp = pFavTemp->GetParent();
    }

    // Remove object from current group
    CFavObject* pFavParent = pFav->GetParent();
    ASSERT(pFavParent != NULL);
    pFavParent->RemoveChild(pFav);

    // Notify all observers of removal
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemRemoved((TREEITEMID)pFavParent, tid);
    }

    // Insert item into the new group
    pFavNewGroup->AddChild(pFav, pFavPrev);

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter1)
    {
        (*iter1)->ItemAdded(tid);
    }

    return S_OK;
}


HRESULT CFavorites::SetItemName(TREEITEMID tid, LPCTSTR pszName)
{
    CFavObject* pFav = FavObjFromTID(tid);
    ASSERT(pszName != NULL && pszName[0] != 0);

    // Change item name
    pFav->m_strName = pszName;

    // Notify all observers of change
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemChanged(tid, TIA_NAME);
    }

    return S_OK;
}


HRESULT CFavorites::AddToFavorites(LPCTSTR szName, LPCTSTR szPath, CMemento &memento, CWnd* pwndHost)
{
	DECLARE_SC (sc, _T("CFavorites::AddToFavorites"));
    CAddFavDialog dlg(szName, this, pwndHost);

    CFavObject* pFavItem = NULL;
    sc = dlg.CreateFavorite(&pFavItem);

    // Note: S_FALSE is returned if user cancels dialog
	if (sc.ToHr() != S_OK)
		return (sc.ToHr());

	sc = ScCheckPointers (pFavItem, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    pFavItem->SetPath(szPath);
    pFavItem->SetMemento(memento);

    return S_OK;
}

CImageList* CFavorites::GetImageList()
{
    if (m_ImageList != NULL)
        return CImageList::FromHandle (m_ImageList);

    do
    {
        BOOL bStat = m_ImageList.Create(16, 16, ILC_COLORDDB | ILC_MASK, 20, 10);
        if (!bStat)
            break;

        CBitmap bmap;
        bStat = bmap.LoadBitmap(IDB_AMC_NODES16);
        if (!bStat)
            break;

        int ipos = m_ImageList.Add(bmap, RGB(255,0,255));
        if (ipos == -1)
            break;
    }
    while (0);

	return CImageList::FromHandle (m_ImageList);
}


HRESULT CFavorites::OrganizeFavorites(CWnd* pwndHost)
{
    COrganizeFavDialog dlg(this, pwndHost);
    dlg.DoModal();

    return S_OK;
}


HRESULT
CFavorites::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr =  m_pFavRoot->ReadSerialObject(stm, nVersion);
    if(FAILED(hr))
        return hr;

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemRemoved(NULL, TIDFromFavObj(m_pFavRoot));
        (*iter)->ItemAdded(TIDFromFavObj(m_pFavRoot));
    }

    return hr;
}

bool
CFavorites::IsEmpty()
{
    // the list is empty if the root has no children.
    return (m_pFavRoot->GetChild()==NULL);
}

/*****************************************************************\
|  METHOD: CFavorites::Persist
|  DESCR:  Persists favorites, by delegating to root item
\*****************************************************************/
void
CFavorites::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CFavorites::Persist"));

    sc = ScCheckPointers(m_pFavRoot, E_POINTER);
    if (sc)
        sc.Throw();

    persistor.Persist(*m_pFavRoot);
}

/*****************************************************************\
|  METHOD: CFavoriteXMLList::PersistItself
|  DESCR:  "soft" version of Persist - ignores missing element
|  RETURN: true == element exists and persistence succeeded
\*****************************************************************/
bool
CFavoriteXMLList::PersistItself(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CFavoriteXMLList::PersistItself"));

    if (persistor.IsLoading())
    {
        if (!persistor.HasElement(GetXMLType(), NULL))
            return false;
    }

    persistor.Persist(*this);
    return true;
}

/*****************************************************************\
|  METHOD: CFavoriteXMLList::Persist
|  DESCR:  Perists collection (linked list) contents
\*****************************************************************/
void
CFavoriteXMLList::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
    {
        for (CFavObject *pObj = m_rpRoot; pObj; pObj = pObj->GetNext())
        {
            persistor.Persist(*pObj);
        }
    }
    else
    {
        ASSERT(m_rpRoot == NULL); // this is to upload new entries only!!!
        m_rpRoot = NULL;
        XMLListCollectionBase::Persist(persistor);
    }
}

/*****************************************************************\
|  METHOD: CFavoriteXMLList::OnNewElement
|  DESCR:  called for every new element when loading
\*****************************************************************/
void
CFavoriteXMLList::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CFavoriteXMLList::OnNewElement"));

    CFavObject **pObj = &m_rpRoot;
    while (*pObj)
        pObj = &(*pObj)->m_pFavNext;

    CFavObject *pNewObj = new CFavObject(false);
    *pObj = pNewObj;

    sc = ScCheckPointers(pNewObj, E_OUTOFMEMORY);
    if (sc)
        sc.Throw();

    pNewObj->SetParent(m_Parent);
    persistor.Persist(*pNewObj);
}

/*****************************************************************\
|  METHOD: CFavObject::Persist
|  DESCR:  Persists Favorites item.
\*****************************************************************/
void
CFavObject::Persist(CPersistor &persistor)
{
    persistor.PersistString(XML_ATTR_NAME, m_strName);
    // persist the type of favorite
    CStr strType(IsGroup() ? XML_VAL_FAVORITE_GROUP : XML_VAL_FAVORITE_SINGLE);
    persistor.PersistAttribute(XML_ATTR_FAVORITE_TYPE, strType);
    m_bIsGroup = (0 == strType.CompareNoCase(XML_VAL_FAVORITE_GROUP));

    // its either group or memento.
    if (IsGroup())
    {
        CFavoriteXMLList children(m_pFavChild, this);
        children.PersistItself(persistor);
    }
    else // if (!IsGroup())
    {
        persistor.Persist(m_memento);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\favorite.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favorite.h
//
//--------------------------------------------------------------------------

// favorite.h

#ifndef _FAVORITE_H_
#define _FAVORITE_H_

#include "treeobsv.h"
#include "tstring.h"
#include "imageid.h"

/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include "atlapp.h"
#include "atlctrls.h"

class CFavorites;
class CFavObject;
class CMemento;

// Extra spacing for favorite tree views
#define FAVVIEW_ITEM_SPACING 4

#define LAST_FAVORITE ((CFavObject*)TREEID_LAST)

//
// CFavObject - class for favorite groups and items.
//
class CFavObject : public CXMLObject
{
    friend CFavorites;

private:
    CFavObject(bool bIsGroup);
    ~CFavObject();

public:

    LPCTSTR GetName() { return m_strName.data(); }

    CFavObject* GetParent() { return m_pFavParent; }
    CFavObject* GetNext()   { return m_pFavNext; }
    CFavObject* GetChild()  { return m_pFavChild;}

    BOOL    IsGroup()       {return m_bIsGroup;}
    DWORD   GetChildCount();
    int     GetImage();
    int     GetOpenImage();

    void    AddChild(CFavObject* pFav, CFavObject* pFavPrev = LAST_FAVORITE);
    void    RemoveChild(CFavObject* pFavRemove);

	CMemento* GetMemento()             {return &m_memento; }
	void SetMemento(CMemento &memento) {m_memento = memento; }

    LPCTSTR GetPath()            { return m_strPath.data(); }
    void SetPath(LPCTSTR szPath);

protected:
    void    SetNext  (CFavObject* pFav) { m_pFavNext = pFav; }
    void    SetChild (CFavObject* pFav) { m_pFavChild = pFav; }
    void    SetParent(CFavObject* pFav) { m_pFavParent = pFav; }

    CFavObject* m_pFavParent;
    CFavObject* m_pFavNext;
    CFavObject* m_pFavChild;

public:
    // pseudo-CSerialObject methods. The real version number is saved with the containing object, for efficiency.
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);

    DEFINE_XML_TYPE(XML_TAG_FAVORITES_ENTRY);
    virtual void    Persist(CPersistor &persistor);
    friend class CFavoriteXMLList;
    // these are persisted
protected:
    bool                m_bIsGroup;
    CStringTableString  m_strName;
    CStringTableString  m_strPath;
    CMemento            m_memento;
};

/*****************************************************************\
|  CLASS: CFavoriteXMLList
|  DESCR: implements persisting of linked list as a collection
\*****************************************************************/
class CFavoriteXMLList : public XMLListCollectionBase
{
    CFavObject * &m_rpRoot;
    CFavObject * m_Parent;
public:
    CFavoriteXMLList(CFavObject * &rpRoot, CFavObject *Parent) : m_rpRoot(rpRoot), m_Parent(Parent) {}
    // PersistItself should be called instead of CPersistor's Persist method
    // implements "softer" loading algorythm
    bool    PersistItself(CPersistor& persistor);
protected:
    virtual void Persist(CPersistor& persistor);
    virtual void OnNewElement(CPersistor& persistor);
    DEFINE_XML_TYPE(XML_TAG_FAVORITES_LIST);
};

class CFavorites : public CTreeSource,
                   public EventSourceImpl<CTreeObserver>,
                   public CSerialObject,
                   public CXMLObject
{
public:

    CFavorites();
    ~CFavorites();

    // CTreeSource methods
    STDMETHOD_(TREEITEMID, GetRootItem)     ();
    STDMETHOD_(TREEITEMID, GetParentItem)   (TREEITEMID tid);
    STDMETHOD_(TREEITEMID, GetChildItem)    (TREEITEMID tid);
    STDMETHOD_(TREEITEMID, GetNextSiblingItem) (TREEITEMID tid);

    STDMETHOD_(LPARAM,  GetItemParam)   (TREEITEMID tid);
    STDMETHOD_(void,    GetItemName)    (TREEITEMID tid, LPTSTR pszName, int cchMaxName);
    STDMETHOD_(void,    GetItemPath)    (TREEITEMID tid, LPTSTR pszPath, int cchMaxName);
    STDMETHOD_(int,     GetItemImage)   (TREEITEMID tid);
    STDMETHOD_(int,     GetItemOpenImage) (TREEITEMID tid);
    STDMETHOD_(BOOL,    IsFolderItem)   (TREEITEMID tid);

    // CFavorites methods
	HRESULT AddToFavorites(LPCTSTR szName, LPCTSTR szPath, CMemento &memento, CWnd* pwndHost);
    HRESULT OrganizeFavorites(CWnd* pwndHost);

    HRESULT AddFavorite(TREEITEMID tidParent, LPCTSTR strName, CFavObject** ppFavRet = NULL);
	HRESULT AddGroup   (TREEITEMID tidParent, LPCTSTR strName, CFavObject** ppFavRet = NULL);
    HRESULT DeleteItem (TREEITEMID tidRemove);
    HRESULT MoveItem   (TREEITEMID tid, TREEITEMID tidNewParent, TREEITEMID tidPrev);
    HRESULT SetItemName(TREEITEMID tid, LPCTSTR pszName);
    HRESULT GetMemento (TREEITEMID tid, CMemento* pmemento);

    CFavObject* FavObjFromTID(TREEITEMID tid) { return reinterpret_cast<CFavObject*>(tid); }
    TREEITEMID TIDFromFavObj(CFavObject* pFav) { return reinterpret_cast<TREEITEMID>(pFav); }

    bool    IsEmpty();

    CImageList* GetImageList();

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);

    DEFINE_XML_TYPE(XML_TAG_FAVORITES_LIST);
    virtual void    Persist(CPersistor &persistor);
private:

	/*
	 * Theming: use WTL::CImageList instead of MFC's CImageList so we can
	 * insure a theme-correct imagelist will be created.
	 */
    WTL::CImageList m_ImageList;

    // these get persisted
private:
    CFavObject* m_pFavRoot;
};

#endif //_FAVORITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\favui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favui.cpp
//
//--------------------------------------------------------------------------

// favui.cpp - favorites tree configuration UI

#include "stdafx.h"
#include "amcdoc.h"
#include "favorite.h"
#include "favui.h"
#include "amcmsgid.h"
#include "amcview.h"
#include "mmcres.h"

void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable);

BEGIN_MESSAGE_MAP(CAddFavDialog, CDialog)
    //{{AFX_MSG_MAP(CAddFavDialog)
    ON_COMMAND(IDC_ADDFAVFOLDER, OnAddFolder)
    ON_EN_CHANGE(IDC_FAVNAME, OnChangeName)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()


CAddFavDialog::CAddFavDialog(LPCTSTR szName, CFavorites* pFavorites, CWnd* pParent)
   : CDialog(CAddFavDialog::IDD, pParent),
     m_pFavorites(pFavorites), m_lAdviseCookie(NULL)
{
    m_strName = szName;
    ASSERT(pFavorites != NULL);
}

CAddFavDialog::~CAddFavDialog()
{
    // disconnect fav view from source
    if (m_lAdviseCookie )
    {
        ASSERT(m_pFavorites != NULL);
        HRESULT hr = m_pFavorites->Unadvise(m_lAdviseCookie);
        ASSERT(SUCCEEDED(hr));

        m_FavTree.SetTreeSource(NULL);
    }

    // detach classes from windows
    m_FavTree.Detach();
    m_FavName.Detach();
}


HRESULT CAddFavDialog::CreateFavorite(CFavObject** pfavRet)
{
    m_pfavItem = NULL;

    if (DoModal() != IDOK)
        return S_FALSE;

    if (pfavRet != NULL)
        *pfavRet = m_pfavItem;

    return m_hr;
}


BOOL CAddFavDialog::OnInitDialog()
{
	DECLARE_SC (sc, _T("CAddFavDialog::OnInitDialog"));
    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    // Attach tree ctrl to favorites tree object
    BOOL bStat = m_FavTree.SubclassDlgItem(IDC_FAVTREE, this);
    ASSERT(bStat);

    bStat = m_FavName.Attach(GetDlgItem(IDC_FAVNAME)->GetSafeHwnd());
    ASSERT(bStat);

    m_FavName.SetWindowText(m_strName);
    m_FavName.SetSel(0,lstrlen(m_strName));
    m_FavName.SetFocus();

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

    // Show only folders
    m_FavTree.SetStyle(TOBSRV_FOLDERSONLY);

	/*
	 * validate m_pFavorites
	 */
	sc = ScCheckPointers (m_pFavorites, E_UNEXPECTED);
	if (sc)
	{
		EndDialog (IDCANCEL);
		return (0);
	}

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(m_pFavorites->GetImageList(), TVSIL_NORMAL);

    // attach view to source as observer
    HRESULT hr = m_pFavorites->Advise(static_cast<CTreeObserver*>(&m_FavTree), &m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr) && m_lAdviseCookie != 0);

    // hand tree data source to tree view
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(m_pFavorites));

    // Select the root
    m_FavTree.SetSelection(m_pFavorites->GetRootItem());

    // return 0 so focus isn't changed
    return 0;
}

void CAddFavDialog::OnChangeName()
{
    EnableButton(m_hWnd, IDOK, (m_FavName.LineLength() != 0));
}

void CAddFavDialog::OnOK( )
{
    // Get favorite name
    TCHAR strName[MAX_PATH];

    m_hr = E_FAIL;
    m_pfavItem = NULL;

    int cChar = m_FavName.GetWindowText(strName, countof(strName));
    ASSERT(cChar != 0);
    if (cChar == 0)
        return;

    // Get selected folder
    TREEITEMID tid = m_FavTree.GetSelection();
    ASSERT(tid != NULL);
    if (tid == NULL)
        return;

    // Detach fav tree from source because it doesn't need updating
    ASSERT(m_pFavorites != NULL);
    HRESULT hr = m_pFavorites->Unadvise(m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr));
    m_lAdviseCookie = 0;

    // Inform source of disconnection
    m_FavTree.SetTreeSource(NULL);

    // Create a favorite
    ASSERT(m_pFavorites != NULL);
    m_hr = m_pFavorites->AddFavorite(tid, strName, &m_pfavItem);
    ASSERT(SUCCEEDED(hr));

    CDialog::OnOK();
}

void CAddFavDialog::OnAddFolder()
{
    ASSERT(m_pFavorites != NULL);

    // Get selected group
    TREEITEMID tidParent = m_FavTree.GetSelection();
    ASSERT(tidParent != NULL);

    // Put up dialog to get folder name
    CAddFavGroupDialog dlgAdd(this);
    if (dlgAdd.DoModal() != IDOK)
        return;

    LPCTSTR strName = dlgAdd.GetGroupName();
    ASSERT(strName[0] != 0);

    CFavObject* pfavGroup = NULL;
    HRESULT hr = m_pFavorites->AddGroup(tidParent, strName, &pfavGroup);
    if (SUCCEEDED(hr))
    {
        ASSERT(pfavGroup != NULL);
        m_FavTree.SetSelection(reinterpret_cast<TREEITEMID>(pfavGroup));
    }
}


/////////////////////////////////////////////////////////////////////
// CAddFavGroup dialog

BEGIN_MESSAGE_MAP(CAddFavGroupDialog, CDialog)
    //{{AFX_MSG_MAP(CAddFavGroupDialog)
    ON_EN_CHANGE(IDC_FAVFOLDER, OnChangeName)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()


CAddFavGroupDialog::CAddFavGroupDialog(CWnd* pParent)
   : CDialog(CAddFavGroupDialog::IDD, pParent)
{
}

CAddFavGroupDialog::~CAddFavGroupDialog()
{
    // detach classes from windows
    m_GrpName.Detach();
}

CAddFavGroupDialog::OnInitDialog()
{
    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    BOOL bStat = m_GrpName.Attach(GetDlgItem(IDC_FAVFOLDER)->GetSafeHwnd());
    ASSERT(bStat);

    // Set default favorite name and select it
    CString strDefault;
    LoadString(strDefault, IDS_NEWFOLDER);

    m_GrpName.SetWindowText(strDefault);
    m_GrpName.SetSel(0,lstrlen(strDefault));
    m_GrpName.SetFocus();

    // return 0 so focus isn't changed
    return 0;
}

void CAddFavGroupDialog::OnChangeName()
{
    EnableButton(m_hWnd, IDOK, (m_GrpName.LineLength() != 0));
}

void CAddFavGroupDialog::OnOK( )
{
    // Get group name
    int cChar = GetDlgItemText(IDC_FAVFOLDER, m_strName, sizeof(m_strName)/sizeof(TCHAR));
    ASSERT(cChar != 0);

    CDialog::OnOK();
}

//////////////////////////////////////////////////////////////////////////////
//
BEGIN_MESSAGE_MAP(COrganizeFavDialog, CDialog)
    //{{AFX_MSG_MAP(COrganizeFavDialog)
    ON_COMMAND(IDC_ADDFAVFOLDER, OnAddFolder)
    ON_COMMAND(IDC_FAVRENAME, OnRename)
    ON_COMMAND(IDC_FAVDELETE, OnDelete)
    ON_COMMAND(IDC_FAVMOVETO, OnMoveTo)
    ON_NOTIFY(TVN_SELCHANGED, IDC_FAVTREE, OnSelChanged)
    ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_FAVTREE, OnBeginLabelEdit)
    ON_NOTIFY(TVN_ENDLABELEDIT, IDC_FAVTREE, OnEndLabelEdit)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()


COrganizeFavDialog::COrganizeFavDialog(CFavorites* pFavorites, CWnd* pParent)
   : CDialog(COrganizeFavDialog::IDD, pParent),
     m_pFavorites(pFavorites), m_lAdviseCookie(NULL), m_tidRenameItem(0), m_bRenameMode(FALSE)
{
    ASSERT(pFavorites != NULL);
}

COrganizeFavDialog::~COrganizeFavDialog()
{
    // disconnect fav view from source
    if (m_lAdviseCookie)
    {
        ASSERT(m_pFavorites != NULL);
        m_pFavorites->Unadvise(m_lAdviseCookie);
        m_FavTree.SetTreeSource(NULL);
    }

    // detach classes from windows
    m_FavTree.Detach();
    m_FavName.Detach();
    m_FavInfo.Detach();
}


BOOL COrganizeFavDialog::OnInitDialog()
{
	DECLARE_SC (sc, _T("COrganizeFavDialog::OnInitDialog"));
    ASSERT(m_pFavorites != NULL);

    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    // Attach tree ctrl to favorites tree object
    BOOL bStat = m_FavTree.SubclassDlgItem(IDC_FAVTREE, this);
    ASSERT(bStat);

    bStat = m_FavName.Attach(GetDlgItem(IDC_FAVNAME)->GetSafeHwnd());
    ASSERT(bStat);

    bStat = m_FavInfo.Attach(GetDlgItem(IDC_FAVINFO)->GetSafeHwnd());
    ASSERT(bStat);

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

	/*
	 * validate m_pFavorites
	 */
	sc = ScCheckPointers (m_pFavorites, E_UNEXPECTED);
	if (sc)
	{
		EndDialog (IDCANCEL);
		return (0);
	}

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(m_pFavorites->GetImageList(), TVSIL_NORMAL);

    // Attach view to source as observer
    HRESULT hr = m_pFavorites->Advise(static_cast<CTreeObserver*>(&m_FavTree), &m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr) && m_lAdviseCookie != 0);

    // Hand tree data source to tree view
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(m_pFavorites));

    // Select the root item and give it focus
    m_FavTree.SetSelection(m_pFavorites->GetRootItem());
    m_FavTree.SetFocus();

    // Create bold font for favorite name control
    LOGFONT logfont;
    m_FavName.GetFont()->GetLogFont(&logfont);

    logfont.lfWeight = FW_BOLD;
    if (m_FontBold.CreateFontIndirect(&logfont))
        m_FavName.SetFont(&m_FontBold);


    // return 0 so focus isn't changed
    return 0;
}

void COrganizeFavDialog::OnOK( )
{
    // if in rename mode, end it with success
    if (m_bRenameMode)
    {
        m_FavTree.SendMessage(TVM_ENDEDITLABELNOW, FALSE);
        return;
    }

    CDialog::OnOK();
}


void COrganizeFavDialog::OnCancel( )
{
    // if in rename mode, cancel it
    if (m_bRenameMode)
    {
        m_FavTree.SendMessage(TVM_ENDEDITLABELNOW, FALSE);
        return;
    }

    CDialog::OnOK();
}


void COrganizeFavDialog::OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult)
{
    ASSERT(pMNHDR != NULL);
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pMNHDR;

    TREEITEMID tid = pnmtv->itemNew.lParam;

    TCHAR name[100];
    m_pFavorites->GetItemName(tid, name, 100);
    m_FavName.SetWindowText(name);

    if (m_pFavorites->IsFolderItem(tid))
    {
        CString strPath;
        LoadString(strPath, IDS_FAVFOLDER);
        m_FavInfo.SetWindowText(strPath);
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        m_pFavorites->GetItemPath(tid, szPath, MAX_PATH);
        m_FavInfo.SetWindowText(szPath);
    }

    // Disable some operation for the root item
    BOOL bRoot = (tid == m_pFavorites->GetRootItem());

    EnableButton(m_hWnd, IDC_FAVRENAME, !bRoot);
    EnableButton(m_hWnd, IDC_FAVDELETE, !bRoot);
    EnableButton(m_hWnd, IDC_FAVMOVETO, !bRoot);
}


void COrganizeFavDialog::OnBeginLabelEdit(NMHDR* pMNHDR, LRESULT* plResult)
{
    // Only allow renaming if an item has been selected
    // This is to prevent an edit starting from an item click because
    // that is confusing when used with the single-click expand style.
    // (returning TRUE disables it)

    if (m_tidRenameItem != 0)
    {
        m_bRenameMode = TRUE;
        *plResult = FALSE;
    }
    else
    {
        *plResult = TRUE;
    }
}


void COrganizeFavDialog::OnEndLabelEdit(NMHDR* pMNHDR, LRESULT* plResult)
{
    ASSERT(m_bRenameMode && m_tidRenameItem != 0);

    *plResult = FALSE;

    if (m_tidRenameItem != 0)
    {
        NMTVDISPINFO* pnmtvd = (NMTVDISPINFO*)pMNHDR;

        // Is this for the expected item?
        ASSERT(pnmtvd->item.lParam == m_tidRenameItem);

        if (pnmtvd->item.pszText != NULL && pnmtvd->item.pszText[0] != 0)
        {
            m_pFavorites->SetItemName(m_tidRenameItem, pnmtvd->item.pszText);
            *plResult = TRUE;

            // update displayed name in info window
            m_FavName.SetWindowText(pnmtvd->item.pszText);
        }

        m_tidRenameItem = 0;
     }

     m_bRenameMode = FALSE;
}


void COrganizeFavDialog::OnAddFolder()
{
    ASSERT(m_pFavorites != NULL);

    // Get selected group
    TREEITEMID tidParent = m_FavTree.GetSelection();
    ASSERT(tidParent != NULL);

    // if selected item is not a group then
    // add the new group as a sibling
    if (!m_pFavorites->IsFolderItem(tidParent))
        tidParent = m_pFavorites->GetParentItem(tidParent);

    // Put up dialog to get folder name
    CAddFavGroupDialog dlgAdd(this);
    if (dlgAdd.DoModal() != IDOK)
        return;

    LPCTSTR strName = dlgAdd.GetGroupName();
    ASSERT(strName[0] != 0);

    CFavObject* pfavGroup = NULL;
    HRESULT hr = m_pFavorites->AddGroup(tidParent, strName, &pfavGroup);
    if (SUCCEEDED(hr))
    {
        m_FavTree.ExpandItem(tidParent);
    }
}


void COrganizeFavDialog::OnDelete()
{
    TREEITEMID tid = m_FavTree.GetSelection();

    if (tid != 0 && tid != m_pFavorites->GetRootItem())
        m_pFavorites->DeleteItem(tid);
}

void COrganizeFavDialog::OnRename()
{
    ASSERT(m_pFavorites != NULL);

    // Get selected item
    TREEITEMID tid = m_FavTree.GetSelection();

    if (tid != 0 && tid != m_pFavorites->GetRootItem())
    {
        HTREEITEM hti = m_FavTree.FindHTI(tid, TRUE);
        ASSERT(hti != NULL);

        m_tidRenameItem = tid;
        m_FavTree.SetFocus();
        m_FavTree.EditLabel(hti);
    }
}

void COrganizeFavDialog::OnMoveTo()
{
    ASSERT(m_pFavorites != NULL);

    // Put up dialog to get destination folder ID
    CFavFolderDialog dlgAdd(m_pFavorites, this);
    if (dlgAdd.DoModal() != IDOK)
        return;

    TREEITEMID  tidNewParent = dlgAdd.GetFolderID();

    // Get selected object
    TREEITEMID tid = m_FavTree.GetSelection();
    ASSERT(tid != NULL);

    HRESULT hr = m_pFavorites->MoveItem(tid, tidNewParent, TREEID_LAST);

    // on failure tell user selected destination is invalid
}

/////////////////////////////////////////////////////////////////////
// CFavFolderDialog dialog

BEGIN_MESSAGE_MAP(CFavFolderDialog, CDialog)
    //{{AFX_MSG_MAP(CFavFolderDialog)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()

CFavFolderDialog::CFavFolderDialog(CFavorites* pFavorites, CWnd* pParent)
   : CDialog(CFavFolderDialog::IDD, pParent),
   m_pFavorites(pFavorites), m_lAdviseCookie(NULL)
{
    ASSERT(pFavorites != NULL);
}

CFavFolderDialog::~CFavFolderDialog()
{
    // disconnect fav view from source
    if (m_lAdviseCookie )
    {
        ASSERT(m_pFavorites != NULL);
        m_pFavorites->Unadvise(m_lAdviseCookie);
        m_FavTree.SetTreeSource(NULL);
    }

    // detach classes from windows
    m_FavTree.Detach();
}

CFavFolderDialog::OnInitDialog()
{
	DECLARE_SC (sc, _T("CFavFolderDialog::OnInitDialog"));
    ASSERT(m_pFavorites != NULL);

    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    // Attach tree ctrl to favorites tree object
    BOOL bStat = m_FavTree.SubclassDlgItem(IDC_FAVTREE, this);
    ASSERT(bStat);

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

    // Show only folders
    m_FavTree.SetStyle(TOBSRV_FOLDERSONLY);

	/*
	 * validate m_pFavorites
	 */
	sc = ScCheckPointers (m_pFavorites, E_UNEXPECTED);
	if (sc)
	{
		EndDialog (IDCANCEL);
		return (0);
	}

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(m_pFavorites->GetImageList(), TVSIL_NORMAL);

    // attach view to source as observer
    HRESULT hr = m_pFavorites->Advise(static_cast<CTreeObserver*>(&m_FavTree), &m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr) && m_lAdviseCookie != 0);

    // hand tree data source to tree view
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(m_pFavorites));

    // Select the root and give it focus
    m_FavTree.SetSelection(m_pFavorites->GetRootItem());
    m_FavTree.SetFocus();

    // return 0 so focus isn't changed
    return 0;

}


void CFavFolderDialog::OnOK()
{
    // Get group name
    m_tidFolder = m_FavTree.GetSelection();

    // disconnect fav view from source before window goes away
    if (m_lAdviseCookie)
    {
        ASSERT(m_pFavorites != NULL);
        m_pFavorites->Unadvise(m_lAdviseCookie);
        m_FavTree.SetTreeSource(NULL);
        m_lAdviseCookie = 0;
    }

    CDialog::OnOK();
}


//////////////////////////////////////////////////////////////////////////////
//  CFavTreeCtrl

SC CFavTreeCtrl::ScInitialize(CFavorites* pFavorites, DWORD dwStyles)
{
	DECLARE_SC (sc, _T("CFavTreeCtrl::Initialize"));

	/*
	 * validate pFavorites
	 */
	sc = ScCheckPointers (pFavorites);
	if (sc)
		return (sc);

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(pFavorites->GetImageList(), TVSIL_NORMAL);

    m_FavTree.SetStyle(dwStyles);

    // Attach favorites data source
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(pFavorites));

	return (sc);
}

int CFavTreeCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    RECT rect;
    GetClientRect(&rect);
    m_FavTree.Create(WS_VISIBLE | TVS_SINGLEEXPAND | TVS_TRACKSELECT |
                     TVS_FULLROWSELECT, rect, this, IDC_FAVTREECTRL);

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

    // Dont' show the "Favorites" root item
    m_FavTree.SetStyle(TOBSRV_HIDEROOT);
    return 0;
}

void CFavTreeCtrl::PostNcDestroy()
{
    /*
     * Commit suicide.  See the comment for this class's ctor for reasoning
     * why this is safe.
     */
    delete this;
}

void  CFavTreeCtrl::OnSize(UINT nType, int cx, int cy)
{
    // size tree control to parent
    m_FavTree.MoveWindow(0, 0, cx, cy);
}

void  CFavTreeCtrl::OnSetFocus(CWnd* pOldWnd)
{
    // pass focus to tree control
    m_FavTree.SetFocus();
}

void  CFavTreeCtrl::OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult)
{
    ASSERT(pMNHDR != NULL);
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pMNHDR;

    TREEITEMID tid = pnmtv->itemNew.lParam;
    CFavObject* pFav = (CFavObject*)tid;

    WPARAM wParam = pFav->IsGroup() ?
                        NULL : reinterpret_cast<WPARAM>(pFav->GetMemento());

    GetParent()->SendMessage(MMC_MSG_FAVORITE_SELECTION, wParam, 0);
}

BEGIN_MESSAGE_MAP(CFavTreeCtrl, CWnd)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_SETFOCUS()
    ON_NOTIFY(TVN_SELCHANGED, IDC_FAVTREECTRL, OnSelChanged)
END_MESSAGE_MAP()


//--------------------------------------------------------------------------
// EnableButton
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    ASSERT(::IsWindow(hWndCtrl));

    if (!bEnable && ::GetFocus() == hWndCtrl)
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if (hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl)
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member     : OnFavoritesMenu
//
//  Synopsis   : Display the favorites menu.
//
//  Arguments  : [point] - x,y co-ordinates for menu.
//
//  Returns    : None.
//
//--------------------------------------------------------------------
void CAMCView::OnFavoritesMenu(CPoint point, LPCRECT prcExclude)
{
	DECLARE_SC (sc, _T("CAMCView::OnFavoritesMenu"));
    TRACE_METHOD(CAMCView, OnFavoritesMenu);

    CMenu menu;
    VERIFY( menu.CreatePopupMenu() );

    // Default items available only in Author mode.
    if (AMCGetApp()->GetMode() == eMode_Author)
    {
        CString strItem;

        // Menu Command Ids for below items are string resource
        // IDs. The real favorites use the TREEITEMID as ID,
        // which are pointers and wont clash with below resource
        // IDs which are less than 0xFFFF
        LoadString(strItem, IDS_ADD_TO_FAVORITES);
		int iSeparator = strItem.Find(_T('\n'));
		if (iSeparator > 0)
			strItem = strItem.Left(iSeparator);

        VERIFY(menu.AppendMenu(MF_DEFAULT, IDS_ADD_TO_FAVORITES, (LPCTSTR)strItem));

        LoadString(strItem, IDS_ORGANIZEFAVORITES);
		iSeparator = strItem.Find(_T('\n'));
		if (iSeparator > 0)
			strItem = strItem.Left(iSeparator);

        VERIFY(menu.AppendMenu(MF_DEFAULT, IDS_ORGANIZEFAVORITES, (LPCTSTR)strItem));
    }

    CAMCDoc* pDoc = GetDocument();
    ASSERT(pDoc);
    CFavorites* pFavorites = pDoc->GetFavorites();

	/*
	 * Index 0 of the vector is unused (a 0 return from TrackPopupMenu
	 * means nothing was selected).  Put a placeholder there.
	 */
	TIDVector vItemIDs;
	vItemIDs.push_back (NULL);

	/*
	 * make sure IDS_ADD_TO_FAVORITES and IDS_ORGANIZEFAVORITES
	 * won't conflict with any indices in the TID vector, given a
	 * reasonable upper bound on the number of favorites
	 */
	const int cMaxReasonableFavorites = 1024;
	ASSERT             (vItemIDs.size ()	  <= cMaxReasonableFavorites);
	COMPILETIME_ASSERT (IDS_ADD_TO_FAVORITES  >  cMaxReasonableFavorites);
	COMPILETIME_ASSERT (IDS_ORGANIZEFAVORITES >  cMaxReasonableFavorites);

    // Add existing favorites.
    if ( (NULL != pFavorites) && (pFavorites->IsEmpty() == false))
    {
        TREEITEMID tid = pFavorites->GetRootItem();
        if (NULL != tid)
        {
            tid = pFavorites->GetChildItem(tid);
            if (NULL != tid)
            {
                // Add separator.
                if (AMCGetApp()->GetMode() == eMode_Author)
                    VERIFY(menu.AppendMenu(MF_SEPARATOR, 0, _T("")));

                // Add child items.
                AddFavItemsToCMenu(menu, pFavorites, tid, vItemIDs);
            }
        }
    }

    // Display the context menu.
	TPMPARAMS* ptpm = NULL;
	TPMPARAMS tpm;

	/*
	 * if given, initialize the rectangle not to obscure
	 */
	if (prcExclude != NULL)
	{
		tpm.cbSize    = sizeof(tpm);
		tpm.rcExclude = *prcExclude;
		ptpm          = &tpm;
	}

    LONG lSelected = TrackPopupMenuEx (
			menu.GetSafeHmenu(),
            TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTBUTTON | TPM_VERTICAL,
            point.x,
            point.y,
            GetSafeHwnd(),
            ptpm );

    // Handle the selection.

    switch (lSelected)
    {
		case 0: // Nothing is selected
			break;
	
		case IDS_ADD_TO_FAVORITES: // Bring the Add To Favorites dialog.
			OnAddToFavorites();
			break;
	
		case IDS_ORGANIZEFAVORITES: // Bring the organize favorites dialog.
			{
				CAMCDoc* pDoc = GetDocument();
				ASSERT(pDoc != NULL && pDoc->GetFavorites() != NULL);
	
				pDoc->GetFavorites()->OrganizeFavorites(this);
			}
			break;
	
		default: // This is a favorite item. Select it.
			{
				CFavorites* pFavs = GetDocument()->GetFavorites();
				sc = ScCheckPointers (pFavs, E_UNEXPECTED);
				if (sc)
					break;
	
				sc = (lSelected < vItemIDs.size()) ? S_OK : E_UNEXPECTED;
				if (sc)
					break;
	
				TREEITEMID tid = vItemIDs[lSelected];
				CFavObject* pFavObj = pFavs->FavObjFromTID(tid);
	
				sc = ScCheckPointers (pFavObj, E_UNEXPECTED);
				if (sc)
					break;
	
				sc = ScViewMemento(pFavObj->GetMemento());
                if (sc == ScFromMMC(IDS_NODE_NOT_FOUND) )
                {
                    MMCMessageBox(sc, MB_ICONEXCLAMATION | MB_OK);
                    sc.Clear();
                    return;
                }

                if (sc)
                    return;
			}
			break;
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member     : AddFavItemsToCMenu.
//
//  Synopsis   : Enumerate the favorites tree and add them as menu items.
//
//  Arguments  : [menu]  - Parent menu item.
//               [pFavs] - Favorites object.
//               [tid]   - Tree Item ID.
//
//  Returns    : None.
//
//--------------------------------------------------------------------
void CAMCView::AddFavItemsToCMenu(CMenu& menu, CFavorites* pFavs, TREEITEMID tid, TIDVector& vItemIDs)
{
    TCHAR szName[MAX_PATH];

    while (NULL != tid)
    {
        UINT nFlags = MF_DEFAULT;
        UINT_PTR nCommandID;

        // If this is folder item then
        // create a popup menu.
        if (pFavs->IsFolderItem(tid))
        {
            TREEITEMID tidChild = pFavs->GetChildItem(tid);

            CMenu submenu;
            VERIFY(submenu.CreatePopupMenu());

            // Add the children.
            if (NULL != tidChild)
            {
                AddFavItemsToCMenu(submenu, pFavs, tidChild, vItemIDs);
            }
            else
            {
                // Add an empty item.
                CString strItem;
                LoadString(strItem, IDS_Empty);
                VERIFY(submenu.AppendMenu(MF_GRAYED, 0, (LPCTSTR)strItem));
            }

            HMENU hSubmenu = submenu.Detach();
            ASSERT( NULL != hSubmenu );

            nFlags = MF_POPUP;
            nCommandID = (UINT_PTR)hSubmenu;
        }
		else
		{
			/*
			 * The command ID will be used as an index into vItemIDs,
			 * so the ID for this item is the size of the vector *before*
			 * the item is added to the vector.
			 */
			nCommandID = vItemIDs.size();
			vItemIDs.push_back (tid);
		}

        pFavs->GetItemName(tid, szName, countof(szName));
        VERIFY(menu.AppendMenu(nFlags, nCommandID, szName));

        // Get the next sibling.
        tid = pFavs->GetNextSiblingItem(tid);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\favui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favui.h
//
//--------------------------------------------------------------------------

// favui.h - favorites UI header

#ifndef _FAVUI_H_
#define _FAVUI_H_

#include "trobimpl.h"
#include "mmcres.h"

class CAddFavDialog : public CDialog
{
public:
    enum { IDD = IDD_ADDFAVORITE };

    CAddFavDialog(LPCTSTR szName, CFavorites* pFavorites, CWnd* pParent = NULL);
    ~CAddFavDialog();

    HRESULT CreateFavorite(CFavObject** ppfavRet);

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();

    afx_msg void OnAddFolder();
    afx_msg void OnChangeName();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_ADDFAVORITE);

    DECLARE_MESSAGE_MAP()

    CTreeObserverTreeImpl m_FavTree;
    CEdit           m_FavName;
    CFavorites*     m_pFavorites;
    LONG_PTR        m_lAdviseCookie;
    HRESULT         m_hr;
    CFavObject*     m_pfavItem;
    CString         m_strName;
};


class CAddFavGroupDialog : public CDialog
{
public:
    enum { IDD = IDD_NEWFAVFOLDER };

    CAddFavGroupDialog(CWnd* pParent);
    ~CAddFavGroupDialog();

    LPCTSTR GetGroupName() { return m_strName; }

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_NEWFAVFOLDER);

    DECLARE_MESSAGE_MAP()
    afx_msg void OnChangeName();

    CEdit   m_GrpName;
    TCHAR   m_strName[MAX_PATH];
};


class COrganizeFavDialog : public CDialog
{
public:
    enum { IDD = IDD_FAVORGANIZE };

    COrganizeFavDialog(CFavorites* pFavorites, CWnd* pParent = NULL);
    ~COrganizeFavDialog();

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();

    afx_msg void OnAddFolder();
    afx_msg void OnDelete();
    afx_msg void OnRename();
    afx_msg void OnMoveTo();
    afx_msg void OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult);
    afx_msg void OnBeginLabelEdit(NMHDR* pMNHDR, LRESULT* plResult);
    afx_msg void OnEndLabelEdit(NMHDR* pMNHDR, LRESULT* plResult);

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_FAVORGANIZE);

    DECLARE_MESSAGE_MAP()

    CTreeObserverTreeImpl m_FavTree;
    CStatic         m_FavName;
    CStatic         m_FavInfo;
    CFont           m_FontBold;
    CFavorites*     m_pFavorites;
    LONG_PTR        m_lAdviseCookie;
    BOOL            m_bRenameMode;
    TREEITEMID      m_tidRenameItem;
};


class CFavFolderDialog : public CDialog
{
public:
    enum { IDD = IDD_FAVSELECTFOLDER };

    CFavFolderDialog(CFavorites* pFavorites, CWnd* pParent);
    ~CFavFolderDialog();

    TREEITEMID GetFolderID() { return m_tidFolder; }

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_FAVSELECTFOLDER);

    DECLARE_MESSAGE_MAP()

    CTreeObserverTreeImpl m_FavTree;
    TREEITEMID      m_tidFolder;
    CFavorites*     m_pFavorites;
    LONG_PTR        m_lAdviseCookie;
};


// Container for CTreeObserverTreeImpl control which makes it a favorites
// tree viewer control. This class attaches the tree control to the
// favorites data source and handles all the necessart notifications from
// the tree control. It sends a MMC message to its parent whenever the tree
// selection changes.
// The primary purpose for this class is to provide a self-contained favorites
// viewer that the node manager can use in a non-MFC dialog.
class CFavTreeCtrl : public CWnd
{
private:
    /*
     * Make the ctor private so it's only accessible to CreateInstace.
     * That way, we can insure that instances of this class can only
     * be created in well-known ways (i.e. on the heap).  Using this
     * technique means that this class can't be used as a base class
     * or member of another class, but we can live with those restrictions.
     *
     * We need to go to this trouble because this class is used (only)
     * on the nodemgr side of things, in the Task Wizard.  It refers to
     * it only by handle (see CAMCView::ScCreateFavoriteObserver), and has
     * no access to this class, so it can't delete it.  If we make the
     * class self-deleting, everything's copasetic.
     */
    CFavTreeCtrl() {}

public:
    static CFavTreeCtrl* CreateInstance()
        { return (new CFavTreeCtrl); }

    SC ScInitialize(CFavorites* pFavorites, DWORD dwStyles);

    DECLARE_MESSAGE_MAP()

    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult);

    virtual void PostNcDestroy();

private:
    enum {IDC_FAVTREECTRL = 1000};

    CTreeObserverTreeImpl m_FavTree;
};


#endif // _FAVUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\filedlgex.h ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
#pragma once

// Windows 2000 version of OPENFILENAME.
// The new version has three extra members.
// This is copied from commdlg.h
//
struct OPENFILENAMEEX : public OPENFILENAME {
  void *        pvReserved;
  DWORD         dwReserved;
  DWORD         FlagsEx;
};

/////////////////////////////////////////////////////////////////////////////
// CFileDialogEx: Encapsulate Windows-2000 style open dialog.
//
class CFileDialogEx : public CFileDialog {
	DECLARE_DYNAMIC(CFileDialogEx)
public:
	CFileDialogEx(BOOL bOpenFileDialog, // TRUE for open, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

	// override
	virtual INT_PTR DoModal();

protected:
	OPENFILENAMEEX m_ofnEx;	// new Windows 2000 version of OPENFILENAME

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()
	//{{AFX_MSG(CFileDialogEx)
	//}}AFX_MSG
};

BOOL HasModernFileDialog();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\fontlink.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      fontlink.h
 *
 *  Contents:  Interface file for CFontLinker
 *
 *  History:   17-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef FONTLINK_H
#define FONTLINK_H
#pragma once

#include <string>
#include <mlang.h>
#include <comdef.h>


HFONT GetFontFromDC (HDC hdc);

class CRichText;


class CFontLinker
{
public:
    CFontLinker ();
    virtual ~CFontLinker ();

    LRESULT OnCustomDraw (NMCUSTOMDRAW* pnmcd);
    void ReleaseFonts ();
    bool ComposeRichText (CRichText& rt);

    IMultiLanguage* GetMultiLang ();
    IMLangFontLink* GetFontLink ();

    virtual bool IsAnyItemLocalizable () const
        { return (true); }

    virtual bool IsItemLocalizable (NMCUSTOMDRAW* pnmcd) const
        { return (true); }

    virtual UINT GetDrawTextFlags () const
        { return (DT_LEFT | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX | DT_SINGLELINE); }

    virtual std::wstring GetItemText (NMCUSTOMDRAW* pnmcd) const
        { return (L""); }

private:
    LRESULT OnCustomDraw_PrePaint     (NMCUSTOMDRAW* pnmcd);
    LRESULT OnCustomDraw_PostPaint    (NMCUSTOMDRAW* pnmcd);
    LRESULT OnCustomDraw_ItemPrePaint (NMCUSTOMDRAW* pnmcd);
    bool GetFontCodePages (HDC hdc, HFONT hFont, DWORD& dwFontCodePages);

    typedef std::set<HFONT>         FontSet;
    typedef std::map<HFONT, DWORD>  FontToCodePagesMap;

    FontSet             m_FontsToRelease;
    FontToCodePagesMap  m_CodePages;
    IMultiLanguagePtr   m_spMultiLang;
    IMLangFontLinkPtr   m_spFontLink;
	UINT				m_cPendingPostPaints;

    struct FontReleaser : public std::unary_function<HFONT, HRESULT>
    {
    public:
        FontReleaser (IMLangFontLink* pFontLink) : m_spFontLink (pFontLink) {}

        HRESULT operator() (HFONT hFont)
        {
            ASSERT (m_spFontLink != NULL);
            return (m_spFontLink->ReleaseFont (hFont));
        }

    private:
        IMLangFontLinkPtr const m_spFontLink;
    };
};


struct TextSegmentFontInfo
{
    HFONT   hFont;
    long    cch;
};


class CRichText
{
    friend class CFontLinker;

public:
    CRichText (HDC hdc, std::wstring strText)
        :   m_hdc          (hdc),
            m_strText      (strText),
            m_hDefaultFont (GetFontFromDC (hdc))
        {}

    ~CRichText ()
        {}

    bool IsDefaultFontSufficient () const
        { return (IsSingleFontSufficient() &&
                  GetSufficientFont() == m_hDefaultFont); }

    bool IsSingleFontSufficient () const
        { return (m_TextSegments.size() == 1); }

    HFONT GetSufficientFont () const
        { return (m_TextSegments.front().hFont); }

    bool Draw (
        LPCRECT rect,                       /* i:rect to draw in                */
        UINT    uFormat,                    /* i:DrawText format flags          */
        LPRECT  prectRemaining = NULL)      /* o:space remaining after drawing  */
        const;

private:
    typedef std::vector<TextSegmentFontInfo> TextSegmentFontInfoCollection;

    const HDC           m_hdc;
    const std::wstring  m_strText;
    const HFONT         m_hDefaultFont;

    TextSegmentFontInfoCollection m_TextSegments;
};


#endif /* FONTLINK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\ftab.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ftab.h
 *
 *  Contents:  Implementation file for CFolderTab, CFolderTabView
 *
 *  History:   06-May-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "ftab.h"
#include "amcview.h"
#include <oleacc.h>

/*
 * if we're supporting old platforms, we need to build MSAA stubs
 */
#if (_WINNT_WIN32 < 0x0500)
	#include <winable.h>
	
	#define COMPILE_MSAA_STUBS
	#include "msaastub.h"
	
	#define WM_GETOBJECT	0x003D
#endif


#ifdef DBG
CTraceTag  tagTabAccessibility (_T("Accessibility"), _T("Tab Control"));
#endif


/*+-------------------------------------------------------------------------*
 * ValueOf
 *
 * Returns the value contained in the given variant.  The variant is
 * expected to be of type VT_I4.
 *--------------------------------------------------------------------------*/

inline LONG ValueOf (VARIANT& var)
{
	ASSERT (V_VT (&var) == VT_I4);		// prevalidation is expected
	return (V_I4 (&var));
}


/*+-------------------------------------------------------------------------*
 * CTabAccessible
 *
 * Implements the accessibility interface IAccessible for CFolderTabView.
 *--------------------------------------------------------------------------*/

class CTabAccessible :
	public CMMCIDispatchImpl<IAccessible, &GUID_NULL, &LIBID_Accessibility>,
    public CTiedComObject<CFolderTabView>
{
    typedef CTabAccessible	ThisClass;
    typedef CFolderTabView	CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(ThisClass)
    END_MMC_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

public:
    // *** IAccessible methods ***
    MMC_METHOD1 (get_accParent,				IDispatch** /*ppdispParent*/);
    MMC_METHOD1 (get_accChildCount,			long* /*pChildCount*/);
    MMC_METHOD2 (get_accChild,				VARIANT /*varChildID*/, IDispatch ** /*ppdispChild*/);
    MMC_METHOD2 (get_accName,				VARIANT /*varChildID*/, BSTR* /*pszName*/);
    MMC_METHOD2 (get_accValue,				VARIANT /*varChildID*/, BSTR* /*pszValue*/);
    MMC_METHOD2 (get_accDescription,		VARIANT /*varChildID*/, BSTR* /*pszDescription*/);
    MMC_METHOD2 (get_accRole,				VARIANT /*varChildID*/, VARIANT */*pvarRole*/);
    MMC_METHOD2 (get_accState,				VARIANT /*varChildID*/, VARIANT */*pvarState*/);
    MMC_METHOD2 (get_accHelp,				VARIANT /*varChildID*/, BSTR* /*pszHelp*/);
    MMC_METHOD3 (get_accHelpTopic,			BSTR* /*pszHelpFile*/, VARIANT /*varChildID*/, long* /*pidTopic*/);
    MMC_METHOD2 (get_accKeyboardShortcut,	VARIANT /*varChildID*/, BSTR* /*pszKeyboardShortcut*/);
    MMC_METHOD1 (get_accFocus,				VARIANT * /*pvarFocusChild*/);
    MMC_METHOD1 (get_accSelection,			VARIANT * /*pvarSelectedChildren*/);
    MMC_METHOD2 (get_accDefaultAction,		VARIANT /*varChildID*/, BSTR* /*pszDefaultAction*/);
    MMC_METHOD2 (accSelect,					long /*flagsSelect*/, VARIANT /*varChildID*/);
    MMC_METHOD5 (accLocation,				long* /*pxLeft*/, long* /*pyTop*/, long* /*pcxWidth*/, long* /*pcyHeight*/, VARIANT /*varChildID*/);
    MMC_METHOD3 (accNavigate,				long /*navDir*/, VARIANT /*varStart*/, VARIANT * /*pvarEndUpAt*/);
    MMC_METHOD3 (accHitTest,				long /*xLeft*/, long /*yTop*/, VARIANT * /*pvarChildAtPoint*/);
    MMC_METHOD1 (accDoDefaultAction,		VARIANT /*varChildID*/);
    MMC_METHOD2 (put_accName,				VARIANT /*varChildID*/, BSTR /*szName*/);
    MMC_METHOD2 (put_accValue,				VARIANT /*varChildID*/, BSTR /*pszValue*/);
};



//############################################################################
//############################################################################
//
//  Implementation of class CFolderTabMetrics
//
//############################################################################
//############################################################################

CFolderTabMetrics::CFolderTabMetrics()
: m_dwStyle(0), m_textHeight(0)
{
}

int CFolderTabMetrics::GetXOffset()     const {return 8;}
int CFolderTabMetrics::GetXMargin()     const {return 2;}
int CFolderTabMetrics::GetYMargin()     const {return 1;}
int CFolderTabMetrics::GetYBorder()     const {return 1;}
int CFolderTabMetrics::GetExtraYSpace() const {return 0;}
int CFolderTabMetrics::GetTabHeight()   const {return GetTextHeight() + 2 * GetYMargin() + 2 * GetYBorder();}
int CFolderTabMetrics::GetUpDownWidth() const {return 2*GetTabHeight();} //for nice square buttons
int CFolderTabMetrics::GetUpDownHeight()const {return GetTabHeight();} // the up-down control is as tall as the tabs


//############################################################################
//############################################################################
//
//  Implementation of class CFolderTab
//
//############################################################################
//############################################################################

CFolderTab::CFolderTab()
{
}

CFolderTab::CFolderTab(const CFolderTab &other)
{
    *this = other;
}

CFolderTab &
CFolderTab::operator = (const CFolderTab &other)
{
    if((CFolderTab *) this == (CFolderTab *) &other)
       return *this;

    m_sText   = other.m_sText;
    m_rect    = other.m_rect;
    m_clsid   = other.m_clsid;
    m_dwStyle = other.m_dwStyle;
    m_textHeight = other.m_textHeight;

    return *this;
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::GetWidth
 *
 * PURPOSE: Returns the width of the tab.
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTab::GetWidth() const
{
    return m_rect.Width() + 1; // rect.Width() returns right-left, need to add 1 for inclusive width.
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::SetWidth
 *
 * PURPOSE:  Sets the width of the tab.
 *
 * PARAMETERS:
 *    int  nWidth :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTab::SetWidth(int nWidth)
{
    ASSERT(nWidth > 0);
    ASSERT(GetWidth() >= nWidth);

    int delta = nWidth - (m_rect.Width() + 1);
    m_rect.right = m_rect.left + nWidth -1;

    m_rgPts[2].x+=delta;
    m_rgPts[3].x+=delta;
    SetRgn();
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::Offset
 *
 * PURPOSE:     Adds a certain offset to the internal array of points.
 *
 * PARAMETERS:
 *    const  CPoint :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTab::Offset(const CPoint &point)
{
    m_rect.OffsetRect(point);
    m_rgPts[0].Offset(point);
    m_rgPts[1].Offset(point);
    m_rgPts[2].Offset(point);
    m_rgPts[3].Offset(point);
    m_rgn.OffsetRgn(point);
}

void
CFolderTab::SetRgn()
{
    m_rgn.DeleteObject();
    m_rgn.CreatePolygonRgn(m_rgPts, 4, WINDING);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::ComputeRgn
 *
 * PURPOSE: Compute the the points, rect and region for a tab.
 *          Input x is starting x pos.
 *
 * PARAMETERS:
 *    CDC& dc :
 *    int  x :
 *
 * RETURNS:
 *    int: The actual width of the tab
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTab::ComputeRgn(CDC& dc, int x)
{

    CRect& rc = m_rect;
    rc.SetRectEmpty();

    // calculate desired text rectangle
    dc.DrawText(m_sText, &rc, DT_CALCRECT);
    rc.right  += 2*GetXOffset() + 2*GetXMargin();                       // add margins
    rc.bottom = rc.top + GetTabHeight();
    rc += CPoint(x,0);                                                  // shift right

    // create region
    GetTrapezoid(rc, m_rgPts);
    SetRgn();

    return rc.Width();
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::GetTrapezoid
 *
 * PURPOSE: Given the bounding rect, compute trapezoid region.
 *          Note that the right and bottom edges not included in rect or
 *          trapezoid; these are normal rules of geometry.
 *
 * PARAMETERS:
 *    const   CRect :
 *    CPoint* pts :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CFolderTab::GetTrapezoid(const CRect& rc, CPoint* pts) const
{
    pts[0] = CPoint(rc.left,                  rc.top    );
    pts[1] = CPoint(rc.left + GetXOffset(),   rc.bottom );
    pts[2] = CPoint(rc.right- GetXOffset()-1, rc.bottom );
    pts[3] = CPoint(rc.right-1,               rc.top    );
}

//////////////////
// Draw tab in normal or highlighted state
//
int CFolderTab::Draw(CDC& dc, CFont& font, BOOL bSelected, bool bFocused)
{
    return DrawTrapezoidal(dc, font, bSelected, bFocused);
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::DrawTrapezoidal
 *
 * PURPOSE: Draws a trapezoidal tab.
 *
 * PARAMETERS:
 *    CDC&   dc :
 *    CFont& font :
 *    BOOL   bSelected :
 *    bool   bFocused :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int CFolderTab::DrawTrapezoidal(CDC& dc, CFont& font, BOOL bSelected, bool bFocused)
{
    COLORREF bgColor = GetSysColor(bSelected ? COLOR_WINDOW     : COLOR_3DFACE);
    COLORREF fgColor = GetSysColor(bSelected ? COLOR_WINDOWTEXT : COLOR_BTNTEXT);

    CBrush brush(bgColor);                   // background brush
    dc.SetBkColor(bgColor);                  // text background
    dc.SetTextColor(fgColor);                // text color = fg color

    CPen blackPen (PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    CPen shadowPen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));

    // Fill trapezoid
    CPoint pts[4];
    CRect rc = m_rect;
    GetTrapezoid(rc, pts);
    CPen* pOldPen = dc.SelectObject(&blackPen);
    dc.FillRgn(&m_rgn, &brush);

    // Draw edges. This is requires two corrections:
    // 1) Trapezoid dimensions don't include the right and bottom edges,
    // so must use one pixel less on bottom (cybottom)
    // 2) the endpoint of LineTo is not included when drawing the line, so
    // must add one pixel (cytop)
    //
    {
        pts[1].y--;         // correction #1: true bottom edge y-coord
        pts[2].y--;         // ...ditto
        pts[3].y--;         // correction #2:   extend final LineTo
    }
    dc.MoveTo(pts[0]);                      // upper left
    dc.LineTo(pts[1]);                      // bottom left
    dc.SelectObject(&shadowPen);            // bottom line is shadow color
    dc.MoveTo(pts[1]);                      // line is inside trapezoid bottom
    dc.LineTo(pts[2]);                      // ...
    dc.SelectObject(&blackPen);         // upstroke is black
    dc.LineTo(pts[3]);                      // y-1 to include endpoint
    if(!bSelected)
    {
        // if not highlighted, upstroke has a 3D shadow, one pixel inside
        pts[2].x--;     // offset left one pixel
        pts[3].x--;     // ...ditto
        dc.SelectObject(&shadowPen);
        dc.MoveTo(pts[2]);
        dc.LineTo(pts[3]);
    }
    dc.SelectObject(pOldPen);

    // draw text
    rc.DeflateRect(GetXOffset() + GetXMargin(), GetYMargin());
    CFont* pOldFont = dc.SelectObject(&font);
    dc.DrawText(m_sText, &rc, DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS);
    dc.SelectObject(pOldFont);

    if(bFocused) // draw the focus rectangle
    {
        // make some more space.
        rc.top--;
        rc.bottom++;
        rc.left--;
        rc.right++;

        dc.DrawFocusRect(&rc);
    }

    return m_rect.right;
}

//############################################################################
//############################################################################
//
//  Implementation of class CFolderTabView
//
//############################################################################
//############################################################################
IMPLEMENT_DYNAMIC(CFolderTabView, CView)
BEGIN_MESSAGE_MAP(CFolderTabView, CView)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEACTIVATE()
	ON_WM_KEYDOWN()
	ON_WM_SETTINGCHANGE()
	ON_WM_SIZE()
	ON_WM_HSCROLL()
	ON_MESSAGE(WM_GETOBJECT, OnGetObject)
END_MESSAGE_MAP()

CFolderTabView::CFolderTabView(CView *pParentView)
: m_bVisible(false), m_pParentView(pParentView)
{
    m_iCurItem   = -1;		// nothing currently selected
    m_dwStyle    = 0;
    m_textHeight = 0;
    m_sizeX      = 0;
    m_sizeY      = 0;
    m_hWndUpDown = NULL;
    m_nPos       = 0; // the first tab is the one drawn
	m_fHaveFocus = false;
}

CFolderTabView::~CFolderTabView()
{
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScFireAccessibilityEvent
 *
 * Fires accessibility events for the folder tab view
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScFireAccessibilityEvent (
	DWORD	dwEvent,					/* I:event to fire					*/
	LONG	idObject)					/* I:object generating the event	*/
{
	DECLARE_SC (sc, _T("CFolderTabView::ScFireAccessibilityEvent"));

	/*
	 * Accessibility events are fired after the event takes place (e.g.
	 * EVENT_OBJECT_CREATE is sent after the child is created, not before).
	 * Because of this the child ID for EVENT_OBJECT_DESTROY is not
	 * necessarily valid, so we shouldn't validate in that case.
	 */
	if (dwEvent != EVENT_OBJECT_DESTROY)
	{
		sc = ScValidateChildID (idObject);
		if (sc)
			return (sc);
	}

	NotifyWinEvent (dwEvent, m_hWnd, OBJID_CLIENT, idObject);	// returns void
	return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::OnHScroll
 *
 * PURPOSE: Called when the position of the scroll bar is changed
 *
 * PARAMETERS:
 *    UINT        nSBCode :
 *    UINT        nPos :
 *    CScrollBar* pScrollBar :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )
{
    // we're only interested in SB_THUMBPOSITION
    if(nSBCode != SB_THUMBPOSITION)
        return;

    // if the position has not changed, do nothing.
    if(nPos == m_nPos)
        return;

    m_nPos = nPos;  // change the position
    RecomputeLayout();
    InvalidateRect(NULL, true); // redraw everything.
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnSetFocus
 *
 * WM_SETFOCUS handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnSetFocus(CWnd* pOldWnd)
{
	m_fHaveFocus = true;

    InvalidateRect(NULL);
    BC::OnSetFocus(pOldWnd);

	/*
	 * If we have any tabs, one of them will get the focus.  Fire the
	 * focus accessibility event, ignoring errors.  We do this after
	 * calling the base class, so this focus event will override the
	 * "focus to the window" event sent by the system on our behalf.
	 */
	if (GetItemCount() > 0)
		ScFireAccessibilityEvent (EVENT_OBJECT_FOCUS, m_iCurItem+1 /*1-based*/);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnKillFocus
 *
 * WM_KILLFOCUS handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnKillFocus(CWnd* pNewWnd)
{
	m_fHaveFocus = false;

    InvalidateRect(NULL);
    BC::OnKillFocus(pNewWnd);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnMouseActivate
 *
 * WM_MOUSEACTIVATE handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

int CFolderTabView::OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message )
{
    //short-circuit the MFC base class code, which sets the keyboard focus here as well...
    return MA_ACTIVATE;
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnCmdMsg
 *
 * WM_COMMAND handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

BOOL CFolderTabView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (BC::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view didn't handle it, give parent view a chance
    if (m_pParentView != NULL)
        return static_cast<CWnd*>(m_pParentView)->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    else
        return FALSE;
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnKeyDown
 *
 * WM_KEYDOWN handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
{
    int cSize = m_tabList.size();

    if( (cSize == 0) || ( (nChar != VK_LEFT) && (nChar != VK_RIGHT) ) )
    {
        BC::OnKeyDown(nChar, nRepCnt, nFlags);
        return;
    }

    ASSERT( (nChar == VK_LEFT) || (nChar == VK_RIGHT) );

    int iNew = GetSelectedItem() + (nChar==VK_LEFT ? -1 : 1);
	if(iNew < 0)
		iNew = 0; // does not wrap

	if(iNew >= cSize)
		iNew = cSize -1; // does not wrap

    SelectItem(iNew, true /*bEnsureVisible*/);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    CView::OnSettingChange(uFlags, lpszSection);

    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        DeleteFonts ();
        CreateFonts ();
        InvalidateRect(NULL, true); // redraw everything.
        RecomputeLayout ();
    }
}

//////////////////
// Create folder tab control from static control.
// Destroys the static control. This is convenient for dialogs
//
BOOL CFolderTabView::CreateFromStatic(UINT nID, CWnd* pParent)
{
    CStatic wndStatic;
    if(!wndStatic.SubclassDlgItem(nID, pParent))
        return FALSE;
    CRect rc;
    wndStatic.GetWindowRect(&rc);
    pParent->ScreenToClient(&rc);
    wndStatic.DestroyWindow();
    rc.bottom = rc.top + GetDesiredHeight();
    return Create(WS_CHILD|WS_VISIBLE, rc, pParent, nID);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::Create
 *
 * PURPOSE: Creates the folder tab control
 *
 * PARAMETERS:
 *    DWORD  dwStyle :
 *    const  RECT :
 *    CWnd*  pParent :
 *    UINT   nID :
 *    DWORD  dwFtabStyle :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL CFolderTabView::Create(DWORD dwStyle, const RECT& rc,
                            CWnd* pParent, UINT nID, DWORD dwFtabStyle)
{
    ASSERT(pParent);
    ASSERT(dwStyle & WS_CHILD);

    m_dwStyle = dwFtabStyle;

    static LPCTSTR lpClassName = _T("AMCCustomTab");
    static BOOL bRegistered = FALSE; // registered?
    if(!bRegistered)
    {
        WNDCLASS wc;
        memset(&wc, 0, sizeof(wc));
        wc.lpfnWndProc = ::DefWindowProc; // will get hooked by MFC
        wc.hInstance = AfxGetInstanceHandle();
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = lpClassName;
        if(!AfxRegisterClass(&wc))
        {
            TRACE(_T("*** CFolderTabView::AfxRegisterClass failed!\n"));
            return FALSE;
        }
        bRegistered = TRUE;
    }
    if(!BC::CreateEx(0, lpClassName, NULL, dwStyle, rc, pParent, nID))
        return FALSE;

    // initialize fonts
    CreateFonts();

	/*
	 * Bug 141015:  Create a buddy window for the up-down control.  It will
	 * never be visible, but we need it so UDM_GETPOS sent to the up-down
	 * will work.  Narrator will send this message when the up-down becomes
	 * visible, but it will fail if there's no buddy (sad, but true).  It
	 * fails by returning an LRESULT with a non-zero high-order word
	 * (specifically, 0x00010000), so Narrator translates and announces
	 * "65536" instead of the true value.
	 *
	 * This is only required for Narrator support, so if it fails it's
	 * not sufficient reason to fail CFolderTabView creation altogether.
	 */
	HWND hwndBuddy = CreateWindow (_T("edit"), NULL, WS_CHILD, 0, 0, 0, 0,
								   m_hWnd, 0, AfxGetInstanceHandle(), NULL);

    // create the up-down control
    DWORD dwUpDownStyle = WS_CHILD | WS_BORDER |
						  UDS_SETBUDDYINT |		// for Narrator support
						  UDS_HORZ /*to display the arrows left to right*/; // NOTE: the control is created invisible on purpose.
    m_hWndUpDown = CreateUpDownControl(dwUpDownStyle, 0, 0,
                        GetUpDownWidth(),   //width
                        GetUpDownHeight(),  //height
                        m_hWnd,
                        1 /*nID*/,
                        AfxGetInstanceHandle(),
                        hwndBuddy,
                        0 /*nUpper*/,
                        0 /*nLower*/,
                        0 /*nPos*/);

    return TRUE;
}

void CFolderTabView::CreateFonts ()
{
    LOGFONT lf;
    SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);
    m_fontNormal.CreateFontIndirect(&lf);

    // Get the font height (converting from points to pixels)
    CClientDC dc(NULL);
    TEXTMETRIC tm;
	CFont *pFontOld = dc.SelectObject(&m_fontNormal);
    dc.GetTextMetrics(&tm);

    m_textHeight = tm.tmHeight;

	// set the old font back.
	dc.SelectObject(pFontOld);

    lf.lfWeight = FW_BOLD;
    m_fontSelected.CreateFontIndirect(&lf);
}

void CFolderTabView::DeleteFonts ()
{
    m_fontNormal.DeleteObject();
    m_fontSelected.DeleteObject();
}

//////////////////
// copy a font
//
static void CopyFont(CFont& dst, CFont& src)
{
    dst.DeleteObject();
    LOGFONT lf;
    VERIFY(src.GetLogFont(&lf));
    dst.CreateFontIndirect(&lf);
}

//////////////////
// Set normal, selected fonts
//
void CFolderTabView::SetFonts(CFont& fontNormal, CFont& fontSelected)
{
    CopyFont(m_fontNormal, fontNormal);
    CopyFont(m_fontSelected, fontSelected);
}

//////////////////
// Paint function
//

void CFolderTabView::OnDraw(CDC* pDC)
{
}

void CFolderTabView::OnPaint()
{
    Paint (m_fHaveFocus);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::EnsureVisible
 *
 * PURPOSE: Changes the layout to ensure that the specified tab is visible.
 *
 * NOTE:    Does NOT invalidate the rect, for efficiency.
 *
 * PARAMETERS:
 *    UINT  iTab :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::EnsureVisible(int iTab)
{
    if((iTab < 0) || (iTab > m_tabList.size()))
    {
        ASSERT(0 && "Should not come here.");
        return;
    }

    if(!::IsWindowVisible(m_hWndUpDown))
        return; // the up-down control is hidden, meaning that all tabs are visible

	RecomputeLayout(); // make sure we have the correct dimensions

	if(m_nPos == iTab)
		return; // the tab already shows as much as it can.

    if(m_nPos > iTab) // the first visible tab is to the right of iTab. Make iTab the first visible tab
    {
        m_nPos = iTab;
        RecomputeLayout();
        return;
    }

    iterator iter = m_tabList.begin();
    std::advance(iter, iTab); // get the correct item

    CRect rcCurTab = iter->GetRect();

    // loop: Increase the start tab position until the right edge of iTab fits.
    while((m_nPos < iTab) && (rcCurTab.right > m_sizeX))
    {
        m_nPos++;
        RecomputeLayout();
        rcCurTab = iter->GetRect();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::Paint
 *
 * PURPOSE: Completely redraws the tab control.
 *
 * PARAMETERS:
 *    bool  bFocused :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::Paint(bool bFocused)
{
    CPaintDC dc(this); // device context for painting

    CRect rc;
    GetClientRect(&rc);

    // draw all the normal (non-selected) tabs
    iterator iterSelected = m_tabList.end();
    int i = 0;
    bool bDraw = true;
    for(iterator iter= m_tabList.begin(); iter!= m_tabList.end(); ++iter, i++)
    {
        if(i!=m_iCurItem)
        {
            if(bDraw && iter->Draw(dc, m_fontNormal, FALSE, false) > rc.right)
                bDraw = false;
        }
        else
        {
            iterSelected = iter;
        }
    }

    ASSERT(iterSelected != m_tabList.end());

    /*
     * Bug 350942: selected tab shouldn't be bold
     */
    // draw selected tab last so it will be "on top" of the others
    iterSelected->Draw(dc, /*m_fontSelected*/ m_fontNormal, TRUE, bFocused);

    // draw border: line along the top edge, excluding seleted tab
    CPoint pts[4];
    CRect rcCurTab = iterSelected->GetRect();
    iterSelected->GetTrapezoid(&rcCurTab, pts);

    CPen blackPen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));

    CPen* pOldPen = dc.SelectObject(&blackPen);
    int y = pts[0].y;
    dc.MoveTo(rc.left,      y);
    dc.LineTo(pts[0].x,     y);
    dc.MoveTo(pts[3].x,     y);
    dc.LineTo(rc.right,     y);

    dc.SelectObject(pOldPen);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::OnLButtonDown
 *
 * PURPOSE: Selects the tab pointed to on a left mouse click
 *
 * PARAMETERS:
 *    UINT    nFlags :
 *    CPoint  pt :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    int iTab = HitTest(pt);
    if(iTab>=0 && iTab!=m_iCurItem)
    {
        SelectItem(iTab, true /*bEnsureVisible*/);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::HitTest
 *
 * PURPOSE: Computes which tab is at the specified point.
 *
 * PARAMETERS:
 *    CPoint  pt :
 *
 * RETURNS:
 *    int: The tab index, or -1 if none.
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::HitTest(CPoint pt)
{
    CRect rc;
    GetClientRect(&rc);
    if(rc.PtInRect(pt))
    {
        int i = 0;
        for( iterator iter= m_tabList.begin(); iter!= m_tabList.end(); ++iter, i++)
        {
            if(iter->HitTest(pt))
                return i;
        }
    }
    return -1;
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::SelectItem
 *
 * PURPOSE: Selects the iTab'th tab and returns the index of the tab selected,
 *          or -1 if an error occurred.
 *
 * PARAMETERS:
 *    int   iTab :
 *    bool  bEnsureVisible : If true, repositions the tab to make it visible.
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::SelectItem(int iTab, bool bEnsureVisible)
{
    if(iTab<0 || iTab>=GetItemCount())
        return -1;      // bad

    bool bSendTabChanged = (iTab != m_iCurItem); // send a message only if a different item got selected

    // repaint the control
    m_iCurItem = iTab;              // set new selected tab
    if(bEnsureVisible)
        EnsureVisible(iTab);
    else
        RecomputeLayout();

    InvalidateRect(NULL, true);

    if(bSendTabChanged)
    {
		/*
		 * If the selection changed, fire the selection accessibility event.
		 * We do it before sending FTN_TABCHANGED so that if the FTN_TABCHANGED
		 * handler selects another item, observers will get the selection
		 * events in the right order (ignore errors)
		 */
		ScFireAccessibilityEvent (EVENT_OBJECT_SELECTION, m_iCurItem+1 /*1-based*/);

		/*
		 * if our window has the focus, focus changes with selection,
		 * so send focus event, too (ignore errors)
		 */
		if (m_fHaveFocus)
			ScFireAccessibilityEvent (EVENT_OBJECT_FOCUS, m_iCurItem+1 /*1-based*/);

        // send the FTN_TABCHANGED message
        NMFOLDERTAB nm;
        nm.hwndFrom = m_hWnd;
        nm.idFrom = GetDlgCtrlID();
        nm.code = FTN_TABCHANGED;
        nm.iItem = iTab;
        CWnd* pParent = GetParent();
        pParent->SendMessage(WM_NOTIFY, nm.idFrom, (LPARAM)&nm);
    }

    return m_iCurItem;
}


int
CFolderTabView::SelectItemByClsid(const CLSID& clsid)
{
    bool bFound = false;
    int i=0;
    for(iterator iter= m_tabList.begin(); iter!= m_tabList.end(); ++iter, i++)
    {
        if(IsEqualGUID(iter->GetClsid(),clsid))
        {
            bFound = true;
            break;
        }
    }

    if(!bFound)
    {
        ASSERT(0 && "Invalid folder tab.");
        return -1;
    }

    return SelectItem(i);
}


CFolderTab &
CFolderTabView::GetItem(int iPos)
{
    ASSERT(!(iPos<0 || iPos>=GetItemCount()));

    CFolderTabList::iterator iter = m_tabList.begin();
    std::advance(iter, iPos);
    return *iter;
}


int CFolderTabView::AddItem(LPCTSTR lpszText, const CLSID& clsid)
{
    CFolderTab tab;
    tab.SetText(lpszText);
    tab.SetClsid(clsid);
    tab.SetStyle(m_dwStyle);
    tab.SetTextHeight(m_textHeight);

    m_tabList.push_back(tab);

    RecomputeLayout();
    InvalidateRect(NULL, true);

	int nNewItemIndex = m_tabList.size() - 1;	// 0-based

	/*
	 * tell observers we created a new tab, after it's been created (ignore errors)
	 */
	ScFireAccessibilityEvent (EVENT_OBJECT_CREATE, nNewItemIndex+1 /*1-based*/);

    return (nNewItemIndex);
}

BOOL CFolderTabView::RemoveItem(int iPos)
{
    if( (iPos < 0) || (iPos>= m_tabList.size()) )
        return false;

    CFolderTabList::iterator iter = m_tabList.begin();
    std::advance(iter, iPos);
    m_tabList.erase(iter);

	/*
	 * tell observers we destroyed a tab, after it's been destroyed but before
	 * we might send selection/focus notifications in SelectItem (ignore errors)
	 */
	ScFireAccessibilityEvent (EVENT_OBJECT_DESTROY, iPos+1 /*1-based*/);

	/*
	 * If we're deleting the currently selected tab, the selection needs to
	 * move somewhere else.  If there are tabs following the current one,
	 * we'll move the selection to the next tab; otherwise, we'll move to
	 * the previous one.
	 */
	if ((iPos == m_iCurItem) && !m_tabList.empty())
	{
		/*
		 * if there are tabs to the following the one we just deleted,
		 * increment m_iCurItem so the subsequent call to SelectItem
		 * will recognize that the selection change and send the proper
		 * notifications.
		 */
		if (m_iCurItem < m_tabList.size())
			m_iCurItem++;

		SelectItem (m_iCurItem-1, true /*bEnsureVisible*/);
	}
	else
	{
		/*
		 * if we deleted a tab before the selected tab, decrement the
		 * selected tab index to keep things in sync
		 * m_iCurItem will become -1 when the last tab is removed, which is correct
		 */
		if (iPos <= m_iCurItem)
			m_iCurItem--;

		InvalidateRect(NULL, true);
		RecomputeLayout();
	}

    return true;
}

void CFolderTabView::DeleteAllItems()
{
	const int cChildren = m_tabList.size();
    m_tabList.clear();
	m_iCurItem = -1;		// nothing is selected

    InvalidateRect(NULL, true);
    RecomputeLayout();

	/*
	 * Tell accessibility observers that each tab is destroyed.  Notify
	 * in last-to-first order so IDs remain sane during this process.
	 */
	for (int idChild = cChildren /*1-based*/; idChild >= 1; idChild--)
	{
		ScFireAccessibilityEvent (EVENT_OBJECT_DESTROY, idChild);
	}

	/*
	 * If we have the focus, tell accessibility observers that the
	 * control itself has the focus.  We do this to be consistent with
	 * other controls (like the list view)
	 */
	if (m_fHaveFocus)
		ScFireAccessibilityEvent (EVENT_OBJECT_FOCUS, CHILDID_SELF);
}

void CFolderTabView::OnSize(UINT nType, int cx, int cy)
{
    m_sizeX = cx;
    m_sizeY = cy;

    CView::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
	{
        RecomputeLayout();
	}

}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::ShowUpDownControl
 *
 * PURPOSE: Shows or hides the up/down control
 *
 * PARAMETERS:
 *    BOOL  bShow : true to show, false to hide.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::ShowUpDownControl(BOOL bShow)
{
    BOOL bVisible = (m_hWndUpDown != NULL) && ::IsWindowVisible(m_hWndUpDown); // was the up-down control visible previously?
    if(bShow)
    {
        if(!bVisible)
        {
            ::SendMessage(m_hWndUpDown, UDM_SETRANGE32, (WPARAM) 0 /*iLow*/, (LPARAM) m_tabList.size()-1 /*zero-based*/);
            ::SendMessage(m_hWndUpDown, UDM_SETPOS,     (WPARAM) 0,          (LPARAM) m_nPos /*nPos*/);
            ::ShowWindow(m_hWndUpDown, SW_SHOW);

            InvalidateRect(NULL, true);
        }
    }
    else
    {
        // hide the updown control
        if(m_hWndUpDown)
            ::ShowWindow(m_hWndUpDown, SW_HIDE);

        if(bVisible) // invalidate only on a transition from visible to invisible
            InvalidateRect(NULL, true);

		m_nPos = 0;
    }

}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::GetTotalTabWidth
 *
 * PURPOSE: Computes the total width of all the tabs.
 *
 * PARAMETERS:
 *    CClientDC& dc :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::GetTotalTabWidth(CClientDC& dc)
{
    int x = 0;

    // compute the width "as is", ie without taking into account the actual space available.
    for(iterator iter = m_tabList.begin(); iter!= m_tabList.end(); ++iter)
    {
        x += iter->ComputeRgn(dc, x) - GetXOffset();
    }

    return x;
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::ComputeRegion
 *
 * PURPOSE: Computes the location and regions for all the tabs
 *
 * PARAMETERS:
 *    CClientDC& dc :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::ComputeRegion(CClientDC& dc)
{
    int x = GetTotalTabWidth(dc);

    // subtract the top-left x coordinate of the m_nPos'th tab from all x coordinates, thereby creating a shift
    iterator iter = m_tabList.begin();
    std::advance(iter, m_nPos); // advance to the m_nPos'th tab

    int xOffset = iter->GetRect().left;

	x = GetUpDownWidth() - xOffset; // shift everything to the left by xOffset

    for(iterator iterTemp = m_tabList.begin(); iterTemp!= m_tabList.end(); ++iterTemp)
    {
        x += iterTemp->ComputeRgn(dc, x) - GetXOffset();
    }

    return x;
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::RecomputeLayout
 *
 * PURPOSE: Determines the location of all the tabs, and whether or not the
 *          up/down control should be displayed.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::RecomputeLayout()
{
	// set the size of the updown control
    if(m_hWndUpDown)
        ::SetWindowPos(m_hWndUpDown, NULL /*hWndInsertAfter*/, 0 /*left*/, 0 /*top*/,
                     GetUpDownWidth(), GetUpDownHeight(), SWP_NOMOVE| SWP_NOZORDER);

	// set the correct text height for the tabs
    for(iterator iterTemp = m_tabList.begin(); iterTemp!= m_tabList.end(); ++iterTemp)
		iterTemp->SetTextHeight(GetTextHeight());


    CClientDC dc(this);
    CFont* pOldFont = dc.SelectObject(&m_fontSelected); // use the bold font to compute with.

    int totalWidth = GetTotalTabWidth(dc); // the width of ALL tabs

    if(totalWidth <= m_sizeX)
    {
        // there's enough space to show all tabs. Hide the updown control
        ShowUpDownControl(false);
    }
    else
    {
        // not enough width for all tabs.
        BOOL bVisible = ::IsWindowVisible(m_hWndUpDown); // was the up-down control visible previously?

        if(!bVisible) // the up-down control was not visible, so make it visible.
        {
            m_nPos = 0;
            ShowUpDownControl(true);
        }

        ComputeRegion(dc); // make sure we leave space for the tab

    }

    dc.SelectObject(pOldFont);
}


void CFolderTabView::Layout(CRect& rectTotal, CRect& rectFTab)
{
    int cy = GetTabHeight() + GetExtraYSpace();
    rectFTab        = rectTotal;
    if(!IsVisible())
        return;

    rectFTab.top    = rectFTab.bottom - cy;
    rectTotal.bottom= rectFTab.top;
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnGetObject
 *
 * WM_GETOBJECT handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

LRESULT CFolderTabView::OnGetObject (WPARAM wParam, LPARAM lParam)
{
	DECLARE_SC (sc, _T("CFolderTabView::OnGetObject"));

	/*
	 * ignore requests for objects other than OBJID_CLIENT
	 */
    if (lParam != OBJID_CLIENT)
	{
		Trace (tagTabAccessibility, _T("WM_GETOBJECT: (lParam != OBJID_CLIENT), returning 0"));
		return (0);
	}

	/*
	 * create our accessibility object
	 */
    if ((sc = CTiedComObjectCreator<CTabAccessible>::ScCreateAndConnect(*this, m_spTabAcc)).IsError() ||
		(sc = ScCheckPointers (m_spTabAcc, E_UNEXPECTED)).IsError())
	{
		sc.TraceAndClear();
		Trace (tagTabAccessibility, _T("WM_GETOBJECT: error creating IAccessible object, returning 0"));
		return (0);
	}

	/*
	 * return a pointer to the IAccessible interface
	 */
	Trace (tagTabAccessibility, _T("WM_GETOBJECT: returning IAccessible*"));
    return (LresultFromObject (IID_IAccessible, wParam, m_spTabAcc));
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accParent
 *
 * Retrieves the IDispatch interface of the object's parent.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accParent(IDispatch ** ppdispParent)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accParent"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accParent"));

	sc = ScCheckPointers (ppdispParent);
	if(sc)
		return (sc);

	/*
	 * return the accessibility interface for the OBJID_WINDOW object
	 */
	sc = AccessibleObjectFromWindow (m_hWnd, OBJID_WINDOW, IID_IDispatch,
									 (void **)ppdispParent);
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accChildCount
 *
 * Retrieves the number of children belonging to this object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accChildCount(long* pChildCount)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accChildCount"));

	sc = ScCheckPointers (pChildCount);
	if(sc)
		return (sc);

	*pChildCount = GetItemCount();
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accChildCount: returning %d"), GetItemCount());

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accChild
 *
 * Retrieves the address of an IDispatch interface for the specified child.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accChild(VARIANT varChildID, IDispatch ** ppdispChild)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accChild"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accChild"));

	sc = ScCheckPointers (ppdispChild);
	if (sc)
		return (sc);

	// init out parameter
	(*ppdispChild) = NULL;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * all children are simple elements exposed through their parent,
	 * not accessible objects in their own right
	 */
	sc = S_FALSE;

	Trace (tagTabAccessibility, TEXT("returning parent's IDispatch for child %d"), ValueOf(varChildID));
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accName
 *
 * Retrieves the name of the specified object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accName(VARIANT varChildID, BSTR* pbstrName)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accName"));

	sc = ScCheckPointers (pbstrName);
	if(sc)
		return (sc);

	// init out parameter
	*pbstrName = NULL;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * the tab control itself doesn't have a name; otherwise, get the
	 * name of the requested tab
	 */
	LONG idChild = ValueOf (varChildID);
	if (idChild == CHILDID_SELF)
	{
		sc = S_FALSE;
	}
	else
	{
		CFolderTab& tab = GetItem (idChild-1);
		CComBSTR bstrName (tab.GetText());
		*pbstrName = bstrName.Detach();
	}

#ifdef DBG
	USES_CONVERSION;
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accName: child %d, returning \"%s\""),
		   idChild,
		   (*pbstrName) ? W2T(*pbstrName) : _T("<None>"));
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accValue
 *
 * Retrieves the value of the specified object. Not all objects have a value.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accValue(VARIANT varChildID, BSTR* pbstrValue)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accValue"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accValue"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * tabs don't have values
	 */
	sc = S_FALSE;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accDescription
 *
 * Retrieves a string that describes the visual appearance of the specified
 * object. Not all objects have a description.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accDescription(VARIANT varChildID, BSTR* pbstrDescription)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accDescription"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accDescription"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * tabs don't have descriptions
	 */
	sc = S_FALSE;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accRole
 *
 * Retrieves information that describes the role of the specified object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accRole(VARIANT varChildID, VARIANT *pvarRole)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accRole"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accRole"));

	sc = ScCheckPointers (pvarRole);
	if(sc)
		return (sc);

	// init out parameter
	VariantInit (pvarRole);

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * the tab control has a "page tab list" role; an individual tab has a
	 * "page tab" role
	 */
	V_VT(pvarRole) = VT_I4;
	V_I4(pvarRole) = (ValueOf (varChildID) == CHILDID_SELF)
						? ROLE_SYSTEM_PAGETABLIST
						: ROLE_SYSTEM_PAGETAB;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accState
 *
 * Retrieves the current state of the specified object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accState(VARIANT varChildID, VARIANT *pvarState)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accState"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	LONG idChild = ValueOf (varChildID);

	/*
	 * all items are focusable
	 */
	V_VT(pvarState) = VT_I4;
	V_I4(pvarState) = STATE_SYSTEM_FOCUSABLE;

	/*
	 * is this for a tab?
	 */
	if (idChild != CHILDID_SELF)
	{
		/*
		 * all tabs are selectable
		 */
		V_I4(pvarState) |= STATE_SYSTEM_SELECTABLE;

		/*
		 * if this is the selected item, give it the selected state
		 */
		if ((idChild - 1 /*1-based*/) == GetSelectedItem())
		{
			V_I4(pvarState) |= STATE_SYSTEM_SELECTED;

			/*
			 * if the tab control also has the focus, give the selected
			 * item the focused state as well
			 */
			if (m_fHaveFocus)
				V_I4(pvarState) |= STATE_SYSTEM_FOCUSED;
		}
	}
	else
	{
		if (m_fHaveFocus)
			V_I4(pvarState) |= STATE_SYSTEM_FOCUSED;
	}

	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accState: child %d, returning 0x%08x"), idChild, V_I4(pvarState));
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accHelp
 *
 * Retrieves an object's Help property string. Not all objects need to
 * support this property.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accHelp(VARIANT varChildID, BSTR* pbstrHelp)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accHelp"));

	sc = ScCheckPointers (pbstrHelp);
	if (sc)
		return (sc);

	/*
	 * no help
	 */
	*pbstrHelp = NULL;

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accHelpTopic
 *
 * Retrieves the full path of the WinHelp file associated with the specified
 * object and the identifier of the appropriate topic within that file. Not
 * all objects need to support this property.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChildID, long* pidTopic)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accHelpTopic"));

	sc = ScCheckPointers (pbstrHelpFile, pidTopic);
	if (sc)
		return (sc);

	/*
	 * no help topic
	 */
	*pbstrHelpFile = NULL;
	*pidTopic      = 0;

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accKeyboardShortcut
 *
 * Retrieves the specified object's shortcut key or access key (also known
 * as the mnemonic). All objects that have a shortcut key or access key
 * should support this property.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accKeyboardShortcut(VARIANT varChildID, BSTR* pbstrKeyboardShortcut)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accKeyboardShortcut"));

	sc = ScCheckPointers (pbstrKeyboardShortcut);
	if (sc)
		return (sc);

	/*
	 * no shortcut keys
	 */
	*pbstrKeyboardShortcut = NULL;

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accFocus
 *
 * Retrieves the object that has the keyboard focus.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accFocus(VARIANT * pvarFocusChild)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accFocus"));

	sc = ScCheckPointers (pvarFocusChild);
	if (sc)
		return (sc);

	/*
	 * if we have the focus, return the (1-based) ID of the selected tab;
	 * otherwise, return VT_EMPTY
	 */
	if (m_fHaveFocus)
	{
		V_VT(pvarFocusChild) = VT_I4;
		V_I4(pvarFocusChild) = GetSelectedItem() + 1;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accFocus: returning %d"), V_I4(pvarFocusChild));
	}
	else
	{
		V_VT(pvarFocusChild) = VT_EMPTY;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accFocus: returning VT_EMPTY"));
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accSelection
 *
 * Retrieves the selected children of this object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accSelection(VARIANT * pvarSelectedChildren)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accSelection"));

	sc = ScCheckPointers (pvarSelectedChildren);
	if (sc)
		return (sc);

	/*
	 * return the (1-based) ID of the selected tab, if there is one
	 */
	if (GetSelectedItem() != -1)
	{
		V_VT(pvarSelectedChildren) = VT_I4;
		V_I4(pvarSelectedChildren) = GetSelectedItem() + 1;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accSelection: returning %d"), V_I4(pvarSelectedChildren));
	}
	else
	{
		V_VT(pvarSelectedChildren) = VT_EMPTY;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accSelection: returning VT_EMPTY"));
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accDefaultAction
 *
 * Retrieves a string that describes the object's default action. Not all
 * objects have a default action.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accDefaultAction(VARIANT varChildID, BSTR* pbstrDefaultAction)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accDefaultAction"));

	sc = ScCheckPointers (pbstrDefaultAction);
	if (sc)
		return (sc);

	/*
	 * default to "no default action"
	 */
	*pbstrDefaultAction = NULL;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * individual tabs have a default action of "Switch", just like WC_TABCONTROL
	 */
	if (ValueOf(varChildID) != CHILDID_SELF)
	{
		CString strDefaultAction (MAKEINTRESOURCE (IDS_TabAccessiblity_DefaultAction));
		CComBSTR bstrDefaultAction (strDefaultAction);

		*pbstrDefaultAction = bstrDefaultAction.Detach();
	}
	else
	{
		sc = S_FALSE;	// no default action
	}

#ifdef DBG
	USES_CONVERSION;
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accDefaultAction: child %d, returning \"%s\""),
		   ValueOf(varChildID),
		   (*pbstrDefaultAction) ? W2T(*pbstrDefaultAction) : _T("<None>"));
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccSelect
 *
 * Modifies the selection or moves the keyboard focus of the specified
 * object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccSelect(long flagsSelect, VARIANT varChildID)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccSelect"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccSelect"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	LONG idChild = ValueOf(varChildID);

	/*
	 * can't select the tab control itself, only child elements
	 */
	if (idChild == CHILDID_SELF)
		return (sc = E_INVALIDARG);

	/*
	 * the tab control doesn't support multiple selection, so reject
	 * requests dealing with multiple selection
	 */
	const long lInvalidFlags = SELFLAG_EXTENDSELECTION	|
							   SELFLAG_ADDSELECTION		|
							   SELFLAG_REMOVESELECTION;

	if (flagsSelect & lInvalidFlags)
		return (sc = E_INVALIDARG);

	/*
	 * activate this view, if we're requested to take the focus
	 */
	if (flagsSelect & SELFLAG_TAKEFOCUS)
	{
		CFrameWnd* pFrame = GetParentFrame();
		sc = ScCheckPointers (pFrame, E_FAIL);
		if (sc)
			return (sc);

		pFrame->SetActiveView (this);
	}

	/*
	 * select the given tab, if requested
	 */
	if (flagsSelect & SELFLAG_TAKESELECTION)
	{
		if (SelectItem (idChild - 1 /*0-based*/, true /*bEnsureVisible*/) == -1)
			return (sc = E_FAIL);
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccLocation
 *
 * Retrieves the specified object's current screen location.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccLocation (
	long*	pxLeft,
	long*	pyTop,
	long*	pcxWidth,
	long*	pcyHeight,
	VARIANT	varChildID)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccLocation"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccLocation"));

	sc = ScCheckPointers (pxLeft, pyTop, pcxWidth, pcyHeight);
	if(sc)
		return (sc);

	// init out parameters
	*pxLeft = *pyTop = *pcxWidth = *pcyHeight = 0;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	LONG idChild = ValueOf(varChildID);
	CRect rectLocation;

	/*
	 * for the tab control itself, get the location of the entire window
	 */
	if (idChild == CHILDID_SELF)
		GetWindowRect (rectLocation);

	/*
	 * otherwise, get the rectangle of the tab and convert it to screen coords
	 */
	else
	{
		rectLocation = GetItem(idChild-1).GetRect();
		MapWindowPoints (NULL, rectLocation);
	}

	*pxLeft    = rectLocation.left;
	*pyTop     = rectLocation.top;
	*pcxWidth  = rectLocation.Width();
	*pcyHeight = rectLocation.Height();

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccNavigate
 *
 * Traverses to another user interface element within a container and if
 * possible, retrieves the object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccNavigate (long lNavDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccNavigate"));

	sc = ScCheckPointers (pvarEndUpAt);
	if (sc)
		return (sc);

	// init out parameters
	VariantInit (pvarEndUpAt);

	sc = ScValidateChildID (varStart);
	if (sc)
		return (sc);

	LONG idFrom = ValueOf (varStart);
	LONG idTo   = -1;

	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccNavigate: start=%d, direction=%d"), idFrom, lNavDir);

	switch (lNavDir)
	{
		case NAVDIR_UP:
		case NAVDIR_DOWN:
			/*
			 * the tab control doesn't have the concept of up and down,
			 * so there's no screen element in that direction; just leave
			 * idTo == -1 and the code below the switch will take care
			 * of the rest
			 */
			break;

		case NAVDIR_FIRSTCHILD:
		case NAVDIR_LASTCHILD:
			/*
			 * NAVDIR_FIRSTCHILD and NAVDIR_LASTCHILD must be relative
			 * to CHILDID_SELF
			 */
			if (idFrom != CHILDID_SELF)
				return (sc = E_INVALIDARG);

			idTo = (lNavDir == NAVDIR_FIRSTCHILD) ? 1 : GetItemCount();
            break;

		case NAVDIR_LEFT:
		case NAVDIR_PREVIOUS:
			/*
			 * if we're moving relative to a child element, bump idTo;
			 * if not, just leave idTo == -1 and the code below the switch
			 * will take of the rest
			 */
			if (idFrom != CHILDID_SELF)
				idTo = idFrom - 1;
            break;

		case NAVDIR_RIGHT:
		case NAVDIR_NEXT:
			/*
			 * if we're moving relative to a child element, bump idTo;
			 * if not, just leave idTo == -1 and the code below the switch
			 * will take of the rest
			 */
			if (idFrom != CHILDID_SELF)
				idTo = idFrom + 1;
            break;

		default:
			return (sc = E_INVALIDARG);
			break;
	}

	/*
	 * if we're trying to navigate to an invalid child ID, return "no element
	 * in that direction"
	 */
	if ((idTo < 1) || (idTo > GetItemCount()))
	{
		V_VT(pvarEndUpAt) = VT_EMPTY;
		sc                = S_FALSE;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccNavigate: VT_EMPTY"));
	}

	/*
	 * otherwise return the new child ID (don't change the selection here;
	 * the client will call IAccessible::accSelect to do that)
	 */
	else
	{
		V_VT(pvarEndUpAt) = VT_I4;
		V_I4(pvarEndUpAt) = idTo;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccNavigate: end=%d"), idTo);
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccHitTest
 *
 * Retrieves the child element or child object at a given point on the screen.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccHitTest (long x, long y, VARIANT* pvarChildAtPoint)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccHitTest"));

	sc = ScCheckPointers (pvarChildAtPoint);
	if(sc)
		return (sc);

	// init out parameters
	VariantInit (pvarChildAtPoint);

	/*
	 * hit-test the given point, converted to client coordinates
	 */
	CPoint pt (x, y);
	ScreenToClient (&pt);
	int nHitTest = HitTest (pt);
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccHitTest: x=%d y=%d"), x, y);

	/*
	 * not on a tab?  see if it's within the client rect
	 */
	if (nHitTest == -1)
	{
		CRect rectClient;
		GetClientRect (rectClient);

		if (rectClient.PtInRect (pt))
		{
			V_VT(pvarChildAtPoint) = VT_I4;
			V_I4(pvarChildAtPoint) = CHILDID_SELF;
		}
		else
		{
			V_VT(pvarChildAtPoint) = VT_EMPTY;
			sc                     = S_FALSE;		// no element there
		}
	}

	/*
	 * otherwise, it is on a tab; return the 1-based ID
	 */
	else
	{
		V_VT(pvarChildAtPoint) = VT_I4;
		V_I4(pvarChildAtPoint) = nHitTest + 1;
	}

#ifdef DBG
	if (V_VT(pvarChildAtPoint) == VT_I4)
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccHitTest: returning %d"), ValueOf (*pvarChildAtPoint));
	else
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccHitTest: returning VT_EMPTY"));
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccDoDefaultAction
 *
 * Performs the specified object's default action. Not all objects have a
 * default action.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccDoDefaultAction (VARIANT varChildID)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccDoDefaultAction"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * the tab control doesn't have a default action
	 */
	LONG idChild = ValueOf (varChildID);
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccDoDefaultAction: child %d"), idChild);
	if (idChild == CHILDID_SELF)
		return (sc = E_INVALIDARG);

	/*
	 * select the given tab item
	 */
	if (SelectItem (idChild - 1 /*0-based*/, true /*bEnsureVisible*/) == -1)
		return (sc = E_FAIL);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scput_accName
 *
 * This is no longer supported. The SetWindowText or control-specific APIs
 * should be used in place of this method.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scput_accName(VARIANT varChildID, BSTR bstrName)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scput_accName"));

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = E_NOTIMPL);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scput_accValue
 *
 * This is no longer supported. Control-specific APIs should be used in
 * place of this method.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scput_accValue(VARIANT varChildID, BSTR bstrValue)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scput_accValue"));

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = E_NOTIMPL);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScValidateChildID
 *
 * Determines if the supplied variant represents a valid child ID.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScValidateChildID (VARIANT &var)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScValidateChildID"));

	/*
	 * child IDs must be VT_I4's
	 */
	if (V_VT(&var) != VT_I4)
		return (sc = E_INVALIDARG);

	return (ScValidateChildID (ValueOf(var)));
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScValidateChildID
 *
 * Determines if the supplied ID is valid child ID.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScValidateChildID (LONG idChild)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScValidateChildID"));

	/*
	 * child ID must be either CHILDID_SELF or a valid tab index
	 */
	if ((idChild < CHILDID_SELF) || (idChild > GetItemCount()))
		return (sc = E_INVALIDARG);

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\filedlgex.cpp ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Largely based on original implementation by Michael Lemley.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
// CFileDialogEx implements a CFileDialog that uses the new Windows
// 2000 style open/save dialog. Use companion class CDocManagerEx in an
// MFC framework app.
//
#include "stdafx.h"
#include <afxpriv.h>
#include "FileDlgEx.h"

IMPLEMENT_DYNAMIC(CFileDialogEx, CFileDialog)

CFileDialogEx::CFileDialogEx(BOOL bOpenFileDialog, LPCTSTR lpszDefExt,
	LPCTSTR lpszFileName, DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
	CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
		dwFlags, lpszFilter, pParentWnd)
{
}


BEGIN_MESSAGE_MAP(CFileDialogEx, CFileDialog)
	//{{AFX_MSG_MAP(CFileDialogEx)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*+-------------------------------------------------------------------------*
 * HasModernFileDialog
 *
 * Returns true if the system we're running on supports the "modern" file
 * open/save dialog (i.e. the one with the places bar).  Systems that
 * qualify are Win2K and higher, and WinMe and higher.
 *--------------------------------------------------------------------------*/

BOOL HasModernFileDialog()
{
	OSVERSIONINFO osvi = { sizeof(osvi) };

	if (!GetVersionEx (&osvi))
		return (false);

	switch (osvi.dwPlatformId)
	{
		// detect Win2K+
		case VER_PLATFORM_WIN32_NT:
			if (osvi.dwMajorVersion >= 5)
				return (true);
			break;

		// detect WinMe+
		case VER_PLATFORM_WIN32_WINDOWS:
			if ( (osvi.dwMajorVersion >= 5) ||
				((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion >= 90)))
				return (true);
			break;
	}

	return (false);
}

//////////////////
// DoModal override copied mostly from MFC, with modification to use
// m_ofnEx instead of m_ofn.
//
INT_PTR CFileDialogEx::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
	ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook

	// zero out the file buffer for consistent parsing later
	ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
	DWORD nOffset = lstrlen(m_ofn.lpstrFile)+1;
	ASSERT(nOffset <= m_ofn.nMaxFile);
	memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));

	// WINBUG: This is a special case for the file open/save dialog,
	//  which sometimes pumps while it is coming up but before it has
	//  disabled the main window.
	HWND hWndFocus = ::GetFocus();
	BOOL bEnableParent = FALSE;
	m_ofn.hwndOwner = PreModal();
	AfxUnhookWindowCreate();
	if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
	{
		bEnableParent = TRUE;
		::EnableWindow(m_ofn.hwndOwner, FALSE);
	}

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);

	if (m_ofn.Flags & OFN_EXPLORER)
		pThreadState->m_pAlternateWndInit = this;
	else
		AfxHookWindowCreate(this);

	memset(&m_ofnEx, 0, sizeof(m_ofnEx));
	memcpy(&m_ofnEx, &m_ofn, sizeof(m_ofn));
   if (HasModernFileDialog())
	   m_ofnEx.lStructSize = sizeof(m_ofnEx);

	int nResult;
	if (m_bOpenFileDialog)
		nResult = ::GetOpenFileName((OPENFILENAME*)&m_ofnEx);
	else
		nResult = ::GetSaveFileName((OPENFILENAME*)&m_ofnEx);

	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

	if (nResult)
		ASSERT(pThreadState->m_pAlternateWndInit == NULL);
	pThreadState->m_pAlternateWndInit = NULL;

	// WINBUG: Second part of special case for file open/save dialog.
	if (bEnableParent)
		::EnableWindow(m_ofnEx.hwndOwner, TRUE);
	if (::IsWindow(hWndFocus))
		::SetFocus(hWndFocus);

	PostModal();
	return nResult ? nResult : IDCANCEL;
}

//////////////////
// When the open dialog sends a notification, copy m_ofnEx to m_ofn in
// case handler function is expecting updated information in the
// OPENFILENAME struct.
//
BOOL CFileDialogEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

   return CFileDialog::OnNotify( wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\fontlink.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      fontlink.cpp
 *
 *  Contents:  Implementation file for CFontLinker
 *
 *  History:   17-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "fontlink.h"
#include "macros.h"

#ifdef DBG
CTraceTag  tagFontlink (_T("Font Linking"), _T("Font Linking"));
#endif


/*+-------------------------------------------------------------------------*
 * GetFontFromDC
 *
 * Returns the font that's currently selected into a DC
 *--------------------------------------------------------------------------*/

HFONT GetFontFromDC (HDC hdc)
{
    HFONT hFont = (HFONT) SelectObject (hdc, GetStockObject (SYSTEM_FONT));
    SelectObject (hdc, hFont);

    return (hFont);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::CFontLinker
 *
 *
 *--------------------------------------------------------------------------*/

CFontLinker::CFontLinker ()
{
	m_cPendingPostPaints = 0;
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::~CFontLinker
 *
 *
 *--------------------------------------------------------------------------*/

CFontLinker::~CFontLinker ()
{
	ASSERT (m_cPendingPostPaints == 0);
    ReleaseFonts();
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::ReleaseFonts
 *
 * Releases all fonts returned by IMLangFontLink
 *--------------------------------------------------------------------------*/

void CFontLinker::ReleaseFonts()
{
    /*
     * release the fonts
     */
    std::for_each (m_FontsToRelease.begin(), m_FontsToRelease.end(),
                   FontReleaser (GetFontLink()));

    /*
     * purge the caches
     */
    m_FontsToRelease.clear();
    m_CodePages.clear();

}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw
 *
 * NM_CUSTOMDRAW handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw (NMCUSTOMDRAW* pnmcd)
{
    switch (pnmcd->dwDrawStage & ~CDDS_SUBITEM)
    {
        case CDDS_PREPAINT:     return (OnCustomDraw_PrePaint     (pnmcd));
        case CDDS_POSTPAINT:    return (OnCustomDraw_PostPaint    (pnmcd));
        case CDDS_ITEMPREPAINT: return (OnCustomDraw_ItemPrePaint (pnmcd));
    }

    return (CDRF_DODEFAULT);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw_PrePaint
 *
 * NM_CUSTOMDRAW (CDDS_PREPAINT) handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw_PrePaint (NMCUSTOMDRAW* pnmcd)
{
	m_cPendingPostPaints++;		// this line must be before the Trace
    Trace (tagFontlink, _T("(0x%08X) PrePaint(%d):---------------------------------------------------------"), this, m_cPendingPostPaints);

	/*
	 * Under certain rare, timing-dependent circumstances (see bug 96465),
	 * we can get nested calls to custom draw from the listview control.
	 * If this is not a nested custom draw, our font and codepage collections
	 * should be empty.
	 */
	if (m_cPendingPostPaints == 1)
	{
		ASSERT (m_FontsToRelease.empty());
		ASSERT (m_CodePages.empty());
	}

	/*
	 * we always need a CDDS_POSTPAINT so we can keep our accounting correct
	 */
	LRESULT rc = CDRF_NOTIFYPOSTPAINT;

    /*
     * get draw notifications for each item and subitem if any items
	 * are localizable
     */
    if (IsAnyItemLocalizable())
        rc |= CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYSUBITEMDRAW;

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw_PostPaint
 *
 * NM_CUSTOMDRAW (CDDS_POSTPAINT) handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw_PostPaint (NMCUSTOMDRAW* pnmcd)
{
    Trace (tagFontlink, _T("(0x%08X) PostPaint(%d):--------------------------------------------------------"), this, m_cPendingPostPaints);
	m_cPendingPostPaints--;		// this line must be after the Trace

	/*
	 * if this is the final CDDS_POSTPAINT we'll get, release our fonts
	 */
	if (m_cPendingPostPaints == 0)
	{
		Trace (tagFontlink, _T("(0x%08X) releasing fonts..."), this);
		ReleaseFonts ();
	}

    return (CDRF_DODEFAULT);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw_ItemPrePaint
 *
 * NM_CUSTOMDRAW (CDDS_ITEMPAINT) handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw_ItemPrePaint (NMCUSTOMDRAW* pnmcd)
{
    /*
     * if this item isn't localizable, do the default thing
     */
    if (!IsItemLocalizable (pnmcd))
        return (CDRF_DODEFAULT);

#ifdef DBG
    USES_CONVERSION;
    TCHAR pszPrefix[80];
	wsprintf (pszPrefix, _T("(0x%08X) ItemPrePaint:  "), this);
    LOGFONT lf;
    HFONT hFont;

    hFont = GetFontFromDC (pnmcd->hdc);
    GetObject (hFont, sizeof (lf), &lf);

    Trace (tagFontlink, _T("%sdefault font = (face=%s, weight=%d)"),
         pszPrefix, lf.lfFaceName, lf.lfWeight);

    /*
     * compute all of the fonts needed for this;
     * if we couldn't, do the default thing
     */
    Trace (tagFontlink, _T("%s    text = \"%s\""),
         pszPrefix, W2CT (GetItemText(pnmcd).data()));
#endif

    CRichText rt (pnmcd->hdc, GetItemText (pnmcd));

    if (!ComposeRichText (rt))
    {
        Trace (tagFontlink, _T("%s    unable to determine font, using default"), pszPrefix);
        return (CDRF_DODEFAULT);
    }

    /*
     * if the default font in the DC is sufficient, do the default thing
     */
    if (rt.IsDefaultFontSufficient ())
    {
        Trace (tagFontlink, _T("%s    default font is sufficient"), pszPrefix);
        return (CDRF_DODEFAULT);
    }

    /*
     * if the default font isn't sufficient, but there's a single
     * font that is, select it into the DC and let the control draw
     * the text
     */
    if (rt.IsSingleFontSufficient ())
    {
#ifdef DBG
        hFont = rt.GetSufficientFont();
        GetObject (hFont, sizeof (lf), &lf);
        Trace (tagFontlink, _T("%s    using single font = (face=%s, weight=%d)"),
             pszPrefix, lf.lfFaceName, lf.lfWeight);
#endif

        SelectObject (pnmcd->hdc, rt.GetSufficientFont());
        return (CDRF_NEWFONT);
    }

    /*
     * TODO: handle drawing the icon and indented text
     */
    Trace (tagFontlink, _T("%s    (punting...)"), pszPrefix);
    return (CDRF_DODEFAULT);

    /*
     * if we get here, two or more fonts are required to draw the
     * text; draw it ourselves, and tell the control not to do anything
     */
    rt.Draw (&pnmcd->rc, GetDrawTextFlags());
    return (CDRF_SKIPDEFAULT);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::ComposeRichText
 *
 * Computes all of the fonts required to draw a given Unicode string
 *--------------------------------------------------------------------------*/

bool CFontLinker::ComposeRichText (CRichText& rt)
{
    /*
     * get the code pages for the given DC's font
     */
    DWORD dwDefaultFontCodePages;

    if (!GetFontCodePages (rt.m_hdc, rt.m_hDefaultFont, dwDefaultFontCodePages))
        return (false);

    IMLangFontLink* pFontLink = GetFontLink();
    if (pFontLink == NULL)
        return (false);

    const LPCWSTR pszText = rt.m_strText.data();
    const int     cchText = rt.m_strText.length();
    int   cchDone = 0;
    DWORD dwPriorityCodePages = NULL;

    /*
     * build up the collection of TextSegmentFontInfos for the text
     */
    while (cchDone < cchText)
    {
        TextSegmentFontInfo tsfi;
        DWORD dwTextCodePages;

        /*
         * find out which code pages support the next segment of text
         */
        pFontLink->GetStrCodePages (pszText + cchDone,
                                    cchText - cchDone,
                                    dwPriorityCodePages,
                                    &dwTextCodePages, &tsfi.cch);

        /*
         * if the default font can render the text, things are easy
         */
        if (dwDefaultFontCodePages & dwTextCodePages)
            tsfi.hFont = rt.m_hDefaultFont;

        /*
         * otherwise, ask IFontLink for the font to use
         */
        else
        {
            /*
             * get the font
             */
            if (FAILED (pFontLink->MapFont (rt.m_hdc, dwTextCodePages,
                                            rt.m_hDefaultFont, &tsfi.hFont)))
            {
                rt.m_TextSegments.clear();
                return (false);
            }

            /*
             * add this font to the set of fonts to release when we're done
             */
            std::pair<FontSet::iterator, bool> rc =
                            m_FontsToRelease.insert (tsfi.hFont);

            /*
             * if it was already there, release it now to keep
             * the ref counts right
             */
            if (!rc.second)
                pFontLink->ReleaseFont (tsfi.hFont);
        }

        rt.m_TextSegments.push_back (tsfi);
        cchDone += tsfi.cch;
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::GetMultiLang
 *
 *
 *--------------------------------------------------------------------------*/

IMultiLanguage* CFontLinker::GetMultiLang ()
{
    if (m_spMultiLang == NULL)
        m_spMultiLang.CreateInstance (CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER);

    return (m_spMultiLang);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::GetFontLink
 *
 *
 *--------------------------------------------------------------------------*/

IMLangFontLink* CFontLinker::GetFontLink ()
{
    if (m_spFontLink == NULL)
        m_spFontLink = GetMultiLang ();

    return (m_spFontLink);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::GetFontCodePages
 *
 * Returns a bit mask representing the code pages supported by the font.
 *--------------------------------------------------------------------------*/

bool CFontLinker::GetFontCodePages (
    HDC     hdc,
    HFONT   hFont,
    DWORD&  dwFontCodePages)
{
    /*
     * check the code page cache to see if we've
     * asked MLang about this font before
     */
    FontToCodePagesMap::const_iterator itCodePages = m_CodePages.find (hFont);

    if (itCodePages != m_CodePages.end())
    {
        dwFontCodePages = itCodePages->second;
        return (true);
    }

    /*
     * this font isn't in our code page cache yet;
     * ask MLang for the code pages
     */
    IMLangFontLink* pFontLink = GetFontLink();

    if (pFontLink == NULL)
        return (false);

    if (FAILED (pFontLink->GetFontCodePages (hdc, hFont, &dwFontCodePages)))
        return (false);

    /*
     * put the code pages in the cache
     */
    m_CodePages[hFont] = dwFontCodePages;

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CRichText::Draw
 *
 *
 *--------------------------------------------------------------------------*/

bool CRichText::Draw (
    LPCRECT rect,                       /* i:rect to draw in                */
    UINT    uFormat,                    /* i:DrawText format flags          */
    LPRECT  prectRemaining /*=NULL*/)   /* o:space remaining after drawing  */
    const
{
    HFONT   hOriginalFont = GetFontFromDC (m_hdc);
    CRect   rectDraw      = rect;
    LPCWSTR pszDraw       = m_strText.data();

    TextSegmentFontInfoCollection::const_iterator it = m_TextSegments.begin();

    /*
     * draw each segment
     */
    while (it != m_TextSegments.end())
    {
        /*
         * select the font for this segment
         */
        SelectObject (m_hdc, it->hFont);

        /*
         * measure the width of this segment
         */
        CRect rectMeasure = rectDraw;
        DrawTextW (m_hdc, pszDraw, it->cch, rectMeasure, uFormat | DT_CALCRECT);

        /*
         * draw this segment
         */
        DrawTextW (m_hdc, pszDraw, it->cch, rectDraw, uFormat);

        /*
         * set up for the next segment
         */
        pszDraw      += it->cch;
        rectDraw.left = rectMeasure.right;
        ++it;

        /*
         * if we've run out of rect to draw in, short out
         */
        if (rectDraw.IsRectEmpty ())
            break;
    }

    /*
     * if the caller wants it, return the remaining rectangle after drawing
     */
    if (prectRemaining != NULL)
        *prectRemaining = rectDraw;

    /*
     * re-select the original font
     */
    SelectObject (m_hdc, hOriginalFont);
    return (true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\ftab.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ftab.h
 *
 *  Contents:  Interface file for CFolderTab, CFolderTabView
 *
 *  History:   06-May-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/
#ifndef FTAB_H
#define FTAB_H

class CFolderTabMetrics
{
public:
                CFolderTabMetrics();
    int         GetXOffset()     const;
    int         GetXMargin()     const;
    int         GetYMargin()     const;      // top/bottom text margin.
    int         GetYBorder()     const;      // top border thickness.
    int         GetTextHeight()  const      { return m_textHeight;}
    int         GetExtraYSpace() const;
    int         GetTabHeight()   const;
    int         GetUpDownWidth() const;
    int         GetUpDownHeight()const;


    void        SetStyle(DWORD dwStyle)     { m_dwStyle = dwStyle;}
    void        SetTextHeight(int textHeight){ m_textHeight = textHeight;}


protected:
    DWORD       m_dwStyle;
    int         m_textHeight;                // height, in pixels, of the text in a rectangle.

};

/*+-------------------------------------------------------------------------*
 * class CFolderTab
 *
 *
 * PURPOSE: Encapsulates a single tab on the tab control
 *
 *+-------------------------------------------------------------------------*/
class CFolderTab : public CFolderTabMetrics
{
private:
    CString     m_sText; // tab text
    CRect       m_rect;         // bounding rect
    CRgn        m_rgn;          // polygon region to fill (trapezoid)
    CLSID       m_clsid;
    CPoint      m_rgPts[4];

    void        SetRgn();           // called by ComputeRgn() and SetWidth()
    int         ComputeRgn(CDC& dc, int x);
    int         Draw           (CDC& dc, CFont& font, BOOL bSelected, bool bFocused);
    int         DrawTrapezoidal(CDC& dc, CFont& font, BOOL bSelected, bool bFocused);

    BOOL        HitTest(CPoint pt)          { return m_rgn.PtInRegion(pt);}
    const CRect& GetRect() const            { return m_rect;}
    void        GetTrapezoid(const CRect& rc, CPoint* pts) const;
    int         GetWidth() const;
    void        SetWidth(int nWidth);
    void        Offset(const CPoint &point);

    friend class CFolderTabView;

public:
    CFolderTab();
    CFolderTab(const CFolderTab &other);
    CFolderTab &operator = (const CFolderTab &other);
    void    SetText(LPCTSTR lpszText)   { m_sText = lpszText; }
    LPCTSTR GetText() const             { return m_sText;}
    void    SetClsid(const CLSID& clsid){ m_clsid = clsid;}
    CLSID   GetClsid()                  { return m_clsid;}
};

enum
{
    FTN_TABCHANGED = 1
};                 // notification: tab changed

struct NMFOLDERTAB : public NMHDR
{      // notification struct
    int iItem;                                       // item index
    const CFolderTab* pItem;                     // ptr to data, if any
};

/*+-------------------------------------------------------------------------*
 * CFolderTabView
 *
 *
 * PURPOSE: Provides an Excel-like tab control
 *
 *+-------------------------------------------------------------------------*/
class CFolderTabView :
	public CView,
	public CFolderTabMetrics,
	public CTiedObject
{
    typedef  CView  BC;
    typedef  std::list<CFolderTab> CFolderTabList;
    typedef  CFolderTabList::iterator  iterator;


protected:
    CFolderTabList  m_tabList;                    // array of CFolderTabs
    int             m_iCurItem;                  // current selected tab
    CFont           m_fontNormal;                // current font, normal ntab
    CFont           m_fontSelected;              // current font, selected tab
    CView *         m_pParentView;
    bool            m_bVisible;
	bool			m_fHaveFocus;
    int             m_sizeX;
    int             m_sizeY;
    HWND            m_hWndUpDown;               // the up-down control
    int             m_nPos;                     // the first tab displayed
	CComPtr<IAccessible>	m_spTabAcc;			// the CTabAccessible object

    // helpers
    void DrawTabs(CDC& dc, const CRect& rc);

    void CreateFonts();
    void DeleteFonts();

public:
    CFolderTabView(CView *pParentView);
    virtual ~CFolderTabView();

    BOOL CreateFromStatic(UINT nID, CWnd* pParent);

    virtual BOOL Create(DWORD dwWndStyle, const RECT& rc,
                        CWnd* pParent, UINT nID, DWORD dwFtabStyle=0);

    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );

    void        Layout (CRect& rectTotal, CRect& rectFTab);
    CFolderTab &GetItem(int iPos);
    int         GetSelectedItem()       { return m_iCurItem;}
    int         GetItemCount()          { return m_tabList.size();}
    int         GetDesiredHeight()      { return GetSystemMetrics(SM_CYHSCROLL);}
    BOOL        AddItem(LPCTSTR lpszText, const CLSID& clsid);
    BOOL        RemoveItem(int iPos);
    void        DeleteAllItems();
    void        RecomputeLayout();
    int         HitTest(CPoint pt);
    int         SelectItem(int iTab, bool bEnsureVisible = false);
    int         SelectItemByClsid(const CLSID& clsid);
    void        SetFonts(CFont& fontNormal, CFont& fontSelected);
    void        SetVisible(bool bVisible) {m_bVisible = bVisible;}
    bool        IsVisible()             { return m_bVisible;}

public:
    // *** IAccessible methods ***
    SC Scget_accParent				(IDispatch** ppdispParent);
    SC Scget_accChildCount			(long* pChildCount);
    SC Scget_accChild				(VARIANT varChildID, IDispatch ** ppdispChild);
    SC Scget_accName				(VARIANT varChildID, BSTR* pszName);
    SC Scget_accValue				(VARIANT varChildID, BSTR* pszValue);
    SC Scget_accDescription			(VARIANT varChildID, BSTR* pszDescription);
    SC Scget_accRole				(VARIANT varChildID, VARIANT *pvarRole);
    SC Scget_accState				(VARIANT varChildID, VARIANT *pvarState);
    SC Scget_accHelp				(VARIANT varChildID, BSTR* pszHelp);
    SC Scget_accHelpTopic			(BSTR* pszHelpFile, VARIANT varChildID, long* pidTopic);
    SC Scget_accKeyboardShortcut	(VARIANT varChildID, BSTR* pszKeyboardShortcut);
    SC Scget_accFocus				(VARIANT * pvarFocusChild);
    SC Scget_accSelection			(VARIANT * pvarSelectedChildren);
    SC Scget_accDefaultAction		(VARIANT varChildID, BSTR* pszDefaultAction);
    SC ScaccSelect					(long flagsSelect, VARIANT varChildID);
    SC ScaccLocation				(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChildID);
    SC ScaccNavigate				(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    SC ScaccHitTest					(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    SC ScaccDoDefaultAction			(VARIANT varChildID);
    SC Scput_accName				(VARIANT varChildID, BSTR szName);
    SC Scput_accValue				(VARIANT varChildID, BSTR pszValue);

private:
    void        ShowUpDownControl(BOOL bShow);
    void        EnsureVisible(int iTab);
    int         ComputeRegion(CClientDC& dc);
    int         GetTotalTabWidth(CClientDC& dc);

	SC			ScFireAccessibilityEvent (DWORD dwEvent, LONG idObject);
	SC			ScValidateChildID (VARIANT &var);
	SC			ScValidateChildID (LONG id);

protected:
            void Paint(bool bFocused);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnPaint();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg int  OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message );
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
    afx_msg void OnHScroll(NMHDR *nmhdr, LRESULT *pRes);
    afx_msg LRESULT OnGetObject(WPARAM wParam, LPARAM lParam);

    DECLARE_DYNAMIC(CFolderTabView);
    DECLARE_MESSAGE_MAP()
};


#endif // FTAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\histlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       histlist.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "histlist.h"
#include "cstr.h"
#include "amcmsgid.h"
#include "websnk.h"
#include "webctrl.h"

//############################################################################
//############################################################################
//
//  Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagHistory(TEXT("History"), TEXT("History"));

LPCTSTR SzHistoryEntryType(CHistoryEntry &entry)
{
    if(entry.IsListEntry())
        return TEXT("ListView");

    else if(entry.IsOCXEntry())
        return TEXT("OCXView ");

    else if(entry.IsWebEntry())
        return TEXT("WebView ");

    else
        ASSERT(0 && "Should not come here");
        return TEXT("Illegal entry");
}

#define TraceHistory(Name, iter)                                                                                           \
        {                                                                                                                  \
            USES_CONVERSION;                                                                                               \
            Trace(tagHistory, TEXT("%s hNode = %d, %s, viewMode = %d, strOCX = \"%s\" iterator = %d "), \
                Name, iter->hnode, SzHistoryEntryType(*iter), iter->viewMode,                                         \
                TEXT(""), (LPARAM) &*iter);                                             \
        }

#else  // DBG

#define TraceHistory(Name, iter)

#endif // DBG


//############################################################################
//############################################################################
//
//  Implementation of class CHistoryEntry
//
//############################################################################
//############################################################################

bool
CHistoryEntry::operator == (const CHistoryEntry &other) const
{
    if( hnode != other.hnode)
        return false;

    if( guidTaskpad != other.guidTaskpad)
        return false;

    if(resultViewType != other.resultViewType) // NOTE: implement operator == for CResultViewType.
        return false;

    return true;
}

bool
CHistoryEntry::operator != (const CHistoryEntry &other) const
{
    return !operator == (other);
}


//############################################################################
//############################################################################
//
//  Implementation of class CHistoryList
//
//############################################################################
//############################################################################


CHistoryList::CHistoryList(CAMCView* pAMCView)
: m_bBrowserBackEnabled(false),
  m_bBrowserForwardEnabled(false),
  m_pWebViewCtrl(NULL),
  m_bPageBreak(false),
  m_bWithin_CHistoryList_Back(false),
  m_bWithin_CHistoryList_Forward(false)
{
    m_pView = pAMCView;
    m_iterCurrent  = m_entries.begin();
    m_navState    = MMC_HISTORY_READY; // not busy

}
CHistoryList::~CHistoryList()
{
}


SC
CHistoryList::ScOnPageBreak()
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScOnPageBreak"));

    // handle recursion
    if(MMC_HISTORY_PAGE_BREAK == m_navState)
    {
        Trace(tagHistory, _T("OnPageBreak() - while inserting pagebreak"));

        m_navState = MMC_HISTORY_READY;
        return sc;
    }

    bool bHandled = false;
    if(m_bCurrentStateIsForward)
    {
        Trace(tagHistory, _T("OnPageBreak() - while going Forward"));
        Forward(bHandled, false);
    }
    else
    {
        Trace(tagHistory, _T("OnPageBreak() - while going Back"));
        Back(bHandled, false);
    }

    if(!bHandled)
    {
        Trace(tagHistory, _T("OnPageBreak() - unhandled, passing back to web browser"));
        m_bCurrentStateIsForward ? GetWebViewCtrl()->Forward() : GetWebViewCtrl()->Back();
    }

    return sc;
}

void
CHistoryList::OnPageBreakStateChange(bool bPageBreak)
{
    m_bPageBreak = bPageBreak;
    return;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::OnBrowserStateChange
 *
 * PURPOSE:     Callback that receives events from the IE control that the
 *              forward/back button needs to be enabled/disabled. A
 *              combination of this information with any non-HTML states in the
 *              history list is used to enable/disable the actual UI.
 *
 * PARAMETERS:
 *    bool  bForward :
 *    bool  bEnable :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::OnBrowserStateChange(bool bEnableForward, bool bEnableBack)
{
#if DBG
    CStr strTrace;
    strTrace.Format(_T("OnBrowserStateChange() - bEnableForward = %s, bEnableBack = %s"),
                    bEnableForward ? _T("true") : _T("false"), 
                    bEnableBack  ? _T("true") : _T("false"));
    Trace(tagHistory, strTrace);
#endif

    // handle the forward case.
    if(m_bBrowserForwardEnabled && !bEnableForward && !m_bPageBreak)
    {
        // the button was originally enabled but is now disabled.
        // This means that the user branched forward. So we need to throw away
        // any history ahead of the present time.
        if(m_iterCurrent != m_entries.end())
        {
            iterator iterTemp = m_iterCurrent;
            TraceHistory(TEXT("CHistoryList::Deleting all subsequent entries after"), iterTemp);
            ++iterTemp;
            m_entries.erase(iterTemp, m_entries.end());
        }
    }

    m_bBrowserForwardEnabled = bEnableForward;
    m_bBrowserBackEnabled    = bEnableBack;

    MaintainWebBar();
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::IsFirst
 *
 * PURPOSE:
 *
 * RETURNS:
 *    BOOL: TRUE if we should not light up the "Back" button.
 *
 *+-------------------------------------------------------------------------*/
BOOL
CHistoryList::IsFirst()
{
    return (m_iterCurrent == m_entries.begin());
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::IsLast
 *
 * PURPOSE:
 *
 * RETURNS:
 *    BOOL : TRUE if we should not light up the "Forward" button
 *
 *+-------------------------------------------------------------------------*/
BOOL
CHistoryList::IsLast()
{
    // see notes above
    if(m_iterCurrent == m_entries.end())
        return TRUE;

    // find next unique entry, if any
    iterator iter = m_iterCurrent;
    ++iter;            // this must exist, we've already taken care of the end case.
    return(iter == m_entries.end());
}

SC
CHistoryList::ScDoPageBreak()
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScDoPageBreak"));

    sc = ScCheckPointers(GetWebViewCtrl());
    if(sc)
        return sc;

    Trace(tagHistory, _T("ScDoPageBreak()"));

    // navigate to the "break" page.
    m_navState = MMC_HISTORY_PAGE_BREAK;


    CStr strResultPane;
    sc = ScGetPageBreakURL (strResultPane);
	if (sc)
		return (sc);

    GetWebViewCtrl()->Navigate(strResultPane, NULL);

    //wait for the navigate to complete.
    while (1)
    {
        READYSTATE state;
        sc = GetWebViewCtrl()->ScGetReadyState (state);
        if (sc)
            return (sc);

        if ((state == READYSTATE_COMPLETE) || (state == READYSTATE_LOADED))
            break;

        MSG msg;

        if(!GetMessage( &msg, NULL, 0, 0 )) // the WM_QUIT message.
        {
            PostQuitMessage (msg.wParam);
            return sc;
        }

		// If it is view close message make sure it gets posted (async) again.
		if ( (msg.message == WM_SYSCOMMAND) && (msg.wParam == SC_CLOSE))
		{
			// Make sure the message is intended for this view.
			CWnd *pWnd = m_pView->GetParent();
			if ( msg.hwnd == pWnd->GetSafeHwnd())
			{
				// DeleteView does PostMessage(WM_SYSCOMMAND, SC_CLOSE)
				m_pView->DeleteView();
				return sc;
			}
		}

        TranslateMessage( &msg );
        DispatchMessage( &msg );
     }

    // m_navState = MMC_HISTORY_READY; // don't set the here. Will be set in OnPageBreak().

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScAddEntry
 *
 * PURPOSE: Adds a history entry
 *
 * PARAMETERS:
 *    CResultViewType & rvt :
 *    int               viewMode:       The list view mode (large icon, etc)
 *    GUID &            guidTaskpad :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScAddEntry(CResultViewType &rvt, int viewMode, GUID &guidTaskpad)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScAddEntry"));

    if(m_navState != MMC_HISTORY_READY)
    {
#ifdef DBG
        CHistoryEntry entry;
        entry.viewMode = viewMode;
        entry.resultViewType = rvt;
        entry.guidTaskpad = guidTaskpad;
        TraceHistory(TEXT("CHistoryList::Busy-RejectEntry"), (&entry));
#endif //DBG
        MaintainWebBar();
        return sc;
    }

    BOOL bIsWebEntry = rvt.HasWebBrowser();

    // must be in the MMC_HISTORY_READY state at this point, ie not busy.
    // figure out current node
    HNODE hnode = m_pView->GetSelectedNode();
    if(hnode == NULL)
        return sc; // not initialized yet

   /*  if selection change includes the web page (either as 'from' or 'to' node)
    *  we need to perform proper separation of the webentries by inserting the pagebreaks.
    *  This is to be done to ensure 2 goals:
    *   - to detect when navigation should leave the IE history and use MMC history navigation
    *   - to ensure we always leave IE only after navigating to a pagebreak - to stop the
    *     scripts on the page as soon as we hide it. to achieve that we need pagebreaks
    *     before every web page and after every web page.
    *
    *  to do so we need one of the following:
    *
    *  1. Add a pagebreak (used when selection changes from the web page to non-web view)
    *  2. Add a pagebreak and navigate 
    *       (a. when selection changes from web page to another web page)
    *       (b. when selection changes from non-web view to the webpage 
    *        and it is the first web page in the history)
    *  3. Navigate only. ( when selection changes from non-web view to the 
    *       webpage [except #2.b case] - pagebreak had to be added when leaving the 
    *       previous web page)
    *
    *   inverting the said will result in:
    *   - add a pagebreak if :
    *       C1: web page is a 'from' node (#1. and #2.a.)
    *       C2: web page is a 'to' node 
    *        && no previous web pages 
    *        && 'from' node is a non-web view (#2.b)
    *   - navigate to web page if:
    *       C3: "to' node is the web page
    */

    // see if we were in the web before this
    // Note: both following variables may be false (in case it there are no entries)
    bool bPreviousPageWasWeb = (m_entries.size() != 0) && m_iterCurrent->IsWebEntry();
    bool bPreviousPageWasNonWeb = (m_entries.size() != 0) && !bPreviousPageWasWeb;

    // see if we need a pagebreak
    bool bNeedAPageBreak = false;
    if ( bPreviousPageWasWeb ) 
    {
        // condition C1 in the comment above
        bNeedAPageBreak = true;
    }
    else if ( bIsWebEntry && !PreviousWebPagesExist() && bPreviousPageWasNonWeb ) 
    {
        // condition C2 in the comment above
        bNeedAPageBreak = true;
    }

    // conditions C1 || C2 || C3 in the comment above
    if (bIsWebEntry || bNeedAPageBreak) 
    {
        USES_CONVERSION;
        LPCTSTR szURL = bIsWebEntry ? (OLE2CT( rvt.GetURL() )) : NULL;
        sc = m_pView->ScAddPageBreakAndNavigate (bNeedAPageBreak, bIsWebEntry, szURL); 
        if(sc)
            return sc;
    }

    DeleteSubsequentEntries();

    // add an entry to the end of the list.
    CHistoryEntry entry;
    ZeroMemory(&entry, sizeof(entry));
    m_entries.push_back(entry);
    m_iterCurrent = m_entries.end();
    --m_iterCurrent;        // points to the newly inserted item.

    m_iterCurrent->viewMode       = viewMode;
    m_iterCurrent->guidTaskpad    = guidTaskpad;
    m_iterCurrent->hnode          = hnode;
    m_iterCurrent->resultViewType = rvt;

    TraceHistory(TEXT("CHistoryList::AddEntry"), m_iterCurrent);

    Compact();
    MaintainWebBar();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::DeleteSubsequentEntries
 *
 * PURPOSE: When a new entry is inserted, all subsequent entries need to be
 *          deleted, because a new branch has been taken.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::DeleteSubsequentEntries()
{
    if(m_iterCurrent == m_entries.end())
        return; // nothing to do.

    iterator iterTemp = m_iterCurrent;
    ++iterTemp;

    while(iterTemp != m_entries.end())
    {
        iterator iterNext = iterTemp;
        ++iterNext; // point to the next element.

        TraceHistory(TEXT("CHistoryList::DeleteSubsequentEntries"), iterTemp);

        m_entries.erase(iterTemp);
        iterTemp = iterNext;
    }

    // the current entry must be the last at this stage.
    #ifdef DBG
    {
        iterator iterTemp = m_iterCurrent;
        ++iterTemp;
        ASSERT(iterTemp == m_entries.end());
    }
    #endif

}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::Back
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    bool & bHandled :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CHistoryList::Back(bool &bHandled, bool bUseBrowserHistory)
{
    Trace(tagHistory, TEXT("Back()"));

    // change the state to indicate we are navigating back.
    // and assure it is reset on function exit
    m_bWithin_CHistoryList_Back = true;
    CAutoAssignOnExit<bool, false> auto_reset( m_bWithin_CHistoryList_Back );

    // if we're in browser mode AND
    // if the back button is enabled by the browser use browser history.
    m_bCurrentStateIsForward = false;
    if( (m_iterCurrent->IsWebEntry()) && bUseBrowserHistory)
    {
        if(m_bBrowserBackEnabled)
        {
            Trace(tagHistory, TEXT("Back() web entry - not handling"));
            bHandled = false;
            return S_OK;
        }
    }

    bHandled = true;

    // BOGUS assert - amcview calls Back when ALT <- is pressed
    // regardless of the state of the button.
    //ASSERT (m_iterCurrent != m_entries.begin());
    if(m_iterCurrent == m_entries.begin())
        return S_FALSE;

    --m_iterCurrent;

    HRESULT hr = ExecuteCurrent();
    if(FAILED(hr))
        return hr;

    if(m_iterCurrent->IsWebEntry())
    {
        if(m_bPageBreak)      // if we're at a page break, go past it.
        {
            Trace(tagHistory, TEXT("Back() - stepped on the pagebreak"));
            bHandled = false; // this tells the caller to use the Browser's Back button.
        }
    }

    return hr;
}


/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::Forward
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    bool & bHandled :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CHistoryList::Forward(bool &bHandled, bool bUseBrowserHistory)
{
    // change the state to indicate we are navigating forward.
    // and assure it is reset on function exit
    m_bWithin_CHistoryList_Forward = true;
    CAutoAssignOnExit<bool, false> auto_reset( m_bWithin_CHistoryList_Forward );

    // if we're in browser mode AND
    // if the forward button is enabled by the browser use browser history.
    m_bCurrentStateIsForward = true;
    if( (m_iterCurrent->IsWebEntry()) && bUseBrowserHistory)
    {
        if(m_bBrowserForwardEnabled)
        {
            bHandled = false;
            return S_OK;
        }
    }

    bHandled = true;

    // BOGUS assert - amcview calls Forward when ALT -> is pressed
    //  regardless of the state of the Forward button.
    //ASSERT (m_iterCurrent != m_entries.end());
    if(m_iterCurrent == m_entries.end())
        return S_FALSE;

    ++m_iterCurrent;

    if(m_iterCurrent == m_entries.end())
        return S_FALSE;

    HRESULT hr = ExecuteCurrent();
    if(FAILED(hr))
        return hr;

    if(m_iterCurrent->IsWebEntry())
    {
        if(m_bPageBreak)      // if we're at a page break, go past it.
            bHandled = false; // this tells the caller to use the Browser's Forward button.
    }

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ExecuteCurrent
 *
 * PURPOSE: Sets the state of MMC to that of the current History entry. Called
 *          by Back() and Forward().
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CHistoryList::ExecuteCurrent()
{
    DECLARE_SC(sc, TEXT("CHistoryList::ExecuteCurrent"));
    INodeCallback* pNC = m_pView->GetNodeCallback();
    MTNODEID id;

    TraceHistory(TEXT("CHistoryList::ExecuteCurrent"), m_iterCurrent);

    pNC->GetMTNodeID (m_iterCurrent->hnode, &id);
    m_navState = MMC_HISTORY_NAVIGATING;

    // store values to local variables to avoid losing them
    // when an entry is removed from history
    GUID guidTaskpad = m_iterCurrent->guidTaskpad;
    bool bIsListEntry = m_iterCurrent->IsListEntry();
    DWORD viewMode = m_iterCurrent->viewMode;

    m_pView->SelectNode (id, guidTaskpad);

    if(bIsListEntry)
    {
        sc = m_pView->ScChangeViewMode(viewMode);
        if (sc)
            sc.TraceAndClear();
    }

    m_navState = MMC_HISTORY_READY;

    MaintainWebBar();
    return sc.ToHr();
}

void CHistoryList::MaintainWebBar()
{
    bool bWebEntry = ((m_entries.size() != 0) && m_iterCurrent->IsWebEntry());

    UpdateWebBar ( HB_BACK,    ( bWebEntry && m_bBrowserBackEnabled    ) || !IsFirst());    // back
    UpdateWebBar ( HB_FORWARD, ( bWebEntry && m_bBrowserForwardEnabled ) || !IsLast () );   // forward
}

void CHistoryList::UpdateWebBar (HistoryButton button, BOOL bOn)
{
    DECLARE_SC (sc, _T("CHistoryList::UpdateWebBar"));

    if (NULL == m_pView)
    {
        sc = E_UNEXPECTED;
        return;
    }

    CStandardToolbar* pStandardToolbar = m_pView->GetStdToolbar();
    if (NULL == pStandardToolbar)
    {
        sc = E_UNEXPECTED;
        return;
    }

    switch (button)
    {
    case HB_BACK:
        sc = pStandardToolbar->ScEnableButton(IDS_MMC_WEB_BACK, bOn);
        break;
    case  HB_STOP:
        sc = pStandardToolbar->ScEnableButton(IDS_MMC_WEB_STOP, bOn);
        break;
    case  HB_FORWARD:
        sc = pStandardToolbar->ScEnableButton(IDS_MMC_WEB_FORWARD, bOn);
        break;
    }

}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScGetCurrentResultViewType
 *
 * PURPOSE: Returns the current history entry.
 *
 * PARAMETERS:
 *    CResultViewType & rvt :
 *    int&              viewMode :
 *    GUID &            guidTaskpad :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScGetCurrentResultViewType (CResultViewType &rvt, int& viewMode, GUID &guidTaskpad)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScGetCurrentResultViewType"));

    if(m_iterCurrent == m_entries.end())
        return (sc = E_FAIL); // should never happen

    rvt         = m_iterCurrent->resultViewType;
    viewMode    = m_iterCurrent->viewMode;
    guidTaskpad = m_iterCurrent->guidTaskpad;

    return sc;
}

void CHistoryList::SetCurrentViewMode (long nViewMode)
{
    if(m_navState != MMC_HISTORY_READY)
        return;
    if(m_iterCurrent == m_entries.end())
        return;

    m_iterCurrent->viewMode = nViewMode;
}

void CHistoryList::Clear()
{
    Trace(tagHistory, TEXT("Clear"));
    m_entries.erase(m_entries.begin(), m_entries.end());
    m_iterCurrent = m_entries.begin();
    MaintainWebBar();
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScModifyViewTab
 *
 * PURPOSE: Adds an entry to the history list, which is the same as the current
 *          entry, except that the changes specified by the dwFlags and history
 *          entry parameters are applied
 *
 * PARAMETERS:
 *    const GUID& guidTab :      Specifies guid of selected view tab
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScModifyViewTab(const GUID& guidTab)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScAddModifiedEntry"));

    // we are not going to modify anything if we navigating "Back" or ""Forward" 
    // thru the history enries
    if ( m_bWithin_CHistoryList_Back || m_bWithin_CHistoryList_Forward )
        return sc;

    if( m_iterCurrent == m_entries.end() )
    {
        return (sc = E_UNEXPECTED);
    }

    // for web we cannot add new entries without reselecting the node
    // (same is true about deleting subsequen entries)
    // since that would make MMC and IE histories out of sync
    // instead we just modify the current history entry
    
    if ( !m_iterCurrent->IsWebEntry() ) // in case it is a regular entry
    {
        DeleteSubsequentEntries();  // delete everything ahead of this one.

        // add an entry to the end of the list.
        CHistoryEntry entry;
        ZeroMemory(&entry, sizeof(entry));
        m_entries.push_back(entry);
        iterator iterNew = m_entries.end();
        --iterNew;  // point to the new entry.

        // create a duplicate of the current entry.
        *iterNew = *m_iterCurrent;

        //set the pointer.
        m_iterCurrent = iterNew;
    }

    // change the guid of the tab.
    m_iterCurrent->guidTaskpad = guidTab;

    // we're done.
    Compact();
    MaintainWebBar();
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScChangeViewMode
 *
 * PURPOSE: Changes the view mode of the current entry. Changing the view
 *          mode does not add a new entry. Instead, history remembers the last
 *          view mode that a node was at and always restores to that
 *
 * PARAMETERS:
 *    int  viewMode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScChangeViewMode(int viewMode)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScChangeViewMode"));

    if( m_iterCurrent == m_entries.end() )
    {
        return (sc = E_UNEXPECTED);
    }

    m_iterCurrent->viewMode = viewMode; // set the view mode.

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::DeleteEntry
 *
 * PURPOSE: Deletes all entries for a node from the history list.
 *
 * PARAMETERS:
 *    HNODE  hnode :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::DeleteEntry (HNODE hnode)
{
    for(iterator i= m_entries.begin(); i != m_entries.end(); )
    {
        if(i->hnode == hnode)
        {
            iterator iNext = i;
            ++iNext;
            if(m_iterCurrent==i)
                m_iterCurrent=iNext;
            TraceHistory(TEXT("CHistoryList::Deleting entry"), i);
            m_entries.erase(i);

            i= iNext;
        }
        else
        {
            ++i;
        }
    }
    Compact();
    MaintainWebBar();
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::Compact
 *
 * PURPOSE: 1) Removes redundancies in the history list by eliminating duplicates.
 *          2) Ensures that a maximum of MAX_HISTORY_ENTRIES entries is retained.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::Compact()
{
    if (m_entries.size() == 0)
        return;

    // discard duplicates.
    for (iterator i= m_entries.begin(); i != m_entries.end(); )
    {
        iterator iNext = i;
        ++iNext;
        if(iNext == m_entries.end())
            break;

        // do not delete if it is a webentry (there is no way for us to tell IE
        // to delete that history entry).
        if ( (i->IsWebEntry() == false) && ( *i == *iNext))
        {
            if(m_iterCurrent==i)
                m_iterCurrent=iNext;

            TraceHistory(TEXT("CHistoryList::Deleting entry"), i);
            m_entries.erase(i);
            i = iNext;
        }
        else
        {
            ++i;
        }
    }

    iterator iter = m_entries.begin();
    iterator iterNext = iter;
    int nExcess = m_entries.size() - MAX_HISTORY_ENTRIES;
    while(nExcess-- > 0)
    {
        iterNext = iter;
        ++iterNext;

        if(iter == m_iterCurrent)   // make sure we don't delete the current entry.
            break;

        TraceHistory(TEXT("CHistoryList::Deleting entry"), i);
        m_entries.erase(iter);
        iter = iterNext;
    }
}

/***************************************************************************\
 *
 * METHOD:  CHistoryList::PreviousWebPagesExist
 *
 * PURPOSE: looks back to see if there are any web pages in the history
 *          up to the current mark (including it)
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool    - result true = there is web pages 
 *
\***************************************************************************/
bool CHistoryList::PreviousWebPagesExist()
{
    if ( m_entries.size() && m_iterCurrent == m_entries.end() )
    {
        ASSERT(FALSE); // need to point to a valid entry !!!
        return false;
    }

    // will loop past the current entry.
    iterator end = m_iterCurrent;
    ++end;

    for ( iterator it = m_entries.begin(); it != end; ++it )
    {
        if ( it->IsWebEntry() )
            return true;
    }

    return false;
}


/*+-------------------------------------------------------------------------*
 * ScGetPageBreakURL
 *
 * Returns the URL for MMC's HTML page containing a page break.
 *--------------------------------------------------------------------------*/

SC ScGetPageBreakURL(CStr& strPageBreakURL)
{
	DECLARE_SC (sc, _T("GetPageBreakURL"));

	/*
	 * clear out the old value, if any
	 */
	strPageBreakURL.Empty();

    // generate new pagebreak URL every time ( prevent web browser from compacting it)
    static int nPageBreak = 0;
    strPageBreakURL.Format( _T("%s%d"),  PAGEBREAK_URL, ++nPageBreak );

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\histlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       histlist.h
//
//--------------------------------------------------------------------------

#pragma once

#ifndef _HISTORY_LIST_H
#define _HISTORY_LIST_H

#include <exdisp.h>
#include <mshtml.h>

#include "amcview.h"
#include "treectrl.h"
#include "resultview.h"

#include <windowsx.h>   // for globalallocptr macro

SC ScGetPageBreakURL(CStr& strResultPane);

enum NavState
{
    MMC_HISTORY_READY      = 0,
    MMC_HISTORY_NAVIGATING = 1,
    MMC_HISTORY_BUSY       = 2,
    MMC_HISTORY_PAGE_BREAK = 3
};

enum HistoryButton
{
    HB_BACK                = -1,
    HB_STOP                = 0,
    HB_FORWARD             = 1
};


class CHistoryEntry
{
public:
    bool operator == (const CHistoryEntry &other) const;
    bool operator != (const CHistoryEntry &other) const;

    bool IsWebEntry()   {return resultViewType.HasWebBrowser();}
    bool IsListEntry()  {return resultViewType.HasList();}
    bool IsOCXEntry()   {return resultViewType.HasOCX();}

public:
    int              viewMode;       // valid only if the result view is a list. This field is not a part of CResultViewType because the snapin does not specify this.
    HNODE            hnode;          // currently selected node in scope tree
    GUID             guidTaskpad;    // the selected taskpad
    CResultViewType  resultViewType; // all the details about the result pane
};

/*+-------------------------------------------------------------------------*
 * class CHistoryList
 *
 *
 * PURPOSE: Maintains a list of all the states visited by the user for a view.
 *
 *+-------------------------------------------------------------------------*/
class CHistoryList
{
    typedef std::list<CHistoryEntry> HistoryEntryList;

    enum {MAX_HISTORY_ENTRIES = 100};

public:
    typedef HistoryEntryList::iterator iterator;

    CHistoryList(CAMCView* pView);
   ~CHistoryList();

    void    Attach (CAMCWebViewCtrl* pWebViewCtrl)  {m_pWebViewCtrl = pWebViewCtrl;}
    BOOL    IsFirst();  // should we light up the "Back"    button?
    BOOL    IsLast();   // should we light up the "Forward" button?
    HRESULT Back   (bool &bHandled, bool bUseBrowserHistory = true);
    HRESULT Forward(bool &bHandled, bool bUseBrowserHistory = true);
    SC      ScAddEntry (CResultViewType &rvt, int viewMode, GUID &guidTaskpad); // adds new entry at current location
    void    DeleteEntry (HNODE hnode);
    SC      ScModifyViewTab(const GUID& guidTab);
    SC      ScChangeViewMode(int viewMode);
    void    MaintainWebBar();
    void    Compact();
    HRESULT ExecuteCurrent();
    void    UpdateWebBar (HistoryButton button, BOOL bOn);
    void    Clear();
    void    OnBrowserStateChange(bool bEnableForward, bool bEnableBack);
    SC      ScOnPageBreak();
    SC      ScDoPageBreak();
    void    OnPageBreakStateChange(bool bPageBreak);
    void    DeleteSubsequentEntries();

    NavState GetNavigateState()                 { return m_navState; }
    void    SetNavigateState(NavState state)    { m_navState = state; }
    SC      ScGetCurrentResultViewType (CResultViewType &rvt, int& viewMode, GUID &guidTaskpad);
    void    SetCurrentViewMode (long nViewMode);

private:
    CAMCWebViewCtrl* GetWebViewCtrl()   {return m_pWebViewCtrl;}
    bool    PreviousWebPagesExist();

private:
    iterator         m_iterCurrent;   // current index
    HistoryEntryList m_entries;       // array (note: using array-size doubling scheme)
    CAMCView*        m_pView;         // to get current node
    NavState         m_navState;      // TRUE when busy

    CAMCWebViewCtrl *m_pWebViewCtrl;  // used to navigate to a page break.

    bool             m_bBrowserForwardEnabled;
    bool             m_bBrowserBackEnabled;
    bool             m_bCurrentStateIsForward;  // tells us if we're going forward or backward.
    bool             m_bPageBreak;     // are we sitting at a page break right now?
    bool             m_bWithin_CHistoryList_Back; // to know "Back" is on stack
    bool             m_bWithin_CHistoryList_Forward; // to know "Forward" is on stack
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       HelpArr.h
//
//--------------------------------------------------------------------------
#ifndef _HELPARR_H_
#define _HELPARR_H_

#define IDH_DISABLEHELP ((DWORD)-1)

#define IDH_ADDSNAPIN_LV_SNAP_INS                       2001
#define IDH_PROPPAGE_CONSOLE_CHANGE_ICON                2002
#define IDH_PROPPAGE_CONSOLE_CONSOLE_ICON               2003
#define IDH_PROPPAGE_CONSOLE_CONSOLE_MODE               2004
#define IDH_PROPPAGE_CONSOLE_CONSOLE_MODE_DESCRIPTION   2005
#define IDH_PROPPAGE_CONSOLE_CUSTOM_TITLE               2006
#define IDH_PROPPAGE_CONSOLE_DONTSAVECHANGES            2007
#define IDH_URL_INPUT_URL_EDIT                          2008
#define IDH_ADDFAVORITE_ADDFAVFOLDER                    2009
#define IDH_ADDFAVORITE_FAVNAME                         2010
#define IDH_ADDFAVORITE_FAVTREE                         2011
#define IDH_FAVORGANIZE_ADDFAVFOLDER                    2012
#define IDH_FAVORGANIZE_FAVDELETE                       2013
#define IDH_FAVORGANIZE_FAVINFO                         2014
#define IDH_FAVORGANIZE_FAVMOVETO                       2015
#define IDH_FAVORGANIZE_FAVNAME                         2016
#define IDH_FAVORGANIZE_FAVRENAME                       2017
#define IDH_FAVORGANIZE_FAVTREE                         2018
#define IDH_FAVSELECTFOLDER_FAVTREE                     2019
#define IDH_LIST_SAVE_SEL                               2020
#define IDH_NEWFAVFOLDER_FAVFOLDER                      2021
#define IDH_PROPPAGE_CONSOLE_AllowViewCustomization     2022
#define IDH_DISKCLEANUP_DESCRIPTION                     1032
#define IDH_DELETE_TEMP_FILES                           1031


const DWORD g_aHelpIDs_IDD_URL_INPUT[]=
{
IDC_URL_EDIT,   IDH_URL_INPUT_URL_EDIT,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADDSNAPIN[]=
{
IDC_LV_SNAP_INS,    IDH_ADDSNAPIN_LV_SNAP_INS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_CONSOLE[]=
{
IDC_CONSOLE_MODE,   IDH_PROPPAGE_CONSOLE_CONSOLE_MODE,
IDC_CONSOLE_MODE_DESCRIPTION,   IDH_PROPPAGE_CONSOLE_CONSOLE_MODE_DESCRIPTION,
IDC_DONTSAVECHANGES,    IDH_PROPPAGE_CONSOLE_DONTSAVECHANGES,
IDC_CHANGE_ICON,    IDH_PROPPAGE_CONSOLE_CHANGE_ICON,
IDC_CUSTOM_TITLE,   IDH_PROPPAGE_CONSOLE_CUSTOM_TITLE,
IDC_CONSOLE_ICON,   IDH_PROPPAGE_CONSOLE_CONSOLE_ICON,
IDC_AllowViewCustomization, IDH_PROPPAGE_CONSOLE_AllowViewCustomization,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_DISK_CLEANUP[]=
{
IDC_DISKCLEANUP_DESCRIPTION,  IDH_DISKCLEANUP_DESCRIPTION,
IDC_DELETE_TEMP_FILES,        IDH_DELETE_TEMP_FILES,
IDC_DISKCLEANUP_OCCUPIED,     IDH_DISKCLEANUP_DESCRIPTION,
IDC_DISKCLEANUP_TO_DELETE,    IDH_DISKCLEANUP_DESCRIPTION,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADDFAVORITE[]=
{
IDC_FAVNAME,    IDH_ADDFAVORITE_FAVNAME,
IDC_FAVTREE,    IDH_ADDFAVORITE_FAVTREE,
IDC_ADDFAVFOLDER,   IDH_ADDFAVORITE_ADDFAVFOLDER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FAVORGANIZE[]=
{
IDC_ADDFAVFOLDER,   IDH_FAVORGANIZE_ADDFAVFOLDER,
IDC_FAVRENAME,  IDH_FAVORGANIZE_FAVRENAME,
IDC_FAVMOVETO,  IDH_FAVORGANIZE_FAVMOVETO,
IDC_FAVDELETE,  IDH_FAVORGANIZE_FAVDELETE,
IDC_FAVNAME,    IDH_FAVORGANIZE_FAVNAME,
IDC_FAVINFO,    IDH_FAVORGANIZE_FAVINFO,
IDC_FAVTREE,    IDH_FAVORGANIZE_FAVTREE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FAVSELECTFOLDER[]=
{
IDC_FAVTREE,    IDH_FAVSELECTFOLDER_FAVTREE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_LIST_SAVE[]=
{
IDC_SEL,    IDH_LIST_SAVE_SEL,
    0, 0
};

const DWORD g_aHelpIDs_IDD_NEWFAVFOLDER[]=
{
IDC_FAVFOLDER,  IDH_NEWFAVFOLDER_FAVFOLDER,
    0, 0
};


// Handle context sensitive dialog help for the conui subsystem
void HelpWmHelp(LPHELPINFO pHelpInfo, const DWORD* pHelpIDs);
void HelpContextMenuHelp(HWND hWnd, ULONG_PTR p);

#define ON_MMC_CONTEXT_HELP()                                                   \
        ON_MESSAGE(WM_HELP,          OnWmHelp)                                  \
        ON_MESSAGE(WM_CONTEXTMENU,   OnWmContextMenu)                           \


#define IMPLEMENT_CONTEXT_HELP(g_helpIds)                                         \
                                                                                  \
LRESULT OnWmHelp(WPARAM wParam, LPARAM lParam)                                    \
{                                                                                 \
    HelpWmHelp(reinterpret_cast<LPHELPINFO>(lParam), g_helpIds);                  \
    return true;                                                                  \
}                                                                                 \
                                                                                  \
LRESULT OnWmContextMenu(WPARAM wParam, LPARAM lParam)                             \
{                                                                                 \
    HelpContextMenuHelp((HWND)wParam,                                             \
                        (ULONG_PTR)(LPVOID) g_helpIds);                           \
    return TRUE;                                                                  \
}



#endif // _HELPAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\imagemap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       imagemap.h
//
//--------------------------------------------------------------------------

#ifndef __IMAGEMAP_H
#define __IMAGEMAP_H

#include "ndmgr.h"

class CImageIndexMapKey
{
public:
	COMPONENTID	m_ID;
	int			m_nIndex;

	CImageIndexMapKey()
	{
		m_ID = NULL;
		m_nIndex = 0;
	}

	CImageIndexMapKey(COMPONENTID ID, int nIndex)
	{
		m_ID = ID;
		m_nIndex = nIndex;
	}
};

typedef CImageIndexMapKey * PImageIndexMapKey;

inline UINT HashKey(PImageIndexMapKey keyPtr)
{
	return(((static_cast<UINT>(keyPtr->m_ID) << 16) & 0xFFFF0000)|
			(static_cast<UINT>(keyPtr->m_nIndex) & 0x0000FFFF));
}

inline void DestructElements(PImageIndexMapKey *keyArray, int nCount)
{
	for(int i=0;i<nCount;i++)
		delete keyArray[i];
}

inline BOOL CompareElements(PImageIndexMapKey *p1, PImageIndexMapKey *p2)
{
	return(((*p1)->m_ID == (*p2)->m_ID)&&((*p1)->m_nIndex == (*p2)->m_nIndex));
}

#define INITIAL_HASHSIZE 223

class CImageIndexMap : public CMap <PImageIndexMapKey, PImageIndexMapKey, int, int &>
{
public:
	CImageIndexMap()
	{
		InitHashTable(INITIAL_HASHSIZE);
	}
};

#undef INITIAL_HASHSIZE
#endif // __IMAGEMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\idle.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      idle.cpp
 *
 *  Contents:  Implementation file for CIdleTaskQueue
 *
 *  History:   13-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"

//############################################################################
//############################################################################
//
// Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagIdle(TEXT("IdleTaskQueue"), TEXT("IdleTaskQueue"));
#endif //DBG

//############################################################################
//############################################################################
//
// Implementation of CIdleTask
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CIdleTask);

CIdleTask::CIdleTask()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleTask);
}

CIdleTask::~CIdleTask()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CIdleTask);

}

CIdleTask::CIdleTask(const CIdleTask &rhs)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleTask);
    *this = rhs;
}

CIdleTask&
CIdleTask::operator= (const CIdleTask& rhs)
{
    return *this;
}


//############################################################################
//############################################################################
//
// Implementation of CIdleQueueEntry
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CIdleQueueEntry);

CIdleQueueEntry::CIdleQueueEntry(const CIdleQueueEntry &rhs)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    *this = rhs;
}


CIdleQueueEntry&
CIdleQueueEntry::operator= (const CIdleQueueEntry& rhs)
{
    m_pTask     = rhs.m_pTask;
    m_ePriority = rhs.m_ePriority;
    return (*this);
}


//############################################################################
//############################################################################
//
// Implementation of CIdleTaskQueue
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CIdleTaskQueue);

CIdleTaskQueue::CIdleTaskQueue()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleTaskQueue);
}

CIdleTaskQueue::~CIdleTaskQueue()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CIdleTaskQueue);

    while(!m_queue.empty())
    {
        CIdleTask *pIdleTask = m_queue.top().GetTask();
        m_queue.pop();

        ASSERT(pIdleTask != NULL);
        if(pIdleTask!=NULL)
        {
            delete pIdleTask;
        }
    }
}

/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::ScPushTask
 *
 *
 * Adds the given task the list of tasks to execute at idle time.
 *
 * S_OK     the task was added to the list.
 * S_FALSE  the task was merged with an existing task.
 * other    the task was not added to the list
 *
 *--------------------------------------------------------------------------*/

SC CIdleTaskQueue::ScPushTask (
    CIdleTask* pitToPush,
    IdleTaskPriority ePriority)
{
    SC   sc;
    ATOM idToPush;

    /*
     * validate the parameters
     */
    if (IsBadWritePtr (pitToPush, sizeof (*pitToPush)))
    {
        sc = E_POINTER;
        goto Error;
    }

    if ((ePriority < ePriority_Low) || (ePriority > ePriority_High))
    {
        ASSERT (false && "Invalid idle task priority");
        sc = E_INVALIDARG;
        goto Error;
    }

    sc = pitToPush->ScGetTaskID (&idToPush);
    if(sc)
        goto Error;

#ifdef DBG
    TCHAR szNameToPush[64];
    GetAtomName (idToPush, szNameToPush, countof (szNameToPush));
#endif

    /*
     * if we have tasks in the queue, look for one we can merge with
     */
    if (!m_queue.empty())
    {
        Queue::iterator it    = m_queue.begin();
        Queue::iterator itEnd = m_queue.end();

        while ( (!sc.IsError()) &&
               (it = FindTaskByID(it, itEnd, idToPush)) != itEnd)
        {
#ifdef DBG
            ATOM idMergeTarget;
            it->GetTask()->ScGetTaskID(&idMergeTarget);

            TCHAR szMergeTargetName[64];
            GetAtomName (idMergeTarget, szMergeTargetName, countof (szMergeTargetName));

            Trace (tagIdle, _T("%s (0x%08x) %smerged with %s (0x%08x) (%d idle tasks)"),
                 szNameToPush,
                 pitToPush,
                 (sc) ? _T("not ") : _T(""),
                 szMergeTargetName,
                 it->GetTask(),
                 m_queue.size());
#endif

            sc = it->GetTask()->ScMerge(pitToPush);
            if(sc==S_OK) //  successfully merged? just return
            {
                delete pitToPush;
                sc = S_FALSE;
                goto Cleanup;
            }

            // bump past the task we didn't merge with
            ++it;
        }
    }

    m_queue.push (CIdleQueueEntry (pitToPush, ePriority));

#ifdef DBG
    Trace (tagIdle, _T("%s (0x%08x) pushed, priority %d (%d idle tasks)"),
         szNameToPush,
         pitToPush,
         ePriority,
         m_queue.size());
#endif

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CIdleTaskQueue::ScPushTask"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::ScPerformNextTask
 *
 *
 * Performs the next task, if any.
 * Removes the highest priority idle task from the task list, and calls ScDoWork() on it.
 *
 *--------------------------------------------------------------------------*/
SC
CIdleTaskQueue::ScPerformNextTask ()
{
	DECLARE_SC (sc, _T("CIdleTaskQueue::ScPerformNextTask"));

    if (m_queue.empty())
		return (sc);

    CAutoPtr<CIdleTask> spIdleTask (m_queue.top().GetTask());
    if (spIdleTask == NULL)
		return (sc = E_UNEXPECTED);

    m_queue.pop();

#ifdef DBG
	ATOM idTask;
	spIdleTask->ScGetTaskID(&idTask);

	TCHAR szTaskName[64];
	GetAtomName (idTask, szTaskName, countof (szTaskName));

	Trace (tagIdle, _T("Performing %s (0x%08x) (%d idle tasks remaining)"),
		 szTaskName,
		 (CIdleTask*) spIdleTask,
		 m_queue.size());
#endif

    sc = spIdleTask->ScDoWork();
    if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::ScGetTaskCount
 *
 * Returns the number of tasks in the idle list.
 *--------------------------------------------------------------------------*/

SC CIdleTaskQueue::ScGetTaskCount (LONG_PTR* plCount)
{
    SC sc;

    if (IsBadWritePtr (plCount, sizeof (*plCount)))
    {
        sc = E_POINTER;
        goto Error;
    }

    *plCount = m_queue.size();

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CIdleTaskQueue::ScGetTaskCount"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::FindTaskByID
 *
 *
 *--------------------------------------------------------------------------*/

CIdleTaskQueue::Queue::iterator CIdleTaskQueue::FindTaskByID (
    CIdleTaskQueue::Queue::iterator itFirst,
    CIdleTaskQueue::Queue::iterator itLast,
    ATOM                                idToFind)
{
    return (std::find_if (itFirst, itLast,
                          std::bind2nd (EqualTaskID(), idToFind)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\kbdnav.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      kbdnav.h
 *
 *  Contents:  Interface file for CKeyboardNavDelayTimer
 *
 *  History:   4-May-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#ifdef DBG
extern CTraceTag tagKeyboardNavDelay;
#endif

class CKeyboardNavDelayTimer
{
public:
	typedef std::map<UINT_PTR, CKeyboardNavDelayTimer*>  CTimerMap;

	CKeyboardNavDelayTimer();
   ~CKeyboardNavDelayTimer();

	SC ScStartTimer();
	SC ScStopTimer();
	virtual void OnTimer() = 0;

private:
	static VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
	static CTimerMap& GetTimerMap();

private:
	UINT_PTR	m_nTimerID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mainfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mainfrm.cpp
//
//  Contents:  Main frame for amc
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Add code to test switching views
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "AMC.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "treectrl.h"
#include "menubar.h"
#include "mdiuisim.h"
#include "toolbar.h"
#include "props.h"
#include "sysmenu.h"

#include "amcmsgid.h"
#include "HtmlHelp.h"

#include "strings.h"
#include "ndmgrp.h"
#include "amcmsgid.h"
#include "tbtrack.h"
#include "caption.h"
#include "scriptevents.h"


#ifdef DBG
CTraceTag tagMainFrame(TEXT("CMainFrame"), TEXT("Messages"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CMMCApplicationFrame
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CMMCApplicationFrame
 *
 *
 * PURPOSE: The COM 0bject that exposes the Frame interface off the Application object.
 *
 *+-------------------------------------------------------------------------*/
class CMMCApplicationFrame :
    public CMMCIDispatchImpl<Frame>,
    public CTiedComObject<CMainFrame>
{
    typedef CMainFrame CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CMMCApplicationFrame)
    END_MMC_COM_MAP()

    //Frame interface
public:
    STDMETHOD(Maximize)();
    STDMETHOD(Minimize)();
    STDMETHOD(Restore)();

    STDMETHOD(get_Left)(int *pLeft)      {return GetCoordinate(pLeft, eLeft);}
    STDMETHOD(put_Left)(int left)        {return PutCoordinate(left, eLeft);}

    STDMETHOD(get_Right)(int *pRight)    {return GetCoordinate(pRight, eRight);}
    STDMETHOD(put_Right)(int right)      {return PutCoordinate(right, eRight);}

    STDMETHOD(get_Top)(int *pTop)        {return GetCoordinate(pTop, eTop);}
    STDMETHOD(put_Top)(int top)          {return PutCoordinate(top, eTop);}

    STDMETHOD(get_Bottom)(int *pBottom)  {return GetCoordinate(pBottom, eBottom);}
    STDMETHOD(put_Bottom)(int bottom)    {return PutCoordinate(bottom, eBottom);}

private:
    enum eCoordinate { eLeft, eRight, eTop, eBottom };

    STDMETHOD(GetCoordinate)(int *pCoordinate, eCoordinate e);
    STDMETHOD(PutCoordinate)(int coordinate,   eCoordinate e);
};


/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::Maximize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::Maximize()
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::Maximize"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    // do the operation
    sc = pTiedObj->ScMaximize();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::Minimize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::Minimize()
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::Minimize"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    // do the operation
    sc = pTiedObj->ScMinimize();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::Restore
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::Restore()
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::Restore"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    sc = pTiedObj->ScRestore();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::GetCoordinate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    int *        pCoordinate :
 *    eCoordinate  e :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::GetCoordinate(int *pCoordinate, eCoordinate e)
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::GetCoordinate"));

    // check parameters
    if(!pCoordinate)
    {
        sc = E_POINTER;
        return sc.ToHr();
    }

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    RECT rect;

    // do the operation
    sc = pTiedObj->ScGetPosition(rect);
    if(sc)
        return sc.ToHr();

    switch(e)
    {
    case eTop:
        *pCoordinate = rect.top;
        break;

    case eBottom:
        *pCoordinate = rect.bottom;
        break;

    case eLeft:
        *pCoordinate = rect.left;
        break;

    case eRight:
        *pCoordinate = rect.right;
        break;

    default:
        ASSERT(0 && "Should not come here!!");
        break;
    }


    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::PutCoordinate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    int          coordinate :
 *    eCoordinate  e :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::PutCoordinate(int coordinate,   eCoordinate e)
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::PutCoordinate"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    RECT rect;

    sc = pTiedObj->ScGetPosition(rect);
    if(sc)
        return sc.ToHr();

    switch(e)
    {
    case eTop:
        rect.top    = coordinate;
        break;

    case eBottom:
        rect.bottom = coordinate;
        break;

    case eLeft:
        rect.left   = coordinate;
        break;

    case eRight:
        rect.right  = coordinate;
        break;

    default:
        ASSERT(0 && "Should not come here!!");
        break;
    }


    sc = pTiedObj->ScSetPosition(rect);

    return sc.ToHr();
}

//############################################################################
//############################################################################
//
//  Misc declarations
//
//############################################################################
//############################################################################

static TBBUTTON MainButtons[] =
{
 { 0, ID_FILE_NEW           , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 0 },
 { 1, ID_FILE_OPEN          , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 1 },
 { 2, ID_FILE_SAVE          , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 2 },
 { 0, 0                     , TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, 0 },
 { 3, ID_WINDOW_NEW         , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 3 },
};


/*
 * remove the definition that WTL might have given us
 */
#ifdef ID_VIEW_REFRESH
#undef ID_VIEW_REFRESH
#endif

enum DoWeNeedThis
{
    ID_VIEW_REFRESH     =  12797
};

//############################################################################
//############################################################################
//
//  Implementation of class CMainFrame
//
//############################################################################
//############################################################################

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

// CODEWORK message reflection not working yet
BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_DRAWCLIPBOARD()
    ON_WM_CHANGECBCHAIN()
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateFilePrint)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_SETUP, OnUpdateFilePrintSetup)
    ON_WM_CLOSE()
    ON_COMMAND(ID_VIEW_TOOLBAR, OnViewToolbar)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, OnUpdateViewToolbar)
    ON_WM_SIZE()
    ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpTopics)
    ON_COMMAND(ID_VIEW_REFRESH, OnViewRefresh)
    ON_UPDATE_COMMAND_UI(ID_VIEW_REFRESH, OnUpdateViewRefresh)
    ON_WM_DESTROY()
    ON_WM_SYSCOMMAND()
    ON_WM_INITMENUPOPUP()
    ON_COMMAND(ID_CONSOLE_PROPERTIES, OnConsoleProperties)
    ON_WM_MOVE()
    ON_WM_ACTIVATE()
    ON_WM_NCACTIVATE()
    ON_WM_NCPAINT()
    ON_WM_PALETTECHANGED()
    ON_WM_QUERYNEWPALETTE()
    ON_COMMAND(ID_WINDOW_NEW, OnWindowNew)
    ON_WM_SETTINGCHANGE()
 	ON_WM_MENUSELECT()
    ON_MESSAGE(WM_UNINITMENUPOPUP, OnUnInitMenuPopup)
   //}}AFX_MSG_MAP

#ifdef DBG
    ON_COMMAND(ID_MMC_TRACE_DIALOG, OnMMCTraceDialog)
#endif

    ON_MESSAGE(WM_SETTEXT, OnSetText)

    ON_MESSAGE(MMC_MSG_PROP_SHEET_NOTIFY, OnPropertySheetNotify)
    ON_MESSAGE(MMC_MSG_SHOW_SNAPIN_HELP_TOPIC, OnShowSnapinHelpTopic)

    // The following entry is placed here for compatibilty with versions
    // of mmc.lib that were compiled with the incorrect value for message
    // MMC_MSG_SHOW_SNAPIN_HELP_TOPIC. MMC.lib function MMCPropertyHelp
    // sends this message to the mainframe window when called by a snap-in.

    ON_MESSAGE(MMC_MSG_SHOW_SNAPIN_HELP_TOPIC_ALT, OnShowSnapinHelpTopic)

END_MESSAGE_MAP()

//+-------------------------------------------------------------------
//
//  Member:      CMainFrame::OnMenuSelect
//
//  Synopsis:    Handles WM_MENUSELECT, sets status bar text for the
//               given menu item.
//
//  Arguments:   [nItemID] - the resource id of menu item.
//               [nFlags]  - MF_* flags
//               [hMenu]   -
//
//  Returns:     none
//
//--------------------------------------------------------------------
void CMainFrame::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hMenu)
{
    DECLARE_SC(sc, TEXT("CMainFrame::OnMenuSelect"));
    if (nFlags & MF_SYSMENU)
        return;

    CString strText = TEXT("");
    CString strStatusText;

	/*
	 * We need to handle special cases, most of the menu items have status text with them.
	 * The exception being, the favoties list, the windows list in windows menu and popup menus.
	 * The reason is the menu ids are not unique in main menu because we do TrackPopupMenu at
	 * three places first one for File, Window & Help menus done in menubar.cpp, second for
	 * Action & View menu in cmenu.cpp and third favorites menu in favui.cpp.
	 */

	/*
	 * Special case 1: Check to see if current menu is favorites menu, if so need to get status
	 * text for favorites list except for "Add to favorites.." and "Organize favorites.." items.
	 * The below test can break if "Add to Favorites..." is moved in menu resource.
	 */
	if ((IDS_ADD_TO_FAVORITES != nItemID) &&
		(IDS_ORGANIZEFAVORITES != nItemID) &&
		(GetMenuItemID(hMenu, 0) == IDS_ADD_TO_FAVORITES) )
	{
		strStatusText.LoadString(IDS_FAVORITES_ACTIVATE);
	}
	/*
	 * Special case 2: Handle any popup menus (popup menus dont have any ID).
	 */
    else if (nFlags & MF_POPUP)
	{
        // do nothing
	}
	// Special case 3: Assume mmc supports maximum of 1024 windows for status bar text sake.
    else if ( (nItemID >= AFX_IDM_FIRST_MDICHILD) && (nItemID <= AFX_IDM_FIRST_MDICHILD+1024) )
    {
        strStatusText.LoadString(ID_WINDOW_ACTIVATEWINDOW);
    }
	else
    {
        strText.LoadString(nItemID);

        int iSeparator = strText.Find(_T('\n'));
        if (iSeparator < 0) // No status text so use the menu text as status text.
            strStatusText = strText;
        else
            strStatusText = strText.Mid(iSeparator);
    }

    CChildFrame *pChildFrame = dynamic_cast<CChildFrame*>(GetActiveFrame());
    if (!pChildFrame)
        return;

    sc = pChildFrame->ScSetStatusText(strStatusText);
    if (sc)
        return;

	return;
}




/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScGetFrame
 *
 * PURPOSE: Returns a pointer to the COM object that implements the
 *          Frame interface.
 *
 * PARAMETERS:
 *    Frame **ppFrame :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScGetFrame(Frame **ppFrame)
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScGetFrame") );

    if(!ppFrame)
    {
        sc = E_POINTER;
        return sc;
    }

    *ppFrame = NULL;

    // NOTE the com object cannot be cached with a smart pointer owned by CMainFrame
    // since CMainFrame is VERY LONG living guy - it will lock mmc.exe from exitting
    // it could be used by creating CComObjectCached, but CTiedComObjectCreator does
    // not support that
    // see bug # 101564
    CComPtr<Frame> spFrame;
    // create a CMMCApplicationFrame if not already done so.
    sc = CTiedComObjectCreator<CMMCApplicationFrame>::ScCreateAndConnect(*this, spFrame);
    if(sc)
        return sc;

    if(spFrame == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    *ppFrame = spFrame.Detach();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScMaximize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScMaximize()
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScMaximize"));

    ShowWindow(SW_MAXIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScMinimize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScMinimize()
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScMinimize"));

    ShowWindow(SW_MINIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScRestore
 *
 * PURPOSE:  Restores the position of the main frame.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScRestore()
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScRestore"));

    ShowWindow(SW_RESTORE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScSetPosition
 *
 * PURPOSE: Sets the position of the main frame
 *
 * PARAMETERS:
 *    const  RECT :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScSetPosition(const RECT &rect)
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScSetPosition"));

    int width  = rect.right - rect.left + 1;
    int height = rect.bottom - rect.top + 1;

    SetWindowPos(NULL /*hWndInsertAfter*/, rect.left, rect.top, width, height, SWP_NOZORDER);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScGetPosition
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    RECT & rect :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScGetPosition(RECT &rect)
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScGetPosition"));

    GetWindowRect(&rect);

    return sc;
}



// OnActivate is overridden to work around a SQL snap-in problem under
// Win9x. When SQL tries to force focus back to its property sheet it
// causes an infinite recursion of the OnActivate call.
// This override discards any activation that occurs during the processing
// of a prior activation.
void CMainFrame::OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized )
{
    Trace(tagMainFrame, TEXT("OnActivate: nState=%d"), nState);

    static bActivating = FALSE;

    m_fCurrentlyActive = (nState != WA_INACTIVE);

    // if activating
    if (m_fCurrentlyActive)
    {
        CAMCApp* pApp = AMCGetApp();
        ASSERT(NULL != pApp);

        // if windows and we're already activating, prevent recursion
        if ( (NULL != pApp) && (pApp->IsWin9xPlatform() == true) && bActivating)
            return;

        // Process activation request
        bActivating = TRUE;
        CMDIFrameWnd::OnActivate(nState, pWndOther, bMinimized);
        bActivating = FALSE;
    }
    else
    {
        // if we have accelarators hilited (it happen when one press Alt+TAB)
        // we need to remove them now.
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));

        // Let unactivate through
        CMDIFrameWnd::OnActivate(nState, pWndOther, bMinimized);
    }
}


CAMCView* CMainFrame::GetActiveAMCView()
{
    CChildFrame *pChildFrame = dynamic_cast<CChildFrame*>(GetActiveFrame());
    if (!pChildFrame)
        return NULL;

    CAMCView* pAMCView = pChildFrame->GetAMCView();
    ASSERT(pAMCView != NULL);
    ASSERT(::IsWindow(*pAMCView));

    if (pAMCView && ::IsWindow(*pAMCView))
        return pAMCView;

    return NULL;
}

CAMCTreeView* CMainFrame::_GetActiveAMCTreeView()
{
    CAMCView* pAMCView = GetActiveAMCView();
    CAMCTreeView* pAMCTreeView = pAMCView ? pAMCView->GetTreeCtrl() : NULL;
    if (pAMCTreeView && ::IsWindow(*pAMCTreeView))
        return pAMCTreeView;

    return NULL;
}

void CMainFrame::OnDrawClipboard()
{
    if (m_hwndToNotifyCBChange != NULL &&
        ::IsWindow(m_hwndToNotifyCBChange))
    {
        ::SendMessage(m_hwndToNotifyCBChange, WM_DRAWCLIPBOARD, 0, 0);
        m_hwndToNotifyCBChange = NULL;
    }

    if (m_hwndNextCB != NULL &&
        ::IsWindow(m_hwndNextCB))
    {
        ::SendMessage(m_hwndNextCB, WM_DRAWCLIPBOARD, 0, 0);
    }

    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    if (pAMCDoc)
    {
        CAMCViewPosition pos = pAMCDoc->GetFirstAMCViewPosition();
        while (pos != NULL)
        {
            CAMCView* v = pAMCDoc->GetNextAMCView(pos);

            if (v && ::IsWindow(*v))
                v->OnUpdatePasteBtn();
        }
    }
}

void CMainFrame::OnChangeCbChain(HWND hWndRemove, HWND hWndAfter)
{
    if (m_hwndNextCB == hWndRemove)
        m_hwndNextCB = hWndAfter;
    else if (m_hwndNextCB != NULL && ::IsWindow(m_hwndNextCB))
        ::SendMessage(m_hwndNextCB, WM_CHANGECBCHAIN,
                      (WPARAM)hWndRemove, (LPARAM)hWndAfter);
}

void CMainFrame::OnWindowNew()
{
    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    ASSERT(pAMCDoc != NULL);
    if (pAMCDoc != NULL)
    {
        pAMCDoc->SetMTNodeIDForNewView(ROOTNODEID);
        pAMCDoc->CreateNewView(true);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
    :
    m_hwndToNotifyCBChange(NULL),
    m_hwndNextCB(NULL),
    m_fCurrentlyMinimized(false),
    m_fCurrentlyActive(false)
{
    CommonConstruct();
}

void CMainFrame::CommonConstruct(void)
{
    m_pRebar = NULL;
    m_pMenuBar = NULL;
    m_pToolBar = NULL;
    m_pMDIChildWndFocused = NULL;
    m_hMenuCurrent = NULL;
    m_pToolbarTracker = NULL;
    SetInRenameMode(false);
}


CMainFrame::~CMainFrame()
{
    delete m_pMenuBar;
    delete m_pToolBar;
    delete m_pRebar;
    delete m_pToolbarTracker;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, TEXT("CMainFrame::OnCreate"));

    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndMDIClient.SubclassWindow(m_hWndMDIClient))
    {
        ASSERT(0 && "Failed to subclass MDI client window\n");
        return -1;
    }

    ASSERT(m_wndMDIClient.m_hWnd == m_hWndMDIClient);

    // create the rebar
    m_pRebar = new CRebarDockWindow;
    m_pRebar->Create(this,WS_CHILD|WS_VISIBLE, IDR_REBAR);

    // Create the toolbar like we just created the stat bar
    //m_wndToolBar.Create(this, WS_CHILD|WS_VISIBLE|SBARS_SIZEGRIP, 0x1003);
    m_ToolBarDockSite.Create(CDockSite::DSS_TOP);
    m_ToolBarDockSite.Attach(m_pRebar);
    m_ToolBarDockSite.Show();

    m_DockingManager.Attach(&m_ToolBarDockSite);

    AddMainFrameBars();

    m_hwndNextCB = SetClipboardViewer();
    if (m_hwndNextCB == NULL)
    {
        LRESULT lr = GetLastError();
        ASSERT(lr == 0);
    }

    // append our modifications to the system menu
    AppendToSystemMenu (this, eMode_Last + 1);

    // create the toolbar tracker
    m_pToolbarTracker = new CToolbarTracker (this);

    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if (!CMDIFrameWnd::PreCreateWindow(cs))
        return (FALSE);

    static TCHAR szClassName[countof (MAINFRAME_CLASS_NAME)];
    static bool  fFirstTime = true;

    if (fFirstTime)
    {
        USES_CONVERSION;
        _tcscpy (szClassName, W2T (MAINFRAME_CLASS_NAME));
        fFirstTime = false;
    }

    WNDCLASS    wc;
    HINSTANCE   hInst    = AfxGetInstanceHandle();
    BOOL        fSuccess = GetClassInfo (hInst, szClassName, &wc);

    // if we haven't already registered...
    if (!fSuccess && ::GetClassInfo (hInst, cs.lpszClass, &wc))
    {
        // ...register a uniquely-named window class so
        // MMCPropertyHelp the correct main window
        wc.lpszClassName = szClassName;
        wc.hIcon         = GetDefaultIcon();
        fSuccess = AfxRegisterClass (&wc);
    }

    if (fSuccess)
    {
        // Use the new child frame window class
        cs.lpszClass = szClassName;

        // remove MFC's title-munging styles
        cs.style &= ~(FWS_ADDTOTITLE | FWS_PREFIXTITLE);
    }

    return (fSuccess);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


// this code is duplicated in ..\nodemgr\propsht.cpp
BOOL CALLBACK MyEnumThreadWindProc (HWND current, LPARAM lParam)
{  // this enumerates non-child-windows created by a given thread

   if (!IsWindow (current))
      return TRUE;   // this shouldn't happen, but does!!!

   if (!IsWindowVisible (current))  // if they've explicitly hidden a window,
      return TRUE;                  // don't set focus to it.

   // we'll return hwnd in here
   HWND * phwnd = reinterpret_cast<HWND *>(lParam);

   // don't bother returning property sheet dialog window handle
   if (*phwnd == current)
      return TRUE;

   // also, don't return OleMainThreadWndClass window
   TCHAR szCaption[14];
   GetWindowText (current, szCaption, 14);
   if (!lstrcmp (szCaption, _T("OLEChannelWnd")))
      return TRUE;

   // anything else will do
   *phwnd = current;
   return FALSE;
}


/***************************************************************************\
 *
 * METHOD:  FArePropertySheetsOpen
 *
 * PURPOSE: Checks if there are propperty sheets open and asks to close them
 *          It is implemented as the following steps:
 *          1. Collect all property pages (and their children) to the stack
 *          2. Bring all the pages to the front, maintainig their z-order
 *          3. Disable all those windows, plus MMC main window to disallow switching to them
 *             untill message box is dissmissed
 *          4. Put all disabled windows to the stack, to be able to re-enable them
 *          5. (if there are any sheets) display message box asking to close the sheets
 *          6. Re-enable disabled windows
 *
 * PARAMETERS:
 *    CString* pstrUserMsg - [in] message to display
 *    bool bBringToFrontAndAskToClose [in] if need to proceed whole way. false -> just inspect and do nothing
 *
 * RETURNS:
 *    bool - [true == there are windows to close]
 *
\***************************************************************************/
bool FArePropertySheetsOpen(CString* pstrUserMsg, bool bBringToFrontAndAskToClose /* = true */ )
{
    std::stack<HWND, std::vector<HWND> >  WindowStack;
    std::stack<HWND, std::vector<HWND> >  EnableWindowStack;

    ASSERT (WindowStack.empty());

    HWND hwndData = NULL;

    while (TRUE)
    {
        USES_CONVERSION;

        // Note: No need to localize this string
        hwndData = ::FindWindowEx(NULL, hwndData, W2T(DATAWINDOW_CLASS_NAME), NULL);
        if (hwndData == NULL)
            break;  // No more windows

        ASSERT(IsWindow(hwndData));

        // Check if the window belongs to the current process
        DWORD dwPid = 0;        // Process Id
        ::GetWindowThreadProcessId(hwndData, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        DataWindowData* pData = GetDataWindowData (hwndData);
        ASSERT (pData != NULL);

        HWND hwndPropSheet = pData->hDlg;
        ASSERT (IsWindow (hwndPropSheet));
		
		// don't allow lost data window to block mmc from exiting
		// windows bug #425049	ntbug9 6/27/2001
		if ( !IsWindow (hwndPropSheet) )
			continue;

        // if propsheet has other windows or prop pages up,
        // then we send focus to them....

        // grab first one that isn't property sheet dialog
        HWND hwndOther = pData->hDlg;
        EnumThreadWindows (::GetWindowThreadProcessId(pData->hDlg, NULL),
                           MyEnumThreadWindProc, (LPARAM)&hwndOther);

        // if we got another window for this property sheet, we'll want
        // it to be on top of the property sheet after the shuffle, so
        // put it under the property sheet on the stack
        if (IsWindow (hwndOther) && (hwndOther != hwndPropSheet))
            WindowStack.push (hwndOther);

        // push the property sheet on the stack
        // of windows to bring to the foreground
        WindowStack.push (hwndPropSheet);
    }

    bool fFoundSheets = !WindowStack.empty();

    // we did the investigation, see if we were asked to do more
    if ( !bBringToFrontAndAskToClose )
        return (fFoundSheets);

    HWND hwndMsgBoxParent = NULL;

    // if we found property sheets, bring them to the foreground,
    // maintaining their original Z-order
    while (!WindowStack.empty())
    {
        HWND hwnd = WindowStack.top();
        WindowStack.pop();

        SetActiveWindow (hwnd);
        SetForegroundWindow (hwnd);

		if ( ::IsWindowEnabled(hwnd) )
		{
			// disable the pages while message box is displayed
			::EnableWindow( hwnd, FALSE );
			// remember to enable when done
			EnableWindowStack.push(hwnd);
		}
        hwndMsgBoxParent = hwnd; // the last one wins the right to be the parent :-)
    }

    if (fFoundSheets && pstrUserMsg)
    {
        // parent the message box on the top-most property page to make it obvios to the user
        CString strCaption;
        LPCTSTR szCaption = LoadString(strCaption, IDR_MAINFRAME) ? (LPCTSTR)strCaption : NULL;

        // disable main window as well
        CWnd *pMainWnd = AfxGetMainWnd();
        if ( pMainWnd && pMainWnd->IsWindowEnabled() )
        {
            pMainWnd->EnableWindow( FALSE );
            // remember to enable when done
            EnableWindowStack.push( pMainWnd->m_hWnd );
        }

        ::MessageBox( hwndMsgBoxParent, *pstrUserMsg, szCaption , MB_ICONSTOP | MB_OK );
    }

    // make everything functional again
    while (!EnableWindowStack.empty())
    {
        // enable the disabled window
        ::EnableWindow( EnableWindowStack.top(), TRUE );
        EnableWindowStack.pop();
    }

    return (fFoundSheets);
}


bool CanCloseDoc(void)
{
    CString strMessage;
    CString strConsoleName;

    AfxGetMainWnd()->GetWindowText (strConsoleName);
    FormatString1 (strMessage, IDS_ClosePropertyPagesBeforeClosingTheDoc,
                       strConsoleName);

    bool fPropSheets = FArePropertySheetsOpen(&strMessage);

    return !fPropSheets;
}


void CMainFrame::OnClose()
{
    /*
     * Bug 233682:  We need to make sure that we only handle WM_CLOSE when
     * it's dispatched from our main message pump.  If it comes from elsewhere
     * (like the message pump in a modal dialog or message box), then we're
     * likely in a state where we can't shut down cleanly.
     */
    CAMCApp* pApp = AMCGetApp();

    if (!pApp->DidCloseComeFromMainPump())
    {
        pApp->DelayCloseUntilIdle();
        return;
    }

    // Reset the flag so that while processing this WM_CLOSE if there is
    // any more WM_CLOSE messages from other sources it will not be processed.
    pApp->ResetCloseCameFromMainPump();

    if (!CanCloseDoc())
        return;

    // since this process includes event posting
    // - we should guard the function from reentrance
    static bool bInProgress = false;
    if (!bInProgress)
    {
        bInProgress = true;
        CMDIFrameWnd::OnClose();
        bInProgress = false;
    }
}

void CMainFrame::OnUpdateFilePrint(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}

void CMainFrame::OnUpdateFilePrintSetup(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}

#ifdef DBG
/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::OnMMCTraceDialog
 *
 * PURPOSE: In Debug mode, shows the Trace dialog, in response to the hotkey.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMainFrame::OnMMCTraceDialog()
{
    DoDebugTraceDialog();
}


#endif

SC CMainFrame::ScUpdateAllScopes(LONG lHint, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    // Updating all scopes may be requested as a result of document being deleted
    // in that case we do not have a document, and thus do not have any views.
    // So we are done.
    if (NULL == CAMCDoc::GetDocument())
        return S_OK;

    CAMCDoc::GetDocument()->UpdateAllViews (NULL, lHint,
                                            reinterpret_cast<CObject*>(lParam));
    return (S_OK);
}


void CMainFrame::OnViewToolbar()
{
    m_ToolBarDockSite.Toggle();
    RenderDockSites();
}

void CMainFrame::OnUpdateViewToolbar(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_ToolBarDockSite.IsVisible());
    pCmdUI->Enable(true);
}


void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
    // Don't call MFC version to size window
//  CMDIFrameWnd::OnSize (nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
    {
        RenderDockSites();
        MDIIconArrange();
    }

    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    if (pDoc != NULL)
        pDoc->SetFrameModifiedFlag();

    /*
     * If we're moving to or from the minimized state, notify child windows.
     */
    if (m_fCurrentlyMinimized != (nType == SIZE_MINIMIZED))
    {
        m_fCurrentlyMinimized = (nType == SIZE_MINIMIZED);
        SendMinimizeNotifications (m_fCurrentlyMinimized);
    }
}


void CMainFrame::OnMove(int x, int y)
{
    CMDIFrameWnd::OnMove (x, y);

    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    if (pDoc != NULL)
        pDoc->SetFrameModifiedFlag();
}

void CMainFrame::RenderDockSites()
{
    ASSERT_VALID (this);

    CRect clientRect;
    GetClientRect(&clientRect);

    m_DockingManager.BeginLayout();
    m_DockingManager.RenderDockSites(m_hWndMDIClient, clientRect);
    m_DockingManager.EndLayout();
}


void CMainFrame::AddMainFrameBars(void)
{
	/*
	 * activate our fusion context so the bars will be themed
	 */
	CThemeContextActivator activator;

    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMainFrame::AddMainFrameBars"));
    sc = ScCheckPointers(m_pRebar);
    if (sc)
        return;

    // insert the menu bar
    ASSERT (m_pMenuBar == NULL);
    m_pMenuBar = new CMenuBar;
    sc = ScCheckPointers(m_pMenuBar);
    if (sc)
        return;

    m_pMenuBar->Create  (this, m_pRebar, WS_VISIBLE, ID_MENUBAR);
    m_pMenuBar->SetMenu (GetMenu ());
    m_pMenuBar->Show    (TRUE);

    ASSERT(NULL == m_pToolBar);
    m_pToolBar = new CMMCToolBar();
    sc = ScCheckPointers(m_pToolBar);
    if (sc)
        return;

    // Create the toolbar.
    sc = m_pToolBar->ScInit(m_pRebar);
    if (sc)
        return;

    m_pToolBar->Show(TRUE, true /* In new line*/);
}


SC CMainFrame::ScCreateNewView (CreateNewViewStruct* pcnvs, bool bEmitScriptEvents /*= true*/)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    DECLARE_SC (sc, _T("CMainFrame::ScCreateNewView"));
    CAMCView* pNewView = NULL;  // avoid "initialization skipped by 'goto Error'"

    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    ASSERT(pAMCDoc != NULL);
    if (pAMCDoc == NULL)
        return (sc = E_UNEXPECTED);

    if (pcnvs == NULL)
        return (sc = E_POINTER);

    if ((AMCGetApp()->GetMode() == eMode_User_SDI) && pcnvs->fVisible)
        return (sc = E_FAIL);

    pAMCDoc->SetMTNodeIDForNewView (pcnvs->idRootNode);
    pAMCDoc->SetNewWindowOptions   (pcnvs->lWindowOptions);
    pNewView = pAMCDoc->CreateNewView (pcnvs->fVisible, bEmitScriptEvents);

    if (pNewView == NULL)
    {
        pcnvs->pViewData = NULL;
        return (sc = E_FAIL);
    }

    pcnvs->pViewData = pNewView->GetViewData();
    pcnvs->hRootNode = pNewView->GetRootNode();

    return (sc);
}


void CMainFrame::OnHelpTopics()
{
    ScOnHelpTopics();
}

SC CMainFrame::ScOnHelpTopics()
{
    DECLARE_SC(sc, _T("CMainFrame::ScOnHelpTopics"));
    /*
     * if there is a view, route through it so the snap-in gets a crack
     * at the help message (just like Help Topics from the Help menu).
     */
    CConsoleView* pConsoleView = NULL;
    sc = ScGetActiveConsoleView (pConsoleView);
    if (sc)
        return (sc);

    if (pConsoleView != NULL)
    {
        sc = pConsoleView->ScHelpTopics ();
        return sc;
    }

    HH_WINTYPE hhWinType;
    ZeroMemory(&hhWinType, sizeof(hhWinType));

    CAMCApp* pAMCApp = AMCGetApp();
    if (NULL == pAMCApp)
        return (sc = E_UNEXPECTED);

    sc = pAMCApp->ScShowHtmlHelp(SC::GetHelpFile(), 0);

    return sc;
}


void CMainFrame::OnViewRefresh()
{
    // if this doesn't fire before 10/1/99, remove this, OnUpdateViewRefresh, and all references to ID_VIEW_REFRESH (vivekj)
    ASSERT(false && "If this assert ever fires, then we need ID_VIEW_REFRESH (see above) and we can remove the 'Do we need this?' and this assert");
    CAMCTreeView* pAMCTreeView = _GetActiveAMCTreeView();
    if (pAMCTreeView)
        pAMCTreeView->ScReselect();
}

void CMainFrame::OnUpdateViewRefresh(CCmdUI* pCmdUI)
{
    // if this doesn't fire before 10/1/99, remove this, OnUpdateView, and all references to ID_VIEW_REFRESH (vivekj)
    ASSERT(false && "If this assert ever fires, then we need ID_VIEW_REFRESH (see above) and we can remove the 'Do we need this?' and this assert");
    pCmdUI->Enable(TRUE);
}

void CMainFrame::OnDestroy()
{
    if (m_hwndNextCB)
        ChangeClipboardChain(m_hwndNextCB);

    CMDIFrameWnd::OnDestroy();
}


void CMainFrame::OnUpdateFrameMenu(HMENU hMenuAlt)
{
    // let the base class select the right menu
    CMDIFrameWnd::OnUpdateFrameMenu (hMenuAlt);

    // by now, the right menu is on the frame; reflect it to the toolbar
    NotifyMenuChanged ();
}


void CMainFrame::NotifyMenuChanged ()
{
    CMenu*  pMenuCurrent = NULL;

    // make sure we don't have menus for MDI or SDI User mode
    switch (AMCGetApp()->GetMode())
    {
        case eMode_Author:
        case eMode_User:
        case eMode_User_MDI:
        case eMode_User_SDI:
            pMenuCurrent = CWnd::GetMenu();
            break;

        default:
            ASSERT (false);
            break;
    }

    m_hMenuCurrent = pMenuCurrent->GetSafeHmenu();

    if (m_pMenuBar != NULL)
    {
        // reflect the new menu on the menu bar
        m_pMenuBar->SetMenu (pMenuCurrent);

        // detach the menu from the frame
        SetMenu (NULL);
    }
}


BOOL CMainFrame::PreTranslateMessage(MSG* pMsg)
{
	/*
	 * If mainframe is not the active window then do not translate
	 * the messages. (See Bug# 119355)
	 */
	if (!m_fCurrentlyActive)
		return (FALSE);

    CRebarWnd* pwndRebar = m_pRebar->GetRebar();

    // give the rebar a crack
    if (pwndRebar && pwndRebar->PreTranslateMessage (pMsg))
        return (TRUE);

    // give the menu bar a crack (for menu accelerators)
    if (m_pMenuBar && m_pMenuBar->PreTranslateMessage (pMsg))
        return (TRUE);

    // give the base class a crack
    if ((InRenameMode() == false) &&
        (CMDIFrameWnd::PreTranslateMessage(pMsg)))
            return (TRUE);

    // not translated
    return (FALSE);
}


void CMainFrame::OnIdle ()
{
    if (m_pMenuBar != NULL)
    {
        CMDIChildWnd*   pwndActive = MDIGetActive ();

        // The menus are always visible in SDI & MDI modes.
        switch (AMCGetApp()->GetMode())
        {

            case eMode_User_SDI:
            {
                BOOL bMaximized = (pwndActive != NULL) ? pwndActive->IsZoomed () : false;
                ASSERT (bMaximized);
                ASSERT (IsMenuVisible());
            }
            break;

            case eMode_User_MDI:
                ASSERT (pwndActive != NULL);
                ASSERT (IsMenuVisible());
                break;
        }

        ASSERT (m_pMenuBar->GetMenu() != NULL);

        m_pMenuBar->OnIdle ();
    }
}

void CMainFrame::ShowMenu (bool fShow)
{
    CRebarWnd * pwndRebar = m_pRebar->GetRebar();
    pwndRebar->ShowBand (pwndRebar->IdToIndex (ID_MENUBAR), fShow);

    /*---------------------------------------------------------------------*/
    /* if we're showing, the rebar must be showing, too;                   */
    /* if we're hiding, the rebar should be hidden if no bands are visible */
    /*---------------------------------------------------------------------*/
    if ( fShow && !m_pRebar->IsVisible())
    {
        m_pRebar->Show (fShow);
        RenderDockSites ();
    }
}

static bool IsRebarBandVisible (CRebarWnd* pwndRebar, int nBandID)
{
    REBARBANDINFO   rbbi;
    ZeroMemory (&rbbi, sizeof (rbbi));
    rbbi.cbSize = sizeof (rbbi);
    rbbi.fMask  = RBBIM_STYLE;

    pwndRebar->GetBandInfo (pwndRebar->IdToIndex (nBandID), &rbbi);

    return ((rbbi.fStyle & RBBS_HIDDEN) == 0);
}

bool CMainFrame::IsMenuVisible ()
{
    return (IsRebarBandVisible (m_pRebar->GetRebar(), ID_MENUBAR));
}

/////////////////////////////////////////////////////////////////////////////
// Special UI processing depending on current active child

CString CMainFrame::GetFrameTitle()
{
    /*
     * If there's no active child window, then the document
     * is being closed.  Just use the default title.
     */
    if (MDIGetActive() != NULL)
    {
        CAMCDoc* pDocument = CAMCDoc::GetDocument();

        /*
         * If there's a document, use its title.
         */
        if (pDocument != NULL)
            return (pDocument->GetCustomTitle());
    }

    return (m_strGenericTitle);
}

void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    AfxSetWindowText(m_hWnd, GetFrameTitle());
}

BOOL CMainFrame::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
    if (!CMDIFrameWnd::LoadFrame(nIDResource, dwDefaultStyle, pParentWnd, pContext))
        return (FALSE);

    // save the title we'll use for the main frame if there's no console open
    m_strGenericTitle = m_strTitle;

    return (TRUE);
}

void CMainFrame::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID)
    {
        case ID_HELP_HELPTOPICS:
            OnHelpTopics ();
            break;

        case ID_CUSTOMIZE_VIEW:
        {
            CChildFrame* pwndActive = dynamic_cast<CChildFrame*>(MDIGetActive ());

            if (pwndActive != NULL)
                pwndActive->OnSysCommand (nID, lParam);
            else
                CMDIFrameWnd::OnSysCommand(nID, lParam);
            break;
        }

        default:
            CMDIFrameWnd::OnSysCommand(nID, lParam);
            break;
    }
}

void CMainFrame::UpdateChildSystemMenus ()
{
    ProgramMode eMode = AMCGetApp()->GetMode();

    // make necessary modifications to existing windows' system menus
    for (CWnd* pwndT = MDIGetActive();
         pwndT != NULL;
         pwndT = pwndT->GetWindow (GW_HWNDNEXT))
    {
        CMenu*  pSysMenu = pwndT->GetSystemMenu (FALSE);

        if (pSysMenu != NULL)
        {
            // if not in author mode, protect author mode windows from
            // user close
            if (eMode != eMode_Author)
            {
                // Get AMCView object for this frame
                CChildFrame *pChildFrm = dynamic_cast<CChildFrame*>(pwndT);
                ASSERT(pChildFrm != NULL);

                CAMCView* pView = pChildFrm->GetAMCView();
                ASSERT(pView != NULL);

                // if it's an author mode view, don't let user close it
                if (pView && pView->IsAuthorModeView())
                    pSysMenu->EnableMenuItem (SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
            }

            // if we're not in SDI User mode, append common stuff
            if (eMode != eMode_User_SDI)
                AppendToSystemMenu (pwndT, eMode);
        }
    }
}

void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
    CMDIFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);

    if (bSysMenu)
    {
        int nEnable = MF_GRAYED;
        CChildFrame* pwndActive = dynamic_cast<CChildFrame*>(MDIGetActive ());

        // if there's an active child, let it handle system menu validation
        if ((pwndActive != NULL) && (pwndActive->IsCustomizeViewEnabled()))
            nEnable = MF_ENABLED;

        pPopupMenu->EnableMenuItem (ID_CUSTOMIZE_VIEW, MF_BYCOMMAND | nEnable);
    }
    else
    {
        // Check if Help menu by testing for "Help Topics" item
        if (pPopupMenu->GetMenuState(ID_HELP_HELPTOPICS, MF_BYCOMMAND) != UINT(-1))
        {
            // View will update item
            CAMCView* pView = GetActiveAMCView();
            if (pView != NULL)
            {
                pView->UpdateSnapInHelpMenus(pPopupMenu);
            }
        }
    }
}

LRESULT CMainFrame::OnShowSnapinHelpTopic (WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC (sc, _T("CMainFrame::OnShowSnapinHelpTopic"));

    CConsoleView* pConsoleView;
    sc = ScGetActiveConsoleView (pConsoleView);

    if (sc)
        return (sc.ToHr());

    /*
     * ScGetActiveConsoleView will return success (S_FALSE) even if there's no
     * active view.  This is a valid case, occuring when there's no console
     * file open.  In this particular circumstance, it is an unexpected
     * failure since we shouldn't get to this point in the code if there's
     * no view.
     */
    sc = ScCheckPointers (pConsoleView, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    // forward this on the the active AMC view window
    USES_CONVERSION;
    sc = pConsoleView->ScShowSnapinHelpTopic (W2T (reinterpret_cast<LPOLESTR>(lParam)));

    return (sc.ToHr());
}

SC CMainFrame::ScGetMenuAccelerators (LPTSTR pBuffer, int cchBuffer)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if ((m_pMenuBar != NULL) && IsMenuVisible())
        m_pMenuBar->GetAccelerators (cchBuffer, pBuffer);

    else if (cchBuffer > 0)
        pBuffer[0] = 0;

    return (S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:      CMainFrame::ScShowMMCMenus
//
//  Synopsis:    Show or hide MMC menus. (Action/View/Favs)
//
//  Arguments:   bShow
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMainFrame::ScShowMMCMenus (bool bShow)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMainFrame::ScShowMMCMenus"));

    if ((m_pMenuBar != NULL) && IsMenuVisible())
        sc = m_pMenuBar->ScShowMMCMenus(bShow);
    else
        return (sc = E_UNEXPECTED);

    return (sc);
}

//////////////////////////////////////////////////////////////////////////////
// This message is received from the node manager whenever a property
// sheet use the MMCPropertyChangeNotify() api.
// The wParam contains a copy of the handle information which must be freed.
//
LRESULT CMainFrame::OnPropertySheetNotify(WPARAM wParam, LPARAM lParam)
{
    TRACE_METHOD(CAMCView, OnPropertySheetNotify);

    ASSERT(wParam != 0);
    LPPROPERTYNOTIFYINFO pNotify = reinterpret_cast<LPPROPERTYNOTIFYINFO>(wParam);

    // Crack the information from the handle object and send a notify to the snap-in
    ASSERT((pNotify->pComponent != NULL || pNotify->pComponentData != NULL));

    if (pNotify->pComponent != NULL)
        pNotify->pComponent->Notify(NULL, MMCN_PROPERTY_CHANGE, pNotify->fScopePane, lParam);

    else if (pNotify->pComponentData != NULL)
        pNotify->pComponentData->Notify(NULL, MMCN_PROPERTY_CHANGE, pNotify->fScopePane, lParam);

    ::GlobalFree(pNotify);
    return TRUE;
}


LRESULT CMainFrame::OnSetText (WPARAM wParam, LPARAM lParam)
{
    LRESULT rc;
    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    /*
     * If the document has a custom title, we don't want to append
     * the maxed child's title to the main frame's title.  To do this,
     * we'll bypass DefFrameProc and go directly to DefWindowProc.
     */
    if ((pDoc != NULL) && pDoc->HasCustomTitle())
        rc = CWnd::DefWindowProc (WM_SETTEXT, wParam, lParam);
    else
        rc = Default();

    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}

void CMainFrame::OnPaletteChanged( CWnd* pwndFocus)
{
    if (pwndFocus != this)
    {
        CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
        if (pAMCDoc)
        {
            HWND hwndFocus = pwndFocus->GetSafeHwnd();
            CAMCViewPosition pos = pAMCDoc->GetFirstAMCViewPosition();
            while (pos != NULL)
            {
                CAMCView* pv = pAMCDoc->GetNextAMCView(pos);

                if (pv)
                    pv->SendMessage(WM_PALETTECHANGED, (WPARAM)hwndFocus);
            }
        }
    }

    CMDIFrameWnd::OnPaletteChanged(pwndFocus);
}

BOOL CMainFrame::OnQueryNewPalette()
{
    CAMCView* pAMCView = GetActiveAMCView();
    if (pAMCView != NULL)
        return pAMCView->SendMessage(WM_QUERYNEWPALETTE);

    return CMDIFrameWnd::OnQueryNewPalette();
}

void CMainFrame::OnConsoleProperties()
{
    CConsolePropSheet().DoModal();
}

void CMainFrame::SetIconEx (HICON hIcon, BOOL fBig)
{
    if (hIcon == NULL)
        hIcon = GetDefaultIcon();

    SetIcon (hIcon, fBig);

    /*
     * make sure the child icon on the menu bar gets updated
     */
    ASSERT (m_pMenuBar != NULL);
    m_pMenuBar->InvalidateMaxedChildIcon();
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::GetDefaultIcon
 *
 *
 *--------------------------------------------------------------------------*/

HICON CMainFrame::GetDefaultIcon () const
{
    return (AfxGetApp()->LoadIcon (IDR_MAINFRAME));
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::SendMinimizeNotifications
 *
 * Causes each CChildFrame to send NCLBK_MINIMIZED.
 *--------------------------------------------------------------------------*/

void CMainFrame::SendMinimizeNotifications (bool fMinimized) const
{
    CWnd* pwndMDIChild;

    for (pwndMDIChild  = m_wndMDIClient.GetWindow (GW_CHILD);
         pwndMDIChild != NULL;
         pwndMDIChild  = pwndMDIChild->GetWindow (GW_HWNDNEXT))
    {
        // There used to be an ASSERT_ISKINDOF. However, that had to change to an if
        // since the active background denies that assumption. See bug 428906.
        if(pwndMDIChild->IsKindOf(RUNTIME_CLASS(CChildFrame)))
            (static_cast<CChildFrame*>(pwndMDIChild))->SendMinimizeNotification (fMinimized);
    }
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::OnNcActivate
 *
 * WM_NCACTIVATE handler for CMainFrame.
 *--------------------------------------------------------------------------*/

BOOL CMainFrame::OnNcActivate(BOOL bActive)
{
    BOOL rc = CMDIFrameWnd::OnNcActivate(bActive);
    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::OnNcPaint
 *
 * WM_NCPAINT handler for CMainFrame.
 *--------------------------------------------------------------------------*/

void CMainFrame::OnNcPaint()
{
    Default();
    DrawFrameCaption (this, m_fCurrentlyActive);
}


/*+-------------------------------------------------------------------------*
 * MsgForwardingEnumProc
 *
 *
 *--------------------------------------------------------------------------*/

static BOOL CALLBACK MsgForwardingEnumProc (HWND hwnd, LPARAM lParam)
{
    /*
     * if this isn't an MFC window, forward the message
     */
    if (CWnd::FromHandlePermanent(hwnd) == NULL)
    {
        const MSG* pMsg = (const MSG*) lParam;
        SendMessage (hwnd, pMsg->message, pMsg->wParam, pMsg->lParam);
    }

    /*
     * continue enumeration
     */
    return (true);
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CMainFrame.
 *--------------------------------------------------------------------------*/

void CMainFrame::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    CMDIFrameWnd::OnSettingChange(uFlags, lpszSection);

    /*
     * MFC will send WM_SETTINGCHANGEs to all descendent MFC windows.
     * There are some non-MFC windows owned by nodemgr that we also want
     * to get this message.  We'll send these manually.
     */
    const MSG* pMsg = GetCurrentMessage();
    EnumChildWindows (m_hWnd, MsgForwardingEnumProc, (LPARAM) pMsg);

    /*
     * If we're in SDI mode, then there can be some redrawing problems
     * around the caption if the caption height changes significantly.
     * (This is a USER MDI bug.)  We can work around it by manually
     * placing the maximized child window within the MDI client.
     *
     * Note that restoring and re-maximizing the active child window
     * will put the window in the right place, it has the side effect
     * of undesired window flicker (see 375430, et al) as well as
     * a bunch of annoying sound effects if you have sounds associated
     * with the "Restore Down" and/or "Maximize" sound events.
     */
    if (AMCGetApp()->GetMode() == eMode_User_SDI)
    {
        CMDIChildWnd* pwndActive = MDIGetActive();

        if (pwndActive)
        {
            /*
             * get the size of the MDI client
             */
            CRect rect;
            m_wndMDIClient.GetClientRect (rect);

            /*
             * inflate the MDI client's client rect by the size of sizing
             * borders, and add room for the caption at the top
             */
            rect.InflateRect (GetSystemMetrics (SM_CXFRAME),
                              GetSystemMetrics (SM_CYFRAME));
            rect.top -= GetSystemMetrics (SM_CYCAPTION);

            /*
             * put the window in the right place
             */
            pwndActive->MoveWindow (rect);
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::ScGetActiveStatusBar
 *
 * Returns the CConsoleStatusBar interface for the active view.  If there's no
 * active view, pStatusBar is set to NULL and S_FALSE is returned.
 *--------------------------------------------------------------------------*/

SC CMainFrame::ScGetActiveStatusBar (
    CConsoleStatusBar*& pStatusBar)     /* O:CConsoleStatusBar for active view*/
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CMainFrame::ScGetActiveStatusBar"));

    pStatusBar = dynamic_cast<CConsoleStatusBar*>(GetActiveFrame());

    if (pStatusBar == NULL)
        sc = S_FALSE;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::ScGetActiveConsoleView
 *
 * Returns the CConsoleView interface for the active view.  If there's no
 * active view, pConsoleView is set to NULL and S_FALSE is returned.
 *--------------------------------------------------------------------------*/

SC CMainFrame::ScGetActiveConsoleView (
    CConsoleView*& pConsoleView)        /* O:CConsoleView for active view   */
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CMainFrame::ScGetActiveConsoleView"));

    pConsoleView = GetActiveAMCView();

    if (pConsoleView == NULL)
        sc = S_FALSE;

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CMainFrame::OnUnInitMenuPopup
 *
 * PURPOSE: Used to remove accelerators once system menus are dismissed
 *
 * PARAMETERS:
 *    WPARAM wParam
 *    LPARAM lParam
 *
 * RETURNS:
 *    LRESULT    - result code
 *
\***************************************************************************/
afx_msg LRESULT CMainFrame::OnUnInitMenuPopup(WPARAM wParam, LPARAM lParam)
{
    // hide accelerators whenever leaving system popup
    if ( HIWORD(lParam) & MF_SYSMENU )
    {
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mdiclint.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       MDIClint.cpp
//
//--------------------------------------------------------------------------

// MDIClint.cpp : implementation file
//

#include "stdafx.h"
#include "amc.h"
#include "MDIClint.h"
#include "amcview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


//############################################################################
//############################################################################
//
// Implementation of CMDIClientWnd
//
//############################################################################
//############################################################################
CMDIClientWnd::CMDIClientWnd()
{
}

CMDIClientWnd::~CMDIClientWnd()
{
}


BEGIN_MESSAGE_MAP(CMDIClientWnd, CWnd)
    //{{AFX_MSG_MAP(CMDIClientWnd)
    ON_WM_CREATE()
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


int CMDIClientWnd::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    return BC::OnCreate(lpCreateStruct);

    // Do not add anything here because this function will never be called.
    // The CMDIClientWnd window is subclassed after it is created.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\idle.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      idle.h
 *
 *  Contents:  Interface file for CIdleTaskQueue
 *
 *  History:   13-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef IDLE_H
#define IDLE_H
#pragma once

#include <queue>

typedef enum tagIdleTaskPriority
{
    ePriority_Low,
    ePriority_Normal,
    ePriority_High
} IdleTaskPriority;


class CIdleTask
{
public:
    CIdleTask();
    virtual ~CIdleTask();

    CIdleTask(const CIdleTask &rhs);
    CIdleTask&   operator= (const CIdleTask& rhs);

    virtual SC ScDoWork() = 0;
    virtual SC ScGetTaskID(ATOM* pID) = 0;

    /*
     * Merge from pitMergeFrom into the called idle task.
     *
     * S_OK     the tasks have been merged and pitMergeFrom can be discarded
     *
     * S_FALSE  these two tasks cannot be merged and you wish the idle task
     *          manager to continue searching for idle tasks into which
     *          pitMergeFrom can be merged.
     *
     * E_FAIL   these two tasks cannot be merged and you do not wish the idle
     *          task manager to continue searching for idle tasks into which
     *          pitMergeFrom can be merged.
     */
    virtual SC ScMerge(CIdleTask* pitMergeFrom) = 0;
};



class CIdleQueueEntry
{
public:
    CIdleQueueEntry () :
        m_ePriority (ePriority_Normal)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    }

    CIdleQueueEntry (CIdleTask *pIdleTask, IdleTaskPriority ePriority = ePriority_Normal) :
        m_pTask(pIdleTask), m_ePriority (ePriority)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    }

    ~CIdleQueueEntry()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    }

    CIdleQueueEntry(const CIdleQueueEntry &rhs);
    CIdleQueueEntry&   operator= (const CIdleQueueEntry& rhs);

    bool operator< (const CIdleQueueEntry& other) const
    {
        return (m_ePriority < other.m_ePriority);
    }

private:
    CIdleTask *         m_pTask;
    IdleTaskPriority    m_ePriority;

public:
    CIdleTask *         GetTask()      const {return m_pTask;}
    IdleTaskPriority    GetPriority () const {return m_ePriority;}

};


/*
 * Determines if a CIdleQueueEntry matches a given task ID.
 */
struct EqualTaskID : std::binary_function<CIdleQueueEntry, ATOM, bool>
{
    bool operator()(const CIdleQueueEntry& iqe, ATOM idToMatch) const
    {
        ATOM id;

        SC  sc = iqe.GetTask()->ScGetTaskID(&id);
        if(sc)
            return (false);

        return (id == idToMatch);
    }
};


/*
 * accessible_priority_queue - thin wrapper around std::prority_queue to
 * provide access to the container iterators
 */
template<class _Ty, class _C = std::vector<_Ty>, class _Pr = std::less<_C::value_type> >
class accessible_priority_queue : public std::priority_queue<_Ty, _C, _Pr>
{
public:
    typedef _C::iterator iterator;

    iterator begin()
        { return (c.begin()); }

    iterator end()
        { return (c.end()); }
};


class CIdleTaskQueue
{
public:
    CIdleTaskQueue();
    ~CIdleTaskQueue();


    // CIdleTaskManager methods
    SC ScPushTask     (CIdleTask* pitToPush, IdleTaskPriority ePriority);
    SC ScPerformNextTask();
    SC ScGetTaskCount (LONG_PTR* plCount);

private:
    typedef accessible_priority_queue<CIdleQueueEntry> Queue;

    Queue::iterator FindTaskByID (
        Queue::iterator itFirst,
        Queue::iterator itLast,
        ATOM            idToFind);

private:
    Queue   m_queue;

};

#endif /* IDLE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\kbdnav.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      kbdnav.cpp
 *
 *  Contents:  Implementation of CKeyboardNavDelayTimer
 *
 *  History:   4-May-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "kbdnav.h"


#ifdef DBG
CTraceTag tagKeyboardNavDelay (_T("Keyboard Navigation"), _T("Keyboard Navigation Delay"));
#endif


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::CKeyboardNavDelayTimer
 *
 * Constructs a CKeyboardNavDelayTimer object.
 *--------------------------------------------------------------------------*/

CKeyboardNavDelayTimer::CKeyboardNavDelayTimer () :
    m_nTimerID  (0)
{
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::~CKeyboardNavDelayTimer
 *
 * Destroys a CKeyboardNavDelayTimer object.
 *--------------------------------------------------------------------------*/

CKeyboardNavDelayTimer::~CKeyboardNavDelayTimer ()
{
    ScStopTimer();
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::TimerProc
 *
 * Callback function called when a timer started by this class fires.
 *--------------------------------------------------------------------------*/

VOID CALLBACK CKeyboardNavDelayTimer::TimerProc (
	HWND		hwnd,
	UINT		uMsg,
	UINT_PTR	idEvent,
	DWORD		dwTime)
{
	CTimerMap& TimerMap = GetTimerMap();

	/*
	 * locate the CKeyboardNavDelayTimer object corresponding to this timer event
	 */
    CTimerMap::iterator itTimer = TimerMap.find (idEvent);

    // ASSERT(itTimer != TimerMap.end());
    // The above assertion is not valid because: (From the SDK docs):
    // The KillTimer function does not remove WM_TIMER messages already posted to the message queue.

    if (itTimer != TimerMap.end())
    {
        CKeyboardNavDelayTimer *pNavDelay = itTimer->second;

		if (pNavDelay != NULL)
		{
			Trace (tagKeyboardNavDelay, _T ("Timer fired: id=%d"), pNavDelay->m_nTimerID);
			pNavDelay->OnTimer();
		}
    }
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::ScStartTimer
 *
 *
 *--------------------------------------------------------------------------*/

SC CKeyboardNavDelayTimer::ScStartTimer()
{
	DECLARE_SC (sc, _T("CKeyboardNavDelayTimer::ScStartTimer"));

    /*
     * shouldn't start a timer if it's started already
     */
    ASSERT (m_nTimerID == 0);

    /*
     * Get the menu popout delay and use that for the delay before
     * changing the result pane.  If the system doesn't support
     * SPI_GETMENUSHOWDELAY (i.e. Win95, NT4), use a value slightly
     * longer than the longer of keyboard repeat delay and keyboard
     * repeat rate.
     */
    DWORD dwDelay;

    if (!SystemParametersInfo (SPI_GETMENUSHOWDELAY, 0, &dwDelay, false))
    {
        /*
         * Get the keyboard delay and convert to milliseconds.  The ordinal
         * range is from 0 (approximately 250 ms dealy) to 3 (approximately
         * 1 sec delay).  The equation to convert from ordinal to approximate
         * milliseconds is:
         *
         *      msec = (ordinal + 1) * 250;
         */
        DWORD dwKeyboardDelayOrdinal;
        SystemParametersInfo (SPI_GETKEYBOARDDELAY, 0, &dwKeyboardDelayOrdinal, false);
        DWORD dwKeyboardDelay = (dwKeyboardDelayOrdinal + 1) * 250;

        /*
         * Get the keyboard speed and convert to milliseconds.  The ordinal
         * range is from 0 (approximately 2.5 reps per second, or 400 msec
         * interval) to 31 (approximately 30 reps per second, or 33 msec
         * interval).  (The documentation has this reversed.)  The equation
         * to convert from ordinal to approximate milliseconds is:
         *
         *      msec = (ordinal * -12) + 400;
         */
        DWORD dwKeyboardRateOrdinal;
        SystemParametersInfo (SPI_GETKEYBOARDSPEED,  0, &dwKeyboardRateOrdinal, false);
        DWORD dwKeyboardRate = (dwKeyboardRateOrdinal * -12) + 400;

        dwDelay = std::_MAX (dwKeyboardDelay, dwKeyboardRate) + 50;
    }

    m_nTimerID = SetTimer(NULL, 0, dwDelay, TimerProc);
	if (m_nTimerID == 0)
		return (sc.FromLastError());

    GetTimerMap()[m_nTimerID] = this; // set up the timer map.
    Trace (tagKeyboardNavDelay, _T("Started new timer: id=%d, delay=%d milliseconds"), m_nTimerID, dwDelay);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::ScStopTimer
 *
 * Stops the timer running for this CKeyboardNavDelayTimer, if it is running
 *--------------------------------------------------------------------------*/

SC CKeyboardNavDelayTimer::ScStopTimer()
{
	DECLARE_SC (sc, _T("CKeyboardNavDelayTimer::ScStopTimer"));

    if (m_nTimerID != 0)
    {
		CTimerMap&			TimerMap = GetTimerMap();
		CTimerMap::iterator	itTimer  = TimerMap.find (m_nTimerID);
		ASSERT (itTimer != TimerMap.end());

        TimerMap.erase (itTimer);
        Trace (tagKeyboardNavDelay, _T("Stopped timer: id=%d"), m_nTimerID);
        UINT_PTR nTimerID = m_nTimerID;
		m_nTimerID = 0;

        if (!KillTimer (NULL, nTimerID))
			return (sc.FromLastError());
    }

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::GetTimerMap
 *
 * Returns a reference to the data structure that maps timer IDs to
 * CKeyboardNavDelayTimer objects.
 *--------------------------------------------------------------------------*/

CKeyboardNavDelayTimer::CTimerMap& CKeyboardNavDelayTimer::GetTimerMap()
{
    static CTimerMap map;
    return (map);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mdiclint.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       MDIClint.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_MDICLINT_H__22C6BB09_294D_11D1_A7D4_00C04FD8D565__INCLUDED_)
#define AFX_MDICLINT_H__22C6BB09_294D_11D1_A7D4_00C04FD8D565__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MDIClint.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CMDIClientWnd window

class CMDIClientWnd : public CWnd
{
    typedef CWnd BC;
// Construction
public:
    CMDIClientWnd();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMDIClientWnd)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMDIClientWnd();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMDIClientWnd)
        // NOTE - the ClassWizard will add and remove member functions here.
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP();
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MDICLINT_H__22C6BB09_294D_11D1_A7D4_00C04FD8D565__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mainfrm.h ===
///+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mainfrm.h
//
//--------------------------------------------------------------------------

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DOCKSITE_H__
#include "docksite.h"
#endif

//forward prototypes
class CAMCView;
class CAMCTreeView;
class CMenuBar;
class CMMCToolBar;
class CToolbarTracker;

#ifndef _STATBAR_H
#include "statbar.h"
#endif

#include "MDIClint.h"
#include "conframe.h"       // for CConsoleFrame


#define ID_MENUBAR      0x1001
#define ID_TOOLBAR      0x1002

class CMainFrame : public CMDIFrameWnd, public CConsoleFrame, public CTiedObject
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame();

// Attributes
public:
    SC  ScGetFrame(Frame** ppFrame);
    SC  ScMaximize();
    SC  ScMinimize();
    SC  ScRestore();
    SC  ScSetPosition(const RECT &rect);
    SC  ScGetPosition(RECT &rect);

// Operations
public:
    void NotifyMenuChanged ();
    void OnIdle ();
    void SetInRenameMode(bool b)
    {
        m_bInRenameMode = b;
    }

    bool InRenameMode(void) const
    {
        return m_bInRenameMode;
    }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual void OnUpdateFrameMenu(HMENU hMenuAlt);

public:  // control bar embedded members
    CMenuBar *          m_pMenuBar;
    CMMCToolBar*        m_pToolBar;
    CMDIClientWnd       m_wndMDIClient;

//Operations
public:
    void RenderDockSites();
    bool IsMenuVisible();
    void ShowMenu(bool bShow);
    void UpdateChildSystemMenus ();
    void SetIconEx (HICON hIcon, BOOL fBig);

    void SetFocusedChildWnd(CMDIChildWnd* pWnd) { m_pMDIChildWndFocused = pWnd; }
    CMDIChildWnd* GetFocusedChildWnd() { return m_pMDIChildWndFocused; }
    void SetWindowToNotifyCBChange(HWND hwnd) { m_hwndToNotifyCBChange = hwnd; }
    CAMCView* GetActiveAMCView();

    HACCEL& GetAccelTable()
    {
        return (m_hAccelTable);
    }

    CMenu* GetMenu () const
    {
        return (CMenu::FromHandle (m_hMenuCurrent));
    }

    CRebarWnd* GetRebar () const
    {
        return (m_pRebar->GetRebar());
    }

    CRebarDockWindow* GetRebarDockWindow()
    {
        return (m_pRebar);
    }

    CToolbarTracker* GetToolbarTracker () const
    {
        return (m_pToolbarTracker);
    }

    CMenuBar* GetMenuBar() const
    {
        return (m_pMenuBar);
    }

    CMMCToolBar* GetMainToolbar()
    {
        return m_pToolBar;
    }
public:
    // CConsoleFrame methods
    virtual SC ScGetActiveStatusBar   (CConsoleStatusBar*& pStatusBar);
    virtual SC ScGetActiveConsoleView (CConsoleView*& pConsoleView);
    virtual SC ScCreateNewView        (CreateNewViewStruct* pcnvs,
                                       bool bEmitScriptEvents = true);
    virtual SC ScUpdateAllScopes      (LONG lHint, LPARAM lParam);
    virtual SC ScGetMenuAccelerators  (LPTSTR pBuffer, int cchBuffer);
    virtual SC ScShowMMCMenus         (bool bShow);

protected:  // control bar embedded members
    virtual CWnd* GetMessageBar()
        { return (NULL); }

    HICON GetDefaultIcon () const;

    CDockManager<CDockSite>    m_DockingManager;
    CDockSite   m_ToolBarDockSite;
    CRebarDockWindow*   m_pRebar;
    CToolbarTracker*    m_pToolbarTracker;

    CMDIChildWnd*   m_pMDIChildWndFocused;

//Operations
protected:
    void AddMainFrameBars(void);
    void CommonConstruct(void);

// Generated message map functions
// CODEWORK message reflection not working yet
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDrawClipboard();
    afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
    afx_msg void OnUpdateFilePrint(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFilePrintSetup(CCmdUI* pCmdUI);
    afx_msg void OnClose();
    afx_msg void OnViewToolbar();
    afx_msg void OnUpdateViewToolbar(CCmdUI* pCmdUI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnViewRefresh();
    afx_msg void OnUpdateViewRefresh(CCmdUI* pCmdUI);
    afx_msg void OnDestroy();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    afx_msg void OnConsoleProperties();
    afx_msg void OnMove(int x, int y);
    afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnNcPaint();
    afx_msg void OnPaletteChanged(CWnd* pwndFocus);
    afx_msg BOOL OnQueryNewPalette( );
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LRESULT OnUnInitMenuPopup(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG

    #ifdef DBG
    afx_msg void OnMMCTraceDialog();
    #endif

    afx_msg LRESULT OnShowSnapinHelpTopic(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnPropertySheetNotify(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg void OnWindowNew();
    DECLARE_MESSAGE_MAP()

    // These need to be public so that the app can get to them.
public:
    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);

    afx_msg void OnHelpTopics();
    SC           ScOnHelpTopics();


private:
    HWND    m_hwndNextCB;
    HWND    m_hwndToNotifyCBChange;
    HMENU   m_hMenuCurrent;
    bool    m_bInRenameMode;
    bool    m_fCurrentlyMinimized;
    bool    m_fCurrentlyActive;
    CString m_strGenericTitle;

    CString GetFrameTitle();
    CAMCTreeView* _GetActiveAMCTreeView();
    void SendMinimizeNotifications (bool fMinimized) const;
};


inline CMainFrame* AMCGetMainWnd()
{
    /*
     * Note:  the dynamic_cast here can fail.  Under certain, not understood
     * circumstances, AfxGetMainWnd can return a pointer to CTempWnd instead
     * of CMainFrame.
     *
     * Any callers of this function *must* check for a NULL return value.
     */

    CWnd *pWnd = AfxGetMainWnd();
    CMainFrame *pMainFrame = NULL;

    try
    {
        pMainFrame = dynamic_cast<CMainFrame*>(pWnd);
    }
    catch (...)
    {
        pMainFrame = NULL;
    }

    return (pMainFrame);
}

inline CRebarWnd* AMCGetRebar()
{
    CMainFrame* pMainFrame = AMCGetMainWnd();
    if (NULL == pMainFrame)
        return NULL;

    return pMainFrame->GetRebar();
}

bool FArePropertySheetsOpen(CString* pstrUserMsg, bool bBringToFrontAndAskToClose = true);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mdiuisim.cpp ===
/*--------------------------------------------------------------------------*
 * 
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      mdiuisim.cpp
 *
 *  Contents:  Implementation file for CMDIMenuDecoration
 *
 *  History:   17-Nov-97 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "mdiuisim.h"


struct MDIDataMap {
    DWORD   dwStyle;
    int     nCommand;
};

const int cMapEntries = 4;

const MDIDataMap anMDIDataMap[cMapEntries] = {
    {   MMDS_CLOSE,     SC_CLOSE    },      // DFCS_CAPTIONCLOSE   
    {   MMDS_MINIMIZE,  SC_MINIMIZE },      // DFCS_CAPTIONMIN     
    {   MMDS_MAXIMIZE,  SC_MAXIMIZE },      // DFCS_CAPTIONMAX     
    {   MMDS_RESTORE,   SC_RESTORE  },      // DFCS_CAPTIONRESTORE 
};

// this array is in the order the decorations are drawn, left-to-right
const int anDrawOrder[cMapEntries] = {
    DFCS_CAPTIONMIN, 
    DFCS_CAPTIONRESTORE,  
    DFCS_CAPTIONMAX, 
    DFCS_CAPTIONCLOSE
};



/*--------------------------------------------------------------------------*
 * DrawCaptionControl 
 *
 *
 *--------------------------------------------------------------------------*/

static void DrawCaptionControl (
    CDC *   pdc,
    LPCRECT pRect,
    int     nIndex,
    bool    fPushed)
{
    const int   cxInflate = -1;
    const int   cyInflate = -2;
    CRect       rectDraw  = pRect;

    rectDraw.InflateRect (cxInflate, cyInflate);
    rectDraw.OffsetRect  ((nIndex == DFCS_CAPTIONMIN) ? 1 : -1, 0);

    if (fPushed)
        nIndex |= DFCS_PUSHED;

    pdc->DrawFrameControl (rectDraw, DFC_CAPTION, nIndex);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::CMouseTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CMDIMenuDecoration::CMouseTrackContext::CMouseTrackContext (
    CMDIMenuDecoration* pMenuDec,
    CPoint              point)
    :   m_fHotButtonPressed (false),
        m_pMenuDec          (pMenuDec)
{
    ASSERT_VALID (m_pMenuDec);

    // set up hit testing rectangles for each button
    int     cxButton = GetSystemMetrics (SM_CXMENUSIZE);
    int     cyButton = GetSystemMetrics (SM_CYMENUSIZE);
    DWORD   dwStyle  = m_pMenuDec->GetStyle ();
    
    CRect   rectT (0, 0, cxButton, cyButton);
    
    for (int i = 0; i < cMapEntries; i++)
    {
        int nDataIndex = anDrawOrder[i];

        if (dwStyle & anMDIDataMap[nDataIndex].dwStyle)
        {
            m_rectButton[nDataIndex] = rectT;
            rectT.OffsetRect (cxButton, 0);
        }
        else
            m_rectButton[nDataIndex].SetRectEmpty();
    }

    m_nHotButton = HitTest (point);
    ASSERT (m_nHotButton != -1);

    // if the user clicked on a disbled button, we don't want to track -- punt!
    if (!m_pMenuDec->IsSysCommandEnabled (anMDIDataMap[m_nHotButton].nCommand))
        AfxThrowUserException ();

    // press the hot button initially
    ToggleHotButton ();

    // capture the mouse
    m_pMenuDec->SetCapture ();
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::~CMouseTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CMDIMenuDecoration::CMouseTrackContext::~CMouseTrackContext ()
{
    ReleaseCapture();

    if (m_fHotButtonPressed)
        ToggleHotButton ();
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::Track 
 *
 *
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::CMouseTrackContext::Track (CPoint point)
{
    int nButton = HitTest (point);

    /*-----------------------------------------------------*/
    /* if we're over the hot button and it's not pressed,  */
    /* or we're not over the hot button and it is pressed, */
    /* toggle the state of the hot button                  */
    /*-----------------------------------------------------*/
    if (((nButton != m_nHotButton) &&  m_fHotButtonPressed) ||
        ((nButton == m_nHotButton) && !m_fHotButtonPressed))
    {
        ToggleHotButton ();
    }
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::ToggleHotButton 
 *
 *
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::CMouseTrackContext::ToggleHotButton ()
{
    DrawCaptionControl (&CClientDC (m_pMenuDec),
                        m_rectButton[m_nHotButton], m_nHotButton,
                        m_fHotButtonPressed = !m_fHotButtonPressed);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::HitTest 
 *
 *
 *--------------------------------------------------------------------------*/

int CMDIMenuDecoration::CMouseTrackContext::HitTest (CPoint point) const
{
    for (int i = 0; i < countof (m_rectButton); i++)
    {
        if (m_rectButton[i].PtInRect (point))
            return (i);
    }

    return (-1);
}


/////////////////////////////////////////////////////////////////////////////
// CMDIMenuDecoration

CMDIMenuDecoration::CMDIMenuDecoration()
{
    // anMDIDataMap is indexed by these values
    ASSERT (DFCS_CAPTIONCLOSE   == 0);
    ASSERT (DFCS_CAPTIONMIN     == 1);
    ASSERT (DFCS_CAPTIONMAX     == 2);
    ASSERT (DFCS_CAPTIONRESTORE == 3);
}

CMDIMenuDecoration::~CMDIMenuDecoration()
{
}


BEGIN_MESSAGE_MAP(CMDIMenuDecoration, CWnd)
    //{{AFX_MSG_MAP(CMDIMenuDecoration)
    ON_WM_PAINT()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMDIMenuDecoration message handlers



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnPaint
 *
 * WM_PAINT handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnPaint() 
{
    CPaintDC dcPaint (this);

//#define DRAW_OFF_SCREEN
#ifndef DRAW_OFF_SCREEN
    CDC& dc = dcPaint;
#else
    CRect rect;
    GetClientRect (rect);
    const int cx = rect.Width();
    const int cy = rect.Height();

    CDC dcMem;
    CDC& dc = dcMem;
    dcMem.CreateCompatibleDC (&dcPaint);

    CBitmap bmMem;
    bmMem.CreateCompatibleBitmap (&dcPaint, cx, cy);

    CBitmap* pbmOld = dcMem.SelectObject (&bmMem);
#endif

    if (dcPaint.m_ps.fErase)
        dc.FillRect (&dcPaint.m_ps.rcPaint, AMCGetSysColorBrush (COLOR_BTNFACE));

    int     cxButton = GetSystemMetrics (SM_CXMENUSIZE);
    int     cyButton = GetSystemMetrics (SM_CYMENUSIZE);
    DWORD   dwStyle  = GetStyle ();

    CRect   rectDraw (0, 0, cxButton, cyButton);

    // make sure we don't have both the maximize and restore styles
    ASSERT ((dwStyle & (MMDS_MAXIMIZE | MMDS_RESTORE)) != 
                       (MMDS_MAXIMIZE | MMDS_RESTORE));

    // we shouldn't get here if we're tracking
    ASSERT (m_spTrackCtxt.get() == NULL);

    CMenu*  pSysMenu = GetActiveSystemMenu ();

    for (int i = 0; i < cMapEntries; i++)
    {
        int nDataIndex = anDrawOrder[i];

        if (dwStyle & anMDIDataMap[nDataIndex].dwStyle)
        {
            int nState = nDataIndex;

            if (!IsSysCommandEnabled (anMDIDataMap[nDataIndex].nCommand, pSysMenu))
                nState |= DFCS_INACTIVE;

            DrawCaptionControl (&dc, rectDraw, nState, false);
            rectDraw.OffsetRect (cxButton, 0);
        }
    }

#ifdef DRAW_OFF_SCREEN
    dcPaint.BitBlt (0, 0, cx, cy, &dcMem, 0, 0, SRCCOPY);
    dcMem.SelectObject (pbmOld);
#endif
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnWindowPosChanging
 *
 * WM_WINDOWPOSCHANGING handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
    DWORD   dwStyle = GetStyle ();

    if (dwStyle & MMDS_AUTOSIZE)
    {
        int cxButton = GetSystemMetrics (SM_CXMENUSIZE);
        int cyButton = GetSystemMetrics (SM_CYMENUSIZE);

        lpwndpos->cx = 0;
        lpwndpos->cy = cyButton;

        dwStyle &= MMDS_BTNSTYLES;

        while (dwStyle != 0)
        {
            if (dwStyle & 1)
                lpwndpos->cx += cxButton;

            dwStyle >>= 1;
        }
    }

    else
        CWnd::OnWindowPosChanging(lpwndpos);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnLButtonDown
 *
 * WM_LBUTTONDOWN handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

// this routine needs placement new syntax -- 
// temporarily remove MFC's incompatible placement new definition
#ifdef _DEBUG
#undef new
#endif

void CMDIMenuDecoration::OnLButtonDown(UINT nFlags, CPoint point) 
{
    typedef std::auto_ptr<char> CharPtr;

    CWnd::OnLButtonDown(nFlags, point);

    try
    {
        /*------------------------------------------------------------------*/
        /* This looks ugly.  We'd like to write:                            */
        /*                                                                  */
        /*     m_spTrackCtxt = CMouseTrackContextPtr (                      */
        /*                         new CMouseTrackContext (this, point));   */
        /*                                                                  */
        /* but CMouseTrackContext's ctor might throw an exception.  If it   */
        /* does, the smart pointer won't yet have been initialized so the   */
        /* CMouseTrackContext won't be deleted.                             */
        /*                                                                  */
        /* To get around it, we'll create a smart pointer pointing to a     */
        /* dynamically-allocated buffer of the right size.  That buffer     */
        /* will not leak with an exception.  We can then use a placement    */
        /* new to initialize a CMouseTrackContext in the hunk of memory.    */
        /* It's now not a problem if the CMouseTrackContext throws, because */
        /* the buffer is still protected it's own smart pointer.  Once      */
        /* the placement new completes successfully, we can transfer        */
        /* ownership of the object to a CMouseTrackContext smart pointer    */
        /* and we're golden.                                                */
        /*------------------------------------------------------------------*/
                                                                        
        // allocate a hunk of memory and construct a CMouseTrackContext in it
        CharPtr spchBuffer = CharPtr (new char[sizeof (CMouseTrackContext)]);
        CMouseTrackContext* pNewCtxt = new (spchBuffer.get()) CMouseTrackContext (this, point);

        // if we get here, the CMouseTrackContext initialized properly,
        // so we can transfer ownership to the CMouseTrackContext smart pointer
        spchBuffer.release ();
        m_spTrackCtxt = CMouseTrackContextPtr (pNewCtxt);
    }
    catch (CUserException* pe)       
    {
        // do nothing, just eat the exception
        pe->Delete();
    }
}

#ifdef _DEBUG
#define new DEBUG_NEW
#endif



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnLButtonUp
 *
 * WM_LBUTTONUP handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnLButtonUp(UINT nFlags, CPoint point) 
{
    if (m_spTrackCtxt.get() != NULL)
    {
        const int nHotButton = m_spTrackCtxt->m_nHotButton;
        const int nHitButton = m_spTrackCtxt->HitTest (point);

        // delete the track context
        m_spTrackCtxt = CMouseTrackContextPtr (NULL);

        if (nHitButton == nHotButton)
        {
            int cmd = anMDIDataMap[nHotButton].nCommand;

            // make sure the command looks like a valid sys command
            ASSERT (cmd >= 0xF000);

            ClientToScreen (&point);
            GetOwner()->SendMessage (WM_SYSCOMMAND, cmd,
                                     MAKELPARAM (point.x, point.y));
        }

    }
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnMouseMove
 *
 * WM_MOUSEMOVE handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnMouseMove(UINT nFlags, CPoint point) 
{
    if (m_spTrackCtxt.get() != NULL)
        m_spTrackCtxt->Track (point);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::GetActiveSystemMenu 
 *
 *
 *--------------------------------------------------------------------------*/

CMenu* CMDIMenuDecoration::GetActiveSystemMenu ()
{
    CFrameWnd* pwndFrame = GetParentFrame()->GetActiveFrame();
    ASSERT (pwndFrame != NULL);

    CMenu*  pSysMenu = pwndFrame->GetSystemMenu (FALSE);
    ASSERT (pSysMenu != NULL);

    return (pSysMenu);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::IsSysCommandEnabled 
 *
 *
 *--------------------------------------------------------------------------*/

bool CMDIMenuDecoration::IsSysCommandEnabled (int nSysCommand, CMenu* pSysMenu)
{
    if (pSysMenu == NULL)
        pSysMenu = GetActiveSystemMenu ();

    int nState = pSysMenu->GetMenuState (nSysCommand, MF_BYCOMMAND);
    ASSERT (nState != 0xFFFFFFFF);

    return ((nState & MF_GRAYED) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mdiuisim.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      mdiuisim.h  
 *
 *  Contents:  Interface file for CMDIMenuDecoration
 *
 *  History:   17-Nov-97 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_MDIUISIM_H__EB2A4CC1_5F5E_11D1_8009_0000F875A9CE__INCLUDED_)
#define AFX_MDIUISIM_H__EB2A4CC1_5F5E_11D1_8009_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CMDIMenuDecoration window


// window styles
#define MMDS_CLOSE          0x0001
#define MMDS_MINIMIZE       0x0002
#define MMDS_MAXIMIZE       0x0004
#define MMDS_RESTORE        0x0008
#define MMDS_AUTOSIZE       0x0010

#define MMDS_BTNSTYLES      0x000F


class CMDIMenuDecoration : public CWnd
{
    class CMouseTrackContext
    {
    public:
        CMouseTrackContext (CMDIMenuDecoration*, CPoint);
        ~CMouseTrackContext ();

        void Track (CPoint);
        int HitTest (CPoint) const;
        void ToggleHotButton ();

        int                 m_nHotButton;

    private:    
        CMDIMenuDecoration* m_pMenuDec;
        CRect               m_rectButton[4];
        bool                m_fHotButtonPressed;
    };
    
    typedef std::auto_ptr<CMouseTrackContext>   CMouseTrackContextPtr;
    friend class CMouseTrackContext;

    CMouseTrackContextPtr   m_spTrackCtxt;

// Construction
public:
    CMDIMenuDecoration();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMDIMenuDecoration)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMDIMenuDecoration();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMDIMenuDecoration)
    afx_msg void OnPaint();
    afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CMenu*  GetActiveSystemMenu ();
    bool    IsSysCommandEnabled (int nSysCommand, CMenu* pSysMenu = NULL);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MDIUISIM_H__EB2A4CC1_5F5E_11D1_8009_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\menubtns.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      menubtns.cpp
//
//  Contents:  Menu Buttons implementation
//
//  History:   08-27-99 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"
#include "ChildFrm.h"
#include "menubtns.h"
#include "AMCView.h"
#include "mainfrm.h"
#include "menubar.h"
#include "util.h"         // GetTBBtnTextAndStatus()


CMenuButtonsMgrImpl::CMenuButtonsMgrImpl()
 : m_pChildFrame(NULL), m_pMainFrame(NULL),
   m_pMenuBar(NULL)
{
    m_MenuButtons.clear();
    m_AttachedMenuButtons.clear();
}

CMenuButtonsMgrImpl::~CMenuButtonsMgrImpl()
{
    m_MenuButtons.clear();
    m_AttachedMenuButtons.clear();
}

//+-------------------------------------------------------------------
//
//  Member:      ScInit
//
//  Synopsis:    Init the Menubuttons mgr.
//
//  Arguments:   [pMainFrame]     - Ptr to Main Frame window.
//               [pChildFrameWnd] - Ptr to child frame window.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScInit (CMainFrame* pMainFrame, CChildFrame* pChildFrameWnd)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScInit"));

    if ( (NULL == pChildFrameWnd) ||
         (NULL == pMainFrame))
        return (sc = E_INVALIDARG);

    m_pChildFrame = pChildFrameWnd;
    m_pMainFrame  = pMainFrame;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScAddMenuButton
//
//  Synopsis:   Adds a menu button to the data structure
//              and calls ScAddMenuButtonToMenu.
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for button click.
//              [idCommand]          - Button command id.
//              [lpButtonText]       - Button text.
//              [lpStatusText]       - Button status text.
//
//  Returns:    SC
//
//  Note : The status text is not used.
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScAddMenuButton(
                             CMenuButtonNotify* pMenuBtnNotifyClbk,
                             INT idCommand,
                             LPCOLESTR lpButtonText,
                             LPCOLESTR lpStatusText)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScAddMenuButton"));

    // Validate the data
    if ( (NULL == pMenuBtnNotifyClbk) ||
         (NULL == lpButtonText) ||
         (NULL == lpStatusText) )
        return (sc = E_INVALIDARG);

    // Add the data to our data structure
    MMC_MenuButtonCollection::iterator it;
    it = GetMMCMenuButton( pMenuBtnNotifyClbk, idCommand);
    if (it != m_MenuButtons.end())
    {
        // Duplicate Menu button found.
        // The pMenuButtonNofifyClbk represents IMenuButton
        // given to the snapin and we found another button
        // with idCommand already added by this snapin.

        // For compatibility reasons (disk mgmt) this is not an error.
        return (sc = S_OK);
    }

    MMC_MENUBUTTON mmb;
    mmb.pMenuButtonNotifyClbk = pMenuBtnNotifyClbk;
    mmb.idCommand = idCommand;

    USES_CONVERSION;
    mmb.lpButtonText = OLE2CT(lpButtonText);
    mmb.lpStatusText = OLE2CT(lpStatusText);

    // Add the MMC_MENUBUTTON to the our array.
    m_MenuButtons.push_back(mmb);

    // Add the menubuttons to main menu
    sc = ScAddMenuButtonsToMainMenu();
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     ScModifyMenuButton
//
//  Synopsis:   Modify button text or status text for menu button
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for button click.
//              [idCommand]          - Button command id.
//              [lpButtonText]       - Button text.
//              [lpStatusText]       - Button status text.
//
//  Returns:    SC
//
//  Note : The status text is not used.
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScModifyMenuButton(
                             CMenuButtonNotify* pMenuBtnNotifyClbk,
                             INT idCommand,
                             LPCOLESTR lpButtonText,
                             LPCOLESTR lpStatusText)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScModifyMenuButton"));

    // Validate the data
    if ( (NULL == pMenuBtnNotifyClbk) ||
         (NULL == lpButtonText) ||
         (NULL == lpStatusText) )
        return (sc = E_INVALIDARG);

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) )
        return (sc = E_UNEXPECTED);

    // Iterate thro the vector and find the MMC_MENUBUTTON for
    // given CMenuButtonNotify* and Command id of button.
    MMC_MenuButtonCollection::iterator it;
    it = GetMMCMenuButton( pMenuBtnNotifyClbk, idCommand);
    if (it == m_MenuButtons.end())
    {
        // Menu button not found.
        // The pMenuButtonNofifyClbk represents IMenuButton
        // given to the snapin and we could not find a menu button
        // with idCommand already added by this snapin.
        return (sc = E_INVALIDARG);
    }

    it->pMenuButtonNotifyClbk = pMenuBtnNotifyClbk;
    it->idCommand = idCommand;

    USES_CONVERSION;
    it->lpButtonText = OLE2CT(lpButtonText);
    it->lpStatusText = OLE2CT(lpStatusText);

    if (NULL == m_pMenuBar)
        return (sc = E_UNEXPECTED);

    // Change the name of the menu item.
    if (-1 != it->nCommandIDFromMenuBar)
    {
        sc = (m_pMenuBar->SetMenuButton(it->nCommandIDFromMenuBar, it->lpButtonText.data()) == -1)
                        ? E_FAIL : S_OK;
        if (sc)
            return sc;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScModifyMenuButtonState
//
//  Synopsis:   Modify menu button state.
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for button click.
//              [idCommand]          - Button command id.
//              [nState]             - The state to be modified.
//              [bState]             - Set or Reset the state.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScModifyMenuButtonState(
                             CMenuButtonNotify* pMenuBtnNotifyClbk,
                             INT idCommand,
                             MMC_BUTTON_STATE nState,
                             BOOL bState)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScModifyMenuButtonState"));

    // Validate the data
    if (NULL == pMenuBtnNotifyClbk)
        return (sc = E_INVALIDARG);

    if (NULL == m_pChildFrame)
        return (sc = E_UNEXPECTED);

    // If childframe is not active, menus for this viewdoes not exist.
    if (false == m_pChildFrame->IsChildFrameActive())
    {
        switch (nState)
        {
        case ENABLED:
            // Enabling is illegal disabling is Ok (do nothing).
            sc = bState ? E_FAIL : S_OK;
            break;

        case HIDDEN:
            // Hiding is Ok(do nothing), Un-hiding is illegal.
            sc = bState ? S_OK : E_FAIL;
            break;

        case BUTTONPRESSED:
            sc = E_FAIL; // Always fail.
            break;

        default:
            ASSERT(FALSE);
            sc = E_FAIL;
            break;
        }

        return sc;
    }

    // Iterate thro the vector and find the MMC_MENUBUTTON for
    // given CMenuButtonNotify* and Command id of button.
    MMC_MenuButtonCollection::iterator it;
    it = GetMMCMenuButton( pMenuBtnNotifyClbk, idCommand);
    if (it == m_MenuButtons.end())
    {
        // Menu button not found.
        // The pMenuButtonNofifyClbk represents IMenuButton
        // given to the snapin and we could not find a menu button
        // with idCommand already added by this snapin.
        return (sc = E_INVALIDARG);
    }


    // Note the hidden state specified by the snapin.
    if (HIDDEN == nState)
    {
        bool bShow = (FALSE == bState);

        it->SetShowMenu(bShow);

        // If a menu button is to be un-hidden make sure that snapin buttons
        // are allowed in this view. Ask view-data for this information.
        if (bShow)
        {
            CAMCView* pAMCView = m_pChildFrame->GetAMCView();
            if (NULL == pAMCView)
                return (sc = E_UNEXPECTED);

            SViewData* pViewData = pAMCView->GetViewData();
            if (NULL == pViewData)
                return (sc = E_UNEXPECTED);

            // We have noted the hidden state of the button.
            // Return S_OK if menubuttons are disabled for this view.
            // Later when the menus are turned on the hidden state will
            // be properly restored.
            if (! pViewData->IsSnapinMenusAllowed())
                return (sc = S_OK);
        }
    }

    if (NULL == m_pMenuBar)
        return (sc = E_UNEXPECTED);

    BOOL bRet = FALSE;

    switch (nState)
    {
    case ENABLED:
        bRet = m_pMenuBar->EnableButton(it->nCommandIDFromMenuBar , bState);
        break;

    case HIDDEN:
        bRet = m_pMenuBar->HideButton(it->nCommandIDFromMenuBar , bState);
        break;

    case BUTTONPRESSED:
        bRet = m_pMenuBar->PressButton(it->nCommandIDFromMenuBar, bState);
        break;

    default:
        ASSERT(FALSE);
        bRet = FALSE;
        break;
    }

    sc = bRet ? S_OK : E_FAIL;
    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScAddMenuButtonsToMainMenu
//
//  Synopsis:   Add the menu buttons that are not yet added to
//              the main menu.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScAddMenuButtonsToMainMenu ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScAddMenuButtonsToMainMenu"));

    // To add a menu button the following conditions must be true.

    // 1. The child frame window must be active.
    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) )
        return (sc = E_UNEXPECTED);

    CAMCView* pAMCView = m_pChildFrame->GetAMCView();
    if (NULL == pAMCView)
        return (sc = E_UNEXPECTED);

    SViewData* pViewData = pAMCView->GetViewData();
    if (NULL == pViewData)
        return (sc = E_UNEXPECTED);

    if (NULL == m_pMainFrame)
        return (sc = E_UNEXPECTED);

    m_pMenuBar = m_pMainFrame->GetMenuBar();
    if (NULL == m_pMenuBar)
        return (sc = E_FAIL);

    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        // 2. The menu button is attached (IControlbar::Attach was called).
        if (IsAttached(it->pMenuButtonNotifyClbk) == false)
            continue;

        // 3. The button is not already added.
        if (FALSE == m_pMenuBar->IsButtonHidden(it->nCommandIDFromMenuBar))
            continue;

        BOOL bHidden = FALSE;

        if (false == pViewData->IsSnapinMenusAllowed())
            bHidden = TRUE;

        it->nCommandIDFromMenuBar =
            m_pMenuBar->InsertMenuButton((LPCTSTR)it->lpButtonText.data(),
                                                                                 bHidden || !(it->CanShowMenu()) );

        // In user mode there are no menus so this assert is not valid.
        // ASSERT(-1 != it->nCommandIDFromMenuBar);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifyMenuClick
//
//  Synopsis:   A menu button is clicked. Notify appropriate owner
//              to display a menu.
//
//  Arguments:
//              [nCommandID] - Command ID
//              [pt]        - display co-ordinates for popup menu.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScNotifyMenuClick(const INT nCommandID, const POINT& pt)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScNotifyMenuClick"));
    CAMCView* pAMCView = NULL;

    MMC_MenuButtonCollection::iterator it;

    // Get the MenuButton data.
    it = GetMMCMenuButton( nCommandID );
    if (it == m_MenuButtons.end())
        return (sc = E_FAIL);

    pAMCView = m_pChildFrame->GetAMCView();
    if (NULL == pAMCView)
        return (sc = E_FAIL);

    // This is snapin owned menu, so get the
    // selected HNODE, lParam (if result item)
    // MENUBUTTONDATA.
    HNODE hNode;
    bool  bScope;
    LPARAM lParam;
    MENUBUTTONDATA menuButtonData;

    // Get the details about the selected item.
    sc = pAMCView->ScGetFocusedItem (hNode, lParam, bScope);
    if (sc)
        return sc;

    menuButtonData.idCommand = it->idCommand;
    menuButtonData.x = pt.x;
    menuButtonData.y = pt.y;

    // Notify snapin about the click
    if (NULL == it->pMenuButtonNotifyClbk)
        return (sc = E_UNEXPECTED);

    sc = it->pMenuButtonNotifyClbk->ScNotifyMenuBtnClick(hNode, bScope, lParam, menuButtonData);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScAttachMenuButton
//
//  Synopsis:   Attach the menu buttons object (this object corresponds
//                 to the IMenuButton object exposed to the snapin).
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for menu button click.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScAttachMenuButton (CMenuButtonNotify* pMenuBtnNotifyClbk)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScAttachMenuButton"));

    MMC_AttachedMenuButtons::iterator it = m_AttachedMenuButtons.find(pMenuBtnNotifyClbk);
    if (m_AttachedMenuButtons.end() != it)
    {
        // Already attached, nothing wrong calling twice, return S_FALSE.
        return (sc = S_FALSE);
    }

    // Add the button to the set.
    std::pair<MMC_AttachedMenuButtons::iterator, bool> rc =
                       m_AttachedMenuButtons.insert(pMenuBtnNotifyClbk);
    if (false == rc.second)
        return (sc = E_FAIL);

    // The menu buttons may already be added  (without calling
    // IControlbar::Attach)
    // So give a chance for those buttons that are already added
    // but just now attached to get themself added to the main menu.
    sc = ScAddMenuButtonsToMainMenu ();
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetachMenuButton
//
//  Synopsis:   Detach the menu buttons object (this object corresponds
//                 to the IMenuButton object exposed to the snapin).
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for menu button click.
//
//  Returns:    SC
//
//  Note : Detach removes the menu buttons and destroys the object.
//         So to re-create the menu button the snapin should again
//         do IMenuButton::AddButton and IControlbar::Attach.
//         This is how it is designed in mmc 1.0
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScDetachMenuButton (CMenuButtonNotify* pMenuBtnNotifyClbk)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScDetachMenuButton"));

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()))
        return (sc = S_OK); // When child-frame is deactivated the menus are removed.

    // Make sure the menu is currently attached.
    if (m_AttachedMenuButtons.end() ==
        m_AttachedMenuButtons.find(pMenuBtnNotifyClbk))
        // This Menu Button is not attached.
        return (sc = E_UNEXPECTED);

    if ( (NULL == m_pMainFrame) ||
         (NULL == m_pMenuBar) )
        return (sc = E_UNEXPECTED);

    MMC_MenuButtonCollection::iterator it = m_MenuButtons.begin();
    while ( it != m_MenuButtons.end())
    {
        if (it->pMenuButtonNotifyClbk == pMenuBtnNotifyClbk)
        {
            BOOL bRet = FALSE;

            // Remove the menu button from Main Menu.
            if (-1 != it->nCommandIDFromMenuBar)
                bRet = m_pMenuBar->DeleteMenuButton(it->nCommandIDFromMenuBar);

            // The CMenubar removes all the menus when childframe is de-activated.
            // So DeleteMenuButton will fail if the button does not exist.
            // Therefore we do not check below error.
            // if (FALSE == bRet)
            //    return (sc = E_FAIL);

            // Delete the object in our data structure
            it = m_MenuButtons.erase(it);
        }
        else
            ++it;
    }

    // Delete the IMenuButton ref from the set.
    m_AttachedMenuButtons.erase(pMenuBtnNotifyClbk);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScToggleMenuButton
//
//  Synopsis:   Hide or Show the given menu buttons.
//
//  Arguments:
//              [bShow] - Show or Hide the menu buttons.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScToggleMenuButton(BOOL bShow)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScToggleMenuButton"));

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) ||
         (NULL == m_pMenuBar) )
        return (sc = E_UNEXPECTED);

    // Go thro all the menu buttons added.
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        BOOL bRetVal = TRUE; // Init to true so that failure (false) can be checked below.

        // Toggle the menu hidden status. If the menu is
        // un-hidden then check if it is allowed.
        bRetVal = m_pMenuBar->HideButton(it->nCommandIDFromMenuBar, bShow ? !(it->CanShowMenu()) : TRUE);

        if (FALSE == bRetVal)
            return (sc = E_FAIL);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScDisableMenuButtons
//
//  Synopsis:   Disable all the menubuttons.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScDisableMenuButtons()
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScDisableMenuButtons"));

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) ||
         (NULL == m_pMenuBar) )
        return (sc = E_UNEXPECTED);

    // Go thro all the menu buttons added.
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        if (m_pMenuBar->IsButtonEnabled(it->nCommandIDFromMenuBar))
        {
            BOOL bRet = m_pMenuBar->EnableButton(it->nCommandIDFromMenuBar, false);

            if (FALSE == bRet)
                return (sc = E_FAIL);
        }
    }


    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     GetMMCMenuButton
//
//  Synopsis:   Given the Notify callback and button command id get the button
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Callback for Menu click.
//              [idCommand]          - Button command id.
//
//  Returns:    iterator to MMC_MenuButtonCollection
//
//--------------------------------------------------------------------
MMC_MenuButtonCollection::iterator
CMenuButtonsMgrImpl::GetMMCMenuButton( CMenuButtonNotify* pMenuBtnNotifyClbk,
                                       INT idCommand)
{
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        if ( (it->pMenuButtonNotifyClbk == pMenuBtnNotifyClbk) &&
             (it->idCommand == idCommand) )
        {
            return it;
        }
    }

    return m_MenuButtons.end();
}

//+-------------------------------------------------------------------
//
//  Member:     GetMMCMenuButton
//
//  Synopsis:   Given the command id get the button
//
//  Arguments:
//              [nCommandID] - Command ID.
//
//  Returns:    iterator to MMC_MenuButtonCollection
//
//--------------------------------------------------------------------
MMC_MenuButtonCollection::iterator
CMenuButtonsMgrImpl::GetMMCMenuButton( INT nCommandID)
{
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        if ( it->nCommandIDFromMenuBar == nCommandID )
        {
            return it;
        }
    }

    return m_MenuButtons.end();
}


//+-------------------------------------------------------------------
//
//  Member:     IsAttached
//
//  Synopsis:   Given the notify callback, check if the MenuButtons
//              object is attached or not.
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback.
//
//  Returns:    bool
//
//--------------------------------------------------------------------
bool CMenuButtonsMgrImpl::IsAttached( CMenuButtonNotify* pMenuBtnNotifyClbk)
{
    MMC_AttachedMenuButtons::iterator it = m_AttachedMenuButtons.find(pMenuBtnNotifyClbk);
    if (m_AttachedMenuButtons.end() != it)
        return true;

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\menubar.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      menubar.h
 *
 *  Contents:  Interface file for CMenuBar
 *
 *  History:   14-Nov-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef MENUBAR_H
#define MENUBAR_H
#pragma once


/////////////////////////////////////////////////////////////////////////////
// CMenuBar class

class CRebarDockWindow;     // forward declaration
class CMDIMenuDecoration;
class CRebarWnd;

#define WM_POPUP_ASYNC      WM_APP

#define MAX_MENU_ITEMS      32    // Maximum # of items in main menu.


class CMenuBar : public CMMCToolBarCtrlEx
{
    friend class CPopupTrackContext;
    typedef std::vector<CString>    ToolbarStringPool;
    typedef std::set<INT>           CommandIDPool;

    std::auto_ptr<CMDIMenuDecoration>   m_pMDIDec;

    ToolbarStringPool       m_ToolbarStringPool;
    CMDIFrameWnd *          m_pMDIFrame;
    CWnd*                   m_pwndLastActive;
    CRebarWnd *             m_pRebar;
    HMENU                   m_hMenuLast;
    CAccel                  m_MenuAccel;        // to handle Alt+<mnemonic>
    CAccel                  m_TrackingAccel;    // to <mnemonic> while in menu mode
    CFont                   m_MenuFont;
    CString                 m_strAccelerators;
    HICON                   m_hMaxedChildIcon;
    bool                    m_fDestroyChildIcon;
    bool                    m_fDecorationsShowing;
    bool                    m_fMaxedChildIconIsInvalid;
    // following member is to indicate that the change in menu is because of attempt
    // to switch to another submenu, and should not be treated as dismissing the menu
    // thus accelerator state should not be changed
    bool                    m_bInProgressDisplayingPopup;
    CommandIDPool           m_CommandIDUnUsed;       // Command IDs pool (to recycle unused ids).

    static const CAccel& GetMenuUISimAccel();

    void    DeleteMaxedChildIcon();
public:
    CMenuBar ();
    virtual ~CMenuBar ();

    virtual void BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd);
    virtual void EndTracking2   (CToolbarTrackerAuxWnd* pAuxWnd);

    virtual int GetFirstButtonIndex ();
    BOOL Create (CMDIFrameWnd* pwndFrame, CRebarDockWindow* pParentRebar, DWORD dwStyle, UINT idWindow);
    BOOL Create (CFrameWnd* pwndFrame,    CRebarDockWindow* pParentRebar, DWORD dwStyle, UINT idWindow);
    void SetMenu (CMenu* pMenu);
    int AddString (const CString& strAdd);
    void PopupMenuAsync (int cmd);
    void OnIdle ();
    void GetAccelerators (int cchBuffer, LPTSTR lpBuffer) const;

    // Following methods used by CMenuButtonsMgr
    // to add/delete/modify menu buttons
    LONG InsertMenuButton(LPCTSTR lpszButtonText, BOOL bHidden, int iPreferredPos = -1);
    BOOL DeleteMenuButton(INT nCommandID);
    LONG SetMenuButton(INT nCommandID, LPCTSTR lpszButtonText);

    SC   ScShowMMCMenus(bool bShow);

    CMenu* GetMenu () const
    {
        return (CMenu::FromHandle (m_hMenuLast));
    }

    void InvalidateMaxedChildIcon ()
    {
        if (m_fDecorationsShowing)
        {
            m_fMaxedChildIconIsInvalid = true;
            InvalidateRect (NULL);
        }
    }

    enum
    {
        cMaxTopLevelMenuItems = MAX_MENU_ITEMS,

        // top-level menu item commands
        ID_MTB_MENU_FIRST     = CMMCToolBarCtrlEx::ID_MTBX_LAST + 1,

        // The following menus have fixed command-ids.
        ID_MTB_MENU_SYSMENU   = ID_MTB_MENU_FIRST,
        ID_MTB_MENU_ACTION    = ID_MTB_MENU_SYSMENU + 1,
        ID_MTB_MENU_VIEW      = ID_MTB_MENU_ACTION + 1,
        ID_MTB_MENU_FAVORITES = ID_MTB_MENU_VIEW + 1,
        ID_MTB_MENU_SNAPIN_PLACEHOLDER = ID_MTB_MENU_FAVORITES + 1,

        // The following command ids are free to be assigned.
        // Starts with last fixed command-id.
        ID_MTB_FIRST_COMMANDID = ID_MTB_MENU_SNAPIN_PLACEHOLDER + 1,
        ID_MTB_MENU_LAST    = ID_MTB_MENU_VIEW + cMaxTopLevelMenuItems,

        ID_MTB_ACTIVATE_CURRENT_POPUP,

        ID_MTB_FIRST = ID_MTB_MENU_FIRST,
        ID_MTB_LAST  = ID_MTB_ACTIVATE_CURRENT_POPUP,

        ID_MDIDECORATION = 0x2001
    };


    int IndexToCommand (int nIndex) const
    {
        TBBUTTON tbbi;
        tbbi.idCommand = 0; // We need only idCommand so just init this.

        if (GetButton(nIndex, &tbbi))
            return tbbi.idCommand;

        ASSERT(FALSE);
        return -1;
    }


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMenuBar)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

protected:
    void DestroyAcceleratorTable ();
    void SetMenuFont ();
    void SizeDecoration ();
    int  GetMenuBandIndex () const;
    int  GetDecorationBandIndex () const;
    void GetMaxedChildIcon (CWnd* pwnd);
    BOOL InsertButton (int nIndex, const CString& strText, int idCommand,
                       DWORD_PTR dwMenuData, BYTE fsState, BYTE fsStyle);

	/*
	 * Derived classes can override this to handle properties they support.
	 * The base class should always be called first.
	 */
	virtual SC ScGetPropValue (
		HWND				hwnd,		// I:accessible window
		DWORD				idObject,	// I:accessible object
		DWORD				idChild,	// I:accessible child object
		const MSAAPROPID&	idProp,		// I:property requested
		VARIANT&			varValue,	// O:returned property value
		BOOL&				fGotProp);	// O:was a property returned?

	virtual SC ScInsertAccPropIDs (PropIDCollection& v);

    // Generated message map functions
protected:
    //{{AFX_MSG(CMenuBar)
    afx_msg void OnDropDown(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg LRESULT OnPopupAsync(WPARAM, LPARAM);
    afx_msg void OnHotItemChange(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAccelPopup (UINT cmd);
    afx_msg void OnUpdateAllCmdUI (CCmdUI*  pCmdUI);
    afx_msg void OnActivateCurrentPopup ();

    DECLARE_MESSAGE_MAP()

    void PopupMenu (int nItemIndex, bool bHighlightFirstItem);

    // Accelerators
private:
	typedef std::vector<ACCEL>  AccelVector;
	
	AccelVector  m_vMenuAccels;
	AccelVector  m_vTrackingAccels;

private:
	void LoadAccels();
	bool IsStandardMenuAllowed(UINT uMenuID);
};

/*---------------------------------------------------------*\
| copied from winuser.h since we currently compile
| with _WIN32_WINNT == 0x0400
\*---------------------------------------------------------*/
#if(_WIN32_WINNT < 0x0500)
    #define WM_CHANGEUISTATE                0x0127
    #define WM_UPDATEUISTATE                0x0128
    #define WM_QUERYUISTATE                 0x0129

    #define UIS_SET                         1
    #define UIS_CLEAR                       2
    #define UIS_INITIALIZE                  3

    #define UISF_HIDEFOCUS                  0x1
    #define UISF_HIDEACCEL                  0x2

    #define WM_UNINITMENUPOPUP              0x0125
#endif // (_WIN32_WINNT < 0x0500)

#endif  /* MENUBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\menubar.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      menubar.cpp
 *
 *  Contents:  Implementation file for CMenuBar
 *
 *  History:   14-Nov-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/


#include "stdafx.h"
#include "menubar.h"
#include "mdiuisim.h"
#include "amc.h"
#include "amcdoc.h"
#include "mainfrm.h"
#include "tbtrack.h"
#include "mnemonic.h"
#include "childfrm.h"
#include "menubtns.h"
#include <algorithm>
#include <mmsystem.h>
#include <oleacc.h>
#include "amcview.h"
#include "favorite.h"
#include "util.h"

/*
 * if we're supporting old platforms, we need to get MSAA definitions
 * from somewhere other than winuser.h
 */
#if (_WINNT_WIN32 < 0x0500)
	#include <winable.h>
#endif

/*--------*/
/* SAccel */
/*--------*/
struct SAccel : public ACCEL
{
    SAccel (WORD key_, WORD cmd_, BYTE fVirt_)
    {
        ZeroMemory (this, sizeof (*this));
        key   = key_;
        cmd   = cmd_;
        fVirt = fVirt_;
    }
};


/*--------------------*/
/* CPopupTrackContext */
/*--------------------*/
class CPopupTrackContext
{
public:
    CPopupTrackContext (CMenuBar* pMenuBar, int nCurrentPopupIndex);
    ~CPopupTrackContext ();

    // control over monitoring
    void StartMonitoring();
    bool WasAnotherPopupRequested(int& iNewIdx);

private:
    typedef std::vector<int>                    BoundaryCollection;
    typedef BoundaryCollection::iterator        BoundIt;
    typedef BoundaryCollection::const_iterator  BoundConstIt;

    BoundaryCollection  m_ButtonBoundaries;
    CMenuBar* const     m_pMenuBar;
    HHOOK               m_hhkMouse;
    HHOOK               m_hhkKeyboard;
    HHOOK               m_hhkCallWnd;
    CRect               m_rectAllButtons;
    CPoint              m_ptLastMouseMove;
    int                 m_nCurrentPopupIndex;

    CWnd*               m_pMaxedMDIChild;
    const CPoint        m_ptLButtonDown;
    const UINT          m_dwLButtonDownTime;
    const int           m_cButtons;
    int                 m_cCascadedPopups;
    bool                m_fCurrentlyOnPopupItem;
    bool                m_bPopupMonitorHooksActive;
    int                 m_iRequestForNewPopup;

    LRESULT MouseProc    (int nCode, UINT msg, LPMOUSEHOOKSTRUCT pmhs);
    LRESULT KeyboardProc (int nCode, int vkey, int cRepeat, bool fDown, LPARAM lParam);
    LRESULT CallWndProc  (int nCode, BOOL bCurrentThread, LPCWPSTRUCT lpCWP);

    int  HitTest (CPoint pt) const;
    int  MapBoundaryIteratorToButtonIndex (BoundConstIt it) const;
    void MaybeCloseMDIChild (CPoint pt);
    void DismissCurrentPopup (bool fTrackingComplete);
    void NotifyNewPopup (int nNewPopupIndex);

    void  SetPopupMonitorHooks();
    void  RemovePopupMonitorHooks();
    static LRESULT CALLBACK MouseProc    (int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK KeyboardProc (int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK CallWndProc  (int nCode, WPARAM wParam, LPARAM lParam);
    static CPopupTrackContext*  s_pTrackContext;
};

CPopupTrackContext* CPopupTrackContext::s_pTrackContext = NULL;



const TCHAR chChildSysMenuMnemonic = _T('-');



/*--------------------------------------------------------------------------*
 * AddMnemonic
 *
 *
 *--------------------------------------------------------------------------*/

template<class OutputIterator>
static void AddMnemonic (
    TCHAR           chMnemonic,
    int             cmd,
    BYTE            fVirt,
    OutputIterator  it)
{
    ASSERT (chMnemonic != _T('\0'));

    TCHAR chLower = (TCHAR) tolower (chMnemonic);
    TCHAR chUpper = (TCHAR) toupper (chMnemonic);

    /*
     * add the lowercase mnemonic
     */
    *it++ = SAccel (chLower, (WORD) cmd, fVirt);

    /*
     * if the uppercase mnemonic character is different from the
     * lowercase character, add the uppercase mnemonic as well
     */
    if (chUpper != chLower)
        *it++ = SAccel (chUpper, (WORD) cmd, fVirt);
}



/*--------------------------------------------------------------------------*
 * PrepBandInfo
 *
 *
 *--------------------------------------------------------------------------*/

static void PrepBandInfo (LPREBARBANDINFO prbi, UINT fMask)
{
    ZeroMemory (prbi, sizeof (REBARBANDINFO));
    prbi->cbSize = sizeof (REBARBANDINFO);
    prbi->fMask  = fMask;
}



/////////////////////////////////////////////////////////////////////////////
// CMenuBar

BEGIN_MESSAGE_MAP(CMenuBar, CMMCToolBarCtrlEx)
    //{{AFX_MSG_MAP(CMenuBar)
    ON_NOTIFY_REFLECT(TBN_DROPDOWN, OnDropDown)
    ON_NOTIFY_REFLECT(TBN_GETDISPINFO, OnGetDispInfo)
    ON_NOTIFY_REFLECT(TBN_HOTITEMCHANGE, OnHotItemChange)
    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)
    ON_WM_SYSCOMMAND()
    ON_WM_SETTINGCHANGE()
    ON_WM_DESTROY()
    ON_COMMAND(ID_MTB_ACTIVATE_CURRENT_POPUP, OnActivateCurrentPopup)
    //}}AFX_MSG_MAP

    ON_MESSAGE(WM_POPUP_ASYNC, OnPopupAsync)
    ON_COMMAND(CMMCToolBarCtrlEx::ID_MTBX_PRESS_HOT_BUTTON, OnActivateCurrentPopup)
    ON_COMMAND_RANGE(ID_MTB_MENU_FIRST, ID_MTB_MENU_LAST, OnAccelPopup)
    ON_UPDATE_COMMAND_UI_RANGE(ID_MTB_MENU_FIRST, ID_MTB_MENU_LAST, OnUpdateAllCmdUI)
END_MESSAGE_MAP()




/*--------------------------------------------------------------------------*
 * CMenuBar::GetMenuUISimAccel
 *
 * Manages the accelerator table singleton for CMenuBar
 *--------------------------------------------------------------------------*/

const CAccel& CMenuBar::GetMenuUISimAccel ()
{
    static ACCEL aaclTrack[] = {
        {   FVIRTKEY,   VK_RETURN,  CMenuBar::ID_MTB_ACTIVATE_CURRENT_POPUP },
        {   FVIRTKEY,   VK_UP,      CMenuBar::ID_MTB_ACTIVATE_CURRENT_POPUP },
        {   FVIRTKEY,   VK_DOWN,    CMenuBar::ID_MTB_ACTIVATE_CURRENT_POPUP },
    };

    static const CAccel MenuUISimAccel (aaclTrack, countof (aaclTrack));
    return (MenuUISimAccel);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::CMenuBar
 *
 *
 *--------------------------------------------------------------------------*/

CMenuBar::CMenuBar ()
{
    m_pMDIFrame                = NULL;
    m_pwndLastActive           = NULL;
    m_pRebar                   = NULL;
    m_hMenuLast                = NULL;
    m_hMaxedChildIcon          = NULL;
    m_fDestroyChildIcon        = false;
    m_fDecorationsShowing      = false;
    m_fMaxedChildIconIsInvalid = false;
    m_CommandIDUnUsed.clear();
    m_vMenuAccels.clear();
    m_vTrackingAccels.clear();
    m_bInProgressDisplayingPopup = false;
}



/*--------------------------------------------------------------------------*
 * CMenuBar::~CMenuBar
 *
 *
 *--------------------------------------------------------------------------*/

CMenuBar::~CMenuBar ()
{
    DeleteMaxedChildIcon();
}



/*--------------------------------------------------------------------------*
 * CMenuBar::Create
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CMenuBar::Create (
    CFrameWnd *         pwndFrame,
    CRebarDockWindow*   pParentRebar,
    DWORD               dwStyle,
    UINT                idWindow)
{
    ASSERT_VALID (pwndFrame);
    ASSERT_VALID (pParentRebar);

    // create the window
    if (!CMMCToolBarCtrlEx::Create (NULL, dwStyle | TBSTYLE_LIST,
                                    g_rectEmpty, pParentRebar, idWindow))
        return (FALSE);

    // initialize to hidded accelerator state
    SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));

    // insert a hidden button for the maximized child's system menu
    InsertButton (0, (LPCTSTR) NULL, ID_MTB_MENU_SYSMENU, NULL, 0, 0);

    TBBUTTONINFO btni;
    btni.cbSize  = sizeof (btni);
    btni.dwMask  = TBIF_STATE | TBIF_SIZE;
    btni.fsState = TBSTATE_HIDDEN;
    btni.cx      = static_cast<WORD>(GetSystemMetrics (SM_CXSMICON));

    SetButtonInfo (ID_MTB_MENU_SYSMENU, &btni);

#ifdef SHRINK_PADDING
    CSize sizePad = GetPadding();
    sizePad.cx = 3;
    SetPadding (sizePad);
#endif  // SHRINK_PADDING

    SetMenuFont ();
    m_pRebar = pParentRebar->GetRebar();

    return (TRUE);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::Create
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CMenuBar::Create (
    CMDIFrameWnd *      pwndFrame,
    CRebarDockWindow*   pParentRebar,
    DWORD               dwStyle,
    UINT                idWindow)
{
    if (!Create ((CFrameWnd*) pwndFrame, pParentRebar, dwStyle, idWindow))
        return (FALSE);

    m_pMDIFrame = pwndFrame;

    // this is a menu for an MDI frame window; create MDI decorations
    m_pMDIDec = std::auto_ptr<CMDIMenuDecoration>(new CMDIMenuDecoration);
    m_pMDIDec->Create (NULL, NULL,
                       WS_CHILD | MMDS_MINIMIZE |
                            MMDS_RESTORE | MMDS_CLOSE | MMDS_AUTOSIZE,
                       g_rectEmpty, this, ID_MDIDECORATION);

    // the rebar will re-parent the decoration, make sure we remain the owner
    m_pMDIDec->SetOwner (this);

    // insert the MDI decoration band
    REBARBANDINFO   rbi;
    PrepBandInfo (&rbi, RBBIM_CHILD | RBBIM_STYLE | RBBIM_ID);

    rbi.fStyle    = RBBS_FIXEDSIZE | RBBS_HIDDEN;
    rbi.hwndChild = m_pMDIDec->m_hWnd;
    rbi.wID       = ID_MDIDECORATION;

    ASSERT (m_pRebar != NULL);
    m_pRebar->InsertBand (&rbi);

    // resize the decoration window, *after* inserting the band
    SizeDecoration ();

    // there's bug in rebar which will show a band's
    // child, even with RBBS_HIDDEN, work around it
    m_pMDIDec->ShowWindow (SW_HIDE);

    return (TRUE);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::PreTranslateMessage
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CMenuBar::PreTranslateMessage(MSG* pMsg)
{
    // show accelerators, since user indicated he wants to control using the keyboard
    if ( (pMsg->message == WM_SYSKEYDOWN ) &&
         (!(pMsg->lParam & 0x40000000)/*not repeating*/) )
    {
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    }

    if (CMMCToolBarCtrlEx::PreTranslateMessage (pMsg))
        return (TRUE);

    if ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST))
    {
        CMainFrame* pFrame = AMCGetMainWnd();
        if ((pFrame == NULL) || !pFrame->IsMenuVisible())
            return (FALSE);

        // if we're in menu mode, check menu mode-only accelerators
        if (IsTrackingToolBar ())
        {
            const CAccel& MenuUISimAccel = GetMenuUISimAccel();

            ASSERT (MenuUISimAccel != NULL);
            if (MenuUISimAccel.TranslateAccelerator (m_hWnd, pMsg))
                return (TRUE);

            ASSERT (m_TrackingAccel != NULL);
            if (m_TrackingAccel.TranslateAccelerator (m_hWnd, pMsg))
                return (TRUE);
        }

        if ((m_MenuAccel != NULL) && m_MenuAccel.TranslateAccelerator (m_hWnd, pMsg))
            return (TRUE);

        // handle Alt+- when child is maximized
        if (m_fDecorationsShowing &&
            (pMsg->message == WM_SYSCHAR) &&
            (pMsg->wParam  == chChildSysMenuMnemonic))
        {
            SendMessage (WM_COMMAND, ID_MTB_MENU_SYSMENU);
            return (TRUE);
        }
    }

    return (FALSE);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::SetMenu
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::SetMenu (CMenu* pMenu)
{
    HMENU hMenu = pMenu->GetSafeHmenu();

    // don't need to do anything if we're setting the same menu as last time
    if (hMenu == m_hMenuLast)
        return;

    // remember this menu for optimization next time
    m_hMenuLast = hMenu;

    // delete all but the first existing buttons from the toolbar
    while (DeleteButton(1))
    {
    }

    // delete the previous dynamic accelerator table
    m_MenuAccel.DestroyAcceleratorTable ();
    m_strAccelerators.Empty ();

    // this should have been done in CMenuBar::Create
    ASSERT (GetBitmapSize().cx == 0);

    if (pMenu != NULL)
    {
        CString      strMenuText;

        // Clear the accels before calling InsertButton
        // which adds accels for each button.
        m_vMenuAccels.clear();
        m_vTrackingAccels.clear();

        int cMenuItems     = pMenu->GetMenuItemCount();

        // Initialize Unused command IDs pool.
        m_CommandIDUnUsed.clear();
        for (INT idCommand = ID_MTB_FIRST_COMMANDID;
             idCommand < ID_MTB_MENU_LAST;
             idCommand++)
        {
            m_CommandIDUnUsed.insert(idCommand);
        }

        for (int i = 0; i < cMenuItems; i++)
        {
            // get the menu text and add it to the toolbar
            pMenu->GetMenuString (i, strMenuText, MF_BYPOSITION);

            // sometimes empty items will be appended to the menu, ignore them
            if (strMenuText.IsEmpty ())
                continue;

            if (m_CommandIDUnUsed.empty())
            {
                ASSERT(FALSE);
            }

            // See if this top level menu has sub menus, if so when menu is clicked
            // it is popped up else it is Action or View or Favorites menu
            // for which submenu is dynamic and has to be constructured.
            // So we set the TBBUTTON.dwData member with submenu (for static menus)
            // or NULL for for dynamic menus like Action, View, Favorites.
            CMenu* pSubMenu = pMenu->GetSubMenu(i);
            DWORD_PTR dwMenuData = NULL;
            BYTE      byState = 0;

            if (pSubMenu)
            {
                // Get an unused command id for this button.
                CommandIDPool::iterator itCommandID = m_CommandIDUnUsed.begin();
                idCommand = *itCommandID;
                m_CommandIDUnUsed.erase(itCommandID);
                dwMenuData = reinterpret_cast<DWORD_PTR>(pSubMenu->GetSafeHmenu());
            }
            else
            {
                UINT uMenuID = pMenu->GetMenuItemID(i);
                switch (uMenuID)
                {
                case ID_ACTION_MENU:
                    idCommand = ID_MTB_MENU_ACTION;
                    break;

                case ID_VIEW_MENU:
                    idCommand = ID_MTB_MENU_VIEW;
                    break;

                case ID_FAVORITES_MENU:
                    idCommand = ID_MTB_MENU_FAVORITES;
                    break;

                case ID_SNAPIN_MENU_PLACEHOLDER:
                   /*
                    * We add a hidden menu as a marker. Later when snapin
                    * calls to insert a menu button we find the position
                    * of this menu and add snapin menu before it.
                    */
                    idCommand = ID_MTB_MENU_SNAPIN_PLACEHOLDER;
                    byState |= TBSTATE_HIDDEN; // Add this as hidden.
                    break;

                default:
                    ASSERT(FALSE);
                    return;
                    break;
                }

                bool bShow = IsStandardMenuAllowed(uMenuID);
                if (! bShow)
                    byState |= TBSTATE_HIDDEN;

            }


            // append this button to the end of the toolbar
            InsertButton (-1, strMenuText, idCommand, dwMenuData, byState, TBSTYLE_AUTOSIZE);
        }

        // add the accelerator for the child system menu
        std::back_insert_iterator<AccelVector>
            itTrackingInserter = std::back_inserter (m_vTrackingAccels);

        AddMnemonic (chChildSysMenuMnemonic, ID_MTB_MENU_SYSMENU, 0,    itTrackingInserter);
    }


    UpdateToolbarSize ();
    AutoSize ();
}



//+-------------------------------------------------------------------
//
//  Member:     InsertButton
//
//  Synopsis:   Insert a menu (button) to the main menu and then
//              if there is a mnemonic char add it to accelerator
//              and re-load the accelerators.
//
//  Arguments:  [nIndex]     - index after which to insert.
//              [strText]    - menu text.
//              [idCommand]  - ID of command to notify with.
//              [dwMenuData] - either submenu to be displayed (for static menus)
//                             or NULL for Action, View & Favorites.
//              [fsState]    - additional button states.
//              [fsStyle]    - additional button styles.
//
//  Returns:    BOOL
//
//  Note:       dwMenuData is handle to submenu for File, Window, Help menus whose
//              sub-menu is static. But for top level menus like Action, View, Favorites,
//              and Snapin menus it is NULL.
//
//--------------------------------------------------------------------
BOOL CMenuBar::InsertButton (
    int             nIndex,
    const CString&  strText,
    int             idCommand,
    DWORD_PTR       dwMenuData,
    BYTE            fsState,
    BYTE            fsStyle)
{
    TBBUTTON    btn;

    btn.iBitmap   = nIndex;
    btn.idCommand = idCommand;

    if (fsState & TBSTATE_HIDDEN)
        btn.fsState   = fsState;
    else
        btn.fsState   = TBSTATE_ENABLED  | fsState;

    btn.fsStyle   = TBSTYLE_DROPDOWN | fsStyle;
    btn.dwData    = dwMenuData;
    btn.iString   = AddString (strText);

    ASSERT(GetButtonCount() <= cMaxTopLevelMenuItems);
    ASSERT (btn.idCommand <= ID_MTB_MENU_LAST);

    BOOL bRet = CMMCToolBarCtrlEx::InsertButton (nIndex, &btn);
    if (bRet == FALSE)
        return bRet;

    // Successfully added the menu button. Now add
    // the accelerator for this item to our dynamic tables
    TCHAR chMnemonic = GetMnemonicChar (static_cast<LPCTSTR>(strText));

    if (chMnemonic != _T('\0'))
    {

        std::back_insert_iterator<AccelVector>
            itMenuInserter = std::back_inserter (m_vMenuAccels);
        std::back_insert_iterator<AccelVector>
            itTrackingInserter = std::back_inserter (m_vTrackingAccels);

        // add the Alt+<mnemonic> accelerator for use all the time
        AddMnemonic (chMnemonic, idCommand, FALT, itMenuInserter);

        // add the <mnemonic> accelerator for use when we're in menu mode
        AddMnemonic (chMnemonic, idCommand, 0,    itTrackingInserter);

        m_strAccelerators += (TCHAR) tolower (chMnemonic);
        m_strAccelerators += (TCHAR) toupper (chMnemonic);
    }

    // Re-load the accelerators
    LoadAccels();

    return bRet;
}


//+-------------------------------------------------------------------
//
//  Member:     LoadAccels
//
//  Synopsis:   Load the accelerators. (This destorys old accel table
//              and creates accel table).
//
//  Arguments:  None.
//
//  Returns:    void
//
//--------------------------------------------------------------------
void CMenuBar::LoadAccels()
{
    // create the accelerator tables for the menu
    m_MenuAccel    .CreateAcceleratorTable (m_vMenuAccels.begin (),
                                            m_vMenuAccels.size  ());
    m_TrackingAccel.CreateAcceleratorTable (m_vTrackingAccels.begin (),
                                            m_vTrackingAccels.size  ());
}

//+-------------------------------------------------------------------
//
//  Member:     InsertMenuButton
//
//  Synopsis:   Insert a menu button to the main menu, called by
//              CMenuButtonsMgr to add any snapin menus.
//
//  Arguments:  [lpszButtonText] - menu text.
//              [bHidden]        - Is this menu to be inserted hidden or not.
//              [iPreferredPos]  - The preferred position of this button.
//
//  Returns:    LONG, the command id of the inserted button.
//                    -1 if failed.
//
// Note:        The snapin added menus should be added before the Window menu.
//              For this a hidden menu is added (in SetMenu) which tells the
//              position where snapin menu is to be added. If iPreferredPos is -1
//              then find the position of this menu and add the menu before it.
//
//--------------------------------------------------------------------
LONG CMenuBar::InsertMenuButton(LPCTSTR lpszButtonText,
                                BOOL bHidden,
                                                                int  iPreferredPos)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (m_CommandIDUnUsed.size() == 0)
        return -1;

    // Get a command id for this button from the pool
    CommandIDPool::iterator itCommandID = m_CommandIDUnUsed.begin();
    int idCommand = *itCommandID;
    m_CommandIDUnUsed.erase(itCommandID);

    CString str = lpszButtonText;

    // Add snapin  menus before the SNAPIN_MENU_PLACE holder.
    // See CMenubar::SetMenu.
        if (-1 == iPreferredPos)
        iPreferredPos = CommandToIndex(ID_MTB_MENU_SNAPIN_PLACEHOLDER);

    BOOL bSuccess = InsertButton(iPreferredPos,
                                 str, idCommand,
                                 NULL,
                                 bHidden ? TBSTATE_HIDDEN : 0,
                                 TBSTYLE_AUTOSIZE);

    if (bSuccess)
    {
        UpdateToolbarSize ();
        AutoSize ();
        return idCommand;
    }

    return -1;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteMenuButton
//
//  Synopsis:   Delete a menu button from the main menu, called by
//              CMenuButtonsMgr
//
//  Arguments:  [nCommandID]      - Command ID of the menu.
//
//  Returns:    BOOL
//
//  Note:       Delete should also delete the accelerator.
//
//--------------------------------------------------------------------
BOOL CMenuBar::DeleteMenuButton(INT nCommandID)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    int iIndex = CommandToIndex(nCommandID);

    // We need to delete the mnemonics. So let us get the old
    // mnemonic before deleting the button.

    // 1. Get the menu text (string) index.
    TBBUTTON tbbi;
    ZeroMemory(&tbbi, sizeof(tbbi));
    BOOL bSuccess = GetButton(iIndex, &tbbi);
    if (FALSE == bSuccess)
        return bSuccess;

    // 2. Delete the button.
    bSuccess = DeleteButton(iIndex);
    ASSERT(bSuccess);
    if (FALSE == bSuccess)
        return bSuccess;

    // Add the command id to the unused pool.
    m_CommandIDUnUsed.insert(nCommandID);

    // Get the mnemonic and Delete it.
    ASSERT(m_ToolbarStringPool.size() > tbbi.iString);
    CString strText = m_ToolbarStringPool[tbbi.iString];
    for (AccelVector::iterator itAccel = m_vMenuAccels.begin();
         itAccel != m_vMenuAccels.end();
         itAccel++)
    {
        if (itAccel->cmd == (WORD)nCommandID)
        {
            m_vMenuAccels.erase(itAccel);
            break;
        }
    }

    for (AccelVector::iterator itTrack = m_vTrackingAccels.begin();
         itTrack != m_vTrackingAccels.end();
         itTrack++)
    {
        if (itTrack->cmd == (WORD)nCommandID)
        {
            m_vTrackingAccels.erase(itTrack);
            break;
        }
    }

    // Delete the mnemonic from m_strAccelerators.
    TCHAR chMnemonicOld = GetMnemonicChar (static_cast<LPCTSTR>(strText));
    if (chMnemonicOld != _T('\0'))
    {
        // CString::Remove cannot be used as it is for VC6. We use the tstring
        // to remove chars from the mnemonic string.
        tstring tstrAccels = m_strAccelerators;

        tstring::iterator itNewEnd = std::remove(tstrAccels.begin(), tstrAccels.end(), toupper(chMnemonicOld));
        tstrAccels.erase(itNewEnd, tstrAccels.end());
        itNewEnd = std::remove(tstrAccels.begin(), tstrAccels.end(), tolower(chMnemonicOld));
        tstrAccels.erase(itNewEnd, tstrAccels.end());
        m_strAccelerators = tstrAccels.data();
    }

    return bSuccess;
}

//+-------------------------------------------------------------------
//
//  Member:     SetMenuButton
//
//  Synopsis:   Modify menu button text, called by CMenuButtonsMgr
//
//  Arguments:  [nCommandID]     - Command ID.
//              [lpszButtonText] - New text.
//
//  Returns:    LONG, command id of the menu (-1 if failed to change).
//
//  Note:       We delete the old button and add a new button with this
//              name and button id.
//              The reason for not calling SetButtonInfo is it does not allow us
//              to change the string index (iString in TBBUTTON).
//
//--------------------------------------------------------------------
LONG CMenuBar::SetMenuButton(INT nCommandID, LPCTSTR lpszButtonText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    // Note the index and hidden state.
    int iIndex = CommandToIndex(nCommandID);
    bool bHidden = IsButtonHidden(nCommandID);

    // Please see the note above about why we do Delete and Insert
    // instead of Set.
    BOOL bSuccess = DeleteMenuButton(nCommandID);

    if (bSuccess)
        return InsertMenuButton(lpszButtonText, bHidden, iIndex);

    return -1;
}


/*--------------------------------------------------------------------------*
 * CMenuBar::SetMenuFont
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::SetMenuFont ()
{
    // delete the old font
    m_MenuFont.DeleteObject ();

    // query the system for the current menu font
    NONCLIENTMETRICS    ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    // use it here, too
    m_MenuFont.CreateFontIndirect (&ncm.lfMenuFont);
    SetFont (&m_MenuFont, FALSE);

    /*
     * get the metrics for the menu text, so we can use it's height
     */
    TEXTMETRIC tm;
    CWindowDC dc(this);
    CFont* pOldFont = dc.SelectObject (&m_MenuFont);
    dc.GetTextMetrics (&tm);
    dc.SelectObject (pOldFont);

    /*
     * Menu item buttons will contain only text (no bitmaps), so set the
     * bitmap width to 0 so we don't have unwanted whitespace.
     *
     * We need to reserve height for the bitmap, though.  If we don't do
     * this, then the toolbar will calculate its own height to be too
     * small when there aren't any buttons with text.  (This occurs in MDI
     * user mode when the active child is maximized.  In that case, the
     * system menu button is visible, but we have no menu items.)
     */
    SetBitmapSize (CSize (0, std::_MAX ((int) tm.tmHeight,
                                        GetSystemMetrics (SM_CXSMICON))));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnActivateCurrentPopup
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::OnActivateCurrentPopup ()
{
    PopupMenu (GetHotItem(), false /*bHighlightFirstItem*/);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnDestroy
 *
 * WM_DESTROY handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnDestroy()
{
    CMMCToolBarCtrlEx::OnDestroy();
    GetMaxedChildIcon (NULL);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnSysCommand
 *
 * WM_SYSCOMMAND handler for CMenuBar.
 *
 * If we want to get the right sound effects for the action, we'll need to
 * let DefWindowProc handle the message.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnSysCommand(UINT nID, LPARAM lParam)
{
    ASSERT (m_pMDIFrame != NULL);

    BOOL            bMaximized;
    CMDIChildWnd*   pwndActive = m_pMDIFrame->MDIGetActive (&bMaximized);

    // if the user has quick fingers he may succeed in issuing the command
    // while the document is being closed - thus there may not be any
    // child windows at all. We ignore the command in such case
    // see bug #119775: MMC Crashes when snapin delays in closing down.
    if (pwndActive == NULL)
        return;

    switch (nID & 0xFFF0)
    {
        case SC_MINIMIZE:   pwndActive->ShowWindow  (SW_MINIMIZE);  break;
        case SC_MAXIMIZE:   pwndActive->ShowWindow  (SW_MAXIMIZE);  break;
        case SC_RESTORE:    pwndActive->ShowWindow  (SW_RESTORE);   break;
        case SC_CLOSE:      pwndActive->SendMessage (WM_CLOSE);     break;
        default:
            CMMCToolBarCtrlEx::OnSysCommand (nID, lParam);
            break;
    }
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        // the system menu font may have changed; update it now
        SetMenuFont ();

        // resize the decoration window
        SizeDecoration ();

        // update the size of the system menu button
        TBBUTTONINFO btni;
        btni.cbSize  = sizeof (btni);
        btni.dwMask  = TBIF_SIZE;
        btni.cx      = static_cast<WORD>(GetSystemMetrics (SM_CXSMICON));
        SetButtonInfo (ID_MTB_MENU_SYSMENU, &btni);

        m_fMaxedChildIconIsInvalid = true;

        // auto-size the toolbar
        UpdateToolbarSize ();
        AutoSize ();
    }
}



/*--------------------------------------------------------------------------*
 * CMenuBar::SizeDecoration
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::SizeDecoration ()
{
    if (m_pMDIDec.get() == NULL)
        return;

    // jiggle the window's size so it will auto-size...
    m_pMDIDec->SetWindowPos (NULL, 0, 0, 10, 10,
                             SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);

    CRect   rect;
    m_pMDIDec->GetClientRect (rect);

    // ...and update its band to accomodate it
    REBARBANDINFO   rbi;
    PrepBandInfo (&rbi, RBBIM_SIZE | RBBIM_CHILDSIZE);
    rbi.cx         = rect.Width();
    rbi.cxMinChild = rect.Width();
    rbi.cyMinChild = rect.Height();

    m_pRebar->SetBandInfo (GetDecorationBandIndex (), &rbi);
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnDropDown
 *
 * Reflected TBN_DROPDOWN handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg void CMenuBar::OnDropDown (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);

    // pop up the menu. Use async method, because toolbar will
    // keeb the button hilited until this function returns
    PopupMenuAsync (CommandToIndex (((LPNMTOOLBAR) pHdr)->iItem));

    // drop down notification handled here
    *pResult = TBDDRET_DEFAULT;
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnGetDispInfo
 *
 * Reflected TBN_GETDISPINFO handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg void CMenuBar::OnGetDispInfo (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);

    if (m_fDecorationsShowing)
    {
        NMTBDISPINFO*   ptbdi = reinterpret_cast<NMTBDISPINFO *>(pHdr);

        if ((ptbdi->dwMask & TBNF_IMAGE) &&
            (ptbdi->idCommand != ID_MTB_MENU_SYSMENU))
        {
            ptbdi->iImage = -1;
        }
    }
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnCustomDraw
 *
 * Reflected NM_CUSTOMDRAW handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg void CMenuBar::OnCustomDraw (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);
    LPNMCUSTOMDRAW pnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(pHdr);

    switch (pnmcd->dwDrawStage)
    {
        case CDDS_PREPAINT:
            // notify for individual buttons
            *pResult = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
            // draw the system menu button manually
            if (pnmcd->dwItemSpec == ID_MTB_MENU_SYSMENU)
            {
                if (m_fMaxedChildIconIsInvalid)
                    GetMaxedChildIcon (m_pMDIFrame->MDIGetActive());

                if (m_hMaxedChildIcon != NULL)
                {
                    /*
                     * compute the location at which we'll draw,
                     * biasing down and to the left
                     */
                    CRect rect = pnmcd->rc;
                    int dx = (rect.Width()  - GetSystemMetrics(SM_CXSMICON)    ) / 2;
                    int dy = (rect.Height() - GetSystemMetrics(SM_CYSMICON) + 1) / 2;



					/*
					 * Preserve icon shape when BitBlitting it to a
					 * mirrored DC.
					 */
					DWORD dwLayout=0L;
					if ((dwLayout=GetLayout(pnmcd->hdc)) & LAYOUT_RTL)
					{
						SetLayout(pnmcd->hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
					}

                    DrawIconEx (pnmcd->hdc,
                                rect.left + dx,
                                rect.top  + dy,
                                m_hMaxedChildIcon, 0, 0, 0,
                                NULL, DI_NORMAL);


					/*
					 * Restore the DC to its previous layout state.
					 */
					if (dwLayout & LAYOUT_RTL)
					{
						SetLayout(pnmcd->hdc, dwLayout);
					}
                }

                // skip the default drawing
                *pResult = CDRF_SKIPDEFAULT;
            }
            else
            {
                // do the default drawing
                *pResult = CDRF_DODEFAULT;
            }
            break;
    }
}



/*--------------------------------------------------------------------------*
 * CMenuBar::PopupMenuAsync
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::PopupMenuAsync (int nItemIdex)
{
    PostMessage (WM_POPUP_ASYNC, nItemIdex);
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnPopupAsync
 *
 * WM_POPUP_ASYNC handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg LRESULT CMenuBar::OnPopupAsync (WPARAM wParam, LPARAM)
{
    PopupMenu (wParam, false /*bHighlightFirstItem*/);
    return (0);
}

/***************************************************************************\
 *
 * METHOD:  CMenuBar::OnHotItemChange
 *
 * PURPOSE: Called when item hiliting changes. Used here to detect when menu
 *          is dissmissed to reset the UI
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
afx_msg void CMenuBar::OnHotItemChange(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CMenuBar::OnHotItemChange"));

    // parameter chack
    sc = ScCheckPointers(pNMHDR, pResult);
    if (sc)
        return;

    // init out parameter
    *pResult = 0;

    // let the base class do it's job
    CMMCToolBarCtrlEx::OnHotItemChange(pNMHDR, pResult);

    // if menu is dismissed and not because of popup being displayed,
    // we need to revert to initial state by hiding accelerators
    LPNMTBHOTITEM lpNmTbHotItem = (LPNMTBHOTITEM)pNMHDR;
    if ( (*pResult == 0) &&
         (lpNmTbHotItem->dwFlags & HICF_LEAVING) &&
         !m_bInProgressDisplayingPopup )
    {
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CMenuBar::PopupMenu
 *
 * PURPOSE: Displays the popup menu specified by the index.
 *
 * PARAMETERS:
 *    int   nItemIndex :
 *    bool  bHighlightFirstItem : true to automatically highlight the first item
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CMenuBar::PopupMenu (int nItemIndex, bool bHighlightFirstItem)
{
    DECLARE_SC(sc, TEXT("CMenuBar::PopupMenu"));

    // get the rectangle that we don't want the popup to overlap
    CRect   rectExclude;
    CPopupTrackContext popupMonitor(this, nItemIndex);

    /*
     * OnIdle updates various member variables such as
     * m_fDecorationsShowing. It must be called before
     * popup menu is created to ensure accurate information
     */
    OnIdle();

    // there is high possibility, that the code in following block
    // adds nothing to the current functionality. It is left as it was
    // in previos implementation, since it isn't obvios if removing it
    // does not break anything.
    // Even if the block is removed, call to EndTracking() at the end of method
    // must still be present to exit tracking if it was put by entering menu
    // via pressing the ALT key
    {
        /*
         * make sure the frame's tracking manager is in tracking mode
         */
        CMainFrame* pFrame = AMCGetMainWnd();
        if (pFrame != NULL)
        {
            CToolbarTracker*    pTracker = pFrame->GetToolbarTracker();
            ASSERT (pTracker != NULL);

            if (!pTracker->IsTracking())
                pTracker->BeginTracking();
        }

        BeginTracking ();
    }

    // following is to indicate that the change in menu (if one does occurr)
    // is because of attempt to switch to another submenu, and should not be
    // treated as dismissing the menu. thus accelerator state should not be changed
    m_bInProgressDisplayingPopup = true;

    // There are two ways the popup menu is dismissed. it either:
    // - request to display the new popup (left & right arrows, mouse on other item, etc)
    // - or request to close the menu ( command is selected, ESC is pressed )
    // following loop will continue displaying menus until request to close the menu is received
    do {

        GetItemRect (nItemIndex, rectExclude);
        MapWindowPoints (NULL, rectExclude);

        // get the information for this button
        TBBUTTON    btn;
        GetButton (nItemIndex, &btn);

        // if the requested button is ignorable, punt
        if (::IsIgnorableButton (btn))
            break;

        // get the popup menu to display
        HMENU   hPopupMenu = (HMENU) btn.dwData;

        // For system menu hPopupMenu will be NULL.
        // If system menu is requested get it now.
        if (ID_MTB_MENU_SYSMENU == btn.idCommand)
        {
            ASSERT (m_fDecorationsShowing);
            ASSERT (m_pMDIFrame != NULL);

            CMDIChildWnd* pwndActive = m_pMDIFrame->MDIGetActive();
            ASSERT (pwndActive != NULL);
            if (pwndActive == NULL)
                break;

            hPopupMenu = pwndActive->GetSystemMenu(FALSE)->GetSafeHmenu();
        }

        // display the button's popup menu
        TPMPARAMS   tpm;
        tpm.cbSize    = sizeof(TPMPARAMS);
        tpm.rcExclude = rectExclude;

        SetHotItem (-1);
        PressButton (btn.idCommand, TRUE);

        // Get the point where the  menu should be popped up.
        bool fLayoutRTL = (GetExStyle() & WS_EX_LAYOUTRTL);
        POINT pt;
        pt.y = rectExclude.bottom;
        pt.x = (fLayoutRTL) ? rectExclude.right : rectExclude.left;

		/*
		 * Bug 17342: TrackPopupMenuEx doesn't place the menu well if the
		 * x-coordinate of its origin is off-screen to the left, so prevent
		 * this from occurring.  TrackPopupMenuEx *does* work fine when the
		 * x-coordinate is off-screen to the right or if the y-coordinate is
		 * off-screen to the bottom, so we don't need to account for those
		 * cases.  (The system prevents placing the window such that the
		 * y-coordinate would be off-screen to the top.)
		 *
		 * Bug 173543: We can't assume that an x-coordinate less than 0 is
		 * off the screen.  For multimon systems with the primary monitor
		 * on the right, the left monitor will have negative x coordinates.
		 * Our left-most position will be the left edge of the monitor nearest
		 * where the menu will be displayed.
		 */
		int xMin = 0;
		HMONITOR hmonMenu = MonitorFromPoint (pt, MONITOR_DEFAULTTONEAREST);

		if (hmonMenu != NULL)
		{
			MONITORINFO mi = { sizeof(mi) };
			
			if (GetMonitorInfo (hmonMenu, &mi))
				xMin = (fLayoutRTL) ? mi.rcWork.right : mi.rcWork.left;
		}

		if ((!fLayoutRTL && (pt.x < xMin)) || (fLayoutRTL && (pt.x > xMin)))
			pt.x = xMin;

        // HACK: post a bogus down arrow so the first menu item will be selected
        if(bHighlightFirstItem)
        {
            CWnd*   pwndFocus = GetFocus();

            if (pwndFocus != NULL)
                pwndFocus->PostMessage (WM_KEYDOWN, VK_DOWN, 1);
        }

        // monitor what's the popup menu fate
        popupMonitor.StartMonitoring();

		// Child window wont exist if there is no views, so check this ptr before using it.
		CChildFrame* pChildFrame = dynamic_cast<CChildFrame*>(m_pMDIFrame->MDIGetActive());

        // hPopupMenu exists only if the sub-menus were added thro resource like File, Window
        // and Help menus. The Action, View, Favorites and any snapin added menu's sub-menus
        // are not added thro resources so for them hPopupmenu is null.
        if (! hPopupMenu)
        {
			sc = ScCheckPointers(pChildFrame, E_UNEXPECTED);
			if (sc)
            {
				sc.TraceAndClear();
                break;
            }

            CAMCView *pAMCView = pChildFrame->GetAMCView();
            sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
            if (sc)
            {
				sc.TraceAndClear();
                break;
            }

            switch(btn.idCommand)
            {
				case ID_MTB_MENU_ACTION:
                    pAMCView->OnActionMenu(pt, rectExclude);
					break;

				case ID_MTB_MENU_VIEW:
                    pAMCView->OnViewMenu(pt, rectExclude);
					break;

				case ID_MTB_MENU_FAVORITES:
                    pAMCView->OnFavoritesMenu(pt, rectExclude);
					break;

                // Assumption if none of the above then it is snapin added menu.
                // We try to forward this to snapin else we get an error.
				default:
                {
                    // If this is one of the MenuButtons inserted by
                    // the CMenuButtonsMgrImpl, notify CMenuButtonsMgrImpl
                    // to do TrackPopupMenu.

                    // Get the CMenuButtonsMgrImpl from the ChildFrame.
                    CMenuButtonsMgrImpl* pMenuBtnsMgr = pChildFrame->GetMenuButtonsMgr();
                    sc = ScCheckPointers(pMenuBtnsMgr, E_UNEXPECTED);
                    if (sc)
                        break;

                    // Notify CMenuButtonsMgr to popup a menu.
                    sc = pMenuBtnsMgr->ScNotifyMenuClick(btn.idCommand, pt);
                    if (sc)
                        break;
                }
                break;
            }

            if (sc)
            {
				sc.TraceAndClear();
                break;
            }

        }
        else
        {
            ASSERT (::IsMenu (hPopupMenu));

            HWND hwndMenuOwner = AfxGetMainWnd()->GetSafeHwnd();

            TrackPopupMenuEx (hPopupMenu,
                              TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL,
                              pt.x, pt.y, hwndMenuOwner, &tpm);
        }

		// Clear the status bar.
		if (pChildFrame)
	        sc = pChildFrame->ScSetStatusText(TEXT(""));

        if (sc)
			sc.TraceAndClear();

        PressButton (btn.idCommand, FALSE);
        SetHotItem (-1);

        // the loop will continue if it was requested to display the new popup menu.
        // if it was requested to simply close the menu, execution will exit the loop
    }while ( popupMonitor.WasAnotherPopupRequested(nItemIndex) );

    m_bInProgressDisplayingPopup = false;
    //reset the UI by hiding the accelerators (since we are done)
    SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));

    EndTracking();
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnAccelPopup
 *
 * Keyboard accelerator handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnAccelPopup (UINT cmd)
{
    PopupMenu (CommandToIndex (cmd), true /*bHighlightFirstItem*/);
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnUpdateAllCmdUI
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::OnUpdateAllCmdUI (CCmdUI* pCmdUI)
{
    pCmdUI->Enable ();
}



/*--------------------------------------------------------------------------*
 * CMenuBar::AddString
 *
 * The toolbar control doesn't provide a way to delete strings once they've
 * been added, so we'll check our cache of strings that we've already added
 * to the toolbar so we don't add wasteful duplicate strings.
 *--------------------------------------------------------------------------*/

int CMenuBar::AddString (const CString& strAdd)
{
    // -1 for empty strings
    if (strAdd.IsEmpty())
        return (-1);

    // check the cache
    ToolbarStringPool::iterator it = std::find (m_ToolbarStringPool.begin(),
                                                m_ToolbarStringPool.end(),
                                                strAdd);

    // if we found a hit in the cache, return the cached index
    if (it != m_ToolbarStringPool.end())
        return (it - m_ToolbarStringPool.begin());


    // new string, add it to the cache...
    m_ToolbarStringPool.push_back (strAdd);


    // ...and to the toolbar, including a double-NULL
    int     cchAdd = strAdd.GetLength() + 1;
    LPTSTR  pszAdd = (LPTSTR) _alloca ((cchAdd + 1) * sizeof (TCHAR));
    _tcscpy (pszAdd, strAdd);
    pszAdd[cchAdd] = 0;

    int nIndex = AddStrings (pszAdd);

    // make sure the toolbar's string index matches the cache's string index
    ASSERT (nIndex == m_ToolbarStringPool.end()-m_ToolbarStringPool.begin()-1);

    return (nIndex);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::GetMenuBandIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMenuBar::GetMenuBandIndex () const
{
    return (m_pRebar->IdToIndex (GetDlgCtrlID ()));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::GetDecorationBandIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMenuBar::GetDecorationBandIndex () const
{
    return (m_pRebar->IdToIndex (ID_MDIDECORATION));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::GetFirstButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMenuBar::GetFirstButtonIndex ()
{
    // make sure the system menu isn't the first one activated
    return (GetNextButtonIndex (0));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnIdle
 *
 * WM_IDLE handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnIdle ()
{
    /*----------------------------------------------------------*/
    /* If there's no MDI frame, that means this menu is serving */
    /* an SDI window.  We don't have to do any special stuff to */
    /* simulate the MDI menu UI, so bail now.                   */
    /*----------------------------------------------------------*/
    if (m_pMDIFrame == NULL)
        return;

    ProgramMode eMode = AMCGetApp()->GetMode();

    // if we're in SDI User mode, bail now as well
    if (eMode == eMode_User_SDI)
    {
#ifdef DBG
        // the decorations should be hidden
        REBARBANDINFO   rbi;
        PrepBandInfo (&rbi, RBBIM_STYLE);
        m_pRebar->GetBandInfo (GetDecorationBandIndex(), &rbi);
        ASSERT (rbi.fStyle & RBBS_HIDDEN);
#endif

        return;
    }

    /*---------------------------------------------------------------*/
    /* We should be able to use MDIGetActive(&fMaximized) to tell    */
    /* whether the active window is maximized, instead of calling    */
    /* pwndActive->IsZoomed().  However, fMaximized doesn't always   */
    /* get initialized correctly in certain low memory/slow machine  */
    /* situations.  This was the cause of Bug 133179, logged by SQL. */
    /*---------------------------------------------------------------*/
    CMDIChildWnd*   pwndActive = m_pMDIFrame->MDIGetActive ();
    bool            fShow      = (pwndActive != NULL) && pwndActive->IsZoomed();

    REBARBANDINFO   rbi;
    PrepBandInfo (&rbi, RBBIM_STYLE);
    m_pRebar->GetBandInfo (GetMenuBandIndex(), &rbi);

    // if the menu bar is hidden, the decorations must be hidden as well
    if (rbi.fStyle & RBBS_HIDDEN)
        fShow = false;

    if (fShow != m_fDecorationsShowing)
    {
        // show/hide the MDI decorations
        m_pRebar->ShowBand (GetDecorationBandIndex(), fShow);

        GetMaxedChildIcon (pwndActive);
        HideButton (ID_MTB_MENU_SYSMENU, !fShow);
        UpdateToolbarSize ();

        // remember the new setting
        m_fDecorationsShowing = fShow;
    }

    // otherwise, see if a window was maximized before but a different one is maxed now
    else if (fShow && (m_pwndLastActive != pwndActive))
    {
        // get the new active window's icon
        GetMaxedChildIcon (pwndActive);

        // repaint the menu and MDI decorations
        InvalidateRect (NULL);
        m_pMDIDec->InvalidateRect (NULL);
    }

    // remember the currently active window
    m_pwndLastActive = pwndActive;

    // insure that it's safe to keep this pointer around
    ASSERT ((m_pwndLastActive == NULL) ||
            (CWnd::FromHandlePermanent (m_pwndLastActive->m_hWnd) != NULL));
}


/*--------------------------------------------------------------------------*
 * CMenuBar::DeleteMaxedChildIcon
 *
 *
 *--------------------------------------------------------------------------*/
void
CMenuBar::DeleteMaxedChildIcon()
{
    // destroy the previous icon, if we need to
    if (m_fDestroyChildIcon)
    {
        ASSERT (m_hMaxedChildIcon != NULL);
        DestroyIcon (m_hMaxedChildIcon);
        m_hMaxedChildIcon   = NULL;
        m_fDestroyChildIcon = false;
    }
}


/*--------------------------------------------------------------------------*
 * CMenuBar::GetMaxedChildIcon
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::GetMaxedChildIcon (CWnd* pwnd)
{
    DeleteMaxedChildIcon();

    // get the small icon for the given window
    if (IsWindow (pwnd->GetSafeHwnd()))
    {
        HICON hOriginalIcon = pwnd->GetIcon (false /*bBigIcon*/);

        m_hMaxedChildIcon = (HICON) CopyImage (
                                        hOriginalIcon, IMAGE_ICON,
                                        GetSystemMetrics (SM_CXSMICON),
                                        GetSystemMetrics (SM_CYSMICON),
                                        LR_COPYFROMRESOURCE | LR_COPYRETURNORG);

        // if the system had to create a new icon, we'll have to destroy it later
        if ((m_hMaxedChildIcon != NULL) && (m_hMaxedChildIcon != hOriginalIcon))
            m_fDestroyChildIcon = true;
    }

    m_fMaxedChildIconIsInvalid = false;
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::GetAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::GetAccelerators (int cchBuffer, LPTSTR lpBuffer) const
{
    lstrcpyn (lpBuffer, m_strAccelerators, cchBuffer);
}

//+-------------------------------------------------------------------
//
//  Member:      CMenuBar::IsStandardMenuAllowed
//
//  Synopsis:    Is this standard MMC menu allowed or not.
//
//  Arguments:   uMenuID - The menu ID.
//
//  Returns:     bool
//
//--------------------------------------------------------------------
bool CMenuBar::IsStandardMenuAllowed(UINT uMenuID)
{
    DECLARE_SC(sc, _T("CMenuBar::IsStandardMenuAllowed"));

    /*
     * We add a hidden menu as a marker. Later when snapin
     * calls to insert a menu button we find the position
     * of this menu and add snapin menu before it.
     * So this acts as Std menu which is always allowed.
     */
    if (uMenuID == ID_SNAPIN_MENU_PLACEHOLDER)
        return true;

    // First make sure it is one of the std menus.
    if ( (uMenuID != ID_FAVORITES_MENU) &&
         (uMenuID != ID_ACTION_MENU) &&
         (uMenuID != ID_VIEW_MENU))
         {
             sc = E_INVALIDARG;
             return true;
         }

    // Ask view data if std menus are allowed.

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return false;

    CAMCView *pAMCView = pMainFrame->GetActiveAMCView();
    sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
    if (sc)
        return false;

    SViewData* pViewData = pAMCView->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return false;

    if (! pViewData->IsStandardMenusAllowed())
        return false;

    if (uMenuID != ID_FAVORITES_MENU)
        return true;

    /*
     * Display the Favorites menu button if we are in author mode, or if
     * we're in user mode and we have at least one favorite.  If we're in
     * user mode and no favorites are defined, hide the Favorites button.
     */
    bool fShowFavorites = true;
    CAMCApp* pApp = AMCGetApp();

    if (pApp != NULL)
    {
        /*
         * show favorites in author mode
         */
        fShowFavorites = (pApp->GetMode() == eMode_Author);

        /*
         * not author mode? see if we have any favorites
         */
        if (!fShowFavorites)
        {
            CAMCDoc* pDoc = CAMCDoc::GetDocument ();

            if (pDoc != NULL)
            {
                CFavorites* pFavorites = pDoc->GetFavorites();

                if (pFavorites != NULL)
                    fShowFavorites = !pFavorites->IsEmpty();
            }
        }
    }

    return fShowFavorites;
}


//+-------------------------------------------------------------------
//
//  Member:      CMenuBar::ScShowMMCMenus
//
//  Synopsis:    Show or Hide the MMC menus (Action, View & Favorites).
//               Called from customize view.
//
//  Arguments:
//
//  Returns:     SC
//
//  Note:        As this is called from Customize view no need to look
//               at viewdata::IsStandardMenusAllowed.
//               Also Favorites button is not added in first place
//               if it is not allowed. So no need for Favorites menu
//               special case.
//
//--------------------------------------------------------------------
SC CMenuBar::ScShowMMCMenus (bool bShow)
{
    DECLARE_SC(sc, _T("CMenuBar::ScShowMMCMenus"));

    // Go through the menu buttons & find Action, View & Favorites.

    TBBUTTON    btn;
    int cButtons = GetButtonCount();

    for (int i = 0; i < cButtons; ++i)
    {
        GetButton (i, &btn);

        // Skip if button is not action/view/favs.
        if ( (btn.idCommand != ID_MTB_MENU_FAVORITES) &&
             (btn.idCommand != ID_MTB_MENU_ACTION) &&
             (btn.idCommand != ID_MTB_MENU_VIEW) )
             {
                 continue;
             }

        // For favorites menu see if it is appropriate to un-hide it.
        // In non-author mode if there is no favorites then this menu
        // is hidden.
        if ( bShow &&
             (btn.idCommand == ID_MTB_MENU_FAVORITES) &&
             (! IsStandardMenuAllowed(ID_FAVORITES_MENU)) )
            continue;

        HideButton(btn.idCommand, !bShow);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::ScInsertAccPropIDs
 *
 * Inserts the IDs of the accessibility properties supported by CMenuBar
 * (see ScGetPropValue).
 *--------------------------------------------------------------------------*/

SC CMenuBar::ScInsertAccPropIDs (PropIDCollection& v)
{
	DECLARE_SC (sc, _T("CMenuBar::ScInsertAccPropIDs"));

	/*
	 * let the base class do its thing
	 */
	sc = CMMCToolBarCtrlEx::ScInsertAccPropIDs (v);
	if (sc)
		return (sc);

	/*
	 * add our own properties
	 */
	v.push_back (PROPID_ACC_ROLE);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::ScGetPropValue
 *
 * Returns accessibility properties supported by CMenuBar.
 *
 * If a property is returned, fGotProp is set to true.  If it is not
 * returned, the value of fGotProp is unchanged, since the property might
 * have been provided by a base/derived class.
 *--------------------------------------------------------------------------*/

SC CMenuBar::ScGetPropValue (
	HWND				hwnd,		// I:accessible window
	DWORD				idObject,	// I:accessible object
	DWORD				idChild,	// I:accessible child object
	const MSAAPROPID&	idProp,		// I:property requested
	VARIANT&			varValue,	// O:returned property value
	BOOL&				fGotProp)	// O:was a property returned?
{
	DECLARE_SC (sc, _T("CMenuBar::ScGetPropValue"));

	/*
	 * call the base class
	 */
	sc = CMMCToolBarCtrlEx::ScGetPropValue (hwnd, idObject, idChild, idProp, varValue, fGotProp);
	if (sc)
		return (sc);

	/*
	 * now handle requests for properties we support...role first
	 */
	if (idProp == PROPID_ACC_ROLE)
	{
		/*
		 * don't override the property for child elements,
		 * don't return a property
		 */
		if (idChild != CHILDID_SELF)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: no role for child %d"), idChild);
			return (sc);
		}

		/*
		 * the control itself has a role of menubar
		 */
		V_VT(&varValue) = VT_I4;
		V_I4(&varValue) = ROLE_SYSTEM_MENUBAR;
		fGotProp        = true;
		Trace (tagToolbarAccessibility, _T("GetPropValue: Returning 0x%08x"), V_I4(&varValue));
	}
    else if (idProp == PROPID_ACC_STATE)
    {
        /*
         * Bug 148132: if the base class returned a property, append
         * STATE_SYSTEM_HASPOPUP so Narrator et al will announce "has a
         * submenu" when the menu item is highlighted
         */
        if (fGotProp)
        {
            ASSERT (V_VT(&varValue) == VT_I4);
            V_I4(&varValue) |= STATE_SYSTEM_HASPOPUP;
            Trace (tagToolbarAccessibility, _T("GetPropValue: Appending STATE_SYSTEM_HASPOPUP, Returning 0x%08x"), V_I4(&varValue));
        }
        else
        {
            V_VT(&varValue) = VT_I4;
            V_I4(&varValue) = STATE_SYSTEM_FOCUSABLE | STATE_SYSTEM_HASPOPUP;
            fGotProp        = true;

            if (IsTrackingToolBar() && (GetHotItem() == (idChild-1) /*0-based*/))
                V_I4(&varValue) |= STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED;

            Trace (tagToolbarAccessibility, _T("GetPropValue: Returning 0x%08x"), V_I4(&varValue));
        }
    }

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::BeginTracking2
 *
 * Fires EVENT_SYSTEM_MENUSTART event accessibility event, then call base
 * class.
 *--------------------------------------------------------------------------*/

void CMenuBar::BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
	NotifyWinEvent (EVENT_SYSTEM_MENUSTART, m_hWnd, OBJID_CLIENT, CHILDID_SELF);
	CMMCToolBarCtrlEx::BeginTracking2 (pAuxWnd);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::EndTracking2
 *
 * Fires EVENT_SYSTEM_MENUEND event accessibility event, then call base
 * class.
 *--------------------------------------------------------------------------*/

void CMenuBar::EndTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
	NotifyWinEvent (EVENT_SYSTEM_MENUEND, m_hWnd, OBJID_CLIENT, CHILDID_SELF);
	CMMCToolBarCtrlEx::EndTracking2 (pAuxWnd);
}


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPopupTrackContext



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::CPopupTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CPopupTrackContext::CPopupTrackContext (
    CMenuBar*   pMenuBar,
    int         nCurrentPopupIndex)
    :
    m_pMenuBar          (pMenuBar),
    m_cButtons          (pMenuBar->GetButtonCount()),
    m_ptLastMouseMove   (GetMessagePos()),
    m_ptLButtonDown     (GetMessagePos()),
    m_dwLButtonDownTime (GetMessageTime()),
    m_bPopupMonitorHooksActive(false),
    m_iRequestForNewPopup(-1)
{
    ASSERT_VALID (pMenuBar);
    ASSERT (s_pTrackContext == NULL);

    m_nCurrentPopupIndex    = nCurrentPopupIndex;
    m_fCurrentlyOnPopupItem = false;
    m_cCascadedPopups       = 0;

    ASSERT (m_nCurrentPopupIndex <  m_cButtons);
    ASSERT (m_nCurrentPopupIndex >= 0);

    // build the vector of button boundaries
    m_ButtonBoundaries.resize (m_cButtons + 1, 0);
    ASSERT (m_ButtonBoundaries.size() == m_cButtons + 1);
    ASSERT (m_ButtonBoundaries.size() >= 2);

    CRect   rectButton (0, 0, 0, 0);
    POINT   ptTopLeft = rectButton.TopLeft();

    for (int i = 0; i < m_cButtons; i++)
    {
        // GetItemRect will fail (acceptably) for hidden buttons,
        // but should otherwise succeed.
        VERIFY (pMenuBar->GetItemRect(i, rectButton) ||
                pMenuBar->IsButtonHidden(pMenuBar->IndexToCommand(i)) );

        // Do not map rectButton from Client To Screen.
        // Map a copy of it (in ptTopLeft). So if a hidden
        // button follows, it can use the rectButton.TopLeft()
        // value and map it.
        ptTopLeft = rectButton.TopLeft();
        pMenuBar->ClientToScreen (&ptTopLeft);
        m_ButtonBoundaries[i] = ptTopLeft.x;

		// make m_rectAllButtons as a union of all buttons
		if (i == 0)
			m_rectAllButtons = rectButton;
		else
			m_rectAllButtons |= rectButton;
    }

    ptTopLeft = rectButton.BottomRight();
    pMenuBar->ClientToScreen (&ptTopLeft);
    m_ButtonBoundaries[m_cButtons] = ptTopLeft.x;

	pMenuBar->ClientToScreen (&m_rectAllButtons);
	// decrease m_rectAllButtons slightly
	m_rectAllButtons.left =	m_rectAllButtons.left + 1;
	m_rectAllButtons.right = m_rectAllButtons.right - 1;

#ifdef DBG
    {
        // the button boundaries should naturally fall in ascending(for LTR) order
        for (int j = 0; j < m_ButtonBoundaries.size()-1; j++)
        {
		    if (0 == (m_pMenuBar->GetExStyle() & WS_EX_LAYOUTRTL))
				ASSERT (m_ButtonBoundaries[j] <= m_ButtonBoundaries[j+1]);
			else
				ASSERT (m_ButtonBoundaries[j] >= m_ButtonBoundaries[j+1]);
        }
    }
#endif

    /*--------------------------------------------------------------------*/
    /* see if we might need to simulate a double-click on the system menu */
    /*--------------------------------------------------------------------*/
    m_pMaxedMDIChild = NULL;

    // only deal with the system menu if the MDI decorations are showing
    if (m_pMenuBar->m_fDecorationsShowing)
    {
        ASSERT (m_pMenuBar->m_pMDIFrame != NULL);
        CWnd* pMDIChild = m_pMenuBar->m_pMDIFrame->MDIGetActive();

        // nothing to do if child is already gone
        if ( pMDIChild == NULL )
            return;

        ASSERT (pMDIChild->IsZoomed());

        // if the mouse is over the system menu, remember the maximized child
        // (non-NULL m_pMaxedMDIChild is the key later on in MaybeCloseMDIChild)
        if (HitTest (m_ptLButtonDown) == 0)
            m_pMaxedMDIChild = pMDIChild;
    }

}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::~CPopupTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CPopupTrackContext::~CPopupTrackContext ()
{
    // release the mouse and keyboard hooks
    RemovePopupMonitorHooks();
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::RemovePopupMonitorHooks
 *
 * Unhooks from the system and stops watching the events
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::RemovePopupMonitorHooks ()
{
    // ignore if not monitoring yet
    if (m_bPopupMonitorHooksActive)
    {
        // we MUST be the active monitor if we came here
        if (s_pTrackContext != this)
        {
            ASSERT(FALSE && "Popup monitor uninstalled from outside");
            return;
        }
        // release the mouse and keyboard hooks
        UnhookWindowsHookEx (m_hhkMouse);
        UnhookWindowsHookEx (m_hhkKeyboard);
        UnhookWindowsHookEx (m_hhkCallWnd);

        m_bPopupMonitorHooksActive = false;
        // uninstall itself as hook monitor
        s_pTrackContext = NULL;
    }
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::SetPopupMonitorHooks
 *
 * Hooks into the system and begins watching the events
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::SetPopupMonitorHooks ()
{
    // ignore if already set
    if (!m_bPopupMonitorHooksActive)
    {
        // there is only one active menu per app. There is no place for anybody else
        if (s_pTrackContext)
        {
            ASSERT(FALSE && "Popup menu overrun");
            return;
        }
        // install itself as hook monitor
        s_pTrackContext = this;

        DWORD   idCurrentThread = ::GetCurrentThreadId();

        // hook the mouse for hot tracking
        m_hhkMouse = SetWindowsHookEx (WH_MOUSE, MouseProc, NULL, idCurrentThread);

        // hook the keyboard for navigation
        m_hhkKeyboard = SetWindowsHookEx (WH_KEYBOARD, KeyboardProc, NULL, idCurrentThread);

        // hook send messages for Menu_Is_Closed detection
        m_hhkCallWnd = SetWindowsHookEx (WH_CALLWNDPROC, CallWndProc, NULL, idCurrentThread);

        m_bPopupMonitorHooksActive = true;
    }
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::StartMonitoring
 *
 * Public method to start popup monitoring
 * Hooks into the system and begins watching the events
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::StartMonitoring()
{
    // reset the request to activate another popup upon finish
    m_iRequestForNewPopup = -1;
    // setup hooks and watch...
    SetPopupMonitorHooks();
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::WasAnotherPopupRequested
 *
 * Used to retrieve the cause the menu was dismissed.
 * If new popupu is requested, button index is returned
 *--------------------------------------------------------------------------*/

bool CPopupTrackContext::WasAnotherPopupRequested(int& iNewIdx)
{
    if (m_iRequestForNewPopup >= 0)
    {
        iNewIdx = m_iRequestForNewPopup;
        return true;
    }
    return false;
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MouseProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CPopupTrackContext::MouseProc (int nCode, WPARAM wParam, LPARAM lParam)
{
    CPopupTrackContext* this_ = s_pTrackContext;
    ASSERT (this_ != NULL);

    if (nCode < 0)
        return (CallNextHookEx (this_->m_hhkMouse, nCode, wParam, lParam));

    return (this_->MouseProc (nCode, wParam, (LPMOUSEHOOKSTRUCT) lParam));
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MouseProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CPopupTrackContext::MouseProc (int nCode, UINT msg, LPMOUSEHOOKSTRUCT pmhs)
{
    // if this is a mouse message within the menu bar...
    if (m_rectAllButtons.PtInRect (pmhs->pt))
    {
        // eat the button down so we don't get into a TBN_DROPDOWN loop
        if (msg == WM_LBUTTONDOWN)
        {
            DismissCurrentPopup (true);
            MaybeCloseMDIChild (pmhs->pt);
            return (1);
        }

        // for (non-duplicate) mouse moves, follow the mouse with the active menu
        if ((msg   == WM_MOUSEMOVE) &&
            (nCode == HC_ACTION) &&
            (m_ptLastMouseMove != pmhs->pt))
        {
            // determine which button is being tracked over
            m_ptLastMouseMove = pmhs->pt;
            int nNewPopupIndex = HitTest (m_ptLastMouseMove);
            ASSERT (nNewPopupIndex != -1);

            // if we're not over the same button we were last
            // time, display the popup for the new button
            if (nNewPopupIndex != m_nCurrentPopupIndex)
                NotifyNewPopup (m_nCurrentPopupIndex = nNewPopupIndex);
        }
    }

    return (CallNextHookEx (m_hhkMouse, nCode, msg, (LPARAM) pmhs));
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::KeyboardProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CPopupTrackContext::KeyboardProc (int nCode, WPARAM wParam, LPARAM lParam)
{
    CPopupTrackContext* this_ = s_pTrackContext;
    ASSERT (this_ != NULL);

    if (nCode < 0)
        return (CallNextHookEx (this_->m_hhkKeyboard, nCode, wParam, lParam));

    int     cRepeat = LOWORD (lParam);
    bool    fDown   = (lParam & (1 << 31)) == 0;

    return (this_->KeyboardProc (nCode, wParam, cRepeat, fDown, lParam));
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::KeyboardProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CPopupTrackContext::KeyboardProc (
    int     nCode,
    int     vkey,
    int     cRepeat,
    bool    fDown,
    LPARAM  lParam)
{
    // if this isn't a real message, ignore it
    if (nCode != HC_ACTION)
        return (CallNextHookEx (m_hhkKeyboard, nCode, vkey, lParam));

    // if this is a left or right message...
    if ((vkey == VK_LEFT) || (vkey == VK_RIGHT))
    {
        // eat the key release, but don't do anything with it
        if (!fDown)
            return (1);

        /*
         * let the menu code handle cascaded popups
         */
		// need to do everything in opposite direction on RTL layout
		// see bug #402620	ntbug9	05/23/2001
		const bool fNext = ( (m_pMenuBar->GetExStyle() & WS_EX_LAYOUTRTL) ? (vkey != VK_RIGHT) : (vkey == VK_RIGHT) ) ;

        if (m_fCurrentlyOnPopupItem && fNext)
            m_cCascadedPopups++;

        else if ((m_cCascadedPopups > 0) && !fNext)
            m_cCascadedPopups--;

        /*
         * not right on a popup item, or left on a popped-up menu
         */
        else
        {
            m_cCascadedPopups = 0;

            // figure out the next button
            int nNewPopupIndex = fNext
                    ? m_pMenuBar->GetNextButtonIndex (m_nCurrentPopupIndex, cRepeat)
                    : m_pMenuBar->GetPrevButtonIndex (m_nCurrentPopupIndex, cRepeat);

            // activate the new button's popup, if it's different from the current one
            if (nNewPopupIndex != m_nCurrentPopupIndex)
                NotifyNewPopup (m_nCurrentPopupIndex = nNewPopupIndex);

            // eat the key press
            return (1);
        }
    }

    return (CallNextHookEx (m_hhkKeyboard, nCode, vkey, lParam));
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::CallWndProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CPopupTrackContext::CallWndProc(
  int nCode,      // hook code
  WPARAM wParam,  // current-process flag
  LPARAM lParam   // address of structure with message data
)
{
    // get the active monitor
    CPopupTrackContext* this_ = s_pTrackContext;
    ASSERT (this_ != NULL);

    // ignore special cases
    if (nCode < 0)
        return (CallNextHookEx (this_->m_hhkCallWnd, nCode, wParam, lParam));

    BOOL bCurrentThread = wParam;
    LPCWPSTRUCT lpCWP = reinterpret_cast<LPCWPSTRUCT>(lParam);

    // forward the request to monitor
    return (this_->CallWndProc (nCode, bCurrentThread, lpCWP));
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::CallWndProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CPopupTrackContext::CallWndProc  (int nCode, BOOL bCurrentThread, LPCWPSTRUCT lpCWP)
{
    ASSERT(lpCWP != NULL);
    if (lpCWP)
    {
        // watch for message
        if (lpCWP->message == WM_MENUSELECT)
        {
            // decode params
            const UINT fuFlags = (UINT)  HIWORD(lpCWP->wParam);  // menu flags
            const HMENU hmenu =  (HMENU) lpCWP->lParam;          // handle to menu clicked

            if (fuFlags == 0xFFFF && hmenu == NULL)
            {
                // menu is closed! no more hooking needed
                RemovePopupMonitorHooks ();
            }
            else
            {
                // we stepped on the popup (will use the info when arrows are pressed)
                m_fCurrentlyOnPopupItem = (fuFlags & MF_POPUP);
            }
        }
    }
    // done
    return (CallNextHookEx (m_hhkCallWnd, nCode, bCurrentThread, (LPARAM)lpCWP));
}
/*--------------------------------------------------------------------------*
 * CPopupTrackContext::DismissCurrentPopup
 *
 *
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::DismissCurrentPopup (bool fTrackingComplete)
{
    // If the snapin does TrackPopupMenu with a window other than
    // MainFrame as parent then that window should be asked to
    // close the menu by sending WM_CANCELMODE. The window
    // is found by calling GetCapture().
    CWnd* pwndMode = CWnd::GetCapture();

    if (pwndMode == NULL)
        pwndMode = AfxGetMainWnd();

    pwndMode->SendMessage (WM_CANCELMODE);
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::NotifyNewPopup
 *
 * Notify the menu toolbar that it needs to display a new popup menu.
 * Note that this must be accomplished asynchronously so that we can
 * allow CMenuBar::PopupMenu to unwind after the WM_CANCELMODE from
 * DismissCurrentPopup.
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::NotifyNewPopup (int nNewPopupIndex)
{
    // dismiss the existing popup
    DismissCurrentPopup (false);
    // ask to activate the new popup after this one is closed
    m_iRequestForNewPopup = nNewPopupIndex;
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::HitTest
 *
 * Returns the index of the button under the given point, -1 if none.
 *--------------------------------------------------------------------------*/

int CPopupTrackContext::HitTest (CPoint pt) const
{
    /*----------------------------------------------------------------*/
    /* Find the range of "hit" buttons.  The range will span more     */
    /* than one button only if there are hidden buttons in the range, */
    /* and in that case, there will be exactly one non-hidden button  */
    /* in the range.                                                  */
    /*----------------------------------------------------------------*/
    std::pair<BoundConstIt, BoundConstIt> range;

	if ( m_pMenuBar->GetExStyle() & WS_EX_LAYOUTRTL )
	{
		range = std::equal_range (m_ButtonBoundaries.begin(),
								  m_ButtonBoundaries.end(), pt.x,
								  std::greater<BoundaryCollection::value_type>() );
	}
	else
	{
		range = std::equal_range (m_ButtonBoundaries.begin(),
                                  m_ButtonBoundaries.end(), pt.x);
	}

    int nLowerHitIndex = MapBoundaryIteratorToButtonIndex (range.first);
    int nUpperHitIndex = MapBoundaryIteratorToButtonIndex (range.second);

    /*
     * equal_range returns values that are less_than and greater_than
     * given value. The m_ButtonBoundaries has duplicate values (due
     * to hidden buttons). So if the less_than value is one of duplicate
     * values (not unique) then equal_range returns the iterator to
     * last dup item, not first dup item.
     *
     * Below we try to find the first dup item.
     */

    // Find the first item with value m_ButtonBoundaries[nLowerHitIndex].
    for (int iIndex = 0; iIndex < nLowerHitIndex; ++iIndex)
    {
        if (m_ButtonBoundaries[iIndex] == m_ButtonBoundaries[nLowerHitIndex])
        {
            // Found first item.
            nLowerHitIndex = iIndex;
            break;
        }
    }

    ASSERT (nLowerHitIndex <= nUpperHitIndex);

    int nHitIndex;

    // lower equal upper?  no hidden buttons
    if (nLowerHitIndex == nUpperHitIndex)
        nHitIndex = nLowerHitIndex;

    // otherwise we have some hidden buttons, or we are precisely on a button border
    else
    {
        nHitIndex = -1;

        if (nUpperHitIndex == -1)
            nUpperHitIndex = m_cButtons;

        for (int i = nLowerHitIndex;
             i <= nUpperHitIndex; // We should check till we hit nUpperHitIndex? AnandhaG
             ++i)
        {
            // See if this button is not hidden.
            if (!m_pMenuBar->IsButtonHidden (m_pMenuBar->IndexToCommand(i)))
            {
                nHitIndex = i;
                break;
            }
        }

        // we should have found a visible button
        ASSERT (nHitIndex != -1);
    }

    ASSERT (nHitIndex >= -1);
    ASSERT (nHitIndex <  m_cButtons);
    return (nHitIndex);
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MapBoundaryIteratorToButtonIndex
 *
 * Returns the button index corresponding to the input m_ButtonBoundaries
 * index, -1 for not found.
 *--------------------------------------------------------------------------*/

int CPopupTrackContext::MapBoundaryIteratorToButtonIndex (BoundConstIt it) const
{
    return ((it != m_ButtonBoundaries.end())
                ? it - m_ButtonBoundaries.begin() - 1
                : -1);
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MaybeCloseMDIChild
 *
 *
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::MaybeCloseMDIChild (CPoint pt)
{
    // if we didn't find a maxed MDI child when this all started, punt
    if (m_pMaxedMDIChild == NULL)
        return;

    // if the click didn't happen on the system menu toolbar button, punt
    if (HitTest (pt) != 0)
        return;

    /*-------------------------------------------------------------------*/
    /* if the double-click time has elapsed, punt                        */
    /*                                                                   */
    /* Note: this is called from a mouse hook, which means the value     */
    /* returned by GetMessageTime hasn't been updated for this message,  */
    /* so it really reflects the time of the *previous* message (most    */
    /* likely WM_LBUTTONUP).                                             */
    /*                                                                   */
    /* GetTickCount returns a close enough approximation to              */
    /* GetMessageTime, except when we're debugging through this routine, */
    /* in which case the tick count will continue to spin (and this test */
    /* will always fail) but the message time would have remained fixed. */
    /*-------------------------------------------------------------------*/
//  if ((GetMessageTime() - m_dwLButtonDownTime) > GetDoubleClickTime())
    if ((GetTickCount()   - m_dwLButtonDownTime) > GetDoubleClickTime())
        return;

    // if the second click occurred outside the double-click space, punt
    if ((abs (m_ptLButtonDown.x - pt.x) > GetSystemMetrics (SM_CXDOUBLECLK)) ||
        (abs (m_ptLButtonDown.y - pt.y) > GetSystemMetrics (SM_CYDOUBLECLK)))
        return;

    // if the window doesn't have a system menu, or its Close item is disabled, punt
    CMenu* pSysMenu = m_pMaxedMDIChild->GetSystemMenu (FALSE);

    if (pSysMenu == NULL)
        return;

    UINT nCloseState = pSysMenu->GetMenuState (SC_CLOSE, MF_BYCOMMAND);

    if ((nCloseState == 0xFFFFFFFF) ||
        (nCloseState & (MF_GRAYED | MF_DISABLED)))
        return;

    // here: we've identified a double-click on a maximized child's
    //       system menu; close it
    m_pMaxedMDIChild->PostMessage (WM_SYSCOMMAND, SC_CLOSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mmcaxwin.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      MMCAxWin.h
 *
 *  Contents:  Header file for CMMCAxWindow
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

DEFINE_COM_SMARTPTR(IHTMLElement2);                 // IHTMLElement2Ptr
DEFINE_COM_SMARTPTR(IElementBehaviorFactory);       // IElementBehaviorFactoryPtr

/*+-------------------------------------------------------------------------*
 * HACK_CAN_WINDOWLESS_ACTIVATE
 * 
 * Bug 451918:  By default, the ATL OCX host window supports hosting
 * windowless controls.  This differs from the MMC 1.2 implementation
 * of the OCX host window (which used MFC), which did not.  Some controls
 * (e.g. Disk Defragmenter OCX) claim to support windowless activation
 * but do not.
 * 
 * For compatibility, we must only instantiate result pane OCX's as 
 * windowed controls.  IInPlaceSiteWindowless (implemented by CAxHostWindow) 
 * gives us a nice clean way to do this, by returning S_FALSE from
 * CanWindowlessActivate.  We instruct CAxHostWindow to do this by changing its
 * AllowWindowlessActivation property.
 * 
 * There's a problem with that, however.  ATL21 has a bug where it tests
 * for CanWindowlessActivate returning a FAILED code rather than S_FALSE.
 * This means that even if we use put_AllowWindowlessActivation, ATL21-based
 * controls will still try to activate windowless.
 * 
 * We'll fix this problem by deriving a class, CMMCAxHostWindow, from 
 * CAxHostWindow which will return E_FAIL instead of S_FALSE if windowless
 * activation is not desired.
 *--------------------------------------------------------------------------*/
#define HACK_CAN_WINDOWLESS_ACTIVATE


/*+-------------------------------------------------------------------------*
 * class CMMCAxWindow
 * 
 *
 * PURPOSE: The MMC-specific version of CAxWindow. Contains any fixes and
 *          updates.
 *          Refer to the December 1999 issue of Microsoft Systems Journal
 *          for details, in the article "Extending ATL3.0 Control Containers
 *          to Help you write Real-World Containers."
 *
 *+-------------------------------------------------------------------------*/
class CMMCAxWindow : public CAxWindowImplT<CMMCAxWindow, CAxWindow2>
{
#ifdef HACK_CAN_WINDOWLESS_ACTIVATE
public:
    HRESULT AxCreateControl2(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, IUnknown** ppUnkControl = 0, REFIID iidSink = IID_NULL, IUnknown* punkSink = 0);
#endif
    // Simply override of CAxWindow::SetFocus that handles more special cases
    // NOTE: this is not a virtual method. Invoking on base class pointer will
    // endup in executing other method.
    // this method is added mainly to cope with bug 433228 (MMC2.0 Can not tab in a SQL table)
    HWND SetFocus();
};




/*+-------------------------------------------------------------------------*
 * CMMCAxHostWindow
 *
 * Simple class that overrides IInPlaceSiteWindowless::CanWindowlessActivate
 * to work around an ATL21 bug.  See comments for HACK_CAN_WINDOWLESS_ACTIVATE
 * for details.
 *--------------------------------------------------------------------------*/

class CMMCAxHostWindow : public CAxHostWindow
{
#ifdef HACK_CAN_WINDOWLESS_ACTIVATE

public:
#ifdef _ATL_HOST_NOLOCK
    typedef CComCreator< CComObjectNoLock< CMMCAxHostWindow > > _CreatorClass;
#else
    DECLARE_POLY_AGGREGATABLE(CMMCAxHostWindow)
#endif

    STDMETHOD(CanWindowlessActivate)()
    {
        return m_bCanWindowlessActivate ? S_OK : E_FAIL /*S_FALSE*/;
    }

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control
    // implements workarround for DISPID_AMBIENT_SHOWGRABHANDLES and DISPID_AMBIENT_SHOWHATCHING
    // the actual bug is in ALT 3.0 (atliface.idl)
    STDMETHOD(Invoke)( DISPID dispIdMember, REFIID riid, LCID lcid, 
                       WORD wFlags, DISPPARAMS FAR* pDispParams, 
                       VARIANT FAR* pVarResult, EXCEPINFO FAR* pExcepInfo, 
                       unsigned int FAR* puArgErr);

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control
    // Since ATL 3.0 does not implement it, we have to do it to make MFC controls happy
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

#if _ATL_VER <= 0x0301
    BEGIN_MSG_MAP(CMMCAxHostWindow)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        CHAIN_MSG_MAP(CAxHostWindow)
    END_MSG_MAP()

    //  We handle focus here specifically because of bogus implementation in ATL 3.0
    //  ATL tests m_bInPlaceActive instead of m_bUIActive.
    //  We need to test this rigorously so that we don't break other snapins.
    //  See bug 433228 (MMC2.0 Can not tab in a SQL table)
    LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled);
#else
    #error The code above was added as fix to bug in ATL 3.0; It needs to be revisited
           // since: 
           // a) the bug may be fixed on newer ATL versions;
           // b) it relies on variables defined in ATL, which may change;
#endif

#endif /* HACK_CAN_WINDOWLESS_ACTIVATE */


public:
    STDMETHOD(QueryService)( REFGUID rsid, REFIID riid, void** ppvObj); // used to supply the default behavior factory

private:
    IElementBehaviorFactoryPtr m_spElementBehaviorFactory;
};



#include "mmcaxwin.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\menubtns.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menubtns.h
//
//              Menu Buttons implementation
//
/////////////////////////////////////////////////////////////////////////////

#ifndef MENUBTNS_H
#define MENUBTNS_H

#include "toolbars.h"       // for CMenuButtonsMgrImpl
#include "tstring.h"

class CMenuBar;

// The (individual) Menu Button.
typedef struct MMC_MENUBUTTON
{
    CMenuButtonNotify* pMenuButtonNotifyClbk; // Represents the IMenuButton object
                                              // exposed to the snapin.
    tstring            lpButtonText;
    tstring            lpStatusText;

    INT                idCommand;            // Unique ID given by the snapin, may not be unique within
                                             // this object as there may be another snapin with same id.
                                             // The pair of (pMenuButtonNotifyClbk, idCommand) is unique.

    INT                nCommandIDFromMenuBar; // The CMenuBar has inserted this button and has
                                              // assigned this command id. CMenuButtonsMgrImpl
                                              // can call CMenuBar methods (other than InsertMenuButton)
                                              // using this id. Also this id will be unique for this button
                                              // in this object.

    bool                m_fShowMenu      : 1; // Represents hidden state set by snapin.

    MMC_MENUBUTTON()
    {
        pMenuButtonNotifyClbk = NULL;
        lpButtonText    = _T("");
        lpStatusText    = _T("");
        m_fShowMenu     = true;
        nCommandIDFromMenuBar = -1;
    }

    void SetShowMenu     (bool b = true)   { m_fShowMenu    = b; }

    bool CanShowMenu     () const          { return (m_fShowMenu); }

} MMC_MENUBUTTON;

// This is the collection of all menu buttons added by snapin
// as well as MMC (Action, View, Favorites).
typedef std::vector<MMC_MENUBUTTON>   MMC_MenuButtonCollection;

// This is the collection of each IMenuButton (objecct) that snapin
// has called Attach on (therefore visible).
typedef std::set<CMenuButtonNotify*>  MMC_AttachedMenuButtons;

class CMenuButtonsMgrImpl : public CMenuButtonsMgr
{
public:
    // CMenuButtonsMgr methods
    virtual SC ScAddMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                               INT idCommand, LPCOLESTR lpButtonText,
                               LPCOLESTR lpStatusText);
    virtual SC ScAttachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk);
    virtual SC ScDetachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk);
    virtual SC ScModifyMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                  INT idCommand, LPCOLESTR lpButtonText,
                                  LPCOLESTR lpStatusText);
    virtual SC ScModifyMenuButtonState(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                       INT idCommand, MMC_BUTTON_STATE nState,
                                       BOOL bState);
    virtual SC ScDisableMenuButtons();
    virtual SC ScToggleMenuButton(BOOL bShow);

public:
    // These methods are used the Child Frame
    SC ScInit(CMainFrame* pMainFrame, CChildFrame* pParentWnd);
    SC ScAddMenuButtonsToMainMenu();

    // Used by CMenuBar to notify a menu button click.
    SC ScNotifyMenuClick(const INT nCommandID, const POINT& pt);

public:
    CMenuButtonsMgrImpl();
    virtual ~CMenuButtonsMgrImpl();

private:
    MMC_MenuButtonCollection::iterator GetMMCMenuButton(
                                 CMenuButtonNotify* pMenuBtnNotifyClbk,
                                 INT idCommand);
    MMC_MenuButtonCollection::iterator GetMMCMenuButton(INT nButtonID);
    bool IsAttached(CMenuButtonNotify* pMenuBtnNotifyClbk);

private:
    // Data members
    CChildFrame*    m_pChildFrame;  // The child frame window.
    CMainFrame*     m_pMainFrame;   // The main frame window.

    // This is the collection of menu buttons.
    MMC_MenuButtonCollection     m_MenuButtons;

    // This is the collection of each IMenuButton seen by the snapin.
    MMC_AttachedMenuButtons      m_AttachedMenuButtons;

    // The Menu Bar object that is the main menu
    CMenuBar*  m_pMenuBar;
};

#endif /* MENUBTNS_H */

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mmcaxwin.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 2000
 *
 *  File:      mmcaxwin.cpp
 *
 *  Contents:  functions for CMMCAxWindow
 *
 *  History:   27-Jan-2000 audriusz    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "mshtml.h"

#include "amc.h"
#include "ocxview.h"
#include "amcview.h"
#include "findview.h"

#ifdef DBG
    CTraceTag tagMMCViewBehavior (TEXT("MMCView Behavior"), TEXT("MMCView Behavior"));
#endif

/***************************************************************************\
 *
 * METHOD:  CMMCAxHostWindow::Invoke
 *
 * PURPOSE: ATL 3.0 has a bug in type library so we owerride this method to
 *          take care of properties which will fail othervise
 *
 * PARAMETERS:
 *    DISPID dispIdMember
 *    REFIID riid
 *    LCID lcid
 *    WORD wFlags
 *    DISPPARAMS FAR* pDispParams
 *    VARIANT FAR* pVarResult
 *    EXCEPINFO FAR* pExcepInfo
 *    unsigned int FAR* puArgErr
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCAxHostWindow::Invoke(  DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT FAR* pVarResult, EXCEPINFO FAR* pExcepInfo, unsigned int FAR* puArgErr)
{
    DECLARE_SC(sc, TEXT("CMMCAxHostWindow::Invoke"));

    // This method is here to override IDispatch::Invoke from IDispatchImpl<IAxWinAmbientDispatch,..>
    // to workaround the ATL30 bug - invalid type library entries for disp ids:
    // DISPID_AMBIENT_SHOWHATCHING and DISPID_AMBIENT_SHOWGRABHANDLES

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control

    if (DISPATCH_PROPERTYGET & wFlags)
    {
		if (dispIdMember == DISPID_AMBIENT_SHOWGRABHANDLES)
		{
			if (pVarResult == NULL)
            {
				sc = SC(E_INVALIDARG);
				return sc.ToHr();
            }
			V_VT(pVarResult) = VT_BOOL;
			sc = get_ShowGrabHandles(&(V_BOOL(pVarResult)));
            return sc.ToHr();
		}
		else if (dispIdMember == DISPID_AMBIENT_SHOWHATCHING)
		{
			if (pVarResult == NULL)
            {
				sc = SC(E_INVALIDARG);
				return sc.ToHr();
            }
			V_VT(pVarResult) = VT_BOOL;
			sc = get_ShowHatching(&(V_BOOL(pVarResult)));
            return sc.ToHr();
		}
    }
    // default: forward to base class
    return CAxHostWindow::Invoke( dispIdMember, riid, lcid, wFlags, pDispParams,
                                  pVarResult, pExcepInfo, puArgErr);
}

/***************************************************************************\
 *
 * METHOD:  CMMCAxHostWindow::OnPosRectChange
 *
 * PURPOSE: ATL does not implement this method, but it's needed to size MFC controls
 *
 * PARAMETERS:
 *    LPCRECT lprcPosRect - rectangle to fit in
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCAxHostWindow::OnPosRectChange(LPCRECT lprcPosRect)
{
    DECLARE_SC(sc, TEXT("CMMCAxHostWindow::OnPosRectChange"));

    // give base class a try (use temp sc to prevent tracing here)
    SC sc_temp = CAxHostWindow::OnPosRectChange(lprcPosRect);

    // we only want to come into the game as the last resort
    if (!(sc_temp == SC(E_NOTIMPL)))
        return sc_temp.ToHr();

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control
    // since ATL does not implement it, we have to do it to make MFC controls happy

    // from MSDN:
    // When the in-place object calls IOleInPlaceSite::OnPosRectChange,
    // the container must call IOleInPlaceObject::SetObjectRects to specify
    // the new position of the in-place window and the ClipRect.
    // Only then does the object resize its window.

    // get pointer to control
    IDispatchPtr spExtendedControl;
    sc= GetExtendedControl(&spExtendedControl);
    if (sc)
        return sc.ToHr();

    // get inplace object interface
    IOleInPlaceObjectPtr spInPlaceObject = spExtendedControl;
    if (spInPlaceObject == NULL)
    {
        sc = SC(E_UNEXPECTED);
        return sc.ToHr();
    }

    sc = spInPlaceObject->SetObjectRects(lprcPosRect,lprcPosRect);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCAxHostWindow::OnSetFocus
 *
 * PURPOSE: Simple override of bogus CAxHostWindow::OnSetFocus
 *          Coppied from ATL 3.0, changed m_bInPlaceActive to m_bUIActive
 *          See bug 433228 (MMC2.0 Can not tab in a SQL table)
 *
 * PARAMETERS:
 *    UINT uMsg
 *    WPARAM wParam
 *    LPARAM lParam
 *    BOOL& bHandled
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
LRESULT CMMCAxHostWindow::OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
{
    m_bHaveFocus = TRUE;
    if (!m_bReleaseAll)
    {
        if (m_spOleObject != NULL && !m_bUIActive)
        {
            CComPtr<IOleClientSite> spClientSite;
            GetControllingUnknown()->QueryInterface(IID_IOleClientSite, (void**)&spClientSite);
            if (spClientSite != NULL)
			{
				Trace (tagOCXActivation, _T("Activating in-place object"));
                HRESULT hr = m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
				Trace (tagOCXActivation, _T("UI activation returned 0x%08x"), hr);
			}
        }
        if(!m_bWindowless && !IsChild(::GetFocus()))
		{
			Trace (tagOCXActivation, _T("Manually setting focus to first child"));
            ::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
		}
    }
	else
		Trace (tagOCXActivation, _T("Skipping UI activation"));

	/*
	 * The code above might cause the focus to be sent elsewhere, which
	 * means this window will receive WM_KILLFOCUS.  CAxHostWindow::OnKillFocus
	 * sets m_bHaveFocus to FALSE.
	 *
	 * If we set bHandled = FALSE here, then ATL will call CAxHostWindow::OnSetFocus,
	 * which will set m_bHaveFocus to TRUE again, even though we've already
	 * lost the focus.  We only want to forward on to CAxHostWindow if
	 * we still have the focus after attempting to activate our hosted control.
	 */
	if (m_bHaveFocus)
	{
		Trace (tagOCXActivation, _T("Forwarding to CAxHostWindow::OnSetFocus"));
		bHandled = FALSE;
	}
	else
		Trace (tagOCXActivation, _T("Skipping CAxHostWindow::OnSetFocus"));

    return 0;
}


/*+-------------------------------------------------------------------------*
 * class CMMCViewBehavior
 *
 *
 * PURPOSE: Allows the current snapin view (ie list, web, or OCX) to be
 *          superimposed onto a view extension. The behavior can be attached
 *          to any tag, and will cause the snapin view to display in the area
 *          occupied by the tag.
 *
 *+-------------------------------------------------------------------------*/
class CMMCViewBehavior :
    public CComObjectRoot,
    public IElementBehavior,
    public IDispatch // used as the event sink
{
typedef CMMCViewBehavior ThisClass;
    UINT m_bCausalityCount;
	// fix to the bug #248351 - ntbug9. 6/25/01	"No List" taskpad displays a list when node selection changes from extended view
	// the script should not force the list to be shown more then once, since, due to the asynchronous nature of the
	// script execution, some of code may be executed late, after the MMC hides the listview.
	// In such case showing the listview is harmful
	bool m_bShowShowListView;

public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IElementBehavior)
        COM_INTERFACE_ENTRY(IDispatch) // NEEDED. See note above
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    // constructor
    CMMCViewBehavior() : m_pAMCView(NULL), m_bCausalityCount(0), m_bShowShowListView(true) {}

    // IElementBehavior
    STDMETHODIMP Detach()                                   {return ScDetach().ToHr();}
    STDMETHODIMP Init(IElementBehaviorSite *pBehaviorSite)  {return ScInit(pBehaviorSite).ToHr();}
    STDMETHODIMP Notify(LONG lEvent,VARIANT *pVar)          {return ScNotify(lEvent).ToHr();}

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(unsigned int *  pctinfo)                                                               {return E_NOTIMPL;}
    STDMETHODIMP GetTypeInfo(unsigned int  iTInfo, LCID  lcid, ITypeInfo **  ppTInfo)                                    {return E_NOTIMPL;}
    STDMETHODIMP GetIDsOfNames( REFIID  riid, OLECHAR **rgszNames, unsigned int  cNames, LCID   lcid, DISPID *  rgDispId){return E_NOTIMPL;}
    STDMETHODIMP Invoke(DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult,
                    EXCEPINFO *pExcepInfo, unsigned int *puArgErr)                                                       {return ScUpdateMMCView().ToHr();}


private:

    /*+-------------------------------------------------------------------------*
     *
     * ScNotify
     *
     * PURPOSE: Handles the IElementBehavior::Notify method.
	 *          When we get the document ready notification we can get the document
	 *          and get the CAMCView window which will be cached for future use.
     *
     * PARAMETERS:
     *    LONG  lEvent :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC  ScNotify(LONG lEvent)
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::ScNotify"));

        // When the whole document is loaded access it to get the CAMCView window.
        if (lEvent == BEHAVIOREVENT_DOCUMENTREADY )
        {
            // get the HTML document from the element
            IDispatchPtr spDispatchDoc;
            sc = m_spElement->get_document(&spDispatchDoc);
            if(sc)
                return sc;

            // QI for the IOleWindow interface
            IOleWindowPtr spOleWindow = spDispatchDoc;

            sc = ScCheckPointers(spOleWindow, E_UNEXPECTED);
            if(sc)
                return sc;

            // Get the IE window and find the ancestor AMCView
            HWND hwnd = NULL;

            sc = spOleWindow->GetWindow(&hwnd);
            if(sc)
                return sc;

            hwnd = FindMMCView(hwnd); // find the ancestor mmcview

            if(hwnd==NULL)
                return (sc = E_UNEXPECTED);

            m_pAMCView = dynamic_cast<CAMCView *>(CWnd::FromHandle(hwnd));

            sc = ScCheckPointers(m_pAMCView); // make sure we found a valid view.
			if (sc)
				return sc;
        }

        sc = ScUpdateMMCView(); // this sets up the view initially

        return sc;
    }


    /*+-------------------------------------------------------------------------*
     *
     * ScInit
     *
     * PURPOSE: Initializes the behavior. Connects the behavior to the onresize
	 *          and onreadystatechange events of the element it is attached to.
	 *          We can talk to the element but cannot access document until we
	 *          get document-ready notification in Notify method.
     *
     * PARAMETERS:
     *    IElementBehaviorSite * pBehaviorSite :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC ScInit(IElementBehaviorSite *pBehaviorSite)
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::Init"));

        sc = ScCheckPointers(pBehaviorSite);
        if(sc)
            return sc;

        sc = pBehaviorSite->GetElement(&m_spElement);
        if(sc)
            return sc;

        IDispatchPtr spDispatch = this; // does the addref

        IHTMLElement2Ptr spElement2 = m_spElement;

        sc = ScCheckPointers(spElement2.GetInterfacePtr(), spDispatch.GetInterfacePtr());
        if(sc)
            return sc;

        
        // set the onresize handler
        sc = spElement2->put_onresize(_variant_t(spDispatch.GetInterfacePtr()));
        if(sc)
            return sc;

        
        // set the onreadystatechange handler
        sc = spElement2->put_onreadystatechange(_variant_t(spDispatch.GetInterfacePtr()));
        if(sc)
            return sc;

        return sc;
    }

    /*+-------------------------------------------------------------------------*
     *
     * ScDetach
     *
     * PURPOSE: Detaches the behavior
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC ScDetach()
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::ScDetach"));

        m_spElement = NULL;
        m_pAMCView  = NULL;

        return sc;
    }


    /*+-------------------------------------------------------------------------*
     * class CCausalityCounter
     * 
     *
     * PURPOSE: used to determine whether a function has resulted in a call back to itself on the same stack
     *
     * USAGE: Initialize with a variable that is set to zero.
     *+-------------------------------------------------------------------------*/
    class CCausalityCounter // 
    {
        UINT & m_bCounter;
    public:
        CCausalityCounter(UINT &bCounter) : m_bCounter(bCounter){++m_bCounter;}
        ~CCausalityCounter() {--m_bCounter;}

        bool HasReentered() 
        {
            return (m_bCounter>1);
        }
    };

    /*+-------------------------------------------------------------------------*
     *
     * ScUpdateMMCView
     *
     * PURPOSE: The callback for all events that the behavior is connected to. This
     *          causes the size of the snapin view to be recomputed and displayed
	 *
	 *          This method is also called by IDispatch::Invoke, which is called for mouse-in,
	 *          mouse-out events. So this method may be called after Detach in which case
	 *          m_pAMCView is NULL which is legal.
	 *
     * PARAMETERS: None
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC ScUpdateMMCView()
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::ScUpdateMMCView"));

        CCausalityCounter causalityCounter(m_bCausalityCount);
        if(causalityCounter.HasReentered())
            return sc; // avoid re-entering the function from itself.

        sc = ScCheckPointers(m_spElement);
        if(sc)
            return sc;

		// See the note above.
		if (! m_pAMCView)
			return sc;

        long offsetTop    = 0;
        long offsetLeft   = 0;
        long offsetHeight = 0;
        long offsetWidth  = 0;

        // get the coordinates of the element
        sc = m_spElement->get_offsetTop(&offsetTop);
        if(sc)
            return sc;

        sc = m_spElement->get_offsetLeft(&offsetLeft);
        if(sc)
            return sc;

        sc = m_spElement->get_offsetHeight(&offsetHeight);
        if(sc)
            return sc;

        sc = m_spElement->get_offsetWidth(&offsetWidth);
        if(sc)
            return sc;

        Trace(tagMMCViewBehavior, TEXT("Top: %d Left: %d Height: %d Width: %d"), offsetTop, offsetLeft, offsetHeight, offsetWidth);

        // set the coordinates. NOTE: replace by a single method call
        sc = m_pAMCView->ScSetViewExtensionFrame(m_bShowShowListView, offsetTop, offsetLeft, offsetTop + offsetHeight /*bottom*/, offsetLeft + offsetWidth /*right*/);
		m_bShowShowListView = false;

        return sc;
    }

    // data members
private:
    IHTMLElementPtr m_spElement;
    CAMCView *      m_pAMCView;

};


/*+-------------------------------------------------------------------------*
 * class CElementBehaviorFactory
 *
 *
 * PURPOSE: Creates instances of the MMCView behavior
 *
 *+-------------------------------------------------------------------------*/
class CElementBehaviorFactory :
    public CComObjectRoot,
    public IElementBehaviorFactory,
    public IObjectSafetyImpl<CElementBehaviorFactory, INTERFACESAFE_FOR_UNTRUSTED_CALLER> // required
{
    typedef CElementBehaviorFactory ThisClass;

public:

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

public: // IElementBehaviorFactory

    STDMETHODIMP FindBehavior(BSTR bstrBehavior, BSTR bstrBehaviorUrl,
                              IElementBehaviorSite *pSite, IElementBehavior **ppBehavior)
    {
        DECLARE_SC(sc, TEXT("CElementBehaviorFactory::FindBehavior"));

        sc = ScCheckPointers(ppBehavior);
        if(sc)
            return sc.ToHr();


        // init out parameter
        *ppBehavior = NULL;

        if((bstrBehavior != NULL) && (wcscmp(bstrBehavior, L"mmcview")==0)) // requested the mmcview behavior
        {
            typedef CComObject<CMMCViewBehavior> t_behavior;

            t_behavior *pBehavior = NULL;
            sc = t_behavior::CreateInstance(&pBehavior);
            if(sc)
                return sc.ToHr();

            *ppBehavior = pBehavior;
            if(!*ppBehavior)
            {
                delete pBehavior;
                return (sc = E_UNEXPECTED).ToHr();
            }

            (*ppBehavior)->AddRef(); // addref for client

            return sc.ToHr();
        }
        return E_FAIL;
    }
};


/*+-------------------------------------------------------------------------*
 *
 * CMMCAxHostWindow::QueryService
 *
 * PURPOSE: If called with SID_SElementBehaviorFactory, returns a behavior
 *          factory that implements the mmcview behavior
 *
 * PARAMETERS:
 *    REFGUID  rsid :
 *    REFIID   riid :
 *    void**   ppvObj :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCAxHostWindow::QueryService( REFGUID rsid, REFIID riid, void** ppvObj)
{
    DECLARE_SC(sc, TEXT("CMMCAxHostWindow::QueryService"));
    typedef CAxHostWindow BC;

    if(rsid==SID_SElementBehaviorFactory)
    {
        if(m_spElementBehaviorFactory==NULL)
        {
            // create the object
            typedef CComObject<CElementBehaviorFactory> t_behaviorFactory;
            t_behaviorFactory *pBehaviorFactory = NULL;

            sc = t_behaviorFactory::CreateInstance(&pBehaviorFactory);
            if(sc)
                return sc.ToHr();

            m_spElementBehaviorFactory = pBehaviorFactory; // does the addref
            if(m_spElementBehaviorFactory==NULL)
            {
                delete pBehaviorFactory;
                return (sc = E_UNEXPECTED).ToHr();
            }
        }

        sc = m_spElementBehaviorFactory->QueryInterface(riid, ppvObj);
        return sc.ToHr();

    }

    HRESULT hr = BC::QueryService(rsid, riid, ppvObj);
    return hr; // do not want errors from BC to be traced
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mmcaxwin.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      mmcaxwin.inl
 *
 *  Contents:  Inline functions for CMMCAxWindow
 *
 *  History:   10-Jan-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef MMCAXWIN_INL_INCLUDED
#define MMCAXWIN_INL_INCLUDED

#ifdef HACK_CAN_WINDOWLESS_ACTIVATE

/*+-------------------------------------------------------------------------*
 * MMCAxCreateControlEx
 *
 * Lifted straight from AtlAxCreateControlEx in atl30.h.  The only
 * difference is that it creates a CMMCAxHostWindow rather than a 
 * CAxHostWindow.
 *--------------------------------------------------------------------------*/

inline HRESULT MMCAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream,
        IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
    AtlAxWinInit();
    HRESULT hr;
    CComPtr<IUnknown> spUnkContainer;
    CComPtr<IUnknown> spUnkControl;

//  hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
    hr = CMMCAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
    if (SUCCEEDED(hr))
    {
        CComPtr<IAxWinHostWindow> pAxWindow;
        spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
        CComBSTR bstrName(lpszName);
        hr = pAxWindow->CreateControlEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink);
    }
    if (ppUnkContainer != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *ppUnkContainer = spUnkContainer.p;
            spUnkContainer.p = NULL;
        }
        else
            *ppUnkContainer = NULL;
    }
    if (ppUnkControl != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
            spUnkControl.p = NULL;
        }
        else
            *ppUnkControl = NULL;
    }
    return hr;
}


/*+-------------------------------------------------------------------------*
 * CMMCAxWindow::AxCreateControl2
 *
 * Simple override of CAxWindowImplT::AxCreateControl2 that calls
 * MMCAxCreateControlEx rather than AtlAxCreateControlEx
 *--------------------------------------------------------------------------*/

inline HRESULT CMMCAxWindow::AxCreateControl2(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
    return MMCAxCreateControlEx(lpszName, hWnd, pStream,ppUnkContainer,ppUnkControl,iidSink,punkSink);
}

#endif /* HACK_CAN_WINDOWLESS_ACTIVATE */

/*+-------------------------------------------------------------------------*
 * CMMCAxWindow::SetFocus
 *
 * Simple override of CAxWindow::SetFocus that handles more special cases
 * NOTE: this is not a virtual method. Invoking on base class pointer will
 * endup in executing other method.
 *--------------------------------------------------------------------------*/

inline HWND CMMCAxWindow::SetFocus()
{
    DECLARE_SC(sc, TEXT("CMMCAxWindow::SetFocus"));

    //  A misbehaving OCX may keep a hidden window in our view instead 
    //  of destroying it when it's not in-place active, so make sure 
    //  the window's visible and enabled before trying to give it focus.
    //  (MFC doesn't check before doing a UIActivate call.)
    HWND hwndControl = ::GetWindow(m_hWnd, GW_CHILD);
    if (!hwndControl || !::IsWindowVisible(hwndControl) || !::IsWindowEnabled(hwndControl))
        return (HWND)NULL;  // do not change anything

    // simply set focus on itselt - msg handlers will do the rest
    return ::SetFocus(m_hWnd);
}

#endif /* MMCAXWIN_INL_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mmcres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by amc.rc
//
#define IDR_MMCOBJ_TYPELIB              1
#define IDR_WEBSINK_TYPELIB             4
#define IDD_LIST_SAVE                   102
#define IDR_MAINFRAME                   128
#define IDR_AMCTYPE                     129
#define IDD_URL_INPUT                   131
#define IDD_ADDSNAPIN                   132
#define IDR_AMCTYPE_USER                157
#define IDB_AMC_NODES16                 158
#define IDD_PROPPAGE_CONSOLE            158
#define IDB_AMC_NODES32                 159
#define IDR_SYSMENU_ADDITIONS           162
#define IDB_SORT                        168
#define IDD_ADDFAVORITE                 170
#define IDC_FAVNAME                     171
#define IDC_FAVTREE                     172
#define IDC_ADDFAVFOLDER                173
#define IDD_NEWFAVFOLDER                174
#define IDC_FAVFOLDER                   175
#define IDD_FAVORGANIZE                 176
#define IDC_FAVDELETE                   177
#define IDC_FAVMOVETO                   178
#define IDC_FAVRENAME                   179
#define IDC_FAVINFO                     180
#define IDD_FAVSELECTFOLDER             183
#define IDC_HAND_INTERNAL               186
#define IDR_AMCTYPE_MDI_USER            192
#define IDR_AMCTYPE_SDI_USER            194
#define IDD_DISK_CLEANUP                199
#define IDD_ArchitecturePicker          200
#define IDD_LIST_SAVE_NEW               201
#define IDB_COMMON_16                   202
#define IDB_COMMON_16_RTL				203
#define IDC_LV_SNAP_INS                 1000
#define IDC_URL_EDIT                    1001
#define IDC_SEL                         1002
#define IDC_CONSOLE_MODE                1022
#define IDC_CONSOLE_MODE_DESCRIPTION    1023
#define IDC_DONTSAVECHANGES             1024
#define IDC_CHANGE_ICON                 1025
#define IDC_CUSTOM_TITLE                1027
#define IDC_CONSOLE_ICON                1028
#define IDC_AllowViewCustomization      1029
#define IDC_DELETE_TEMP_FILES           1031
#define IDC_DISKCLEANUP_DESCRIPTION     1032
#define IDC_DISKCLEANUP_OCCUPIED        1033
#define IDC_DISKCLEANUP_TO_DELETE       1034
#define IDC_ConsoleFileName             1035
#define IDC_SnapinCount64               1036
#define IDC_SnapinCount32               1037
#define IDC_SnapinList64                1038
#define IDC_SnapinList32                1039
#define IDC_64Bit                       1040
#define IDC_32Bit                       1041
#define ID_HELP_HELPTOPICS              12804
#define ID_HELP_SNAPINHELP              12817
#define ID_CONSOLE_ADDREMOVESNAPIN      13201
#define ID_MMC_CUT                      13205
#define ID_MMC_COPY                     13206
#define ID_MMC_PASTE                    13207
#define ID_MMC_RENAME                   13208
#define ID_MMC_REFRESH                  13209
#define ID_MMC_PRINT                    13210
#define ID_MMC_MAXIMIZE                 13211
#define ID_MMC_RESTORE                  13212
#define ID_MMC_NEXT_PANE                13213
#define ID_MMC_PREV_PANE                13214
#define ID_MMC_CONTEXTHELP              13215
#define ID_CONSOLE_PROPERTIES           13220
#define ID_CUSTOMIZE_VIEW               13231
#define ID_MMC_TRACE_DIALOG             13235
#define ID_ACTION_MENU                  13238
#define ID_VIEW_MENU                    13239
#define ID_FAVORITES_MENU               13240
#define ID_SNAPIN_MENU_PLACEHOLDER      13241
#define ID_SNAPIN_ABOUT                 13242
#define ID_FILE_NEW_USER_MODE           13243

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         13243
#define _APS_NEXT_CONTROL_VALUE         1045
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mscparser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      mscparser.cpp
//
//  Contents:  Implementation of the code to upgrade legacy (MMC1.0, MMC1.1 and 
//             MMC1.2) .msc files to the new XML format
//
//  History:   04-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include <stdafx.h>
#include "strtable.h"
#include "stgio.h"
#include "comdbg.h"
#include "mmcdata.h"
#include "mscparser.h"

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScUpgrade
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    LPCTSTR  lpszPathName :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleFile::ScUpgrade(LPCTSTR lpszPathName)
{
    SC                      sc;
    IStoragePtr             spStorage;
    TCHAR                   szTempFile[MAX_PATH];
    DWORD                   dwRet                   = 0;
    
    USES_CONVERSION;

    // short circuit
    return sc;
    
    ASSERT(lpszPathName != NULL && *lpszPathName != 0);
    if (lpszPathName == NULL || *lpszPathName == 0)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }

    // Open the specified file
    sc = OpenDebugStorage(T2OLE((LPTSTR)lpszPathName), STGM_READ|STGM_SHARE_DENY_WRITE, &spStorage);
    if(sc.IsError() || spStorage==NULL)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }

    // get the console file's version
    sc = ScGetFileVersion(spStorage);
    if(sc)
        goto Error;

    // Load the string table.
    sc = ScLoadStringTable(spStorage);
    if(sc)
        goto Error;

    // Load column settings.
    sc = ScLoadColumnSettings(spStorage);
    if(sc)
        goto Error;

    // load the view settings
    sc = ScLoadViewSettings(spStorage);
    if(sc)
        goto Error;

    // load the tree
    sc = ScLoadTree(spStorage);
    if(sc)
        goto Error;

    // load the favorites
    sc = ScLoadFavorites(spStorage);
    if(sc)
        goto Error;

    // load custom data (including the icon)
    sc = ScLoadCustomData(spStorage);
    if(sc)
        goto Error;

    // The LoadAppMode, LoadViews and LoadFrame should be called in that order

    // load the app mode
    sc = ScLoadAppMode(spStorage);
    if(sc)
        goto Error;

    // load the views
    sc = ScLoadViews(spStorage);
    if(sc)
        goto Error;

    // load the frame
    sc = ScLoadFrame(spStorage);
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    //TraceError(TEXT("CConsoleFile::ScUpgrade"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScGetFileVersion
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScGetFileVersion(IStorage* pstgRoot)
{
    static const wchar_t*    AMCSignatureStreamName = L"signature";
    static const long double dOldVersion10          = 0.00000015;   // MMC version 1.0
    static const long double dOldVersion11          = 1.1;          // MMC version 1.1
    static const BYTE        byStreamVersionMagic   = 0xFF;


    SC                      sc;
    ConsoleFileVersion      eFileVer    = FileVer_0100;
    IStreamPtr              spStream;
    int                     nVersion    = 0;
    IStoragePtr             spStorage;

    ASSERT (sizeof(eFileVer) == sizeof(int));
    ASSERT(pstgRoot != NULL);

    // check for a valid pointer
    if (pstgRoot == NULL)
    {
        sc = ScFromMMC(IDS_INVALIDFILE); // TODO: add this IDS.
        goto Error;
    }

    // Open the stream containing the signature
    sc = OpenDebugStream(pstgRoot, AMCSignatureStreamName, STGM_SHARE_EXCLUSIVE | STGM_READ, L"\\signature", &spStream);
    if(sc.IsError() || spStream==NULL)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }

    // read the signature (stream extraction operators will throw
    // _com_error's, so we need an exception block here)
    try
    {
        // MMC v1.2 and later write a marker as the first 
        // byte of the signature stream.
        BYTE byMagic;
        *spStream >> byMagic;

        // if this file was written by v1.2, 
        // read the console file version (int)
        if (byMagic == byStreamVersionMagic)
        {
            *spStream >> nVersion;
            ASSERT (nVersion == FileVer_0120);
        }
        // Otherwise, the file was written by v1.0 or v1.1.
        // Back up to re-read the marker byte, and read the old-style 
        // file version (long double), then map it to a new-style version
        else
        {
            LARGE_INTEGER pos = {0, 0};
            spStream->Seek (pos, STREAM_SEEK_SET, NULL);

            long double dVersion;
            *spStream >> dVersion;

            // v1.1?
            if (dVersion == dOldVersion11)
                nVersion = FileVer_0110;

            // v1.0?
            else if (dVersion == dOldVersion10)
            {
                // If we got a v1.0 signature, we still may have a v1.1 file.
                // There was a period of time where MMC v1.1 wrote a v1.0
                // signature, but the file format had in fact changed.  We
                // can determine this by checking the \FrameData stream in 
                // the file.  If the first DWORD in the \FrameData stream is
                // sizeof(WINDOWPLACEMENT), we have a true v1.0 file, otherwise
                // it's a funky v1.1 file.

                IStreamPtr spFrameDataStm;

                sc = OpenDebugStream (pstgRoot, L"FrameData", STGM_SHARE_EXCLUSIVE | STGM_READ,
                                      &spFrameDataStm);
                if(sc)
                    goto Error;

                DWORD dw;
                *spFrameDataStm >> dw;

                if (dw == sizeof (WINDOWPLACEMENT))
                    nVersion = FileVer_0100;
                else
                    nVersion = FileVer_0110;
            }
            // unexpected version
            else
            {
                ASSERT (false && "Unexpected old-style signature");
                sc = E_UNEXPECTED;
                goto Error;
            }
        }
    }
    catch (_com_error& err)
    {
        sc = err.Error();
        goto Error;
    }

    // make sure the version number is valid.
    if(IsValidFileVersion(eFileVer))
    {
        sc = ScFromMMC(IDS_InvalidVersion); // TODO: add this IDS
        goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CConsoleFile::ScGetFileVersion"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScLoadStringTable
 *
 * PURPOSE: Reads in the string table for an .msc file.
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScLoadStringTable(IStorage* pstgRoot)
{
    SC      sc;

    static const wchar_t* AMCStringTableStorageName = L"String Table";

    /*
     * open the string table storage
     */
    IStoragePtr spStringTableStg;
    sc = OpenDebugStorage (pstgRoot, AMCStringTableStorageName,
                                        STGM_SHARE_EXCLUSIVE | STGM_READ, 
                                        &spStringTableStg);


    /*
     * If there's no string table, things are OK.  We allow this so
     * we can continue to open older console files.
     */
    if (sc == SC(STG_E_FILENOTFOUND) )
        return (true);

    if(sc)
        goto Error;

    /*
     * read the string table from the storage
     */
    try
    {
        *spStringTableStg >> *m_pStringTable;
    }
    catch (_com_error& err)
    {
        sc = err.Error();
        ASSERT (false && "Caught _com_error");
        goto Error;
    }


Cleanup:
    return sc;
Error:
    TraceError(TEXT("CConsoleFile::ScLoadStringTable"), sc);
    goto Cleanup;
}


SC  
CConsoleFile::ScLoadFrame(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadViews(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadAppMode(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScLoadColumnSettings
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScLoadColumnSettings(IStorage* pstgRoot)
{
    static const wchar_t* AMCColumnDataStreamName   = L"ColumnData";

    SC      sc;
    
    IPersistStreamPtr spPersistStreamColumnData; // TODO: create this object!

    IStreamPtr spStream;
    sc = OpenDebugStream (pstgRoot, AMCColumnDataStreamName,
                          STGM_SHARE_EXCLUSIVE | STGM_READ, &spStream);
    if (sc)
        goto Error;

    if (NULL == spPersistStreamColumnData)
    {
        sc = E_POINTER;
        goto Error;
    }
        
    sc = spPersistStreamColumnData->Load(spStream); // $CHANGE to use Load(spColumnData, spStream).
    if(sc)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }
    
Cleanup:
    return sc;
Error: 
    TraceError(TEXT("CConsoleFile::ScLoadColumnSettings"), sc);
    goto Cleanup;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScLoadViewSettings
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScLoadViewSettings(IStorage* pstgRoot)
{
    static const wchar_t* AMCViewSettingDataStreamName = L"ViewSettingData"; // View settings data stream

    SC      sc;
    IPersistStreamPtr spPersistStreamViewSettingData; // TODO: create this object!
    
    IStreamPtr spStream;
    sc = OpenDebugStream (pstgRoot, AMCViewSettingDataStreamName, 
                          STGM_SHARE_EXCLUSIVE | STGM_READ, &spStream);

    if (sc)
        goto Error;

    if (NULL == spPersistStreamViewSettingData)
    {
        sc = E_POINTER;
        goto Error;
    }
        
    sc = spPersistStreamViewSettingData->Load(spStream); // $CHANGE to use Load(spPersistStreamViewSettingData, spStream).
    if(sc)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }
    
Cleanup:
    return sc;
Error: 
    TraceError(TEXT("CConsoleFile::ScLoadViewSettings"), sc);
    goto Cleanup;
}

SC  
CConsoleFile::ScLoadTree(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadFavorites(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadCustomData(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\mscparser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      mscparser.h
//
//  Contents:  Header of the code to upgrade legacy (MMC1.0, MMC1.1 and 
//             MMC1.2) .msc files to the new XML format
//
//  History:   04-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------

class CConsoleFile
{
public:
    SC  ScUpgrade(LPCTSTR lpszPathName);    // upgrade the file to the latest version.

private: // conversion and other routines
    SC  ScGetFileVersion        (IStorage* pstgRoot);
    SC  ScLoadAppMode           (IStorage* pstgRoot);
    SC  ScLoadStringTable       (IStorage* pstgRoot);
    SC  ScLoadColumnSettings    (IStorage* pstgRoot);
    SC  ScLoadViewSettings      (IStorage* pstgRoot);
    SC  ScLoadViews             (IStorage* pstgRoot);
    SC  ScLoadFrame             (IStorage* pstgRoot);
    SC  ScLoadTree              (IStorage* pstgRoot);
    SC  ScLoadFavorites         (IStorage* pstgRoot);
    SC  ScLoadCustomData        (IStorage* pstgRoot);

private:
    CMasterStringTable *m_pStringTable;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\msaastub.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      msaastub.h
 *
 *  Contents:  Provides stub implementations of OLEACC functions that
 * 			   aren't available on backlevel OS's (Win95, NT4 SP3).
 *             These implementations were copied from msaa.h, which
 *             is no longer supported.
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

// UnDefine these names so we can re-define them below.
#undef AccessibleObjectFromWindow
#undef LresultFromObject

//
// Define COMPILE_MSAA_STUBS to compile the stubs;
// otherwise, you get the declarations.
//
// Exactly one source must include this with COMPILE_MSAA_STUBS defined.
//
#ifdef COMPILE_MSAA_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

#ifndef MSAA_FNS_DEFINED
// OLEACC
HRESULT         (WINAPI* g_pfnAccessibleObjectFromWindow)(HWND,DWORD,REFIID,void **) = NULL;
LRESULT         (WINAPI* g_pfnLresultFromObject)(REFIID,WPARAM,LPUNKNOWN) = NULL;
// STATUS
BOOL            g_fMSAAInitDone = FALSE;

#endif

//-----------------------------------------------------------------------------
// This is the function that checks that all the required API's exist, and
// then allows apps that include this file to call the real functions if they
// exist, or the 'stubs' if they do not. This function is only called by the
// stub functions - client code never needs to call this.
//-----------------------------------------------------------------------------
BOOL InitMSAAStubs(void)
{
    HMODULE hOleacc;

    if (g_fMSAAInitDone)
    {
        return g_pfnLresultFromObject != NULL;
    }

    hOleacc = GetModuleHandle(TEXT("OLEACC.DLL"));
    if (!hOleacc)
        hOleacc = LoadLibrary(TEXT("OLEACC.DLL"));

    if ((hOleacc) &&
        (*(FARPROC*)&g_pfnAccessibleObjectFromWindow = GetProcAddress(hOleacc,"AccessibleObjectFromWindow")) &&
        (*(FARPROC*)&g_pfnLresultFromObject          = GetProcAddress(hOleacc,"LresultFromObject")))
    {
        g_fMSAAInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnAccessibleObjectFromWindow = NULL;
        g_pfnLresultFromObject = NULL;

        g_fMSAAInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// Fake implementations of MSAA APIs that return error codes.
// No special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Fake implementation of AccessibleObjectFromWindow. Returns E_NOTIMPL if the
// real API is not present.
//-----------------------------------------------------------------------------
HRESULT WINAPI xAccessibleObjectFromWindow (HWND hWnd,DWORD dwID,REFIID riidInterface,
                                            void ** ppvObject)
{
    if (InitMSAAStubs())
        return g_pfnAccessibleObjectFromWindow (hWnd,dwID,riidInterface,ppvObject);

    return (E_NOTIMPL);
}

//-----------------------------------------------------------------------------
// Fake implementation of LresultFromObject. Returns E_NOTIMPL if the real API
// is not present.
//-----------------------------------------------------------------------------
LRESULT WINAPI xLresultFromObject (REFIID riidInterface,WPARAM wParam,LPUNKNOWN pUnk)
{
    if (InitMSAAStubs())
        return g_pfnLresultFromObject (riidInterface,wParam,pUnk);

    return (E_NOTIMPL);
}

#undef COMPILE_MSAA_STUBS

#else   // COMPILE_MSAA_STUBS

extern HRESULT WINAPI       xAccessibleObjectFromWindow (HWND hWnd,
                                                         DWORD dwID,
                                                         REFIID riidInterface,
                                                         void ** ppvObject);
extern LRESULT WINAPI       xLresultFromObject (REFIID riidInterface,
                                                WPARAM wParam,
                                                LPUNKNOWN pUnk);

#endif  // COMPILE_MSAA_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define AccessibleObjectFromWindow  xAccessibleObjectFromWindow
#define LresultFromObject           xLresultFromObject

#ifdef __cplusplus
}
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\ocxview.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ocxview.cpp
 *
 *  Contents:  Implementation file for COCXHostView
 *
 *  History:   12-Dec-97 JeffRo     Created
 *
 *  This class is required to host OCX controls to fix focus problems.
 *  The MDI child frame window keeps track of its currently active view.
 *  When we're hosting OCX controls without this view and the OCX get the
 *  focus, the MDI child frame thinks the previously active view, usually
 *  the scope tree, is still the active view.  So if the user Alt-Tabs
 *  away from MMC and back, for instance, the scope tree will get the focus
 *  even though the OCX had the focus before.
 *
 *  We need this view to represent the OCX, which isn't a view, to the MDI
 *  child frame.
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "ocxview.h"
#include "amcview.h"


#ifdef DBG
CTraceTag  tagOCXActivation     (_T("OCX"), _T("Activation"));
CTraceTag  tagOCXTranslateAccel (_T("OCX"), _T("TranslateAccelerator"));
#endif


/*+-------------------------------------------------------------------------*
 * class COCXCtrlWrapper
 *
 *
 * PURPOSE: Maintains a pointer to a CMMCAxWindow as well as to the OCX in
 *          the window.
 *
 *+-------------------------------------------------------------------------*/
class COCXCtrlWrapper : public CComObjectRoot, public IUnknown
{
    typedef COCXCtrlWrapper ThisClass;
public:
    COCXCtrlWrapper() : m_pOCXWindow(NULL)
    {
    }

    ~COCXCtrlWrapper()
    {
        if(m_pOCXWindow && m_pOCXWindow->IsWindow())
            m_pOCXWindow->DestroyWindow();

        delete m_pOCXWindow;
    }

    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IUnknown)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass);

    SC  ScInitialize(CMMCAxWindow *pWindowOCX, IUnknown *pUnkCtrl) // initialize with the window that hosts the control
    {
        DECLARE_SC(sc, TEXT("COCXCtrlWrapper::ScInitialize"));
        sc = ScCheckPointers(pWindowOCX, pUnkCtrl);
        if(sc)
            return sc;

        m_pOCXWindow = pWindowOCX;
        m_spUnkCtrl  = pUnkCtrl;
        return sc;
    }

    SC  ScGetControl(IUnknown **ppUnkCtrl)
    {
        DECLARE_SC(sc, TEXT("COCXCtrlWrapper::ScGetData"));
        sc = ScCheckPointers(ppUnkCtrl);
        if(sc)
            return sc;

        *ppUnkCtrl   = m_spUnkCtrl;
        if(*ppUnkCtrl)
            (*ppUnkCtrl)->AddRef();
        return sc;
    }

   CMMCAxWindow *       GetAxWindow() {return m_pOCXWindow;}

private:
   CMMCAxWindow *       m_pOCXWindow; // handle to the window.
   CComPtr<IUnknown>    m_spUnkCtrl; // the IUnknown of the control
};



/////////////////////////////////////////////////////////////////////////////
// COCXHostView

IMPLEMENT_DYNCREATE(COCXHostView, CView)

COCXHostView::COCXHostView()  : m_pAMCView(NULL)
{
}

COCXHostView::~COCXHostView()
{
    m_pAMCView = NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::PreCreateWindow
 *
 * PURPOSE: Adds the WS_CLIPCHILDREN bit. This prevents the host window
 *          from overwriting the OCX.
 *
 * PARAMETERS:
 *    CREATESTRUCT& cs :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL
COCXHostView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |=  WS_CLIPCHILDREN;
    // give base class a chance to do own job
    BOOL bOK = (CView::PreCreateWindow(cs));

    // register view class
    LPCTSTR pszViewClassName = g_szOCXViewWndClassName;

    // try to register window class which does not cause the repaint
    // on resizing (do it only once)
    static bool bClassRegistered = false;
    if ( !bClassRegistered )
    {
        WNDCLASS wc;
        if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
        {
            // Clear the H and V REDRAW flags
            wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
            wc.lpszClassName = pszViewClassName;
            // Register this new class;
            bClassRegistered = AfxRegisterClass(&wc);
        }
    }

    // change window class to one which does not cause the repaint
    // on resizing if we successfully registered such
    if ( bClassRegistered )
        cs.lpszClass = pszViewClassName;

    return bOK;
}


/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::GetAxWindow
 *
 * PURPOSE: Returns a pointer to the current AxWindow.
 *
 * RETURNS:
 *    CMMCAxWindow *
 *
 *+-------------------------------------------------------------------------*/
CMMCAxWindow *
COCXHostView::GetAxWindow()
{
    COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>(m_spUnkCtrlWrapper.GetInterfacePtr());
    if(!pOCXCtrlWrapper)
        return (NULL);

    return pOCXCtrlWrapper->GetAxWindow();
}

CAMCView *
COCXHostView::GetAMCView()
{
    return m_pAMCView;
}


BEGIN_MESSAGE_MAP(COCXHostView, CView)
    //{{AFX_MSG_MAP(COCXHostView)
    ON_WM_SIZE()
    ON_WM_SETFOCUS()
    ON_WM_MOUSEACTIVATE()
    ON_WM_SETTINGCHANGE()
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COCXHostView drawing

void COCXHostView::OnDraw(CDC* pDC)
{
    // this view should always be totally obscured by the OCX it is hosting
}

/////////////////////////////////////////////////////////////////////////////
// COCXHostView diagnostics

#ifdef _DEBUG
void COCXHostView::AssertValid() const
{
    CView::AssertValid();
}

void COCXHostView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COCXHostView message handlers
void COCXHostView::OnSize(UINT nType, int cx, int cy)
{
    ASSERT_VALID (this);
    CView::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
    {
        if(GetAxWindow() != NULL)
            GetAxWindow()->MoveWindow (0, 0, cx, cy, FALSE /*bRepaint*/);
    }

}

void COCXHostView::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	SetAmbientFont (NULL);

    CView::OnSettingChange(uFlags, lpszSection);

    if(GetAxWindow() != NULL)
        GetAxWindow()->SendMessage (WM_SETTINGCHANGE, uFlags, (LPARAM) lpszSection);
}


void COCXHostView::OnSetFocus(CWnd* pOldWnd)
{
    DECLARE_SC(sc, TEXT("COCXHostView::OnSetFocus"));

    ASSERT_VALID (this);

    // delegate the focus to the control we're hosting, if we have one
    if(GetAxWindow() != NULL)
       GetAxWindow()->SetFocus();

    // check if someone cared to take the focus.
    // default handling else.
    if (this == GetFocus())
    {
        CView::OnSetFocus (pOldWnd);
    }
}

int COCXHostView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
    /*---------------------------------------------------------*/
    /* this code came from CView::OnMouseActivate; we do it    */
    /* here to bypass sending WM_MOUSEACTIVATE on the the      */
    /* parent window, avoiding focus churn in the parent frame */
    /*---------------------------------------------------------*/

    CFrameWnd* pParentFrame = GetParentFrame();
    if (pParentFrame != NULL)
    {
        // eat it if this will cause activation
        ASSERT(pParentFrame == pDesktopWnd || pDesktopWnd->IsChild(pParentFrame));

        // either re-activate the current view, or set this view to be active
        CView* pView = pParentFrame->GetActiveView();
        HWND hWndFocus = ::GetFocus();
        if (pView == this &&
            m_hWnd != hWndFocus && !::IsChild(m_hWnd, hWndFocus))
        {
            // re-activate this view
            OnActivateView(TRUE, this, this);
        }
        else
        {
            // activate this view
            pParentFrame->SetActiveView(this);
        }
    }
    return (MA_ACTIVATE);
}



BOOL COCXHostView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (CView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view didn't handle it, give parent view a chance
    CWnd*   pParentView = GetParent ();

    if ((pParentView != NULL) &&
            pParentView->IsKindOf (RUNTIME_CLASS (CAMCView)) &&
            pParentView->OnCmdMsg (nID, nCode, pExtra, pHandlerInfo))
        return (TRUE);

    // not handled
    return FALSE;
}

void COCXHostView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    DECLARE_SC(sc, TEXT("COCXHostView::OnActivateView"));

    CView::OnActivateView(bActivate,pActivateView,pDeactiveView);

    // If pActivateView and pDeactiveView are same then this app has lost
    // or gained focus without changing the active view within the app.
    // So do nothing.
    if (pActivateView == pDeactiveView)
        return;

    if (bActivate)
    {
        sc = ScFireEvent(COCXHostActivationObserver::ScOnOCXHostActivated);
        if (sc)
            sc.TraceAndClear();
    }
    else
    /*
     * If this view's no longer active, then the in-place object should
     * no longer be UI active.  This is important for the WebBrowser control
     * because if you move from one "Link to Web Address" node to another, or
     * from one taskpad to another, it won't allow tabbing to links on the
     * new hosted page if it's not deactivated and reactivated in the
     * appropriate sequence.
     */
    {
        IOleInPlaceObjectPtr spOleIPObj = GetIUnknown();

        /*
         * app hack for SQL snapin. Do not UIDeactivate the DaVinci control.
         * See bugs 175586, 175756, 193673 & 258109.
         */
        CAMCView *pAMCView = GetAMCView();
        sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
        if (sc)
            return;

        SViewData *pViewData = pAMCView->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return;

        // If DaVinci control do not UIDeactivate.
        LPCOLESTR lpszOCXClsid = pViewData->GetOCX();
        if ( (_wcsicmp(lpszOCXClsid, L"{464EE255-FDC7-11D2-9743-00105A994F8D}") == 0) ||
			 (_wcsicmp(lpszOCXClsid, L"{97240642-F896-11D0-B255-006097C68E81}") == 0) )
            return;
        /*
         * app hack for SQL snapin ends here.
         */

        if (spOleIPObj != NULL)
        {
            Trace (tagOCXActivation, _T("Deactivating in-place object"));
            spOleIPObj->UIDeactivate();
        }
        else
            Trace (tagOCXActivation, _T("No in-place object to deactivate"));
    }
}

int COCXHostView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // initialize the AxWin class just once.
    static bool bIsAxWinInitialized = false;
    if(!bIsAxWinInitialized)
    {
        AtlAxWinInit();
        bIsAxWinInitialized = true;
    }

    // get a pointer to the AMCView.
    m_pAMCView = dynamic_cast<CAMCView*>(GetParent());

    return 0;
}

LPUNKNOWN COCXHostView::GetIUnknown(void)
{
    DECLARE_SC(sc, TEXT("COCXHostView::GetIUnknown"));

    COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>((IUnknown *)m_spUnkCtrlWrapper);
    if(!pOCXCtrlWrapper)
    {
        sc = E_UNEXPECTED;
        return NULL;
    }

    IUnknownPtr spUnkCtrl;
    sc = pOCXCtrlWrapper->ScGetControl(&spUnkCtrl);
    if(sc)
        return NULL;

    return (LPUNKNOWN)spUnkCtrl;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScSetControl
 *
 * PURPOSE: Hosts the specified control in the OCX view. Delegates to one of
 *          the two other overloaded versions of this function.
 *
 * PARAMETERS:
 *    HNODE           hNode :           The node that owns the view.
 *    CResultViewType& rvt:             The result view information
 *    INodeCallback * pNodeCallback :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScSetControl(HNODE hNode, CResultViewType& rvt, INodeCallback *pNodeCallback)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScSetControl"));
    USES_CONVERSION;

    // make sure that we're trying to set up the right type of view.
    if(rvt.GetType() != MMC_VIEW_TYPE_OCX)
        return E_UNEXPECTED;

    // either BOTH rvt.IsPersistableViewDescriptionValid() and rvt.GetOCXUnknown() should be valid (the GetResultViewType2 case)
    // or     BOTH should be invalid and just GetOCX() should be valid.

    if(rvt.IsPersistableViewDescriptionValid() && (rvt.GetOCXUnknown() != NULL) )
    {
        // the GetResultViewType2 case
        sc = ScSetControl1(hNode, rvt.GetOCXUnknown(), rvt.GetOCXOptions(), pNodeCallback);
        if(sc)
            return sc;
    }
    else if(rvt.GetOCX() != NULL)
    {
        sc = ScSetControl2(hNode, rvt.GetOCX(),        rvt.GetOCXOptions(), pNodeCallback);
        if(sc)
            return sc;
    }
    else
    {
        // should never happen.
        return (sc = E_UNEXPECTED);
    }


    // must have a legal Ax Window at this point.
    sc = ScCheckPointers(GetAxWindow());
    if(sc)
        return sc;


    // the OCX should fill the entirety of the OCX host view
    CRect   rectHost;
    GetClientRect (rectHost);
    GetAxWindow()->SetWindowPos(HWND_TOP, rectHost.left, rectHost.top, rectHost.Width(), rectHost.Height(), SWP_NOACTIVATE | SWP_SHOWWINDOW);

    return sc;

}


/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScSetControl1
 *
 * PURPOSE: Hosts the control specified by pUnkCtrl in the OCX view. Takes
 *          care of caching the control
 *
 * PARAMETERS:
 *    HNODE           hNode :
 *    LPUNKNOWN       pUnkCtrl :
 *    DWORD           dwOCXOptions :
 *    INodeCallback * pNodeCallback :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScSetControl1(HNODE hNode, LPUNKNOWN pUnkCtrl, DWORD dwOCXOptions, INodeCallback *pNodeCallback)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScSetControl1"));

    // validate parameters.
    sc = ScCheckPointers((void *)hNode, pUnkCtrl, pNodeCallback);
    if(sc)
        return sc;

    CComPtr<IUnknown> spUnkCtrl;

    // 1. Hide existing window, if any.
    sc = ScHideWindow();
    if(sc)
        return sc;

    // 2. Get a cached window if one exists - NOTE that in this overload we do not look at RVTI_OCX_OPTIONS_CACHE_OCX at this point.
    sc = pNodeCallback->GetControl(hNode, pUnkCtrl, &m_spUnkCtrlWrapper);  // the overloaded form of GetControl
    if (sc)
        return sc;

    // 3. if no cached window, create one.
    if(m_spUnkCtrlWrapper == NULL) /*no cached window, create one*/
    {
        CMMCAxWindow * pWndAx = NULL;

        sc = ScCreateAxWindow(pWndAx);
        if(sc)
            return sc;

        CComPtr<IUnknown> spUnkContainer;

        // attach the container to the AxWindow
        sc = pWndAx->AttachControl(pUnkCtrl, &spUnkContainer);
        if(sc)
            return sc;


        // create a wrapper for the control
        CComObject<COCXCtrlWrapper> *pOCXCtrlWrapper = NULL;
        sc = CComObject<COCXCtrlWrapper>::CreateInstance(&pOCXCtrlWrapper);
        if(sc)
            return sc;

        spUnkCtrl = pUnkCtrl;

        // initialize the wrapper.
        // The pointer to the control and the CMMCAxWindow is now owned by the wrapper.
        sc = pOCXCtrlWrapper->ScInitialize(pWndAx, spUnkCtrl);
        if(sc)
            return sc;

        m_spUnkCtrlWrapper = pOCXCtrlWrapper; // does the addref.


        // cache only if the snapin asked us to. NOTE that this logic is different from the other version of SetControl
        if(dwOCXOptions &  RVTI_OCX_OPTIONS_CACHE_OCX)
        {
            // This is cached by the static node and used for all nodes of the snapin.
            sc = pNodeCallback->SetControl(hNode, pUnkCtrl, m_spUnkCtrlWrapper); // this call passes the wrapper
            if(sc)
                return sc;
        }

        // Do not send MMCN_INITOCX, the snapin created this control it should have initialized it.
    }
    else
    {
        // The next call sets m_spUnkCtrlWrapper, which is used to get a pointer to the Ax window.
        COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>((IUnknown *)m_spUnkCtrlWrapper);
        if(!pOCXCtrlWrapper)
            return (sc = E_UNEXPECTED); // this should never happen.

        sc = pOCXCtrlWrapper->ScGetControl(&spUnkCtrl);
        if(sc)
            return sc;

        sc = ScCheckPointers(GetAxWindow(), (LPUNKNOWN)spUnkCtrl);
        if(sc)
            return sc;

        // un-hide the window.
        GetAxWindow()->ShowWindow(SW_SHOWNORMAL);

    }


    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScSetControl2
 *
 * PURPOSE: Hosts the specified control in the OCX view. This is the
 *          OCX returned by GetResultViewType. Also takes care of
 *          caching the control if needed and sending the MMCN_INITOCX
 *          notification to snap-ins. The caching is done by hiding the
 *          OCX window and passing nodemgr a COM object that holds a pointer
 *          to the window as well as the control. The nodemgr side determines
 *          whether or not to cache the control. If the control is not
 *          cached, nodemgr merely releases the object passed to it.
 *
 * PARAMETERS:
 *    HNODE           hNode :
 *    LPCWSTR         szOCXClsid :
 *    DWORD           dwOCXOptions :
 *    INodeCallback * pNodeCallback :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScSetControl2(HNODE hNode, LPCWSTR szOCXClsid, DWORD dwOCXOptions, INodeCallback *pNodeCallback)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScSetControl2"));

    // validate parameters.
    sc = ScCheckPointers((void *)hNode, szOCXClsid, pNodeCallback);
    if(sc)
        return sc;

    // create the OCX if needed
    CLSID clsid;
    sc = CLSIDFromString (const_cast<LPWSTR>(szOCXClsid), &clsid);
    if(sc)
        return sc;

    CComPtr<IUnknown> spUnkCtrl;

    sc = ScHideWindow();
    if(sc)
        return sc;

    // check whether there is a cached control for this node.
    if (dwOCXOptions &  RVTI_OCX_OPTIONS_CACHE_OCX)
    {
        sc = pNodeCallback->GetControl(hNode, clsid, &m_spUnkCtrlWrapper);
        if (sc)
            return sc;
    }

    // nope, create a control and set this control for the node.
    if (m_spUnkCtrlWrapper == NULL)
    {
        CMMCAxWindow * pWndAx = NULL;

        sc = ScCreateAxWindow(pWndAx);
        if(sc)
            return sc;

        sc = pWndAx->CreateControlEx(szOCXClsid, NULL /*pStream*/,
                                            NULL /*ppUnkContainer*/, &spUnkCtrl);
        if(sc)
            return sc;


        // spUnkCtrl should be valid at this point.
        sc = ScCheckPointers(spUnkCtrl);
        if(sc)
            return sc;

        CComObject<COCXCtrlWrapper> *pOCXCtrlWrapper = NULL;
        sc = CComObject<COCXCtrlWrapper>::CreateInstance(&pOCXCtrlWrapper);
        if(sc)
            return sc;

        sc = ScCheckPointers(pOCXCtrlWrapper);
        if(sc)
            return sc;

        // initialize the wrapper.
        // The pointer to the control and the CMMCAxWindow is now owned by the wrapper.
        sc = pOCXCtrlWrapper->ScInitialize(pWndAx, spUnkCtrl);
        if(sc)
            return sc;

        m_spUnkCtrlWrapper = pOCXCtrlWrapper; // does the addref.

        // This is cached by the static node and used for all nodes of the snapin.
        if (dwOCXOptions &  RVTI_OCX_OPTIONS_CACHE_OCX)
        {
            sc = pNodeCallback->SetControl(hNode, clsid, m_spUnkCtrlWrapper); // this call passes the wrapper
            if(sc)
                return sc;
        }

        // send the MMCN_INITOCX notification.
        sc = pNodeCallback->InitOCX(hNode, spUnkCtrl); // this passes the actual IUnknown of the control.
        if(sc)
            return sc;
    }
    else
    {
        // The next call sets m_spUnkCtrlWrapper, which is used to get a pointer to the Ax window.
        COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>((IUnknown *)m_spUnkCtrlWrapper);
        if(!pOCXCtrlWrapper)
            return (sc = E_UNEXPECTED); // this should never happen.

        sc = pOCXCtrlWrapper->ScGetControl(&spUnkCtrl);
        if(sc)
            return sc;

        sc = ScCheckPointers(GetAxWindow(), (LPUNKNOWN)spUnkCtrl);
        if(sc)
            return sc;

        // un-hide the window.
        GetAxWindow()->ShowWindow(SW_SHOWNORMAL);

    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScHideWindow
 *
 * PURPOSE: Hides the existing window, if any.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScHideWindow()
{
    DECLARE_SC(sc, TEXT("COCXCtrlWrapper::ScHideWindow"));

    // if there is an existing window, hide it.
    if(GetAxWindow())
    {
        GetAxWindow()->ShowWindow(SW_HIDE);
        m_spUnkCtrlWrapper.Release(); // this deletes the unneeded window if the reference count is zero.
    }


    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScCreateAxWindow
 *
 * PURPOSE: Creates a new Ax window
 *
 * PARAMETERS:
 *    PMMCAXWINDOW  pWndAx :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScCreateAxWindow(PMMCAXWINDOW &pWndAx)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScCreateAxWindow"));

    // create a new window
    pWndAx = new CMMCAxWindow;
    if(!pWndAx)
        return (sc = E_OUTOFMEMORY);


    // create the OCX host window
    RECT rcClient;
    GetClientRect(&rcClient);
    HWND hwndAx = pWndAx->Create(m_hWnd, rcClient, _T(""), (WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS) );

    if (hwndAx == NULL)
    {
        sc.FromLastError();
        return (sc);
    }

    /*
     * Bug 451981:  By default, the ATL OCX host window supports hosting
     * windowless controls.  This differs from the MMC 1.2 implementation
     * of the OCX host window (which used MFC), which did not.  Some controls
     * (e.g. Disk Defragmenter OCX) claim to support windowless instantiation
     * but do not.
     *
     * For compatibility, we must only instantiate result pane OCX's as
     * windowed controls.
     */
    CComPtr<IAxWinAmbientDispatch> spHostDispatch;
    sc = pWndAx->QueryHost(IID_IAxWinAmbientDispatch, (void**)&spHostDispatch);
    if (sc)
        sc.Clear();     // ignore this failure
    else
	{
        spHostDispatch->put_AllowWindowlessActivation (VARIANT_FALSE);  // disallow windowless activation
		SetAmbientFont (spHostDispatch);
	}

    return sc;
}


void COCXHostView::OnDestroy()
{
    CView::OnDestroy();

    if(GetAxWindow())
        GetAxWindow()->DestroyWindow();
}


/*+-------------------------------------------------------------------------*
 * COCXHostView::SetAmbientFont
 *
 * This function sets the font that any OCX that uses the DISPID_AMBIENT_FONT
 * ambient property will inherit.
 *--------------------------------------------------------------------------*/

void COCXHostView::SetAmbientFont (IAxWinAmbientDispatch* pHostDispatch)
{
	DECLARE_SC (sc, _T("COCXHostView::SetAmbientFont"));
    CComPtr<IAxWinAmbientDispatch> spHostDispatch;

	/*
	 * no host dispatch interface supplied?  get it from the AxWindow
	 */
	if (pHostDispatch == NULL)
	{
		CMMCAxWindow* pWndAx = GetAxWindow();
		if (pWndAx == NULL)
			return;

		sc = pWndAx->QueryHost(IID_IAxWinAmbientDispatch, (void**)&spHostDispatch);
		if (sc)
			return;

		pHostDispatch = spHostDispatch;
		sc = ScCheckPointers (pHostDispatch, E_UNEXPECTED);
		if (sc)
			return;
	}

	/*
	 * get the icon title font
	 */
    LOGFONT lf;
    SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);

	/*
	 * get the desktop resolution
	 */
	CWindowDC dcDesktop (CWnd::GetDesktopWindow());
	int ppi = dcDesktop.GetDeviceCaps (LOGPIXELSY);
	long lfHeight = (lf.lfHeight >= 0) ? lf.lfHeight : -lf.lfHeight;

	/*
	 * create an IFontDisp interface around the icon title font
	 */
	USES_CONVERSION;
	FONTDESC fd;
	fd.cbSizeofstruct = sizeof (fd);
	fd.lpstrName      = T2OLE (lf.lfFaceName);
	fd.sWeight        = (short) lf.lfWeight;
	fd.sCharset       = lf.lfCharSet;
	fd.fItalic        = lf.lfItalic;
	fd.fUnderline     = lf.lfUnderline;
	fd.fStrikethrough = lf.lfStrikeOut;
	fd.cySize.Lo      = lfHeight * 720000 / ppi;
	fd.cySize.Hi      = 0;

	CComPtr<IFontDisp> spFontDisp;
	sc = OleCreateFontIndirect (&fd, IID_IFontDisp, (void**) &spFontDisp);
	if (sc)
		return;

	/*
	 * set the Font property on the AxHostWindow
	 */
    pHostDispatch->put_Font (spFontDisp);
}


/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::PreTranslateMessage
 *
 * PURPOSE: Sends accelerator messages to the OCX.
 *
 * PARAMETERS:
 *    MSG* pMsg :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL
COCXHostView::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
    {
        IOleInPlaceActiveObjectPtr spOleIPAObj = GetIUnknown();

#ifdef DBG
        TCHAR szTracePrefix[32];
        wsprintf (szTracePrefix, _T("msg=0x%04x, vkey=0x%04x:"), pMsg->message, pMsg->wParam);
#endif

        if (spOleIPAObj != NULL)
        {
            bool fHandled = (spOleIPAObj->TranslateAccelerator(pMsg) == S_OK);
            Trace (tagOCXTranslateAccel, _T("%s %s handled"), szTracePrefix, fHandled ? _T("   ") : _T("not"));

            if (fHandled)
                return TRUE;
        }
        else
            Trace (tagOCXTranslateAccel, _T("%s not handled (no IOleInPlaceActiveObject*)"), szTracePrefix);
    }

    return BC::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\ocxview.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ocxview.h
 *
 *  Contents:  Interface file for COCXHostView
 *
 *  History:   12-Dec-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/
#if !defined(AFX_OCXVIEW_H__B320948E_731E_11D1_8033_0000F875A9CE__INCLUDED_)
#define AFX_OCXVIEW_H__B320948E_731E_11D1_8033_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ocxview.h : header file
//

#ifdef DBG
extern CTraceTag tagOCXActivation;
#endif

/////////////////////////////////////////////////////////////////////////////
// COCXHostView view

class COCXHostView : public CView,
                     public CEventSource<COCXHostActivationObserver>
{
    typedef CView BC;

public:
    COCXHostView();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(COCXHostView)

// Attributes
private:
    CAMCView *          m_pAMCView;
    IUnknownPtr         m_spUnkCtrlWrapper;

protected:
    virtual CMMCAxWindow * GetAxWindow(); // can be overridden.
    CAMCView *          GetAMCView();

// Attributes
public:
    CFont   m_font;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COCXHostView)
    protected:
    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~COCXHostView();

    void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);


    virtual LPUNKNOWN GetIUnknown();
    virtual BOOL PreTranslateMessage(MSG* pMsg);


    SC      ScSetControl(HNODE hNode, CResultViewType& rvt, INodeCallback *pNodeCallback);

private:
    SC      ScSetControl1(HNODE hNode, LPUNKNOWN pUnkCtrl, DWORD dwOCXOptions, INodeCallback *pNodeCallback);
    SC      ScSetControl2(HNODE hNode, LPCWSTR szOCXClsid, DWORD dwOCXOptions, INodeCallback *pNodeCallback);
    typedef CMMCAxWindow *PMMCAXWINDOW;

    SC      ScCreateAxWindow(PMMCAXWINDOW &pWndAx); // creates a new CMMCAxWindow
    SC      ScHideWindow();


protected:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
protected:
    //{{AFX_MSG(COCXHostView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg int  OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetAmbientFont (IAxWinAmbientDispatch* pHostDispatch);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OCXVIEW_H__B320948E_731E_11D1_8033_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\props.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      props.cpp
 *
 *  Contents:  Interface file for console property sheet and page(s)
 *
 *  History:   05-Dec-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_PROPS_H__088693B7_6D93_11D1_802E_0000F875A9CE__INCLUDED_)
#define AFX_PROPS_H__088693B7_6D93_11D1_802E_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// props.h : header file
//

#include "amc.h"    // for CAMCApp::ProgramMode
#include "smarticon.h"

class CMainFrame;
class CAMCDoc;
class CConsolePropSheet;


/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage dialog

class CConsolePropPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CConsolePropPage)

// Construction
public:
    CConsolePropPage();
    ~CConsolePropPage();

// Dialog Data
    //{{AFX_DATA(CConsolePropPage)
	enum { IDD = IDD_PROPPAGE_CONSOLE };
    CButton m_wndDontSaveChanges;
    CButton m_wndAllowViewCustomization;
    CStatic m_wndModeDescription;
    CEdit   m_wndTitle;
    CStatic m_wndIcon;
    int     m_nConsoleMode;
    BOOL    m_fDontSaveChanges;
    CString m_strTitle;
    BOOL    m_fAllowViewCustomization;
	//}}AFX_DATA

private:
    // this is exported by ordinal from shell32.dll
    // used here by permission of the shell team, specifically Chris Guzak (chrisg)
    // STDAPI_(int) PickIconDlg (HWND hwnd, LPTSTR pszIconPath, UINT cchIconPath, int * piIconIndex)
    typedef int (STDAPICALLTYPE* PickIconDlg_Ptr)(HWND, LPTSTR, UINT, int *);
    enum { PickIconDlg_Ordinal = 62 };

    HINSTANCE           m_hinstSelf;
	CSmartIcon			m_icon;
    CString             m_strIconFile;
    int                 m_nIconIndex;
    bool                m_fTitleChanged;
    bool                m_fIconChanged;

    CAMCDoc* const m_pDoc;
    CString m_strDescription[eMode_Count];

    void SetDescriptionText ();
    void EnableDontSaveChanges();

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CConsolePropPage)
    public:
    virtual void OnOK();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CConsolePropPage)
    afx_msg void OnSelendokConsoleMode();
    virtual BOOL OnInitDialog();
    afx_msg void OnDontSaveChanges();
    afx_msg void OnAllowViewCustomization();
    afx_msg void OnChangeIcon();
    afx_msg void OnChangeCustomTitle();
	//}}AFX_MSG

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_PROPPAGE_CONSOLE);

    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage dialog

class CDiskCleanupPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CDiskCleanupPage)

// Construction
public:
    CDiskCleanupPage();
    ~CDiskCleanupPage();

// Dialog Data
	enum { IDD = IDD_DISK_CLEANUP};

    virtual BOOL OnInitDialog();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_PROPPAGE_DISK_CLEANUP);

    // Generated message map functions
protected:
    //{{AFX_MSG(CDiskCleanupPage)
    afx_msg void OnDeleteTemporaryFiles();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
private:
    SC   ScRecalculateUsedSpace();
};



/////////////////////////////////////////////////////////////////////////////
// CConsolePropSheet

class CConsolePropSheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CConsolePropSheet)

// Construction
public:
    CConsolePropSheet(UINT nIDCaption = IDS_CONSOLE_PROPERTIES, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CConsolePropSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

private:
    void CommonConstruct();

// Attributes
public:
    CConsolePropPage    m_ConsolePage;
    CDiskCleanupPage    m_diskCleanupPage;

// Operations
public:
    void SetTitle (LPCTSTR pszTitle);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConsolePropSheet)
	public:
	virtual INT_PTR DoModal();
	//}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CConsolePropSheet();

    // Generated message map functions
protected:
    //{{AFX_MSG(CConsolePropSheet)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPS_H__088693B7_6D93_11D1_802E_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\props.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      props.cpp
 *
 *  Contents:  Implementation file for console property sheet and page(s)
 *
 *  History:   05-Dec-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "props.h"
#include "mainfrm.h"
#include "amcdoc.h"
#include "pickicon.h"

//#ifdef _DEBUG
//#define new DEBUG_NEW
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#endif


/////////////////////////////////////////////////////////////////////////////
// CConsolePropSheet

IMPLEMENT_DYNAMIC(CConsolePropSheet, CPropertySheet)

CConsolePropSheet::CConsolePropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    CommonConstruct ();
}

CConsolePropSheet::CConsolePropSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    CommonConstruct ();
}

void CConsolePropSheet::CommonConstruct()
{
    DECLARE_SC(sc, TEXT("CConsolePropSheet::CommonConstruct"));

    CAMCApp *pAMCApp = AMCGetApp();
    sc = ScCheckPointers( pAMCApp, E_UNEXPECTED );
    if (sc)
        sc.TraceAndClear();

    // add the main page only for author mode
    if ( (pAMCApp != NULL) && (pAMCApp->GetMode() == eMode_Author) )
    {
        AddPage (&m_ConsolePage);
    }

    AddPage (&m_diskCleanupPage);
}


BOOL CConsolePropSheet::OnInitDialog()
{
    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);
    return CPropertySheet::OnInitDialog();
}

CConsolePropSheet::~CConsolePropSheet()
{
}

BEGIN_MESSAGE_MAP(CConsolePropSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CConsolePropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*+-------------------------------------------------------------------------*
 * CConsolePropSheet::DoModal
 *
 *
 *--------------------------------------------------------------------------*/
INT_PTR CConsolePropSheet::DoModal()
{
	CThemeContextActivator activator;
	return CPropertySheet::DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage property page

IMPLEMENT_DYNCREATE(CConsolePropPage, CPropertyPage)

CConsolePropPage::CConsolePropPage()
    :   CPropertyPage(CConsolePropPage::IDD),
        m_pDoc (CAMCDoc::GetDocument())
{
    ASSERT        (m_pDoc != NULL);
    ASSERT_VALID  (m_pDoc);
    ASSERT_KINDOF (CAMCDoc, m_pDoc);

    m_hinstSelf               = AfxGetInstanceHandle ();
    m_fTitleChanged           = false;
    m_fIconChanged            = false;
    m_strTitle                = m_pDoc->GetCustomTitle ();
    m_nConsoleMode            = m_pDoc->GetMode ();
    m_fDontSaveChanges        = m_pDoc->IsLogicalReadOnly ();
    m_fAllowViewCustomization = m_pDoc->AllowViewCustomization ();
}

CConsolePropPage::~CConsolePropPage()
{
}

void CConsolePropPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConsolePropPage)
    DDX_Control(pDX, IDC_DONTSAVECHANGES, m_wndDontSaveChanges);
    DDX_Control(pDX, IDC_AllowViewCustomization, m_wndAllowViewCustomization);
    DDX_Control(pDX, IDC_CONSOLE_MODE_DESCRIPTION, m_wndModeDescription);
    DDX_Control(pDX, IDC_CUSTOM_TITLE, m_wndTitle);
    DDX_CBIndex(pDX, IDC_CONSOLE_MODE, m_nConsoleMode);
    DDX_Check(pDX, IDC_DONTSAVECHANGES, m_fDontSaveChanges);
    DDX_Text(pDX, IDC_CUSTOM_TITLE, m_strTitle);
    DDX_Check(pDX, IDC_AllowViewCustomization, m_fAllowViewCustomization);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConsolePropPage, CPropertyPage)
    //{{AFX_MSG_MAP(CConsolePropPage)
    ON_CBN_SELENDOK(IDC_CONSOLE_MODE, OnSelendokConsoleMode)
    ON_BN_CLICKED(IDC_DONTSAVECHANGES, OnDontSaveChanges)
    ON_BN_CLICKED(IDC_AllowViewCustomization, OnAllowViewCustomization)
    ON_BN_CLICKED(IDC_CHANGE_ICON, OnChangeIcon)
    ON_EN_CHANGE(IDC_CUSTOM_TITLE, OnChangeCustomTitle)
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage message handlers

void CConsolePropPage::OnOK()
{
    m_pDoc->SetMode (static_cast<ProgramMode>(m_nConsoleMode));
    m_pDoc->SetLogicalReadOnlyFlag (m_fDontSaveChanges);
    m_pDoc->AllowViewCustomization (m_fAllowViewCustomization);

	if (m_fIconChanged)
	{
		m_pDoc->SetCustomIcon (m_strIconFile, m_nIconIndex);
		m_fIconChanged = false;
	}

    if (m_fTitleChanged)
    {
        m_pDoc->SetCustomTitle (m_strTitle);
        m_fTitleChanged = false;
    }

    CPropertyPage::OnOK();
}

void CConsolePropPage::OnSelendokConsoleMode()
{
    SetModified ();
    UpdateData ();
    SetDescriptionText ();
    EnableDontSaveChanges ();
}

void CConsolePropPage::SetDescriptionText ()
{
    // make sure the mode index is within range
    ASSERT (IsValidProgramMode (static_cast<ProgramMode>(m_nConsoleMode)));

    m_wndModeDescription.SetWindowText (m_strDescription[m_nConsoleMode]);
}

BOOL CConsolePropPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    /*
     * make sure the string IDs are as the code expects them
     */
    ASSERT ((IDS_ModeAuthor               + 1) == IDS_ModeUserFull);
    ASSERT ((IDS_ModeUserFull             + 1) == IDS_ModeUserMDI);
    ASSERT ((IDS_ModeUserMDI              + 1) == IDS_ModeUserSDI);
    ASSERT ((IDS_ModeAuthor_Description   + 1) == IDS_ModeUserFull_Description);
    ASSERT ((IDS_ModeUserFull_Description + 1) == IDS_ModeUserMDI_Description);
    ASSERT ((IDS_ModeUserMDI_Description  + 1) == IDS_ModeUserSDI_Description);


    /*
     * load the mode names into the combo box
     */
    int i;
    CString strComboText;
    CComboBox* pCombo = reinterpret_cast<CComboBox*>(GetDlgItem (IDC_CONSOLE_MODE));
    ASSERT (pCombo != NULL);

    for (i = 0; i < eMode_Count; i++)
    {
        VERIFY (LoadString (strComboText, IDS_ModeAuthor + i));
        pCombo->AddString (strComboText);
    }

    pCombo->SetCurSel (m_nConsoleMode - eMode_Author);


    /*
     * load up the description text
     */
    ASSERT (countof (m_strDescription) == eMode_Count);

    for (i = 0; i < countof (m_strDescription); i++)
    {
        VERIFY (LoadString (m_strDescription[i], IDS_ModeAuthor_Description + i));
    }

    SetDescriptionText ();
    EnableDontSaveChanges ();


    /*
     * Get the current icon for this console file
     */
    ASSERT (m_pDoc != NULL);
    HICON hIcon = m_pDoc->GetCustomIcon (true, &m_strIconFile, &m_nIconIndex);
    m_wndIcon.SubclassDlgItem (IDC_CONSOLE_ICON, this);

    /*
     * if we haven't specified a custom icon yet, use MMC.EXE
     */
    if (hIcon == NULL)
    {
        ASSERT (m_strIconFile.IsEmpty());
        const int cchBuffer = MAX_PATH;

        GetModuleFileName (AfxGetInstanceHandle(), m_strIconFile.GetBuffer(cchBuffer), cchBuffer);
        m_strIconFile.ReleaseBuffer();
        m_nIconIndex = 0;
    }
    else
        m_wndIcon.SetIcon (hIcon);

    /*
     * Get the current title for this console file
     */
    m_wndTitle.SetWindowText (m_pDoc->GetCustomTitle());
    m_fTitleChanged = false;

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConsolePropPage::OnDontSaveChanges()
{
    SetModified ();
}

void CConsolePropPage::OnAllowViewCustomization()
{
    SetModified ();
}

void CConsolePropPage::EnableDontSaveChanges()
{
    if (m_nConsoleMode == eMode_Author)
    {
        m_wndDontSaveChanges.       EnableWindow (false);
        m_wndDontSaveChanges.       SetCheck (0);

        m_wndAllowViewCustomization.EnableWindow (false);
        m_wndAllowViewCustomization.SetCheck (1);
    }
    else
    {
        m_wndDontSaveChanges.       EnableWindow (true);
        m_wndAllowViewCustomization.EnableWindow (true);
    }
}


void CConsolePropPage::OnChangeIcon()
{
    int nIconIndex = m_nIconIndex;
    TCHAR szIconFile[MAX_PATH];
    lstrcpy (szIconFile, m_strIconFile);

    /*
     * show the pick 'em dialog; if something changed, enable OK/Apply
     */
    if (PickIconDlg (m_hWnd, szIconFile, countof (szIconFile), &nIconIndex) &&
        ((nIconIndex != m_nIconIndex) || (lstrcmpi (szIconFile, m_strIconFile) != 0)))
    {
        m_icon.Attach (ExtractIcon (m_hinstSelf, szIconFile, nIconIndex));

        if (m_icon != NULL)
        {
			m_fIconChanged = true;
            m_strIconFile  = szIconFile;
            m_nIconIndex   = nIconIndex;
            m_wndIcon.SetIcon (m_icon);
            SetModified();
        }
    }
}

void CConsolePropPage::OnChangeCustomTitle()
{
    m_fTitleChanged = true;
    SetModified();
}

/////////////////////////////////////////////////////////////////////////////
// CDiskCleanupPage property page

IMPLEMENT_DYNCREATE(CDiskCleanupPage, CPropertyPage)


BEGIN_MESSAGE_MAP(CDiskCleanupPage, CPropertyPage)
    ON_MMC_CONTEXT_HELP()
    ON_BN_CLICKED(IDC_DELETE_TEMP_FILES, OnDeleteTemporaryFiles)
END_MESSAGE_MAP()


CDiskCleanupPage::CDiskCleanupPage() :   CPropertyPage(CDiskCleanupPage::IDD)
{
}

CDiskCleanupPage::~CDiskCleanupPage()
{
}


BOOL CDiskCleanupPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    ScRecalculateUsedSpace();

    return TRUE;
}

/***************************************************************************\
 *
 * METHOD:  CDiskCleanupPage::OnDeleteTemporaryFiles
 *
 * PURPOSE: Invoked when "Delete Filed" button is pressed
 *          Removes all files from MMC folder storing the user data
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
void CDiskCleanupPage::OnDeleteTemporaryFiles()
{
    DECLARE_SC(sc, TEXT("CDiskCleanupPage::OnDeleteTemporaryFiles"));

    // ask user if he is sure...
    CString strConfirmMessage;
    CString strConfirmCaption;
    if (!LoadString(strConfirmMessage, IDS_ConfirmDeleteTempFiles) ||
        !LoadString(strConfirmCaption, IDR_MAINFRAME))
    {
        sc = E_UNEXPECTED;
        return;
    }

    int ans = ::MessageBox( m_hWnd, strConfirmMessage, strConfirmCaption, MB_YESNO | MB_ICONWARNING);
    if ( ans != IDYES )
        return;

    // display wait cursor while working
    CWaitCursor cursorWait;

    // get folder
    tstring strFileFolder;
    sc = CConsoleFilePersistor::ScGetUserDataFolder(strFileFolder);
    if (sc)
        return;

    // get file mask
    tstring strFileMask = strFileFolder;
    strFileMask += _T("\\*.*");

    WIN32_FIND_DATA findFileData;
    ZeroMemory( &findFileData, sizeof(findFileData) );

    // start file search
    HANDLE hFindFile = FindFirstFile( strFileMask.c_str(), &findFileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        sc.FromLastError();
        return;
    }

    // loop thru files and delete them
    bool bContinue = true;
    while ( bContinue )
    {
        tstring strFileToDelete = strFileFolder + _T('\\') + findFileData.cFileName;
        DWORD   dwFileAttributes = findFileData.dwFileAttributes;

        // get to the next file first
        bContinue = FindNextFile( hFindFile, &findFileData );

        // delete files, but not directories
        if ( 0 == (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // delete
            if ( !DeleteFile( strFileToDelete.c_str() ) )
            {
                // trace on errors (but do not stop)
                sc.FromLastError().TraceAndClear();
            }
        }
    }

    // Done, release the handle
    FindClose(hFindFile);

    sc = ScRecalculateUsedSpace();
    if (sc)
        sc.TraceAndClear();

}

/***************************************************************************\
 *
 * METHOD:  CDiskCleanupPage::ScRecalculateUsedSpace
 *
 * PURPOSE: Recalculates and displays disk space occupied by user data in this profile
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CDiskCleanupPage::ScRecalculateUsedSpace()
{
    DECLARE_SC(sc, TEXT("CDiskCleanupPage::ScRecalculateUsedSpace"));

    // display wait cursor while working
    CWaitCursor cursorWait;

    // get folder
    tstring strFileFolder;
    sc = CConsoleFilePersistor::ScGetUserDataFolder(strFileFolder);
    if (sc)
        return sc;

    // get file mask
    tstring strFileMask = strFileFolder;
    strFileMask += _T("\\*.*");

    WIN32_FIND_DATA findFileData;
    ZeroMemory( &findFileData, sizeof(findFileData) );

    // start file search
    HANDLE hFindFile = FindFirstFile( strFileMask.c_str(), &findFileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
        return sc.FromLastError();

    // loop thru files and count size
    ULARGE_INTEGER ulgOccupied = {0};
    bool bContinue = true;
    while ( bContinue )
    {
        DWORD   dwFileAttributes = findFileData.dwFileAttributes;
        if ( 0 == (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // add the high and low part separatelly, since findFileData does not have it bundled
            ulgOccupied.HighPart += findFileData.nFileSizeHigh;
            // add lower part to the whole large integer not to lose carry on overflow
            ulgOccupied.QuadPart += findFileData.nFileSizeLow;
        }

        // get to the next file first
        bContinue = FindNextFile( hFindFile, &findFileData );
    }

    // Done, release the handle
    FindClose(hFindFile);

    // now conver the size into string
    UINT nTerraBytes = (UINT)(ulgOccupied.QuadPart >> 40);
    UINT nGigaBytes =  (UINT)(ulgOccupied.QuadPart >> 30) & 0x3ff;
    UINT nMegaBytes =  ((ulgOccupied.LowPart >> 20) & 0x3ff);
    UINT nKiloBytes =  ((ulgOccupied.LowPart >> 10) & 0x3ff);
    UINT nBytes =      ( ulgOccupied.LowPart  & 0x3ff);

    CString strUnit;
    double dSize = 0.0;
    bool   bNonZeroOccupied = (ulgOccupied.QuadPart != 0);

    // display only biggest units, and never more than 999
    // instead of "1001 KB" we display "0.98 MB"
    if ( (nTerraBytes) > 0 || (nGigaBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_TB);
        dSize = (double)nTerraBytes + ((double)nGigaBytes / 1024.);
    }
    else if ( (nGigaBytes) > 0 || (nMegaBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_GB);
        dSize = (double)nGigaBytes + ((double)nMegaBytes / 1024.);
    }
    else if ( (nMegaBytes) > 0 || (nKiloBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_MB);
        dSize = (double)nMegaBytes + ((double)nKiloBytes / 1024.);
    }
    else if ( (nKiloBytes) > 0 || (nBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_KB);
        dSize = (double)nKiloBytes + ((double)nBytes / 1024.);
    }
    else
    {
        LoadString(strUnit, IDS_FileSize_bytes);
        dSize = (double)nBytes;
    }

    // format with op to two decimal points
    CString strSize;
    strSize.Format(_T("%.2f"), dSize);

    //truncate trailing zeros
    while (strSize.Right(1) == _T("0"))
        strSize = strSize.Left(strSize.GetLength() - 1);
    //truncate trailing decimal point
    if (strSize.Right(1) == _T("."))
        strSize = strSize.Left(strSize.GetLength() - 1);

    // add units ( in locale independant way )
    strUnit.Replace(_T("%1"), strSize);

    // set to the window
    SetDlgItemText( IDC_DISKCLEANUP_OCCUPIED, strUnit );

    // enable/disable "Delete Files" button
    CWnd *pWndDeleteBtn = GetDlgItem(IDC_DELETE_TEMP_FILES);
    sc = ScCheckPointers( pWndDeleteBtn, E_UNEXPECTED );
    if (sc)
        return sc;

    pWndDeleteBtn->EnableWindow( bNonZeroOccupied );

    // if the focus went away (belonged to the window being disabled)
    // set it to the OK button
    if ( ::GetFocus() == NULL && GetParent())
    {
        GetParent()->SetFocus();
        GetParent()->SendMessage(DM_SETDEFID, IDOK);
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by amc.rc
//
#include "mmcres.h"

#include <ntverp.h>
#include <winver.h>
#include <dlgs.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Microsoft Management Console"
#define VER_INTERNALNAME_STR            "mmc.exe"
#define VER_ORIGINALFILENAME_STR        "mmc.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\scriptevents.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      scriptevents.h
//
//  Contents:  Implementation of script events thru connection points
//
//  History:   11-Feb-99 AudriusZ    Created
//
//--------------------------------------------------------------------------

/*
    This file provides means to implement connection-point based events with 
    the ability to fire them to running scripts. That is an alternative to 
    wizard-based implementation provided by ATL.

IDEA

    The idea behind this implementation is to create the class that 
    implements the methods from the event interface. Each such method will 
    have a string literal equivalent to method name. Whenever such a method 
    is called, it will use that string literal to find the dispatch ID of 
    the interface method and will use it to forward the call to event sinks.

    The special measures need to be taken to assure correct mapping of methods,
    proper parameter types and count. The provided implementation puts these 
    tasks on the compiler, since it's more accurate than the human. Deriving 
    the class from the event interface implemented assures it. To implement 
    method mapping the class uses CComTypeInfoHolder defined in ATL
    to do the actual mapping.

    The benefits come with a price - the event interface needs to be dual 
    (while the scripts require it to be dispinterface only) - that requires 
    defining 2 interfaces in IDL. Mapping also means slightly increased method 
    call time.

REQUIREMENTS / USAGE

    1.	You need to define hidden dual interface (with the name constructed by prepending
        underscore to the name of dispinterface) in the IDL file, like this:

        [ 
            uuid(YYYYYYYYYYY), dual, helpstring("")
        ]
        interface _DocEvents : IDispatch
        {
            [id(1), helpstring("Occurs when a document is initialized")]
            HRESULT OnInitialize( [in] PDOCUMENT pDocument);
            [id(2), helpstring("Occurs when a document is destroyed")]
            HRESULT OnDestroy( [in] PDOCUMENT pDocument);
        };

    2.	You need to define the dispinterface to be used as event source, like 
        this:

        [ 
            uuid(XXXXXXXXXXX) ,   helpstring("DocEvents Interface")
        ]
        dispinterface DocEvents
        {
    	    interface _DocEvents;
        };

    3.	Your com object needs to derive from IConnectionPointContainerImpl and 
        define CONNECTION_POINT_MAP.

    4.	You need to provide the specialization of the event proxy, mapping all 
        the methods from the event interface, like this:

        DISPATCH_CALL_MAP_BEGIN(DocEvents)
            DISPATCH_CALL1( OnInitialize,  PDOCUMENT )
            DISPATCH_CALL1( OnDestroy,     PDOCUMENT )
        DISPATCH_CALL_MAP_END()

        Note: this must be defined at global scope (probably *.h file) and visible
              from wherever ScFireComEvent is executed.

    5.	(optional) If any of the parameters in the event interface refers to 
        coclass in IDL, you need to map (cast) the types to the interface 
        pointer inside the proxy, like this:

        DISPATCH_CALL_MAP_BEGIN(DocEvents)
            DISPATCH_PARAM_CAST ( PDOCUMENT, IDispatch * );
            DISPATCH_CALL1( OnInitialize,  PDOCUMENT )
            DISPATCH_CALL1( OnDestroy,     PDOCUMENT )
        DISPATCH_CALL_MAP_END()

    6.	where needed you may fire the evens like this:

    sc = ScFireComEvent(m_sp_Document, DocEvents , OnDestroy(pDocument));

    7.  to avoid creating com objects (parameters to events) when there is no one
        interested in receiving them use ScHasSinks macro:

    sc = ScHasSinks(m_sp_Document, DocEvents);
    if (sc == SC(S_OK))
    {
        // create com objects and fire the event
    }


COMPARISON                      this                    ATL

    Manual changes              yes                     semi

    Dual interface              required                not required

    Call to method 1st time     Maps the name           direct

    Type library                required at runtime     only to generate

    After method is added       require to add          Require to regenerate
                                the method to proxy     proxy file

    After disp ID is changed    no changes              Require to regen.

    Compiling changed IDL       Won't compile if proxy  Fail on runtime
                                doesn't fit interface

    fire                        from anywhere           from proxy only

    coclass param casting       provides                not support

USED CLASS HIERARCHY

    CEventDispatcherBase                [ type-invariant stuff]
        /\
        ||
    CEventDispatcher<_dual_interface>   [ interface type parametrized stuff]
        /\
        ||
    CEventProxy<_dispinterface>         [ client provided call map defines this]
        /\
        ||
    CScriptEvent<_dispinterface>        [ this one gets instantiated by ScFireComEvent ]

*/

#include "eventlock.h"

/***************************************************************************\
 *
 * CLASS:  CEventDispatcherBase
 *
 * PURPOSE: base class for CEventDispatcher template
 *          implements functionality not dependant on template parameters
 *
\***************************************************************************/
class CEventDispatcherBase
{
protected:
    // c-tor
    CEventDispatcherBase() : m_bEventSourceExists(false) {}

    // Parameter cast template
    // Provided to allow parameter casting for parameters of specified types
    // in proxy using DISPATCH_PARAM_CAST macro.
    // Default (specified here) casts every type to itself
    template <typename _param_type> 
    struct ParamCast 
    { 
        typedef _param_type PT; 
    };
            
    // Parameter cast function (see comment above)
    template <typename _param_type>
    inline ParamCast<_param_type>::PT& CastParam(_param_type& arg) const
    { 
        return reinterpret_cast<ParamCast<_param_type>::PT&>(arg); 
    }

    // sets connection point container to be used to forward events
    void SetContainer(LPUNKNOWN pComObject);
    // forward the call using IDispatch of event sinks
    SC   ScInvokeOnConnections(const REFIID riid, DISPID dispid, CComVariant *pVar, int count, CEventBuffer& buffer) const;

    // returns S_FALSE if no sinks are registered with the object.
    SC   ScHaveSinksRegisteredForInterface(const REFIID riid);

private:
    // there are two options: com object does not exist (that's ok)
    // and it does not implement container (error)
    // we have 2 variables to deal with both situations
    bool                         m_bEventSourceExists;
    IConnectionPointContainerPtr m_spContainer;
};


/***************************************************************************\
 *
 * CLASS:  CEventDispatcher
 *
 * PURPOSE: Fully equipped call dispather
 *          Main functionality of it is to implement ScMapMethodToID
 *          and ScInvokeOnConnections - two functions required to call
 *          method by name thru IDispatch::Invoke()
 *          They are use by DISPATCH_CALL# macros
 *
\***************************************************************************/
template <typename _dual_interface>
class CEventDispatcher : public CEventDispatcherBase 
{
protected:
    typedef _dual_interface DualIntf;
    // Maps method name to dispId; Employs CComTypeInfoHolder to do the job
    SC ScMapMethodToID(LPCWSTR strMethod, DISPID& dispid)
    {
        DECLARE_SC(sc, TEXT("ScMapMethodToID"));

        // this cast is needed just because of bad parameter type defined in GetIDsOfNames
        LPOLESTR strName = const_cast<LPOLESTR>(strMethod);
        // rely on CComTypeInfoHolder to do it
        sc = m_TypeInfo.GetIDsOfNames( IID_NULL, &strName, 1, LOCALE_NEUTRAL, &dispid );
        if (sc)
            return sc;
    
        return sc;
    }

private:
    // be aware - this member depents on template parameter
    static CComTypeInfoHolder m_TypeInfo;
};

/***************************************************************************\
 *
 * CEventDispatcher static member initialization
 *
\***************************************************************************/

const WORD wVersionMajor = 1;
const WORD wVersionMinor = 0;

template <typename _dual_interface>
CComTypeInfoHolder CEventDispatcher<_dual_interface>::m_TypeInfo =
{ &__uuidof(_dual_interface), &LIBID_MMC20, wVersionMajor, wVersionMinor, NULL, 0, NULL, 0 };

/***************************************************************************\
 *
 * CLASS:  CEventProxy
 *
 * PURPOSE: Every event interface should have specialization of this class,
 *          describing mapped (dual interface - to - dispinterface) methods.
 *          Here it is just declared - not defined.
 *
\***************************************************************************/
template <typename _dispinterface> class CEventProxy;

/***************************************************************************\
 *
 * CLASS:  CScriptEvent
 *
 * PURPOSE: The object that will be constructed to fire actual event.
 *          It is provided solely to do initialization by constuctor,
 *          coz that allowes us to use single unnamed object in the single
 *          statement to both construct it and invoke a method on it.
 *
\***************************************************************************/
template <typename _dispinterface>
class CScriptEvent: public CEventProxy<_dispinterface>
{
public:
    CScriptEvent(LPUNKNOWN pComObject)
    {
        SetContainer(pComObject);
    }
    // returns S_FALSE if no sinks are registered with the object.
    SC  ScHaveSinksRegistered() 
    { 
        return ScHaveSinksRegisteredForInterface(__uuidof(_dispinterface)); 
    }
};


/***************************************************************************\
 *
 *  MACROS USED TO IMPLEMENT EVENT PROXY
 *
\***************************************************************************/

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_MAP_BEGIN
 *
 * defines the begining of the call map.
 * NOTE : assumes that dual interface has the same name as the dispinterface 
 *        with single '_' prepended
\***************************************************************************/
#define  DISPATCH_CALL_MAP_BEGIN(_dispinterface)        \
    template<> class CEventProxy<_dispinterface> : public CEventDispatcher<_##_dispinterface> {

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_MAP_END
 *
 * defines the end of the call map.
\***************************************************************************/
#define  DISPATCH_CALL_MAP_END()  };

/***************************************************************************\
 *
 * MACRO:  DISPATCH_PARAM_CAST
 *
 * defines type mapping to be used prior to IDispatch::Invoke
 * It is provided to deal with objects defined as coclass
 * in IDL file, which cannot implecitly be converted to any interface.
 * ( if we do not change it CComVariant will treat it as bool type )
 *
\***************************************************************************/
#define DISPATCH_PARAM_CAST(from,to) \
    public: template <> struct CEventDispatcherBase::ParamCast<from> { typedef to PT; }

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_PROLOG
 *
 * used as first part of every DISPATCH_CALL# macro
 *
\***************************************************************************/
#define  DISPATCH_CALL_PROLOG(_method, _param_list)                                     \
    /* Implement pure method to be able to instantiate the class */                     \
    /* it should not be used - so it's declared private          */                     \
    private: STDMETHOD(_method) _param_list                                             \
    {                                                                                   \
    /* retrieving the pointer to base won't compile if method is */                     \
    /* removed from the interface (that's what we want to catch) */                     \
        HRESULT (STDMETHODCALLTYPE DualIntf::*pm)_param_list = DualIntf::_method;       \
        return E_NOTIMPL;                                                               \
    }                                                                                   \
    /* Implement invocation in Sc* method used by SC_FIRE* macro */                     \
    /* _param_list represents parameter list with brackets       */                     \
    public: SC Sc##_method _param_list {                                                \
    DECLARE_SC(sc, TEXT("DISPATCH_CALL::Sc") TEXT(#_method));                           \
    /* following lines gets dispid on the first call only.       */                     \
    /* succeeding calls will reuse it or error from the 1st call */                     \
    static DISPID dispid = 0;                                                           \
    static SC sc_map = ScMapMethodToID(L#_method, dispid);                              \
    if (sc_map) return sc = sc_map; 

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_EPILOG
 *
 * used as last part of every DISPATCH_CALL# macro
 *
\***************************************************************************/
#define  DISPATCH_CALL_EPILOG(_pvar, _count)                                            \
    /* Get the proper event buffer for locked scenarios         */                      \
    CEventBuffer& buffer = GetEventBuffer();											\
    /* just invoke the method on the sinks                       */                     \
    return sc = ScInvokeOnConnections(__uuidof(_dispinterface), dispid, _pvar, _count, buffer); } 

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL0
 *
 * used to map an event interface method with 0 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL0(_method)                                                        \
    DISPATCH_CALL_PROLOG(_method, ())                                                   \
    DISPATCH_CALL_EPILOG(NULL, 0)

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL1
 *
 * used to map an event interface method with 1 parameter
 *
\***************************************************************************/
#define  DISPATCH_CALL1(_method,  P1)                                                   \
    DISPATCH_CALL_PROLOG(_method, (P1 param1))                                          \
    CComVariant var[] = { CastParam(param1) };                                          \
    DISPATCH_CALL_EPILOG(var, countof(var))

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL2
 *
 * used to map an event interface method with 2 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL2(_method,  P1, P2)                                               \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2))                               \
    CComVariant var[] = { CastParam(param2), CastParam(param1) };                       \
    DISPATCH_CALL_EPILOG(var, countof(var))

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL3
 *
 * used to map an event interface method with 3 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL3(_method,  P1, P2, P3)                                           \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2, P3 param3))                    \
    CComVariant var[] = { CastParam(param3), CastParam(param2), CastParam(param1) };    \
    DISPATCH_CALL_EPILOG(var, countof(var))


/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL4
 *
 * used to map an event interface method with 4 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL4(_method,  P1, P2, P3, P4)                                           \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2, P3 param3, P4 param4))             \
    CComVariant var[] = { CastParam(param4), CastParam(param3), CastParam(param2), CastParam(param1) };    \
    DISPATCH_CALL_EPILOG(var, countof(var))


/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL5
 *
 * used to map an event interface method with 5 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL5(_method,  P1, P2, P3, P4, P5)                                           \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2, P3 param3, P4 param4, P5 param5))             \
    CComVariant var[] = { CastParam(param5), CastParam(param4), CastParam(param3), CastParam(param2), CastParam(param1) };    \
    DISPATCH_CALL_EPILOG(var, countof(var))


/***************************************************************************\
 *
 * MACRO:  ScFireComEvent
 *
 * used to fire script event. Note that _p_com_object may be NULL
 *
\***************************************************************************/
#ifdef DBG
extern CTraceTag  tagComEvents;
#endif

#define ScFireComEvent(_p_com_object, _dispinterface, _function_call)             \
    CScriptEvent<_dispinterface>(_p_com_object).Sc##_function_call;               \
    Trace(tagComEvents, _T(#_function_call));

/***************************************************************************\
 *
 * MACRO:  ScHasSinks
 *
 * used to determine if there are sinks connected 
 * ( to avoid creating com object when ScFireComEvent would result in no calls )
 *
\***************************************************************************/
#define ScHasSinks(_p_com_object, _dispinterface)                                    \
    ((_p_com_object) == NULL) ? SC(S_FALSE) : \
                                CScriptEvent<_dispinterface>(_p_com_object).ScHaveSinksRegistered();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\scripthost.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ScriptHost.cpp
//
//  Contents:   CScriptHostMgr & CScriptHost implementation.
//
//  History:    11/05/1999   AnandhaG   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "scripthost.h"

//+-------------------------------------------------------------------
// MMCObjectName is the name scripts will use to refer to mmc object.
//
// Example:
//
// Dim doc
// Dim snapins
// Set doc     = MMCApplication.Document
// Set snapins = doc.snapins
// snapins.Add "{58221c66-ea27-11cf-adcf-00aa00a80033}" ' the services snap-in
//
//+-------------------------------------------------------------------

const LPOLESTR MMCObjectName = OLESTR("MMCApplication");

//+-------------------------------------------------------------------
//
//  Member:      CScriptHostMgr::ScInitScriptHostMgr
//
//  Synopsis:    Get the ITypeInfo of this instance of mmc.
//
//  Arguments:   [pDispatch]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
CScriptHostMgr::CScriptHostMgr(LPDISPATCH pDispatch)
{
    m_spMMCObjectDispatch = pDispatch;

    // It is ok if below fails. These interfaces (dispatch & typeinfo) are required
    // in CScriptHost::GetItemInfo method, so that this object can be given to engine.
    pDispatch->GetTypeInfo(1, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), &m_spMMCObjectTypeInfo);
}

CScriptHostMgr::~CScriptHostMgr()
{
    DECLARE_SC(sc, _T("CScriptHostMgr::~CScriptHostMgr"));

    // The script manager is going away so ask all the script
    // hosts to finish their scripts & then destroy them.
    sc = ScDestroyScriptHosts();
}

SC CScriptHostMgr::ScGetMMCObject(LPUNKNOWN *ppunkItem)
{
    DECLARE_SC(sc, TEXT("CScriptHostMgr::ScGetMMCObject"));
    sc = ScCheckPointers(ppunkItem);
    if (sc)
        return sc;

    if (m_spMMCObjectDispatch)
    {
        *ppunkItem = m_spMMCObjectDispatch;
        return sc;
    }

    return (sc = E_FAIL);
}

SC CScriptHostMgr::ScGetMMCTypeInfo(LPTYPEINFO *ppTypeInfo)
{
    DECLARE_SC(sc, TEXT("CScriptHostMgr::ScGetMMCObject"));
    sc = ScCheckPointers(ppTypeInfo);
    if (sc)
        return sc;

    if (m_spMMCObjectDispatch)
    {
        *ppTypeInfo = m_spMMCObjectTypeInfo;
        return sc;
    }

    return (sc = E_FAIL);
}


//+-------------------------------------------------------------------
//
//  Member:      ScGetScriptEngineFromExtn
//
//  Synopsis:    Using the file extension get the script engine & Clsid.
//
//  Arguments:   [strFileExtn]     - Script extension.
//               [strScriptEngine] - Type script.
//               [rClsid]          - CLSID of engine.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScGetScriptEngineFromExtn(const tstring& strFileExtn,
                                             tstring& strScriptEngine,
                                             CLSID& rClsid)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScGetScriptEngine"));

    CRegKey regKey;

    // Open the extension.
    LONG lRet = regKey.Open(HKEY_CLASSES_ROOT, strFileExtn.data(), KEY_READ);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }

    TCHAR szTemp[MAX_PATH];
    DWORD dwLen = MAX_PATH;
    tstring strTemp;
    // Read the default value, the location of file association data.
    lRet = regKey.QueryValue(szTemp, NULL, &dwLen);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }
    ASSERT(dwLen > 0);

    // Open the HKCR/FileAssocLoc/ScriptEngine.
    strTemp  = szTemp;
    strTemp += _T("\\");
    strTemp += SCRIPT_ENGINE_KEY;

    lRet = regKey.Open(HKEY_CLASSES_ROOT, strTemp.data(), KEY_READ);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }

    // Now read the ScriptEngine default value.
    dwLen = MAX_PATH;
    lRet = regKey.QueryValue(szTemp, NULL, &dwLen);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }
    ASSERT(dwLen > 0);

    strScriptEngine  = szTemp;

    // Read HKCR/ScriptEngine/CLSID for ScriptEngine clsid.
    strTemp  = strScriptEngine + _T("\\");
    strTemp += CLSIDSTR;

    lRet = regKey.Open(HKEY_CLASSES_ROOT, strTemp.data(), KEY_READ);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }

    // Read the CLSID value.
    dwLen = MAX_PATH;
    lRet = regKey.QueryValue(szTemp, NULL, &dwLen);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }
    ASSERT(dwLen > 0);

    USES_CONVERSION;
    LPOLESTR lpClsid = T2OLE(szTemp);
    sc = CLSIDFromString(lpClsid, &rClsid);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScGetScriptEngine
//
//  Synopsis:    [strFileName] - Script file name.
//               [eScriptType] - Type script.
//               [rClsid]      - CLSID of engine.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScGetScriptEngine(const tstring& strFileName,
                                     tstring& strScriptEngine,
                                     CLSID& rClsid)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScGetScriptEngine"));

    // Is this required, the file is already read.
    // It is a file & it exists.
    DWORD dwAttr = GetFileAttributes(strFileName.data());
    if (-1 == dwAttr)
    {
        // What if lasterror is overwritten?
        sc.FromWin32(::GetLastError());
        return sc;
    }

    // Get the extension (look for . from end).
    int iPos = strFileName.rfind(_T('.'));
    tstring strExtn;
    if (-1 != iPos)
    {
        strExtn = strFileName.substr(iPos, strFileName.length());
    }
    else
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = ScGetScriptEngineFromExtn(strExtn, strScriptEngine, rClsid);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      ScLoadScriptFromFile
//
//  Synopsis:    Allocate memory & Load the script from the given file.
//
//  Arguments:   [strFileName]       - File to be loaded.
//               [pszScriptContents] - Memory buffer containing the script
//                                     contents (See note).
//
//  Note:        The caller should call HeapFree() to free the pszScriptContents.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScLoadScriptFromFile (const tstring& strFileName, LPOLESTR* pszScriptText)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScLoadScriptFromFile"));
    sc = ScCheckPointers(pszScriptText);
    if (sc)
        return sc;
    *pszScriptText = NULL;

    // Open the file.
    HANDLE hFile = ::CreateFile(strFileName.data(),
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        sc.FromWin32(::GetLastError());
        return sc;
    }

    HANDLE hFileMap = NULL;
    LPSTR pszMBCS   = NULL;

    DWORD dwFileSize = ::GetFileSize(hFile, NULL);
    if (dwFileSize == 0xFFFFFFFF)
    {
        sc.FromWin32(::GetLastError());
        goto FileError;
    }

    if (dwFileSize == 0)
    {
        sc = E_UNEXPECTED;
        goto FileError;
    }

    // Create a file mapping object.
    hFileMap = ::CreateFileMapping(hFile,
                                   NULL,
                                   PAGE_READONLY,
                                   0, dwFileSize,
                                   NULL );
    if (hFileMap == NULL)
    {
        sc.FromWin32(::GetLastError());
        goto FileError;
    }

    // Dummy block.
    {
        // Map the file into memory.
        pszMBCS = (LPSTR) ::MapViewOfFile(hFileMap,
                                          FILE_MAP_READ,
                                          0, 0,
                                          0 );

        if (pszMBCS == NULL)
        {
            sc.FromWin32(::GetLastError());
            goto FileMapError;
        }

        // Get the size of buffer needed.
        int n = ::MultiByteToWideChar(CP_ACP,
                                      0,
                                      pszMBCS, dwFileSize,
                                      NULL, 0 );

        //
        // Allocate script text buffer. +1 for EOS.
        //
        LPOLESTR pszText;
        pszText = (LPOLESTR) ::HeapAlloc(::GetProcessHeap(),
                                         0,
                                         (n + 2) * sizeof(wchar_t) );
        if (pszText == NULL)
        {
            sc.FromWin32(::GetLastError());
            goto FileAllocError;
        }


        // Store file as WCHAR inthe buffer.
        ::MultiByteToWideChar(CP_ACP,
                              0,
                              pszMBCS, dwFileSize,
                              pszText, n );
        //
        // Remove legacy EOF character.
        //
        if (pszText[n - 1] == 0x1A)
        {
            pszText[n - 1] = '\n';
        }

        pszText[n] = '\n';
        pszText[n + 1] = '\0';

        *pszScriptText = pszText;
    }


FileAllocError:
    ::UnmapViewOfFile(pszMBCS);

FileMapError:
    ::CloseHandle(hFileMap);

FileError:
    ::CloseHandle(hFile);

//NoError:
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScExecuteScript
//
//  Synopsis:    Execute given script file.
//
//  Arguments:   [strFileName]  - The script file.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScExecuteScript(const tstring& strFileName)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScExecuteScript"));

    CHeapAllocMemPtr<OLECHAR> spszFileContents;
    sc = ScLoadScriptFromFile(strFileName, &spszFileContents);
    if (sc)
        return sc;

    tstring strScriptEngine;
    CLSID EngineClsid;
    // Validate the file, get the script engine and script type.
    sc = ScGetScriptEngine(strFileName, strScriptEngine, EngineClsid);
    if (sc)
        return sc;

    sc = ScExecuteScriptHelper(spszFileContents, strScriptEngine, EngineClsid);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScExecuteScript
//
//  Synopsis:    Execute given script.
//
//  Arguments:   [pszScriptText]   - The script itself.
//               [strExtn]         - The script file extension.
//
//  Note:        The extension is used to determine the script
//               engine (as shell does).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScExecuteScript(LPOLESTR pszScriptText, const tstring& strExtn)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScExecuteScript"));

    tstring strScriptEngine;
    CLSID EngineClsid;
    // Validate the file, get the script engine and script type.
    sc = ScGetScriptEngineFromExtn(strExtn, strScriptEngine, EngineClsid);
    if (sc)
        return sc;

    sc = ScExecuteScriptHelper(pszScriptText, strScriptEngine, EngineClsid);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScExecuteScriptHelper
//
//  Synopsis:    Helper for ScExecuteScript, Create the Script Host &
//               asks it to run the script.
//
//  Arguments:   [pszScriptText]   - The script contents.
//               [strScriptEngine] - The script engine name.
//               [EngineClsid]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScExecuteScriptHelper (LPCOLESTR pszScriptText,
                                          const tstring strScriptEngine,
                                          const CLSID& EngineClsid)
{
    DECLARE_SC(sc, _T("ScExecuteScriptHelper"));

    // Create CScriptHost and ask it to run the script.
    CComObject<CScriptHost>* pScriptHost = NULL;
    sc = CComObject<CScriptHost>::CreateInstance(&pScriptHost);
    if (sc)
        return sc;

    if (NULL == pScriptHost)
        return (sc = E_FAIL);

    IUnknownPtr spUnknown = pScriptHost;
    if (NULL == spUnknown)
        return (sc = E_UNEXPECTED);

    m_ArrayOfHosts.push_back(spUnknown);

    sc = pScriptHost->ScRunScript(this, pszScriptText, strScriptEngine, EngineClsid);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      ScDestroyScriptHosts
//
//  Synopsis:    Stop all the running scripts and destroy all
//               script hosts.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScDestroyScriptHosts()
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScStopAllScripts"));

    // Ask each script host created to stop its script.
    ArrayOfScriptHosts::iterator it = m_ArrayOfHosts.begin();
    for (;it != m_ArrayOfHosts.end(); ++it)
    {
        CScriptHost* pScriptHost = dynamic_cast<CScriptHost*>(it->GetInterfacePtr());
        sc = ScCheckPointers(pScriptHost, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = pScriptHost->ScStopScript();
    }

    // This clear will call release on the IUnknown smart-pointers (that are in this array).
    m_ArrayOfHosts.clear();

    return sc;
}


CScriptHost::CScriptHost() :
    m_pScriptHostMgr(NULL)
{
}

CScriptHost::~CScriptHost()
{
}

//+-------------------------------------------------------------------
//
//  Member:      ScRunScript
//
//  Synopsis:    Run the given script
//
//  Arguments:   [pMgr]           - Object that manages all CScriptHosts.
//               [strScript]      - The script itself.
//               [strEngineName]  - Script engine name.
//               [rEngineClsid]   - The script engine that runs this script.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHost::ScRunScript(CScriptHostMgr* pMgr, LPCOLESTR pszScriptText,
                            const tstring& strEngineName, const CLSID& rEngineClsid)
{
    DECLARE_SC(sc, _T("CScriptHost::ScRunScript"));

    m_pScriptHostMgr = pMgr;
    sc = ScCheckPointers(m_pScriptHostMgr, E_UNEXPECTED);
    if (sc)
        return sc;

    m_strScriptEngine = strEngineName;
    m_EngineClsid = rEngineClsid;

    // Now create the script engine.
    LPUNKNOWN* pUnknown = NULL;
    sc = CoCreateInstance(m_EngineClsid, NULL, CLSCTX_INPROC_SERVER,
                          IID_IActiveScript, (void **)&m_spActiveScriptEngine);
    if (sc)
        return sc;

    m_spActiveScriptParser = m_spActiveScriptEngine;
    if (NULL == m_spActiveScriptParser)
    {
        m_spActiveScriptEngine = NULL; // Release the engine.
        return (sc = E_FAIL);
    }

    sc = m_spActiveScriptEngine->SetScriptSite(this);
    if (sc)
        return sc;

    sc = m_spActiveScriptParser->InitNew();
    if (sc)
        return sc;

    // Add MMC objects to the top-level.
    sc = m_spActiveScriptEngine->AddNamedItem(MMCObjectName,
                                              SCRIPTITEM_ISSOURCE |
                                              SCRIPTITEM_GLOBALMEMBERS |
                                              SCRIPTITEM_ISVISIBLE);
    if (sc)
    {
        m_spActiveScriptEngine = NULL;
        m_spActiveScriptParser = NULL;
        return sc;
    }

    sc = m_spActiveScriptParser->ParseScriptText(pszScriptText, NULL, NULL, NULL,
                                                 0, 0, 0L, NULL, NULL);
    if (sc)
    {
        m_spActiveScriptEngine = NULL;
        m_spActiveScriptParser = NULL;
        return sc;
    }

    sc = m_spActiveScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (sc)
    {
        m_spActiveScriptEngine = NULL;
        m_spActiveScriptParser = NULL;
        return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScStopScript
//
//  Synopsis:    Stop the script engine.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHost::ScStopScript ()
{
    DECLARE_SC(sc, _T("CScriptHost::ScStopScript"));

    sc = ScCheckPointers(m_spActiveScriptEngine, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_spActiveScriptEngine->SetScriptState(SCRIPTSTATE_DISCONNECTED);
    sc = m_spActiveScriptEngine->Close();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      GetLCID
//
//  Synopsis:    Return the Lang Id to Script engine.
//
//  Arguments:   [plcid] - Language Identifier.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetLCID( LCID *plcid)
{
    DECLARE_SC(sc, _T("CScriptHost::GetLCID"));
    sc = ScCheckPointers(plcid);
    if (sc)
        return sc.ToHr();

    *plcid = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      GetItemInfo
//
//  Synopsis:    Return IUnknown or ITypeInfo of the item added using
//               IActiveScript::AddNamedItem. Called by script engine.
//
//  Arguments:   [pstrName]     - The item that was added.
//               [dwReturnMask] - Request (IUnknown or ITypeInfo).
//               [ppunkItem]    - IUnknown returned if requested.
//               [ppTypeInfo]   - ITypeInfo returned if requested.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetItemInfo( LPCOLESTR pstrName, DWORD dwReturnMask,
                                    IUnknown **ppunkItem, ITypeInfo **ppTypeInfo)
{
    DECLARE_SC(sc, _T("CScriptHost::GetItemInfo"));

    // The IUnknown** & ITypeInfo** can be NULL.
    if (ppunkItem)
        *ppunkItem = NULL;

    if (ppTypeInfo)
        *ppTypeInfo = NULL;

    // Make sure it is our object being requested.
    if (_wcsicmp(MMCObjectName, pstrName))
        return (sc = TYPE_E_ELEMENTNOTFOUND).ToHr();

    sc = ScCheckPointers(m_pScriptHostMgr, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (ppunkItem)
        {
            sc = m_pScriptHostMgr->ScGetMMCObject(ppunkItem);
            if (sc)
                return sc.ToHr();

            (*ppunkItem)->AddRef();
        }
        else
            return (sc = E_POINTER).ToHr();
    }


    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (ppTypeInfo)
        {
            sc = m_pScriptHostMgr->ScGetMMCTypeInfo(ppTypeInfo);
            if (sc)
                return sc.ToHr();

            (*ppTypeInfo)->AddRef();
        }
        else
            return  (sc = E_POINTER).ToHr();

    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      GetDocVersionString
//
//  Synopsis:    This retrieves a host-defined string that uniquely
//               identifies the current script (document) version from
//               the host's point of view. Called by script engine.
//
//  Arguments:   [pbstrVersionString] - The doc version string.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetDocVersionString( BSTR *pbstrVersionString)
{
    DECLARE_SC(sc, _T("CScriptHost::GetDocVersionString"));

    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:      OnScriptTerminate
//
//  Synopsis:    Called by engine when the script has completed execution.
//
//  Arguments:   [pvarResult] - Script results.
//               [pexcepinfo] - Any exceptions generated.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnScriptTerminate( const VARIANT *pvarResult,
                                             const EXCEPINFO *pexcepinfo)
{
    DECLARE_SC(sc, _T("CScriptHost::OnScriptTerminate"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnStateChange
//
//  Synopsis:    Called by engine when its state changes.
//
//  Arguments:   [ssScriptState] - New state.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnStateChange(SCRIPTSTATE ssScriptState)
{
    DECLARE_SC(sc, _T("CScriptHost::OnStateChange"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnScriptError
//
//  Synopsis:    Engine informs that an execution error occurred
//               while it was running the script.
//
//  Arguments:   [pase ] - Host can obtain info about execution
//                         error using this interface.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnScriptError(IActiveScriptError *pase)
{
    DECLARE_SC(sc, _T("CScriptHost::OnScriptError"));
    sc = ScCheckPointers(pase);
    if (sc)
        return sc.ToHr();

    // For test purposes. We need to provide much better debug info,
    // We will hookup the ScriptDebugger for this.
    BSTR bstrSourceLine;
    sc = pase->GetSourceLineText(&bstrSourceLine);

    EXCEPINFO exinfo;
    ZeroMemory(&exinfo, sizeof(exinfo));
    sc = pase->GetExceptionInfo(&exinfo);

    DWORD dwSourceContext = 0;
    ULONG ulLineNumber    = -1;
    LONG  lCharPos        = -1;
    sc = pase->GetSourcePosition(&dwSourceContext, &ulLineNumber, &lCharPos);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnEnterScript
//
//  Synopsis:    Engine informs that it has begun executing script.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnEnterScript(void)
{
    DECLARE_SC(sc, _T("CScriptHost::OnEnterScript"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnEnterScript
//
//  Synopsis:    Engine informs that it has returned from executing script.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnLeaveScript(void)
{
    DECLARE_SC(sc, _T("CScriptHost::OnLeaveScript"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      GetWindow
//
//  Synopsis:    Engine asks for window that can be parent of a popup
//               it can display.
//
//  Arguments:   [phwnd ] - Parent window.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetWindow(HWND *phwnd)
{
    DECLARE_SC(sc, _T("CScriptHost::GetWindow"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      EnableModeless
//
//  Synopsis:    Enables/Disables modelessness of parent window.
//
//  Arguments:   [fEnable ] - Enable/Disable.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::EnableModeless(BOOL fEnable)
{
    DECLARE_SC(sc, _T("CScriptHost::EnableModeless"));

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	AMC.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF


MAJORCOMP=MMC
MINORCOMP=conui

TARGETNAME=mmc
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=windows


WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

USE_VCCOM      = 1
USE_STL        = 1
USE_STATIC_ATL = 1
ATL_VER        = 30
USE_WTL        = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
SXS_ASSEMBLY_NAME                 = Microsoft.Windows.MMC
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT = 1
SXS_MANIFEST                      = mmc.manifest
SXS_MANIFEST_IN_RESOURCES         = 1
SXS_NO_BINPLACE                   = 1
SXS_MANIFEST_RESOURCE_ID          = ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID

C_DEFINES = $(C_DEFINES) -DISOLATION_AWARE_ENABLED
C_DEFINES = $(C_DEFINES) -DSXS_MANIFEST_RESOURCE_ID=$(SXS_MANIFEST_RESOURCE_ID)

#
# Shfusion.lib causes linker warnings. Ignore them.
#
LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217

!if $(FREEBUILD)
# on retail builds we don't want to stack fault, so we reserve 56k of stack
LINKER_STACKCOMMITSIZE = 57344
!else
# on chk builds, we default to 36k so that we can find stack pigs and elimnate them
LINKER_STACKCOMMITSIZE = 36864
!endif

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
   $(SDK_LIB_PATH)\mmc.lib					\
   ..\..\core\$(CharWidth)\$(O)\uicore.lib	\
   ..\..\base\$(CharWidth)\$(O)\mmcbase.lib

# We need $(SHELL_LIB_PATH)\shlwapip.lib for ualstr*
TARGETLIBS = \
   $(SDK_LIB_PATH)\kernel32.lib 	\
   $(SDK_LIB_PATH)\user32.lib   	\
   $(SDK_LIB_PATH)\oleaut32.lib 	\
   $(SDK_LIB_PATH)\ole32.lib    	\
   $(SDK_LIB_PATH)\oleacc.lib   	\
   $(SDK_LIB_PATH)\advapi32.lib 	\
   $(SDK_LIB_PATH)\uuid.lib     	\
   $(SDK_LIB_PATH)\comdlg32.lib 	\
   $(SDK_LIB_PATH)\HtmlHelp.lib 	\
   $(SDK_LIB_PATH)\shell32.lib		\
   $(SHELL_LIB_PATH)\shlwapip.lib	\
   $(SHELL_LIB_PATH)\shfusion.lib	\


!if exist (..\..\PrivateBranch.inc)
!include   ..\..\PrivateBranch.inc
!endif

!ifndef __PublishedDir
__PublishedDir = mmc
!endif

TLBDir = $(PROJECT_ROOT)\published\$(__PublishedDir)\$(O)

# We need $(SHELL_INC_PATH) for uastrfnc.h
# We need $(BASE_INC_PATH) for wow64t.h
INCLUDES = \
	..\;					\
	..\..\base;				\
	..\..\inc;              \
	..\..\types\idl\$(O);   \
	$(TLBDir);				\
	$(SHELL_INC_PATH);		\
	$(BASE_INC_PATH);		\

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX =     1

# This target is required so $(O)\amc.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$(O)\amc.res: \
	..\..\types\idl\$(O)\websnk.tlb	\
	$(TLBDir)\mmcobj.tlb        	\
	..\html\glyph100.eot        	\
	..\html\glyph110.eot        	\
	..\html\break.htm           	\
	..\html\default.htm         	\
	..\html\error.htm           	\
	..\html\horiz.htm           	\
	..\html\listpad.htm         	\
	..\html\reload.htm          	\
	..\html\reload2.htm         	\
	..\html\reload3.htm         	\
	..\res\commontb.bmp         	\
	..\res\commontb_rtl.bmp        	\
	..\res\hand.cur             	\
	..\res\mmc.ico              	\
	..\res\mmc.ico              	\
	..\res\nodes16.bmp          	\
	..\res\nodes32.bmp          	\
	..\res\sort.bmp					\

SOURCES = \
	..\amc.rc               		\
	..\amc.cpp              		\
	..\amcdoc.cpp           		\
	..\amcdocmg.cpp         		\
	..\amcview.cpp          		\
	..\archpicker.cpp       		\
	..\caption.cpp          		\
	..\cclvctl.cpp          		\
	..\childfrm.cpp         		\
	..\controls.cpp         		\
	..\dd.cpp               		\
	..\docksite.cpp         		\
	..\evtsink.cpp          		\
	..\favorite.cpp         		\
	..\favui.cpp            		\
	..\filedlgex.cpp            	\
	..\fontlink.cpp         		\
	..\ftab.cpp             		\
	..\histlist.cpp         		\
	..\idle.cpp             		\
	..\kbdnav.cpp					\
	..\mainfrm.cpp          		\
	..\mdiclint.cpp         		\
	..\mdiuisim.cpp         		\
	..\menubar.cpp          		\
	..\menubtns.cpp         		\
	..\mmcaxwin.cpp         		\
	..\mscparser.cpp        		\
	..\ocxview.cpp          		\
	..\props.cpp            		\
	..\scripthost.cpp       		\
	..\scriptevents.cpp     		\
	..\statbar.cpp          		\
	..\stdbar.cpp           		\
	..\stringutil.cpp       		\
	..\strtable.cpp         		\
	..\subclass.cpp         		\
	..\svfildlg.cpp         		\
	..\sysmenu.cpp          		\
	..\taskhost.cpp         		\
	..\tbtrack.cpp          		\
	..\toolbar.cpp          		\
	..\treectrl.cpp         		\
	..\trobimpl.cpp         		\
	..\vwtrack.cpp          		\
	..\webctrl.cpp          		\
	..\wrapper.cpp					\




MISCFILES = \
        ..\Microsoft_Management_Console_(MMC)_{386FE156-EDEB-4687-9AF0-7B24E6DE4EA4}.sld
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\scriptevents.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      scriptevents.cpp
//
//  Contents:  Implementation of script events thru connection points
//
//  History:   11-Feb-99 AudriusZ    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "scriptevents.h"

// Traces
#ifdef DBG
    CTraceTag  tagComEvents(_T("Events"), _T("COM events"));
#endif


/***************************************************************************\
 *
 * METHOD:  CEventDispatcherBase::SetContainer
 *
 * PURPOSE: Accesory function. Sets Connection point container 
 *          to be used for getting the sinks
 *
 * PARAMETERS:
 *    LPUNKNOWN pComObject - pointer to COM object - event source (NULL is OK)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CEventDispatcherBase::SetContainer(LPUNKNOWN pComObject)
{
    // It makes difference to us if the object pointer is NULL
    // (that means there are no com object , and that's OK)
    // Or QI for IConnectionPointContainer will fail
    // (that means an error)
    m_bEventSourceExists = !(pComObject == NULL);
    if (!m_bEventSourceExists)
        return;

    // note it's not guaranteed here m_spContainer won't be NULL
    m_spContainer = pComObject;
}

/***************************************************************************\
 *
 * METHOD:  CEventDispatcherBase::ScInvokeOnConnections
 *
 * PURPOSE: This method will iterate thu sinks and invoke
 *          same method on each ot them
 *
 * PARAMETERS:
 *    REFIID riid           - GUID of disp interface
 *    DISPID dispid         - disp id
 *    CComVariant *pVar     - array of parameters (may be NULL)
 *    int count             - count of items in pVar
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventDispatcherBase::ScInvokeOnConnections(REFIID riid, DISPID dispid, CComVariant *pVar, int count, CEventBuffer& buffer) const
{
    DECLARE_SC(sc, TEXT("CEventDispatcherBase::ScInvokeOnConnections"));

    // the pointer to event source passed is NULL,
    // that means there is no event source - and no event sinks connected
    // thus we are done at this point
    if (!m_bEventSourceExists)
        return sc;

    // check if com object supports IConnectionPointContainer;
    // Bad pointer ( or to bad object ) if it does not
    sc = ScCheckPointers(m_spContainer, E_NOINTERFACE);
    if (sc)
        return sc;

    // get connection point
    IConnectionPointPtr spConnectionPoint;
    sc = m_spContainer->FindConnectionPoint(riid, &spConnectionPoint);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spConnectionPoint, E_UNEXPECTED);
    if (sc)
        return sc;

    // get connections
    IEnumConnectionsPtr spEnumConnections;
    sc = spConnectionPoint->EnumConnections(&spEnumConnections);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spEnumConnections, E_UNEXPECTED);
    if (sc)
        return sc;

    // reset iterator
    sc = spEnumConnections->Reset();
    if (sc)
        return sc;

    // iterate thru sinks until Next returns S_FALSE.
    CONNECTDATA connectdata;
    SC sc_last_error;
    while (1) // will use <break> to exit
    {
        // get the next sink
        ZeroMemory(&connectdata, sizeof(connectdata));
        sc = spEnumConnections->Next( 1, &connectdata, NULL );
        if (sc)
            return sc;

        // done if no more sinks
        if (sc == SC(S_FALSE))
            break;

        // recheck the pointer
        sc = ScCheckPointers(connectdata.pUnk, E_UNEXPECTED);
        if (sc)
            return sc;

        // QI for IDispatch
        IDispatchPtr spDispatch = connectdata.pUnk;
        connectdata.pUnk->Release();

        // recheck the pointer
        sc = ScCheckPointers(spDispatch, E_UNEXPECTED);
        if (sc)
            return sc;

        // if events are locked by now, we need to postpone the call
        // else - emit it
        sc = buffer.ScEmitOrPostpone(spDispatch, dispid, pVar, count);
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
        }
    }
    
    // we succeeded, but sinks may not,
    // report the error (if one happened)
    return sc_last_error;
}


/***************************************************************************\
 *
 * METHOD:  CEventDispatcherBase::ScHaveSinksRegisteredForInterface
 *
 * PURPOSE: Checks if there are any sinks registered with interface
 *          Function allows perform early check to skip com object creation
 *          fo event parameters if event will go nowere anyway
 *
 * PARAMETERS:
 *    const REFIID riid - interface id
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventDispatcherBase::ScHaveSinksRegisteredForInterface(const REFIID riid)
{
    DECLARE_SC(sc, TEXT("CEventDispatcherBase::ScHaveSinksRegisteredForInterface"));

    // the pointer to event source passed is NULL,
    // that means there is no event source - and no event sinks connected
    if (!m_bEventSourceExists)
        return sc = S_FALSE;

    // check if com object supports IConnectionPointContainer;
    // Bad pointer ( or to bad object ) if it does not
    sc = ScCheckPointers(m_spContainer, E_NOINTERFACE);
    if (sc)
        return sc;

    // get connection point
    IConnectionPointPtr spConnectionPoint;
    sc = m_spContainer->FindConnectionPoint(riid, &spConnectionPoint);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spConnectionPoint, E_UNEXPECTED);
    if (sc)
        return sc;

    // get connections
    IEnumConnectionsPtr spEnumConnections;
    sc = spConnectionPoint->EnumConnections(&spEnumConnections);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spEnumConnections, E_UNEXPECTED);
    if (sc)
        return sc;

    // reset iterator
    sc = spEnumConnections->Reset();
    if (sc)
        return sc;

    // get first member. Will return S_FALSE if no items in collection
    CONNECTDATA connectdata;
    ZeroMemory(&connectdata, sizeof(connectdata));
    sc = spEnumConnections->Next( 1, &connectdata, NULL );
    if (sc)
        return sc;

    // release the data
    if (connectdata.pUnk)
        connectdata.pUnk->Release();

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\statbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statbar.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "StatBar.h"
#include "amcmsgid.h"

// CODEWORK message reflection not working yet


// Set the default upper and lower bounds since these are the default values used in CProgressCtrl
CAMCProgressCtrl::CAMCProgressCtrl() : CProgressCtrl()
{
    nLower = 0;
    nUpper = 100;
}

// Set the default upper and lower bounds before setting the range in the base class
void
CAMCProgressCtrl::SetRange( int nNewLower, int nNewUpper )
{
    if ((nLower != nNewLower) || (nUpper != nNewUpper))
    {
        nLower = nNewLower;
        nUpper = nNewUpper;

        /*
         * MFC 4.2 doesn't define SetRange32, so do it the old-fashioned way
         */
        SendMessage (PBM_SETRANGE32, nNewLower, nNewUpper);
    }
}

// Retrieve the range
void
CAMCProgressCtrl::GetRange( int * nGetLower, int * nGetUpper )
{
    *nGetLower = nLower;
    *nGetUpper = nUpper;
}

// Display the progress bar whenever the position is being set
int
CAMCProgressCtrl::SetPos(int nPos)
{
	/*
	 * Theming:  When navigation is concluded, the web browser will set a
	 * 0 position, with a range of (0,0).  This would leave the progress
	 * control visible, but not distiguishable from the status bar because
	 * the status bar and the progress bar had the same background.  When
	 * themes are enabled, the progress bar is distinguishable because the
	 * themed progress bar has a different background from the status bar.
	 * See bug 366817.
	 *
	 * The fix is to only show the progress bar if there's a non-empty range.
	 */
	bool fShow = (nUpper != nLower);
    ShowWindow (fShow ? SW_SHOW : SW_HIDE);

    return CProgressCtrl::SetPos(nPos);
}

IMPLEMENT_DYNAMIC(CAMCStatusBar, CStatBar)

BEGIN_MESSAGE_MAP(CAMCStatusBar, CStatBar)
    //{{AFX_MSG_MAP(CAMCStatusBar)
    ON_WM_CREATE()
    ON_WM_SIZE()
	//}}AFX_MSG_MAP

    ON_WM_SETTINGCHANGE()
    ON_MESSAGE (WM_SETTEXT, OnSetText)
    ON_MESSAGE (SB_SETTEXT, OnSBSetText)
END_MESSAGE_MAP()

const TCHAR CAMCStatusBar::DELINEATOR[] = TEXT("|");
const TCHAR CAMCStatusBar::PROGRESSBAR[] = TEXT("%");

CAMCStatusBar::CAMCStatusBar()
{
}

CAMCStatusBar::~CAMCStatusBar()
{
    CSingleLock lock( &m_Critsec );
    POSITION pos = m_TextList.GetHeadPosition();
    while ( NULL != pos )
    {
        delete m_TextList.GetNext( pos );
    }
    m_TextList.RemoveAll();
}


void CAMCStatusBar::Parse(LPCTSTR strText)
{
    m_progressControl.ShowWindow(SW_HIDE);
    CString str[eStatusFields];
    int i;

    if (strText != NULL)
    {
        str[0] = strText;
        str[0].TrimLeft();
        str[0].TrimRight();
    }

    // If there is no text to display
    if (str[0].IsEmpty())
    {
        // Set the variable to designate this
        m_iNumStatusText = 0;
        // Wipe the rest of the panes
        for (i = 0; i < eStatusFields; i++)
            SetPaneText(i, NULL );
    }
    else
    {
        m_iNumStatusText = 0xffff;
        int iLocationDelin = 0;

        // Dissect the string into parts to be displayed in appropriate windows
        for (i = 0; (i < eStatusFields) &&
            ((iLocationDelin = str[i].FindOneOf(DELINEATOR)) > -1);
            i++)
        {
            if (i < eStatusFields - 1)
            {
                str[i+1] = str[i].Mid(iLocationDelin + 1);

                /*
                 * trim leading whitespace (trailing whitespace
                 * should have been trimmed already)
                 */
                str[i+1].TrimLeft();
                ASSERT (str[i+1].IsEmpty() || !_istspace(str[i+1][str[i+1].GetLength()-1]));
            }

            str[i] = str[i].Left( iLocationDelin );

            /*
             * trim trailing whitespace (leading whitespace
             * should have been trimmed already)
             */
            str[i].TrimRight();
            ASSERT (str[i].IsEmpty() || !_istspace(str[i][0]));
        }

        // If the progress bar is being displayed

        if ((str[1].GetLength() > 1) && (str[1].FindOneOf(PROGRESSBAR) == 0))
        {
            if (str[1][0] == str[1][1])
                str[1] = str[1].Mid(1);
            else
            {
                int val = _ttoi(str[1].Mid(1));
                m_progressControl.SetRange(0, 100);
                m_progressControl.SetPos(val);
                m_iNumStatusText &= ~(0x2);
            }
        }

        // Display the text in the panes (which wipes them if necessary)
        for (i = 0; i < eStatusFields; i++)
            if (m_iNumStatusText & (1 << i))
                SetPaneText(i, str[i]);
    }
}

void CAMCStatusBar::Update()
{
    // keep copy of string to avoid WIN32 operations while holding critsec
    CString str;
    {
        CSingleLock lock( &m_Critsec );
        if ( !m_TextList.IsEmpty() )
        {
            CString* pstr = m_TextList.GetHead();
            ASSERT( pstr != NULL );
            str = *pstr;
        }
    }

    if (str.IsEmpty())
        GetParentFrame()->SendMessage (WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
    else
        Parse(str);
}

int CAMCStatusBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CStatBar::OnCreate(lpCreateStruct) == -1)
        return -1;

    // Create the progres bar control as a child of the status bar
    CRect rect(0,0,0,0);
    m_progressControl.Create(PBS_SMOOTH|WS_CLIPSIBLINGS|WS_CHILD|WS_VISIBLE, rect, this, 0x1000);
    m_staticControl.Create(_T(""), WS_CLIPSIBLINGS|WS_CHILD|WS_VISIBLE|SS_SIMPLE, rect, this, 0x1001);

    // Remove the static edge, hide the window and display a changes frame
    m_progressControl.ModifyStyleEx(WS_EX_STATICEDGE, 0, SWP_HIDEWINDOW | SWP_FRAMECHANGED);

    SetStatusBarFont();

    return 0;
}

void CAMCStatusBar::OnSize(UINT nType, int cx, int cy)
{
    CStatBar::OnSize(nType, cx, cy);

    // Get the width of the first pane for position and get the width of the pane
    // to set the width of the progress bar
    CRect textRect, progressRect, staticRect;
    GetItemRect(0, &textRect);
    GetItemRect(1, &progressRect);
    GetItemRect(2, &staticRect);

    progressRect.InflateRect(-2, -2);
    staticRect.InflateRect(-2, -2);

    int pane1Width = textRect.Width();      // (Text area) add two for the border
    int pane2Width = progressRect.Width();  // (Progress area) add two for the border
    const int BORDER = 4;

    // size the progress bar
    if (IsWindow (m_progressControl))
        m_progressControl.SetWindowPos(NULL, pane1Width + BORDER, BORDER, pane2Width,
                                            progressRect.Height(),
                                            SWP_FRAMECHANGED |
                                            SWP_NOREPOSITION |
                                            SWP_NOZORDER);

    // size the static control
    if (IsWindow (m_staticControl))
        m_staticControl.SetWindowPos(NULL, pane1Width + pane2Width + (2*BORDER), BORDER, staticRect.Width(),
                                            staticRect.Height(),
                                            SWP_FRAMECHANGED |
                                            SWP_NOREPOSITION |
                                            SWP_NOZORDER);
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CAMCStatusBar.
 *--------------------------------------------------------------------------*/

void CAMCStatusBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    Default();

    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        // the system status bar font may have changed; update it now
        SetStatusBarFont();
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::OnSetText
 *
 * WM_SETTEXT handler for CAMCStatusBar.
 *--------------------------------------------------------------------------*/

LRESULT CAMCStatusBar::OnSetText (WPARAM, LPARAM lParam)
{
    Parse (reinterpret_cast<LPCTSTR>(lParam));
    return (TRUE);
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::OnSBSetText
 *
 * SB_SETTEXT handler for CAMCStatusBar.
 *--------------------------------------------------------------------------*/

LRESULT CAMCStatusBar::OnSBSetText (WPARAM wParam, LPARAM)
{
    return (Default());
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::SetStatusBarFont
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCStatusBar::SetStatusBarFont ()
{
    /*
     * delete the old font
     */
    m_StaticFont.DeleteObject ();

    /*
     * query the system for the current status bar font
     */
    NONCLIENTMETRICS    ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    /*
     * use it here, too;  we need to set the font for the embedded static
     * control, but the status bar window will take care of itself
     */
    m_StaticFont.CreateFontIndirect (&ncm.lfStatusFont);
    m_staticControl.SetFont (&m_StaticFont, false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\statbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statbar.h
//
//--------------------------------------------------------------------------

#ifndef _STATBAR_H
#define _STATBAR_H

#ifndef __DOCKSITE_H__
#include "docksite.h"
#endif

class CAMCProgressCtrl : public CProgressCtrl
{
public:
    CAMCProgressCtrl();

    void SetRange( int nLower, int nUpper );
    void GetRange( int * nLower, int * nUpper );
    int  SetPos  ( int nPos);

private:
    int nLower, nUpper;
};

class CAMCStatusBar : public CStatBar
{
    DECLARE_DYNAMIC (CAMCStatusBar)

    static const TCHAR DELINEATOR[]; 
    static const TCHAR PROGRESSBAR[];

    enum eFieldSize
    {
        eStatusFields = 3  
    };

// Constructor/Destructors
public:
    CAMCStatusBar(); 
    ~CAMCStatusBar();

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCStatusBar)
    //}}AFX_VIRTUAL

// usable only by CAMCStatusBarText
protected:
    //{{AFX_MSG(CAMCStatusBar)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG

    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LPARAM OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg LPARAM OnSBSetText(WPARAM wParam, LPARAM lParam);

public:
    DECLARE_MESSAGE_MAP()

// Progress bar child control
public:
    CAMCProgressCtrl    m_progressControl;
    CStatic             m_staticControl;

// internal
private:
    CTypedPtrList<CPtrList, CString*> m_TextList;
    CCriticalSection m_Critsec;
    DWORD m_iNumStatusText;
    CFont   m_StaticFont;

    void Update();
    void Parse(LPCTSTR strText);
    void SetStatusBarFont();

public:
    CAMCProgressCtrl* GetStatusProgressCtrlHwnd()
        { return (&m_progressControl); }

    CStatic* GetStatusStaticCtrlHwnd()
        { return (&m_staticControl); }
};

#endif  // _STATBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      stdafx.h
//
//  Contents:  PCH for AMC
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Added #include for template support
//
//--------------------------------------------------------------------------
#pragma warning(disable: 4786)      // symbol greater than 255 characters
#pragma warning(disable: 4291)      // 'placement new': no matching operator delete found; memory will not be freed if initialization throws an exception

#define VC_EXTRALEAN	    // Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERTMSG
#undef ASSERT

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <mmctempl.h>       // MFC Template classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcview.h>       // MFC CListView & CTreeView classes
#include <afxpriv.h>        // used for OLE2T T2OLE conversions
#include <afxmt.h>          // CCriticalSection
#include <afxole.h>         // MFC OLE classes

#if (_WIN32_WINNT < 0x0500)
#include <multimon.h>       // multiple monitor support
#endif

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <objidl.h>         // OLE interface definitions

/*----------------------------------------------------------*/
/* include the STL headers that define operator new() here, */
/* so we don't run into trouble with DEBUG_NEW below        */
/*----------------------------------------------------------*/
#include <new>
#include <memory>


#define SIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))


#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//############################################################################
//############################################################################
//
// STL and  other classes
//
//############################################################################
//############################################################################

#include <set>
#include <map>
#include <vector>
#include <list>
#include <deque>
#include <queue>
#include <stack>
#include <algorithm>
#include <iterator>


//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include <mmc.h>
#include <ndmgr.h>          // include file built by MIDL from ndmgr.idl
#include <ndmgrpriv.h>


//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "dbg.h"            // Debug helper
#include "cstr.h"
#include "mmcdebug.h"
#include "mmcerror.h"

#pragma warning(disable: 4068)      // unknown pragma
#include "atlconui.h"
#pragma warning(default: 4068)

#include "tiedobj.h"
#include "comerror.h"
#include "events.h"
#include "comobjects.h"
#include "enumerator.h"
#include "autoptr.h"

//############################################################################
//############################################################################
//
// include common and conui-only strings.
//
//############################################################################
//############################################################################
#include "..\base\basestr.h"
#include "..\base\conuistr.h"

#include "stringutil.h"
//############################################################################
//############################################################################
//
// Debug support for legacy traces.
//
//############################################################################
//############################################################################
#undef TRACE

#ifdef DBG

#define TRACE TraceConuiLegacy

#else // DBG

#define TRACE               ;/##/

#endif DBG

//############################################################################
//############################################################################
//
// Misc functions
//
//############################################################################
//############################################################################
void DrawBitmap(HDC hWnd, int nID, CRect& rc, BOOL bStretch);

// Project specific includes
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "docksite.h"
#include "Controls.h"
#include "mmcptrs.h"
#include "wrapper.h"
#include "countof.h"
#include "cpputil.h"
#include "stlstuff.h"
#include "bookmark.h"
#include "serial.h"
#include "xmlbase.h"
#include "resultview.h"
#include "mmcdata.h"
#include "viewset.h"
#include "memento.h"
#include "objmodelptrs.h"
#include "macros.h"

//############################################################################
//############################################################################
//
// Headers included from conui
//
//############################################################################
//############################################################################
#include "resource.h"       // main symbols
#include "helparr.h"
#include "idle.h"
#include "conuiobservers.h"
#include "mmcaxwin.h"

//############################################################################
//############################################################################
//
// Miscellaneous
//
//############################################################################
//############################################################################

#include <shfusion.h>

class CThemeContextActivator
{
public:
	CThemeContextActivator() : m_ulActivationCookie(0)
		{ SHActivateContext (&m_ulActivationCookie); }

   ~CThemeContextActivator()
		{ SHDeactivateContext (m_ulActivationCookie); }

private:
	ULONG_PTR	m_ulActivationCookie;
};

// from afxpriv.h
extern void AFXAPI AfxSetWindowText(HWND, LPCTSTR);


inline bool IsKeyPressed (int nVirtKey)
{
    return (GetKeyState (nVirtKey) < 0);
}

template<typename T>
inline T abs (const T& t)
{
    return ((t < 0) ? -t : t);
}


/*
 * Define some handy message map macros that afxmsg_.h doesn't define for us
 */
#define ON_WM_SETTEXT() \
    { WM_SETTEXT, 0, 0, 0, AfxSig_vs, \
        (AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(LPTSTR))&OnSetText },
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\scripthost.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ScriptHost.h
//
//              Script Hosting implementation.
//
//--------------------------------------------------------------------------
#ifndef SCRIPTHOST_H
#define SCRIPTHOST_H
#include "activscp.h"
#include "tstring.h"

#define  SCRIPT_ENGINE_KEY   _T("ScriptEngine")
#define  CLSIDSTR            _T("CLSID")

class CScriptHost;

//+-------------------------------------------------------------------
//
//  class:     CScriptHostMgr
//
//  Purpose:   Manages all the script hosts (CScriptHost). Owned by
//             CAMCApp which calls ScExecuteScript.
//
//  History:   11-05-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CScriptHostMgr
{
public:
    CScriptHostMgr(LPDISPATCH pDispatch);
    ~CScriptHostMgr();

public:
    // Accessors.
    SC ScGetMMCObject(LPUNKNOWN *ppunkItem);
    SC ScGetMMCTypeInfo(LPTYPEINFO *ppTypeInfo);

    // Members to run a script.
    SC ScExecuteScript(const tstring& strFileName);
    SC ScExecuteScript(LPOLESTR pszScriptText, const tstring& strExtn);

private:
    SC ScLoadScriptFromFile (const tstring& strFileName, LPOLESTR* pszScriptText);
    SC ScDestroyScriptHosts();
    SC ScGetScriptEngine(const tstring& strFileName, tstring& strScriptEngine, CLSID& rClsidEngine);
    SC ScGetScriptEngineFromExtn(const tstring& strFileExtn, tstring& strScriptEngine, CLSID& rClsidEngine);
    SC ScExecuteScriptHelper(LPCOLESTR pszScriptText, const tstring strScriptEngine, const CLSID& EngineClsid);

private:
    typedef std::map<tstring, tstring> ScriptExtnToScriptEngineNameMap;
    ScriptExtnToScriptEngineNameMap    m_ScriptExtnToScriptEngineNameMap;

    typedef std::map<tstring, CLSID>   ScriptExtnToScriptEngineMap;
    ScriptExtnToScriptEngineMap        m_ScriptExtnToScriptEngineMap;

    typedef std::vector<IUnknownPtr>   ArrayOfScriptHosts;
    ArrayOfScriptHosts                 m_ArrayOfHosts;

    IDispatchPtr                       m_spMMCObjectDispatch;
    ITypeInfoPtr                       m_spMMCObjectTypeInfo;
};

//+-------------------------------------------------------------------
//
//  class:     CScriptHost
//
//  Purpose:   Script Host (executes a single script).
//
//  History:   11-05-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CScriptHost : public CComObjectRoot,
                    public IActiveScriptSite,
                    public IActiveScriptSiteWindow
{
private:
    CScriptHost(const CScriptHost&);

public:
    CScriptHost();
    ~CScriptHost();

public:
// ATL COM map
BEGIN_COM_MAP(CScriptHost)
    COM_INTERFACE_ENTRY(IActiveScriptSite)
    COM_INTERFACE_ENTRY(IActiveScriptSiteWindow)
END_COM_MAP()

    SC ScRunScript(CScriptHostMgr* pMgr, LPCOLESTR pszScriptText,
                   const tstring& strScriptEngine, const CLSID& rEngineClsid);

    SC ScStopScript();

    // IActiveScriptSite methods.
   STDMETHOD(GetLCID)            ( LCID *plcid);
   STDMETHOD(GetItemInfo)        ( LPCOLESTR pstrName, DWORD dwReturnMask,
                                   IUnknown **ppunkItem, ITypeInfo **ppTypeInfo);
   STDMETHOD(GetDocVersionString)( BSTR *pbstrVersionString);
   STDMETHOD(OnScriptTerminate)  ( const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo);
   STDMETHOD(OnStateChange)      (SCRIPTSTATE ssScriptState);
   STDMETHOD(OnScriptError)      (IActiveScriptError *pase);
   STDMETHOD(OnEnterScript)      (void);
   STDMETHOD(OnLeaveScript)      (void);

   // IActiveScriptSiteWindow methods.
   STDMETHOD(GetWindow)          (HWND *phwnd);
   STDMETHOD(EnableModeless)     (BOOL fEnable);

private:
    tstring               m_strScriptEngine;
    CLSID                 m_EngineClsid;
    CScriptHostMgr*       m_pScriptHostMgr;

    IActiveScriptPtr      m_spActiveScriptEngine;
    IActiveScriptParsePtr m_spActiveScriptParser;
};

#endif SCRIPTHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\stringutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      string.cpp
//
//  Contents:  Utility functions for the CString class
//
//  History:   10-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------


// a function to load strings from the string module, not the AfxModule
BOOL    LoadString(CString &str, UINT nID);
void    FormatStrings(CString& rString, UINT nIDS, LPCTSTR const* rglpsz, int nString);
void    FormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void    FormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1, LPCTSTR lpsz2);

// make sure that the MMC functions replace the MFC ones.
#define AfxFormatString1  FormatString1
#define AfxFormatString2  FormatString2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\stdbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdbar.h
//
//              Standard toolbar implementation.
//
//--------------------------------------------------------------------------
#ifndef STDBAR_H__
#define STDBAR_H__
#include "toolbars.h"

#define  MMC_TOOLBTN_COLORREF RGB(255, 0, 255)

//+-------------------------------------------------------------------
//
//  class:     CStandardToolbar
//
//  Purpose:   Standard toolbar implementation.
//
//  History:    10-25-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CStandardToolbar : public CToolbarNotify,
                         public CStdVerbButtons
{
public:
    CStandardToolbar();
    ~CStandardToolbar();

    SC ScInitializeStdToolbar(CAMCView* pAMCView);

    // The following methods are used by CAMCView.
    SC ScEnableExportList(bool bEnable);
    SC ScEnableUpOneLevel(bool bEnable);
    SC ScEnableContextHelpBtn(bool bEnable);
    SC ScEnableScopePaneBtn(bool bEnable = true);
    SC ScCheckScopePaneBtn(bool bChecked);
    SC ScShowStdBar(bool bShow);
    SC ScEnableButton(INT nID, bool bState);
    SC ScEnableAndShowButton(INT nID, bool bEnableAndShow); // Instead of disabling hide it.

    // CStdVerbButtons implementation (used by nodemgr to update verbs).
    virtual SC ScUpdateStdbarVerbs(IConsoleVerb* pCV);
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, IConsoleVerb* pCV = NULL);
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE nState, BOOL bFlag);
    virtual SC ScShow(BOOL bShow);

public:
    // CToolbarNotify implementation (used by CToolbarsMgr to notify about button click).
    virtual SC ScNotifyToolBarClick(HNODE hNode, bool bScope, LPARAM lParam, UINT nID);
    virtual SC ScAMCViewToolbarsBeingDestroyed();

private:
    CMMCToolbarIntf*  m_pToolbarUI;        // Toolbar UI interface.
    CAMCView*         m_pAMCView;          // View owner.

    typedef std::map<INT, INT> MMCVerbCommandIDs;
    MMCVerbCommandIDs       m_MMCVerbCommandIDs;

    SC ScAddToolbarButtons(int nCnt, MMCBUTTON* pButtons);
};

#endif STDBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\stdbar.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdbar.cpp
//
//  Contents:   Standard toolbar implementation.
//
//  History:    10/22/1999   AnandhaG   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "stdbar.h"
#include "amcview.h"
#include "toolbar.h"
#include "util.h"       // GetTBBtnTextAndStatus()

using namespace std;

/*
 * These are used only to give the separators unique IDs, so automatic
 * separator handling will work (see AssertSeparatorsAreValid).
 */
enum
{
    ID_Separator1 = 1,
    ID_Separator2,
    ID_Separator3,
    ID_Separator4,
    ID_Separator5,
    ID_Separator6,
    ID_Separator7,
    ID_Separator8,
    ID_Separator9,

    // must be last
    ID_SeparatorFirst = ID_Separator1,
    ID_SeparatorLast  = ID_Separator9,
    ID_SeparatorMax   = ID_SeparatorLast,
};

static MMCBUTTON CommonButtons[] =
{
    { 0, IDS_MMC_WEB_BACK         , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    { 1, IDS_MMC_WEB_FORWARD      , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator1            , 0,               TBSTYLE_SEP   , NULL, NULL },
    { 9, IDS_MMC_GENL_UPONELEVEL  , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    {10, IDS_MMC_GENL_SCOPE       , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator2            , 0,               TBSTYLE_SEP   , NULL, NULL },
    { 5, IDS_MMC_VERB_CUT         , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 6, IDS_MMC_VERB_COPY        , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 7, IDS_MMC_VERB_PASTE       , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator3            , 0,               TBSTYLE_SEP   , NULL, NULL },
    {11, IDS_MMC_VERB_DELETE      , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 8, IDS_MMC_VERB_PROPERTIES  , 0,               TBSTYLE_BUTTON, NULL, NULL },
    {12, IDS_MMC_VERB_PRINT       , 0,               TBSTYLE_BUTTON, NULL, NULL },
    {13, IDS_MMC_VERB_REFRESH     , 0,               TBSTYLE_BUTTON, NULL, NULL },
    {16, IDS_SAVE_LIST_BUTTON     , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator4            , 0,               TBSTYLE_SEP   , NULL, NULL },
    {15, IDS_MMC_GENL_CONTEXTHELP , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
};


CStandardToolbar::CStandardToolbar()
   :m_pToolbarUI(NULL), m_pAMCView(NULL)
{
    /*
     * Map helps in determining string id from verb & vice versa.
     */
    m_MMCVerbCommandIDs[MMC_VERB_CUT]        = IDS_MMC_VERB_CUT;
    m_MMCVerbCommandIDs[MMC_VERB_CUT]        = IDS_MMC_VERB_CUT;
    m_MMCVerbCommandIDs[MMC_VERB_COPY]       = IDS_MMC_VERB_COPY;
    m_MMCVerbCommandIDs[MMC_VERB_PASTE]      = IDS_MMC_VERB_PASTE;
    m_MMCVerbCommandIDs[MMC_VERB_DELETE]     = IDS_MMC_VERB_DELETE;
    m_MMCVerbCommandIDs[MMC_VERB_PROPERTIES] = IDS_MMC_VERB_PROPERTIES;
    m_MMCVerbCommandIDs[MMC_VERB_PRINT]      = IDS_MMC_VERB_PRINT;
    m_MMCVerbCommandIDs[MMC_VERB_REFRESH]    = IDS_MMC_VERB_REFRESH;
}

CStandardToolbar::~CStandardToolbar()
{
    DECLARE_SC(sc, TEXT("CStandardToolbar::~CStandardToolbar"));

    // Ask the toolbar UI object to delete itself.
    if (m_pToolbarUI)
    {
        sc = m_pToolbarUI->ScDelete(this);

        if (sc)
            sc.TraceAndClear();
    }

}


//+-------------------------------------------------------------------
//
//  Member:      ScInitializeStdToolbar
//
//  Synopsis:    Initialize the standard toolbar, add bitmap & buttons.
//
//  Arguments:   [pAMCView]  - The CAMCView (owner) of this stdbar.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScInitializeStdToolbar(CAMCView* pAMCView)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScInitializeStdToolbar"));

    if (NULL == pAMCView)
        return (sc = E_UNEXPECTED);

    m_pAMCView = pAMCView;

    SViewData* pViewData = m_pAMCView->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        return sc;
    }


    // Get the toolbars mgr from CAMCView and create the stdandrd toolbar.
    CAMCViewToolbarsMgr* pAMCViewToolbarsMgr = pViewData->GetAMCViewToolbarsMgr();
    if (NULL == pAMCViewToolbarsMgr)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = pAMCViewToolbarsMgr->ScCreateToolBar(&m_pToolbarUI);
    if (sc)
        return sc;
    ASSERT(NULL != m_pToolbarUI);

    // Add the bitmap
    CBitmap cBmp;
    cBmp.LoadBitmap((pAMCView->GetExStyle() & WS_EX_LAYOUTRTL) ? IDB_COMMON_16_RTL : IDB_COMMON_16);

    BITMAP bm;
    cBmp.GetBitmap (&bm);

    int cBitmaps = (bm.bmWidth / BUTTON_BITMAP_SIZE) /*width*/;

    sc = m_pToolbarUI->ScAddBitmap(this, cBitmaps, cBmp, MMC_TOOLBTN_COLORREF);
    if (sc)
        return sc;

    // Add the buttons to the toolbar and then display toolbar
    sc = ScAddToolbarButtons(countof(CommonButtons), CommonButtons);
    if (sc)
        return sc;

    // See if Std bar is allowed or not.
    bool bShowStdbar = (pViewData->m_dwToolbarsDisplayed & STD_BUTTONS);

    sc = bShowStdbar ? m_pToolbarUI->ScAttach(this) : m_pToolbarUI->ScDetach(this);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScAddToolbarButtons
//
//  Synopsis:    Add buttons to standard toolbar.
//
//  Arguments:   [nCnt]     - Number of buttons to be added.
//               [pButtons] - Array of nCnt MMCBUTTONS.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScAddToolbarButtons(int nCnt, MMCBUTTON* pButtons)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScAddToolbarButtons"));

    // Array to store button text & tooltip text.
    wstring szButtonText[countof(CommonButtons)];
    wstring szTooltipText[countof(CommonButtons)];

    USES_CONVERSION;

    HINSTANCE hInst = GetStringModule();

    // get resource strings for all buttons
    for (int i = 0; i < nCnt; i++)
    {
        // We dont want to get text for separators.
        if (pButtons[i].idCommand > ID_SeparatorMax)
        {
            bool bSuccess = GetTBBtnTextAndStatus(hInst,
                                                  pButtons[i].idCommand,
                                                  szButtonText[i],
                                                  szTooltipText[i]);
            if (false == bSuccess)
            {
                return (sc = E_FAIL);
            }

            pButtons[i].lpButtonText = const_cast<LPOLESTR>(szButtonText[i].data());
            pButtons[i].lpTooltipText = const_cast<LPOLESTR>(szTooltipText[i].data());
        }
    }

    // Got the strings, now add buttons.
    sc = m_pToolbarUI->ScAddButtons(this, nCnt, pButtons);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScNotifyToolBarClick
//
//  Synopsis:    Button click handler.
//
//  Arguments:   [hNode]  - The HNODE owner of the view.
//               [bScope] - Focus on scope or result.
//               [lParam] - if result the lParam of focused result item.
//               [nID]    - Button ID that was clicked.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScNotifyToolBarClick(HNODE hNode, bool bScope, LPARAM lParam, UINT nID)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScNotifyToolBarClick"));

    if (NULL == m_pAMCView)
        return (sc = E_UNEXPECTED);

    switch (nID)
    {
        case IDS_MMC_VERB_CUT:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evCut);
            break;

        case IDS_MMC_VERB_COPY:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evCopy);
            break;

        case IDS_MMC_VERB_PASTE:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evPaste);
            break;

        case IDS_MMC_VERB_DELETE:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evDelete);
            break;

        case IDS_MMC_VERB_PROPERTIES:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evProperties);
            break;

        case IDS_MMC_VERB_PRINT:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evPrint);
            break;

        case IDS_MMC_VERB_REFRESH:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evRefresh);
            break;

        case IDS_MMC_GENL_CONTEXTHELP:
            sc = m_pAMCView->ScContextHelp ();
            break;

        case IDS_MMC_GENL_UPONELEVEL:
            sc = m_pAMCView->ScUpOneLevel ();
            break;

        case IDS_MMC_GENL_SCOPE:
            sc = m_pAMCView->ScToggleScopePane ();
            break;

        case IDS_MMC_WEB_BACK:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Back);
            break;

        case IDS_MMC_WEB_FORWARD:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Forward);
            break;

        case IDS_MMC_WEB_STOP:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Stop);
            break;

        case IDS_MMC_WEB_REFRESH:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Refresh);
            break;

        case IDS_MMC_WEB_HOME:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Home);
            break;

        case IDS_SAVE_LIST_BUTTON:
            sc = m_pAMCView->ScSaveList ();
            break;

        default:
            sc = E_UNEXPECTED;
            TraceError(_T("Unknown Standard bar button ID"), sc);
            break;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CStandardToolbar::ScAMCViewToolbarsBeingDestroyed
//
//  Synopsis:    The CAMCViewToolbars object is going away, do not
//               reference that object anymore.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScAMCViewToolbarsBeingDestroyed ()
{
    DECLARE_SC(sc, _T("CStandardToolbar::ScAMCViewToolbarsBeingDestroyed"));

    m_pToolbarUI = NULL;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableButton
//
//  Synopsis:    Enable/Disable given button.
//
//  Arguments:
//               [nID]  - Button ID that should be enabled/disabled.
//               [bool] - Enable or Disable.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableButton(INT nID, bool bState)
{
    SC sc;

    if (NULL == m_pToolbarUI)
        return (sc = E_UNEXPECTED);

    sc = m_pToolbarUI->ScSetButtonState(this, nID, TBSTATE_ENABLED, bState);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableAndShowButton
//
//  Synopsis:    Enable (and show) or disable (and hide) the given button.
//
//  Arguments:
//               [nID]  - Button ID that should be enabled/disabled.
//               [bool] - If true enable else hide.
//
//  Note:        If the button is being disabled hide it.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableAndShowButton(INT nID, bool bEnableAndShow)
{
    DECLARE_SC(sc, _T("CStandardToolbar::ScEnableAndShowButton"));

    sc = ScCheckPointers(m_pToolbarUI, E_UNEXPECTED);
    if (sc)
        return sc;

    // First hide or show the button.
    sc = m_pToolbarUI->ScSetButtonState(this, nID, TBSTATE_HIDDEN,  !bEnableAndShow);
    if (sc)
        return sc;

    // Now enable or disable the button.
    sc = m_pToolbarUI->ScSetButtonState(this, nID, TBSTATE_ENABLED, bEnableAndShow);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableExportList
//
//  Synopsis:    Enable/Disable export-list button.
//
//  Arguments:   [bEnable] - enable/disable.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableExportList(bool bEnable)
{
    // If there are ANY items on the list, enable the button.
    return ScEnableAndShowButton(IDS_SAVE_LIST_BUTTON, bEnable );
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableUpOneLevel
//
//  Synopsis:    Enable/Disable up-one-level button.
//
//  Arguments:   [bEnable] -
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableUpOneLevel(bool bEnable)
{
    return ScEnableAndShowButton(IDS_MMC_GENL_UPONELEVEL, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableContextHelpBtn
//
//  Synopsis:    Enable/Disable help button.
//
//  Arguments:   [bEnable] -
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableContextHelpBtn(bool bEnable)
{
    return ScEnableAndShowButton(IDS_MMC_GENL_CONTEXTHELP, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableScopePaneBtn
//
//  Synopsis:    Enable/Disable scope-pane button.
//
//  Arguments:   [bEnable] -
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableScopePaneBtn(bool bEnable)
{
    return ScEnableAndShowButton(IDS_MMC_GENL_SCOPE, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:      ScCheckScopePaneBtn
//
//  Synopsis:    Set scope button in normal or checked state.
//
//  Arguments:   [bChecked] - BOOL
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScCheckScopePaneBtn(bool bChecked)
{
    SC sc;

    if (NULL == m_pToolbarUI)
        return (sc = E_UNEXPECTED);

    sc = m_pToolbarUI->ScSetButtonState(this, IDS_MMC_GENL_SCOPE, TBSTATE_CHECKED, bChecked);
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScShowStdBar
//
//  Synopsis:    Show or Hide std bar.
//
//  Arguments:   [bShow] - BOOL
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScShowStdBar(bool bShow)
{
    SC sc;

    if (NULL == m_pToolbarUI)
        return (sc = E_UNEXPECTED);

    sc = bShow ? m_pToolbarUI->ScAttach(this) : m_pToolbarUI->ScDetach(this);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerbs
//
//  Synopsis:    Update the toolbuttons of std-verbs.
//
//  Arguments:   [pCV] - the IConsoleVerb that has state of the verb.
//
//  Returns:     SC.
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScUpdateStdbarVerbs(IConsoleVerb* pCV)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScUpdateStdbarVerbs"));

    for (int verb = MMC_VERB_FIRST; verb <= MMC_VERB_LAST; verb++)
    {
        // No toolbar buttons for following verbs.
        if ( (MMC_VERB_OPEN == verb) ||
             (MMC_VERB_RENAME == verb))
             continue;

        sc = ScUpdateStdbarVerb (static_cast<MMC_CONSOLE_VERB>(verb), pCV);
        if (sc)
            return sc;
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update the toolbutton of given std-verbs.
//
//  Arguments:   [cVerb] - the verb (ie: toolbutton) to be updated.
//               [pVC]   - the IConsoleVerb that has state of the verb.
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScUpdateStdbarVerb(MMC_CONSOLE_VERB cVerb, IConsoleVerb* pConsoleVerb /*=NULL*/)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScUpdateStdbarVerb"));

    if (NULL == m_pToolbarUI)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    if (pConsoleVerb == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // No toolbuttons for these verbs.
    if ( (MMC_VERB_OPEN == cVerb) ||
         (MMC_VERB_RENAME == cVerb))
         return sc;

    MMCVerbCommandIDs::iterator it = m_MMCVerbCommandIDs.find(cVerb);
    if (m_MMCVerbCommandIDs.end() == it)
    {
        // Could not find the verb in our map.
        sc = E_UNEXPECTED;
        return sc;
    }

    INT nCommandID = it->second;
    BOOL bFlag = 0;
    pConsoleVerb->GetVerbState(cVerb, HIDDEN, &bFlag);
    sc = m_pToolbarUI->ScSetButtonState(this, nCommandID, TBSTATE_HIDDEN, bFlag);
    if (sc)
        return sc;

    if (bFlag == FALSE)
    {
        // If verb is not hidden then enable/disable it.
        pConsoleVerb->GetVerbState(cVerb, ENABLED, &bFlag);
        sc = m_pToolbarUI->ScSetButtonState(this, nCommandID, TBSTATE_ENABLED, bFlag);

        if (sc)
            return sc;
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update the toolbutton of given std-verb.
//
//  Arguments:   [cVerb]   - the verb (ie: toolbutton) to be updated.
//               [nState]  - the button state to be updated.
//               [bFlag]   - State
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScUpdateStdbarVerb"));

    if (NULL == m_pToolbarUI)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    MMCVerbCommandIDs::iterator it = m_MMCVerbCommandIDs.find(cVerb);
    if (m_MMCVerbCommandIDs.end() == it)
    {
        // Could not find the verb in our map.
        sc = E_UNEXPECTED;
        return sc;
    }

    INT nCommandID = it->second;
    sc = m_pToolbarUI->ScSetButtonState(this, nCommandID, byState, bFlag);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScShow
//
//  Synopsis:    Show/Hide the toolbar.
//
//  Arguments:   [bShow]   - show/hide.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScShow (BOOL bShow)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScShow"));

    if (NULL == m_pToolbarUI)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = m_pToolbarUI->ScShow(this, bShow);
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\strtable.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      strtable.h
 *
 *  Contents:  Interface file for CStringTable
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STRTABLE_H
#define STRTABLE_H
#pragma once

#include <exception>        // for class exception
#include <string>           // for string relational operators
#include "guidhelp.h"       // for GUID relational operators
#include "stgio.h"
#include "strings.h"


#ifdef DBG
#define DECLARE_DIAGNOSITICS()  \
public: void Dump() const;
#else
#define DECLARE_DIAGNOSITICS()  \
public: void Dump() const {}
#endif


#ifdef DBG
extern CTraceTag tagStringTable;
#endif  // DBG


/*--------------------------------------------------------------------------
 * IdentifierRange should be private to CIdentifierPool, but
 * compiler bugs prevent it.
 */
template<class T>
class IdentifierRange
{
public:
    IdentifierRange(T idMin_ = T(), T idMax_ = T())
        : idMin (idMin_), idMax (idMax_)
        { ASSERT (idMin <= idMax); }

    bool operator== (const IdentifierRange<T>& other) const
        { return ((idMin == other.idMin) && (idMax == other.idMax)); }

    bool operator!= (const IdentifierRange<T>& other) const
        { return (!(*this == other.idMin)); }

    T idMin;
    T idMax;
};


template<class T = int>
class CIdentifierPool : public CXMLObject
{
public:
    typedef IdentifierRange<T>  Range;
    typedef std::list<Range>    RangeList;

private:
    friend IStream& operator>> (IStream& stm,       CIdentifierPool<T>& pool);
    friend IStream& operator<< (IStream& stm, const CIdentifierPool<T>& pool);
    virtual void Persist(CPersistor &persistor);
    DEFINE_XML_TYPE(XML_TAG_IDENTIFIER_POOL);

    SC ScInvertRangeList (RangeList& rlInvert) const;

#ifdef DBG
    void DumpRangeList (const RangeList& l) const;
#endif

public:
    DECLARE_DIAGNOSITICS();

    CIdentifierPool (T idMin, T idMax);
    CIdentifierPool (IStream& stm);
    T Reserve();
    bool Release(T idRelease);
    bool IsValid () const;
    bool IsRangeListValid (const RangeList& rl) const;
    SC   ScGenerate (const RangeList& rlUsedIDs);

    static bool AddToRangeList (RangeList& rl, const Range& rangeToAdd);
    static bool AddToRangeList (RangeList& rl, T idAdd);

    class pool_exhausted : public exception
    {
    public:
        pool_exhausted(const char *_S = "pool exhausted") _THROW0()
            : exception(_S) {}
        virtual ~pool_exhausted() _THROW0()
            {}
    };

private:
    RangeList   m_AvailableIDs;
    RangeList   m_StaleIDs;
    T           m_idAbsoluteMin;
    T           m_idAbsoluteMax;
    T           m_idNextAvailable;
};


typedef CIdentifierPool<MMC_STRING_ID>  CStringIDPool;



/*--------------------------------------------------------------------------
 * CEntry and CStoredEntry should be private to CStringTable,
 * but compiler bugs prevent it.
 */

/*
 * represents a string table entry in memory
 */
class CEntry : public CXMLObject
{
    friend class  CStringTable;
    friend class  CStringEnumerator;
    friend struct CompareEntriesByID;
    friend struct CompareEntriesByString;
    friend struct IdentifierReleaser;

    friend IStream& operator>> (IStream& stm,       CEntry& entry);
    friend IStream& operator<< (IStream& stm, const CEntry& entry);

public:
    DECLARE_DIAGNOSITICS();

    CEntry () : m_id(0), m_cRefs(0) {}

    CEntry (const std::wstring& str, MMC_STRING_ID id)
        : m_str(str), m_id(id), m_cRefs(0)
    {}
    virtual LPCTSTR GetXMLType()  {return XML_TAG_STRING_TABLE_STRING;}
    virtual void Persist(CPersistor& persistor);

private:
    /*
     * This ctor is only used by CStringTable when reconstructing
     * the entry from a file.
     */
    CEntry (const std::wstring& str, MMC_STRING_ID id, DWORD cRefs)
        : m_str(str) , m_id(id), m_cRefs(cRefs)
    {}

private:
    bool operator< (const LPCWSTR psz) const
        { return (m_str < psz); }

    bool operator< (const CEntry& other) const
        { return (m_str < other.m_str); }

    bool operator== (const LPCWSTR psz) const
        { return (m_str == psz); }

    bool operator== (const CEntry& other) const
        { return (m_str == other.m_str); }

//private:
public: // temp!
    std::wstring  m_str;
    MMC_STRING_ID m_id;
    DWORD         m_cRefs;
};


struct CompareEntriesByID :
    public std::binary_function<const CEntry&, const CEntry&, bool>
{
    bool operator() (const CEntry& entry1, const CEntry& entry2) const
        { return (entry1.m_id < entry2.m_id); }
};

struct CompareEntriesByString :
    public std::binary_function<const CEntry&, const CEntry&, bool>
{
    bool operator() (const CEntry& entry1, const CEntry& entry2) const
        { return (entry1 < entry2); }
};

struct IdentifierReleaser :
    public std::unary_function<CEntry&, bool>
{
    IdentifierReleaser (CStringIDPool& pool) : m_pool (pool) {}

    bool operator() (CEntry& entry) const
        { return (m_pool.Release (entry.m_id)); }

private:
    CStringIDPool& m_pool;
};


/*
 * Because the string and ID indexes map their keys to CEntry
 * pointers, we must use a collection that doesn't move its
 * elements once they're inserted.  The only STL collection
 * that meets this requirement is a list.
 */
typedef std::list<CEntry>  EntryList;

typedef XMLListCollectionWrap<EntryList> CStringTable_base;
class CStringTable : public CStringTable_base
{
    friend IStream& operator>> (IStream& stm,       CStringTable& entry);
    friend IStream& operator<< (IStream& stm, const CStringTable& entry);

public:
    DECLARE_DIAGNOSITICS();

    CStringTable (CStringIDPool* pIDPool);
    CStringTable (CStringIDPool* pIDPool, IStream& stm);
   ~CStringTable ();

    CStringTable (const CStringTable& other);
    CStringTable& operator= (const CStringTable& other);

    /*
     * IStringTable methods.  Note that object doesn't implement
     * IStringTable, because IUnknown isn't implemented.
     */
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID);
    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut) const;
    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString) const;
    STDMETHOD(DeleteString)     (MMC_STRING_ID id);
    STDMETHOD(DeleteAllStrings) ();
    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID) const;
    STDMETHOD(Enumerate)        (IEnumString** ppEnum) const;

    size_t size() const
        { return (m_Entries.size()); }

    virtual void Persist(CPersistor& persistor)
    {
        CStringTable_base::Persist(persistor);
        if (persistor.IsLoading())
            IndexAllEntries ();
    }

    SC ScCollectInUseIDs (CStringIDPool::RangeList& l) const;


private:

    void IndexAllEntries ()
        { IndexEntries (m_Entries.begin(), m_Entries.end()); }

    void IndexEntries (EntryList::iterator first, EntryList::iterator last)
    {
        for (; first != last; ++first)
            IndexEntry (first);
    }

    void IndexEntry (EntryList::iterator);

    typedef std::map<std::wstring,  EntryList::iterator>    StringToEntryMap;
    typedef std::map<MMC_STRING_ID, EntryList::iterator>    IDToEntryMap;

    EntryList::iterator LookupEntryByString (const std::wstring&)   const;
    EntryList::iterator LookupEntryByID     (MMC_STRING_ID)         const;
    EntryList::iterator FindInsertionPointForEntry (const CEntry& entry) const;


#ifdef DBG
    static void AssertValid (const CStringTable* pTable);
    #define ASSERT_VALID_(p)    do { AssertValid(p); } while(0)
#else
    #define ASSERT_VALID_(p)    ((void) 0)
#endif


private:
    EntryList           m_Entries;
    StringToEntryMap    m_StringIndex;
    IDToEntryMap        m_IDIndex;
    CStringIDPool*      m_pIDPool;
};

extern const CLSID CLSID_MMC;


/*+-------------------------------------------------------------------------*
 * class  CLSIDToStringTableMap
 *
 *
 * PURPOSE:  stl::map derived class that maps snapin_clsid to stringtable
 *           and supports XML persistence of the map collection
 *
 * NOTE: Throws exceptions!
 *+-------------------------------------------------------------------------*/
typedef std::map<CLSID, CStringTable> ST_base;
class  CLSIDToStringTableMap : public XMLMapCollection<ST_base>
{
public:
    // this method is provided as alternative to Persist, whic allows
    // to cache parameter to be used to create new string tables
    void PersistSelf(CStringIDPool *pIDPool, CPersistor& persistor)
    {
        m_pIDPersistPool = pIDPool;
        persistor.Persist(*this, NULL);
    }
protected:
    // XML persistence implementation
    virtual LPCTSTR GetXMLType() {return XML_TAG_STRING_TABLE_MAP;}
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
    {
        CLSID key;
        ZeroMemory(&key,sizeof(key));
        persistKey.Persist(key);

        CStringTable val(m_pIDPersistPool);
        persistVal.Persist(val);
        insert(ST_base::value_type(key,val));
    }
private:
    CStringIDPool *m_pIDPersistPool;
};
typedef CLSIDToStringTableMap::value_type   TableMapValue;

class CMasterStringTable :  public IStringTablePrivate, public CComObjectRoot, public CXMLObject
{
    friend IStorage& operator>> (IStorage& stg,       CMasterStringTable& mst);
    friend IStorage& operator<< (IStorage& stg, const CMasterStringTable& mst);

public:
    DECLARE_DIAGNOSITICS();

    CMasterStringTable ();
    ~CMasterStringTable ();


public:
    DEFINE_XML_TYPE(XML_TAG_MMC_STRING_TABLE);
    virtual void Persist(CPersistor& persistor);

    SC ScPurgeUnusedStrings();

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CMasterStringTable)
        COM_INTERFACE_ENTRY (IStringTablePrivate)
    END_COM_MAP ()

    /*
     * IStringTablePrivate methods
     */
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID, const CLSID* pclsid);
    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut, const CLSID* pclsid);
    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString, const CLSID* pclsid);
    STDMETHOD(DeleteString)     (MMC_STRING_ID id, const CLSID* pclsid);
    STDMETHOD(DeleteAllStrings) (const CLSID* pclsid);
    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID, const CLSID* pclsid);
    STDMETHOD(Enumerate)        (IEnumString** ppEnum, const CLSID* pclsid);

    /*
     * Shorthand into IStringTablePrivate (simulating a default parameter)
     */
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID)
        { return (AddString (pszAdd, pID, &CLSID_MMC)); }

    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut)
        { return (GetString (id, cchBuffer, lpBuffer, pcchOut, &CLSID_MMC)); }

    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString)
        { return (GetStringLength (id, pcchString, &CLSID_MMC)); }

    STDMETHOD(DeleteString)     (MMC_STRING_ID id)
        { return (DeleteString (id, &CLSID_MMC)); }

    STDMETHOD(DeleteAllStrings) ()
        { return (DeleteAllStrings (&CLSID_MMC)); }

    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID)
        { return (FindString (pszFind, pID, &CLSID_MMC)); }

    STDMETHOD(Enumerate)        (IEnumString** ppEnum)
        { return (Enumerate (ppEnum, &CLSID_MMC)); }


private:
    CStringTable* LookupStringTableByCLSID (const CLSID* pclsid) const;
    SC ScGenerateIDPool ();

private:
    CStringIDPool           m_IDPool;
    CLSIDToStringTableMap   m_TableMap;

    static const WCHAR      s_pszIDPoolStream[];
    static const WCHAR      s_pszStringsStream[];
};



class CStringEnumerator : public IEnumString, public CComObjectRoot
{
public:
    CStringEnumerator ();
    ~CStringEnumerator ();

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CStringEnumerator)
        COM_INTERFACE_ENTRY (IEnumString)
    END_COM_MAP ()

    /*
     * IEnumString methods
     */
    STDMETHOD(Next)  (ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)  (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (IEnumString **ppenum);

    static HRESULT CreateInstanceWrapper (
        CComObject<CStringEnumerator>** ppEnumObject,
        IEnumString**                   ppEnumIface);

    bool Init (const EntryList& entries);

private:
    typedef std::vector<std::wstring> StringVector;

    StringVector    m_Strings;
    size_t          m_cStrings;
    size_t          m_nCurrentIndex;
};


IStorage& operator>> (IStorage& stg,       CMasterStringTable& mst);
IStorage& operator<< (IStorage& stg, const CMasterStringTable& mst);
IStorage& operator>> (IStorage& stg,       CComObject<CMasterStringTable>& mst);
IStorage& operator<< (IStorage& stg, const CComObject<CMasterStringTable>& mst);

IStream& operator>> (IStream& stm,       CStringTable& st);
IStream& operator<< (IStream& stm, const CStringTable& st);
IStream& operator>> (IStream& stm,       CEntry& entry);
IStream& operator<< (IStream& stm, const CEntry& entry);

template<class T>
IStream& operator>> (IStream& stm,       CIdentifierPool<T>& pool);
template<class T>
IStream& operator<< (IStream& stm, const CIdentifierPool<T>& pool);


#include "strtable.inl"

#endif /* STRTABLE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\strtable.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1998.
 *
 *  File:      strtable.inl
 *
 *  Contents:  Inline functions for strtable.h
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STRTABLE_INL
#define STRTABLE_INL
#pragma once

#include "macros.h"     // for THROW_ON_FAIL
#include "stgio.h"



/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a IdentifierRange<T> from a stream.
 *--------------------------------------------------------------------------*/

template<class T>
inline IStream& operator>> (IStream& stm, IdentifierRange<T>& range)
{
    stm >> range.idMin >> range.idMax;

    if (range.idMin > range.idMax)
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a IdentifierRange<T> to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
inline IStream& operator<< (IStream& stm, const IdentifierRange<T>& range)
{
    return (stm << range.idMin << range.idMax);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::CIdentifierPool
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
inline CIdentifierPool<T>::CIdentifierPool (T idMin_, T idMax_)
    :   m_idAbsoluteMin   (idMin_),
        m_idAbsoluteMax   (idMax_),
        m_idNextAvailable (idMin_)
{
    ASSERT (m_idAbsoluteMin <= m_idAbsoluteMax);
    m_AvailableIDs.push_front (Range (m_idAbsoluteMin, m_idAbsoluteMax));

    ASSERT (m_StaleIDs.empty());
}

template<class T>
inline CIdentifierPool<T>::CIdentifierPool (IStream& stm)
{
    stm >> *this;
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::Reserve
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
T CIdentifierPool<T>::Reserve ()
{
    /*
     * if no more IDs are available, recycle the stale IDs
     */
    if (m_AvailableIDs.empty())
    {
        m_AvailableIDs.splice (m_AvailableIDs.end(), m_StaleIDs);
        ASSERT (m_StaleIDs.empty());
    }

    /*
     * if still no more IDs are available, throw an exception
     */
    if (m_AvailableIDs.empty())
        throw (pool_exhausted());

    /*
     * get the first ID from the first ID range
     */
    Range& FirstRange = m_AvailableIDs.front();
    T idReserved = FirstRange.idMin;

    /*
     * if we get here, we're going to return an ID, make sure it's the one
     * we though it was going to be
     */
    ASSERT (idReserved == m_idNextAvailable);

    /*
     * if the first ID range is now empty, remove it; otherwise,
     * remove the ID we just reserved from the available range
     */
    if (FirstRange.idMin == FirstRange.idMax)
        m_AvailableIDs.pop_front();
    else
        FirstRange.idMin++;

    /*
     * remember the next available ID
     */
    if (!m_AvailableIDs.empty())
        m_idNextAvailable = m_AvailableIDs.front().idMin;
    else if (!m_StaleIDs.empty())
        m_idNextAvailable = m_StaleIDs.front().idMin;
    else
        m_idNextAvailable = m_idAbsoluteMin;

    return (idReserved);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::Release
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::Release (T idRelease)
{
    /*
     * if the ID to be released falls outside
     * the range managed by this pool, fail
     */
    if ((idRelease < m_idAbsoluteMin) || (idRelease > m_idAbsoluteMax))
    {
        ASSERT (false);
        return (false);
    }

    /*
     * put the released ID in the stale pool
     */
    return (AddToRangeList (m_StaleIDs, idRelease));
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::IsValid
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::IsValid () const
{
    if (m_idAbsoluteMin > m_idAbsoluteMax)
        return (false);

    if (!IsRangeListValid (m_AvailableIDs))
        return (false);

    if (!IsRangeListValid (m_StaleIDs))
        return (false);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::IsRangeListValid
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::IsRangeListValid (const RangeList& rl) const
{
    RangeList::const_iterator it;

    for (it = rl.begin(); it != rl.end(); ++it)
    {
        if ((it->idMin < m_idAbsoluteMin) ||
            (it->idMax > m_idAbsoluteMax))
            return (false);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::ScGenerate
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
SC CIdentifierPool<T>::ScGenerate (const RangeList& rlInUseIDs)
{
    DECLARE_SC (sc, _T("CIdentifierPool<T>::ScGenerate"));
    m_AvailableIDs.clear();
    m_StaleIDs.clear();

    /*
     * Invert the in-use IDs.  We'll then have a collection of all the
     * ID's that are not in use.  Note that not all of these ID's are
     * necessarily "available", since some may be stale.
     */
    RangeList rlNotInUseIDs = rlInUseIDs;
    sc = ScInvertRangeList (rlNotInUseIDs);
    if (sc)
        return (sc);

    /*
     * Find the range containing the next available ID.
     */
    RangeList::iterator it;

    for (it = rlNotInUseIDs.begin(); it != rlNotInUseIDs.end(); ++it)
    {
		/*
		 * if this range contains the next available ID, we've found a hit
		 */
		if ((m_idNextAvailable >= it->idMin) && (m_idNextAvailable <= it->idMax))
		{
			/*
			 * if the next available ID is at the beginning of this range,
			 * things are simple; we can just break out of the loop
			 */
			if (m_idNextAvailable == it->idMin)
				break;

			/*
			 * otherwise, we need to split the current range into two
			 * adjacent ranges so the code below that copies to the
			 * stale and available ranges can work; then we can break out
			 * of the loop
			 */
			Range range (m_idNextAvailable, it->idMax);
			it->idMax = m_idNextAvailable - 1;
			it = rlNotInUseIDs.insert (++it, range);
			break;
		}
    }

    /*
     * confirm that we found one
     */
    ASSERT (it != rlNotInUseIDs.end());

    /*
     * everything before the next available ID that's not it use is stale;
     * everything after  the next available ID that's not in use is available;
     */
    std::copy (rlNotInUseIDs.begin(), it, std::back_inserter(m_StaleIDs));
    std::copy (it, rlNotInUseIDs.end(),   std::back_inserter(m_AvailableIDs));

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::AddToRangeList
 *
 * This adds an identifier to the specified range list.
 *
 * This really should be a member function on a RangeList class, like so:
 *
 *      class RangeList : public std::list<Range>
 *      {
 *      public:
 *          bool Add (const Range& rangeToAdd);
 *          bool Add (T tAdd);
 *      };
 *
 * but compiler bugs prevent it.
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::AddToRangeList (RangeList& rl, T idAdd)
{
    return (AddToRangeList (rl, Range (idAdd, idAdd)));
}

template<class T>
bool CIdentifierPool<T>::AddToRangeList (RangeList& l, const Range& rangeToAdd)
{
    RangeList::iterator it;

    for (it = l.begin(); it != l.end(); ++it)
    {
        Range& rangeT = *it;

        /*
         * the range to add shouldn't overlap the existing range in any way
         */
        if (((rangeToAdd.idMin >= rangeT.idMin) && (rangeToAdd.idMin <= rangeT.idMax)) ||
            ((rangeToAdd.idMax >= rangeT.idMin) && (rangeToAdd.idMax <= rangeT.idMax)))
        {
            ASSERT (false);
            return (false);
        }

        /*
         * If the range to add is immediately to the left of the current
         * range (that is, the upper bound of the range to add is immediately
         * adjacent to the lower bound of the current range), it can be
         * absorbed into the current range and we're done.
         *
         * Note that we don't have to worry about coalescing this range
         * with the preceeding range.  That case would have been covered
         * by the next clause, in the preceeding iteration of this loop.
         */
        if (rangeToAdd.idMax == (rangeT.idMin - 1))
        {
            rangeT.idMin = rangeToAdd.idMin;
            return (true);
        }


        /*
         * If the range to add is immediately to the right of the current
         * range (that is, the lower bound of the range to add is immediately
         * adjacent to the upper bound of the current range), it can be
         * absorbed into the current range and we're done.
         */
        else if (rangeToAdd.idMin == (rangeT.idMax + 1))
        {
            rangeT.idMax = rangeToAdd.idMax;

            /*
             * Now check the next available range (if there is one).
             * If it begins where the current range now ends, then
             * the two ranges can be coalesced into a single range.
             */
            if (++it != l.end())
            {
                Range& rangeNext = *it;
                ASSERT (rangeT.idMax < rangeNext.idMin);

                if (rangeT.idMax == (rangeNext.idMin - 1))
                {
                    rangeT.idMax = rangeNext.idMax;
                    l.erase (it);
                }
            }

            return (true);
        }


        /*
         * If the upper bound of the range to insert is less than the
         * lower bound of the current available range, we need to insert
         * the new range here. The insertion is handled outside the loop.
         */
        else if (rangeToAdd.idMax < rangeT.idMin)
            break;

    }

    /*
     * If we get here, then we need to create a new available range
     * to the left of the current iterator, which will address the
     * end of the list if the ID is greater than the current maximum
     * available ID.
     */
    ASSERT ((it == l.end()) || (rangeToAdd.idMax < (it->idMin - 1)));
    l.insert (it, rangeToAdd);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::ScInvertRangeList
 *
 * Changes rlInvert into a range list containing all elements between
 * m_idAbsoluteMin and m_idAbsoluteMax that were not originally in
 * rlInvert.
 *
 * So, if the range looks like this before inversion:
 *
 *                         +----+----+           +----+----+
 *   m_idAbsoluteMin       |  5 | 10 | --------> | 15 | 20 |    m_idAbsoluteMax
 *                         +----+----+           +----+----+
 *
 * it will look like this after inversion:
 *
 * +-----------------+----+           +----+----+           +----+-----------------+
 * | m_idAbsoluteMin |  4 | --------> | 11 | 14 | --------> | 21 | m_idAbsoluteMax |
 * +-----------------+----+           +----+----+           +----+-----------------+
 *--------------------------------------------------------------------------*/

template<class T>
SC CIdentifierPool<T>::ScInvertRangeList (RangeList& rlInvert) const
{
    DECLARE_SC (sc, _T("CIdentifierPool::ScInvertRangeList"));

    /*
     * if there's nothing in the list to invert, the inverted
     * list will contain a single range spanning min to max
     */
    if (rlInvert.empty())
    {
        rlInvert.push_front (Range (m_idAbsoluteMin, m_idAbsoluteMax));
        return (sc);
    }

    /*
     * determine whether we'll need to add ranges on the front or back,
     * and initialize the ranges we'll add if we will
     */
    Range rFirst;
    bool fAddFirstRange = (rlInvert.front().idMin > m_idAbsoluteMin);
    if (fAddFirstRange)
    {
        rFirst.idMin = m_idAbsoluteMin;
        rFirst.idMax = rlInvert.front().idMin - 1;
    }

    Range rLast;
    bool fAddLastRange = (rlInvert.back().idMax < m_idAbsoluteMax);
    if (fAddLastRange)
    {
        rLast.idMin = rlInvert.back().idMax + 1;
        rLast.idMax = m_idAbsoluteMax;
    }

    /*
     * Change rlInvert to contain ranges that represent the gaps
     * between the ranges it currently contains.  The size of rlInvert
     * will be one less than its original size when this process is
     * complete.
     */
    RangeList::iterator it     =   rlInvert.begin();
    RangeList::iterator itNext = ++rlInvert.begin();

    while (itNext != rlInvert.end())
    {
        /*
         * morph this range into the range representing the gap between
         * this range and the next one
         */
        it->idMin = it->idMax + 1;
        it->idMax = itNext->idMin - 1;

        /*
         * advance the iterators
         */
        it = itNext++;
    }

    /*
     * remove the extraneous node at the end of the list
     */
    rlInvert.pop_back();

    /*
     * append to the beginning and/or end, if necessary
     */
    if (fAddFirstRange)
        rlInvert.push_front (rFirst);

    if (fAddLastRange)
        rlInvert.push_back (rLast);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CIdentifierPool<T> from a stream
 *--------------------------------------------------------------------------*/

template<class T>
IStream& operator>> (IStream& stm, CIdentifierPool<T>& pool)
{
    /*
     * read the min and max IDs from the stream
     */
    stm >> pool.m_idAbsoluteMin >> pool.m_idAbsoluteMax;

    /*
     * read the available and stale IDs
     */
    stm >> pool.m_AvailableIDs >> pool.m_StaleIDs;

    /*
     * find out how big the stream is
     */
    STATSTG statstg;
    HRESULT hr = stm.Stat (&statstg, STATFLAG_NONAME);
    if (FAILED (hr))
        _com_issue_error (hr);

    /*
     * get our seek position
     */
    ULARGE_INTEGER  uliSeekPos;
    LARGE_INTEGER   liOffset;
    liOffset.QuadPart = 0;
    hr = stm.Seek (liOffset, STREAM_SEEK_CUR, &uliSeekPos);
    if (FAILED (hr))
        _com_issue_error (hr);

    /*
     * Older files won't have saved the next available ID.  If it's there,
     * read it; if not, use a default value for pool.m_idNextAvailable.
     */
    if (statstg.cbSize.QuadPart > uliSeekPos.QuadPart)
    {
        stm >> pool.m_idNextAvailable;
    }
    else
    {
        if (!pool.m_AvailableIDs.empty())
            pool.m_idNextAvailable = pool.m_AvailableIDs.front().idMin;
        else
            pool.m_idNextAvailable = pool.m_idAbsoluteMin;
    }

    /*
     * validate what we read
     */
    if (!pool.IsValid ())
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CIdentifierPool<T> to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
IStream& operator<< (IStream& stm, const CIdentifierPool<T>& pool)
{
    /*
     * write the min and max IDs to the stream
     */
    stm << pool.m_idAbsoluteMin << pool.m_idAbsoluteMax;

    /*
     * Write an empty collection of available and stale IDs to keep the
     * stream format the same as previous versions.  Beginning with MMC 2.0,
     * the available and stale IDs will be regenerated from the next available
     * ID and in-use IDs after the string table is read in.  This is done to
     * minimize the data that needs to be saved with the new XML file format.
     */
    CIdentifierPool<T>::RangeList rlEmpty;
    stm << rlEmpty;     // available IDs
    stm << rlEmpty;     // stale IDs

    /*
     * write the next available ID
     */
    stm << pool.m_idNextAvailable;

    return (stm);
}

template<class T>
void CIdentifierPool<T>::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_ID_POOL_ABSOLUTE_MIN, m_idAbsoluteMin);
    persistor.PersistAttribute(XML_ATTR_ID_POOL_ABSOLUTE_MAX, m_idAbsoluteMax);
    persistor.PersistAttribute(XML_ATTR_ID_POOL_NEXT_AVAILABLE, m_idNextAvailable);
}

/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

template<class T>
void CIdentifierPool<T>::DumpRangeList (const RangeList& l) const
{
    int cEntries = 0;

    for (RangeList::const_iterator it = l.begin(); it != l.end(); ++it)
    {
        Trace (tagStringTable, _T("Range %d:min=%d, max=%d"),
               ++cEntries, (int) it->idMin, (int) it->idMax);
    }
}

template<class T>
void CIdentifierPool<T>::Dump () const
{
    Trace (tagStringTable, _T("Next available ID: %d"), m_idNextAvailable);

    Trace (tagStringTable, _T("Available IDs:"));
    DumpRangeList (m_AvailableIDs);

    Trace (tagStringTable, _T("Stale IDs:"));
    DumpRangeList (m_StaleIDs);
}

#endif  // DBG


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 *
 *--------------------------------------------------------------------------*/

inline IStorage& operator>> (IStorage& stg, CComObject<CMasterStringTable>& mst)
{
    return (stg >> static_cast<CMasterStringTable&>(mst));
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 *
 *--------------------------------------------------------------------------*/

inline IStorage& operator<< (IStorage& stg, const CComObject<CMasterStringTable>& mst)
{
    return (stg << static_cast<const CMasterStringTable&>(mst));
}


#endif /* STRTABLE_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\stringutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      string.cpp
//
//  Contents:  Utility functions for the CString class
//
//  History:   10-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include <stdafx.h>

/*+-------------------------------------------------------------------------*
 *
 * LoadString
 *
 * PURPOSE: A function to load strings from the string module, not the AfxModule
 *
 * PARAMETERS: 
 *    CString & str :
 *    UINT      nID :
 *
 * RETURNS: 
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL LoadString(CString &str, UINT nID)
{
    const size_t STRING_LEN_INCREMENT = 256;

    str.Empty();

    // try fixed buffer first (to avoid wasting space in the heap)
    static TCHAR szTemp[STRING_LEN_INCREMENT];

    int nLen = ::LoadString(GetStringModule(), nID, szTemp, countof(szTemp));
    if (countof(szTemp) - nLen > 1)
    {
        szTemp[nLen] = 0;
        str = szTemp;
        return nLen > 0;
    }

    // try buffer size of 2*STRING_LEN_INCREMENT, then larger size until entire string is retrieved
    int nSize = STRING_LEN_INCREMENT;
    do
    {
        nSize += STRING_LEN_INCREMENT;
        nLen = ::LoadString(GetStringModule(), nID, str.GetBuffer(nSize-1), nSize);
    } while (nSize - nLen <= 1);

    str.ReleaseBuffer();

    return (nLen > 0);
}

/*+-------------------------------------------------------------------------*
 *
 * FormatStrings
 *
 * PURPOSE: Similar to AfxFormatStrings, but uses GetStringModule() instead of
 *          AfxGetModuleInstance.
 *
 * PARAMETERS: 
 *    CString& rString :
 *    UINT     nIDS :
 *    LPCTSTR  const :
 *    int      nString :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void FormatStrings(CString& rString, UINT nIDS, LPCTSTR const* rglpsz, int nString)
{
    // empty the result (in case we fail)
    rString.Empty();

    // get the format string.
    CString strFormat;
    if (!LoadString(strFormat, nIDS))
    {
        TraceError(_T("FormatStrings"), SC(E_INVALIDARG));
        return; // failed...
    }

    AfxFormatStrings(rString, strFormat, rglpsz, nString);
}

/*+-------------------------------------------------------------------------*
 *
 * FormatString1
 *
 * PURPOSE: Similar to AfxFormatString1, but uses GetStringModule() instead
 *          of AfxGetModuleInstance()
 *
 * PARAMETERS: 
 *    CString& rString :
 *    UINT     nIDS :
 *    LPCTSTR  lpsz1 :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void FormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1)
{
	FormatStrings(rString, nIDS, &lpsz1, 1);
}

/*+-------------------------------------------------------------------------*
 *
 * FormatString2
 *
 * PURPOSE: Similar to AfxFormatString2, but uses GetStringModule() instead 
 *          of AfxGetModuleInstance()                                       
 *
 * PARAMETERS: 
 *    CString& rString :
 *    UINT     nIDS :
 *    LPCTSTR  lpsz1 :
 *    LPCTSTR  lpsz2 :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void FormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1, LPCTSTR lpsz2)
{
	LPCTSTR rglpsz[2];
	rglpsz[0] = lpsz1;
	rglpsz[1] = lpsz2;
	FormatStrings(rString, nIDS, rglpsz, 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\strtable.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      strtable.cpp
 *
 *  Contents:  Implementation file for CStringTable
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "strtable.h"
#include "macros.h"
#include "comdbg.h"
#include "amcdoc.h"


// {71E5B33E-1064-11d2-808F-0000F875A9CE}
const CLSID CLSID_MMC =
{ 0x71e5b33e, 0x1064, 0x11d2, { 0x80, 0x8f, 0x0, 0x0, 0xf8, 0x75, 0xa9, 0xce } };

const WCHAR CMasterStringTable::s_pszIDPoolStream[]  = L"ID Pool";
const WCHAR CMasterStringTable::s_pszStringsStream[] = L"Strings";

#ifdef DBG
CTraceTag tagStringTable (_T("StringTable"), _T("StringTable"));
#endif  // DBG


/*+-------------------------------------------------------------------------*
 * IsBadString
 *
 *
 *--------------------------------------------------------------------------*/

inline static bool IsBadString (LPCWSTR psz)
{
    if (psz == NULL)
        return (true);

    return (::IsBadStringPtrW (psz, -1) != 0);
}


/*+-------------------------------------------------------------------------*
 * TStringFromCLSID
 *
 *
 *--------------------------------------------------------------------------*/

static LPTSTR TStringFromCLSID (LPTSTR pszClsid, const CLSID& clsid)
{
    const int cchClass = 40;

#ifdef UNICODE
    StringFromGUID2 (clsid, pszClsid, cchClass);
#else
    USES_CONVERSION;
    WCHAR wzClsid[cchClass];
    StringFromGUID2 (clsid, wzClsid, cchClass);
    _tcscpy (pszClsid, W2T (wzClsid));
#endif

    return (pszClsid);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 *
 *--------------------------------------------------------------------------*/

inline IStream& operator>> (IStream& stm, CEntry& entry)
{
    return (stm >> entry.m_id >> entry.m_cRefs >> entry.m_str);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CEntry to a stream.  The format is:
 *
 *      DWORD   string ID
 *      DWORD   reference count
 *      DWORD   string length (character count)
 *      WCHAR[] characters in the strings, *not* NULL-terminated
 *
 *--------------------------------------------------------------------------*/

inline IStream& operator<< (IStream& stm, const CEntry& entry)
{
    return (stm << entry.m_id << entry.m_cRefs << entry.m_str);
}

/*+-------------------------------------------------------------------------*
 * CEntry::Persist
 *
 *
 *--------------------------------------------------------------------------*/
void CEntry::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_ID,    m_id);
    persistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_REFS,  m_cRefs);
    persistor.PersistContents(m_str); 
}

/*+-------------------------------------------------------------------------*
 * CEntry::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CEntry::Dump () const
{
    USES_CONVERSION;
    Trace (tagStringTable, _T("id=%d, refs=%d, string=\"%s\""),
           m_id, m_cRefs, W2CT (m_str.data()));
}

#endif


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::CMasterStringTable
 *
 * Even though a MMC_STRING_ID is a DWORD, we want to make sure the high
 * word is 0, to keep open the possibility that we can use something like
 * MAKEINTRESOURCE in the future.  To do this, set USHRT_MAX as the
 * maximum string ID.
 *--------------------------------------------------------------------------*/

CMasterStringTable::CMasterStringTable ()
    : m_IDPool (1, USHRT_MAX)
{
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::~CMasterStringTable
 *
 *
 *--------------------------------------------------------------------------*/

CMasterStringTable::~CMasterStringTable ()
{
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::AddString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::AddString (
    LPCOLESTR       pszAdd,
    MMC_STRING_ID*  pID,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    /*
     * If this the first string added for this CLSID,
     * we need to create a new string table.
     */
    if (pStringTable == NULL)
    {
        CStringTable    table (&m_IDPool);
        TableMapValue   value (*pclsid, table);

        CLSIDToStringTableMap::_Pairib rc = m_TableMap.insert (value);

        /*
         * we should have actually inserted the new table
         */
        ASSERT (rc.second);

        pStringTable = &(rc.first->second);
        ASSERT (pStringTable != NULL);
    }

    HRESULT hr = pStringTable->AddString (pszAdd, pID);

#ifdef DBG
    if (SUCCEEDED (hr))
    {
        USES_CONVERSION;
        TCHAR szClsid[40];
        Trace (tagStringTable, _T("Added \"%s\" (id=%d) for %s"),
               W2CT(pszAdd), (int) *pID, TStringFromCLSID (szClsid, *pclsid));
        Dump();
    }
#endif

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::GetString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::GetString (
    MMC_STRING_ID   id,
    ULONG           cchBuffer,
    LPOLESTR        lpBuffer,
    ULONG*          pcchOut,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->GetString (id, cchBuffer, lpBuffer, pcchOut));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::GetStringLength
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::GetStringLength (
    MMC_STRING_ID   id,
    ULONG*          pcchString,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->GetStringLength (id, pcchString));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::DeleteString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::DeleteString (
    MMC_STRING_ID   id,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    HRESULT hr = pStringTable->DeleteString (id);

    TCHAR szClsid[40];
    Trace (tagStringTable, _T("Deleted string %d for %s"), (int) id, TStringFromCLSID (szClsid, *pclsid));
    Dump();

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::DeleteAllStrings
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::DeleteAllStrings (
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

#include "pushwarn.h"
#pragma warning(disable: 4553)      // "==" operator has no effect
    VERIFY (pStringTable->DeleteAllStrings () == S_OK);
    VERIFY (m_TableMap.erase (*pclsid) == 1);
#include "popwarn.h"

    TCHAR szClsid[40];
    Trace (tagStringTable, _T("Deleted all strings for %s"), TStringFromCLSID (szClsid, *pclsid));
    Dump();

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::FindString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::FindString (
    LPCOLESTR       pszFind,
    MMC_STRING_ID*  pID,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->FindString (pszFind, pID));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::Enumerate
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::Enumerate (
    IEnumString**   ppEnum,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->Enumerate (ppEnum));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::LookupStringTableByCLSID
 *
 * Returns a pointer to the string table for a given CLSID, or NULL if
 * there isn't a corresponding string in the string table.
 *--------------------------------------------------------------------------*/

CStringTable* CMasterStringTable::LookupStringTableByCLSID (const CLSID* pclsid) const
{
    CLSIDToStringTableMap::iterator it = m_TableMap.find (*pclsid);

    if (it == m_TableMap.end())
        return (NULL);

    return (&it->second);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CMasterStringTable from a storage.
 *--------------------------------------------------------------------------*/

IStorage& operator>> (IStorage& stg, CMasterStringTable& mst)
{
    DECLARE_SC (sc, _T("operator>> (IStorage& stg, CMasterStringTable& mst)"));

    HRESULT hr;
    IStreamPtr spStream;

    /*
     * read the available IDs
     */
    hr = OpenDebugStream (&stg, CMasterStringTable::s_pszIDPoolStream,
                         STGM_SHARE_EXCLUSIVE | STGM_READ,
                         &spStream);

    THROW_ON_FAIL (hr);
    spStream >> mst.m_IDPool;

    /*
     * read the CLSIDs and the strings
     */
    hr = OpenDebugStream (&stg, CMasterStringTable::s_pszStringsStream,
                         STGM_SHARE_EXCLUSIVE | STGM_READ, 
                         &spStream);

    THROW_ON_FAIL (hr);

#if 1
    /*
     * clear out the current table
     */
    mst.m_TableMap.clear();

    /*
     * read the CLSID count
     */
    DWORD cClasses;
    *spStream >> cClasses;

    while (cClasses-- > 0)
    {
        /*
         * read the CLSID...
         */
        CLSID clsid;
        spStream >> clsid;

        /*
         * ...and the string table
         */
        CStringTable table (&mst.m_IDPool, spStream);

        /*
         * insert the string table into the CLSID map
         */
        TableMapValue value (clsid, table);
        VERIFY (mst.m_TableMap.insert(value).second);
    }
#else
    /*
     * Can't use this because there's no default ctor for CStringTable
     */
    *spStream >> mst.m_TableMap;
#endif

    /*
     * Generate the list of stale IDs.  
     */

    sc = mst.ScGenerateIDPool ();
    if (sc)
        return (stg);

    mst.Dump();
    return (stg);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::ScGenerateIDPool 
 *
 * Generates the list of stale string IDs for this CMasterStringTable.  
 * The set of stale IDs is the entire set of IDs, minus the available IDs,
 * minus the in-use IDs.
 *--------------------------------------------------------------------------*/

SC CMasterStringTable::ScGenerateIDPool ()
{
    /*
     * Step 1:  build up a RangeList of the in-use IDs
     */
    DECLARE_SC (sc, _T("CMasterStringTable::ScGenerateIDPool"));
    CStringIDPool::RangeList                lInUseIDs;
    CLSIDToStringTableMap::const_iterator   itTable;

    for (itTable = m_TableMap.begin(); itTable != m_TableMap.end(); ++itTable)
    {
        const CStringTable& st = itTable->second;

        sc = st.ScCollectInUseIDs (lInUseIDs);
        if (sc)
            return (sc);
    }

    /*
     * Step 2:  give the in-use IDs to the ID pool so it can merge it 
     * with the available IDs (which it already has) to generate the 
     * list of stale IDs
     */
    sc = m_IDPool.ScGenerate (lInUseIDs);
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CMasterStringTable::Persist
 *
 * PURPOSE: persists the CMasterStringTable object to the specified persistor.
 *
 * PARAMETERS: 
 *    CPersistor & persistor :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CMasterStringTable::Persist(CPersistor & persistor)
{
    DECLARE_SC(sc, TEXT("CMasterStringTable::Persist"));

    // purge unused snapins not to save what's already gone
    sc = ScPurgeUnusedStrings();
    if (sc)
        sc.Throw();

    persistor.Persist(m_IDPool); 
    m_TableMap.PersistSelf(&m_IDPool, persistor);
    if (persistor.IsLoading())
        ScGenerateIDPool ();
}


/***************************************************************************\
 *
 * METHOD:  CMasterStringTable::ScPurgeUnusedStrings
 *
 * PURPOSE: removes entries for snapins what aren't in use anymore
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMasterStringTable::ScPurgeUnusedStrings()
{
    DECLARE_SC(sc, TEXT("CMasterStringTable::ScPurgeUnusedStrings"));

    // det to the currfent document
    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    sc = ScCheckPointers(pAMCDoc, E_UNEXPECTED);
    if (sc)
        return sc;

    // get the access to scope tree
    IScopeTree *pScopeTree = pAMCDoc->GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // now iterate thru entries removing those belonging
    // to snapins already gone.
    CLSIDToStringTableMap::iterator it = m_TableMap.begin();
    while (it != m_TableMap.end())
    {
        // special case for internal guid
        if (IsEqualGUID(it->first, CLSID_MMC))
        {
            ++it;   // simply skip own stuff
        }
        else
        {
            // ask the scope tree if snapin is in use
            BOOL bInUse = FALSE;
            sc = pScopeTree->IsSnapinInUse(it->first, &bInUse);
            if (sc)
                return sc;

            // act depending on usage
            if (bInUse)
            {
                ++it;   // skip also the stuff currently in use
            }
            else 
            {
                // to the trash can
                sc = it->second.DeleteAllStrings();
                if (sc)
                    return sc;

                it = m_TableMap.erase(it);
            }
        }
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CMasterStringTable to a storage.
 *
 * It is written into two streams: "ID Pool" and "Strings".
 *
 * "ID Pool" contains the list of available string IDs remaining in the
 * string table.  Its format is defined by CIdentifierPool.
 *
 * "Strings" contains the strings.  The format is:
 *
 *      DWORD   count of string tables
 *      [n string tables]
 *
 * The format for each string is defined by operator<<(TableMapValue).
 *--------------------------------------------------------------------------*/

IStorage& operator<< (IStorage& stg, const CMasterStringTable& mst)
{
    HRESULT hr;
    IStreamPtr spStream;

    /*
     * write the available IDs
     */
    hr = CreateDebugStream (&stg, CMasterStringTable::s_pszIDPoolStream,
                           STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_WRITE,
                           &spStream);

    THROW_ON_FAIL (hr);
    spStream << mst.m_IDPool;


    /*
     * write the string tables
     */
    hr = CreateDebugStream (&stg, CMasterStringTable::s_pszStringsStream,
                           STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_WRITE,
                           &spStream);

    THROW_ON_FAIL (hr);
    *spStream << mst.m_TableMap;

    return (stg);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CMasterStringTable::Dump () const
{
    Trace (tagStringTable, _T("Contents of CMasterStringTable at 0x08%x"), this);

    m_IDPool.Dump();

    CLSIDToStringTableMap::const_iterator it;

    for (it = m_TableMap.begin(); it != m_TableMap.end(); ++it)
    {
        TCHAR szClsid[40];
        const CLSID&        clsid = it->first;
        const CStringTable& st    = it->second;

        Trace (tagStringTable, _T("%d strings for %s:"),
               st.size(), TStringFromCLSID (szClsid, clsid));
        st.Dump();
    }
}

#endif




/*+-------------------------------------------------------------------------*
 * CStringTable::CStringTable
 *
 *
 *--------------------------------------------------------------------------*/

CStringTable::CStringTable (CStringIDPool* pIDPool)
    : m_pIDPool (pIDPool),
      CStringTable_base(m_Entries, XML_TAG_STRING_TABLE)
{
    ASSERT_VALID_(this);
}

CStringTable::CStringTable (CStringIDPool* pIDPool, IStream& stm)
    : m_pIDPool (pIDPool),
      CStringTable_base(m_Entries, XML_TAG_STRING_TABLE)
{
    stm >> *this;
    ASSERT_VALID_(this);
}

/*+-------------------------------------------------------------------------*
 * CStringTable::~CStringTable
 *
 *
 *--------------------------------------------------------------------------*/

CStringTable::~CStringTable ()
{
}


/*+-------------------------------------------------------------------------*
 * CStringTable::CStringTable
 *
 * Copy constructor
 *--------------------------------------------------------------------------*/

CStringTable::CStringTable (const CStringTable& other)
    :   m_Entries (other.m_Entries),
        m_pIDPool (other.m_pIDPool),
        CStringTable_base(m_Entries, XML_TAG_STRING_TABLE)
{
    ASSERT_VALID_(&other);
    IndexAllEntries ();
    ASSERT_VALID_(this);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::operator=
 *
 * Assignment operator
 *--------------------------------------------------------------------------*/

CStringTable& CStringTable::operator= (const CStringTable& other)
{
    ASSERT_VALID_(&other);

    if (&other != this)
    {
        m_Entries = other.m_Entries;
        m_pIDPool = other.m_pIDPool;
        IndexAllEntries ();
    }

    ASSERT_VALID_(this);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::AddString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::AddString (
    LPCOLESTR       pszAdd,
    MMC_STRING_ID*  pID)
{
    /*
     * validate the parameters
     */
    if (IsBadString (pszAdd))
        return (E_INVALIDARG);

    if (IsBadWritePtr (pID, sizeof (*pID)))
        return (E_INVALIDARG);

    std::wstring strAdd = pszAdd;

    /*
     * check to see if there's already an entry for this string
     */
    EntryList::iterator itEntry = LookupEntryByString (strAdd);


    /*
     * if there's not an entry for this string, add one
     */
    if (itEntry == m_Entries.end())
    {
        /*
         * add the entry to the list
         */
        try
        {
            CEntry EntryToInsert (strAdd, m_pIDPool->Reserve());

            itEntry = m_Entries.insert (FindInsertionPointForEntry (EntryToInsert),
                                        EntryToInsert);
            ASSERT (itEntry->m_cRefs == 0);
        }
        catch (CStringIDPool::pool_exhausted&)
        {
            return (E_OUTOFMEMORY);
        }

        /*
         * add the new entry to the indices
         */
        IndexEntry (itEntry);
    }


    /*
     * Bump the ref count for this string.  The ref count for
     * new strings is 0, so we won't have ref counting problems.
     */
    ASSERT (itEntry != m_Entries.end());
    itEntry->m_cRefs++;

    *pID = itEntry->m_id;

    ASSERT_VALID_(this);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::GetString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::GetString (
    MMC_STRING_ID   id,
    ULONG           cchBuffer,
    LPOLESTR        lpBuffer,
    ULONG*          pcchOut) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (cchBuffer == 0)
        return (E_INVALIDARG);

    if (IsBadWritePtr (lpBuffer, cchBuffer * sizeof (*lpBuffer)))
        return (E_INVALIDARG);

    if ((pcchOut != NULL) && IsBadWritePtr (pcchOut, sizeof (*pcchOut)))
        return (E_INVALIDARG);

    /*
     * find the entry for this string ID
     */
    EntryList::iterator itEntry = LookupEntryByID (id);

    if (itEntry == m_Entries.end())
        return (E_FAIL);

    /*
     * copy to the user's buffer and make sure it's terminated
     */
    wcsncpy (lpBuffer, itEntry->m_str.data(), cchBuffer);
    lpBuffer[cchBuffer-1] = 0;

    /*
     * if the caller wants the write count, give it to him
     */
    if ( pcchOut != NULL)
        *pcchOut = wcslen (lpBuffer);

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::GetStringLength
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::GetStringLength (
    MMC_STRING_ID   id,
    ULONG*          pcchString) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (IsBadWritePtr (pcchString, sizeof (*pcchString)))
        return (E_INVALIDARG);

    /*
     * find the entry for this string ID
     */
    EntryList::iterator itEntry = LookupEntryByID (id);

    if (itEntry == m_Entries.end())
        return (E_FAIL);

    *pcchString = itEntry->m_str.length();

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::DeleteString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::DeleteString (
    MMC_STRING_ID   id)
{
    /*
     * find the entry for this string ID
     */
    EntryList::iterator itEntry = LookupEntryByID (id);

    if (itEntry == m_Entries.end())
        return (E_FAIL);

    /*
     * Decrement the ref count.  If it goes to zero, we can remove the
     * string entirely.
     */
    if (--itEntry->m_cRefs == 0)
    {
        /*
         * remove the string from the indices
         */
        m_StringIndex.erase (itEntry->m_str);
        m_IDIndex.erase     (itEntry->m_id);

        /*
         * return the string ID to the ID pool and remove the entry
         */
        VERIFY (m_pIDPool->Release (itEntry->m_id));
        m_Entries.erase (itEntry);
    }

    ASSERT_VALID_(this);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::DeleteAllStrings
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::DeleteAllStrings ()
{
    /*
     * return all string IDs to the ID pool
     */
    std::for_each (m_Entries.begin(), m_Entries.end(),
                   IdentifierReleaser (*m_pIDPool));

    /*
     * wipe everything clean
     */
    m_Entries.clear ();
    m_StringIndex.clear ();
    m_IDIndex.clear ();

    ASSERT_VALID_(this);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::FindString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::FindString (
    LPCOLESTR       pszFind,
    MMC_STRING_ID*  pID) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (IsBadString (pszFind))
        return (E_INVALIDARG);

    if (IsBadWritePtr (pID, sizeof (*pID)))
        return (E_INVALIDARG);

    /*
     * look up the string
     */
    EntryList::iterator itEntry = LookupEntryByString (pszFind);

    /*
     * no entry? fail
     */
    if (itEntry == m_Entries.end())
        return (E_FAIL);

    *pID = itEntry->m_id;

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::Enumerate
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::Enumerate (
    IEnumString**   ppEnum) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (IsBadWritePtr (ppEnum, sizeof (*ppEnum)))
        return (E_INVALIDARG);

    /*
     * Create the new CStringEnumerator object
     */
    CComObject<CStringEnumerator>* pEnumerator;
    HRESULT hr = CStringEnumerator::CreateInstanceWrapper(&pEnumerator, ppEnum);

    if (FAILED (hr))
        return (hr);

    /*
     * initialize it
     */
    ASSERT (pEnumerator != NULL);
    pEnumerator->Init (m_Entries);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::IndexEntry
 *
 * Adds an EntryList entry to the by-string and by-ID indices maintained
 * for the EntryList.
 *--------------------------------------------------------------------------*/

void CStringTable::IndexEntry (EntryList::iterator itEntry)
{
    /*
     * the entry shouldn't be in any of the indices yet
     */
    ASSERT (m_StringIndex.find (itEntry->m_str) == m_StringIndex.end());
    ASSERT (m_IDIndex.find     (itEntry->m_id)  == m_IDIndex.end());

    /*
     * add the entry to the indices
     */
    m_StringIndex[itEntry->m_str] = itEntry;
    m_IDIndex    [itEntry->m_id]  = itEntry;
}


/*+-------------------------------------------------------------------------*
 * CStringTable::LookupEntryByString
 *
 * Returns an iterator to the string table entry for a given string, or
 * m_Entries.end() if there isn't an entry for the ID.
 *--------------------------------------------------------------------------*/

EntryList::iterator
CStringTable::LookupEntryByString (const std::wstring& str) const
{
    StringToEntryMap::iterator it = m_StringIndex.find (str);

    if (it == m_StringIndex.end())
        return (m_Entries.end());

    return (it->second);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::LookupEntryByID
 *
 * Returns an iterator to the string table entry for a given string ID, or
 * m_Entries.end() if there isn't an entry for the ID.
 *--------------------------------------------------------------------------*/

EntryList::iterator
CStringTable::LookupEntryByID (MMC_STRING_ID id) const
{
    IDToEntryMap::iterator it = m_IDIndex.find (id);

    if (it == m_IDIndex.end())
        return (m_Entries.end());

    return (it->second);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CStringTable from a storage.
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, CStringTable& table)
{
    stm >> table.m_Entries;

    /*
     * rebuild the by-string and by-ID indices
     */
    EntryList::iterator it;
    table.m_StringIndex.clear();
    table.m_IDIndex.clear();

    for (it = table.m_Entries.begin(); it != table.m_Entries.end(); ++it)
    {
        table.IndexEntry (it);
    }

#ifdef DBG
    CStringTable::AssertValid (&table);
#endif

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CStringTable to a stream.  The format is:
 *
 *      DWORD   count of string entries
 *      [n string entries]
 *
 * The format of each string entry is controled by operator<<(CEntry).
 *--------------------------------------------------------------------------*/

IStream& operator<< (IStream& stm, const CStringTable& table)
{
    return (stm << table.m_Entries);
}

/*+-------------------------------------------------------------------------*
 * CStringTable::FindInsertionPointForEntry
 *
 *
 *--------------------------------------------------------------------------*/

EntryList::iterator CStringTable::FindInsertionPointForEntry (
    const CEntry& entry) const
{
    return (std::lower_bound (m_Entries.begin(), m_Entries.end(),
                              entry, CompareEntriesByID()));
}


/*+-------------------------------------------------------------------------*
 * CStringTable::ScCollectInUseIDs 
 *
 *
 *--------------------------------------------------------------------------*/

SC CStringTable::ScCollectInUseIDs (CStringIDPool::RangeList& rl) const
{
    DECLARE_SC (sc, _T("CStringTable::ScCollectInUseIDs"));
    EntryList::iterator it;

    for (it = m_Entries.begin(); it != m_Entries.end(); ++it)
    {
        if (!CStringIDPool::AddToRangeList (rl, it->m_id))
            return (sc = E_FAIL);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CStringTable::Dump () const
{
    EntryList::const_iterator it;

    for (it = m_Entries.begin(); it != m_Entries.end(); ++it)
    {
        it->Dump();
    }
}

#endif


/*+-------------------------------------------------------------------------*
 * CStringTable::AssertValid
 *
 * Asserts the validity of a CStringTable object.  It is pretty slow,
 * O(n * logn)
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CStringTable::AssertValid (const CStringTable* pTable)
{
    ASSERT (pTable != NULL);
    ASSERT (pTable->m_pIDPool != NULL);
    ASSERT (pTable->m_Entries.size() == pTable->m_StringIndex.size());
    ASSERT (pTable->m_Entries.size() == pTable->m_IDIndex.size());

    EntryList::iterator it;
    EntryList::iterator itPrev;

    /*
     * for each string in the list, make sure the string index
     * and the ID index point to the string
     */
    for (it = pTable->m_Entries.begin(); it != pTable->m_Entries.end(); ++it)
    {
        /*
         * there should be at least one reference to the string
         */
        ASSERT (it->m_cRefs > 0);

        /*
         * make sure the IDs are in ascending order (to aid debugging)
         */
        if (it != pTable->m_Entries.begin())
            ASSERT (it->m_id > itPrev->m_id);

        /*
         * validate the string index
         */
        ASSERT (pTable->LookupEntryByString (it->m_str) == it);

        /*
         * validate the ID index
         */
        ASSERT (pTable->LookupEntryByID (it->m_id) == it);

        itPrev = it;
    }
}

#endif // DBG



/*+-------------------------------------------------------------------------*
 * CStringEnumerator::CStringEnumerator
 *
 *
 *--------------------------------------------------------------------------*/

CStringEnumerator::CStringEnumerator ()
{
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::~CStringEnumerator
 *
 *
 *--------------------------------------------------------------------------*/

CStringEnumerator::~CStringEnumerator ()
{
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Init
 *
 *
 *--------------------------------------------------------------------------*/

bool CStringEnumerator::Init (const EntryList& entries)
{
    m_cStrings      = entries.size();
    m_nCurrentIndex = 0;

    if (m_cStrings > 0)
    {
        /*
         * pre-set the size of the vector to optimize allocation
         */
        m_Strings.reserve (m_cStrings);

        for (EntryList::iterator it = entries.begin(); it != entries.end(); ++it)
            m_Strings.push_back (it->m_str);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Next
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Next (ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    /*
     * validate the parameters
     */
    if ((celt > 0) && IsBadWritePtr (rgelt, celt * sizeof (*rgelt)))
        return (E_INVALIDARG);

    if ((pceltFetched != NULL) && IsBadWritePtr (pceltFetched, sizeof (*pceltFetched)))
        return (E_INVALIDARG);


    IMallocPtr spMalloc;
    HRESULT    hr = CoGetMalloc (1, &spMalloc);

    if (FAILED (hr))
        return (hr);


    /*
     * allocate copies of the next celt strings
     */
    for (int i = 0; (celt > 0) && (m_nCurrentIndex < m_Strings.size()); i++)
    {
        int cchString = m_Strings[m_nCurrentIndex].length();
        int cbAlloc   = (cchString + 1) * sizeof (WCHAR);
        rgelt[i] = (LPOLESTR) spMalloc->Alloc (cbAlloc);

        /*
         * couldn't get the buffer, free the ones we've allocated so far
         */
        if (rgelt[i] == NULL)
        {
            while (--i >= 0)
                spMalloc->Free (rgelt[i]);

            return (E_OUTOFMEMORY);
        }

        /*
         * copy this string and bump to the next one
         */
        wcscpy (rgelt[i], m_Strings[m_nCurrentIndex].data());
        m_nCurrentIndex++;
        celt--;
    }

    if ( pceltFetched != NULL)
        *pceltFetched = i;

    return ((celt == 0) ? S_OK : S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Skip
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Skip (ULONG celt)
{
    ULONG cSkip = min (celt, m_cStrings - m_nCurrentIndex);
    m_nCurrentIndex += cSkip;
    ASSERT (m_nCurrentIndex <= m_cStrings);

    return ((cSkip == celt) ? S_OK : S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Reset
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Reset ()
{
    m_nCurrentIndex = 0;
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Clone
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Clone (IEnumString **ppEnum)
{
    /*
     * Create the new CStringEnumerator object
     */
    CComObject<CStringEnumerator>* pEnumerator;
    HRESULT hr = CStringEnumerator::CreateInstanceWrapper (&pEnumerator, ppEnum);

    if (FAILED (hr))
        return (hr);

    /*
     * copy to the CStringEnuerator part of the new CComObect from this
     */
    ASSERT (pEnumerator != NULL);
    CStringEnumerator& rEnum = *pEnumerator;

    rEnum.m_cStrings      = m_cStrings;
    rEnum.m_nCurrentIndex = m_nCurrentIndex;
    rEnum.m_Strings       = m_Strings;

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::CreateInstance
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CStringEnumerator::CreateInstanceWrapper(
    CComObject<CStringEnumerator>** ppEnumObject,
    IEnumString**                   ppEnumIface)
{
    /*
     * Create the new CStringEnumerator object
     */
    HRESULT hr = CComObject<CStringEnumerator>::CreateInstance(ppEnumObject);

    if (FAILED (hr))
        return (hr);

    /*
     * get the IEnumString interface for the caller
     */
    ASSERT ((*ppEnumObject) != NULL);
    return ((*ppEnumObject)->QueryInterface (IID_IEnumString,
                                             reinterpret_cast<void**>(ppEnumIface)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\subclass.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      subclass.cpp
 *
 *  Contents:  Implementation file for the dynamic subclass manager
 *
 *  History:   06-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "subclass.h"


/*
 * Add 0x00080000 to 
 * HKLM\Software\Microsoft\Windows\CurrentVersion\AdminDebug\AMCConUI
 * to enable debug output for this module
 */
#define DEB_SUBCLASS DEB_USER4



/*--------------------------------------------------------------------------*
 * SetWindowProc 
 *
 * Changes the window procedure for a window and returns the previous
 * window procedure.
 *--------------------------------------------------------------------------*/

static WNDPROC SetWindowProc (HWND hwnd, WNDPROC pfnNewWndProc)
{
    return ((WNDPROC) SetWindowLongPtr (hwnd, GWLP_WNDPROC,
                                        (LONG_PTR) pfnNewWndProc));
}



/*--------------------------------------------------------------------------*
 * GetWindowProc 
 *
 * Returns the window procedure for a window.
 *--------------------------------------------------------------------------*/

static WNDPROC GetWindowProc (HWND hwnd)
{
    return ((WNDPROC) GetWindowLongPtr (hwnd, GWLP_WNDPROC));
}



/*--------------------------------------------------------------------------*
 * GetSubclassManager
 *
 * Returns the one-and-only subclass manager for the app.
 *--------------------------------------------------------------------------*/

CSubclassManager& GetSubclassManager()
{
    static CSubclassManager mgr;
    return (mgr);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::SubclassWindow 
 *
 * Subclasses a window.
 *--------------------------------------------------------------------------*/

bool CSubclassManager::SubclassWindow (
    HWND hwnd, 
    CSubclasser* pSubclasser)
{
    /*
     * Set up the data structure that represents this subclass.
     */
    SubclasserData subclasser (pSubclasser, hwnd);

    /*
     * Get the subclass context for this window.  If this is the
     * first time this window is being subclassed, std::map will
     * create a map entry for it.
     */
    WindowContext& ctxt = m_ContextMap[hwnd];

    /*
     * If the subclass context's wndproc pointer is NULL, then this
     * is the first time we've subclassed this window.  We need to
     * physically subclass the window with CSubclassManager's subclass proc.
     */
    if (ctxt.pfnOriginalWndProc == NULL)
    {
        ctxt.pfnOriginalWndProc = SetWindowProc (hwnd, SubclassProc);
        ASSERT (ctxt.Subclassers.empty());
        Dbg (DEB_SUBCLASS, _T("CSubclassManager subclassed window 0x%08x\n"), hwnd);
    }

    /*
     * Otherwise, make sure this isn't a redundant subclass.
     */
    else
    {
        SubclasserList::iterator itEnd   = ctxt.Subclassers.end();
        SubclasserList::iterator itFound = std::find (ctxt.Subclassers.begin(), 
                                                      itEnd, subclasser);

        /*
         * Trying to subclass a window with a given subclasser twice?
         */
        if (itFound != itEnd)
        {
            ASSERT (false);
            return (false);
        }
    }

    /*
     * Add this subclasser to this windows subclasser list.
     */
    ctxt.Insert (subclasser);
    Dbg (DEB_SUBCLASS, _T("CSubclassManager added subclass proc for window 0x%08x\n"), hwnd);

    return (true);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::UnsubclassWindow 
 *
 * Unsubclasses a window.
 *--------------------------------------------------------------------------*/

bool CSubclassManager::UnsubclassWindow (
    HWND hwnd, 
    CSubclasser* pSubclasser)
{
    /*
     * Get the subclass context for this window.  Use map::find
     * instead of map::operator[] to avoid creating a map entry if
     * one doesn't exist already
     */
    ContextMap::iterator itContext = m_ContextMap.find (hwnd);

    /*
     * Trying to unsubclass a window that's not subclassed at all?
     */
    if (itContext == m_ContextMap.end())
        return (false);

    WindowContext& ctxt = itContext->second;

    /*
     * Set up the data structure that represents this subclass.
     */
    SubclasserData subclasser (pSubclasser, hwnd);

    /*
     * Trying to unsubclass a window that's not subclassed
     * by this subclasser?
     */
    SubclasserList::iterator itEnd        = ctxt.Subclassers.end();
    SubclasserList::iterator itSubclasser = std::find (ctxt.Subclassers.begin(), itEnd, subclasser);

    if (itSubclasser == itEnd)
    {
        ASSERT (false);
        return (false);
    }

    /*
     * Remove this subclasser
     */
    UINT cRefs = ctxt.Remove (*itSubclasser);

    if (cRefs == 0)
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager removed subclass proc for window 0x%08x\n"), hwnd);
    }
    else
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager zombied subclass proc for window 0x%08x, (cRefs=%d)\n"),
                            hwnd, cRefs);
    }

    /*
     * If we just removed the last subclasser, unsubclass the window
     * and remove the window's WindowContext from the map.
     */
    if (ctxt.Subclassers.empty() && !PhysicallyUnsubclassWindow (hwnd))
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager zombied window 0x%08x\n"), hwnd);
    }

    return (true);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::PhysicallyUnsubclassWindow 
 *
 * Physically removes CSubclassManager's subclass proc from the given
 * window if it is safe (or forced) to do so.
 *
 * It is safe to remove a subclass procedure A from a window W if no one 
 * has subclassed W after A.  In other words, subclasses have to be removed
 * in a strictly LIFO order, or there's big trouble.  
 *
 * To illustrate, let's say the A subclasses W.  Messages that A doesn't  
 * handle will be passed on to W's original window procedure that was in  
 * place when A subclassed W.  Call this original procedure O.  So        
 * messages flow from A to O:                                             
 *
 *      A -> O
 *
 * Now let's say that B subclasses the W.  B will pass messages on to A, 
 * so the messages now flow like so:                                     
 *
 *      B -> A -> O
 *
 * Now say that A no longer needs to subclass W.  The typical way to
 * unsubclass a window is to put back the original window procedure that
 * was in place at the time of subclassing.  In A's case that was O, so
 * messages destined for W now flow directly to O:
 *
 *      O
 *
 * This is the first problem:  B has been shorted out of the window's
 * message stream.
 *
 * The problem gets worse when B no longer needs to subclass W.  It will
 * put back the window procedure it found when it subclassed, namely A.
 * A's work no longer needs to be done, and there's no telling whether
 * A's conduit to O is still alive.  We don't want to get into this
 * situation.
 *--------------------------------------------------------------------------*/

bool CSubclassManager::PhysicallyUnsubclassWindow (
    HWND    hwnd,                       /* I:window to unsubclass           */
    bool    fForce /* =false */)        /* I:force the unsubclass?          */
{
    ContextMap::iterator itRemove = m_ContextMap.find(hwnd);

    /*
     * If we get here, this window had better be in the map.
     */
    ASSERT (itRemove != m_ContextMap.end());

    /*
     * If no one subclassed after CSubclassManager, it's safe to unsubclass.
     */
    if (GetWindowProc (hwnd) == SubclassProc)
    {
        const WindowContext& ctxt = itRemove->second;
        SetWindowProc (hwnd, ctxt.pfnOriginalWndProc);
        fForce = true;
        Dbg (DEB_SUBCLASS, _T("CSubclassManager unsubclassed window 0x%08x\n"), hwnd);
    }

    /*
     * Remove this window's entry from the context map if appropriate.
     */
    if (fForce)
        m_ContextMap.erase (itRemove);

    return (fForce);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::SubclassProc 
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CSubclassManager::SubclassProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    return (GetSubclassManager().SubclassProcWorker (hwnd, msg, wParam, lParam));
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::SubclassProcWorker
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CSubclassManager::SubclassProcWorker (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    /*
     * Get the subclass context for this window.  Use map::find
     * instead of map::operator[] to avoid excessive overhead in 
     * map::operator[]
     */
    ContextMap::iterator itContext = m_ContextMap.find (hwnd);

    /*
     * If we get here, this window had better be in the map.
     */
    ASSERT (itContext != m_ContextMap.end());

    WindowContext& ctxt = itContext->second;
    WNDPROC pfnOriginalWndProc = ctxt.pfnOriginalWndProc;

    bool    fPassMessageOn = true;
    LRESULT rc;

    /*
     * If there are subclassers, give each one a crack at this message.
     * If a subclasser indicates it wants to eat the message, bail.
     */
    if (!ctxt.Subclassers.empty())
    {
        SubclasserList::iterator it;

        for (it  = ctxt.Subclassers.begin(); 
             it != ctxt.Subclassers.end() && fPassMessageOn;
             ++it)
        {
            SubclasserData& subclasser = *it;
            subclasser.AddRef();

            ctxt.RemoveZombies ();
    
            /*
             * If this isn't a zombied subclasser, call the callback
             */
            if (!ctxt.IsZombie(subclasser))
            {
                rc = subclasser.pSubclasser->Callback (hwnd, msg, 
                                                       wParam, lParam,
                                                       fPassMessageOn);
            }

            subclasser.Release();
        }

        ctxt.RemoveZombies ();
    }

    /*
     * Otherwise, we have a zombie window (see 
     * PhysicallyUnsubclassWindow). Try to remove the zombie now.
     */
    else if (PhysicallyUnsubclassWindow (hwnd))
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager removed zombied window 0x%08x\n"), hwnd);
    }

    /*
     * remove this window's WindowContext on WM_NCDESTROY
     */
    if ((msg == WM_NCDESTROY) && 
        (m_ContextMap.find(hwnd) != m_ContextMap.end()))
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager forced removal of zombied window 0x%08x on WM_NCDESTROY\n"), hwnd);
        PhysicallyUnsubclassWindow (hwnd, true);
    }

    /*
     * If the last subclasser didn't eat the message, 
     * give it to the original window procedure.
     */
    if (fPassMessageOn)
        rc = CallWindowProc (pfnOriginalWndProc, hwnd, msg, wParam, lParam);

    return (rc);
}



/*--------------------------------------------------------------------------*
 * WindowContext::IsZombie 
 *
 *
 *--------------------------------------------------------------------------*/

bool WindowContext::IsZombie (const SubclasserData& subclasser) const
{
    /*
     * If this is a zombie, make sure it's in the zombie list;
     * if it's not, make sure it's not.
     */
    ASSERT (subclasser.fZombie == (Zombies.find(subclasser) != Zombies.end()));

    return (subclasser.fZombie);
}



/*--------------------------------------------------------------------------*
 * WindowContext::Zombie
 *
 * Changes the state fo a subclasser to or from a zombie.
 *--------------------------------------------------------------------------*/

void WindowContext::Zombie (SubclasserData& subclasser, bool fZombie)
{
    // zombie-ing a zombied subclasser?
    ASSERT (IsZombie (subclasser) != fZombie);

    subclasser.fZombie = fZombie;

    if (fZombie)
        Zombies.insert (subclasser);
    else
        Zombies.erase (subclasser);

    ASSERT (IsZombie (subclasser) == fZombie);
}



/*--------------------------------------------------------------------------*
 * WindowContext::Insert 
 *
 *
 *--------------------------------------------------------------------------*/

void WindowContext::Insert (SubclasserData& subclasser)
{
    /*
     * This code can't handle re-subclassing by a subclasser 
     * that's currently a zombie.  If this ever becomes a requirement,
     * we'll need to identify the subclass instance by something other
     * than the CSubclasser pointer, like a unique handle.
     */
    ASSERT (Zombies.find(subclasser) == Zombies.end());

    /*
     * Subclassers get called in LIFO order, put the new 
     * subclasser at the head of the list.
     */
    Subclassers.push_front (subclasser);
}



/*--------------------------------------------------------------------------*
 * WindowContext::Remove 
 *
 * Logically removes a subclasser from the subclass chain.  "Logically"
 * because it's not safe to totally remove a subclasser from the chain if
 * it's currently in use.  If the subclass is in use when we want to remove
 * it, we'll mark it as "zombied" so it won't be used any more, to be 
 * physically removed later.
 *
 * Returns the reference count for the subclasser.
 *--------------------------------------------------------------------------*/

UINT WindowContext::Remove (SubclasserData& subclasser)
{
    // we shouldn't be removing zombies this way
    ASSERT (!IsZombie (subclasser));

    /*
     * If this subclasser has outstanding references, zombie it instead
     * of removing it.
     */
    UINT cRefs = subclasser.cRefs;

    if (cRefs == 0)
    {
        SubclasserList::iterator itRemove = std::find (Subclassers.begin(), 
                                                       Subclassers.end(),
                                                       subclasser);
        ASSERT (itRemove != Subclassers.end());
        Subclassers.erase (itRemove);
    }
    else
    {
        Zombie (subclasser, true);
    }

    return (cRefs);
}



/*--------------------------------------------------------------------------*
 * WindowContext::RemoveZombies 
 *
 *
 *--------------------------------------------------------------------------*/

void WindowContext::RemoveZombies ()
{
    if (Zombies.empty())
        return;

    /*
     * Build up a list of zombies that we can remove.  We have to build
     * the list ahead of time, instead of removing them as we find them,
     * because removing an element from a set invalidates all iterators
     * on the set.
     */
    SubclasserSet   ZombiesToRemove;

    SubclasserSet::iterator itEnd = Zombies.end();
    SubclasserSet::iterator it;

    for (it = Zombies.begin(); it != itEnd; ++it)
    {
        const SubclasserData& ShadowSubclasser = *it;

        /*
         * Find the real subclasser in the Subclassers list.  That's
         * the live one whose ref count will be correct.
         */
        SubclasserList::iterator itReal = std::find (Subclassers.begin(), 
                                                     Subclassers.end(),
                                                     ShadowSubclasser);

        const SubclasserData& RealSubclasser = *itReal;

        if (RealSubclasser.cRefs == 0)
        {
            Dbg (DEB_SUBCLASS, _T("CSubclassManager removed zombied subclass proc for window 0x%08x\n"),
                                RealSubclasser.hwnd);
            ZombiesToRemove.insert (ShadowSubclasser);
            Subclassers.erase (itReal);
        }
    }

    /*
     * Now remove the truly dead zombies.
     */
    itEnd = ZombiesToRemove.end();

    for (it = ZombiesToRemove.begin(); it != itEnd; ++it)
    {
        Zombies.erase (*it);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\subclass.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      subclass.h  
 *
 *  Contents:  Interface file for the dynamic subclass manager
 *
 *  History:   06-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef __SUBCLASS_H__
#define __SUBCLASS_H__
#pragma once


// remove the definition from windowsx.h that conflicts with declarations here
#ifdef SubclassWindow
#undef SubclassWindow
#endif



/*--------------------------------------------------------------------------*
 * CSubclasser
 *
 * Derive a class from this to implement subclassing the subclass manager
 * way.
 *--------------------------------------------------------------------------*/

class CSubclasser
{
public:
    virtual ~CSubclasser() {}

    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam, 
                              LPARAM& lParam, bool& fPassMessageOn) = 0;
};


/*----------------*/
/* SubclasserData */
/*----------------*/
class SubclasserData
{
public:
    SubclasserData (CSubclasser* pSubclasser_ = NULL, HWND hwnd = NULL)
        :   pSubclasser (pSubclasser_),
            hwnd        (hwnd),
            cRefs       (0),
            fZombie     (false)
        {}

    UINT AddRef ()
        { return (++cRefs); }

    UINT Release ()
        { ASSERT (cRefs > 0); return (--cRefs); }

    bool operator==(const SubclasserData& other) const
        { return (pSubclasser == other.pSubclasser); }

    bool operator<(const SubclasserData& other) const
        { return (pSubclasser < other.pSubclasser); }

    CSubclasser* pSubclasser;

private:
    friend class WindowContext;

    HWND    hwnd;
    UINT    cRefs;
    bool    fZombie;
};

typedef std::list<SubclasserData>   SubclasserList;
typedef std::set< SubclasserData>   SubclasserSet;


/*---------------*/
/* WindowContext */
/*---------------*/
class WindowContext
{
public:
    WindowContext() : pfnOriginalWndProc(NULL) 
        {}

    bool IsZombie(const SubclasserData& subclasser) const;
    void Insert(SubclasserData& subclasser);
    UINT Remove(SubclasserData& subclasser);
    void RemoveZombies();

    SubclasserList  Subclassers;
    WNDPROC         pfnOriginalWndProc;

private:
    void Zombie(SubclasserData& subclasser, bool fZombie);

    SubclasserSet   Zombies;
};


/*------------------*/
/* CSubclassManager */
/*------------------*/
class CSubclassManager
{
public:
    bool SubclassWindow   (HWND hwnd, CSubclasser* pSubclasser);
    bool UnsubclassWindow (HWND hwnd, CSubclasser* pSubclasser);

private:
    typedef std::map<HWND, WindowContext>   ContextMap;
    ContextMap  m_ContextMap;

    bool PhysicallyUnsubclassWindow (HWND hwnd, bool fForce = false);
    LRESULT SubclassProcWorker (HWND, UINT, WPARAM, LPARAM);

    static LRESULT CALLBACK SubclassProc (HWND, UINT, WPARAM, LPARAM);
};

CSubclassManager& GetSubclassManager();


#endif /* __SUBCLASS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\taskhost.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       TaskHost.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/17/1997   RaviR   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "amcdoc.h"
#include "amcview.h"
#include "taskhost.h"


STDMETHODIMP
CTaskPadHost::GetTaskEnumerator(
    BSTR bstrTaskGroup,
    IEnumTASK** ppEnumTask)
{
    ASSERT(ppEnumTask != NULL);
    if (!ppEnumTask)
        return E_POINTER;

    ASSERT(m_pAMCView);
    if (!m_pAMCView)
        return E_UNEXPECTED;

    HNODE hNode = m_pAMCView->GetSelectedNode();
    ASSERT(hNode != NULL);
    if (!hNode)
        return E_UNEXPECTED;

    INodeCallback* pNC = _GetNodeCallback();
    ASSERT(pNC != NULL);
    if (!pNC)
        return E_UNEXPECTED;

    // do not pas NULL, pas empty string instead
    LPCOLESTR strTaskGroup = bstrTaskGroup ? bstrTaskGroup : L"";

    return pNC->GetTaskEnumerator(hNode, strTaskGroup, ppEnumTask);
}


STDMETHODIMP
CTaskPadHost::TaskNotify(
    BSTR szClsid,
    VARIANT* pvArg,
    VARIANT* pvParam)
{
    ASSERT(m_pAMCView);
    if (!m_pAMCView)
        return E_UNEXPECTED;

    HNODE hNode = m_pAMCView->GetSelectedNode();
    ASSERT(hNode != NULL);
    if (!hNode)
        return E_UNEXPECTED;

    INodeCallback* pNC = _GetNodeCallback();
    if (!pNC)
        return E_UNEXPECTED;

    VARIANT* ppv[2] = {pvArg, pvParam};

    pNC->Notify(hNode, NCLBK_TASKNOTIFY, reinterpret_cast<LPARAM>(szClsid),
                reinterpret_cast<LPARAM>(ppv));

    return S_OK;
}

STDMETHODIMP
CTaskPadHost::GetPrimaryTask(
    IExtendTaskPad** ppExtendTaskPad)
{
    ASSERT(ppExtendTaskPad != NULL);
    if (!ppExtendTaskPad)
        return E_POINTER;

    if (m_spExtendTaskPadPrimary == NULL)
    {
        HNODE hNode = m_pAMCView->GetSelectedNode();
        ASSERT(hNode != NULL);
        if (!hNode)
            return E_UNEXPECTED;

        INodeCallback* pNC = _GetNodeCallback();
        if (!pNC)
            return E_UNEXPECTED;

        HRESULT hr = pNC->Notify(hNode, NCLBK_GETPRIMARYTASK, NULL,
                                reinterpret_cast<LPARAM>(&m_spExtendTaskPadPrimary));
        if (hr != S_OK)
            return hr;

        ASSERT (m_spExtendTaskPadPrimary != NULL);
        if (m_spExtendTaskPadPrimary == NULL)
            return E_UNEXPECTED;
    }

    *ppExtendTaskPad = m_spExtendTaskPadPrimary;
    (*ppExtendTaskPad)->AddRef ();

    return S_OK;
}

STDMETHODIMP
CTaskPadHost::GetTitle(
    BSTR bstrTaskGroup,
    BSTR* pbstrOut)
{
    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    LPOLESTR szString = NULL;
    HRESULT hr = pExtendTaskPad->GetTitle (bstrTaskGroup, &szString);
    ASSERT ((hr == S_OK) && (szString != NULL));
    if ((hr == S_OK) && (szString != NULL)) {
        *pbstrOut = SysAllocString (szString);
        ASSERT (pbstrOut != NULL);
        CoTaskMemFree (szString);
        if (pbstrOut == NULL)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP
CTaskPadHost::GetDescriptiveText(
    BSTR bstrTaskGroup,
    BSTR* pbstrOut)
{
    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    LPOLESTR szString = NULL;
    HRESULT hr = pExtendTaskPad->GetDescriptiveText (bstrTaskGroup, &szString);
// optional ASSERT ((hr == S_OK) && (szString != NULL));
    if ((hr == S_OK) && (szString != NULL)) {
        *pbstrOut = SysAllocString (szString);
        ASSERT (pbstrOut != NULL);
        CoTaskMemFree (szString);
        if (pbstrOut == NULL)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP
CTaskPadHost::GetBackground(
    BSTR bstrTaskGroup,
    MMC_TASK_DISPLAY_OBJECT * pTDO)
{
    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    LPOLESTR szString = NULL;
    HRESULT hr = pExtendTaskPad->GetBackground (bstrTaskGroup, pTDO);
// optional ASSERT (hr == S_OK);
    return hr;
}

STDMETHODIMP CTaskPadHost::GetListPadInfo(BSTR szTaskGroup, MMC_ILISTPAD_INFO * pIListPadInfo)
{
    ASSERT(pIListPadInfo != NULL);
    ASSERT (!IsBadWritePtr (pIListPadInfo, sizeof(MMC_ILISTPAD_INFO)));

    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    ASSERT(m_pAMCView);
    if (!m_pAMCView)
        return E_UNEXPECTED;

    HNODE hNode = m_pAMCView->GetSelectedNode();
    ASSERT(hNode != NULL);
    if (!hNode)
        return E_UNEXPECTED;

    INodeCallback* pNC = _GetNodeCallback();
    ASSERT(pNC != NULL);
    if (!pNC)
        return E_UNEXPECTED;

    return pNC->GetListPadInfo (hNode, pExtendTaskPad, (LPOLESTR)szTaskGroup, pIListPadInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\taskhost.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       taskhost.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/19/1997   RaviR   Created
//____________________________________________________________________________
//

#ifndef TASKHOST_H__
#define TASKHOST_H__

class CTaskPadHost : public ITaskPadHost,
                     public CComObjectRoot
{
// Constructor & destructor
public:
    CTaskPadHost() : m_pAMCView(NULL)
    {
    }
    void Init(CAMCView* pv)
    {
        ASSERT(pv);
        m_pAMCView = pv;
    }
    ~CTaskPadHost()
    {
        m_pAMCView = NULL;
    }

// ATL COM map
public:
BEGIN_COM_MAP(CTaskPadHost)
    COM_INTERFACE_ENTRY(ITaskPadHost)
END_COM_MAP()

// ITaskPadHost methods
public:

    STDMETHOD(TaskNotify        )(BSTR szClsid, VARIANT * pvArg, VARIANT * pvParam);
    STDMETHOD(GetTaskEnumerator )(BSTR szTaskGroup, IEnumTASK** ppEnumTASK);
    STDMETHOD(GetPrimaryTask    )(IExtendTaskPad** ppExtendTaskPad);
    STDMETHOD(GetTitle          )(BSTR szTaskGroup, BSTR * pbstrTitle);
    STDMETHOD(GetDescriptiveText)(BSTR szTaskGroup, BSTR * pbstrDescriptiveText);
    STDMETHOD(GetBackground     )(BSTR szTaskGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
//  STDMETHOD(GetBranding       )(BSTR szTaskGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
    STDMETHOD(GetListPadInfo    )(BSTR szTaskGroup, MMC_ILISTPAD_INFO * pIListPadInfo);

// Implementation
private:
    CAMCView*           m_pAMCView;
    IExtendTaskPadPtr   m_spExtendTaskPadPrimary;

    INodeCallback* _GetNodeCallback(void)
    {
        return m_pAMCView->GetNodeCallback();
    }

    IExtendTaskPad* _GetPrimaryExtendTaskPad()
    {
        if (m_spExtendTaskPadPrimary == NULL)
        {
            IExtendTaskPadPtr spExtendTaskPad;
            HRESULT hr = GetPrimaryTask(&spExtendTaskPad);
            if (SUCCEEDED(hr))
                m_spExtendTaskPadPrimary.Attach(spExtendTaskPad.Detach());
        }

        ASSERT(m_spExtendTaskPadPrimary != NULL);
        return m_spExtendTaskPadPrimary;
    }

// Ensure that default copy constructor & assignment are not used.
    CTaskPadHost(const CTaskPadHost& rhs);
    CTaskPadHost& operator=(const CTaskPadHost& rhs);

}; // class CTaskPadHost


#endif // TASKHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\tbtrack.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tbtrack.cpp
 *
 *  Contents:  Implementation file for CToolbarTracker
 *
 *  History:   15-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "tbtrack.h"
#include "controls.h"
#include "mainfrm.h"
#include "childfrm.h"


/*+-------------------------------------------------------------------------*
 * GetMainAuxWnd
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTrackerAuxWnd* GetMainAuxWnd()
{
    CMainFrame* pFrame = AMCGetMainWnd();
    if (pFrame == NULL)
        return (NULL);

    CToolbarTracker* pTracker = pFrame->GetToolbarTracker();
    if (pTracker == NULL)
        return (NULL);

    return (pTracker->GetAuxWnd());
}


/*--------------------------------------------------------------------------*
 * IsToolbar
 *
 *
 *--------------------------------------------------------------------------*/

static bool IsToolbar (HWND hwnd)
{
    TCHAR   szClassName[countof (TOOLBARCLASSNAME) + 1];

    GetClassName (hwnd, szClassName, countof (szClassName));
    return (lstrcmpi (szClassName, TOOLBARCLASSNAME) == 0);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CToolbarTracker
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::CToolbarTracker(CWnd* pMainFrame)
    :   m_Subclasser   (this, pMainFrame),
        m_pAuxWnd      (NULL),
        m_fTerminating (false)
{
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::~CToolbarTracker
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::~CToolbarTracker()
{
    if (IsTracking ())
        EndTracking ();

    ASSERT (!IsTracking ());
    ASSERT (m_pAuxWnd == NULL);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::BeginTracking
 *
 *
 *--------------------------------------------------------------------------*/

bool CToolbarTracker::BeginTracking()
{
    ASSERT (!m_fTerminating);
    ASSERT (!IsTracking ());

    /*
     * Allocate a new CToolbarTrackerAuxWnd.  We want to hold it in a
     * temporary instead of assigning directly to m_pAuxWnd so that
     * CMMCToolBarCtrlEx::OnHotItemChange will allow the hot item
     * changes that CToolbarTrackerAuxWnd::EnumerateToolbars will attempt.
     */
    std::auto_ptr<CToolbarTrackerAuxWnd> spAuxWnd(new CToolbarTrackerAuxWnd(this));

    if (!spAuxWnd->BeginTracking ())
        return (false);

    m_pAuxWnd = spAuxWnd.release();
    ASSERT (IsTracking ());

    return (true);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::EndTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTracker::EndTracking()
{
    if (m_fTerminating)
        return;

    ASSERT (IsTracking ());
    m_fTerminating = true;

    m_pAuxWnd->EndTracking ();
    delete m_pAuxWnd;
    m_pAuxWnd = NULL;

    m_fTerminating = false;
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CFrameSubclasser::CFrameSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::CFrameSubclasser::CFrameSubclasser (CToolbarTracker* pTracker, CWnd* pwnd)
    :   m_hwnd     (pwnd->GetSafeHwnd()),
        m_pTracker (pTracker)
{
    GetSubclassManager().SubclassWindow (m_hwnd, this);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CFrameSubclasser::~CFrameSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::CFrameSubclasser::~CFrameSubclasser ()
{
    GetSubclassManager().UnsubclassWindow (m_hwnd, this);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CFrameSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CToolbarTracker::CFrameSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    switch (msg)
    {
        case WM_SYSCOMMAND:
            if ((wParam & 0xFFF0) == SC_CLOSE)
            {
                /*
                 * tracking? stop now.
                 * or else close will not go thru,
                 * since we hold the capture
                 */
                if ((m_pTracker != NULL) && (m_pTracker->IsTracking ()))
                    m_pTracker->EndTracking ();
            }
            else if ((wParam & 0xFFF0) == SC_KEYMENU)
            {
                /*
                 * tracking? stop now.
                 */
                if (m_pTracker->IsTracking ())
                    m_pTracker->EndTracking ();

                /*
                 * not tracking and this was a simple Alt,
                 * (not Alt+Space or Alt+-)? start now
                 */
                else if (lParam == 0)
                    m_pTracker->BeginTracking ();

                /*
                 * don't let simple Alt through, regardless of whether
                 * we started or ended tracking
                 */
                if (lParam == 0)
                    fPassMessageOn = false;
            }
            break;

        case WM_ACTIVATE:
        case WM_ACTIVATEAPP:
        case WM_ACTIVATETOPLEVEL:
//      case WM_ENTERMENULOOP:
        case WM_CANCELMODE:
            if (m_pTracker->IsTracking ())
                m_pTracker->EndTracking ();
            break;
    }

    return (0);
}


/////////////////////////////////////////////////////////////////////////////
// CToolbarTrackerAuxWnd

BEGIN_MESSAGE_MAP(CToolbarTrackerAuxWnd, CWnd)
    //{{AFX_MSG_MAP(CToolbarTrackerAuxWnd)
    ON_COMMAND(ID_CMD_NEXT_TOOLBAR, OnNextToolbar)
    ON_COMMAND(ID_CMD_PREV_TOOLBAR, OnPrevToolbar)
    ON_COMMAND(ID_CMD_NOP, OnNop)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::CToolbarTrackerAuxWnd
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTrackerAuxWnd::CToolbarTrackerAuxWnd(CToolbarTracker* pTracker)
    :   m_pTracker        (pTracker),
        m_pTrackedToolbar (NULL),
        m_fMessagesHooked (false)
{
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::~CToolbarTrackerAuxWnd
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTrackerAuxWnd::~CToolbarTrackerAuxWnd()
{
    /*
     * if any of these fail, EndTracking hasn't been called
     */
    ASSERT (m_pTrackedToolbar == NULL);
    ASSERT (m_hWnd == NULL);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::BeginTracking
 *
 *
 *--------------------------------------------------------------------------*/

bool CToolbarTrackerAuxWnd::BeginTracking ()
{
    CMainFrame* pMainFrame = AMCGetMainWnd();
    if (pMainFrame == NULL)
        return (false);

    /*
     * create a dummy window to be the target of WM_COMMANDs from accelerators
     */
    if (!Create (NULL, NULL, WS_DISABLED, g_rectEmpty, pMainFrame, 0))
        return (false);

    /*
     * enumerate the toolbars for the main frame
     */
    EnumerateToolbars (pMainFrame->GetRebar());

    /*
     * if there aren't any toolbars, don't track
     */
    if (m_vToolbars.empty())
    {
        DestroyWindow ();
        return (false);
    }

    /*
     * track the first toolbar
     */
    TrackToolbar (m_vToolbars[0]);

    /*
     * hook into the translate message chain
     */
    AMCGetApp()->HookPreTranslateMessage (this);
    m_fMessagesHooked = true;

    return (true);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::EndTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::EndTracking ()
{
    /*
     * stop tracking the tracked toolbar, if there is one
     */
    if (m_pTrackedToolbar != NULL)
        m_pTrackedToolbar->EndTracking2 (this);

    /*
     * get out of the translate message chain
     */
    if (m_fMessagesHooked)
    {
        AMCGetApp()->UnhookPreTranslateMessage (this);
        m_fMessagesHooked = false;
    }

    /*
     * destroy the auxilliary window
     */
    DestroyWindow();
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::GetTrackAccel
 *
 * Manages the accelerator table singleton for CToolbarTrackerAuxWnd
 *--------------------------------------------------------------------------*/

const CAccel& CToolbarTrackerAuxWnd::GetTrackAccel ()
{
    static ACCEL aaclTrack[] = {
        { FVIRTKEY | FCONTROL,          VK_TAB,         ID_CMD_NEXT_TOOLBAR },
        { FVIRTKEY | FCONTROL | FSHIFT, VK_TAB,         ID_CMD_PREV_TOOLBAR },

        /*
         * These keys are used by MMC.
         * We need to eat them when we're tracking toolbars.
         */
        { FVIRTKEY | FSHIFT,            VK_F10,         ID_CMD_NOP },
    };

    static const CAccel TrackAccel (aaclTrack, countof (aaclTrack));
    return (TrackAccel);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::PreTranslateMessage
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CToolbarTrackerAuxWnd::PreTranslateMessage(MSG* pMsg)
{
    if (m_pTrackedToolbar != NULL)
    {
        if ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST))
        {
            // give the tracked toolbar a crack
            if (m_pTrackedToolbar->PreTranslateMessage (pMsg))
                return (true);

            const CAccel& TrackAccel = GetTrackAccel();
            ASSERT (TrackAccel != NULL);

            // ...or try to handle it here.
            if (TrackAccel.TranslateAccelerator (m_hWnd, pMsg))
                return (true);

            /*
             * eat keystrokes that might be used by the tree or list controls
             */
            switch (pMsg->wParam)
            {
                case VK_UP:
                case VK_DOWN:
                case VK_LEFT:
                case VK_RIGHT:
                case VK_NEXT:
                case VK_PRIOR:
                case VK_RETURN:
                case VK_BACK:
                case VK_HOME:
                case VK_END:
                case VK_ADD:
                case VK_SUBTRACT:
                case VK_MULTIPLY:
                    return (true);

                default:
                    break;
            }
        }

        // swallow WM_CONTEXTMENU, too
        if (pMsg->message == WM_CONTEXTMENU)
            return (true);
    }

    // bypass the base class
    return (false);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::TrackToolbar
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::TrackToolbar (CMMCToolBarCtrlEx* pwndNewToolbar)
{
    if (pwndNewToolbar == m_pTrackedToolbar)
        return;

    // protect against recursion via EndTracking
    CMMCToolBarCtrlEx*  pwndOldToolbar = m_pTrackedToolbar;
    m_pTrackedToolbar = NULL;

    // if we were tracking one, quit tracking it
    if (pwndOldToolbar != NULL)
    {
        pwndOldToolbar->EndTracking2 (this);

        /*
         * if we're ending tracking entirely, not just tracking a different
         * toolbar, remove this window from the translate message hook chain
         */
        if (pwndNewToolbar == NULL)
        {
            m_pTracker->EndTracking ();

            /*
             * CToolbarTracker::EndTracking will delete this
             * object, so we need to get outta here -- now!
             */
            return;
        }
    }

    // now track the new one (and let it know about it)
    m_pTrackedToolbar = pwndNewToolbar;

    if (m_pTrackedToolbar != NULL)
        m_pTrackedToolbar->BeginTracking2 (this);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::OnNextToolbar
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::OnNextToolbar ()
{
    ASSERT (m_pTrackedToolbar);
    CMMCToolBarCtrlEx*  pwndNextToolbar = GetToolbar (m_pTrackedToolbar, true);

    if (m_pTrackedToolbar != pwndNextToolbar)
        TrackToolbar (pwndNextToolbar);

    ASSERT (m_pTrackedToolbar == pwndNextToolbar);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::OnPrevToolbar
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::OnPrevToolbar ()
{
    ASSERT (m_pTrackedToolbar);
    CMMCToolBarCtrlEx*  pwndPrevToolbar = GetToolbar (m_pTrackedToolbar, false);

    if (m_pTrackedToolbar != pwndPrevToolbar)
        TrackToolbar (pwndPrevToolbar);

    ASSERT (m_pTrackedToolbar == pwndPrevToolbar);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::OnNop
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::OnNop ()
{
    // do nothing
}



/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::EnumerateToolbars
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::EnumerateToolbars (
    CRebarWnd* pRebar)
{
    int cBands = pRebar->GetBandCount ();

    REBARBANDINFO   rbi;
    ZeroMemory (&rbi, sizeof (rbi));
    rbi.cbSize = sizeof (rbi);
    rbi.fMask  = RBBIM_CHILD;

    /*
     * enumerate children of the rebar looking for toolbars
     */
    for (int i = 0; i < cBands; i++)
    {
        pRebar->GetBandInfo (i, &rbi);

        /*
         * ignore this window if it's hidden or disabled
         */
        DWORD dwStyle = ::GetWindowLong (rbi.hwndChild, GWL_STYLE);

        if (!(dwStyle & WS_VISIBLE) || (dwStyle & WS_DISABLED))
            continue;

        /*
         * get the (permanent) CMMCToolBarCtrlEx pointer for the child
         */
        CMMCToolBarCtrlEx*  pwndToolbar =
                dynamic_cast<CMMCToolBarCtrlEx *> (
                        CWnd::FromHandlePermanent (rbi.hwndChild));

        /*
         * if we got a toolbar, save it in our list of toolbars to track
         */
        if (pwndToolbar != NULL)
        {
            m_vToolbars.push_back (pwndToolbar);

            /*
             * make sure this toolbar doesn't have a hot item
             */
            pwndToolbar->SetHotItem (-1);
        }
    }
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::GetToolbar
 *
 *
 *--------------------------------------------------------------------------*/

CMMCToolBarCtrlEx* CToolbarTrackerAuxWnd::GetToolbar (
    CMMCToolBarCtrlEx*  pCurrentToolbar,
    bool                fNext)
{
    CMMCToolBarCtrlEx*  pTargetToolbar = NULL;
    int cToolbars = m_vToolbars.size();

    if (cToolbars > 0)
    {
        // find the current toolbar in the vector
        ToolbarVector::iterator itCurrent =
                std::find (m_vToolbars.begin(), m_vToolbars.end(), pCurrentToolbar);

        ASSERT ( itCurrent != m_vToolbars.end());
        ASSERT (*itCurrent == pCurrentToolbar);

        int nCurrentIndex = itCurrent - m_vToolbars.begin();

        // now find the target toolbar
        ASSERT ((fNext == 0) || (fNext == 1));
        int nTargetIndex = (nCurrentIndex + (fNext * 2 - 1) + cToolbars) % cToolbars;
        ASSERT ((nTargetIndex >= 0) && (nTargetIndex < cToolbars));
        ASSERT ((cToolbars == 1) || (nTargetIndex != nCurrentIndex));

        pTargetToolbar = m_vToolbars[nTargetIndex];
        ASSERT (pTargetToolbar != NULL);
    }

    return (pTargetToolbar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\sysmenu.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      sysmenu.h
 *
 *  Contents:  Interface file for system menu modification functions
 *
 *  History:   04-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef SYSMENU_H
#define SYSMENU_H


int AppendToSystemMenu (CWnd* pwnd, int nSubmenuIndex);
int AppendToSystemMenu (CWnd* pwnd, CMenu* pMenuToAppend, CMenu* pSysMenu = NULL);


#endif /* SYSMENU.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\svfildlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       svfildlg.cpp
//
//--------------------------------------------------------------------------

// svfildlg.cpp : implSELECTEDementation file
//
#include "stdafx.h"

#ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)

#include "svfildlg.h"

#include <shlobj.h>
#include "AMC.h"
#include "AMCDoc.h"
#include "Shlwapi.h"
#include <windows.h>
#include "macros.h"

// The following constant is defined in Windows.hlp
// So we need to use windows.hlp for help on this topic.
#define IDH_SAVE_SELECTED_ROWS 29520

/////////////////////////////////////////////////////////////////////////////
// CSaveFileDialog dialog


const TCHAR CSaveFileDialog::strSection[] =    _T("Settings");
const TCHAR CSaveFileDialog::strStringItem[] = _T("List Save Location");


CSaveFileDialog::CSaveFileDialog(BOOL bOpenFileDialog,
        LPCTSTR lpszDefExt, LPCTSTR lpszFileName, DWORD dwFlags,
        LPCTSTR lpszFilter, bool bSomeRowSelected, CWnd* pParentWnd)
    : CFileDialogEx(bOpenFileDialog, lpszDefExt, lpszFileName,
        dwFlags, lpszFilter, pParentWnd), m_bSomeRowSelected(bSomeRowSelected)
{
    //{{AFX_DATA_INIT(CSaveFileDialog)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_ofn.lpstrInitialDir = NULL;

    // Set the initial path

    // 1st choice
    // Try to access the default directory in the registry
    CWinApp* pApp = AfxGetApp();
    m_strRegPath = pApp->GetProfileString (strSection, strStringItem);

    // Check if the directory is valid, if so then it is now the starting directory
    DWORD validdir = GetFileAttributes(m_strRegPath);
    if ((validdir != 0xFFFFFFFF) && (validdir | FILE_ATTRIBUTE_DIRECTORY))
        m_ofn.lpstrInitialDir = m_strRegPath;

    // 2nd choice:
    // Set the initial save directory to the personal directory

    // Get the user's personal directory
    // We'll get it now since we'll ust it in the destructor as well
    LPITEMIDLIST pidl;
    HRESULT hres = SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl) ;

    if (SUCCEEDED(hres))
    {
        SHGetPathFromIDList(pidl, szPath);

        // Free the pidl
        IMallocPtr spMalloc;
        SHGetMalloc(&spMalloc);
        spMalloc->Free(pidl);

        if ((m_ofn.lpstrInitialDir == NULL) && (SUCCEEDED(hres)))
            m_ofn.lpstrInitialDir = szPath;
    }

    // 3rd choice: The current directory (m_ofn.lpstrInitialDir = NULL; was set above)


    // Set additional items about the dialog box

    ZeroMemory(szFileName, sizeof(szFileName));
    m_ofn.lpstrFile = szFileName;
    m_ofn.nMaxFile = countof(szFileName);

    m_ofn.Flags |= (OFN_ENABLETEMPLATE|OFN_EXPLORER|OFN_PATHMUSTEXIST);
    m_ofn.lpTemplateName = MAKEINTRESOURCE(HasModernFileDialog() ? IDD_LIST_SAVE_NEW : IDD_LIST_SAVE);
    m_flags = 0;

    // Set the title of the dialog.
    if (LoadString(m_strTitle, IDS_EXPORT_LIST))
        m_ofn.lpstrTitle = (LPCTSTR)m_strTitle;
}

CSaveFileDialog::~CSaveFileDialog()
{
    // Get the path of the file that was just saved
    if (*m_ofn.lpstrFile == '\0' || m_ofn.nFileOffset < 1)
        return;

    CString strRecentPath(m_ofn.lpstrFile, m_ofn.nFileOffset - 1);

    // If the personal path exists and it is different from the old path, then change or add
    // the registry entry
    if ((szPath != NULL) && (strRecentPath != m_strRegPath))
        AfxGetApp()->WriteProfileString (strSection, strStringItem, strRecentPath);
}

void CSaveFileDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CConsolePropPage)
        //{{AFX_DATA_MAP(CSaveFileDialog)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaveFileDialog, CDialog)
    //{{AFX_MSG_MAP(CSaveFileDialog)
    ON_BN_CLICKED(IDC_SEL,  OnSel)
    //}}AFX_MSG_MAP
	ON_MESSAGE(WM_INITDIALOG, OnInitDialog)
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaveFileDialog message handlers

void CSaveFileDialog::OnSel()
{
    m_flags ^= SELECTED;    // Toggle the Selected flag
}

LRESULT CSaveFileDialog::OnInitDialog(WPARAM, LPARAM)
{
	DECLARE_SC (sc, _T("CSaveFileDialog::OnInitDialog"));
    CDialog::OnInitDialog();

    HWND hwndSelRowsOnly = ::GetDlgItem(*this, IDC_SEL);
    if (hwndSelRowsOnly)
        ::EnableWindow(hwndSelRowsOnly, m_bSomeRowSelected );

	return TRUE;
}

#endif  // IMPLEMENT_LIST_SAVE        See nodemgr.idl (t-dmarm)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\svfildlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       svfildlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SVFILDLG_H__28CEAD2E_10E1_11D2_BA23_00C04F8141EF__INCLUDED_)
#define AFX_SVFILDLG_H__28CEAD2E_10E1_11D2_BA23_00C04F8141EF__INCLUDED_

#ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)

#include "filedlgex.h"

// Flags
#define SELECTED       0x0001

// File Types
// Please do not change the order. This order is same
// as the IDS_FILE_TYPE string which contains
// the file types in resource file.
enum eFileTypes
{
    FILE_ANSI_TEXT = 1,
    FILE_ANSI_CSV,
    FILE_UNICODE_TEXT,
    FILE_UNICODE_CSV
};

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// svfildlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaveFileDialog dialog

class CSaveFileDialog : public CFileDialogEx
{
    //DECLARE_DYNCREATE(CSaveFileDialog)
// Construction
public:
    CSaveFileDialog(BOOL bOpenFileDialog,
        LPCTSTR lpszDefExt = NULL,
        LPCTSTR lpszFileName = NULL,
        DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
        LPCTSTR lpszFilter = NULL,
        bool bSomeRowSelected = false,
        CWnd* pParentWnd = NULL);   // standard constructor

    DWORD Getflags()
    {
        return m_flags;
    }

    eFileTypes GetFileType()
    {
        return (eFileTypes)m_ofn.nFilterIndex;
    }

    ~CSaveFileDialog();


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSaveFileDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSaveFileDialog)
    afx_msg void OnSel();
    //}}AFX_MSG

    LRESULT OnInitDialog(WPARAM, LPARAM);
    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_LIST_SAVE);

    DECLARE_MESSAGE_MAP()

private:
    static const TCHAR strSection[];
    static const TCHAR strStringItem[];
    TCHAR   szPath[MAX_PATH];
    TCHAR   szFileName[MAX_PATH];
    CString m_strTitle;
    CString m_strRegPath;
    DWORD   m_flags;
	bool    m_bSomeRowSelected;
};

#endif // IMPLEMENT_LIST_SAVE        See nodemgr.idl (t-dmarm)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVFILDLG_H__28CEAD2E_10E1_11D2_BA23_00C04F8141EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\sysmenu.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      sysmenu.cpp
 *
 *  Contents:  Implementation file for system menu modification functions
 *
 *  History:   04-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "sysmenu.h"
#include "mmcres.h"
#include <list>
#include <algorithm>


typedef std::list<HWND> WindowList;



/*--------------------------------------------------------------------------*
 * GetWindowList
 *
 *
 *--------------------------------------------------------------------------*/

static WindowList& GetWindowList()
{
    static WindowList   List;
    return (List);
}



/*--------------------------------------------------------------------------*
 * WipeWindowList
 *
 * Removes no-longer-valid windows from the Window-to-addition map.
 *--------------------------------------------------------------------------*/

void WipeWindowList ()
{
    WindowList&             List = GetWindowList();
    WindowList::iterator    it   = List.begin();

    while (it != List.end())
    {
        // if the window isn't valid, erase it
        if (!::IsWindow (*it))
        {
            WindowList::iterator itErase = it++;
            List.erase(itErase);
        }

        // this one's OK, check the next one
        else
            ++it;
    }
}



/*--------------------------------------------------------------------------*
 * AppendToSystemMenu
 *
 * Returns number of menu items appended.
 *--------------------------------------------------------------------------*/

int AppendToSystemMenu (CWnd* pwnd, int nSubmenuIndex)
{
    DECLARE_SC(sc, TEXT("AppendToSystemMenu"));

    CMenu   menuSysAdditions;
    sc = menuSysAdditions.LoadMenu (IDR_SYSMENU_ADDITIONS) ? S_OK : E_FAIL;
    if (sc)
        return 0;

    CMenu*  pSubMenu = menuSysAdditions.GetSubMenu (nSubmenuIndex);
    sc = ScCheckPointers(pSubMenu, E_UNEXPECTED);
    if (sc)
        return 0;

    return (AppendToSystemMenu (pwnd, pSubMenu));
}



/*--------------------------------------------------------------------------*
 * AppendToSystemMenu
 *
 * Returns number of menu items appended.
 *
 *--------------------------------------------------------------------------*/

int AppendToSystemMenu (CWnd* pwnd, CMenu* pMenuToAppend, CMenu* pSysMenu)
{
    DECLARE_SC(sc, TEXT("AppendToSystemMenu"));
    sc = ScCheckPointers(pwnd, pMenuToAppend);
    if (sc)
        return 0;

    if ( (!::IsWindow (pwnd->m_hWnd)) ||
         (!::IsMenu (pMenuToAppend->m_hMenu)) )
    {
        sc = E_UNEXPECTED;
        return 0;
    }

    // no system menu?  get one
    if (pSysMenu == NULL)
        pSysMenu = pwnd->GetSystemMenu (FALSE);

    // still no system menu?  bail
    if (pSysMenu == NULL)
        return (0);

    // clean out the map
    WipeWindowList ();

    // if this is the first addition to this window, append a separator
    WindowList& List = GetWindowList();
    WindowList::iterator itEnd = List.end();

    if (std::find (List.begin(), itEnd, pwnd->m_hWnd) == itEnd)
    {
        List.push_back (pwnd->m_hWnd);

        // If this is a child window & the next window item has not yet been added
        if ( (pwnd->GetStyle() & WS_CHILD) &&
            (pSysMenu->GetMenuState (SC_NEXTWINDOW, MF_BYCOMMAND) == 0xFFFFFFFF))
        {
            // Windows exhibits odd behavior by always handing us a non-child system menu
            // The text is currently wrong and diaplays "alt-f4" as the shortcut
            // instead of "ctrl-f4". The following code fixes that.
            CString strClose;
            LoadString(strClose, IDS_CLOSE);
            sc = pSysMenu->ModifyMenu( SC_CLOSE, MF_STRING | MF_BYCOMMAND, SC_CLOSE, strClose ) ? S_OK : E_FAIL;
            sc.TraceAndClear();

            // Add a separator
            sc = pSysMenu->AppendMenu (MF_SEPARATOR) ? S_OK : E_FAIL;
            sc.TraceAndClear();

            // Add the "Next" item
            CString strNext;
            LoadString(strNext, IDS_NEXTWINDOW);
            sc = pSysMenu->AppendMenu( MF_STRING, SC_NEXTWINDOW, strNext ) ? S_OK : E_FAIL;
            sc.TraceAndClear();
        }

        sc = pSysMenu->AppendMenu (MF_SEPARATOR) ? S_OK : E_FAIL;
        sc.TraceAndClear();
    }

    int cAppendedItems = 0;

    int     cItemsToAppend = pMenuToAppend->GetMenuItemCount ();
    TCHAR   szMenuText[64];

    MENUITEMINFO    mii;
    mii.cbSize     = sizeof (mii);
    mii.fMask      = MIIM_ID | MIIM_TYPE | MIIM_SUBMENU;
    mii.dwTypeData = szMenuText;

    for (int i = 0; i < cItemsToAppend; i++)
    {
        ASSERT (mii.dwTypeData == szMenuText);
        mii.cch = countof (szMenuText);
        if (! ::GetMenuItemInfo (pMenuToAppend->m_hMenu, i, TRUE, &mii))
            sc.FromLastError().TraceAndClear();

        // this code can't handle cascaded additions to the system menu
        ASSERT (mii.hSubMenu == NULL);

        // if the menu item is a separator or isn't already there, append it
        if ((mii.fType & MFT_SEPARATOR) ||
            (pSysMenu->GetMenuState (mii.wID, MF_BYCOMMAND) == 0xFFFFFFFF))
        {
            pSysMenu->AppendMenu (mii.fType, mii.wID, szMenuText);
            cAppendedItems++;
        }
    }

    // return the number of items appended
    return (cAppendedItems);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\tbtrack.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tbtrack.h
 *
 *  Contents:  Interface file for CToolbarTracker
 *
 *  History:   15-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_TBTRACK_H__E1BC376B_EAB5_11D1_8080_0000F875A9CE__INCLUDED_)
#define AFX_TBTRACK_H__E1BC376B_EAB5_11D1_8080_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "subclass.h"       // for CSubclasser


class CMMCToolBarCtrlEx;
class CRebarWnd;
class CToolbarTracker;


/////////////////////////////////////////////////////////////////////////////
// CToolbarTrackerAuxWnd window

class CToolbarTrackerAuxWnd : public CWnd
{
    friend class CToolbarTracker;
    friend class std::auto_ptr<CToolbarTrackerAuxWnd>;
    typedef std::vector<CMMCToolBarCtrlEx*>     ToolbarVector;

private:
    // only created and destroyed by CToolbarTracker
    CToolbarTrackerAuxWnd(CToolbarTracker* pTracker);
    virtual ~CToolbarTrackerAuxWnd();

    bool BeginTracking();
    void EndTracking();

public:
    enum
    {
        ID_CMD_NEXT_TOOLBAR = 0x5300,   // could be anything
        ID_CMD_PREV_TOOLBAR,
        ID_CMD_NOP,
    };

public:
    void TrackToolbar (CMMCToolBarCtrlEx* pwndNewToolbar);

    CMMCToolBarCtrlEx* GetTrackedToolbar() const
        { return (m_pTrackedToolbar); }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CToolbarTrackerAuxWnd)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Generated message map functions
protected:
    //{{AFX_MSG(CToolbarTrackerAuxWnd)
    //}}AFX_MSG

protected:
    afx_msg void OnNextToolbar ();
    afx_msg void OnPrevToolbar ();
    afx_msg void OnNop ();

    DECLARE_MESSAGE_MAP()

private:
    const CAccel& GetTrackAccel ();
    CMMCToolBarCtrlEx*  GetToolbar (CMMCToolBarCtrlEx* pCurrentToolbar, bool fNext);
    void EnumerateToolbars (CRebarWnd* pRebar);

    CToolbarTracker* const  m_pTracker;
    CMMCToolBarCtrlEx*      m_pTrackedToolbar;
    ToolbarVector           m_vToolbars;
    bool                    m_fMessagesHooked;
};


/////////////////////////////////////////////////////////////////////////////
// CToolbarTracker window

class CToolbarTracker : public CObject
{
public:
    CToolbarTracker(CWnd* pMainFrame);
    virtual ~CToolbarTracker();

    bool BeginTracking();
    void EndTracking();

    bool IsTracking() const
        { return (m_pAuxWnd != NULL); }

    CToolbarTrackerAuxWnd* GetAuxWnd() const
        { return (m_pAuxWnd); }


private:
    /*
     * CFrameSubclasser
     */
    class CFrameSubclasser : public CSubclasser
    {
        HWND                m_hwnd;
        CToolbarTracker*    m_pTracker;

    public:
        CFrameSubclasser(CToolbarTracker*, CWnd*);
        ~CFrameSubclasser();
        virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                                  LPARAM& lParam, bool& fPassMessageOn);
    };


private:
    CToolbarTrackerAuxWnd*  m_pAuxWnd;
    CFrameSubclasser        m_Subclasser;
    bool                    m_fTerminating;
};


CToolbarTrackerAuxWnd* GetMainAuxWnd();


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TBTRACK_H__E1BC376B_EAB5_11D1_8080_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\toolbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      toolbar.cpp
//
//  Contents:  ToolBars implementation
//
//  History:   09-30-99 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "ChildFrm.h"
#include "mainfrm.h"
#include "controls.h"
#include "toolbar.h"
#include "bitmap.h"
#include "amcview.h"
#include "util.h"

int CAMCViewToolbars::s_idCommand = MMC_TOOLBUTTON_ID_FIRST;

CAMCViewToolbars::~CAMCViewToolbars()
{
    // Ask the toolbars (on nodemgr side) that reference this object to
    // remove their references.
    TBarToBitmapIndex::iterator itToolbars = m_mapTBarToBitmapIndex.begin();
    for (;itToolbars != m_mapTBarToBitmapIndex.end(); ++itToolbars)
    {
        CToolbarNotify* pNotifyCallbk = itToolbars->first;
        SC sc = ScCheckPointers(pNotifyCallbk, E_UNEXPECTED);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        sc = pNotifyCallbk->ScAMCViewToolbarsBeingDestroyed();
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInit
//
//  Synopsis:    Initialize the object by createing imagelist.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInit ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInit"));

    if (m_ImageList.m_hImageList)
        return (sc = E_UNEXPECTED);

    // Create an imagelist.
    BOOL b = m_ImageList.Create(BUTTON_BITMAP_SIZE, BUTTON_BITMAP_SIZE,
                                ILC_COLORDDB|ILC_MASK,
                                20 /*Initial imagelist size*/, 10 /* grow */);


    if (!b)
        return (sc = E_FAIL);

    m_ImageList.SetBkColor(CLR_NONE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScCreateToolBar
//
//  Synopsis:    Create a Toolbar (Just return CMMCToolbarIntf).
//
//  Arguments:
//               [ppToolbarIntf] - corresponds to IToolbar imp.
//                                 call this interface to manipulate toolbar UI.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScCreateToolBar (CMMCToolbarIntf** ppToolbarIntf)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScCreateToolBar"));
    sc = ScCheckPointers(ppToolbarIntf);
    if (sc)
        return sc;

    *ppToolbarIntf = this;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDisableToolbars
//
//  Synopsis:    Disable all the toolbar buttons (reqd during LV multiselect).
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDisableToolbars ()
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDisableToolbars"));

    if (! m_fViewActive)
        return (sc = E_UNEXPECTED);

    // Now iterate thro all toolbuttons & disable them.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        // Set the UI button state.
        sc = ScSetButtonStateInToolbar(pToolButton, TBSTATE_ENABLED, FALSE);
        if (sc)
            return sc;

        // Save the new state.
        BYTE byOldState = pToolButton->GetState();
        pToolButton->SetState(byOldState & ~TBSTATE_ENABLED);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScAddBitmap
//
//  Synopsis:    Add the given bitmap into the view toolbars imagelist.
//               Also store the start index & number of images in an object
//               mapped by the CToolbarNotify (which identifies snapin toolbar
//               or std bar).
//
//  Arguments:   [pNotifyCallbk] - The toolbar identifier (Button click callback interface).
//               [nImages]       - Number of bitmaps.
//               [hbmp]          - Handle to the bitmap.
//               [crMask]        - Color used to generate a mask to overlay
//                                 the images on the toolbar button.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScAddBitmap (CToolbarNotify* pNotifyCallbk, INT nImages,
                               HBITMAP hbmp, COLORREF crMask)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScAddBitmap"));
    sc = ScCheckPointers(pNotifyCallbk, hbmp);
    if (sc)
        return sc;

	/*
	 * make a copy of the input bitmap because ImageList_AddMasked will
	 * modify the input bitmap
	 */
    CBitmap bmpCopy;
    bmpCopy.Attach (CopyBitmap (hbmp));

	if (bmpCopy.GetSafeHandle() == NULL)
		return (sc.FromLastError());

    sc = ScCheckPointers(m_ImageList.m_hImageList, E_UNEXPECTED);
    if (sc)
        return sc;

    MMCToolbarImages imagesNew;

    int cImagesOld = m_ImageList.GetImageCount();

    // First add the bitmap into the imagelist.
    imagesNew.iStart  = m_ImageList.Add (bmpCopy, crMask);

    imagesNew.cCount = m_ImageList.GetImageCount() - cImagesOld;

    if (imagesNew.iStart == -1)
        return (sc = E_FAIL);

    /*
     * Assume a snapin adds 3 bitmaps initialy & then 4 for a toolbar.
     * Then while adding buttons it will specify bitmap index as 5.
     *
     * So this toolbar will have two MMCToolbarImages objects in the multimap.
     *
     * The first  MMCToolbarImages has cCount = 3, iStartWRTSnapin = 0, thus
     * images from 0 (iStartWRTSnapin) to 3 (iStartWRTSnapin + cCount) with respect
     * to snapin.
     * The second MMCToolbarImages has cCount = 4, iStartWRTSnapin = 3, thus
     * images from 3(iStartWRTSnapin) to 7(iStartWRTSnapin + cCount) wrt snapin.
     *
     * The iStartWRTSnapin member is nothing but the largest of iStartWRTSnapin + cCount
     * in all of this toolbars MMCToolbarImages.
     *
     */

    std::pair<TBarToBitmapIndex::iterator, TBarToBitmapIndex::iterator>
                  range =  m_mapTBarToBitmapIndex.equal_range(pNotifyCallbk);

    imagesNew.iStartWRTSnapin = 0;
    while (range.first != range.second)
    {
        // Go thro each item and get the correct start index.
        MMCToolbarImages imagesOld = (range.first)->second;
        int nLastImageIndex = imagesOld.iStartWRTSnapin + imagesOld.cCount;
        if ( imagesNew.iStartWRTSnapin < nLastImageIndex )
            imagesNew.iStartWRTSnapin = nLastImageIndex;

        (range.first)++;
    }

    // Now store the start index, number of bitmaps identified
    // by CToolbarNotify in a multi-map.
    m_mapTBarToBitmapIndex.insert(
                              TBarToBitmapIndex::value_type(pNotifyCallbk, imagesNew) );

    // To be compatible with SysInfo snapin dont return error.
    if ((cImagesOld + nImages) > m_ImageList.GetImageCount())
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("IToolbar::AddBitmap, Number of bitmaps is less than number mentioned"), sc);
        sc.Clear();
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     ScValidateButton
//
//  Synopsis:   Validate the MMCBUTTON data.
//
//  Arguments:
//            [nButtons]  - Number of elements in MMCBUTTON array.
//            [lpButtons] - MMCBUTTON array.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScValidateButton(int nButtons, LPMMCBUTTON lpButtons)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCViewToolbars::ScValidateButton"));

    if ( (lpButtons == NULL) || (nButtons < 1) )
        return (sc = E_INVALIDARG);

    for (int i=0; i < nButtons; i++)
    {
        if (lpButtons[i].nBitmap > GetImageCount())
        {
            sc = E_INVALIDARG;
            return sc;
        }

        // There should be button text if it is not a separator.
        if (((lpButtons[i].fsType & TBSTYLE_SEP) == 0) &&
            ((lpButtons[i].lpButtonText == NULL) ||
             (lpButtons[i].lpTooltipText == NULL)))
        {
            sc = E_INVALIDARG;
            return sc;
        }

        // There should be no bitmap set if it is a separator.
        if ( ((lpButtons[i].fsType & TBSTYLE_SEP) != 0) &&
             (lpButtons[i].nBitmap > 0) )
        {
            sc = E_INVALIDARG;
            return sc;
        }

		// Reset any TBSTATE_WRAP state.
		lpButtons[i].fsState &= (~TBSTATE_WRAP);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInsertButtonToToolbar
//
//  Synopsis:    Inserts the toolbar button into the main toolbar UI.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInsertButtonToToolbar (CMMCToolbarButton* pToolButton)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInsertButtonToToolbar"));
    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    // Button can be added only if view is active, button is not already added
    // to the toolbar & toolbar is attached.
    if (! m_fViewActive)
        return (sc);

    if (pToolButton->IsButtonIsAddedToUI())
        return sc;

    if (! IsToolbarAttached(pToolButton->GetToolbarNotify()))
        return sc;

    // Now get the main toolbar & add the button.
    CMMCToolBar* pToolBarUI = GetMainToolbar();
    sc = ScCheckPointers(pToolBarUI, E_UNEXPECTED);
    if (sc)
        return sc;

    TBBUTTON tbButton;
    ZeroMemory(&tbButton, sizeof(tbButton));
    tbButton.idCommand  = pToolButton->GetUniqueCommandID();
    tbButton.fsStyle    = pToolButton->GetStyle();
    tbButton.iBitmap    = pToolButton->GetBitmap();
    tbButton.fsState    = pToolButton->GetState();

    // The toolbar is hidden by customize view dialog.
    // If so insert the button as hidden. (Do not record
    // the hidden status into the CMMCToolbarButton).
    if (IsToolbarHidden(pToolButton->GetToolbarNotify()))
        tbButton.fsState |= TBSTATE_HIDDEN;

    // Insert the button.
    BOOL bRet = pToolBarUI->InsertButton(-1, &tbButton);
    sc = (bRet ? S_OK : E_FAIL);

    if (sc)
        return sc;

    pToolButton->SetButtonIsAddedToUI(true);

    // Bug 225711:  If the button is supposed to be hidden, hide it now.
    if (tbButton.fsState & TBSTATE_HIDDEN)
        sc = pToolBarUI->ScHideButton(tbButton.idCommand, true);

    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInsertButtonToDataStr
//
//  Synopsis:
//
//  Arguments:   [pNotifyCallbk] - The callbk interface for IToolbar imp.
//               [nIndex]        - Index of the button.
//               [lpButton]      - MMCBUTTON ptr.
//               [pToolButton]   - Return value, the button added (or found
//                                                in case of dup buttons).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInsertButtonToDataStr (CToolbarNotify* pNotifyCallbk,
                                              int nIndex,
                                              LPMMCBUTTON lpButton,
                                              CMMCToolbarButton** ppToolButton)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInsertButtonToDataStr"));

    sc = ScCheckPointers(pNotifyCallbk, ppToolButton);
    if (sc)
        return sc;

    sc = ScValidateButton(1, lpButton);
    if (sc)
        return sc;

    // Make sure snapin does not add duplicate buttons
    // For compatibility (services snapin) this is not a bug.
    *ppToolButton = GetToolbarButton(pNotifyCallbk, lpButton->idCommand);
    if (*ppToolButton)
    {
        // if snapin added the button we already have,
        // we still need to ensure its state (BUG: 439229)
        if ((*ppToolButton)->GetState() != lpButton->fsState)
        {
            // update the object
            (*ppToolButton)->SetState(lpButton->fsState);
            // do we need to update the UI as well?
            if (m_fViewActive && (*ppToolButton)->IsButtonIsAddedToUI())
            {
                INT  iCommandID = (*ppToolButton)->GetUniqueCommandID();
                if (!m_pMainToolbar->SetState(iCommandID, lpButton->fsState))
                    return (sc = E_FAIL);
            }
        }

        return sc;
    }


    // If this button belongs to different toolbar from last button
    // then insert a separator in between.
    if (! m_vToolbarButtons.empty())
    {
        CMMCToolbarButton& lastBtn = m_vToolbarButtons.back();
        if (lastBtn.GetToolbarNotify() != pNotifyCallbk)
        {
            CMMCToolbarButton separatorBtn(-1, GetUniqueCommandID(), -1, -1, 0, TBSTYLE_SEP, pNotifyCallbk);
            m_vToolbarButtons.push_back(separatorBtn);
        }
    }

    /*
     * Assume a snapin adds 3 bitmaps initialy & then 4 for a toolbar.
     * Then while adding buttons it will specify bitmap index as 5.
     *
     * So this toolbar will have two MMCToolbarImages objects in the multimap.
     *
     * The first  MMCToolbarImages has cCount = 3, iStartWRTSnapin = 0, thus
     * images from 0 (iStartWRTSnapin) to 3 (iStartWRTSnapin + cCount) with respect
     * to snapin.
     * The second MMCToolbarImages has cCount = 4, iStartWRTSnapin = 3, thus
     * images from 3(iStartWRTSnapin) to 7(iStartWRTSnapin + cCount) wrt snapin.
     *
     * The iStartWRTSnapin member is nothing but the largest of iStartWRTSnapin + cCount
     * in all of this toolbars MMCToolbarImages.
     *
     * Below we run thro different MMCToolbarImages for this toolbar and see in which
     * one the given index falls under and calculate the real index by adding that
     * object's iStart.
     *
     */

    // Now we need to compute the bitmap index. Find this toolbar in the multimap.
    int iBitmap = -1;

    std::pair<TBarToBitmapIndex::iterator, TBarToBitmapIndex::iterator>
                  range =  m_mapTBarToBitmapIndex.equal_range(pNotifyCallbk);

    while (range.first != range.second)
    {
        MMCToolbarImages images = (range.first)->second;

        // We need to find the bitmap whose start index is greater than or
        // equal to given index and upper index is less than given index.
        int nLastImageIndex = images.iStartWRTSnapin + images.cCount -1;
        if ( (lpButton->nBitmap >= images.iStartWRTSnapin ) &&
             ( lpButton->nBitmap <= nLastImageIndex ) )
        {
            iBitmap = images.iStart + lpButton->nBitmap;
            break;
        }

        (range.first)++;
    }

    // No bitmaps for separators.
    if ( (-1 == iBitmap) && (!(TBSTYLE_SEP & lpButton->fsType)) )
        return (sc = E_UNEXPECTED);


    // Create CMMCToolbarButton for each button, init it with unique command-id, toolbar id.
    // There is only one imagelist per view that contains bitmaps from different toolbars.
    // We use a multimap to identify a particular toolbar's bitmap start indices.
    CMMCToolbarButton newButton(lpButton->idCommand,
                             GetUniqueCommandID(),
                             nIndex,
                             (lpButton->fsType & TBSTYLE_SEP) ? 0 : iBitmap,
                             lpButton->fsState,
                             lpButton->fsType,
                             pNotifyCallbk);

    USES_CONVERSION;
    // First save the button data in CMMCToolButton.
    if (lpButton->lpTooltipText)
        newButton.SetTooltip(OLE2CT(lpButton->lpTooltipText));

    if (lpButton->lpButtonText)
        newButton.SetButtonText(OLE2CT(lpButton->lpButtonText));

    // Add this button to the end of our array.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.insert(m_vToolbarButtons.end(), newButton);
    if (m_vToolbarButtons.end() == itBtn)
        return (sc = E_FAIL);

    *ppToolButton = itBtn;
    sc = ScCheckPointers(*ppToolButton, E_OUTOFMEMORY);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInsertButton
//
//  Synopsis:    Insert a button in our array & if the our view is active
//               add the button to the UI.
//
//  Arguments:   [pNotifyCallbk] - The callbk interface for IToolbar imp.
//               [nIndex]        - Index of the button.
//               [lpButton]      - MMCBUTTON ptr.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInsertButton (CToolbarNotify* pNotifyCallbk, int nIndex, LPMMCBUTTON lpButton)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInsertButton"));

    CMMCToolbarButton *pToolbarButton = NULL;

    sc = ScInsertButtonToDataStr(pNotifyCallbk, nIndex, lpButton, &pToolbarButton);
    if (sc)
        return sc;

    sc = ScInsertButtonToToolbar(pToolbarButton);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScAddButtons
//
//  Synopsis:    Save the buttons in our array and add them to UI if view is active.
//
//  Arguments:   [pNotifyCallbk] - Button click callback interface.
//               [nButtons]      - Number of buttons in lpButtons array.
//               [lpButtons]     - MMCBUTTONs (array) bo be added.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScAddButtons (CToolbarNotify* pNotifyCallbk, int nButtons, LPMMCBUTTON lpButtons)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScAddButtons"));

    for (int i = 0; i < nButtons; i++)
    {
        sc = ScInsertButton(pNotifyCallbk, -1, &(lpButtons[i]));
        if (sc)
            return sc;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDeleteButtonFromToolbar
//
//  Synopsis:    Deletes a button from the toolbar UI if it exists.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDeleteButtonFromToolbar (CMMCToolbarButton* pToolButton)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDeleteButtonFromToolbar"));

    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    if (! m_fViewActive)
        return (sc);

    if (! pToolButton->IsButtonIsAddedToUI())
        return sc;

    CMMCToolBar* pToolBarUI = GetMainToolbar();
    sc = ScCheckPointers(pToolBarUI, E_UNEXPECTED);
    if (sc)
        return sc;

    int nIndexOfBtn = pToolBarUI->CommandToIndex(pToolButton->GetUniqueCommandID());

	// Update the separators before deleting the button.
    pToolBarUI->UpdateSeparators(pToolButton->GetUniqueCommandID(), true);

    // Delete the button.
    BOOL bRet = pToolBarUI->DeleteButton(nIndexOfBtn);
    sc = (bRet ? S_OK : E_FAIL);

    if (sc)
        return sc;

    pToolButton->SetButtonIsAddedToUI(false);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDeleteButton
//
//  Synopsis:    Delete button at given index (index is wrt snapin).
//
//  Arguments:   [pNotifyCallbk]
//               [nIndex[
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDeleteButton (CToolbarNotify* pNotifyCallbk, int nIndex)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDeleteButton"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    // Now iterate thro all toolbuttons & find the one with
    // given toolbar-id & index and if it is added to the
    // toolbar UI then delete it.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if ( (pToolButton->GetToolbarNotify() == pNotifyCallbk) &&
             (pToolButton->GetIndexFromSnapin() == nIndex) )
        {
            sc = ScDeleteButtonFromToolbar(pToolButton);
            if (sc)
                return sc;

			return sc;
        }
    }

    // To be compatible with services snapin on Windows2000 return S_OK.
	sc = S_OK;
    TraceSnapinError(_T("IToolbar::DeleteButton, Snapin called IToolbar::DeleteButton, but the toolbar button is not found. Most likely the button index is wrong (snapin should have called InsertButton with that index)"), sc);
    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScAttach
//
//  Synopsis:    Make the toolbars visible (Add the toolbar buttons
//               to the toolbar UI). First get the CMMCToolbarData
//               and set attached flag. Then add the buttons to toolbar.
//
//  Arguments:   [pNotifyCallbk] - The toolbar identifier (corresponds
//                                 to the IToolbar imp).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScAttach (CToolbarNotify* pNotifyCallbk)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScAttach"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    SetToolbarAttached(pNotifyCallbk, true);

    // Go thro all ToolButtons of this toolbar and add those
    // buttons that are not yet added to the toolbar UI.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pToolButton->GetToolbarNotify() == pNotifyCallbk)
        {
            // Add this button to toolbar UI.
            sc = ScInsertButtonToToolbar(pToolButton);
            if (sc)
                return sc;
        }
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDetach
//
//  Synopsis:    Remove the toolbar buttons from the toolbar UI for
//               given toolbar.
//
//  Arguments:   [pNotifyCallbk] - The given (IToolbar) toolbar.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDetach (CToolbarNotify* pNotifyCallbk)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDetach"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    SetToolbarAttached(pNotifyCallbk, false);

    // Go thro all ToolButtons of this toolbar and delete those
    // buttons that are added to the toolbar UI.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pToolButton->GetToolbarNotify() == pNotifyCallbk)
        {
            // Delete this button from the toolbar UI.
            sc = ScDeleteButtonFromToolbar(pToolButton);
            if (sc)
                return sc;
        }
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScGetButtonStateInToolbar
//
//  Synopsis:    Get the state of given button from toolbar UI.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//               [byState]      - The TBSTATE needed.
//               [pbState]     - The button state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScGetButtonStateInToolbar(CMMCToolbarButton *pToolButton,
                                               BYTE  byState,
                                               BOOL* pbState)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScGetButtonStateInToolbar"));

    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    ASSERT(NULL != m_pMainToolbar);
    int idCommand = pToolButton->GetUniqueCommandID();

    // Make sure button with this command-id exists.
    if (m_pMainToolbar->GetState(idCommand) == -1)
        return (sc = E_INVALIDARG);

    switch (byState)
    {
    case TBSTATE_ENABLED:
        *pbState = m_pMainToolbar->IsButtonEnabled(idCommand);
        break;
    case TBSTATE_CHECKED:
        *pbState = m_pMainToolbar->IsButtonChecked(idCommand);
        break;
    case TBSTATE_HIDDEN:
        *pbState = m_pMainToolbar->IsButtonHidden(idCommand);
        break;
    case TBSTATE_INDETERMINATE:
        *pbState = m_pMainToolbar->IsButtonIndeterminate(idCommand);
        break;
    case TBSTATE_PRESSED:
        *pbState = m_pMainToolbar->IsButtonPressed(idCommand);
        break;
    default:
        sc = E_NOTIMPL;
        ASSERT(FALSE); // Invalid option
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScGetButtonState
//
//  Synopsis:    Get the state of the given button.
//
//  Arguments:   [pNotifyCallbk] - The toolbar (IToolbar).
//               [idCommand]     - Snapin given command-id of button.
//               [byState]       - The state needed.
//               [pbState]       - bool ret val.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScGetButtonState (CToolbarNotify* pNotifyCallbk,
                                      int idCommandFromSnapin, BYTE byState,
                                      BOOL* pbState)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScGetButtonState"));

    sc = ScCheckPointers(pNotifyCallbk, pbState);
    if (sc)
        return sc;

    // Get the toolbutton of given toolbar id & command-id.
    CMMCToolbarButton *pToolButton = GetToolbarButton(pNotifyCallbk, idCommandFromSnapin);
    sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
    if (sc)
        return sc;

    // The toolbutton is not available if view is not active or toolbar is hidden by
    // customize view dialog, then return the state from our data-structure.
    if (m_fViewActive && pToolButton->IsButtonIsAddedToUI() && (!IsToolbarHidden(pNotifyCallbk)) )
        sc = ScGetButtonStateInToolbar(pToolButton, byState, pbState);
    else
        // We cant access the toolbar UI. Return the state we saved.
        *pbState = (pToolButton->GetState() & byState);

    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScSetButtonStateInToolbar
//
//  Synopsis:    Set the state of a button in main toolbar UI.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//               [byState]     - The button state to be set.
//               [bState]      - Set or Reset the state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScSetButtonStateInToolbar (CMMCToolbarButton* pToolButton,
                                                BYTE byState,
                                                BOOL bState)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScSetButtonStateInToolbar"));

    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    if(! m_fViewActive)
        return sc;

    if (! pToolButton->IsButtonIsAddedToUI())
        return sc;

    ASSERT(NULL != m_pMainToolbar);

    int idCommand = pToolButton->GetUniqueCommandID();

    BOOL bRet = FALSE;
    switch (byState)
    {
    case TBSTATE_ENABLED:
        bRet = m_pMainToolbar->EnableButton(idCommand, bState);
        break;

    case TBSTATE_CHECKED:
        bRet = m_pMainToolbar->CheckButton(idCommand, bState);
        break;

    case TBSTATE_HIDDEN:
        {
            int nButtonIndex = m_pMainToolbar->CommandToIndex(idCommand);

            // ignore unknown buttons
            if (nButtonIndex == -1)
                break;

            // ignore ineffectual changes (negate both sides to insure pure bool)
            if (!m_pMainToolbar->IsButtonHidden(idCommand) == !bState)
            {
                bRet = TRUE;
                break;
            }

            sc = m_pMainToolbar->ScHideButton(idCommand, bState);
            return sc;
            break;
        }

    case TBSTATE_INDETERMINATE:
        bRet = m_pMainToolbar->Indeterminate(idCommand, bState);
        break;

    case TBSTATE_PRESSED:
        bRet = m_pMainToolbar->PressButton(idCommand, bState);
        break;

    default:
        sc = E_NOTIMPL;
        ASSERT(FALSE); // Invalid option
        return sc;
    }

    sc = (bRet ? S_OK : E_FAIL);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScSetButtonState
//
//  Synopsis:    Set the state of a button.
//
//  Arguments:   [pNotifyCallbk] - The toolbar (IToolbar).
//               [byState]      - The button state to be set.
//               [bState]      - Set or Reset the state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScSetButtonState (CToolbarNotify* pNotifyCallbk,
                                       int idCommandFromSnapin,
                                       BYTE byState, BOOL bSetState)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScSetButtonState"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

	// Reset any TBSTATE_WRAP state.
	byState &= (~TBSTATE_WRAP);

    // Get the toolbutton of given toolbar id & command-id.
    CMMCToolbarButton *pToolButton = GetToolbarButton(pNotifyCallbk, idCommandFromSnapin);
    sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
    if (sc)
        return (sc = S_OK); // Not an error.

    BYTE byNewState = (bSetState) ? (pToolButton->GetState() | byState) :
                                    (pToolButton->GetState() & (~byState) );

    pToolButton->SetState(byNewState);

    // The toolbar can be hidden by customize view dialog.

    // If the snapin tries to unhide a button in hidden toolbar just return.
    if ( (byState & TBSTATE_HIDDEN) && (!bSetState) && IsToolbarHidden(pNotifyCallbk) )
        return (sc = S_OK);

    sc = ScSetButtonStateInToolbar(pToolButton, byState, bSetState);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScOnActivateView
//
//  Synopsis:    The view of this object is active, add its toolbuttons.
//
//  Arguments:   [pAMCView]         - The AMCView ptr.
//               [bFirstActiveView] - Is this first active view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScOnActivateView (CAMCView *pAMCView,  // We dont care about this arg.
                                       bool bFirstActiveView)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScOnActivateView"));

    // If this is the first active view then insert the toolbar band.
    CMMCToolBar* pMainToolbar = GetMainToolbar();
    sc = ScCheckPointers(pMainToolbar, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScFireEvent(CAMCViewToolbarsObserver::ScOnActivateAMCViewToolbars, this);
	if (sc)
		sc.TraceAndClear();

    m_fViewActive = true;

    pMainToolbar->SetImageList(GetImageList());

    // Go thro all ToolButtons of this toolbar and add them to the UI.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        // Add this button to toolbar UI.
        sc = ScInsertButtonToToolbar(pToolButton);
        if (sc)
            return sc;
    }

    bool bToolbarBandVisible = pMainToolbar->IsBandVisible();
    bool bThereAreVisibleButtons = IsThereAVisibleButton();

    // If there are visible buttons show the band.
    if (bThereAreVisibleButtons)
        pMainToolbar->Show(true, true);
    else if (bToolbarBandVisible)      // Otherwise hide it if it is currently visible.
        pMainToolbar->Show(false);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScOnDeactivateView
//
//  Synopsis:    The view of this object is de-activated. Disable the
//               imagelists & this object should not manipulate the
//               toolbar UI till OnActivateView is fired.
//
//  Arguments:   [pAMCView]        - The view to be de-activated.
//               [bLastActiveView] - Is this the last view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScOnDeactivateView (CAMCView *pAMCView, bool bLastActiveView)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScOnDeactivateView"));

    CMMCToolBar* pMainToolbar = GetMainToolbar();
    sc = ScCheckPointers(pMainToolbar, E_UNEXPECTED);
    if (sc)
        return sc;

    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = ScDeleteButtonFromToolbar(pToolButton);

        if (sc)
            return sc;
    }

    sc = ScFireEvent(CAMCViewToolbarsObserver::ScOnDeactivateAMCViewToolbars);
	if (sc)
		sc.TraceAndClear();

    // If this is last view then delete the band if it is visible.
    if (bLastActiveView && pMainToolbar->IsBandVisible())
        pMainToolbar->Show(FALSE);

    m_bLastActiveView = bLastActiveView;

    m_fViewActive = false;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScButtonClickedNotify
//
//  Synopsis:    A button of this object is clicked. Get the context
//               and inform the CToolbarNotify object.
//
//  Arguments:   [nID] - command id of the button clicked.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScButtonClickedNotify (UINT nID)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScButtonClickedNotify"));

    CMMCToolbarButton* pButton = GetToolbarButton(nID);
    sc = ScCheckPointers(pButton, m_pAMCViewOwner, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the context, (the currently selected HNODE,
    // lParam (if result item)) etc...
    HNODE hNode;
    bool  bScope;
    LPARAM lParam;

    sc = m_pAMCViewOwner->ScGetFocusedItem (hNode, lParam, bScope);
    if (sc)
        return sc;

    CToolbarNotify* pNotifyCallbk = pButton->GetToolbarNotify();
    sc = ScCheckPointers(pNotifyCallbk, E_UNEXPECTED);
    if (sc)
        return sc;

	// Deactivate if theming (fusion or V6 common-control) context before calling snapins.
	ULONG_PTR ulpCookie;
	if (! MmcDownlevelActivateActCtx(NULL, &ulpCookie)) 
		return E_FAIL;

	try
	{
		sc  = pNotifyCallbk->ScNotifyToolBarClick(hNode, bScope, lParam, pButton->GetCommandIDFromSnapin());
	}
	catch(...)
	{
		sc = E_FAIL;
	}

	MmcDownlevelDeactivateActCtx(0, ulpCookie);
	if (sc)
		return sc;

    // fire event informing about execution
    sc = ScFireEvent(CAMCViewToolbarsObserver::ScOnToolbarButtonClicked);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScGetToolTip
//
//  Synopsis:    Tooltip is requested for a button of this object.
//
//  Arguments:   [nCommandID] - Command id of the button.
//               [strTipText] - CString to hold the tooltip.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScGetToolTip (int nCommandID, CString& strTipText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScGetToolTip"));

    // Get the toolbutton.
    CMMCToolbarButton* pButton = GetToolbarButton(nCommandID);
    sc = ScCheckPointers(pButton, E_UNEXPECTED);
    if (sc)
        return sc;

    strTipText = pButton->GetTooltip();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDelete
//
//  Synopsis:    A toolbar needs to be deleted. First remove the buttons
//               from UI & remove buttons from our data structure,
//               remove the toolbar reference from our data structures.
//
//  Arguments:   [pNotifyCallbk] - The toolbar (IToolbar).
//
//  Returns:     SC
//
//  Note:        This method should remove its reference of CToolbarNotify
//               object when it returns (even if it encounters intermediate errors).
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDelete (CToolbarNotify* pNotifyCallbk)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDelete"));
    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    ToolbarButtons::iterator itBtn;
    // Detach the toolbar first.
    sc = ScDetach(pNotifyCallbk);
    if (sc)
        goto Cleanup;

    // Delete the buttons from m_vToolbarButtons.
    itBtn = m_vToolbarButtons.begin();
    while (itBtn != m_vToolbarButtons.end())
    {
        CMMCToolbarButton* pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            goto Cleanup;

        if (pToolButton->GetToolbarNotify() == pNotifyCallbk)
        {
            sc = ScDeleteButtonFromToolbar(pToolButton);
            if (sc)
                goto Cleanup;

            itBtn = m_vToolbarButtons.erase(itBtn);
        }
        else
            ++itBtn;
    }

Cleanup:
    // The toolbar client has asked us to remove our reference
    // to it. So even if there is any error encountered we
    // should remove the reference.
    m_mapTBarToBitmapIndex.erase(pNotifyCallbk);
    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScShow
//
//  Synopsis:    Show/Hide buttons of a toolbar.
//
//  Arguments:   [pNotifyCallbk] - Identifies the toolbar
//               [bShow]         - Show/Hide.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScShow (CToolbarNotify* pNotifyCallbk, BOOL bShow)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScShow"));

    if (m_bLastActiveView)
        return sc;

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pMainToolbar, E_UNEXPECTED);
    if (sc)
        return sc;

    // Go thro all ToolButtons of this toolbar and hide or show them.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if ( (pToolButton->GetToolbarNotify() == pNotifyCallbk) &&
             (pToolButton->IsButtonIsAddedToUI()) )
        {
            // Do not show the buttons which should be hidden (TBSTATE_HIDDEN).
            BOOL bHide = (bShow == FALSE) || (pToolButton->GetState() & TBSTATE_HIDDEN);

            sc = m_pMainToolbar->ScHideButton(pToolButton->GetUniqueCommandID(), bHide);
            if (sc)
                return sc;
        }
    }

    // The toolbar is hidden/shown by customize view dialog.
    SetToolbarStatusHidden(pNotifyCallbk, (FALSE == bShow) );

    if (bShow)
        m_pMainToolbar->Show(TRUE, true /* insert band in new line*/ );
    else if ( (false == IsThereAVisibleButton()) && // If there is no visible
               (m_pMainToolbar->IsBandVisible()) )   // buttons hide the band.
        m_pMainToolbar->Show(FALSE);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::IsThereAVisibleButton
//
//  Synopsis:    Returns true if there is any visible button. If not
//               the band should be hidden (or removed).
//
//  Returns:     bool
//
//--------------------------------------------------------------------
bool CAMCViewToolbars::IsThereAVisibleButton()
{
    if (! m_pMainToolbar)
        return false;

    int cButtons = m_pMainToolbar->GetButtonCount();

    for (int i = 0; i < cButtons; ++i)
    {
        TBBUTTON tbButton;

        if (m_pMainToolbar->GetButton(i, &tbButton))
        {
            // If the button is not hidden return true to
            // IsThereAVisibleButton question.
            if ( !(tbButton.fsState & TBSTATE_HIDDEN) )
                return true;
        }
    }

    return false;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::GetToolbarButton
//
//  Synopsis:    Given the command ID return the button object.
//
//  Arguments:   [nCommandID] -
//
//  Returns:     CMMCToolbarButton obj.
//
//--------------------------------------------------------------------
CMMCToolbarButton* CAMCViewToolbars::GetToolbarButton(int nUniqueCommandID)
{
    ToolbarButtons::iterator itBtns = m_vToolbarButtons.begin();

    for (; itBtns != m_vToolbarButtons.end(); ++itBtns)
    {
        if ((itBtns)->GetUniqueCommandID() == nUniqueCommandID)
            return (itBtns);
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::GetToolbarButton
//
//  Synopsis:    Search for the button with given toolbar id & command id.
//
//  Arguments:   [idToolbar] -
//               [idCommand] - Command id given by snapin (therfore may not be unique).
//
//  Returns:     the toolbutton object.
//
//--------------------------------------------------------------------
CMMCToolbarButton* CAMCViewToolbars::GetToolbarButton(CToolbarNotify* pNotifyCallbk, int idCommandIDFromSnapin)
{
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton* pToolButton = (itBtn);
        if ( (pToolButton->GetToolbarNotify() == pNotifyCallbk) &&
             (pToolButton->GetCommandIDFromSnapin() == idCommandIDFromSnapin) )
        {
            return (pToolButton);
        }
    }

    return NULL;
}



const int CMMCToolBar::s_nUpdateToolbarSizeMsg =
        RegisterWindowMessage (_T("CMMCToolBar::WM_UpdateToolbarSize"));

// Command Ids for buttons must start from 1, since 0 is special case by MFC (BUG:451883)
// For tooltips the child ids of the control is used. This range is 0x0 to 0xFFFF.
BEGIN_MESSAGE_MAP(CMMCToolBar, CMMCToolBarCtrlEx)
    ON_COMMAND_RANGE(MMC_TOOLBUTTON_ID_FIRST, MMC_TOOLBUTTON_ID_LAST, OnButtonClicked)
    ON_UPDATE_COMMAND_UI_RANGE(MMC_TOOLBUTTON_ID_FIRST, MMC_TOOLBUTTON_ID_LAST, OnUpdateAllCmdUI)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xFFFF, OnToolTipText)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xFFFF, OnToolTipText)
    ON_REGISTERED_MESSAGE(s_nUpdateToolbarSizeMsg, OnUpdateToolbarSize)
END_MESSAGE_MAP()


//+-------------------------------------------------------------------
//
//  Member:      ScInit
//
//  Synopsis:    Initialize this toolbar by creating the UI object.
//
//  Arguments:   [pRebar]       - The parent rebar where this toolbar should be added.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScInit(CRebarDockWindow* pRebar)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CMMCToolBar::ScInit"));
    sc = ScCheckPointers(pRebar);
    if (sc)
        return sc;

    // Enable tool-tips for the tool-buttons.
    BOOL bRet = Create (NULL, WS_VISIBLE | TBSTYLE_TOOLTIPS, g_rectEmpty, pRebar, ID_TOOLBAR);
    sc = (bRet ? S_OK : E_FAIL);
    if (sc)
        return sc;

    // Set ComCtrl version as 5 to use multiple imagelists.
    LRESULT lOldVer = SendMessage(CCM_SETVERSION, (WPARAM) 5, 0);
    if (lOldVer == -1)
        return (sc = E_FAIL);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      OnButtonClicked
//
//  Synopsis:    A button of this toolbar is clicked, tell the
//               toolbars manager to notify the client
//               (std toolbar or snapin) about this.
//
//  Arguments:   [nID] - The ID of the button clicked.
//
//  Returns:     None.
//
//--------------------------------------------------------------------
void CMMCToolBar::OnButtonClicked(UINT nID)
{
    DECLARE_SC(sc, _T("CMMCToolBar::OnButtonClicked"));

    sc = ScCheckPointers(m_pActiveAMCViewToolbars, E_UNEXPECTED);
    if (sc)
        return;

    // Inform the active view toolbar object about button click.
    sc = m_pActiveAMCViewToolbars->ScButtonClickedNotify(nID);
    if (sc)
        return;

    return;
}


//+-------------------------------------------------------------------
//
//  Member:      OnToolTipText
//
//  Synopsis:    Tool-tips are requested for a button. (message handler).
//
//  Arguments:
//               [nCID]    - Not used.
//               [pNMHDR]  - Tool-tips for what?
//               [pResult] - tool-tip text.
//
//  Returns:     BOOL.
//
//--------------------------------------------------------------------
BOOL CMMCToolBar::OnToolTipText(UINT nCID, NMHDR* pNMHDR, LRESULT* pResult)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);
    DECLARE_SC(sc, _T("CMMCToolBar::OnToolTipText"));

    CString strTipText = _T("\n");

    // need to handle both ANSI and UNICODE versions of the message
    TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
    TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;

    UINT nID = pNMHDR->idFrom;

    if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
        pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
    {
        // idFrom is actually the HWND of the tool,
        // this cannot be true since we did not set this.
        ASSERT(FALSE);
    }

    if (nID != 0) // will be zero on a separator // this is the command id, not the button index
    {
        // Ask the active view's CViewToolBarData for tooltip
        // corresponding to toolbar with command-id nID.
        sc = ScCheckPointers(m_pActiveAMCViewToolbars, E_UNEXPECTED);
        if (sc)
            return FALSE;

        sc = m_pActiveAMCViewToolbars->ScGetToolTip(nID, strTipText);

        if (sc)
        {
            // No match.
            #ifdef DBG
                strTipText = _T("Unable to get tooltip\nUnable to get tooltip");
            #else
                strTipText = _T("\n");
            #endif
        }
    }

    /*
     * Common control provides either TOOLTIPTEXTA or TOOLTIPTEXTW. So MMC needs to
     * provide wide char string or ansi string as tooltip. So below we have two kind
     * of string buffers.
     *
     * Also common control does not free the given string, but it copies the tooltip
     * as soon as this method returns. So we make the strings as static so that we
     * can reuse them.
     *
     * Also see ID: Q180646.
     */
    static std::string   strToolTipTextBuf;
    static std::wstring wstrToolTipTextBuf;

    USES_CONVERSION;

    if (pNMHDR->code == TTN_NEEDTEXTA)
    {
        wstrToolTipTextBuf = L"\0";
		ASSERT(pTTTA->hinst == NULL);
        strToolTipTextBuf  = T2CA((LPCTSTR)strTipText);
        pTTTA->lpszText    = const_cast<LPSTR>(strToolTipTextBuf.data());
    }
    else
    {
        strToolTipTextBuf = "\0";
	    ASSERT(pTTTW->hinst == NULL);
        wstrToolTipTextBuf = T2CW((LPCTSTR)strTipText);
        pTTTW->lpszText    = const_cast<LPWSTR>(wstrToolTipTextBuf.data());
    }

    *pResult = 0;

    return TRUE;    // message was handled
}


//+-------------------------------------------------------------------
//
//  Member:      CMMCToolBar::ScOnActivateAMCViewToolbars
//
//  Synopsis:    A cAMCViewToolbars object become the active one (since
//               that objects parent view become active). Cache the
//               object to inform it of toolbutton events.
//
//  Arguments:   [pToolbarsOfView] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScOnActivateAMCViewToolbars (CAMCViewToolbars *pAMCViewToolbars)
{
    DECLARE_SC(sc, _T("CMMCToolBar::ScOnActivateAMCViewToolbars"));
    sc = ScCheckPointers(pAMCViewToolbars);
    if (sc)
        return sc;

    m_pActiveAMCViewToolbars = pAMCViewToolbars;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnDeactivateAMCViewToolbars
//
//  Synopsis:    The CAMCViewToolbars object became inactive (as its parent
//               became inactive). Reset the cached active toolbar object.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScOnDeactivateAMCViewToolbars ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnDeactivateAMCViewToolbars"));

    m_pActiveAMCViewToolbars = NULL;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCToolBar::ScHideButton
//
//  Synopsis:    Hide or Un-hide a button & update the toolbar
//               separators & size.
//
//  Arguments:   [idCommand] - Command ID of the button to [un]hide.
//               [fHiding]   - Hide or Unhide.
//
//  Returns:     SC
//
//  Note:        Do not call this method to hide separators.
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScHideButton (int idCommand, BOOL fHiding)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMMCToolBar::ScHideButton"));

    int nIndex = CommandToIndex(idCommand);

    TBBUTTON tbButton;
    BOOL bRet = GetButton(nIndex, &tbButton);
    sc = bRet ? S_OK : E_FAIL;
    if (sc)
        return sc;

    // Dont call this method to hide separators.
    if (tbButton.fsStyle & TBSTYLE_SEP)
        return (sc = S_FALSE);

    bRet = HideButton(idCommand, fHiding);
    sc = bRet ? S_OK : E_FAIL;
    if (sc)
        return sc;

    UpdateSeparators (idCommand, fHiding);
    UpdateToolbarSize(true /* Update Asynch'ly*/);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      UpdateToolbarSize
//
//  Synopsis:    Update the toobar, needed to lazy update (not update
//               after adding each button, cache all the buttons) of
//               toolbar size.
//
//  Arguments:   [bAsync] - Asynchronous or Synch update.
//
//  Returns:     void
//
//--------------------------------------------------------------------
void CMMCToolBar::UpdateToolbarSize(bool bAsync)
{
    MSG msg;

    HWND hWnd = m_hWnd;

    if (!bAsync)
        CToolBarCtrlEx::UpdateToolbarSize();
    else if (!PeekMessage (&msg, m_hWnd, s_nUpdateToolbarSizeMsg, s_nUpdateToolbarSizeMsg, PM_NOREMOVE))
        ::PostMessage (m_hWnd, s_nUpdateToolbarSizeMsg, 0, 0);
}

//+-------------------------------------------------------------------
//
//  Member:      OnUpdateToolbarSize
//
//  Synopsis:    Our registered message handler.
//
//  Arguments:   None used.
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CMMCToolBar::OnUpdateToolbarSize(WPARAM , LPARAM)
{
    CToolBarCtrlEx::UpdateToolbarSize();
    return 0;
}

/*--------------------------------------------------------------------------*
 * CMMCToolBar::UpdateSeparators
 *
 * The legend for the comments below is:
 *
 *      L = left edge
 *      R = right edge
 *      * = target button
 *      B = visible non-separator
 *      b = hidden non-separator
 *      S = visible separator
 *      s = hidden separator
 *      h = 0 or more hidden buttons, separator or non-separator
 *--------------------------------------------------------------------------*/
void CMMCToolBar::UpdateSeparators (int idCommand, BOOL fHiding)
{
    int nButtonIndex = CommandToIndex (idCommand);

    if (nButtonIndex == -1)
        return;

    int nLeftVisible;
    int nRightVisible;
    int cButtons = GetButtonCount ();

    /*
     * If the button is being hidden, turn off any separators
     * that are now redundant.  There are three situations where
     * we'll need to turn off a separator (see legend above):
     *
     * 1.  Lh*hS
     * 2.  Sh*hS
     * 3.  Sh*hR
     *
     * These situations are mutually exclusive.
     */
    if (fHiding)
    {
        TBBUTTON btnLeft;
        TBBUTTON btnRight;

        /*
         * look to the left of the button being hidden for the
         * left edge or a visible button
         */
        for (nLeftVisible = nButtonIndex-1; nLeftVisible >= 0; nLeftVisible--)
        {
            GetButton (nLeftVisible, &btnLeft);

            if (!(btnLeft.fsState & TBSTATE_HIDDEN))
                break;
        }
        ASSERT (nLeftVisible <  nButtonIndex);
        ASSERT (nLeftVisible >= -1);


        /*
         * look to the right of the button being hidden for the
         * right edge or a visible separator
         */
        for (nRightVisible = nButtonIndex+1; nRightVisible < cButtons; nRightVisible++)
        {
            GetButton (nRightVisible, &btnRight);

            if (!(btnRight.fsState & TBSTATE_HIDDEN))
                break;
        }
        ASSERT (nRightVisible >  nButtonIndex);
        ASSERT (nRightVisible <= cButtons);


        /*
         * case 1:  Lh*hS
         */
        if ((nLeftVisible == -1) &&
            (nRightVisible != cButtons) &&
            (btnRight.fsStyle & TBSTYLE_SEP))
            HideButton (btnRight.idCommand, true);

        /*
         * case 2:  Sh*hS
         */
        else if ((nLeftVisible != -1) &&
                 (nRightVisible != cButtons) &&
                 (btnLeft.fsStyle  & TBSTYLE_SEP) &&
                 (btnRight.fsStyle & TBSTYLE_SEP))
            HideButton (btnRight.idCommand, true);

        /*
         * case 3:  Sh*hR
         */
        else if ((nLeftVisible != -1) &&
                 (nRightVisible == cButtons) &&
                 (btnLeft.fsStyle & TBSTYLE_SEP))
            HideButton (btnLeft.idCommand, true);
    }

    /*
     * Otherwise, the button is being shown; turn on any separators
     * that are no longer redundant.  There are two situations where
     * we'll need to turn on a separator (see legend above):
     *
     * 1.  Bhsh*
     * 2.  *hshB
     *
     * Both 1 and 2 can occur simultaneously.
     */
    else do // not a loop
        {
            TBBUTTON btn;

            /*
             * look to the left of the button being shown for the
             * left edge or a visible button
             */
            int idLeftSeparatorCommand = -1;
            for (nLeftVisible = nButtonIndex-1; nLeftVisible >= 0; nLeftVisible--)
            {
                GetButton (nLeftVisible, &btn);

                if (btn.fsStyle & TBSTYLE_SEP)
                    idLeftSeparatorCommand = btn.idCommand;

                if (!(btn.fsState & TBSTATE_HIDDEN))
                    break;
            }
            ASSERT (nLeftVisible <  nButtonIndex);
            ASSERT (nLeftVisible >= -1);


            /*
             * look to the right of the button being shown for the
             * right edge or a hidden separator
             */
            int idRightSeparatorCommand = -1;
            for (nRightVisible = nButtonIndex+1; nRightVisible < cButtons; nRightVisible++)
            {
                GetButton (nRightVisible, &btn);

                if (btn.fsStyle & TBSTYLE_SEP)
                    idRightSeparatorCommand = btn.idCommand;

                if (!(btn.fsState & TBSTATE_HIDDEN))
                    break;
            }
            ASSERT (nRightVisible >  nButtonIndex);
            ASSERT (nRightVisible <= cButtons);


            /*
             * case 1:  Bhsh*
             */
            if ((nLeftVisible != -1) && (idLeftSeparatorCommand != -1))
                HideButton (idLeftSeparatorCommand, false);

            /*
             * case 2:  *hshB
             */
            if ((nRightVisible != cButtons) && (idRightSeparatorCommand != -1))
                HideButton (idRightSeparatorCommand, false);

        } while (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\trobimpl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       trobimpl.cpp
//
//--------------------------------------------------------------------------


// trobimpl.cpp : implementation file
//

#include "stdafx.h"
#include "amc.h"
#include "trobimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CTreeObserverTreeImpl

CTreeObserverTreeImpl::CTreeObserverTreeImpl() : 
    m_pTreeSrc(NULL), m_dwStyle(0), m_tidRoot(NULL)
{
}

CTreeObserverTreeImpl::~CTreeObserverTreeImpl()
{
}

HRESULT CTreeObserverTreeImpl::SetStyle(DWORD dwStyle)
{
    ASSERT((dwStyle & ~(TOBSRV_HIDEROOT | TOBSRV_FOLDERSONLY)) == 0);

    m_dwStyle = dwStyle;

    return S_OK;
}


HRESULT CTreeObserverTreeImpl::SetTreeSource(CTreeSource* pTreeSrc)
{
    // Window may be gone before source is disconnected 
    if (IsWindow(m_hWnd))
        DeleteAllItems();

    m_pTreeSrc = pTreeSrc;

    if (pTreeSrc == NULL)
        return S_OK;

    // Must have window before populating tree
    ASSERT(IsWindow(m_hWnd));

    // populate top level of tree
    TREEITEMID tidRoot = m_pTreeSrc->GetRootItem();
    if (tidRoot != NULL)
    {
        // Trigger handler as though item were just added
        ItemAdded(tidRoot);
    }

    return S_OK;
}


TREEITEMID CTreeObserverTreeImpl::GetSelection()
{
    HTREEITEM hti = GetSelectedItem();
    
    if (hti)
        return static_cast<TREEITEMID>(GetItemData(hti));
    else
        return NULL;
}

void CTreeObserverTreeImpl::SetSelection(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);

    HTREEITEM hti = FindHTI(tid, TRUE);
    ASSERT(hti != NULL);

    SelectItem(hti);
    EnsureVisible(hti);
}

void CTreeObserverTreeImpl::ExpandItem(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    HTREEITEM hti = FindHTI(tid, TRUE);

    if (hti != NULL)
        Expand(hti, TVE_EXPAND);
}

BOOL CTreeObserverTreeImpl::IsItemExpanded(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    HTREEITEM hti = FindHTI(tid, TRUE);

    return (IsItemExpanded(hti));
}

HTREEITEM CTreeObserverTreeImpl::FindChildHTI(HTREEITEM htiParent, TREEITEMID tid)
{
    HTREEITEM htiTemp;

    if (htiParent == TVI_ROOT)
        htiTemp = GetRootItem();
    else
        htiTemp = GetChildItem(htiParent);

    while (htiTemp && GetItemData(htiTemp) != tid)
    {
        htiTemp = GetNextSiblingItem(htiTemp);
    }

    return htiTemp;
}


HTREEITEM CTreeObserverTreeImpl::FindHTI(TREEITEMID tid, BOOL bAutoExpand)
{
    ASSERT(m_pTreeSrc != NULL);

    if (tid == NULL || (tid == m_tidRoot && RootHidden()))
        return TVI_ROOT;

    HTREEITEM htiParent = FindHTI(m_pTreeSrc->GetParentItem(tid), bAutoExpand);
    
    if (htiParent == NULL)
        return NULL;

    if (bAutoExpand && !WasItemExpanded(htiParent))
        Expand(htiParent, TVE_EXPAND);

    return FindChildHTI(htiParent, tid);
}


HTREEITEM CTreeObserverTreeImpl::AddOneItem(HTREEITEM htiParent, HTREEITEM htiAfter, TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);

    TVINSERTSTRUCT insert;

    insert.hParent = htiParent;
    insert.hInsertAfter = htiAfter;

    insert.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    insert.item.lParam = tid;
    insert.item.iImage = m_pTreeSrc->GetItemImage(tid);
    insert.item.iSelectedImage = insert.item.iImage;
    insert.item.cChildren = m_pTreeSrc->GetChildItem(tid) ? 1 : 0;

    TCHAR name[MAX_PATH];
    m_pTreeSrc->GetItemName(tid, name, MAX_PATH);
    insert.item.pszText = name;

    return InsertItem(&insert);
}


void CTreeObserverTreeImpl::AddChildren(HTREEITEM hti)
{
    ASSERT(m_pTreeSrc != NULL);

    TREEITEMID tidChild;

    // if adding top level item
    if (hti == TVI_ROOT)
    {
        if (RootHidden())
        {
            // if root is hidden, add its children
            ASSERT(m_tidRoot != 0);
            tidChild = m_pTreeSrc->GetChildItem(m_tidRoot);
        }
        else
        {
            // else add root item itself
            tidChild = m_pTreeSrc->GetRootItem();
        }
    }
    else
    {
       // convert to TID, then get its child 
       TREEITEMID tid = static_cast<TREEITEMID>(GetItemData(hti));
       ASSERT(tid != 0);
            
       tidChild = m_pTreeSrc->GetChildItem(tid);
    }

    while (tidChild)
    {
        // Add visible items
        if (!ShowFoldersOnly() || m_pTreeSrc->IsFolderItem(tidChild))
            AddOneItem(hti, TVI_LAST, tidChild);

        tidChild = m_pTreeSrc->GetNextSiblingItem(tidChild);
    }
}


void CTreeObserverTreeImpl::ItemAdded(TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    ASSERT(tid != 0);

    // if only folders visible, skip this item
    if (ShowFoldersOnly() && !m_pTreeSrc->IsFolderItem(tid))
        return;

    // Get parent tree item
    TREEITEMID tidParent = m_pTreeSrc->GetParentItem(tid);

    // if this is the tree root and the root is not displayed
    if (tidParent == NULL && RootHidden())
    {
        // Can only have one hidden root
        ASSERT(m_tidRoot == NULL);

        // Just save TID as the hidden root and return
        m_tidRoot = tid;

        // since root is hidden, add its children to the tree
        AddChildren(TVI_ROOT);

        return;
    }

    // Add new item to tree
    HTREEITEM htiParent = FindHTI(tidParent);

    // Parent exists and has been expanded
    if (WasItemExpanded(htiParent)) 
    {
        // Determine previous tree item
        //   Because the source doesn't support GetPrevSibling
        //   we have to get the next TID then use our own tree to
        //   back up to the previous item
        //
        HTREEITEM htiPrev;
        TREEITEMID tidNext = m_pTreeSrc->GetNextSiblingItem(tid);
        if (tidNext)
        {
            HTREEITEM htiNext = FindChildHTI(htiParent, tidNext);
            ASSERT(htiNext);

            htiPrev = GetPrevSiblingItem(htiNext);
            if (htiPrev == NULL)
                htiPrev = TVI_FIRST;
        }
        else
        {
            htiPrev = TVI_LAST;
        }

        // Insert the new tree item
        AddOneItem(htiParent, htiPrev, tid);
    }
    else if (htiParent)
    {
        // Set child count so parent can expand
        TV_ITEM item;
        item.mask = TVIF_CHILDREN;
        item.hItem = htiParent;
        item.cChildren = 1;

        SetItem(&item);
    }

}


void CTreeObserverTreeImpl::ItemRemoved(TREEITEMID tidParent, TREEITEMID tid)
{
    ASSERT(m_pTreeSrc != NULL);
    ASSERT(tid != 0);

    // if deleting hidden root, clear tree and return
    if (tid == m_tidRoot)
    {
        DeleteAllItems();
        m_tidRoot = NULL;

        return;
    }

    // Get parent tree item
    HTREEITEM htiParent = FindHTI(tidParent);

    if (WasItemExpanded(htiParent))
    {
        // Find removed item
        HTREEITEM hti = FindChildHTI(htiParent, tid);

        // Remove the item
        DeleteItem(hti);
    }
}


void CTreeObserverTreeImpl::ItemChanged(TREEITEMID tid, DWORD dwAttrib)
{
    ASSERT(m_pTreeSrc != NULL);
    ASSERT(tid != 0);

    if (dwAttrib & TIA_NAME)
    {
        // Get changed tree item
        HTREEITEM hti = FindHTI(tid);

        // Force item update
        if (hti != 0)
        {
            TCHAR name[MAX_PATH];
            m_pTreeSrc->GetItemName(tid, name, MAX_PATH);

            TVITEM item;
            item.hItem = hti;
            item.mask = TVIF_TEXT;
            item.pszText = name;
            
            SetItem(&item);
        }
    }
}


void CTreeObserverTreeImpl::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNotify = (NM_TREEVIEW*)pNMHDR;
    ASSERT(pNotify != NULL);

    HTREEITEM hti = pNotify->itemNew.hItem;
    ASSERT(hti != NULL);

    // Enumerate the folders below this item
    if (pNotify->action == TVE_EXPAND)
    {
        // Only add children on first expansion
        if (!(pNotify->itemNew.state & TVIS_EXPANDEDONCE))
            AddChildren(hti);
    }

    // Flip state of icon open/closed
    ASSERT(m_pTreeSrc != NULL);

    TREEITEMID tid = pNotify->itemNew.lParam;
    ASSERT(m_pTreeSrc->IsFolderItem(tid));

    int iImage = (pNotify->action == TVE_EXPAND) ? 
                    m_pTreeSrc->GetItemOpenImage(tid) : m_pTreeSrc->GetItemImage(tid);
    TVITEM item;
    item.hItem = hti;
    item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    item.iImage = item.iSelectedImage = iImage;    
    SetItem(&item);
    

    *pResult = 0;
}

     
void CTreeObserverTreeImpl::OnSingleExpand(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = TVNRET_DEFAULT;
}


BEGIN_MESSAGE_MAP(CTreeObserverTreeImpl, CTreeCtrl)
    ON_NOTIFY_REFLECT(TVN_SINGLEEXPAND, OnSingleExpand)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFavoritesView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\toolbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       toolbar.h
//
//              Toolbars implementation
//
/////////////////////////////////////////////////////////////////////////////

#ifndef TOOLBAR_H
#define TOOLBAR_H

#include "tstring.h"
#include "toolbars.h"

/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include "atlapp.h"
#include "atlctrls.h"

#define  BUTTON_BITMAP_SIZE 16

// Command Ids for buttons.

// we must start from 1, since 0 is special case by MFC (BUG:451883)
#define   MMC_TOOLBUTTON_ID_FIRST  0x0001

// End with 0x5000 as ids from 0x5400 are used for toolbar hot tracking.
// A better soln will be to disable all the toolbar tracking code (in tbtrack.*)
// and use the toolbar tracking provided by the toolbars & rebars implementation.
#define   MMC_TOOLBUTTON_ID_LAST   0x5000

// Forward declarations.
class CMMCToolBar;
class CAMCViewToolbars;

//+-------------------------------------------------------------------
//
//  Class:      CMMCToolbarButton
//
//  Purpose:    The toolbar button data, the CAMCViewToolbars will
//              create this object on request to AddButton/InsertButton
//              call and is destroyed when DeleteButton is called
//              or the IToolbar is destroyed (snapin destroys its
//              toolbar).
//              It knows about its toolbar thro CToolbarNotify.
//
//  History:    12-01-1999   AnandhaG   Created
//
// Note:        The fsState refers only to the state set by snapin
//              and wont be set hidden if toolbar is hidden.
//
//--------------------------------------------------------------------
class CMMCToolbarButton
{
public:
    CMMCToolbarButton(); // Vector of CMMCToolbarButton's requires empty ctor.

    CMMCToolbarButton(int nCommandIDFromSnapin, int nUniqueCommandID,
                      int indexFromSnapin, int iImage,
                      BYTE fsState, BYTE fsStyle, CToolbarNotify* pToolbarNotify)
    : m_nCommandIDFromSnapin(nCommandIDFromSnapin),
      m_nUniqueCommandID(nUniqueCommandID),
      m_indexFromSnapin(indexFromSnapin),
      m_iImage(iImage),
      m_fsState(fsState),
      m_fsStyle(fsStyle),
      m_fAddedToUI(false),
      m_pToolbarNotify(pToolbarNotify)
    {
    }

    // Data accessors.
    LPCTSTR GetTooltip() {return m_strTooltip.data();}
    int     GetCommandIDFromSnapin() const {return m_nCommandIDFromSnapin;}
    int     GetUniqueCommandID() const {return m_nUniqueCommandID;}
    int     GetIndexFromSnapin() const {return m_indexFromSnapin;}
    int     GetBitmap() const {return m_iImage;}
    BYTE    GetStyle() const {return m_fsStyle;}
    BYTE    GetState() const {return m_fsState;}
    CToolbarNotify* GetToolbarNotify() const {return m_pToolbarNotify;}

    void    SetTooltip(LPCTSTR lpszTiptext)
    {
        m_strTooltip = lpszTiptext;
    }
    void    SetButtonText(LPCTSTR lpszBtntext)
    {
        m_strBtnText = lpszBtntext;
    }
    void    SetState(BYTE fsState) {m_fsState = fsState;}

    // Keep track if this button is added to the toolbar UI or not.
    void    SetButtonIsAddedToUI   (bool b = true) { m_fAddedToUI = b; }
    bool    IsButtonIsAddedToUI    () const        { return m_fAddedToUI;}

private:
    int                m_nCommandIDFromSnapin;
    int                m_nUniqueCommandID;
    int                m_iImage;
    int                m_indexFromSnapin;
    int                m_indexUnique;
    BYTE               m_fsState;
    BYTE               m_fsStyle;
    bool               m_fAddedToUI : 1;
    CToolbarNotify*    m_pToolbarNotify;
    tstring            m_strTooltip;
    tstring            m_strBtnText;
};

//+-------------------------------------------------------------------
//
//  Class:      CAMCViewToolbars
//
//  Synopsis:   This object maintains data for the toolbars of a CAMCView.
//              When its view is active it adds the toolbar buttons to the
//              main toolbar UI and handles any of the UI messages.
//
//  Desc:       This object is created and destroyed by the view. It
//              provides following services.
//              1. ability to create/destroy toolbars for this view.
//              2. to manipulate single toolbar. It maintains an array of
//                 toolbuttons from all snapins including std toolbar.
//              3. to observe the view for activation & de-activation.
//                 When the view becomes active it adds the buttons & handles
//                 any button click & tooltip notifications.
//              4. It maintains a single imagelist for all the toolbars for
//                 this object. To get image index for a tool button it maintains
//                 a map of CToolbarNotify* (the snapin toolbar) and imagelist
//                 information like start index & number of images for this CToolbarNotify*
//                 in that imagelist.
//
//              It also provides unique command id for each button (as there is only
//              one toolbar UI which needs unique command id for each button from
//              different snapin).
//
//  History:    12-01-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CAMCViewToolbars : public CAMCViewToolbarsMgr,
                         public CMMCToolbarIntf,
                         public CAMCViewObserver,
                         public CEventSource<CAMCViewToolbarsObserver>
{
public:
    CAMCViewToolbars(CMMCToolBar *pMainToolbar, CAMCView* pAMCViewOwner)
    : m_fViewActive(false), m_pMainToolbar(pMainToolbar), m_pAMCViewOwner(pAMCViewOwner), m_bLastActiveView(false)
    {
        ASSERT(NULL != pMainToolbar);
        ASSERT(NULL != pAMCViewOwner);
    }

    virtual ~CAMCViewToolbars();

public:
    // Creation & manipulation of toolbar/toolbars.
    virtual SC ScCreateToolBar(CMMCToolbarIntf** ppToolbarIntf);
    virtual SC ScDisableToolbars();

    // Manipulate given toolbar.
    virtual SC ScAddButtons(CToolbarNotify* pNotifyCallbk, int nButtons, LPMMCBUTTON lpButtons);
    virtual SC ScAddBitmap (CToolbarNotify* pNotifyCallbk, INT nImages, HBITMAP hbmp, COLORREF crMask);
    virtual SC ScInsertButton(CToolbarNotify* pNotifyCallbk, int nIndex, LPMMCBUTTON lpButton);
    virtual SC ScDeleteButton(CToolbarNotify* pNotifyCallbk, int nIndex);
    virtual SC ScGetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL* pbState);
    virtual SC ScSetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL bState);
    virtual SC ScAttach(CToolbarNotify* pNotifyCallbk);
    virtual SC ScDetach(CToolbarNotify* pNotifyCallbk);
    virtual SC ScDelete(CToolbarNotify* pNotifyCallbk);
    virtual SC ScShow(CToolbarNotify* pNotifyCallbk, BOOL bShow);

    // Observer on view (for activation & de-activation).
    virtual SC  ScOnActivateView    (CAMCView *pAMCView, bool bFirstActiveView);
    virtual SC  ScOnDeactivateView  (CAMCView *pAMCView, bool bLastActiveView);

    // Methods used by toolbar UI (to inform button click & to get tooltip).
    SC ScButtonClickedNotify(UINT nID);
    SC ScGetToolTip(int nCommandID, CString& strTipText);

    // Method used by CAMCView to Init.
    SC ScInit();

private:
    static int GetUniqueCommandID()
    {
        // Cycle thro, this is not a good design as there may
        // be buttons with dup command ids. Alternative is
        // to use a set to keep track of available command ids.
        if (MMC_TOOLBUTTON_ID_LAST == s_idCommand)
            s_idCommand = MMC_TOOLBUTTON_ID_FIRST;

        return (s_idCommand++);
    }

    CMMCToolBar* GetMainToolbar() {return m_pMainToolbar;}

    // Helpers
    SC ScInsertButtonToToolbar  (CMMCToolbarButton* pToolButton);
    SC ScInsertButtonToDataStr  (CToolbarNotify* pNotifyCallbk, int nIndex,
                                 LPMMCBUTTON lpButton, CMMCToolbarButton **ppToolButton);

    SC ScDeleteButtonFromToolbar(CMMCToolbarButton* pToolButton);

    SC ScSetButtonStateInToolbar(CMMCToolbarButton* pToolButton, BYTE nState, BOOL bState);
    SC ScGetButtonStateInToolbar(CMMCToolbarButton *pToolButton, BYTE nState, BOOL* pbState);

    SC ScValidateButton(int nButtons, LPMMCBUTTON lpButtons);
    SC ScSetButtonHelper(int nIndex, CMMCToolbarButton* pToolButton);

    // Members to search our data structures.
    CMMCToolbarButton* GetToolbarButton(int nUniqueCommandID);
    CMMCToolbarButton* GetToolbarButton(CToolbarNotify* pNotifyCallbk, int idCommandIDFromSnapin);

    CImageList* GetImageList() {return CImageList::FromHandle(m_ImageList);}
    int         GetImageCount() {return m_ImageList.GetImageCount();}

    bool IsToolbarAttached(CToolbarNotify* pNotifyCallbk)
    {
        return (m_setOfAttachedToolbars.end() != m_setOfAttachedToolbars.find(pNotifyCallbk) );
    }

    void SetToolbarAttached(CToolbarNotify* pNotifyCallbk, bool bAttach)
    {
        if (bAttach)
            m_setOfAttachedToolbars.insert(pNotifyCallbk);
        else
            m_setOfAttachedToolbars.erase(pNotifyCallbk);
    }

    // The toolbar can be hidden using the customize view dialog.
    // This actually hides the toolbuttons in the toolbar. But the
    // toolbutton is unaware of this hidden information.
    // In other words if the toolbar is hidden then its buttons are
    // hidden but the fsState in CMMCToolbarButton is not set hidden.
    bool IsToolbarHidden(CToolbarNotify* pNotifyCallbk)
    {
        return (m_setOfHiddenToolbars.end() != m_setOfHiddenToolbars.find(pNotifyCallbk) );
    }

    void SetToolbarStatusHidden(CToolbarNotify* pNotifyCallbk, bool bHide)
    {
        if (bHide)
            m_setOfHiddenToolbars.insert(pNotifyCallbk);
        else
            m_setOfHiddenToolbars.erase(pNotifyCallbk);
    }

    bool IsThereAVisibleButton();

private:
    /*
     * There is only one imagelist for this object. All the snapin toolbars
     * and stdbar will add their bitmaps to this single imagelist.
     * So when we add bitmaps for a toolbar we need to know where it starts
     * in the imagelist and how many are added.
     * So we maintain a data struct between toolbar (CToolbarNotify*) and an
     * object (MMCToolbarImages) containing start index & number of images.
     *
     * A snapin may add bitmaps multiple times for single toolbar. Each bitmap
     * is added at different start index.
     * So the data struct is a multi-map  between toolbar (CToolbarNotify*)
     * and MMCToolbarImages.
     *
     * Assume a snapin adds 3 bitmaps initialy & then 4. Then while adding
     * buttons it will specify bitmap index as 5.
     *
     * The first  MMCToolbarImages has cCount = 3, iStartWRTSnapin = 0, thus
     * images from 0 (iStartWRTSnapin) to 3 (iStartWRTSnapin + cCount) with respect
     * to snapin.
     * The second MMCToolbarImages has cCount = 4, iStartWRTSnapin = 3, thus
     * images from 3(iStartWRTSnapin) to 7(iStartWRTSnapin + cCount) wrt snapin.
     * So MMCToolbarImages has iStartWRTSnapin member in addition.
     *
     */

    typedef struct MMCToolbarImages
    {
        int iStart;         // Start index.
        int cCount;         // Number of images.
        int iStartWRTSnapin; // Start index w.r.t snapin
    };

    // This is a multi-map so that snapin can call AddBitmap for same toolbar more than once.
    typedef std::multimap<CToolbarNotify*, MMCToolbarImages> TBarToBitmapIndex;

    // Store toolbars on which attach is called.
    typedef std::set<CToolbarNotify*>                        AttachedToolbars;
    // Store toolbars that are hidden.
    typedef std::set<CToolbarNotify*>                        HiddenToolbars;

    // All toolbuttons for this view.
    typedef std::vector<CMMCToolbarButton>                   ToolbarButtons;

private:
    static int            s_idToolbar;
    static int            s_idCommand;

    ToolbarButtons        m_vToolbarButtons;
    TBarToBitmapIndex     m_mapTBarToBitmapIndex;

    AttachedToolbars      m_setOfAttachedToolbars;
    HiddenToolbars        m_setOfHiddenToolbars;

	/*
	 * Theming: use WTL::CImageList instead of MFC's CImageList so we can
	 * insure a theme-correct imagelist will be created.
	 */
    WTL::CImageList       m_ImageList;

    bool                  m_fViewActive : 1;

    CMMCToolBar*          m_pMainToolbar;
    CAMCView*             m_pAMCViewOwner;

    bool                  m_bLastActiveView;
};

//+-------------------------------------------------------------------
//
//  class:     CMMCToolBar
//
//  Purpose:   The toolbar UI that is shown in mainframe. It observes
//             each CAMCViewToolbar and stores active CAMCViewToolbar
//             so that it can notify that object of button click &
///            tooltip notifications.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMMCToolBar : public CMMCToolBarCtrlEx,
                    public CAMCViewToolbarsObserver
{
    // Needed to lazy update (not update after adding
    // each button, cache all the buttons) of toolbar size.
    static const int s_nUpdateToolbarSizeMsg;

public:
    CMMCToolBar() : m_pActiveAMCViewToolbars(NULL)
    {
    }

    // CAMCViewToolbarsObserver.
    virtual SC  ScOnActivateAMCViewToolbars   (CAMCViewToolbars *pAMCViewToolbars);
    virtual SC  ScOnDeactivateAMCViewToolbars ();

    // Generated message map functions
protected:
    afx_msg void OnButtonClicked(UINT nID);
    afx_msg LRESULT OnUpdateToolbarSize(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateAllCmdUI (CCmdUI*  pCmdUI)
    {
        // The idle update looks for this handler else it disables the
        // toolbuttons. This method does nothing. The buttons are already
        // in right state so dont do anything.
    }

    DECLARE_MESSAGE_MAP()

public:
    // Helpers.
    void UpdateSeparators (int idCommand, BOOL fHiding);
    void UpdateToolbarSize(bool bAsync);
    SC   ScInit(CRebarDockWindow* pRebar);
    SC   ScHideButton(int idCommand, BOOL fHiding);

    // Attributes
private:
    CAMCViewToolbars* m_pActiveAMCViewToolbars;
};

#endif /* TOOLBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\trobimpl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       trobimpl.h
//
//--------------------------------------------------------------------------

// trobimpl.h : header file
//
#ifndef _TROBIMPL_H_
#define _TROBIMPL_H_

#include "treeobsv.h"

/////////////////////////////////////////////////////////////////////////////
// CTreeObserverTreeImpl 

class CTreeObserverTreeImpl : public CTreeCtrl, public CTreeObserver
{
// Construction
public:
    CTreeObserverTreeImpl();
    virtual ~CTreeObserverTreeImpl();

// Attributes
public:

// Operations
public:
    STDMETHOD(SetStyle) (DWORD dwStyle);
    STDMETHOD(SetTreeSource) (CTreeSource* pTreeSrc);
    STDMETHOD_(TREEITEMID, GetSelection) ();
    STDMETHOD_(HTREEITEM, FindHTI)(TREEITEMID tid, BOOL bAutoExpand = FALSE);
	STDMETHOD_(void, SetSelection)   (TREEITEMID tid);
	STDMETHOD_(void, ExpandItem)     (TREEITEMID tid);
    STDMETHOD_(BOOL, IsItemExpanded) (TREEITEMID tid);

    // CTreeObserver methods
    STDMETHOD_(void, ItemAdded)   (TREEITEMID tid);
    STDMETHOD_(void, ItemRemoved) (TREEITEMID tidParent, TREEITEMID tidRemoved);
    STDMETHOD_(void, ItemChanged) (TREEITEMID tid, DWORD dwAttrib);

// Implementation
private:
    HTREEITEM FindChildHTI(HTREEITEM hitParent, TREEITEMID tid);    
    HTREEITEM AddOneItem(HTREEITEM hti, HTREEITEM htiAfter, TREEITEMID tid);
    void AddChildren(HTREEITEM hti);

    bool WasItemExpanded(HTREEITEM hti)
    {
        return (hti == TVI_ROOT) ||
               (hti != NULL && (GetItemState(hti, TVIS_EXPANDEDONCE) & TVIS_EXPANDEDONCE));
    }

    BOOL IsItemExpanded(HTREEITEM hti)
    {
        return (hti == TVI_ROOT) ||
               (hti != NULL && (GetItemState(hti, TVIS_EXPANDED) & TVIS_EXPANDED));
    }

    // Generated message map functions
protected:
    afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSingleExpand(NMHDR* pNMHDR, LRESULT* pResult);

    BOOL RootHidden()      { return m_dwStyle & TOBSRV_HIDEROOT; }
    BOOL ShowFoldersOnly() { return m_dwStyle & TOBSRV_FOLDERSONLY; }

    DECLARE_MESSAGE_MAP()

    CTreeSource*    m_pTreeSrc;
    DWORD           m_dwStyle;
    TREEITEMID      m_tidRoot;      // tid of hidden root
};

    
#endif // _TROBIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\treectrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       treectrl.h
//
//--------------------------------------------------------------------------

// TreeCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAMCTreeView window

#ifndef __TREECTRL_H__
#define __TREECTRL_H__

#include "fontlink.h"
#include "contree.h"        // for CConsoleTree
#include "kbdnav.h"			// for CKeyboardNavDelayTimer
#include "dd.h"

struct SDeleteNodeInfo
{
    HTREEITEM   htiToDelete;
    HTREEITEM   htiSelected;
    BOOL        fDeleteThis;
};


class CAMCTreeView;


class CTreeFontLinker : public CFontLinker
{
public:
    CTreeFontLinker (CAMCTreeView* pTreeView) : m_pTreeView (pTreeView)
        { ASSERT (m_pTreeView != NULL); }

protected:
    virtual std::wstring GetItemText (NMCUSTOMDRAW* pnmcd) const;

private:
    CAMCTreeView* const m_pTreeView;
};


/*+-------------------------------------------------------------------------*
 * class CTreeViewMap
 *
 *
 * PURPOSE: Maintains a fast lookup for converting between tree items,
 *          HNODES and HMTNODES.
 *
 *+-------------------------------------------------------------------------*/
class CTreeViewMap : public CTreeViewObserver
{
    // CTreeViewObserver methods
public:
    virtual SC ScOnItemAdded   (TVINSERTSTRUCT *pTVInsertStruct, HTREEITEM hti, HMTNODE hMTNode);
    virtual SC ScOnItemDeleted (HNODE hNode, HTREEITEM hti);

    // possible conversions
    // 1) HMTNODE   to HNODE     - slow. This class adds a fast lookup.
    // 2) HNODE     to HTREEITEM - slow. This class adds a fast lookup.
    // 3) HMTNODE   to HTREEITEM - slow. This class adds a fast lookup.
    // 4) HTREEITEM to HNODE     - already fast. This class does not need to do this.
    // 5) HTREEITEM to HMTNODE   - already fast. This class does not need to do this.
    // 6) HNODE     to HMTNODE   - already fast. This class does not need to do this.

    // Fast lookup methods
    SC ScGetHNodeFromHMTNode    (HMTNODE hMTNode,  /*out*/ HNODE*     phNode);    // fast conversion from hNode to hMTNode.
    SC ScGetHTreeItemFromHNode  (HNODE   hNode,    /*out*/ HTREEITEM* phti);    // fast conversion from HTREEITEM to HNODE
    SC ScGetHTreeItemFromHMTNode(HMTNODE hMTNode,  /*out*/ HTREEITEM* phti);      // fast conversion from HMTNode to HTREEITEM.

    // implementation
private:

    // This structure holds two pieces to the puzzle together:
    typedef struct TreeViewMapInfo
    {
        HTREEITEM hti;         // a tree item
        HMTNODE   hMTNode;     // the corresponding HMTNODE
        HNODE     hNode;       // the corresponding HNODE for the tree view control being observed.
    } *PTREEVIEWMAPINFO;

    typedef std::map<HNODE,     PTREEVIEWMAPINFO> HNodeLookupMap;
    typedef std::map<HMTNODE,   PTREEVIEWMAPINFO> HMTNodeLookupMap;

    HNodeLookupMap   m_hNodeMap;
    HMTNodeLookupMap m_hMTNodeMap;
};

/*+-------------------------------------------------------------------------*
 * class CAMCTreeView
 *
 *
 * PURPOSE: The scope pane tree control. Responsible for adding and removing
 *          items from the tree and also for sending events to
 *          tree observers.
 *
 *+-------------------------------------------------------------------------*/
class CAMCTreeView :
public CTreeView,
public CConsoleTree,
public CEventSource<CTreeViewObserver>,
public CMMCViewDropTarget
{
    DECLARE_DYNCREATE (CAMCTreeView)
    typedef CTreeView BC;

// Construction
public:
    CAMCTreeView();

// Operations
public:
    // Inserts a node into the tree control
    void ResetNode(HTREEITEM hItem);
    HTREEITEM InsertNode(HTREEITEM hParent, HNODE hNode,
                         HTREEITEM hInsertAfter = TVI_LAST);

    // Sets the folder button(+/-) on or off
    void SetButton(HTREEITEM hItem, BOOL bState);

    // Worker function to expand hItem's hNode
    BOOL ExpandNode(HTREEITEM hItem);

    void DeleteScopeTree(void);
    void CleanUp(void);
    SC   ScSelectNode(MTNODEID* pIDs, int length, bool bSelectExactNode = false); // Select the given node
    HTREEITEM ExpandNode(MTNODEID* pIDs, int length, bool bExpand, bool bExpandVisually=true);
    BOOL IsSelectedItemAStaticNode(void);
    HRESULT AddSubFolders(HTREEITEM hti, LPRESULTDATA pResultData);
    HRESULT AddSubFolders(MTNODEID* pIDs, int length);
    CWnd * GetCtrlFromParent(HTREEITEM hti, LPCTSTR pszResultPane);
    void GetCountOfChildren(HTREEITEM hItem, LONG* pcChildren);
    void SetCountOfChildren(HTREEITEM hItem, int cChildren);
    void DeleteNode(HTREEITEM hti, BOOL fDeleteThis);
    IResultData* GetResultData() { ASSERT(m_spResultData != NULL); return m_spResultData; }
    IFramePrivate*  GetNodeManager() { ASSERT(m_spNodeManager != NULL); return m_spNodeManager; }

    BOOL IsRootItemSel(void)
    {
        return (GetRootItem() == GetSelectedItem());
    }

    CTreeViewMap * GetTreeViewMap() {return &m_treeMap;} // returns the tree map for fast indexing.

    HNODE GetItemNode (HTREEITEM hItem) const
        { return (NodeFromLParam (GetItemData (hItem))); }

    static HNODE NodeFromLParam (LPARAM lParam)
        { return (reinterpret_cast<HNODE>(lParam)); }

    static LPARAM LParamFromNode (HNODE hNode)
        { return (reinterpret_cast<LPARAM>(hNode)); }

public:
    // CConsoleTree methods
    virtual SC ScSetTempSelection    (HTREEITEM htiSelected);
    virtual SC ScRemoveTempSelection ();
    virtual SC ScReselect            ();

private:
	bool		IsTempSelectionActive() const					{ return (m_htiTempSelect != NULL); }
	HTREEITEM	GetTempSelectedItem() const						{ return (m_htiTempSelect); }
	void		SetTempSelectedItem(HTREEITEM htiTempSelect)	{ m_htiTempSelect = htiTempSelect; }

    HTREEITEM   m_htiTempSelect;

public:
#ifdef DBG
    void DbgDisplayNodeName(HNODE hNode);
    void DbgDisplayNodeName(HTREEITEM hti);
#endif

    INodeCallback*  GetNodeCallback();

    // REVIEW:  why are we caching this information here when it's already in CAMCView?
    void    SetHasList(BOOL bHasList) {m_bHasListCurrently = bHasList;}
    BOOL    HasList()       const   {return m_bHasListCurrently;}

protected:
    SC ScGetTreeItemIconInfo(HNODE hNode, HICON *phIcon);

private:
    BOOL    m_bHasListCurrently;

public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCTreeView)
    public:
    virtual BOOL DestroyWindow();
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    //}}AFX_VIRTUAL

// Implementation
public:

    virtual SC   ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint pt, bool& bCopyOperation);
    virtual void RemoveDropTargetHiliting();

    virtual ~CAMCTreeView();
    CAMCView* GetAMCView()
    {
        if (m_pAMCView && ::IsWindow(*m_pAMCView))
            return m_pAMCView;
        return NULL;
    }

friend class CNodeInitObject;
friend class CAMCView;
protected:

    IFramePrivatePtr          m_spNodeManager;
    IScopeDataPrivatePtr      m_spScopeData;
    IHeaderCtrlPtr            m_spHeaderCtrl;
    IResultDataPrivatePtr     m_spResultData;
    IImageListPrivatePtr      m_spRsltImageList;

    BOOL                      m_fInCleanUp;
    BOOL                      m_fInExpanding;
    CAMCView*                 m_pAMCView;
    CTreeViewMap              m_treeMap; // fast indexing

    HRESULT CreateNodeManager(void);
    HTREEITEM GetClickedNode();

private:

    inline IScopeTreeIter* GetScopeIterator();
    inline IScopeTree* GetScopeTree();

    void OnDeSelectNode(HNODE hNode);
    void InitDefListView(LPUNKNOWN pUnkResultsPane);
    HRESULT OnSelectNode(HTREEITEM hItem, HNODE hNode);
    HTREEITEM FindNode(HTREEITEM hti, MTNODEID id);
    HTREEITEM FindSiblingItem(HTREEITEM hti, MTNODEID id);
    void _DeleteNode(SDeleteNodeInfo& dni);
	void CollapseChildren (HTREEITEM htiParent);

    void OnButtonUp();

    CTreeFontLinker m_FontLinker;

	/*
	 * this caches the text for the selected item, so we'll know whether
	 * to fire the ScOnSelectedItemTextChanged event to observers
	 */
	CString			m_strSelectedItemText;

    // Generated message map functions
protected:
    //{{AFX_MSG(CAMCTreeView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChanging(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG

    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangedWorker(NM_TREEVIEW* pnmtv, LRESULT* pResult);
    afx_msg void OnSelChangingWorker(NM_TREEVIEW* pnmtv, LRESULT* pResult);

    DECLARE_MESSAGE_MAP()

private:    // used for the keyboard timer
    class CKeyboardNavDelay : public CKeyboardNavDelayTimer
    {
		typedef CKeyboardNavDelayTimer BaseClass;

    public:
        CKeyboardNavDelay(CAMCTreeView* pTreeView);

        SC ScStartTimer(NMTREEVIEW* pnmtv);
        virtual void OnTimer();

    private:
        CAMCTreeView* const	m_pTreeView;
        NMTREEVIEW			m_nmtvSelChanged;
    };

    friend class CKeyboardNavDelay;
    std::auto_ptr<CKeyboardNavDelay> m_spKbdNavDelay;

    void SetNavigatingWithKeyboard (bool fKeyboardNav);

    bool IsNavigatingWithKeyboard () const
    {
        return (m_spKbdNavDelay.get() != NULL);
    }

public:
    SC ScRenameScopeNode(HMTNODE hMTNode); // put the specified scope node into rename mode.

public:
    CImageList* CreateDragImage(HTREEITEM hItem)
    {
        return GetTreeCtrl().CreateDragImage(hItem);
    }
    BOOL DeleteItem(HTREEITEM hItem)
    {
        return GetTreeCtrl().DeleteItem(hItem);
    }
    CEdit* EditLabel(HTREEITEM hItem)
    {
        return GetTreeCtrl().EditLabel(hItem);
    }
    BOOL EnsureVisible(HTREEITEM hItem)
    {
        return GetTreeCtrl().EnsureVisible(hItem);
    }
    BOOL Expand(HTREEITEM hItem, UINT nCode, bool bExpandVisually);
    BOOL Expand(HTREEITEM hItem, UINT nCode)
    {
        return GetTreeCtrl().Expand(hItem, nCode);
    }
    HTREEITEM GetChildItem(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetChildItem(hItem);
    }
    HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode) const
    {
        return GetTreeCtrl().GetNextItem(hItem, nCode);
    }
    HTREEITEM GetNextSiblingItem(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetNextSiblingItem(hItem);
    }
    HTREEITEM GetParentItem(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetParentItem(hItem);
    }
    BOOL GetItem(TV_ITEM* pItem) const
    {
        return GetTreeCtrl().GetItem(pItem);
    }
    DWORD_PTR GetItemData(HTREEITEM hItem) const
    {
        return GetTreeCtrl().GetItemData(hItem);
    }
    BOOL GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
    {
        return GetTreeCtrl().GetItemRect(hItem, lpRect, bTextOnly);
    }
    HTREEITEM GetSelectedItem()
    {
        return GetTreeCtrl().GetSelectedItem();
    }
    HTREEITEM InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
    {
        return GetTreeCtrl().InsertItem(lpInsertStruct);
    }
    BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
    {
        return GetTreeCtrl().SetItemState(hItem, nState, nStateMask);
    }
    BOOL SetItem(TV_ITEM* pItem)
    {
        return GetTreeCtrl().SetItem(pItem);
    }
    HTREEITEM HitTest(CPoint pt, UINT* pFlags = NULL) const
    {
        return GetTreeCtrl().HitTest(pt, pFlags);
    }
    HTREEITEM HitTest(TV_HITTESTINFO* pHitTestInfo) const
    {
        return GetTreeCtrl().HitTest(pHitTestInfo);
    }
    BOOL SelectItem(HTREEITEM hItem)
    {
        return GetTreeCtrl().SelectItem(hItem);
    }
    HTREEITEM GetRootItem()
    {
        return GetTreeCtrl().GetRootItem();
    }
};

#endif // __TREECTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\treectrl.cpp ===
// TreeCtrl.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amctreectrl.cpp
//
//  Contents:  AMC Tree control implementation
//
//  History:   16-Jul-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------



#include "stdafx.h"

#include "AMCDoc.h"         // AMC Console Document
#include "amcview.h"
#include "childfrm.h"

#include "macros.h"
#include "AMCPriv.h"

#include "AMC.h"
#include "mainfrm.h"
#include "TreeCtrl.h"
#include "resource.h"

#include "guidhelp.h" // LoadRootDisplayName
#include "histlist.h"
#include "websnk.h"
#include "webctrl.h"
#include "..\inc\mmcutil.h"
#include "amcmsgid.h"
#include "resultview.h"
#include "eventlock.h"

extern "C" UINT dbg_count;


//############################################################################
//############################################################################
//
// Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagTree(TEXT("Tree View"), TEXT("Tree View"));
#endif //DBG

//############################################################################
//############################################################################
//
// Implementation of class CTreeViewMap
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScOnItemAdded
 *
 * PURPOSE: Called when an item is added. Indexes the item.
 *
 * PARAMETERS:
 *    TVINSERTSTRUCT * pTVInsertStruct :
 *    HTREEITEM        hti :
 *    HMTNODE          hMTNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScOnItemAdded   (TVINSERTSTRUCT *pTVInsertStruct, HTREEITEM hti, HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScOnItemAdded"));

    // validate parameters
    sc = ScCheckPointers(pTVInsertStruct);
    if(sc)
        return sc;

    if(!hti || !hMTNode)
        return (sc = E_INVALIDARG);

    // create a new map info structure.
    TreeViewMapInfo *pMapInfo = new TreeViewMapInfo;
    if(!pMapInfo)
        return (sc = E_OUTOFMEMORY);

    // fill in the values
    pMapInfo->hNode   = CAMCTreeView::NodeFromLParam (pTVInsertStruct->item.lParam);
    pMapInfo->hti     = hti;
    pMapInfo->hMTNode = hMTNode;

    // set up the indexes
    ASSERT(m_hMTNodeMap.find(pMapInfo->hMTNode) == m_hMTNodeMap.end());
    ASSERT(m_hNodeMap.find(pMapInfo->hNode)     == m_hNodeMap.end());

    m_hMTNodeMap [pMapInfo->hMTNode] = pMapInfo;
    m_hNodeMap   [pMapInfo->hNode]   = pMapInfo;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScOnItemDeleted
 *
 * PURPOSE: Called when a tree item is deleted. Removes the item from the
 *          indexes.
 *
 * PARAMETERS:
 *    HNODE      hNode :
 *    HTREEITEM  hti :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScOnItemDeleted (HNODE hNode, HTREEITEM hti)
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScOnItemDeleted"));

    // validate parameters
    sc = ScCheckPointers((LPVOID) hNode, (LPVOID) hti);
    if(sc)
        return sc;


    // remove the TreeViewMapInfo pointer from all the maps
    HNodeLookupMap::iterator iter = m_hNodeMap.find(hNode);
    if(iter == m_hNodeMap.end())
        return (sc = E_UNEXPECTED);

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    HMTNODE   hMTNode = pMapInfo->hMTNode;

#ifdef DBG
    // verify that the same structure is pointed to by the other maps.
    ASSERT(m_hMTNodeMap.find(hMTNode)->second == pMapInfo);
#endif

    m_hMTNodeMap.erase(hMTNode);
    m_hNodeMap.erase(hNode);

    // finally delete the TreeViewMapInfo structure
    delete pMapInfo;

    return sc;
}


// Fast lookup methods
/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScGetHNodeFromHMTNode
 *
 * PURPOSE: Quickly (log n time) retrieves the HNODE for an HMTNODE.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode :
 *    ou       t :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScGetHNodeFromHMTNode    (HMTNODE hMTNode,  /*out*/ HNODE*     phNode)    // fast conversion from hNode to hMTNode.
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScGetHNode"));

    // validate parameters
    sc = ScCheckPointers((LPVOID) hMTNode, phNode);
    if(sc)
        return sc;

    // find the mapinfo structure.
    HMTNodeLookupMap::iterator iter = m_hMTNodeMap.find(hMTNode);
    if(iter == m_hMTNodeMap.end())
        return (sc = ScFromMMC(IDS_NODE_NOT_FOUND));

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    *phNode = pMapInfo->hNode;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScGetHTreeItemFromHNode
 *
 * PURPOSE:  Quickly (log n time) retrieves the HTREEITEM for an HNODE.
 *
 * PARAMETERS:
 *    HNODE    hNode :
 *    ou       t :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScGetHTreeItemFromHNode(HNODE   hNode,    /*out*/ HTREEITEM* phti)    // fast conversion from HTREEITEM to HNODE
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScGetHTreeItem"));

    // validate parameters
    sc = ScCheckPointers((LPVOID) hNode, phti);
    if(sc)
        return sc;

    // find the mapinfo structure.
    HNodeLookupMap::iterator iter = m_hNodeMap.find(hNode);
    if(iter == m_hNodeMap.end())
        return (sc = E_UNEXPECTED);

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    *phti = pMapInfo->hti;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CTreeViewMap::ScGetHTreeItemFromHMTNode
 *
 * PURPOSE: Quickly (log n time) retrieves the HTREEITEM for an HMTNODE.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode :
 *    ou       t :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CTreeViewMap::ScGetHTreeItemFromHMTNode(HMTNODE hMTNode,  /*out*/ HTREEITEM* phti)      // fast conversion from HMTNode to HTREEITEM.
{
    DECLARE_SC(sc, TEXT("CTreeViewMap::ScGetHTreeItem"));

    // validate parameters
    //sc = ScCheckPointers(hMTNode, phti);
    if(sc)
        return sc;

    // find the mapinfo structure.
    HMTNodeLookupMap::iterator iter = m_hMTNodeMap.find(hMTNode);
    if(iter == m_hMTNodeMap.end())
        return (sc = E_UNEXPECTED);

    TreeViewMapInfo *pMapInfo = iter->second; // find the map info structure.
    if(!pMapInfo)
        return (sc = E_UNEXPECTED);

    *phti = pMapInfo->hti;

    return sc;
}


//############################################################################
//############################################################################
//
// Implementation of class CAMCTreeView
//
//############################################################################
//############################################################################

/////////////////////////////////////////////////////////////////////////////
// CAMCTreeView

DEBUG_DECLARE_INSTANCE_COUNTER(CAMCTreeView);

CAMCTreeView::CAMCTreeView()
    :   m_FontLinker (this)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CAMCTreeView);

    m_fInCleanUp = FALSE;
    m_fInExpanding = FALSE;

    m_pAMCView = NULL;

    SetHasList(TRUE);
    SetTempSelectedItem (NULL);
    ASSERT (!IsTempSelectionActive());

    AddObserver(static_cast<CTreeViewObserver&>(m_treeMap)); // add an observer to this control.
}

CAMCTreeView::~CAMCTreeView()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAMCTreeView);
    // Smart pointer are released during their destructor
}


IMPLEMENT_DYNCREATE(CAMCTreeView, CTreeView)

BEGIN_MESSAGE_MAP(CAMCTreeView, CTreeView)
    //{{AFX_MSG_MAP(CAMCTreeView)
    ON_WM_CREATE()
    ON_NOTIFY_REFLECT(TVN_SELCHANGED,  OnSelChanged)
    ON_NOTIFY_REFLECT(TVN_SELCHANGING, OnSelChanging)
    ON_NOTIFY_REFLECT(TVN_GETDISPINFO, OnGetDispInfo)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemExpanded)
    ON_WM_DESTROY()
    ON_WM_KEYDOWN()
    ON_WM_SYSKEYDOWN()
    ON_WM_SYSCHAR()
    ON_WM_MOUSEACTIVATE()
    ON_WM_SETFOCUS()
    ON_NOTIFY_REFLECT(TVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(TVN_BEGINRDRAG, OnBeginRDrag)
    ON_WM_KILLFOCUS()
    //}}AFX_MSG_MAP

    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)
END_MESSAGE_MAP()


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::ScSetTempSelection
 *
 * Applies temporary selection to the specified HTREEITEM.
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::ScSetTempSelection (HTREEITEM htiTempSelect)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCTreeView::ScSetTempSelection"));

    /*
     * Don't use ScSetTempSelection(NULL) to remove temporary selection;
     * use ScRemoveTempSelection instead.
     */
    ASSERT (htiTempSelect != NULL);
    if (htiTempSelect == NULL)
        return (sc = E_FAIL);

    /*
     * If this fails, you must first call ScRemoveTempSelection to remove
     * the temporary selection state (TVIS_SELECTED) from the current
     * temporary selection.
     */
    ASSERT (!IsTempSelectionActive());

    SetTempSelectedItem (htiTempSelect);
    ASSERT (GetTempSelectedItem() == htiTempSelect);

    HTREEITEM htiSelected = GetSelectedItem();

    if (htiSelected != htiTempSelect)
    {
        SetItemState (htiSelected,   0,             TVIS_SELECTED);
        SetItemState (htiTempSelect, TVIS_SELECTED, TVIS_SELECTED);
    }

    ASSERT (IsTempSelectionActive());
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::ScRemoveTempSelection
 *
 * Removes the temporary selection from the current temporarily selected
 * item, if there is one, and restores it to the item that was selected
 * when the temp selection was applied.
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::ScRemoveTempSelection ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCTreeView::ScRemoveTempSelection"));

    if (!IsTempSelectionActive())
        return (sc = S_FALSE);

    HTREEITEM htiTempSelect = GetTempSelectedItem();
    HTREEITEM htiSelected   = GetSelectedItem();

    if (htiTempSelect != htiSelected)
    {
        SetItemState (htiTempSelect, 0,             TVIS_SELECTED);
        SetItemState (htiSelected,   TVIS_SELECTED, TVIS_SELECTED);
    }

    SetTempSelectedItem (NULL);
    ASSERT (!IsTempSelectionActive());

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::ScReselect
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::ScReselect ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    NM_TREEVIEW nmtv;

    nmtv.itemOld.hItem = nmtv.itemNew.hItem = GetSelectedItem();

    if (nmtv.itemOld.hItem)
    {
        nmtv.itemOld.lParam = nmtv.itemNew.lParam = GetItemData(nmtv.itemOld.hItem);

        LRESULT lUnused;
        OnSelChangingWorker (&nmtv, &lUnused);
        OnSelChangedWorker  (&nmtv, &lUnused);
    }

    return (S_OK);
}

/////////////////////////////////////////////////////////////////////////////
// CAMCTreeView message handlers


BOOL CAMCTreeView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style     |= TVS_EDITLABELS | TVS_HASBUTTONS | TVS_HASLINES | TVS_SHOWSELALWAYS;
    cs.dwExStyle |= WS_EX_CLIENTEDGE;

    // do not paint over the children
    cs.style |= WS_CLIPCHILDREN;

    return CTreeView::PreCreateWindow(cs);
}


INodeCallback*  CAMCTreeView::GetNodeCallback()
{
    return m_pAMCView->GetNodeCallback();
}

inline IScopeTreeIter* CAMCTreeView::GetScopeIterator()
{
    return m_pAMCView->GetScopeIterator();
}

inline IScopeTree* CAMCTreeView::GetScopeTree()
{
    return m_pAMCView->GetScopeTree();
}

void CAMCTreeView::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult)
{
    HRESULT hr;
    TV_DISPINFO* ptvdi = (TV_DISPINFO*)pNMHDR;

    HNODE hNode = NodeFromLParam (ptvdi->item.lParam);
    ASSERT(m_pAMCView != NULL);

    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);
    if (hNode)
    {
        if (ptvdi->item.mask & TVIF_TEXT)
        {
            tstring strName;
            hr = spCallback->GetDisplayName(hNode, strName);
            if (hr != S_OK)
            {
                ptvdi->item.pszText[0] = _T('\0');
                ASSERT(FALSE);
            }
            else
            {
                // copy the text, but not too much
                ASSERT (!IsBadWritePtr (ptvdi->item.pszText, ptvdi->item.cchTextMax));
                _tcsncpy (ptvdi->item.pszText, strName.data(), ptvdi->item.cchTextMax);

                /*
                 * _tcsncpy won't terminate the destination if the
                 * source is bigger than the buffer; make sure the
                 * string is NULL-terminated
                 */
                ptvdi->item.pszText[ptvdi->item.cchTextMax-1] = _T('\0');

                /*
                 * If this is the selected item and it's text has changed,
                 * fire an event so observers can know.
                 */
                if ((m_strSelectedItemText != strName.data()) &&
                    (GetSelectedItem() == ptvdi->item.hItem))
                {
                    m_strSelectedItemText = strName.data();
                    SC sc = ScFireEvent (CTreeViewObserver::ScOnSelectedItemTextChanged,
                                         (LPCTSTR) m_strSelectedItemText);
                    if (sc)
                        sc.TraceAndClear();
                }
            }
        }

        int nImage, nSelectedImage;
        hr = spCallback->GetImages(hNode, &nImage, &nSelectedImage);

#ifdef DBG
        if (hr != S_OK)
        {
            ASSERT(nImage == 0 && nSelectedImage == 0);
        }
#endif
        if (ptvdi->item.mask & TVIF_IMAGE)
            ptvdi->item.iImage = nImage;

        if (ptvdi->item.mask & TVIF_SELECTEDIMAGE)
            ptvdi->item.iSelectedImage = nSelectedImage;

        // We will get this request once, the first time the scope item comes into view
        if (ptvdi->item.mask & TVIF_CHILDREN)
        {
            ptvdi->item.cChildren = (spCallback->IsExpandable(hNode) != S_FALSE);

            // set children to fixed value, to avoid any more callbacks
            SetCountOfChildren(ptvdi->item.hItem, ptvdi->item.cChildren);
        }
    }
    else
    {
        ASSERT(0 && "OnGetDispInfo(HNODE is NULL)");
    }

    *pResult = 0;
}


//
// Description:  This method will set the folders Button(+/-) on or
// of depending on the value of bState
//
// Parameters:
//      hItem: the tree item affected
//      bState: TRUE = Enable for folder to show it has children
//              FALSE = Disable for folder to show it has NO children
//
void CAMCTreeView::SetButton(HTREEITEM hItem, BOOL bState)
{
    ASSERT(hItem != NULL);

    TV_ITEM item;
    ZeroMemory(&item, sizeof(item));

    item.hItem = hItem;
    item.mask =  TVIF_HANDLE | TVIF_CHILDREN;
    item.cChildren = bState;

    SetItem(&item);
}

//
// Description: This method will populate hItem's(parent folder) children into
//              the tree control.
//
// Parameters:
//      hItem: the parent
//
BOOL CAMCTreeView::ExpandNode(HTREEITEM hItem)
{
    TRACE_METHOD(CAMCTreeView, ExpandNode);

    // not frequently, but... snap-in will display the dialog, dismissing that will
    // activate the frame again. Tree item will be automatically selected if there
    // is none selected yet. Following will prevent the recursion.
    if (m_fInExpanding)
        return FALSE;

    HRESULT hr;

    // Get the HNODE from the tree node
    HNODE hNode = GetItemNode(hItem);
    ASSERT(hNode != NULL);
    ASSERT(m_pAMCView != NULL);

    HMTNODE hMTNode;
    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);
    hr = spCallback->GetMTNode(hNode, &hMTNode);
    ASSERT(hr == S_OK);

    if (hr == S_OK)
    {
        // The notify will return S_FALSE to indicate already expanded
        // or E_xxxx to indicate an error.

        hr = spCallback->Notify(hNode, NCLBK_EXPAND, FALSE, 0);

        if (hr == S_FALSE)
        {

            __try
            {
                m_fInExpanding = TRUE;
                hr = spCallback->Notify(hNode, NCLBK_EXPAND, TRUE, 0);
            }
            __finally
            {
                m_fInExpanding = FALSE;
            }

            if (SUCCEEDED(hr))
            {
                IScopeTreeIter* spIterator = m_pAMCView->GetScopeIterator();
                hr = spIterator->SetCurrent(hMTNode);
                HMTNODE hMTChildNode;

                // Get the child for the current iterator node and add
                // them to this tree
                if (spIterator->Child(&hMTChildNode) == S_OK)
                {
                    IScopeTree* spScopeTree = m_pAMCView->GetScopeTree();
                    HNODE hNewNode;
                    unsigned int nFetched = 0;

                    if (spIterator->SetCurrent(hMTChildNode) == S_OK)
                    {
                        HMTNODE hCurrentChildNode = hMTChildNode;

                        do
                        {
                            // Get the children and convert them to HNODEs
                            // and add them to the tree
                            hr = spIterator->Next(1, &hCurrentChildNode,
                                                  &nFetched);

                            if (hr != S_OK || nFetched <= 0)
                                break;

                            // Insert node into the  tree control
                            spScopeTree->CreateNode(hCurrentChildNode,
                              reinterpret_cast<LONG_PTR>(m_pAMCView->GetViewData()),
                              FALSE, &hNewNode);

#include "pushwarn.h"
#pragma warning(disable: 4552)      // "!=" operator has no effect
                            VERIFY(InsertNode(hItem, hNewNode) != NULL);
#include "popwarn.h"

                            // give 'em a chance to do the "preload" thing, if applicable
                            spCallback->PreLoad (hNewNode);

                        } while (1);
                    }
                }

                spCallback->Notify(hNode, NCLBK_EXPANDED, 0, 0);
            }
        }
    }

    return SUCCEEDED(hr);
}

HTREEITEM CAMCTreeView::InsertNode(HTREEITEM hParent, HNODE hNode,
                                   HTREEITEM hInsertAfter)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::InsertNode"));
    ASSERT(hParent != NULL);
    ASSERT(hNode != NULL);
    HRESULT hr;

    TV_INSERTSTRUCT tvInsertStruct;
    TV_ITEM& item = tvInsertStruct.item;

    ZeroMemory(&tvInsertStruct, sizeof(tvInsertStruct));

    // Insert item at the end of the hItem chain
    tvInsertStruct.hParent = hParent;
    tvInsertStruct.hInsertAfter = hInsertAfter;

    item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN |
                TVIF_PARAM | TVIF_TEXT;

    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam = LParamFromNode (hNode);

    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);

    // Set callback mode for children, so we don't have to determine this
    // until the scope item becomes visible (it can be expensive).
    item.cChildren = I_CHILDRENCALLBACK;

    spCallback->GetImages(hNode, &item.iImage, &item.iSelectedImage);

    HTREEITEM hti = InsertItem(&tvInsertStruct);

    HMTNODE hMTNode = NULL;

    sc = spCallback->GetMTNode(hNode, &hMTNode);
    if(sc)
        sc.TraceAndClear();

    // send an event to all interested observers
    sc = ScFireEvent(CTreeViewObserver::ScOnItemAdded, &tvInsertStruct, hti, hMTNode);
    if(sc)
        sc.TraceAndClear();

    if (hParent != TVI_ROOT && hti != NULL)
        SetCountOfChildren(hParent, 1);

    return hti;
}

void CAMCTreeView::ResetNode(HTREEITEM hItem)
{
    if (hItem == NULL)
        return;

    TV_ITEM item;
    ZeroMemory(&item, sizeof(item));

    item.hItem = hItem;
    item.mask =  TVIF_HANDLE | TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE |
                 TVIF_STATE | TVIF_TEXT | TVIF_CHILDREN;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.iImage = I_IMAGECALLBACK;
    item.iSelectedImage = I_IMAGECALLBACK;
    item.cChildren = I_CHILDRENCALLBACK;
    item.lParam = GetItemData(hItem);

    SetItem(&item);
}


void CAMCTreeView::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
    TRACE_METHOD(CAMCTreeView, OnItemExpanding);

    HRESULT hr;

    NM_TREEVIEW* pNotify = (NM_TREEVIEW*)pNMHDR;
    ASSERT(pNotify != NULL);

    HTREEITEM &hItem = pNotify->itemNew.hItem;
    ASSERT(hItem != NULL);

    BOOL bExpand = FALSE;

    // Iteratate the folders below this item
    if (pNotify->action == TVE_EXPAND)
    {
        /*
         * Bug 333971:  Node expansion might take awhile.  Supply a wait cursor
         * for all of the UI-challenged snap-ins out there.
         */
        SetCursor (LoadCursor (NULL, IDC_WAIT));

        ExpandNode(hItem);
        bExpand = TRUE;

        /*
         * return the arrow
         */
        SetCursor (LoadCursor (NULL, IDC_ARROW));
    }

    INodeCallback* pCallback = GetNodeCallback();
    ASSERT(pCallback != NULL);
    HNODE hNode = GetItemNode (hItem);
    pCallback->Notify(hNode, NCLBK_SETEXPANDEDVISUALLY, bExpand, 0);

    // If item has no children remove the + sign
    if (GetChildItem(hItem) == NULL)
        SetButton(hItem, FALSE);

    *pResult = 0;
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnItemExpanded
 *
 * TVN_ITEMEXPANDED handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC (sc, _T("CAMCTreeView::OnItemExpanded"));

    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
    sc = ScCheckPointers (pnmtv);
    if (sc)
        return;

    /*
     * Bug 23153:  when collapsing, totally collapse the tree beneath the
     * collapsing item.  We do this in OnItemExpanded rather than
     * OnItemExpanding so we won't see the collapse happen.
     */
    if (pnmtv->action == TVE_COLLAPSE)
    {
        CWaitCursor wait;
        CollapseChildren (pnmtv->itemNew.hItem);
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CollapseChildren
 *
 * Collapses each descendent node of htiParent.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::CollapseChildren (HTREEITEM htiParent)
{
    HTREEITEM htiChild;

    for (htiChild  = GetChildItem (htiParent);
         htiChild != NULL;
         htiChild  = GetNextItem (htiChild, TVGN_NEXT))
    {
        Expand (htiChild, TVE_COLLAPSE);
        CollapseChildren (htiChild);
    }
}

void CAMCTreeView::OnDeSelectNode(HNODE hNode)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnDeSelectNode"));

    {
        // tell all interested observers about the deselection.
        // NOTE: the order is important - legacy snapins believe they can access the
        // result pane at this point and have the items still there.
        // But this is intermediate state, so Com events are locked out until the
        // results are cleared.
        // see windows bug (ntbug09) bug# 198660. (10/11/00)
        LockComEventInterface(AppEvents);
        sc = ScFireEvent(CTreeViewObserver::ScOnItemDeselected, hNode);
        if(sc)
            return;

        // Ensure the result view is clean.
        if (HasList())
        {
            // First findout if the result view is properly
            // set in the nodemgr by asking IFramePrivate.
            IFramePrivatePtr spFrame = m_spResultData;
            if (NULL != spFrame)
            {
                BOOL bIsResultViewSet = FALSE;
                sc = spFrame->IsResultViewSet(&bIsResultViewSet);

                // The result view is set, clean it up.
                if (bIsResultViewSet)
                {
                    m_spResultData->DeleteAllRsltItems();
                    m_spResultData->ResetResultData();
                }
            }
        }
    }

    // don't have a valid result pane type anymore.
    SetHasList(false);
}



// Note that OnSelectNode will return S_FALSE if the snap-in changes
// the selection during the process of selecting the requested node.
// A caller that gets an S_FALSE should assume that a different node
// is selected and continue accordingly.
HRESULT CAMCTreeView::OnSelectNode(HTREEITEM hItem, HNODE hNode)
{
    DECLARE_SC(sc, _T("CAMCTreeView::OnSelectNode"));

    if (!hItem)
    {
        TraceError(_T("Null hItem ptr\n"), sc);
        sc = S_FALSE;
        return sc.ToHr();
    }

    if (!hNode)
    {
        TraceError(_T("Null hNode ptr\n"), sc);
        sc = S_FALSE;
        return sc.ToHr();
    }


    // First ensure that the node has been enumerated by calling expand node.
    ExpandNode(hItem);


    // set up the AMCView correctly.
    BOOL bAddSubFolders = FALSE;

    sc = m_pAMCView->ScOnSelectNode(hNode, bAddSubFolders);
    if(sc)
        return sc.ToHr();

    SetHasList(m_pAMCView->HasList());

    // add subfolders if necessary.
    if(bAddSubFolders)
    {
        sc = AddSubFolders(hItem, m_spResultData);
        if (sc)
            return sc.ToHr();
    }

    if (HasList())
        m_spResultData->SetLoadMode(FALSE); // SetLoadMode(FALSE) was called by CAMCView::OnSelectNode.
                                            // Need to change so that both calls are from the same function.

    // get the node callback
    INodeCallback* spNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(spNodeCallBack, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // send preload notify to children
    HTREEITEM hti = GetChildItem (hItem);
    while (hti != NULL)
    {
        HNODE hNode = GetItemNode (hti);
        if (hNode != 0)
            spNodeCallBack->PreLoad (hNode);
        hti = GetNextItem(hti, TVGN_NEXT);
    }


    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::SetNavigatingWithKeyboard
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCTreeView::SetNavigatingWithKeyboard (bool fKeyboardNav)
{
    /*
     * if the requested state doesn't match the current state,
     * change the current state to match the request
     */
    if (fKeyboardNav != IsNavigatingWithKeyboard())
    {
        m_spKbdNavDelay = std::auto_ptr<CKeyboardNavDelay>(
                                (fKeyboardNav)
                                        ? new CKeyboardNavDelay (this)
                                        : NULL /*assigning NULL deletes*/);
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnSelChanging
 *
 * TVN_SELCHANGING handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnSelChanging(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    if (!IsNavigatingWithKeyboard())
        OnSelChangingWorker ((NM_TREEVIEW*) pNMHDR, pResult);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnSelChanged
 *
 * TVN_SELCHANGED handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pNMHDR;
    *pResult = 0;

    if (IsNavigatingWithKeyboard())
        m_spKbdNavDelay->ScStopTimer();

    SetNavigatingWithKeyboard (pnmtv->action == TVC_BYKEYBOARD);

    bool fDelayedSelection = IsNavigatingWithKeyboard() &&
                             !m_spKbdNavDelay->ScStartTimer(pnmtv).IsError();

    if (!fDelayedSelection)
        OnSelChangedWorker (pnmtv, pResult);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CKeyboardNavDelay::CKeyboardNavDelay
 *
 *
 *--------------------------------------------------------------------------*/

CAMCTreeView::CKeyboardNavDelay::CKeyboardNavDelay (CAMCTreeView* pTreeView) :
    m_pTreeView (pTreeView)
{
    ZeroMemory (&m_nmtvSelChanged, sizeof (m_nmtvSelChanged));
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CKeyboardNavDelay::OnTimer
 *
 * Called when the keyboard navigation delay timer fires.  When that happens,
 * we need to perform the selection
 *--------------------------------------------------------------------------*/

void CAMCTreeView::CKeyboardNavDelay::OnTimer()
{
    /*
     * we don't need any more ticks from this timer (ignoring errors)
     */
    ScStopTimer();
    Trace (tagKeyboardNavDelay, _T("Applying delayed scope selection change"));

    LRESULT lUnused = 0;
    m_pTreeView->OnSelChangedWorker (&m_nmtvSelChanged,  &lUnused);
    m_pTreeView->SetNavigatingWithKeyboard (false);

    /*
     * HANDS OFF!  CAMCTreeView::SetNavigatingWithKeyboard deleted this object!
     */
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::CKeyboardNavDelay::ScStartTimer
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCTreeView::CKeyboardNavDelay::ScStartTimer(NMTREEVIEW* pnmtv)
{
    DECLARE_SC (sc, _T("CAMCTreeView:CKeyboardNavDelay::ScStartTimer"));

    /*
     * let the base class start the timer
     */
    sc = BaseClass::ScStartTimer();
    if (sc)
        return (sc);

    /*
     * copy the notification struct so we can send it when our timer ticks
     */
    m_nmtvSelChanged = *pnmtv;

    return (sc);
}


void CAMCTreeView::OnSelChangedWorker(NM_TREEVIEW* pnmtv, LRESULT* pResult)
{
    TRACE_METHOD(CAMCTreeView, OnSelChangedWorker);

    if (m_fInCleanUp == TRUE)
        return;

    // See which pane has focus. Some snapins/ocx may steal the focus
    // so we restore the focus after selecting the node.
    ASSERT (m_pAMCView != NULL);
    const CConsoleView::ViewPane ePane = m_pAMCView->GetFocusedPane();

    //
    // Select the new node
    //

    // Disable drawing to avoid seeing intermediate tree states.
    UpdateWindow();
    HRESULT hr = OnSelectNode(pnmtv->itemNew.hItem, (HNODE)pnmtv->itemNew.lParam);

    if (hr == S_OK)
    {
        CStandardToolbar* pStdToolbar = m_pAMCView->GetStdToolbar();
        ASSERT(NULL != pStdToolbar);
        if (NULL != pStdToolbar)
        {
            pStdToolbar->ScEnableUpOneLevel(GetRootItem() != pnmtv->itemNew.hItem);

            pStdToolbar->ScEnableExportList(m_pAMCView->HasListOrListPad());
        }
        *pResult = 0;
    }
    else if (hr == S_FALSE)
    {
        // snap-in changed the selection on us, so don't continue with this node.
        return;
    }
    else
    {
        // something wrong with the node we are trying to select, reselect the old one
//      SelectItem(pnmtv->itemOld.hItem);
        MMCMessageBox(IDS_SNAPIN_FAILED_INIT);
        *pResult = hr;
    }

    /*
     * Even if the active view hasn't changed always restore the active view.
     * Reason being, for OCX's even though they have the focus, they require
     * MMC to inform that OCX being selected. (see bug: 180964)
     */
    switch (ePane)
    {
        case CConsoleView::ePane_ScopeTree:
        {
            // if another view was made active, switch it back.
            // View could still be active, but have focus stolen by
            // a snap-in or ocx, so ensure view has focus too.
            CFrameWnd* pFrame = GetParentFrame();

            if (pFrame->GetActiveView() != this)
                pFrame->SetActiveView(this);

            else if (::GetFocus() != m_hWnd)
                SetFocus();

            break;
        }

        case CConsoleView::ePane_Results:
            // If the result pane has the focus before and after
            // the node was selected, then the last event snapin
            // receives is scope selected which is incorrect.
            // So we first set scope pane as active view but do
            // not send notifications. Then we set result pane
            // as active view which sends scope de-select and
            // result pane select.


            // Set Scope pane as active view and we also want to
            // be notified about this active view so that our
            // view activation observers will know who is the
            // active view.
            GetParentFrame()->SetActiveView(this, true);

            // Now set result pane as active view and ask for notifications.
            m_pAMCView->ScDeferSettingFocusToResultPane();
            break;

        case CConsoleView::ePane_None:
            // no pane is active, do nothing
            break;

        default:
            m_pAMCView->ScSetFocusToPane (ePane);
            break;
    }

    /*
     * Bug 345402:  Make sure the focus rect is on the list control (if it
     * actually has the focus) to wake up any accessibility tools that might
     * be watching for input and focus changes.
     */
    m_pAMCView->ScJiggleListViewFocus ();
}


void CAMCTreeView::OnSelChangingWorker (NM_TREEVIEW* pnmtv, LRESULT* pResult)
{
    TRACE_METHOD(CAMCTreeView, OnSelChangingWorker);

    if (m_fInCleanUp == TRUE)
        return;

    //
    // De-select the current node
    //
    OnDeSelectNode ((HNODE)pnmtv->itemOld.lParam);

    *pResult = 0;
}




HRESULT CAMCTreeView::AddSubFolders(MTNODEID* pIDs, int length)
{
    ASSERT(pIDs != NULL && length != 0);

    HRESULT hr = E_FAIL;

    // first make sure the specified node is expanded in the tree ctrl
    HTREEITEM hti = ExpandNode(pIDs, length, TRUE, false /*bExpandVisually*/);
    ASSERT(hti != NULL);

    // if successful, add the node's subfolders to the list view
    if (hti != NULL)
    {
        hr = AddSubFolders(hti, m_spResultData);
        ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT CAMCTreeView::AddSubFolders(HTREEITEM hti, LPRESULTDATA pResultData)
{
    HRESULT hr;
    RESULTDATAITEM tRDI;
    ::ZeroMemory(&tRDI, sizeof(tRDI));

    tRDI.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    tRDI.nCol = 0;
    tRDI.str = MMC_TEXTCALLBACK;
    tRDI.nImage = MMC_IMAGECALLBACK;
    tRDI.nIndex = -1;

    hti = GetChildItem(hti);

    ASSERT(m_pAMCView != NULL);
    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);

    while (hti != NULL)
    {
        HNODE hNode = GetItemNode (hti);

        if (hNode != 0)
        {
            tRDI.lParam = LParamFromNode (hNode);

            hr = pResultData->InsertItem(&tRDI);
            CHECK_HRESULT(hr);

            if (SUCCEEDED(hr))
                hr = spCallback->SetResultItem(hNode, tRDI.itemID);

            // add custom image if any
            spCallback->AddCustomFolderImage (hNode, m_spRsltImageList);
        }

        hti = GetNextItem(hti, TVGN_NEXT);
    }

    return S_OK;
}


int CAMCTreeView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC (sc, _T("CAMCTreeView::OnCreate"));
    TRACE_METHOD(CAMCTreeView, OnCreate);

    if (CTreeView::OnCreate(lpCreateStruct) == -1)
        return -1;

    m_pAMCView = ::GetAMCView (this);
    ASSERT(m_pAMCView != NULL);

    IScopeTree* spScopeTree = m_pAMCView->GetScopeTree();
    ASSERT(spScopeTree != NULL);

    HIMAGELIST hImageList;
    spScopeTree->GetImageList(reinterpret_cast<PLONG_PTR>(&hImageList));

    CBitmap bmp;
    bmp.LoadBitmap(MAKEINTRESOURCE(IDB_AMC_NODES16));
    int i = ImageList_AddMasked(hImageList, (HBITMAP) bmp.GetSafeHandle(), RGB(255,0,255));

    ASSERT(i != -1 && "ImageList_Add failed.");

    TreeView_SetImageList( *this, hImageList, TVSIL_NORMAL );

    sc = ScRegisterAsDropTarget(m_hWnd);
    if (sc)
        return (-1);

    sc = CreateNodeManager();
    if (sc)
        return (-1);

    return 0;
}

BOOL CAMCTreeView::DestroyWindow()
{
    TRACE_METHOD(CAMCTreeView, DestroyWindow);

    CleanUp();

    return CTreeView::DestroyWindow();
}

void
CAMCTreeView::DeleteNode(
    HTREEITEM htiToDelete,
    BOOL fDeleteThis)
{
    // Ensure curr sel is not a child of the item to be deleted.
    for (HTREEITEM hti = GetSelectedItem();
         hti != NULL;
         hti = GetParentItem(hti))
    {
        if (htiToDelete == hti)
        {
            if (fDeleteThis == TRUE)
            {
                hti = GetParentItem(hti);
                if (hti)
                    SelectItem(hti);
            }
            break;
        }
    }

    // There are two paths to this function.  Path 1, the view is deleted and there is no
    // longer a root node.  Path 2. When a node is manually deleted, the selection is updated
    // in CAMCView::OnUpdateSelectionForDelete, therefore, the above code traverses to the root node

    ASSERT(hti == NULL || fDeleteThis == FALSE);

    SDeleteNodeInfo dniLocal = {htiToDelete, hti, fDeleteThis};
    _DeleteNode(dniLocal);
}

void CAMCTreeView::_DeleteNode(SDeleteNodeInfo& dni)
{
   ASSERT(&dni != NULL);
   ASSERT(dni.htiToDelete != NULL);

   if (dni.htiToDelete == NULL)
       return;

   SDeleteNodeInfo dniLocal = {GetChildItem(dni.htiToDelete),
                               dni.htiSelected, TRUE};

   // delete all the child nodes of the node being deleted
   while (dniLocal.htiToDelete != NULL)
   {
       _DeleteNode(dniLocal);
       dniLocal.htiToDelete = GetChildItem(dni.htiToDelete);
   }

   if (dni.fDeleteThis == TRUE)
   {
       // Reset the temp selection cache.
       // This deals with items that are right click selected (temporary) on the context
       // menu
       if (IsTempSelectionActive() && (GetTempSelectedItem() == dni.htiToDelete))
       {
           SC sc = ScRemoveTempSelection ();
           if (sc)
               sc.TraceAndClear();
       }

       HNODE hNode = (HNODE)GetItemData(dni.htiToDelete);

       HTREEITEM htiParentOfItemToDelete = GetParentItem(dni.htiToDelete);

       // If the item is in list view remove it. We do not want to do this
       // if it is virtual list or if selected item is "Console Root"
       // in which case then parent is NULL.
       if (HasList() && !m_pAMCView->IsVirtualList() &&
           (NULL != htiParentOfItemToDelete) &&
           (htiParentOfItemToDelete == dni.htiSelected) )
       {
           HRESULTITEM itemID;
           HRESULT hr;
           hr = m_spResultData->FindItemByLParam(LParamFromNode(hNode), &itemID);
           if (SUCCEEDED(hr))
           {
               hr = m_spResultData->DeleteItem(itemID, 0);
               ASSERT(SUCCEEDED(hr));
           }
       }

       // tell the tree control to nuke it
       DeleteItem(dni.htiToDelete);

       // send an event to all interested observers
       SC sc = ScFireEvent(CTreeViewObserver::ScOnItemDeleted, hNode, dni.htiToDelete);
       if(sc)
           sc.TraceAndClear();

       // tell the master tree to nuke it.
       m_pAMCView->GetScopeTree()->DestroyNode(hNode);

       // maintain history
       m_pAMCView->GetHistoryList()->DeleteEntry (hNode);
   }
}

void CAMCTreeView::DeleteScopeTree()
{
    DECLARE_SC(sc, _T("CAMCTreeView::DeleteScopeTree"));

    m_fInCleanUp = TRUE;

    // Release the ResultView from the IFrame in the primary snapin in
    // the selected node.
    //      This is necessary to release the result view if the selected node
    //      is a snap-in node.

    // Free all the nodes
    HTREEITEM htiRoot = GetRootItem();
    if (htiRoot != NULL)
        DeleteNode(htiRoot, TRUE);

    // First findout if the result view is properly
    // set in the nodemgr by asking IFramePrivate.
    IFramePrivatePtr spFrame = m_spResultData;
    if (NULL != spFrame)
    {
        BOOL bIsResultViewSet = FALSE;
        sc = spFrame->IsResultViewSet(&bIsResultViewSet);

        // The result view is set, clean it up.
        if (bIsResultViewSet)
            sc = m_spResultData->DeleteAllRsltItems();
    }

    m_fInCleanUp = FALSE;
}

void CAMCTreeView::CleanUp()
{
    TRACE_METHOD(CAMCTreeView, CleanUp);

    m_fInCleanUp = TRUE;

    m_spNodeManager = NULL;
    m_spHeaderCtrl = NULL;
    m_spResultData = NULL;
    m_spRsltImageList = NULL;
    m_spScopeData = NULL;

    m_fInCleanUp = FALSE;
}

void CAMCTreeView::OnDestroy()
{
    TRACE_METHOD(CAMCTreeView, OnDestroy);

    //CleanUp();

    CTreeView::OnDestroy();

    CleanUp();
}

HRESULT CAMCTreeView::CreateNodeManager(void)
{
    TRACE_METHOD(CAMCTreeView, CreateNodeManager);

    if (m_spScopeData)
        return S_OK;

    #if _MSC_VER >= 1100
    IFramePrivatePtr pIFrame(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
    #else
    IFramePrivatePtr pIFrame(CLSID_NodeInit, MMC_CLSCTX_INPROC);
    #endif
    ASSERT(pIFrame != NULL); if (pIFrame == NULL) return E_FAIL;

    m_spScopeData = pIFrame;
    m_spHeaderCtrl = pIFrame;

    if (m_spHeaderCtrl)
        pIFrame->SetHeader(m_spHeaderCtrl);

    m_spResultData = pIFrame;
    m_spRsltImageList = pIFrame;
    m_spNodeManager = pIFrame;

    pIFrame->SetComponentID(TVOWNED_MAGICWORD);

    return S_OK;
}

HTREEITEM CAMCTreeView::GetClickedNode()
{
    TV_HITTESTINFO tvhi;
    tvhi.pt = (POINT)GetCaretPos();
    tvhi.flags = TVHT_ONITEMLABEL;
    tvhi.hItem = 0;

    HTREEITEM htiClicked = HitTest(&tvhi);
    return htiClicked;
}


void CAMCTreeView::GetCountOfChildren(HTREEITEM hItem, LONG* pcChildren)
{
    TV_ITEM tvi;
    tvi.hItem = hItem;
    tvi.mask = TVIF_CHILDREN;
    tvi.cChildren = 0;

    GetItem(&tvi);
    *pcChildren = tvi.cChildren;
}


void CAMCTreeView::SetCountOfChildren(HTREEITEM hItem, int cChildren)
{
    TV_ITEM tvi;
    tvi.hItem = hItem;
    tvi.mask = TVIF_HANDLE | TVIF_CHILDREN;
    tvi.cChildren = cChildren;

    SetItem(&tvi);
}


HTREEITEM CAMCTreeView::FindNode(HTREEITEM hti, MTNODEID id)
{
    INodeCallback* pCallback = GetNodeCallback();
    static MTNODEID nID = -1;
    static HRESULT hr = S_OK;

    hr = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return NULL;

    if (nID == id)
        return hti;

    HTREEITEM htiTemp = GetChildItem(hti);

    if (htiTemp != NULL)
        htiTemp = FindNode(htiTemp, id);

    if (htiTemp == NULL)
    {
        htiTemp = GetNextSiblingItem(hti);

        if (htiTemp != NULL)
            htiTemp = FindNode(htiTemp, id);
    }

    return htiTemp;

}


HTREEITEM CAMCTreeView::FindSiblingItem(HTREEITEM hti, MTNODEID id)
{
    INodeCallback* pCallback = GetNodeCallback();
    if (!pCallback)
        return NULL;

    static MTNODEID nID = -1;
    static HRESULT hr = S_OK;

    while (hti != NULL)
    {
        hr = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
        if (FAILED(hr))
            return NULL;

        if (nID == id)
            return hti;

        hti = GetNextSiblingItem(hti);
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCTreeView::SelectNode
//
//  Synopsis:    Given path to a node, select the node. If bSelectExactNode
//               is false then walk the path as much as possible and select
//               the last node in the best matched path. If bSelectExactNode
//               is true then select the node if available else do nothing.
//
//  Arguments:   [pIDs]             - [in] Array of node-id's (the path)
//               [length]           - [in] length of the above array
//               [bSelectExactNode] - [in] select the exact node or not?
//
//  Returns:     SC, return ScFromMMC(IDS_NODE_NOT_FOUND) if select exact node is specified
//               and it cannot be selected
//
//--------------------------------------------------------------------
SC CAMCTreeView::ScSelectNode(MTNODEID* pIDs, int length, bool bSelectExactNode /*= false*/)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScSelectNode"));
    sc = ScCheckPointers(pIDs);
    if (sc)
        return sc;

    if (m_fInExpanding)
        return (sc);

    HTREEITEM hti = GetRootItem();
    sc = ScCheckPointers( (void*)hti, E_UNEXPECTED);
    if (sc)
        return sc;

    if (pIDs[0] != ROOTNODEID)
        return (sc = E_INVALIDARG);

    INodeCallback* pCallback = GetNodeCallback();
    sc = ScCheckPointers(pCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    MTNODEID nID = 0;
    sc = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
    if (sc)
        return sc;

    bool bExactNodeFound = false;

    for (int i=0; i<length; ++i)
    {
        if (pIDs[i] == nID)
            break;
    }

    for (++i; i < length; ++i)
    {
        if (GetChildItem(hti) == NULL)
            Expand(hti, TVE_EXPAND);

        hti = FindSiblingItem(GetChildItem(hti), pIDs[i]);

        if (hti == NULL)
            break;
    }

    if (length == i)
        bExactNodeFound = true;

    if (hti)
    {
        // If exact node is to be selected make sure we have walked through the entire path.
        if ( (bSelectExactNode) && (! bExactNodeFound) )
            return ScFromMMC(IDS_NODE_NOT_FOUND); // do not trace this error.

        if (GetSelectedItem() == hti)
            ScReselect();
        else
            SelectItem(hti);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::Expand
 *
 * PURPOSE: Expands a particular tree item. This is just a wrapper around the
 *          tree control's expand method, which allows items to be expanded
 *          without changing the visual appearance of the tree.
 *
 * PARAMETERS:
 *    HTREEITEM  hItem :
 *    UINT       nCode :
 *    bool       bExpandVisually :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL
CAMCTreeView::Expand(HTREEITEM hItem, UINT nCode, bool bExpandVisually)
{
   if( (nCode==TVE_EXPAND) && (!bExpandVisually) )
    {
        bool bExpand = true;
        // code repeated here from OnItemExpand - we just mimic the effect of TVN_ITEMEXPANDING.
        ExpandNode(hItem);

        INodeCallback* pCallback = GetNodeCallback();
        ASSERT(pCallback != NULL);
        HNODE hNode = GetItemNode(hItem);
        pCallback->Notify(hNode, NCLBK_SETEXPANDEDVISUALLY, bExpand, 0);

        // If item has no children remove the + sign
        if (GetChildItem(hItem) == NULL)
            SetButton(hItem, FALSE);
        return true;
    }
    else
       return Expand(hItem, nCode);
 }

/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::ExpandNode
 *
 * PURPOSE: Expands a particular node in the tree.
 *
 * PARAMETERS:
 *    MTNODEID* pIDs :
 *    int       length :
 *    bool      bExpand :
 *    bool      bExpandVisually : valid only if bExpand is true. If bExpandVisually
 *                                is true, the items appear in the tree. If false,
 *                                the tree appears unchanged, although items have been
 *                                added.
 *
 * RETURNS:
 *    HTREEITEM
 *
 *+-------------------------------------------------------------------------*/
HTREEITEM
CAMCTreeView::ExpandNode(MTNODEID* pIDs, int length, bool bExpand, bool bExpandVisually)
{
    HTREEITEM hti = GetRootItem();
    ASSERT(hti != NULL);
    ASSERT(pIDs[0] == ROOTNODEID);

    INodeCallback* pCallback = GetNodeCallback();
    if (!pCallback)
        return NULL;

    MTNODEID nID = 0;
    HRESULT hr = pCallback->GetMTNodeID(GetItemNode(hti), &nID);
    if (FAILED(hr))
        return NULL;

    for (int i=0; i<length; ++i)
    {
        if (pIDs[i] == nID)
            break;
    }

    for (++i; i < length; ++i)
    {
        if (GetChildItem(hti) == NULL)
            Expand(hti, TVE_EXPAND, bExpandVisually);

        hti = FindSiblingItem(GetChildItem(hti), pIDs[i]);

        if (hti == NULL)
            break;
    }

    if (hti)
        Expand(hti, bExpand ? TVE_EXPAND : TVE_COLLAPSE, bExpandVisually);

    return hti;
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnKeyDown
 *
 * WM_KEYDOWN handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
        case VK_DELETE:
            if (m_pAMCView->IsVerbEnabled(MMC_VERB_DELETE))
            {
                HTREEITEM hti = GetSelectedItem();
                if (hti != NULL)
                {
                    HNODE hNodeSel = GetItemNode(hti);
                    ASSERT(hNodeSel != NULL);

                    INodeCallback* pNC = GetNodeCallback();
                    ASSERT(pNC != NULL);
                    pNC->Notify(hNodeSel, NCLBK_DELETE, TRUE, 0);
                }
                return;
            }
            break;
    }

    CTreeView::OnKeyDown(nChar, nRepCnt, nFlags);
}


#ifdef DBG
void CAMCTreeView::DbgDisplayNodeName(HNODE hNode)
{
    ASSERT(hNode != NULL);

    INodeCallback* spCallback = GetNodeCallback();
    ASSERT(spCallback != NULL);

    tstring strName;
    HRESULT hr = spCallback->GetDisplayName(hNode, strName);

    ::MMCMessageBox( strName.data() );
}

void CAMCTreeView::DbgDisplayNodeName(HTREEITEM hti)
{
    DbgDisplayNodeName((HNODE)GetItemData(hti));
}

#endif

/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::OnSysKeyDown and CAMCTreeView::OnSysChar
 *
 * PURPOSE: Handle the WM_SYSKEYDOWN and WM_SYSCHAR messages. Note:
 *          VK_RETURN causes a beep if handled in WM_SYSKEYDOWN. And VK_LEFT and
 *          VK_RIGHT don't cause a WM_SYSCHAR. Thats why we need to handle these
 *          differently.
 *
 * PARAMETERS:
 *    UINT  nChar :
 *    UINT  nRepCnt :
 *    UINT  nFlags :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCTreeView::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
    case VK_LEFT:
    case VK_RIGHT:
    {
        CWnd* pwndParent = GetParent();
        ASSERT(pwndParent != NULL);
        if (pwndParent != NULL)
            pwndParent->SendMessage (WM_SYSKEYDOWN, nChar,
                                     MAKELPARAM (nRepCnt, nFlags));
        return;
    }

    default:
        break;
    }

    CTreeView::OnSysKeyDown(nChar, nRepCnt, nFlags);
}
void CAMCTreeView::OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnSysChar"));
    switch (nChar)
    {
    case VK_RETURN:
    {
        INodeCallback* pCallback = GetNodeCallback();
        CAMCView*      pAMCView  = GetAMCView();
        sc = ScCheckPointers(pAMCView, pCallback, E_UNEXPECTED);
        if (sc)
            return;

        if (! pAMCView->IsVerbEnabled(MMC_VERB_PROPERTIES))
            return;

        HTREEITEM hti = GetSelectedItem();
        if (!hti)
            break;

        HNODE hNode = (HNODE)GetItemData(hti);
        if (hNode != 0)
            pCallback->Notify(hNode, NCLBK_PROPERTIES, TRUE, 0);

        return;
    }

    default:
        break;
    }

    CTreeView::OnSysChar(nChar, nRepCnt, nFlags);
}


BOOL CAMCTreeView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (CTreeView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view didn't handle it, give parent view a chance
    if (m_pAMCView != NULL)
        return static_cast<CWnd*>(m_pAMCView)->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    else
        return FALSE;
}

void CAMCTreeView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    switch (lHint)
    {
    case VIEW_UPDATE_DELETE_EMPTY_VIEW:
        {
            if (!m_pAMCView)
            {
                CWnd* pWnd = GetParent();
                ASSERT(pWnd != NULL);
                m_pAMCView = reinterpret_cast<CAMCView*>(pWnd);
            }

            ASSERT(m_pAMCView != NULL);
            if (m_pAMCView)
                m_pAMCView->OnDeleteEmptyView();
        }
        break;

    default:
        break;
    }
}

int CAMCTreeView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
    /*------------------------------------------------------------------------*/
    /* Short out the WM_MOUSEACTIVATE here to prevent default processing,     */
    /* which is to send the message on to succeeding parent windows until     */
    /* one answers the message.  In our case, it goes all the way up to       */
    /* the main frame, which invariably decides to activate.  This is a       */
    /* problem for two reasons:                                               */
    /*                                                                        */
    /* 1.  On the way back down from the main frame, the message passes       */
    /*     through CAMCView, which lets CView::OnMouseActivate do the         */
    /*     work.  CView::OnMouseActivate will set itself (CAMCView) as        */
    /*     the active view, which in turn causes focus to be set to           */
    /*     the view.  CAMCView never wants the focus, since it is just        */
    /*     a frame for the scope and result panes, so it will deflect         */
    /*     the activation to the scope pane (CAMCTreeView) in                 */
    /*     CAMCView::OnSetFocus, which is where we want it to be.  If         */
    /*     we short out the processing here, we avoid excessive focus         */
    /*     churn.  It is essential that CAMCTreeView::OnSetFocus set          */
    /*     itself as the active view to keep the bookkeeping straight.        */
    /*                                                                        */
    /* 2.  If we don't short out here and avoid excessive focus churn,        */
    /*     we have a problem with sometimes erroneously entering rename       */
    /*     mode when the tree isn't active and the user clicks (once) on      */
    /*     the selected item.  An ordinary activation sequence goes like      */
    /*     this:  WM_MOUSEACTIVATE, WM_xBUTTONDOWN, WM_SETFOUS -- all to      */
    /*     the tree view.  The tree's button down processing doesn't enter    */
    /*     the label edit (i.e. rename) sequence because it recognizes        */
    /*     that it doesn't have the focus when the click happens.  When       */
    /*     the tree view is a CView, as in this case, CView::OnMouseActivate  */
    /*     sets the focus to the tree view, causing the activation sequence   */
    /*     to look like this:  WM_MOUSEACTIVATE, WM_SETFOCUS, WM_xBUTTONDOWN. */
    /*     Now the tree's button down processing sees that the tree has       */
    /*     the focus, so it enters label edit mode.  BUG!  Shorting out       */
    /*     here (and relying on CAMCTreeView::OnSetFocus to properly activate */
    /*     the view) fixes all that.                                          */
    /*------------------------------------------------------------------------*/

    return (MA_ACTIVATE);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnSetFocus
 *
 * WM_SETFOCUS handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnSetFocus(CWnd* pOldWnd)
{
    Trace(tagTree, TEXT("OnSetFocus"));

    /*
     * if this view has the focus, it should be the active view
     */
    GetParentFrame()->SetActiveView (this);

    CTreeView::OnSetFocus(pOldWnd);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnKillFocus
 *
 * WM_KILLFOCUS handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnKillFocus(CWnd* pNewWnd)
{
    Trace(tagTree, TEXT("OnKillFocus"));

    CTreeView::OnKillFocus(pNewWnd);

    /*
     * Bug 114948 (from the "Windows NT Bugs" database, aka "the overlapping
     * rectangle problem"):  The tree control has code to invalidate the
     * selected item when focus is lost.  If we have a temp selection, we've
     * made a temporary item appear selected by fiddling with TVIS_SELECTED
     * states (see ScSet/RemoveTempSelection). We need to do it that way
     * instead of sending TVM_SELECTITEM so we don't get unwanted
     * TVN_SELCHANGED notifications, but it has the side effect of fooling
     * the tree control's WM_KILLFOCUS handler into invalidating the non-temp
     * selected item instead of the item that is really showing selection, the
     * temp item.
     *
     * This bug was originally fixed with a sledgehammer, specifically by
     * forcing the entire main frame and all of its children to be totally
     * redrawn after displaying any context menu.  This caused bug 139541
     * (in the "Windows Bugs" database).
     *
     * A much more surgical fix to 114948, which also avoids 139541, is to
     * manually invalidate the temporarily selected item.  It's important
     * that we do this after calling the base class so it will be redrawn
     * in the "we don't have the focus" color (usually gray), rather than
     * the standard selection color.
     */
    if (IsTempSelectionActive())
    {
        CRect rectItem;
        GetItemRect (GetTempSelectedItem(), rectItem, false);
        RedrawWindow (rectItem);
    }
}


void CAMCTreeView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnActivateView"));

    #ifdef DBG
    Trace(tagTree, _T("TreeView::OnActivateView (%s, pAct=0x%08x, pDeact=0x%08x))\n"),
         (bActivate) ? _T("true") : _T("false"), pActivateView, pDeactiveView);
    #endif

    if ( (pActivateView != pDeactiveView) &&
         (bActivate) )
    {
        sc = ScFireEvent(CTreeViewObserver::ScOnTreeViewActivated);
        if (sc)
            sc.TraceAndClear();
    }

    CTreeView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}


/*+-------------------------------------------------------------------------*
 * CAMCTreeView::OnCustomDraw
 *
 * NM_CUSTOMDRAW handler for CAMCTreeView.
 *--------------------------------------------------------------------------*/

void CAMCTreeView::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult)
{
    NMCUSTOMDRAW* pnmcd = reinterpret_cast<NMCUSTOMDRAW *>(pNMHDR);
    ASSERT (CWnd::FromHandle (pnmcd->hdr.hwndFrom) == this);

    *pResult = m_FontLinker.OnCustomDraw (pnmcd);
}


/*+-------------------------------------------------------------------------*
 * CTreeFontLinker::GetItemText
 *
 *
 *--------------------------------------------------------------------------*/

std::wstring CTreeFontLinker::GetItemText (NMCUSTOMDRAW* pnmcd) const
{
    USES_CONVERSION;
    HTREEITEM  hItem = reinterpret_cast<HTREEITEM>(pnmcd->dwItemSpec);
    CTreeCtrl& tc    = m_pTreeView->GetTreeCtrl();

    return (std::wstring (T2CW (tc.GetItemText (hItem))));
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCTreeView::ScGetTreeItemIconInfo
//
//  Synopsis:    Get the given node's small icon.
//
//  Arguments:   [hNode] - for which info is needed.
//               [phIcon] - [out], ptr to HICON.
//
//  Note:        Caller calls DestroyIcon on the HICON returned.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCTreeView::ScGetTreeItemIconInfo(HNODE hNode, HICON *phIcon)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScGetTreeItemIconInfo"));
    sc = ScCheckPointers(hNode, phIcon);
    if (sc)
        return sc;

    INodeCallback* spNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(spNodeCallBack, m_pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the index.
    int nImage = -1;
    int nSelectedImage = -1;
    sc = spNodeCallBack->GetImages(hNode, &nImage, &nSelectedImage);
    if (sc)
        return sc;

    // Get the imagelist.
    HIMAGELIST hImageList = NULL;
    hImageList = TreeView_GetImageList(GetSafeHwnd(), TVSIL_NORMAL);
    if (! hImageList)
        return (sc = E_FAIL);

    *phIcon = ImageList_GetIcon(hImageList, nImage, ILD_TRANSPARENT);
    if (!*phIcon)
        return (sc = E_FAIL);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCTreeView::ScRenameScopeNode
 *
 * PURPOSE: put the specified scope node into rename mode.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCTreeView::ScRenameScopeNode(HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScRenameScopeNode"));

    if(!IsWindowVisible())
        return (sc = E_FAIL);

    HTREEITEM hti = NULL;
    sc = m_treeMap.ScGetHTreeItemFromHMTNode(hMTNode,  &hti);
    if(sc)
        return sc;

    // must have the focus to rename
    if (::GetFocus() != m_hWnd)
        SetFocus();

    if(NULL==EditLabel(hti))
        return (sc = E_FAIL); // if for any reason the operation failed, return an error

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\vwtrack.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      vwtrack.cpp
 *
 *  Contents:  Implementation file for CViewTracker
 *
 *  History:   01-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "windowsx.h"
#include "vwtrack.h"
#include "subclass.h"       // for CSubclasser

IMPLEMENT_DYNAMIC (CViewTracker, CObject)

// Tracker subclasser base class
class CTrackingSubclasserBase : public CSubclasser
{
public:
    CTrackingSubclasserBase(CViewTracker*, HWND);
    virtual ~CTrackingSubclasserBase();

    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn) = 0;

protected:
    HWND          const m_hwnd;
    CViewTracker* const m_pTracker;
};


// Focus window subclasser
class CFocusSubclasser : public CTrackingSubclasserBase
{
public:
    CFocusSubclasser(CViewTracker*, HWND);
    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn);
};

// View window subclasser
class CViewSubclasser : public CTrackingSubclasserBase
{
public:
    CViewSubclasser(CViewTracker*, HWND);
    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn);
};

// Frame window subclasser
class CFrameSubclasser : public CTrackingSubclasserBase
{
public:
    CFrameSubclasser(CViewTracker*, HWND);
    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                              LPARAM& lParam, bool& fPassMessageOn);
};


/*+-------------------------------------------------------------------------*
 * IsFullWindowDragEnabled
 *
 * Returns true if the user has enabled the "Show window contents while
 * dragging" on the Effects page of the Display Properties property sheet.
 *--------------------------------------------------------------------------*/

static bool IsFullWindowDragEnabled ()
{
	BOOL fEnabled;
	if (!SystemParametersInfo (SPI_GETDRAGFULLWINDOWS, 0, &fEnabled, 0))
		return (false);

	return (fEnabled != FALSE);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::CViewTracker
 *
 * CViewTracker ctor.  This function is private so we can control how
 * CViewTrackers are allocated.  We want to insure that they're allocated
 * from the heap so it's safe to "delete this".
 *--------------------------------------------------------------------------*/

CViewTracker::CViewTracker (TRACKER_INFO& TrackerInfo)
	:	m_fFullWindowDrag			(IsFullWindowDragEnabled()),
		m_fRestoreClipChildrenStyle	(false),
		m_Info						(TrackerInfo),
        m_dc						(PrepTrackedWindow (TrackerInfo.pView)),
        m_pFocusSubclasser			(NULL),
        m_pViewSubclasser			(NULL),
        m_pFrameSubclasser			(NULL),
		m_lOriginalTrackerLeft		(TrackerInfo.rectTracker.left)
{
	DECLARE_SC (sc, _T("CViewTracker::CViewTracker"));
	sc = ScCheckPointers (m_Info.pView);
	if (sc)
		sc.Throw();

    ASSERT_VALID (m_Info.pView);

    // subclass the focus window to catch VK_ESCAPE
    HWND hwndFocus = ::GetFocus();

    if (hwndFocus != NULL)
	{
        m_pFocusSubclasser = new CFocusSubclasser (this, hwndFocus);
		if (m_pFocusSubclasser == NULL)
			AfxThrowMemoryException();
	}

    // subclass view window to get mouse events
    ASSERT(IsWindow(m_Info.pView->m_hWnd));
    m_pViewSubclasser = new CViewSubclasser (this, m_Info.pView->m_hWnd);
	if (m_pViewSubclasser == NULL)
		AfxThrowMemoryException();

    // subclass the frame window to catch WM_CANCELMODE
    HWND hwndFrame = m_Info.pView->GetTopLevelFrame()->GetSafeHwnd();

    if ((hwndFrame != NULL))
	{
        m_pFrameSubclasser = new CFrameSubclasser (this, hwndFrame);
		if (m_pFrameSubclasser == NULL)
			AfxThrowMemoryException();
	}

    // Draw initial tracker bar
    DrawTracker(m_Info.rectTracker);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::StartTracking
 *
 * CViewTracker factory.  It allocates CViewTrackers from the heap.
 *--------------------------------------------------------------------------*/

bool CViewTracker::StartTracking (TRACKER_INFO* pInfo)
{
    ASSERT(pInfo != NULL);

    CViewTracker* pTracker = NULL;

    try
    {
        /*
         * This doesn't leak. CViewTracker ctor fills in a back-pointer
         * that tracks the new object.  pTracker is also not dereferenced
		 * after allocation, so it doesn't need to be checked.
         */
        pTracker = new CViewTracker(*pInfo);
    }
    catch (CException* pe)
    {
        pe->Delete();
    }
    catch (...)
    {
    }

    return (pTracker != NULL);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::StopTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CViewTracker::StopTracking (BOOL bAcceptChange)
{
    // unsubclass the windows we subclassed
    delete m_pFrameSubclasser;
    delete m_pFocusSubclasser;
    delete m_pViewSubclasser;

    // erase tracker rectangle
    DrawTracker (m_Info.rectTracker);

    // undo changes we made to the view
    UnprepTrackedWindow (m_Info.pView);

	/*
	 * if we're continuously resizing, but the user pressed Esc, restore
	 * the original size
	 */
	if (m_fFullWindowDrag && !bAcceptChange)
	{
		m_Info.rectTracker.left = m_lOriginalTrackerLeft;
		bAcceptChange = true;
	}

    // notify client through callback function
    ASSERT(m_Info.pCallback != NULL);
    (*m_Info.pCallback)(&m_Info, bAcceptChange, m_fFullWindowDrag);

    delete this;
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::Track
 *
 * Mouse movement handler for CViewTracker.
 *--------------------------------------------------------------------------*/

void CViewTracker::Track(CPoint pt)
{
    // if we lost the capture, terminate tracking
    if (CWnd::GetCapture() != m_Info.pView)
	{
		Trace (tagSplitterTracking, _T("Stopping tracking, lost capture)"));
        StopTracking (false);
	}

    // Apply movement limits
    //  if outside area and pane hiding allowed, snap to area edge
    //  else if outside bounds, snap to bounds edge
    if (pt.x < m_Info.rectArea.left && m_Info.bAllowLeftHide)
        pt.x = m_Info.rectArea.left;

    else if (pt.x < m_Info.rectBounds.left)
        pt.x = m_Info.rectBounds.left;

    else if (pt.x > m_Info.rectArea.right && m_Info.bAllowRightHide)
        pt.x = m_Info.rectArea.right;

    else if (pt.x > m_Info.rectBounds.right)
        pt.x = m_Info.rectBounds.right;

    // Erase and redraw tracker rect if moved
    if (pt.x != m_Info.rectTracker.left)
    {
        DrawTracker (m_Info.rectTracker);
        m_Info.rectTracker.OffsetRect (pt.x - m_Info.rectTracker.left, 0);
		Trace (tagSplitterTracking, _T("new tracker x=%d"), m_Info.rectTracker.left);

		/*
		 * if full window drag is enabled, tell the callback the size has
		 * changed
		 */
		if (m_fFullWindowDrag)
			(*m_Info.pCallback)(&m_Info, true, true);

        DrawTracker (m_Info.rectTracker);
    }
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::DrawTracker
 *
 *
 *--------------------------------------------------------------------------*/

void CViewTracker::DrawTracker (CRect& rect) const
{
	/*
	 * we don't draw a tracker bar if we're doing full window drag
	 */
	if (m_fFullWindowDrag)
		return;

    ASSERT (!rect.IsRectEmpty());
    ASSERT ((m_Info.pView->GetStyle() & WS_CLIPCHILDREN) == 0);

    // invert the brush pattern (looks just like frame window sizing)
    m_dc.PatBlt (rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::PrepTrackedWindow
 *
 * Prepares the tracked window prior to obtaining a DC for it.
 *--------------------------------------------------------------------------*/

CWnd* CViewTracker::PrepTrackedWindow (CWnd* pView)
{
    // make sure no updates are pending
    pView->UpdateWindow ();

    // steal capture (no need to steal focus)
    pView->SetCapture();

    // we need to draw in children, so remove clip-children while we track
	if (!m_fFullWindowDrag && (pView->GetStyle() & WS_CLIPCHILDREN))
	{
		pView->ModifyStyle (WS_CLIPCHILDREN, 0);
		m_fRestoreClipChildrenStyle = true;
	}

    return (pView);
}


/*+-------------------------------------------------------------------------*
 * CViewTracker::UnprepTrackedWindow
 *
 * "Unprepares" the tracked window prior to obtaining a DC for it.
 *--------------------------------------------------------------------------*/

void CViewTracker::UnprepTrackedWindow (CWnd* pView)
{
	if (m_fRestoreClipChildrenStyle)
		pView->ModifyStyle (0, WS_CLIPCHILDREN);

    ReleaseCapture();
}


/*+-------------------------------------------------------------------------*
 * CTrackingSubclasserBase::CTrackingSubclasserBase
 *
 *
 *--------------------------------------------------------------------------*/

CTrackingSubclasserBase::CTrackingSubclasserBase (CViewTracker* pTracker, HWND hwnd)
    :   m_hwnd     (hwnd),
        m_pTracker (pTracker)
{
    GetSubclassManager().SubclassWindow (m_hwnd, this);
}


/*+-------------------------------------------------------------------------*
 * CTrackingSubclasserBase::~CTrackingSubclasserBase
 *
 *
 *--------------------------------------------------------------------------*/

CTrackingSubclasserBase::~CTrackingSubclasserBase ()
{
    GetSubclassManager().UnsubclassWindow (m_hwnd, this);
}


/*+-------------------------------------------------------------------------*
 * CFocusSubclasser::CFocusSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CFocusSubclasser::CFocusSubclasser (CViewTracker* pTracker, HWND hwnd)
    :   CTrackingSubclasserBase (pTracker, hwnd)
{
}


/*+-------------------------------------------------------------------------*
 * CFrameSubclasser::CFrameSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CFrameSubclasser::CFrameSubclasser (CViewTracker* pTracker, HWND hwnd)
    :   CTrackingSubclasserBase (pTracker, hwnd)
{
}

/*+-------------------------------------------------------------------------*
 * CViewSubclasser::CViewSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CViewSubclasser::CViewSubclasser (CViewTracker* pTracker, HWND hwnd)
    :   CTrackingSubclasserBase (pTracker, hwnd)
{
}


/*+-------------------------------------------------------------------------*
 * CFocusSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CFocusSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    if (((msg == WM_CHAR) && (wParam == VK_ESCAPE)) ||
         (msg == WM_KILLFOCUS))
    {
#ifdef DBG
		if (msg == WM_CHAR)
			Trace (tagSplitterTracking, _T("Stopping tracking, user pressed Esc"));
		else
			Trace (tagSplitterTracking, _T("Stopping tracking, lost focus to hwnd=0x%08x"), ::GetFocus());
#endif

        m_pTracker->StopTracking (false);
        fPassMessageOn = false;
    }

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CFrameSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CFrameSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    if (msg == WM_CANCELMODE)
	{
		Trace (tagSplitterTracking, _T("Stopping tracking, got WM_CANCELMODE"));
        m_pTracker->StopTracking (false);
	}

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CViewSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CViewSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    switch (msg)
    {
        case WM_MOUSEMOVE:
        {
            CPoint pt(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            m_pTracker->Track (pt);
        }
        break;

		case WM_LBUTTONUP:
			Trace (tagSplitterTracking, _T("Stopping tracking, accepting new position"));
            m_pTracker->StopTracking (true);
            break;
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\vwtrack.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      vwtrack.h
 *
 *  Contents:  Interface file for CViewTracker
 *
 *  History:   01-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef VWTRACK_H
#define VWTRACK_H
#pragma once

#include "amcview.h"

class CFocusSubclasser;
class CFrameSubclasser;
class CViewSubclasser;
struct TRACKER_INFO;

typedef void (CALLBACK *TRACKER_CALLBACK)(TRACKER_INFO* pTrackerInfo, bool bAccept, bool bSyncLayout);

/*
 * This structure is copied in the CViewTracker using its (default) copy
 * constructor.  If you add any members for which member-wise copy is not
 * appropriate, you *must* define a copy constructor for this structure.
 */
typedef struct TRACKER_INFO
{
    CView*    pView;            // View to manage
    CRect     rectArea;         // Total area available
    CRect     rectTracker;      // Current tracker position
    CRect     rectBounds;       // Tracker movement bounds
    BOOL      bAllowLeftHide;   // Can left pane be hidden
    BOOL      bAllowRightHide;  // Can right pane be hidden
    LONG_PTR  lUserData;        // User data
    TRACKER_CALLBACK pCallback; // Tracking completion callback
} TRACKER_INFO;


class CHalftoneClientDC : public CClientDC
{
public:
    CHalftoneClientDC (CWnd* pwnd)
        :   CClientDC (pwnd), m_hBrush(NULL)
        { 
            CBrush *pBrush = SelectObject (GetHalftoneBrush ()); 
            if (pBrush != NULL)
                m_hBrush = *pBrush;
        }

    ~CHalftoneClientDC ()
        { 
            if (m_hBrush != NULL)
                SelectObject ( CBrush::FromHandle(m_hBrush) ); 
        }

private:
    HBRUSH  m_hBrush;
};

class CViewTracker : public CObject
{
    DECLARE_DYNAMIC (CViewTracker)

    // private ctor, use StartTracking to create one
    CViewTracker (TRACKER_INFO& TrackerInfo);

    // private dtor
    ~CViewTracker() {};

public:
    static bool StartTracking (TRACKER_INFO* pTrackerInfo);
    void StopTracking (BOOL fAcceptNewPosition);
    void Track(CPoint pt);

private:
    void DrawTracker (CRect& rect) const;
    CWnd* PrepTrackedWindow (CWnd* pwnd);
    void UnprepTrackedWindow (CWnd* pwnd);

private:
	/*
	 * m_fFullWindowDrag must be first, so it will be initialized first;
	 * other member initializers will use m_fFullWindowDrag's setting
	 */
	const bool					m_fFullWindowDrag;

	bool						m_fRestoreClipChildrenStyle;
    TRACKER_INFO                m_Info;
    CHalftoneClientDC mutable   m_dc;
    CFocusSubclasser *          m_pFocusSubclasser;
    CViewSubclasser  *          m_pViewSubclasser;
    CFrameSubclasser *          m_pFrameSubclasser;
	const LONG					m_lOriginalTrackerLeft;

};  /* class CViewTracker */


#endif /* VWTRACK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\webctrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       webctrl.h
//
//--------------------------------------------------------------------------

// WebCtrl.h : header file
//

#ifndef __WEBCTRL_H__
#define __WEBCTRL_H__

#include "ocxview.h"

/////////////////////////////////////////////////////////////////////////////
// CAMCWebViewCtrl window

class CAMCWebViewCtrl : public COCXHostView
{
public:
    typedef COCXHostView BaseClass;

    enum
    {
        WS_HISTORY    = 0x00000001,     // integrate with history
        WS_SINKEVENTS = 0x00000002,     // act as sink for DIID_DWebBrowserEvents
    };

// Construction
public:
    CAMCWebViewCtrl();
    DECLARE_DYNCREATE(CAMCWebViewCtrl)

    // attributes
private:

    CMMCAxWindow        m_wndAx;                // This ActiveX control will host the web browser.
    IWebBrowser2Ptr     m_spWebBrowser2;        // the interface implemented by the web browser.
    DWORD               m_dwAdviseCookie;       // the connection ID established by the web browser with the event sink.
    CComPtr<IWebSink>   m_spWebSink;

protected:
    virtual CMMCAxWindow * GetAxWindow()           {return &m_wndAx;}

private:
    SC  ScCreateWebBrowser();

    bool IsHistoryEnabled() const;
    bool IsSinkEventsEnabled() const;

// Operations
public:
   void Navigate(LPCTSTR lpszWebSite, LPCTSTR lpszFrameTarget);
   void Back();
   void Forward();
   void Refresh();
   void Stop();
   LPUNKNOWN GetIUnknown(void);
   SC ScGetReadyState(READYSTATE& state);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCWebViewCtrl)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    //}}AFX_VIRTUAL


// Implementation
public:
    virtual ~CAMCWebViewCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CAMCWebViewCtrl)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#include "webctrl.inl"

#endif //__WEBCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\webctrl.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      webctrl.inl
 *
 *  Contents:  Inline functions for CAMCWebViewCtrl
 *
 *  History:   15-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*+-------------------------------------------------------------------------*
 * CAMCWebViewCtrl::IsHistoryEnabled 
 *
 * Returns true if the window has the WS_HISTORY style, false otherwise.
 *--------------------------------------------------------------------------*/

inline bool CAMCWebViewCtrl::IsHistoryEnabled () const
{
    return ((GetStyle() & WS_HISTORY) != 0);
}


/*+-------------------------------------------------------------------------*
 * CAMCWebViewCtrl::IsSinkEventsEnabled 
 *
 * Returns true if the window has the WS_SINKEVENTS style, false otherwise.
 *--------------------------------------------------------------------------*/

inline bool CAMCWebViewCtrl::IsSinkEventsEnabled () const
{
    return ((GetStyle() & WS_SINKEVENTS) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\wrapper.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      wrapper.cpp
 *
 *  Contents:  Implementation file for simple wrapper classes
 *
 *  History:   02-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "wrapper.h"


/*+-------------------------------------------------------------------------*
 * CAccel::CAccel
 *
 *
 *--------------------------------------------------------------------------*/

CAccel::CAccel (HACCEL hAccel /* =NULL */)
    :
    m_hAccel (hAccel)
{
}

CAccel::CAccel (LPACCEL paccl, int cEntries)
    :
    m_hAccel (::CreateAcceleratorTable (paccl, cEntries))
{
}


/*+-------------------------------------------------------------------------*
 * CAccel::~CAccel
 *
 *
 *--------------------------------------------------------------------------*/

CAccel::~CAccel ()
{
    DestroyAcceleratorTable ();
}


/*+-------------------------------------------------------------------------*
 * CAccel::CreateAcceleratorTable
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::CreateAcceleratorTable (LPACCEL paccl, int cEntries)
{
    DestroyAcceleratorTable ();
    ASSERT (m_hAccel == NULL);
    if(paccl != NULL)
        m_hAccel = ::CreateAcceleratorTable (paccl, cEntries);

    return (m_hAccel != NULL);
}


/*+-------------------------------------------------------------------------*
 * CAccel::CopyAcceleratorTable
 *
 *
 *--------------------------------------------------------------------------*/

int CAccel::CopyAcceleratorTable (LPACCEL paccl, int cEntries) const
{
    return (::CopyAcceleratorTable (m_hAccel, paccl, cEntries));
}


/*+-------------------------------------------------------------------------*
 * CAccel::DestroyAcceleratorTable
 *
 *
 *--------------------------------------------------------------------------*/

void CAccel::DestroyAcceleratorTable ()
{
    if (m_hAccel != NULL)
    {
        ::DestroyAcceleratorTable (m_hAccel);
        m_hAccel = NULL;
    }
}


/*+-------------------------------------------------------------------------*
 * CAccel::LoadAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::LoadAccelerators (int nAccelID)
{
    return (LoadAccelerators (MAKEINTRESOURCE (nAccelID)));
}


/*+-------------------------------------------------------------------------*
 * CAccel::LoadAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::LoadAccelerators (LPCTSTR pszAccelName)
{
    HINSTANCE hInst = AfxFindResourceHandle (pszAccelName, RT_ACCELERATOR);
    return (LoadAccelerators (hInst, pszAccelName));
}


/*+-------------------------------------------------------------------------*
 * CAccel::LoadAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::LoadAccelerators (HINSTANCE hInst, LPCTSTR pszAccelName)
{
    DestroyAcceleratorTable ();
    ASSERT (m_hAccel == NULL);
    m_hAccel = ::LoadAccelerators (hInst, pszAccelName);

    return (m_hAccel != NULL);
}


/*+-------------------------------------------------------------------------*
 * CAccel::TranslateAccelerator
 *
 *
 *--------------------------------------------------------------------------*/

bool CAccel::TranslateAccelerator (HWND hwnd, LPMSG pmsg) const
{
    return ((m_hAccel != NULL) &&
            ::TranslateAccelerator (hwnd, m_hAccel, pmsg));
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::CDeferWindowPos
 *
 *
 *--------------------------------------------------------------------------*/

CDeferWindowPos::CDeferWindowPos (
    int     cWindows,
    bool    fSynchronousPositioningForDebugging)
    :   m_hdwp (NULL),
        m_fSynchronousPositioningForDebugging (fSynchronousPositioningForDebugging)
{
	Begin (cWindows);
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::~CDeferWindowPos
 *
 *
 *--------------------------------------------------------------------------*/

CDeferWindowPos::~CDeferWindowPos ()
{
    if (m_hdwp)
        End();
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::Begin
 *
 *
 *--------------------------------------------------------------------------*/

bool CDeferWindowPos::Begin (int cWindows)
{
    ASSERT (m_hdwp == NULL);
    ASSERT (cWindows > 0);

    m_hdwp = ::BeginDeferWindowPos (cWindows);
    return (m_hdwp != NULL);
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::End
 *
 *
 *--------------------------------------------------------------------------*/

bool CDeferWindowPos::End ()
{
    ASSERT (m_hdwp != NULL);
    HDWP hdwp = m_hdwp;
    m_hdwp = NULL;

	if ( hdwp == NULL )
		return false;

    return (::EndDeferWindowPos (hdwp) != 0);
}


/*+-------------------------------------------------------------------------*
 * CDeferWindowPos::AddWindow
 *
 *
 *--------------------------------------------------------------------------*/

bool CDeferWindowPos::AddWindow (
    const CWnd*     pwnd,
    const CRect&    rect,
    DWORD           dwFlags,
    const CWnd*     pwndInsertAfter /* =NULL */)
{
    ASSERT (IsWindow (pwnd->GetSafeHwnd()));

    if (pwndInsertAfter == NULL)
        dwFlags |= SWP_NOZORDER;

	if ( m_hdwp == NULL )
		return false;

    m_hdwp = ::DeferWindowPos (m_hdwp,
                               pwnd->GetSafeHwnd(),
                               pwndInsertAfter->GetSafeHwnd(),
                               rect.left, rect.top,
                               rect.Width(), rect.Height(),
                               dwFlags);

#ifdef DBG
    if (m_fSynchronousPositioningForDebugging)
    {
        End ();
        Begin (1);
    }
#endif

    return (m_hdwp != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\webctrl.cpp ===
// WebCtrl.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amcwebviewctrl.cpp
//
//  Contents:  AMC Private web view control hosting IE 3.x and 4.x
//
//  History:   16-Jul-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "amc.h"
#include "amcview.h"
#include "histlist.h"
#include "exdisp.h" // for the IE dispatch interfaces.
#include "websnk.h"
#include "evtsink.h"
#include "WebCtrl.h"
#include "atliface.h"
#include "mainfrm.h"
#include "statbar.h"

#ifdef DBG
CTraceTag tagVivekDefaultWebContextMenu (_T("Vivek"), _T("Use default web context menu"));
#endif

/*+-------------------------------------------------------------------------*
 * class CDocHostUIHandlerDispatch
 *
 *
 * PURPOSE: Implements the interface required by ATL to find out about
 *          UI hosting.
 *
 *+-------------------------------------------------------------------------*/
class CDocHostUIHandlerDispatch :
    public IDocHostUIHandlerDispatch,
    public CComObjectRoot
{
private:
    ViewPtr  m_spView; // a pointer to the parent AMCView's dispatch interface

public:
    BEGIN_COM_MAP(CDocHostUIHandlerDispatch)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDocHostUIHandlerDispatch)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CDocHostUIHandlerDispatch)

    // initialization
    SC  ScInitialize(PVIEW pView)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::ScInitialize"));

        sc = ScCheckPointers(pView);
        if(sc)
            return sc;

        // should not initialize twice
        if(m_spView)
            return (sc=E_UNEXPECTED);

        m_spView = pView;

        return sc;
    }

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)                          {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo) {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
        LCID lcid, DISPID* rgdispid)                                    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)                          {return E_NOTIMPL;}



    // IDocHostUIHandlerDispatch

    STDMETHODIMP ShowContextMenu (DWORD dwID, DWORD x, DWORD y, IUnknown* pcmdtReserved,
                                  IDispatch* pdispReserved, HRESULT* dwRetVal);
    STDMETHODIMP GetHostInfo( DWORD* pdwFlags, DWORD* pdwDoubleClick);

    // a helper function for all the methods that return S_FALSE;
    SC ScFalse(HRESULT* dwRetVal)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::ScFalse"));
        sc = ScCheckPointers(dwRetVal);
        if(sc)
            return sc.ToHr();

        *dwRetVal = S_FALSE;

        return sc.ToHr();
    }

    STDMETHODIMP ShowUI(DWORD dwID, IUnknown* pActiveObject, IUnknown* pCommandTarget,
                         IUnknown* pFrame, IUnknown* pDoc, HRESULT* dwRetVal)
                                                               {return ScFalse(dwRetVal).ToHr();}
    STDMETHODIMP HideUI()                                      {return S_OK;}
    STDMETHODIMP UpdateUI()                                    {return S_OK;}
    STDMETHODIMP EnableModeless(VARIANT_BOOL fEnable)          {return E_NOTIMPL;}
    STDMETHODIMP OnDocWindowActivate(VARIANT_BOOL fActivate)   {return S_OK;}
    STDMETHODIMP OnFrameWindowActivate(VARIANT_BOOL fActivate) {return S_OK;}
    STDMETHODIMP ResizeBorder(long left, long top, long right,
                               long bottom, IUnknown* pUIWindow,
                               VARIANT_BOOL fFrameWindow)       {return E_NOTIMPL;}
    STDMETHODIMP TranslateAccelerator( DWORD hWnd, DWORD nMessage,
                                        DWORD wParam, DWORD lParam,
                                        BSTR bstrGuidCmdGroup,
                                        DWORD nCmdID,
                                        HRESULT* dwRetVal)      {return ScFalse(dwRetVal).ToHr();}

    STDMETHODIMP GetOptionKeyPath( BSTR* pbstrKey, DWORD dw)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::GetOptionKeyPath"));
        sc = ScCheckPointers(pbstrKey);
        if(sc)
            return sc.ToHr();

        *pbstrKey = NULL;

        return S_FALSE;
    }
    STDMETHODIMP GetDropTarget( IUnknown* pDropTarget,  IUnknown** ppDropTarget)    {return E_NOTIMPL;}
    STDMETHODIMP GetExternal( IDispatch **ppDispatch) // returns a pointer to the view.
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::GetExternal"));

        // set up the connection to the external object.
        sc = ScCheckPointers(m_spView, E_UNEXPECTED);
        if(sc)
            return sc.ToHr();

        *ppDispatch = m_spView;
        (*ppDispatch)->AddRef(); // addref for the client.

        return sc.ToHr();
    }

    STDMETHODIMP TranslateUrl( DWORD dwTranslate, BSTR bstrURLIn, BSTR* pbstrURLOut)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::TranslateUrl"));

        sc = ScCheckPointers(pbstrURLOut);
        if(sc)
            return sc.ToHr();

        *pbstrURLOut = NULL;
        return S_FALSE;
    }

    STDMETHODIMP FilterDataObject(IUnknown*pDO, IUnknown**ppDORet)
    {
        DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::FilterDataObject"));

        sc = ScCheckPointers(ppDORet);
        if(sc)
            return sc.ToHr();

        *ppDORet = NULL;
        return S_FALSE;
    }
};


/*+-------------------------------------------------------------------------*
 * ShouldShowDefaultWebContextMenu
 *
 * Returns true if we should display the default MSHTML context menu,
 * false if we want to display our own (or suppress it altogether)
 *--------------------------------------------------------------------------*/

bool IsDefaultWebContextMenuDesired ()
{
#ifdef DBG
	return (tagVivekDefaultWebContextMenu.FAny());
#else
	return (false);
#endif
}


/*+-------------------------------------------------------------------------*
 *
 * CDocHostUIHandlerDispatch::ShowContextMenu
 *
 * PURPOSE: Handles IE's hook to display context menus. Does not do anything
 *          and returns to IE with the code to not display menus.
 *
 * PARAMETERS:
 *    DWORD      dwID :
 *    DWORD      x :
 *    DWORD      y :
 *    IUnknown*  pcmdtReserved :
 *    IDispatch* pdispReserved :
 *    HRESULT*   dwRetVal :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CDocHostUIHandlerDispatch::ShowContextMenu (DWORD dwID, DWORD x, DWORD y, IUnknown* pcmdtReserved,
                              IDispatch* pdispReserved, HRESULT* dwRetVal)
{
    DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::ShowContextMenu"));

    // validate input
    sc = ScCheckPointers(dwRetVal);
    if(sc)
        return sc.ToHr();

    *dwRetVal = S_OK; // default: don't display.

    // Create context menu for console taskpads.
    // must be in author mode for a menu to show up.
    if (AMCGetApp()->GetMode() != eMode_Author)
        return sc.ToHr(); // prevent browser from displaying its menus.

    // Is it a console taskpad
    CMainFrame* pFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    CConsoleView* pConsoleView;
    sc = pFrame->ScGetActiveConsoleView (pConsoleView);
    if (sc)
        return sc.ToHr();

    /*
     * ScGetActiveConsoleView will return success (S_FALSE) even if there's no
     * active view.  This is a valid case, occuring when there's no console
     * file open.  In this particular circumstance, it is an unexpected
     * failure since we shouldn't get to this point in the code if there's
     * no view.
     */
    sc = ScCheckPointers (pConsoleView, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());


	/*
	 * it we want to let the web browser show it own context menu, return
	 * S_FALSE so it will do so; otherwise, display the context menu we want
	 */
	sc = (IsDefaultWebContextMenuDesired())
				? SC(S_FALSE)
				: pConsoleView->ScShowWebContextMenu ();

    // the real return value is in the out parameter.
    *dwRetVal = sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CDocHostUIHandlerDispatch::GetHostInfo
 *
 * PURPOSE: Indicates to IE not to display context menus.
 *
 * PARAMETERS:
 *    DWORD* pdwFlags :
 *    DWORD* pdwDoubleClick :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CDocHostUIHandlerDispatch::GetHostInfo( DWORD* pdwFlags, DWORD* pdwDoubleClick)
{
    DECLARE_SC(sc, TEXT("CDocHostUIHandlerDispatch::GetHostInfo"));

    sc = ScCheckPointers(pdwFlags, pdwDoubleClick);
    if(sc)
        return sc.ToHr();

    // Disable context menus
    *pdwFlags =  DOCHOSTUIFLAG_DISABLE_HELP_MENU;
    *pdwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return sc.ToHr();
}


/////////////////////////////////////////////////////////////////////////////
// CAMCWebViewCtrl

IMPLEMENT_DYNCREATE(CAMCWebViewCtrl, COCXHostView)

CAMCWebViewCtrl::CAMCWebViewCtrl() : m_dwAdviseCookie(0)
{
}

LPUNKNOWN CAMCWebViewCtrl::GetIUnknown(void)
{

    return m_spWebBrowser2;
}


CAMCWebViewCtrl::~CAMCWebViewCtrl()
{
}


BEGIN_MESSAGE_MAP(CAMCWebViewCtrl, CAMCWebViewCtrl::BaseClass)
    //{{AFX_MSG_MAP(CAMCWebViewCtrl)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCWebViewCtrl message handlers

void CAMCWebViewCtrl::OnDraw(CDC* pDC)
{
}


void
CAMCWebViewCtrl::OnDestroy()
{
    if(m_spWebBrowser2)
    {
        if (m_dwAdviseCookie != 0)
        {
            AtlUnadvise(m_spWebBrowser2, DIID_DWebBrowserEvents, m_dwAdviseCookie /*the connection ID*/);
            m_dwAdviseCookie = 0;
        }

        m_spWebBrowser2.Release();
    }

    BaseClass::OnDestroy();
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCWebViewCtrl::ScCreateWebBrowser
 *
 * PURPOSE: Creates the IWebBrowser2 object, and sets up the external UI
 *          handler and event sink.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCWebViewCtrl::ScCreateWebBrowser()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::ScCreateWebBrowser"));

    sc = ScCheckPointers(GetAMCView(), GetAxWindow());
    if(sc)
        return sc;

    // create the OCX host window
    RECT rcClient;
    GetClientRect(&rcClient);
    GetAxWindow()->Create(m_hWnd, rcClient, _T(""), (WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS) );

   // create the web control
    CCoTaskMemPtr<OLECHAR> spstrWebBrowser;
    sc = StringFromCLSID(CLSID_WebBrowser, &spstrWebBrowser);
    if (sc)
        return sc;
 
    sc = GetAxWindow()->CreateControl(spstrWebBrowser);
    if(sc)
        return sc;

    // get a pointer to the web browser control.
    sc = GetAxWindow()->QueryControl(IID_IWebBrowser2, (void **) &m_spWebBrowser2);
    if(sc)
        return sc;

    sc = ScCheckPointers((IWebBrowser2 *)m_spWebBrowser2);
    if(sc)
        return sc;

    // attach the control to the history list, if history is enabled
    if (IsHistoryEnabled())
    {
        sc = ScCheckPointers(GetAMCView()->GetHistoryList());
        if(sc)
            return sc;

        GetAMCView()->GetHistoryList()->Attach (this);
    }

    // get a pointer to the view object
    ViewPtr spView;
    sc = GetAMCView()->ScGetMMCView(&spView);
    if(sc)
        return sc;


    // Set up the External UI Handler.
    typedef CComObject<CDocHostUIHandlerDispatch> CDocHandler;
    CDocHandler *pDocHandler = NULL;
    sc = CDocHandler::CreateInstance(&pDocHandler);
    if(sc)
        return sc;

    if(!pDocHandler)
        return (sc = E_UNEXPECTED);


    CComPtr<IDocHostUIHandlerDispatch> spIDocHostUIHandlerDispatch = pDocHandler;
    if(!spIDocHostUIHandlerDispatch)
        return (sc = E_UNEXPECTED);

    // initialize the dochandler
    sc = pDocHandler->ScInitialize(spView);
    if(sc)
        return sc;

    sc = GetAxWindow()->SetExternalUIHandler(spIDocHostUIHandlerDispatch); // no need to addref.
    if(sc)
        return sc;

    // set up the Web Event Sink, if requested
    if (IsSinkEventsEnabled())
    {
        typedef CComObject<CWebEventSink> CEventSink;
        CEventSink *pEventSink;
        sc = CEventSink::CreateInstance(&pEventSink);
        if(sc)
            return sc;

        sc = pEventSink->ScInitialize(this);
        if(sc)
            return sc;

        m_spWebSink = pEventSink; // addref's it.

        // create the connection
        sc = AtlAdvise(m_spWebBrowser2, (LPDISPATCH)(IWebSink *)m_spWebSink,
                       DIID_DWebBrowserEvents, &m_dwAdviseCookie/*the connection ID*/);
        if(sc)
            return sc;

        if (m_dwAdviseCookie == 0)
            return (sc = E_UNEXPECTED);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCWebViewCtrl::OnCreate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPCREATESTRUCT  lpCreateStruct :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CAMCWebViewCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::OnCreate"));

    if (BaseClass::OnCreate(lpCreateStruct) == -1)
        return -1;

    sc = ScCreateWebBrowser();
    if(sc)
        return 0;

    /*
     * The client edge is supplied by the OCX host view now.  We do this so
     * we can give a nice edge to OCX's that don't support IDispatch (like
     * CMessageView).  ModifyStyleEx for OCX's is implemented as a change
     * to the Border Style stock property, which is done via IDispatch.
     * If the OCX doesn't support IDispatch, we can't change its border.
     * If the client edge is supplied by the OCX host view, we don't need
     * to change the OCX's border
     */
    ModifyStyleEx (WS_EX_CLIENTEDGE, 0);

    return 0;
}


// REVIEW add other members from old file
void CAMCWebViewCtrl::Navigate(LPCTSTR lpszWebSite, LPCTSTR lpszFrameTarget)
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::ScNavigate"));

    USES_CONVERSION;

    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = NULL;

    if (IsHistoryEnabled())
    {
        pHistoryList = GetAMCView()->GetHistoryList();

        if(!pHistoryList)
        {
            sc = E_POINTER;
            return;
        }
    }

    CComBSTR    bstrURL     (T2COLE(lpszWebSite));
    CComVariant vtFlags     ( (long) 0);
    CComVariant vtTarget    (T2COLE(lpszFrameTarget));
    CComVariant vtPostData;
    CComVariant vtHeaders;

    // What does this DoVerb do?
    /*
    if (FAILED((hr=DoVerb(OLEIVERB_PRIMARY))))
    {
        TRACE(_T("DoVerb failed: %X\n"), hr);
        return hr;
    } */

    sc = m_spWebBrowser2->Navigate(bstrURL, &vtFlags, &vtTarget, &vtPostData, &vtHeaders);
    if(sc)
        return;

    // check errors here.
    if (pHistoryList != NULL)
        pHistoryList->UpdateWebBar (HB_STOP, TRUE);  // turn on "stop" button
}


void CAMCWebViewCtrl::Back()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Back"));

    /*
     * if history isn't enabled, we can't go back
     */
    if (!IsHistoryEnabled())
    {
        sc = E_FAIL;
        return;
    }

    // check parameters.
    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = GetAMCView()->GetHistoryList();
    if(!pHistoryList)
    {
        sc = E_POINTER;
        return;
    }

    Stop();

    // give a chance to History to handle the Back notification.
    // If not handled, use the web browser
    bool bHandled = false;
    pHistoryList->Back (bHandled);
    if(!bHandled)
    {
        sc = m_spWebBrowser2->GoBack();
        if(sc)
            return;
    }
}

void CAMCWebViewCtrl::Forward()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Forward"));

    /*
     * if history isn't enabled, we can't go forward
     */
    if (!IsHistoryEnabled())
    {
        sc = E_FAIL;
        return;
    }

    // check parameters.
    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = GetAMCView()->GetHistoryList();
    if(!pHistoryList)
    {
        sc = E_POINTER;
        return;
    }

    Stop();

    // give a chance to History to handle the Forward notification.
    // If not handled, use the web browser
    bool bHandled = false;
    pHistoryList->Forward (bHandled);
    if(!bHandled)
    {
        sc = m_spWebBrowser2->GoForward();
        if(sc)
            return;
    }
}

void CAMCWebViewCtrl::Stop()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Stop"));

    // check parameters.
    sc = ScCheckPointers(m_spWebBrowser2, GetAMCView());
    if(sc)
        return;

    CHistoryList *pHistoryList = NULL;
    if (IsHistoryEnabled())
    {
        pHistoryList = GetAMCView()->GetHistoryList();
        if(!pHistoryList)
        {
            sc = E_POINTER;
            return;
        }
    }

    sc = m_spWebBrowser2->Stop();
    if(sc)
        return;

    if (pHistoryList != NULL)
        pHistoryList->UpdateWebBar (HB_STOP, FALSE);  // turn off "stop" button
}

void CAMCWebViewCtrl::Refresh()
{
    DECLARE_SC(sc, TEXT("CAMCWebViewCtrl::Refresh"));

    sc = ScCheckPointers(m_spWebBrowser2);
    if(sc)
        return;

    sc = m_spWebBrowser2->Refresh();
    if(sc)
        return;
}

SC CAMCWebViewCtrl::ScGetReadyState(READYSTATE& readyState)
{
    DECLARE_SC (sc, _T("CAMCWebViewCtrl::ScGetReadyState"));
    readyState = READYSTATE_UNINITIALIZED;

    sc = ScCheckPointers(m_spWebBrowser2);
    if(sc)
        return sc;

    sc = m_spWebBrowser2->get_ReadyState(&readyState);
    if(sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\base64.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      base64.cpp
 *
 *  Contents:  Implements encoding / decoding table for base64 format
 *
 *  History:   17-Dec-99 audriusz   Created
 *
 *--------------------------------------------------------------------------*/

#include <windows.h>
#include <comdef.h>
#include <memory.h>
#include "base64.h"

/*+-------------------------------------------------------------------------*
 *
 * TABLE base64_table::_six2pr64
 *
 * PURPOSE: for conversion from binary to base64
 *
 *+-------------------------------------------------------------------------*/
BYTE base64_table::_six2pr64[64] = 
{
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

/*+-------------------------------------------------------------------------*
 *
 * TABLE base64_table::_six2pr64
 *
 * PURPOSE: for conversion from base64 to binary 
 * [filled by base64_table::base64_table()]
 *
 *+-------------------------------------------------------------------------*/
BYTE  base64_table::_pr2six[256]; 

/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::base64_table
 *
 * PURPOSE: c-tor. fills the table
 *
 *+-------------------------------------------------------------------------*/
base64_table::base64_table()
{
    memset(_pr2six,-1,sizeof(_pr2six));
    // Build up the reverse index from base64 characters to values
    for (int i = 0; i < sizeof(_six2pr64)/sizeof(_six2pr64[0]); i++)
        _pr2six[_six2pr64[i]] = (BYTE)i;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::decode
 *
 * PURPOSE: decodes 0-3 bytes of data ( as much as available )
 *
 *+-------------------------------------------------------------------------*/
bool base64_table::decode(LPCOLESTR &src, BYTE * &dest)
{
    BYTE Inputs[4] = { 0, 0, 0, 0 };
    int  nChars = 0;
    // force table initialization on first call
    static base64_table table_init;

    // collect 4 characters if possible.
    while (*src && *src != '=' && nChars < 4)
    {
        BYTE bt = table_init.map2six(static_cast<BYTE>(*src++));
        if (bt != 0xff)
            Inputs[nChars++] = bt;
    }

    dest += table_init.decode4(Inputs, nChars, dest);

    return (nChars == 4);
}


/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::encode
 *
 * PURPOSE: encodes 1-3 bytes of data. pads if the last set
 *
 *+-------------------------------------------------------------------------*/
void base64_table::encode(const BYTE * &src, DWORD &cbInput, LPOLESTR &dest)
{
    BYTE chr0 = src[0];
    BYTE chr1 = cbInput > 1 ? src[1] : 0;
    BYTE chr2 = cbInput > 2 ? src[2] : 0;
    *(dest++) = _six2pr64[chr0 >> 2];                                     // c1 
    *(dest++) = _six2pr64[((chr0 << 4) & 060) | ((chr1 >> 4) & 017)];     // c2
    *(dest++) = _six2pr64[((chr1 << 2) & 074) | ((chr2 >> 6) & 03) ];     // c3
    *(dest++) = _six2pr64[chr2 & 077];                                    // c4 
    src += 3;

    if (cbInput == 1)
    {
        *(dest-1) = '=';
        *(dest-2) = '=';
        cbInput = 0;
    }
    else if (cbInput == 2)
    {
        *(dest-1) = '=';
        cbInput = 0;
    }
    else
        cbInput -= 3;

    if (!cbInput)
        *dest = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\wrapper.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      wrapper.h
 *
 *  Contents:  Interface file for simple wrapper classes
 *
 *  History:   02-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef WRAPPER_H
#define WRAPPER_H


/*----------------*/
/* HACCEL wrapper */
/*----------------*/
class CAccel : public CObject
{
public:
    HACCEL  m_hAccel;

    CAccel (HACCEL hAccel = NULL);
    CAccel (LPACCEL paccl, int cEntries);
    ~CAccel ();

    bool CreateAcceleratorTable (LPACCEL paccl, int cEntries);
    int  CopyAcceleratorTable (LPACCEL paccl, int cEntries) const;
    bool TranslateAccelerator (HWND hwnd, LPMSG pmsg) const;
    void DestroyAcceleratorTable ();

    bool LoadAccelerators (int nAccelID);
    bool LoadAccelerators (LPCTSTR pszAccelName);
    bool LoadAccelerators (HINSTANCE hInst, LPCTSTR pszAccelName);

    bool operator== (int i) const
        { ASSERT (i == NULL); return (m_hAccel == NULL); }

    bool operator!= (int i) const
        { ASSERT (i == NULL); return (m_hAccel != NULL); }

    operator HACCEL() const
        { return (m_hAccel); }
};



/*---------------------------------*/
/* Begin/EndDeferWindowPos wrapper */
/*---------------------------------*/
class CDeferWindowPos
{
public:
    HDWP    m_hdwp;

    CDeferWindowPos (int cWindows = 0, bool fSynchronousPositioningForDebugging = false);
    ~CDeferWindowPos ();

    bool Begin (int cWindows);
    bool End ();
    bool AddWindow (const CWnd* pwnd, const CRect& rect, DWORD dwFlags, const CWnd* pwndInsertAfter = NULL);

    bool operator== (int i) const
        { ASSERT (i == NULL); return (m_hdwp == NULL); }

    bool operator!= (int i) const
        { ASSERT (i == NULL); return (m_hdwp != NULL); }

    operator HDWP() const
        { return (m_hdwp); }


private:
    const bool m_fSynchronousPositioningForDebugging;

};


/*-------------------*/
/* Rectangle helpers */
/*-------------------*/
class CWindowRect : public CRect
{
public:
    CWindowRect (const CWnd* pwnd)
    {
        if (pwnd != NULL)
            pwnd->GetWindowRect (this);
        else
            SetRectEmpty();
    }

    /*
     * just forward other ctors
     */
    CWindowRect(int l, int t, int r, int b)         : CRect(l, t, r, b) {} 
    CWindowRect(const RECT& srcRect)                : CRect(srcRect) {} 
    CWindowRect(LPCRECT lpSrcRect)                  : CRect(lpSrcRect) {} 
    CWindowRect(POINT point, SIZE size)             : CRect(point, size) {} 
    CWindowRect(POINT topLeft, POINT bottomRight)   : CRect(topLeft, bottomRight) {} 
};

class CClientRect : public CRect
{
public:
    CClientRect (const CWnd* pwnd)
    {
        if (pwnd != NULL)
            pwnd->GetClientRect (this);
        else
            SetRectEmpty();
    }

    /*
     * just forward other ctors
     */
    CClientRect(int l, int t, int r, int b)         : CRect(l, t, r, b) {} 
    CClientRect(const RECT& srcRect)                : CRect(srcRect) {} 
    CClientRect(LPCRECT lpSrcRect)                  : CRect(lpSrcRect) {} 
    CClientRect(POINT point, SIZE size)             : CRect(point, size) {} 
    CClientRect(POINT topLeft, POINT bottomRight)   : CRect(topLeft, bottomRight) {} 
};


/*+-------------------------------------------------------------------------*
 * AMCGetSysColorBrush 
 *
 * Returns a (temporary) MFC-friendly system color brush.
 *--------------------------------------------------------------------------*/

inline CBrush* AMCGetSysColorBrush (int nIndex)
{
    return (CBrush::FromHandle (::GetSysColorBrush (nIndex)));
}


#endif /* WRAPPER.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\assert.cpp ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>
#include <vector>       // to keep mmcdebug.h happy
#include "mmcdebug.h"

#ifdef DBG

#define new DEBUG_NEW

#include "..\inc\admindbg.h"
#include "malloc.h" // alloca

//
//  Globals
//

ULONG AdminInfoLevel = DEF_INFOLEVEL;
ULONG AdminInfoMask = 0xffffffff;
ULONG AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fCritSecInit = FALSE;
static CRITICAL_SECTION s_csMessageBuf;
static TCHAR g_szMessageBuf[500];        // this is the message buffer

//
//  Forward declration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  InitializeDebugging(void);
void  CleanUpDebugging(void);
void  smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
int   w4dprintf(LPTSTR format, ...);
int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4smprintf(LPTSTR  format, va_list arglist)
{
    int ret;

    EnterCriticalSection(&s_csMessageBuf);
    ret = wvsprintf(g_szMessageBuf, format, arglist);
    OutputDebugString(g_szMessageBuf);
    LeaveCriticalSection(&s_csMessageBuf);
    return ret;
}


//+------------------------------------------------------------
// Function:    SetAdminInfoLevel(ULONG ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
//
// Returns:     Old info level
//
//-------------------------------------------------------------

ULONG SetAdminInfoLevel(ULONG ulNewLevel)
{
    ULONG ul;

    ul = AdminInfoLevel;
    AdminInfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetAdminInfoMask(ULONG ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
//
// Returns:     Old info mask
//
//-------------------------------------------------------------

ULONG SetAdminInfoMask(ULONG ulNewMask)
{
    ULONG ul;

    ul = AdminInfoMask;
    AdminInfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetAdminAssertLevel(ULONG ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
//
// Returns:     Old assert level
//
//-------------------------------------------------------------

ULONG SetAdminAssertLevel(ULONG ulNewLevel)
{
    ULONG ul;

    ul = AdminAssertLevel;
    AdminAssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

void smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | AdminInfoLevel) & AdminInfoMask))
    {
        EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((AdminInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
            }
            w4smprintf(ppszfmt, pargs);
        }

        //if (AdminInfoLevel & DEB_STDOUT)
        //{
        //    if (! (ulCompMask & DEB_NOCOMPNAME))
        //    {
        //        printf("%x.%03x> %s: ", pid, tid, pszComp);
        //    }
        //    vprintf(ppszfmt, pargs);
        //}

        LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
#define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    if (!fCritSecInit) InitializeDebugging();

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADMINDEBUGKEY, 0,
                                            KEY_ALL_ACCESS, &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                                                    KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                   REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;

            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                        (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}

void InitializeDebugging(void)
{
    if (fCritSecInit) return;
    InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    fCritSecInit = TRUE;
}

void CleanUpDebugging(void)
{
    if (fCritSecInit)
    {
        DeleteCriticalSection(&s_csMessageBuf);
        DeleteCriticalSection(&s_csDebugPrint);
    }
}



// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':')
                            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return (LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static CHAR szModuleName[128];
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    wsprintf(szAssertCaption, _T("%hs: Assertion Failed"), pProcess);


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    wsprintf(szDetails, _T(" Assertion:\t %s\n\n")
                        _T(" File:   \t\t %hs\n")
                        _T(" Line:   \t\t %d\n\n")
                        _T(" Module:   \t %hs\n")
                        _T(" Thread ID:\t %d.%d\n\n")
                        _T(" Press Cancel to debug the application\n")
                        _T(" Press OK to ignore the assertion"),
                        szMsg, szFile, iLine, pszModuleName, pid, tid);


    int id = MessageBox(NULL,
                    szDetails,
                    szAssertCaption,
                    MB_SETFOREGROUND
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
            szMessage, pszFileName, iLine, tid);
    }

    if (AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            MMCDebugBreak();
        }
    }
    else if (AdminAssertLevel & ASSRT_BREAK)
    {
        MMCDebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________

// Initialize the number of CDbg instances.
long CDbg::s_cCDbgObjCount = 0;

CDbg::CDbg(LPTSTR  str)
    :
    m_InfoLevelString(str),
    m_InfoLevel(DEF_INFOLEVEL)
{
    CheckInit(m_InfoLevelString, &m_InfoLevel);
    
    // Increment # of CDbg instances.
    InterlockedIncrement(&s_cCDbgObjCount);         
}

CDbg::~CDbg()
{
    // If this is last CDbg instance destroy the 
    // static objects.
    if (InterlockedDecrement(&s_cCDbgObjCount) == 0)
        CleanUpDebugging();
}

void CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    int convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                                                      err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
    AdminAssertEx(pszFile, iLine, pszMsg);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\bitmap.cpp ===
// bitmap.cpp : implementation file
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      bitmap.cpp
//
//  Contents:  Helper functions to copy bitmaps
//
//  History:   27-Feb-97 WayneSc    Created
//
//
//--------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>


//+-------------------------------------------------------------------
//
//  Member:      CopyBitmap
//
//  Synopsis:    Make a copy of given bitmap & return handle to the copy.
//
//  Returns:     HBITMAP - NULL if error
//
// Note:         Cannot use SC as we need to include too may headers.
//               which will make this dependent on mmcbase.lib, but
//               mmcbase.lib is dependent on this (UICore.lib).
//
//--------------------------------------------------------------------
HBITMAP CopyBitmap(HBITMAP hbm)
{
    if (!hbm)
        return NULL;

    HDC hdc        = NULL;
    HDC hMemDCsrc  = NULL;
    HDC hMemDCdst  = NULL;

    HBITMAP hNewBm = NULL;
    BITMAP  bm;
    ZeroMemory(&bm, sizeof(bm));

    hdc = GetDC (NULL);
    if (!hdc)
        goto Error;

    hMemDCsrc = CreateCompatibleDC (hdc);
    if (!hMemDCsrc)
        goto Error;

    hMemDCdst = CreateCompatibleDC (hdc);
    if (!hMemDCdst)
        goto Error;

    if (! GetObject (hbm, sizeof(BITMAP), (LPSTR)&bm))
        goto Error;

    /*hNewBm = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++ (dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL);*/
    hNewBm = CreateBitmap(bm.bmWidth, bm.bmHeight, bm.bmPlanes, bm.bmBitsPixel, NULL);
    if (hNewBm){
        HBITMAP hbmSrcOld = (HBITMAP) SelectObject (hMemDCsrc, hbm);
        HBITMAP hbmDstOld = (HBITMAP) SelectObject (hMemDCdst, hNewBm);

        BitBlt (hMemDCdst,
                0,
                0,
                bm.bmWidth,
                bm.bmHeight,
                hMemDCsrc,
                0,
                0,
                SRCCOPY);

        SelectObject (hMemDCsrc, hbmSrcOld);
        SelectObject (hMemDCdst, hbmDstOld);
    }

Cleanup:
    if (hdc)
        ReleaseDC (NULL,hdc);

    if (hMemDCsrc)
        DeleteDC (hMemDCsrc);

    if (hMemDCdst)
        DeleteDC (hMemDCdst);

    return hNewBm;

Error:
#ifdef DBG
   /*
    * Cannot use SC as we need to include too may headers.
    * which will make this dependent on mmcbase.lib, but
    * mmcbase.lib is dependent on this (UICore.lib).
    * So call outputstring in case of error.
    */
    LPVOID lpMsgBuf;
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf, 0, NULL );

    OutputDebugString((LPTSTR)lpMsgBuf);
    LocalFree( lpMsgBuf );
#endif

    hNewBm = NULL;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "StdDbg.h"

#ifdef DBG
    DECLARE_DEBUG(AMCCore)
    #define DBG_COMP    AMCCoreInfoLevel

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\columninfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      columninfo.cpp
//
//  Contents:   Classes related to column persistence.
//
//
//  Note:       The classes in this file (CColumnInfo, CColumnInfoList)
//              were in nodemgr/colwidth.h. They are moved here so that
//              if columns change conui can ask nodemgr to persist data
//              or conui can set headers by asking nodemgr for data.
//
//  History:    04-Apr-00 AnandhaG     Created
//
//--------------------------------------------------------------------------
#include "stgio.h"
#include "serial.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include <string>
#include "cstr.h"
#include "xmlbase.h"
#include "countof.h"
#include "columninfo.h"

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Read the CColumnInfo object from the stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - The version of the object being read.
//
//                          The format is :
//                              INT    column index
//                              INT    column width
//                              INT    column format
//
//--------------------------------------------------------------------
HRESULT CColumnInfo::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            stm >> m_nCol;
            stm >> m_nWidth;
            stm >> m_nFormat;

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CColumnInfo::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnInfo::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_COLUMN_INFO_COLUMN, m_nCol) ;
    persistor.PersistAttribute(XML_ATTR_COLUMN_INFO_WIDTH,  m_nWidth) ;

    static const EnumLiteral mappedFormats[] =
    {
        { LVCFMT_LEFT,      XML_ENUM_COL_INFO_LVCFMT_LEFT },
        { LVCFMT_RIGHT,     XML_ENUM_COL_INFO_LVCFMT_RIGHT },
        { LVCFMT_CENTER,    XML_ENUM_COL_INFO_LVCFMT_CENTER },
    };

    CXMLEnumeration formatPersistor(m_nFormat, mappedFormats, countof(mappedFormats) );

    persistor.PersistAttribute(XML_ATTR_COLUMN_INFO_FORMAT, formatPersistor) ;
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Reads CColumnInfoList data from stream for the given version.
//
//  Format:     number of columns : each CColumnInfo entry.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - Version of CColumnInfoList to be read.
//
//
//--------------------------------------------------------------------
HRESULT CColumnInfoList::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            // Number of columns.
            DWORD dwCols;
            stm >> dwCols;

            clear();

            for (int i = 0; i < dwCols; i++)
            {
                CColumnInfo colEntry;

                // Read the colEntry data.
                if (colEntry.Read(stm) != S_OK)
                    continue;

                push_back(colEntry);
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\guidhelp.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       guidhelp.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/18/1996   JonN    Created
//
//____________________________________________________________________________


#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"

DECLARE_INFOLEVEL(AMCCore);

#include "commctrl.h" // for LV_ITEM needed by ndmgrpriv.h

// This defines the GUID's in the headers below.
#ifndef DECLSPEC_UUID
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#endif

#include "mmc.h"
#include "ndmgr.h"
#include "ndmgrpriv.h"
#include "guidhelp.h"
#include "comdef.h"
#include "atlbase.h"	// USES_CONVERSION
#include "macros.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static CLIPFORMAT g_CFNodeType    = 0;
static CLIPFORMAT g_CFSnapInCLSID = 0;
static CLIPFORMAT g_CFDisplayName = 0;

HRESULT ExtractData( IDataObject* piDataObject,
                     CLIPFORMAT   cfClipFormat,
                     BYTE*        pbData,
                     DWORD        cbData )
{
    IF_NULL_RETURN_INVALIDARG2( piDataObject, pbData );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
//          ASSERT( FALSE );
            break;
        }

        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
#if (_MSC_VER >= 1200)
#pragma warning (push)
#endif
#pragma warning(disable: 4553)      // "==" operator has no effect
        VERIFY( NULL == ::GlobalFree(stgmedium.hGlobal) );
#if (_MSC_VER >= 1200)
#pragma warning (pop)
#endif
    }
    return hr;
} // ExtractData()



HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    if( !g_CFSnapInCLSID )
    {
        USES_CONVERSION;
        g_CFSnapInCLSID = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID));
    }

    return ExtractData( piDataObject, g_CFSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    if( !g_CFNodeType )
    {
        USES_CONVERSION;
        g_CFNodeType = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_NODETYPE));
    }

    return ExtractData( piDataObject, g_CFNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}

HRESULT GuidToCStr( CStr* pstr, const GUID& guid )
{
    WCHAR awch[MAX_PATH];
    HRESULT hr = StringFromGUID2(guid, awch, sizeof(awch)/sizeof(awch[0]));
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    USES_CONVERSION;
    LPTSTR lptstr = OLE2T(awch);
    *pstr = lptstr;
    return hr;
}

HRESULT CStrToGuid( const CStr& str, GUID* pguid )
{
    USES_CONVERSION;
    LPOLESTR lpolestr = T2OLE(((LPTSTR)(LPCTSTR)str));
    HRESULT hr = CLSIDFromString(lpolestr, pguid);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT ExtractObjectTypeCStr( IDataObject* piDataObject, CStr* pstr )
{
    GUID guidObjectType;
    HRESULT hr = ExtractObjectTypeGUID( piDataObject, &guidObjectType );
    ASSERT(SUCCEEDED(hr));
    return GuidToCStr( pstr, guidObjectType );
}


HRESULT LoadRootDisplayName(IComponentData* pIComponentData,
                            CStr& strDisplayName)
{
    IDataObjectPtr spIDataObject;
    HRESULT hr = pIComponentData->QueryDataObject(NULL, CCT_SNAPIN_MANAGER, &spIDataObject);
    CHECK_HRESULT(hr);
    if ( FAILED(hr) )
        return hr;

    if( !g_CFDisplayName )
    {
        USES_CONVERSION;
        g_CFDisplayName = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME));
    }

    hr = ExtractString( spIDataObject,
                        g_CFDisplayName,
                        strDisplayName);

    CHECK_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\memento.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      memento.cpp
 *
 *  Contents:  Implements the CMemento class
 *
 *  History:   21-April-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include "serial.h"
#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "cstr.h"
#include <vector>
#include "mmcdebug.h"
#include "mmcerror.h"
#include "mmc.h"
#include "commctrl.h"
#include "bookmark.h"
#include "resultview.h"
#include "viewset.h"
#include "memento.h"

bool
CMemento::operator!=(const CMemento& memento)
{
    return (!operator == (memento));
}

bool
CMemento::operator==(const CMemento& memento)
{
    if(m_viewSettings != memento.m_viewSettings)
        return false;

    if(m_bmTargetNode != memento.m_bmTargetNode)
        return false;

    return true;
}


HRESULT
CMemento::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume unknown version

    if (nVersion == 1)
    {
        try
        {
            stm >> m_bmTargetNode;
            hr = m_viewSettings.Read(stm);
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}

void CMemento::Persist(CPersistor& persistor)
{
    persistor.Persist(m_viewSettings);
    persistor.Persist(m_bmTargetNode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\cstr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include <stdio.h>
#include <objbase.h>

#include <basetyps.h>
#include "dbg.h"
#include "..\inc\cstr.h"


/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
TCHAR strChNil = '\0';      // extractstring

// for creating empty key strings
const CStr strEmptyString;

// begin_extractstring
void CStr::Init()
{
    m_nDataLength = m_nAllocLength = 0;
    m_pchData = (LPTSTR)&strChNil;
}

// declared static
void CStr::SafeDelete(LPTSTR lpch)
{
    if (lpch != (LPTSTR)&strChNil)
        delete[] lpch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

// begin_extractstring
CStr::CStr()
{
    Init();
}

CStr::CStr(const CStr& stringSrc)
{
    // if constructing a String from another String, we make a copy of the
    // original string data to enforce value semantics (i.e. each string
    // gets a copy of its own

    stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CStr::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0);

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception

		if (m_pchData != NULL)
		{
			m_pchData[nLen] = '\0';
			m_nDataLength = nLen;
			m_nAllocLength = nLen;
		}
		else
			Init();
    }
}

void CStr::Empty()
{
    SafeDelete(m_pchData);
    Init();
    ASSERT(m_nDataLength == 0);
    ASSERT(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
    SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlen(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;

    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
    if (lpsz != NULL && (DWORD_PTR)lpsz <= 0xffff)
    {
        Init();
        UINT nID = LOWORD((DWORD_PTR)lpsz);
        // REVIEW hInstance for LoadString(hInst, nID);
    }
    else
    {
        int nLen;
        if ((nLen = SafeStrlen(lpsz)) == 0)
            Init();
        else
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
        }
    }
}

// end_extractstring
/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef UNICODE
CStr::CStr(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen == 0)
        Init();
    else
    {
        AllocBuffer(nSrcLen);
        mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    }
}
#else //UNICODE
CStr::CStr(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen == 0)
        Init();
    else
    {
        AllocBuffer(nSrcLen*2);
        mmc_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif //!UNICODE

// begin_extractstring

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
    AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
    return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}
// end_extractstring

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef UNICODE
const CStr& CStr::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
    return *this;
}
#else //!UNICODE
const CStr& CStr::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    nSrcLen *= 2;
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
    {
        mmc_wcstombsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
    return *this;
}
#endif  //!UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = TCHAR, LPCTSTR
//          String + ?
//          ? + String

void CStr::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
    int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

    int nNewLen = nSrc1Len + nSrc2Len;
    AllocBuffer(nNewLen);
    memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
    memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
}

CStr STRAPI operator+(const CStr& string1, const CStr& string2)
{
    CStr s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
        string2.m_nDataLength, string2.m_pchData);
    return s;
}

CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    CStr s;
    s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlen(lpsz), lpsz);
    return s;
}

CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    CStr s;
    s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStr::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (m_nDataLength + nSrcLen > m_nAllocLength)
    {
        // we have to grow the buffer, use the Concat in place routine
        LPTSTR lpszOldData = m_pchData;
        ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
        ASSERT(lpszOldData != NULL);
        SafeDelete(lpszOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(TCHAR));
        m_nDataLength += nSrcLen;
    }
    ASSERT(m_nDataLength <= m_nAllocLength);
    m_pchData[m_nDataLength] = '\0';
}

const CStr& CStr::operator+=(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStr& CStr::operator+=(TCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CStr& CStr::operator+=(const CStr& string)
{
    ConcatInPlace(string.m_nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CStr::GetBuffer(int nMinBufLength)
{
    ASSERT(nMinBufLength >= 0);

    if (nMinBufLength > m_nAllocLength)
    {
        // we have to grow the buffer
        LPTSTR lpszOldData = m_pchData;
        int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, lpszOldData, nOldLen*sizeof(TCHAR));
        m_nDataLength = nOldLen;
        m_pchData[m_nDataLength] = '\0';

        SafeDelete(lpszOldData);
    }

    // return a pointer to the character storage for this string
    ASSERT(m_pchData != NULL);
    return m_pchData;
}

void CStr::ReleaseBuffer(int nNewLength)
{
    if (nNewLength == -1)
        nNewLength = lstrlen(m_pchData); // zero terminated

    ASSERT(nNewLength <= m_nAllocLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
}

LPTSTR CStr::GetBufferSetLength(int nNewLength)
{
    ASSERT(nNewLength >= 0);

    GetBuffer(nNewLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
    return m_pchData;
}

void CStr::FreeExtra()
{
    ASSERT(m_nDataLength <= m_nAllocLength);
    if (m_nDataLength != m_nAllocLength)
    {
        LPTSTR lpszOldData = m_pchData;
        AllocBuffer(m_nDataLength);
        memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(TCHAR));
        ASSERT(m_pchData[m_nDataLength] == '\0');
        SafeDelete(lpszOldData);
    }
    ASSERT(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStr::Find(TCHAR ch) const
{
    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData, ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStr::FindOneOf(LPCTSTR lpszCharSet) const
{
    ASSERT(IsValidString(lpszCharSet, FALSE));
    LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
// String conversion helpers (these use the current system locale)

int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
        return 0;

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
        mbstr, count, NULL, NULL);
    ASSERT(mbstr == NULL || result <= (int)count);
    if (result > 0)
        mbstr[result-1] = 0;
    return result;
}

int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);
    ASSERT(wcstr == NULL || result <= (int)count);
    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStr::LoadString(HINSTANCE hInst, UINT nID)
{
    ASSERT(nID != 0);       // 0 is an illegal string ID

    // Note: resource strings limited to 511 characters
    TCHAR szBuffer[512];
    UINT nSize = StrLoadString(hInst, nID, szBuffer);
    AssignCopy(nSize, szBuffer);
    return nSize > 0;
}


int STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf)
{
    ASSERT(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
    // LoadString without annoying warning from the Debug kernel if the
    //  segment containing the string is not present
    if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
    {
        lpszBuf[0] = '\0';
        return 0; // not found
    }
#endif //DBG
    int nLen = ::LoadString(hInst, nID, lpszBuf, 511);
    if (nLen == 0)
        lpszBuf[0] = '\0';
    return nLen;
}

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;

    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStr::AllocSysString()
{
    BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
    if (bstr == NULL)
        ;//REVIEW AfxThrowMemoryException();

    return bstr;
}

BSTR CStr::SetSysString(BSTR* pbstr)
{
    ASSERT(IsValidAddressz(pbstr, sizeof(BSTR)));

    if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
        ; //REVIEW AfxThrowMemoryException();

    ASSERT(*pbstr != NULL);
    return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp


CStr::CStr(TCHAR ch, int nLength)
{
#ifndef UNICODE
    ASSERT(!IsDBCSLeadByte(ch));    // can't create a lead byte string
#endif
    if (nLength < 1)
    {
        // return empty string if invalid repeat count
        Init();
    }
    else
    {
        AllocBuffer(nLength);
#ifdef UNICODE
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
#else
        memset(m_pchData, ch, nLength);
#endif
    }
}

CStr::CStr(LPCTSTR lpch, int nLength)
{
    if (nLength == 0)
        Init();
    else
    {
        ASSERT(IsValidAddressz(lpch, nLength, FALSE));
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStr& CStr::operator=(TCHAR ch)
{
#ifndef UNICODE
    ASSERT(!IsDBCSLeadByte(ch));    // can't set single lead byte
#endif
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStr STRAPI operator+(const CStr& string1, TCHAR ch)
{
    CStr s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CStr STRAPI operator+(TCHAR ch, const CStr& string)
{
    CStr s;
    s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStr CStr::Mid(int nFirst) const
{
    return Mid(nFirst, m_nDataLength - nFirst);
}

CStr CStr::Mid(int nFirst, int nCount) const
{
    ASSERT(nFirst >= 0);
    ASSERT(nCount >= 0);

    // out-of-bounds requests return sensible things
    if (nFirst + nCount > m_nDataLength)
        nCount = m_nDataLength - nFirst;
    if (nFirst > m_nDataLength)
        nCount = 0;

    CStr dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CStr CStr::Right(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CStr dest;
    AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
    return dest;
}

CStr CStr::Left(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CStr dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CStr CStr::SpanIncluding(LPCTSTR lpszCharSet) const
{
    ASSERT(IsValidString(lpszCharSet, FALSE));
    return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStr CStr::SpanExcluding(LPCTSTR lpszCharSet) const
{
    ASSERT(IsValidString(lpszCharSet, FALSE));
    return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStr::ReverseFind(TCHAR ch) const
{
    // find last single character
    LPTSTR lpsz = _tcsrchr(m_pchData, ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStr::Find(LPCTSTR lpszSub) const
{
    ASSERT(IsValidString(lpszSub, FALSE));

    // find first matching substring
    LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStr::Format(LPCTSTR lpszFormat, ...)
{
    ASSERT(IsValidString(lpszFormat, FALSE));

    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}


void CStr::FormatV(LPCTSTR lpszFormat, va_list argList)
{

    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
        {
            nMaxLen += _tclen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _ttoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                ;
        }
        ASSERT(nWidth >= 0);

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = _tcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = _tcsinc(lpsz);
            }
            else
            {
                nPrecision = _ttoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                    ;
            }
            ASSERT(nPrecision >= 0);
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = _tcsinc(lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = _tcsinc(lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = _tcsinc(lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, char);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR);
            break;

        // strings
        case 's':
        case 'S':
            nItemLen = lstrlen(va_arg(argList, LPCTSTR));
            nItemLen = __max(1, nItemLen);
            break;
        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
            nItemLen = lstrlenA(va_arg(argList, LPCSTR));
            nItemLen = __max(1, nItemLen);
            break;
#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
            nItemLen = wcslen(va_arg(argList, LPWSTR));
            nItemLen = __max(1, nItemLen);
            break;
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = __max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = __min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = __max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, _STR_DOUBLE);
                nItemLen = 128;
                nItemLen = __max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = __max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                ASSERT(FALSE);  // unknown formatting option
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }
    va_end(argList);

    // finally, set the buffer length and format the string
    GetBuffer(nMaxLen);

#include "pushwarn.h"
#pragma warning(disable: 4552)      // "<=" operator has no effect
    VERIFY(_vstprintf(m_pchData, lpszFormat, argListSave) <= nMaxLen);
#include "popwarn.h"

    ReleaseBuffer();
    va_end(argListSave);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void __cdecl CStr::FormatMessage(LPCTSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
//      AfxThrowMemoryException();
        return;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}
#endif //!_MAC

void CStr::TrimRight()
{
    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPTSTR lpsz = m_pchData;
    LPTSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = _tcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        m_nDataLength = int(lpszLast - m_pchData);
    }
}

void CStr::TrimLeft()
{
    // find first non-space character
    LPCTSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
        lpsz = _tcsinc(lpsz);

    // fix up data and length
    int nDataLength = m_nDataLength - int(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    m_nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

void STRAPI ConstructElements(CStr* pElements, int nCount)
{
    ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

    for (; nCount--; ++pElements)
        memcpy(pElements, &strEmptyString, sizeof(*pElements));
}

void STRAPI DestructElements(CStr* pElements, int nCount)
{
    ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

    for (; nCount--; ++pElements)
        pElements->Empty();
}

UINT STRAPI HashKey(LPCTSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\picon.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      picon.cpp
 *
 *  Contents:  Implementation file for CPersistableIcon
 *
 *  History:   19-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "picon.h"
#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include "util.h"
#include <comdef.h>
#include <shellapi.h>   // for ExtractIconEx
#include <commctrl.h>   // for HIMAGELIST

/*
 * for comdbg.h (assumes client code is ATL-based)
 */
#include <atlbase.h>    // for CComModule
extern CComModule _Module;
#include "comdbg.h"


const LPCWSTR g_pszCustomDataStorage                = L"Custom Data";
const LPCWSTR CPersistableIcon::s_pszIconFileStream = L"Icon";
const LPCWSTR CPersistableIcon::s_pszIconBitsStream = L"Icon Bits";


static HRESULT ReadIcon  (IStream* pstm, CSmartIcon& icon);


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::~CPersistableIcon
 *
 *
 *--------------------------------------------------------------------------*/

CPersistableIcon::~CPersistableIcon()
{
    Cleanup();
}


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::Cleanup
 *
 *
 *--------------------------------------------------------------------------*/

void CPersistableIcon::Cleanup()
{
	m_icon32.Release();
	m_icon16.Release();
    m_Data.Clear();
}


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::operator=
 *
 *
 *--------------------------------------------------------------------------*/

CPersistableIcon& CPersistableIcon::operator= (const CPersistableIconData& data)
{
    if (&data != &m_Data)
    {
        m_Data = data;
        ExtractIcons ();
    }

    return (*this);
}


/*+-------------------------------------------------------------------------*
 * CPersistableIcon::GetIcon
 *
 * Returns an icon of the requested size.
 *
 * NOTE: this method cannot use SC's because it is used in mmcshext.dll,
 * which doesn't have access to mmcbase.dll, where SC is implemented.
 *--------------------------------------------------------------------------*/

HRESULT CPersistableIcon::GetIcon (int nIconSize, CSmartIcon& icon) const
{
	HRESULT hr = S_OK;

	switch (nIconSize)
	{
		/*
		 * standard sizes can be returned directly
		 */
		case 16:	icon = m_icon16;	break;
        case 32:	icon = m_icon32;	break;

		/*
		 * non-standard sizes need to be scaled
		 */
		default:
			/*
			 * find the icon whose size is nearest to the requested size;
			 * that one should scale with the most fidelity
			 */
			const CSmartIcon& iconSrc = (abs (nIconSize-16) < abs (nIconSize-32))
											? m_icon16
											: m_icon32;

			icon.Attach ((HICON) CopyImage ((HANDLE)(HICON) iconSrc, IMAGE_ICON,
											nIconSize, nIconSize, 0));

			/*
			 * if the CopyImage failed, get the error code
			 */
			if (icon == NULL)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());

				/*
				 * just in case CopyImage failed without setting the last error
				 */
				if (SUCCEEDED (hr))
					hr = E_FAIL;
			}
			break;
	}

	return (hr);
}


/*+-------------------------------------------------------------------------*
 * ExtractIcons
 *
 *
 *--------------------------------------------------------------------------*/

bool CPersistableIcon::ExtractIcons ()
{
	/*
	 * clean out existing contents of our CSmartIcons
	 */
	m_icon32.Release();
	m_icon16.Release();

	/*
	 * extract the icons from the icon file
	 */
	HICON hLargeIcon = NULL;
	HICON hSmallIcon = NULL;
	bool fSuccess = ExtractIconEx (m_Data.m_strIconFile.data(), m_Data.m_nIndex,
								   &hLargeIcon, &hSmallIcon, 1);

	/*
	 * if successful, attach them to our smart icons for resource management;
	 * otherwise, clean up anything that might have been returned
	 */
    if (fSuccess)
    {
		m_icon32.Attach (hLargeIcon);
		m_icon16.Attach (hSmallIcon);
    }
	else
	{
        if (hLargeIcon != NULL)
			DestroyIcon (hLargeIcon);

        if (hSmallIcon != NULL)
			DestroyIcon (hSmallIcon);
	}

    return (fSuccess);
}

/*+-------------------------------------------------------------------------*
 * CPersistableIcon::Load
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CPersistableIcon::Load (LPCWSTR pszFilename)
{
    HRESULT hr = E_FAIL;

    do  // not a loop
    {
        IStoragePtr spRootStg;
        IStoragePtr spDefaultIconStg;

        hr = OpenDebugStorage (pszFilename,
                             STGM_READ | STGM_SHARE_DENY_WRITE,
                             &spRootStg);
        BREAK_ON_FAIL (hr);

        hr = OpenDebugStorage (spRootStg, g_pszCustomDataStorage,
                                     STGM_READ | STGM_SHARE_EXCLUSIVE,
                                     &spDefaultIconStg);

        BREAK_ON_FAIL (hr);

        hr = Load (spDefaultIconStg);

    } while (false);

    return (hr);
}


HRESULT CPersistableIcon::Load (IStorage* pStorage)
{
    HRESULT hr;

    try
    {
        /*
         * read the icon data from the stream
         */
        IStreamPtr spStm;
        hr = OpenDebugStream (pStorage, s_pszIconFileStream,
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   &spStm);
        THROW_ON_FAIL (hr);

        *spStm >> m_Data;

		hr = OpenDebugStream (pStorage, s_pszIconBitsStream,
								   STGM_READ | STGM_SHARE_EXCLUSIVE,
								   &spStm);
		THROW_ON_FAIL (hr);

		hr = ReadIcon (spStm, m_icon32);
		THROW_ON_FAIL (hr);

		hr = ReadIcon (spStm, m_icon16);
		THROW_ON_FAIL (hr);
    }
    catch (_com_error& err)
    {
        /*
         * Bug 393868: If anything failed, make sure we clean up anything
         * that was partially completed, to leave us in a coherent
         * (uninitialized) state.
         */
        Cleanup();

        hr = err.Error();
    }

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * ReadIcon
 *
 *
 *--------------------------------------------------------------------------*/

static HRESULT ReadIcon (IStream* pstm, CSmartIcon& icon)
{
    HIMAGELIST  himl = NULL;
	HRESULT		hr   = ReadCompatibleImageList (pstm, himl);

    if (himl != NULL)
    {
        icon.Attach (ImageList_GetIcon (himl, 0, ILD_NORMAL));

		if (icon != NULL)
			hr = S_OK;

        ImageList_Destroy (himl);
    }

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CPersistableIconData from a stream.
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, CPersistableIconData& icon)
{
    /*
     * Read the stream version
     */
    DWORD dwVersion;
    stm >> dwVersion;

    switch (dwVersion)
    {
        case 1:
            stm >> icon.m_nIndex;
            stm >> icon.m_strIconFile;
            break;

        /*
         * beta custom icon format, migrate it forward
         */
        case 0:
        {
            /*
             * Read the custom icon index
             */
            WORD wIconIndex;
            stm >> wIconIndex;
            icon.m_nIndex = wIconIndex;

            /*
             * Read the length, in bytes, of the filename
             */
            WORD cbFilename;
            stm >> cbFilename;

            /*
             * Read the custom icon filename (always in Unicode)
             */
            WCHAR wszFilename[MAX_PATH];

            if (cbFilename > sizeof (wszFilename))
                _com_issue_error (E_FAIL);

            DWORD cbRead;
            HRESULT hr = stm.Read (&wszFilename, cbFilename, &cbRead);
            THROW_ON_FAIL (hr);

            USES_CONVERSION;
            icon.m_strIconFile = W2T (wszFilename);
            break;
        }

        default:
            _com_issue_error (E_FAIL);
            break;
    }

    return (stm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\smarticon.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      smarticon.cpp
 *
 *  Contents:  Implementation file for CSmartIcon
 *
 *  History:   25-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "smarticon.h"


/*+-------------------------------------------------------------------------*
 * CSmartIcon::~CSmartIcon
 *
 * Destroys a CSmartIcon object.
 *--------------------------------------------------------------------------*/

CSmartIcon::~CSmartIcon ()
{
	Release();
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::CSmartIcon
 *
 * Copy constructor for a CSmartIcon object.
 *--------------------------------------------------------------------------*/

CSmartIcon::CSmartIcon (const CSmartIcon& other)
{
	m_pData = other.m_pData;

	if (m_pData)
		m_pData->AddRef();
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::operator=
 *
 * Assignment operator for CSmartIcon.
 *--------------------------------------------------------------------------*/

CSmartIcon& CSmartIcon::operator= (const CSmartIcon& rhs)
{
	if (&rhs != this)
	{
		Release();

		m_pData = rhs.m_pData;
		if (m_pData)
			m_pData->AddRef();
	}

	return *this;
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::Attach
 *
 * Releases the currently held icon and creates a CSmartIconData to hold
 * a reference to the given icon.
 *
 * You would use this method in the same way you'd use CComPtr<T>::Attach.
 *
 * This method will destroy the icon if the underlying CSmartIconData object
 * cannot be created because of insufficient memory.
 *--------------------------------------------------------------------------*/

void CSmartIcon::Attach (HICON hIcon)
{
	/*
	 * if we're already attached to this icon, there's nothing to do
	 */
	if (operator HICON() == hIcon)
		return;

	Release();
	ASSERT (m_pData == NULL);

	/*
	 * if we couldn't create a CSmartIconData to hold hIcon, destroy hIcon
	 */
	if ( (hIcon != NULL) &&
		((m_pData = CSmartIconData::CreateInstance (hIcon)) == NULL))
	{
		DestroyIcon (hIcon);
	}
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::Detach
 *
 * Releases the currently held icon, passing ownership (and responsibility
 * for deletion) to the caller.
 *
 * You would use this method in the same way you'd use CComPtr<T>::Detach.
 *--------------------------------------------------------------------------*/

HICON CSmartIcon::Detach ()
{
	HICON hIcon = NULL;

	/*
	 * if we've got an icon, detach it from our CSmartIconData
	 */
	if (m_pData != NULL)
	{
		hIcon   = m_pData->Detach();
		m_pData = NULL;
	}

	return (hIcon);
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::Release
 *
 * Releases this CSmartIcon's reference on its icon.  It is safe to call
 * this on a CSmartIcon that doesn't refer to an icon.
 *
 * You would use this method in the same way you'd use CComPtr<T>::Release.
 *--------------------------------------------------------------------------*/

void CSmartIcon::Release()
{
	if (m_pData)
	{
		m_pData->Release();
		m_pData = NULL;
	}
}


/*+-------------------------------------------------------------------------*
 * CSmartIcon::CSmartIconData::Detach
 *
 * Releases the currently held icon, passing ownership (and responsibility
 * for deletion) to the caller.
 *--------------------------------------------------------------------------*/

HICON CSmartIcon::CSmartIconData::Detach ()
{
	HICON hIcon = NULL;

	/*
	 * if there's only one reference on us, then we can return the icon
	 * we holding directly to the caller
	 */
	if (m_dwRefs == 1)
	{
		hIcon = m_hIcon;
		m_hIcon = NULL;		// so our d'tor won't delete it
	}

	/*
	 * otherwise, we have more than one reference on us; we need to copy
	 * the icon we're holding so others who refer to us won't have their
	 * icons destroyed from underneath them
	 */
	else
		hIcon = CopyIcon (m_hIcon);

	/*
	 * let go of our reference
	 */
	Release();

	/*
	 * Hands off!  Release() may have deleted this object.
	 */

	return (hIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\serial.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      serial.cpp
 *
 *  Contents:  Object serialization class implementation
 *
 *  History:   11-Feb-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include "serial.h"

/*+-------------------------------------------------------------------------*
 *
 * CSerialObject::Write
 *
 * PURPOSE:  Writes an object with version and size information. This information
 *           is used when the object is read. If an unknown version of the object
 *           is presented, the data is discarded. This way, all known data can 
 *           still be retrieved. (Useful for backward as well as forward compatibility.)
 *
 * PARAMETERS: 
 *    IStream & stm :
 *
 * RETURNS: 
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSerialObjectRW::Write(IStream &stm)
{
    HRESULT         hr              = S_OK;
    UINT            nVersion        = GetVersion();
    ULARGE_INTEGER  nSeekPosMarker;
    ULARGE_INTEGER  nSeekPosNextObj;
    LARGE_INTEGER   lZero;
    LARGE_INTEGER   lint;

    try
    {
        do  // not a loop
        {
            lZero.LowPart = 0;
            lZero.HighPart= 0;
            lZero.QuadPart= 0; // just to be safe.

            stm << nVersion;        // save the version information

            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosMarker);  // get the current location of the pointer
            BREAK_ON_FAIL(hr);

            ::ZeroMemory(&nSeekPosNextObj, sizeof(nSeekPosNextObj) );
            // should we use the low part only? Or will this cause a Y2K like crisis?
            stm << nSeekPosNextObj.QuadPart;  // not the correct value; need to come back and fix (done below)

#ifdef DBG
            ULARGE_INTEGER  nSeekPosMarker2;
            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosMarker2);  // get the current location of the pointer
            BREAK_ON_FAIL(hr);
#endif

            hr = WriteSerialObject(stm);  // write the internal data
            BREAK_ON_FAIL(hr);

            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosNextObj);
            BREAK_ON_FAIL(hr);


            // go back to the placeholder marker
            lint.QuadPart = nSeekPosMarker.QuadPart;
            hr = stm.Seek(lint, STREAM_SEEK_SET, NULL);
            BREAK_ON_FAIL(hr);

            stm << nSeekPosNextObj.QuadPart; // the correct value of the marker

#ifdef DBG
            ULARGE_INTEGER  nSeekPosMarker3;
            hr = stm.Seek(lZero, STREAM_SEEK_CUR, &nSeekPosMarker3);  // get the current location of the pointer
            BREAK_ON_FAIL(hr);

            // make sure we're back in the same place
            ASSERT( (nSeekPosMarker2.QuadPart == nSeekPosMarker3.QuadPart) );
#endif

            lint.QuadPart = nSeekPosNextObj.QuadPart;
            hr = stm.Seek(lint, STREAM_SEEK_SET, NULL);
            BREAK_ON_FAIL(hr);

        } while (false);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }
    
    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CSerialObject::Read
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStream & stm :
 *
 * RETURNS: 
 *    HRESULT - S_OK     if able to read the object.
 *              S_FALSE  if skipped reading the object.
 *              E_FAIL   Could not skip the object or something catastrophic.
 *
 *+-------------------------------------------------------------------------*/
HRESULT 
CSerialObject::Read(IStream &stm)
{
    HRESULT         hr              = S_OK;
    UINT            nVersion        = 0;
    ULARGE_INTEGER  nSeekPosMarker;
    ULARGE_INTEGER  nSeekPosNextObj;
    LARGE_INTEGER   lint;    

    try
    {
        stm >> nVersion;    // get the version number

        stm >> nSeekPosNextObj.QuadPart;  // get the offset to the next object

        hr = ReadSerialObject(stm, nVersion);

        if (hr==S_FALSE)    // data skipped?
        {
            // an unknown version. Throw the data for that object away and continue to read other objects
            lint.QuadPart = nSeekPosNextObj.QuadPart;
            hr = stm.Seek(lint, STREAM_SEEK_SET, NULL);

            if (SUCCEEDED (hr))
                hr = S_FALSE;       // propagate "data skipped"
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=     uicore
TARGETPATH=     obj
TARGETTYPE=     LIBRARY

SYNCHRONIZE_BLOCK = 1
USE_NATIVE_EH     = 1
USE_STATIC_ATL    = 1
USE_CRTDLL        = 1
ATL_VER           = 30
USE_WTL           = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

C_DEFINES = $(C_DEFINES) -DISOLATION_AWARE_ENABLED

# We need $(SHELL_INC_PATH) for uastrfnc.h
INCLUDES = \
	..\;					\
	..\..\inc;				\
	..\..\types\idl\$(O);	\
	$(SHELL_INC_PATH);		\



SOURCES=\
	..\assert.cpp   	\
	..\bitmap.cpp   	\
	..\crc32.c      	\
	..\cstr.cpp     	\
	..\guidhelp.cpp 	\
	..\memento.cpp  	\
	..\picon.cpp    	\
	..\serial.cpp   	\
	..\stddbg.cpp   	\
	..\stgio.cpp    	\
	..\strings.cpp  	\
	..\tstring.cpp  	\
	..\util.cpp     	\
	..\viewset.cpp  	\
	..\xmlbase.cpp  	\
	..\base64.cpp   	\
	..\columninfo.cpp	\
	..\smarticon.cpp	\
	..\xmlicon.cpp		\
	..\xmlimage.cpp		\

UMTYPE= windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\stgutil.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       stgutil.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/3/1996   RaviR   Created
//
//____________________________________________________________________________

#include "headers.hxx"
#pragma hdrstop

#include <afxconv.h>
#include "stgutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//____________________________________________________________________________
//
//  Member:     CIStream::Read
//
//  Synopsis:   Reads cb count of bytes from the stream passed into the
//              buffer, pv.  Insures the count read equals the count
//              requested.
//
//  Arguments:  [pv]   -- buffer to read into.
//              [cb]   -- read request byte count.
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes read != bytes expected>.
//____________________________________________________________________________

void
CIStream::Read(VOID * pv, ULONG cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pv != NULL);

    ULONG cbRead = 0;

    HRESULT hr = m_pstm->Read(pv, cb, &cbRead);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cb != cbRead)
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}


//____________________________________________________________________________
//
//  Member:     CIStream::Write
//
//  Synopsis:   Writes cb count of bytes from the stream passed from the
//              buffer, pv.  Insures the count written equals the count
//              specified.
//
//  Arguments:  [pv]   -- buffer to write from.
//              [cb]   -- write request byte count.
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes written != bytes expected>.
//____________________________________________________________________________

void
CIStream::Write(
    const VOID * pv,
    ULONG        cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pv != NULL);

    ULONG cbWritten = 0;

    HRESULT hr = m_pstm->Write(pv, cb, &cbWritten);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cb != cbWritten)
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}



//____________________________________________________________________________
//
//  Member:     CIStream::CopyTo
//
//  Synopsis:   Copies cb number of bytes from the current seek pointer in
//              the stream to the current seek pointer in another stream
//
//  Arguments:  [pstm] -- Points to the destination stream
//              [cb]   -- Specifies the number of bytes to copy
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes read != bytes written>.
//____________________________________________________________________________

void
CIStream::CopyTo(
    IStream * pstm,
    ULARGE_INTEGER cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pstm != NULL);

    ULARGE_INTEGER cbRead = {0};
    ULARGE_INTEGER cbWritten = {0};

    HRESULT hr = m_pstm->CopyTo(pstm, cb, &cbRead, &cbWritten);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cbWritten.LowPart != cbRead.LowPart ||
             cbWritten.HighPart != cbRead.HighPart )
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       strings.cpp
//
//--------------------------------------------------------------------------

#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

// put actual strings here
#define INIT_MMC_BASE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\stddbg.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stddbg.cpp
 *
 *  Contents:  Implementation file for CDebugLeakDetector
 *
 *  History:   26-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/
#ifdef DBG

#include "windows.h"
#include "stddbg.h"
#include "tstring.h"
#include <map>
#include "atlbase.h" // USES_CONVERSION

DECLARE_INFOLEVEL(AMCCore);
DECLARE_HEAPCHECKING;


class CDebugLeakDetector : public CDebugLeakDetectorBase
{
public:
    CDebugLeakDetector()
    {}

    virtual ~CDebugLeakDetector()
    {
        DumpLeaks();
    }

    virtual void DumpLeaks()
    {
        RefCountsMap::iterator it;
        std::string strError;

        for (it = m_RefCounts.begin(); it != m_RefCounts.end(); ++it)
        {
            const std::string&  strClass = it->first;
            int                 cRefs    = it->second;

            if (cRefs != 0)
            {
                if (!strError.empty())
                    strError += "\n";

                char szMessage[512];
                wsprintfA (szMessage, "%s has %d instances left over",
                           strClass.data(), cRefs);

                strError += szMessage;
            }
        }

        if (!strError.empty())
            ::MessageBoxA(NULL, strError.data(), "MMC: Memory Leaks!!!", MB_OK | MB_SERVICE_NOTIFICATION);
    }

    virtual int AddRef(const std::string& strClass)
    {
        return (++m_RefCounts[strClass]);
    }

    virtual int Release(const std::string& strClass)
    {
        /*
         * if this assert fails, you're releasing something that 
         * hasn't been addref'd -- check the spelling in your
         * DEBUG_DECREMENT_INSTANCE_COUNTER macro usage
         */
        ASSERT (m_RefCounts.find (strClass) != m_RefCounts.end());

        /*
         * If this assert fails, you have excessive releases.
         * One possible cause of this is you might be using a 
         * compiler-generated copy constructor for your object,
         * which won't call DEBUG_INCREMENT_INSTANCE_COUNTER.
         * Define your own copy constructor.
         */
        ASSERT (m_RefCounts[strClass] > 0);

        return (--m_RefCounts[strClass]);
    }

private:
    class RefCounter
    {
    public:
        RefCounter() : m_cRefs(0) {}

        operator int()
        {
            return (m_cRefs);
        }

        int operator++()    // pre-increment
        {
            return (++m_cRefs);
        }

        int operator++(int) // post-increment
        {
            int t = m_cRefs++;
            return (t);
        }

        operator--()        // pre-decrement
        {
            return (--m_cRefs);
        }

        int operator--(int) // post-decrement
        {
            int t = m_cRefs--;
            return (t);
        }

    private:
        int m_cRefs;
    };

    typedef std::map<std::string, RefCounter>   RefCountsMap;
    RefCountsMap m_RefCounts;
};


CDebugLeakDetectorBase& GetLeakDetector()
{
    static CDebugLeakDetector detector;
    return (detector);
}

DBG_PersistTraceData::DBG_PersistTraceData() : 
bIComponent(false), 
bIComponentData(false),
pTraceFN(NULL)
{
} 

void DBG_PersistTraceData::SetTraceInfo(DBG_PersistTraceData::PTraceErrorFn pFn, bool bComponent, const tstring& owner)
{
    ASSERT(pFn);
    pTraceFN = pFn;
    bIComponent = bComponent;
    bIComponentData = !bComponent;
    strSnapin = owner;
}

void DBG_PersistTraceData::TraceErr(LPCTSTR strInterface, LPCTSTR msg)
{
    if (!pTraceFN)
        return;

    tstring formatted;

    formatted += tstring(_T("\"")) + (strSnapin) + _T("\"");

    formatted += tstring(_T(" Interface ")) + strInterface;

    if (bIComponent)
        formatted += _T("[IComponent]");
    else if (bIComponentData)
        formatted += _T("[IComponentData]");

    formatted += _T(" - ");
    formatted += msg;

    pTraceFN(formatted.c_str());
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\stgio.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stgio.h
 *
 *  Contents:  Interface file structured storage I/O utilities
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include <tchar.h>


/*+-------------------------------------------------------------------------*
 * ReadScalar 
 *
 * Reads a scalar value from a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& ReadScalar (IStream& stm, T& t)
{
    ULONG cbActuallyRead;
    HRESULT hr = stm.Read (&t, sizeof (t), &cbActuallyRead);
    THROW_ON_FAIL (hr);

    if (cbActuallyRead != sizeof (t))
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * WriteScalar 
 *
 * Writes a scalar value to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& WriteScalar (IStream& stm, const T& t)
{
    ULONG cbActuallyWritten;
    HRESULT hr = stm.Write (&t, sizeof (t), &cbActuallyWritten);
    THROW_ON_FAIL (hr);

    if (cbActuallyWritten != sizeof (t))
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * ReadString 
 *
 * Reads a std::basic_string from a stream.  The string should have been 
 * written with a DWORD character count preceding an array of characters
 * that is not NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class E, class Tr, class A>
static IStream& ReadString (IStream& stm, std::basic_string<E,Tr,A>& str)
{
    /*
     * read the length
     */
    DWORD cch;
    stm >> cch;

    /*
     * allocate a buffer for the characters
     */
    std::auto_ptr<E> spBuffer (new (std::nothrow) E[cch + 1]);
    E* pBuffer = spBuffer.get();

    if (pBuffer == NULL)
        _com_issue_error (E_OUTOFMEMORY);

    /*
     * read the characters
     */
    ULONG cbActuallyRead;
    const ULONG cbToRead = cch * sizeof (E);
    HRESULT hr = stm.Read (pBuffer, cbToRead, &cbActuallyRead);
    THROW_ON_FAIL (hr);

    if (cbToRead != cbActuallyRead)
        _com_issue_error (E_FAIL);

    /*
     * terminate the character array and assign it to the string
     */
    pBuffer[cch] = 0;

    /*
     * assign it to the string (clear the string first to work around
     * the bug described in KB Q172398)
     */
    str.erase();
    str = pBuffer;

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * WriteString 
 *
 * Writes a std::basic_string to a stream.  The string is written with a 
 * DWORD character count preceding an array of characters that is not 
 * NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class E, class Tr, class A>
static IStream& WriteString (IStream& stm, const std::basic_string<E,Tr,A>& str)
{
    /*
     * write the length
     */
    DWORD cch = str.length();
    stm << cch;

    if (cch > 0)
    {
        /*
         * write the characters
         */
        ULONG cbActuallyWritten;
        const ULONG cbToWrite = cch * sizeof (E);
        HRESULT hr = stm.Write (str.data(), cbToWrite, &cbActuallyWritten);
        THROW_ON_FAIL (hr);

        if (cbToWrite != cbActuallyWritten)
            _com_issue_error (E_FAIL);
    }

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<, operator>>
 *
 * Stream insertion and extraction operators for various types
 *--------------------------------------------------------------------------*/

#define DefineScalarStreamOperators(scalar_type)                \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, scalar_type t)           \
        { return (WriteScalar (stm, t)); }          
                                                    
#define DefineScalarStreamOperatorsByRef(scalar_type)           \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, const scalar_type& t)    \
        { return (WriteScalar (stm, t)); }

DefineScalarStreamOperators      (bool);
DefineScalarStreamOperators      (         char);
DefineScalarStreamOperators      (unsigned char);
DefineScalarStreamOperators      (         short);
DefineScalarStreamOperators      (unsigned short);
DefineScalarStreamOperators      (         int);
DefineScalarStreamOperators      (unsigned int);
DefineScalarStreamOperators      (         long);
DefineScalarStreamOperators      (unsigned long);
DefineScalarStreamOperators      (         __int64);
DefineScalarStreamOperators      (unsigned __int64);
DefineScalarStreamOperators      (float);
DefineScalarStreamOperators      (double);
DefineScalarStreamOperators      (long double);
DefineScalarStreamOperatorsByRef (CLSID);

IStream& operator>> (IStream& stm, std::string& str)
    { return (ReadString (stm, str)); }
IStream& operator<< (IStream& stm, const std::string& str)
    { return (WriteString (stm, str)); }

IStream& operator>> (IStream& stm, std::wstring& str)
    { return (ReadString (stm, str)); }
IStream& operator<< (IStream& stm, const std::wstring& str)
    { return (WriteString (stm, str)); }


/*+-------------------------------------------------------------------------*
 * ReadScalarVector 
 *
 * Reads an entire vector collection of scalar types (written by 
 * insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
static void ReadScalarVector (IStream* pstm, std::vector<T>& v)
{
    /*
     * clear out the current container
     */
    v.clear();

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    if (cItems > 0)
    {
        /*
         * allocate a buffer for the elements
         */
        std::auto_ptr<T> spBuffer (new (std::nothrow) T[cItems]);
        T* pBuffer = spBuffer.get();

        if (pBuffer == NULL)
            _com_issue_error (E_OUTOFMEMORY);

        /*
         * read the elements
         */
        ULONG cbActuallyRead;
        const ULONG cbToRead = cItems * sizeof (T);
        HRESULT hr = pstm->Read (pBuffer, cbToRead, &cbActuallyRead);
        THROW_ON_FAIL (hr);

        if (cbToRead != cbActuallyRead)
            _com_issue_error (E_FAIL);

        /*
         * assign the elements to the vector
         */
        v.assign (pBuffer, pBuffer + cItems);
    }
}


/*+-------------------------------------------------------------------------*
 * WriteScalarVector 
 *
 * Writes an entire vector of scalar types to an IStream.  Note that this
 * code assumes that vectors store their elements sequentially.
 *--------------------------------------------------------------------------*/

template<class T>
static void WriteScalarVector (IStream* pstm, const std::vector<T>& v)
{
    /*
     * write the size
     */
    DWORD cItems = v.size();
    *pstm << cItems;

    if (cItems > 0)
    {
        /*
         * write the elements
         */
        ULONG cbActuallyWritten;
        const ULONG cbToWrite = cItems * sizeof (T);
        HRESULT hr = pstm->Write (v.begin(), cbToWrite, &cbActuallyWritten);
        THROW_ON_FAIL (hr);

        if (cbToWrite != cbActuallyWritten)
            _com_issue_error (E_FAIL);
    }
}


/*+-------------------------------------------------------------------------*
 * extract_vector (specialization for std::vector<scalar>)
 *      Efficiently extracts an entire vector collection of scalar types 
 *      (written by insert_collection) from an IStream.
 * 
 * insert_collection (specializations for std::vector<scalar>)
 *      Efficiently inserts an entire vector of scalar types into an IStream.
 *--------------------------------------------------------------------------*/

#define DefineScalarVectorStreamFunctions(scalar_type)                  \
    void extract_vector (IStream* pstm, std::vector<scalar_type>& v)    \
        { ReadScalarVector (pstm, v); }                                 \
    void insert_collection (IStream* pstm, const std::vector<scalar_type>& v)\
        { WriteScalarVector (pstm, v); }                                    
                                                    
DefineScalarVectorStreamFunctions (bool);
DefineScalarVectorStreamFunctions (         char);
DefineScalarVectorStreamFunctions (unsigned char);
DefineScalarVectorStreamFunctions (         short);
DefineScalarVectorStreamFunctions (unsigned short);
DefineScalarVectorStreamFunctions (         int);
DefineScalarVectorStreamFunctions (unsigned int);
DefineScalarVectorStreamFunctions (         long);
DefineScalarVectorStreamFunctions (unsigned long);
DefineScalarVectorStreamFunctions (         __int64);
DefineScalarVectorStreamFunctions (unsigned __int64);
DefineScalarVectorStreamFunctions (float);
DefineScalarVectorStreamFunctions (double);
DefineScalarVectorStreamFunctions (long double);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\tstring.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tstring.h
 *
 *  Contents:  Implementation file for tstring
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "tstring.h"
#include "stgio.h"
#include <atlbase.h>
#include <comutil.h>
#include "macros.h"
#include "countof.h"


/*+-------------------------------------------------------------------------*
 * tstring::LoadString
 *
 *
 *--------------------------------------------------------------------------*/

bool tstring::LoadString (HINSTANCE hInst, UINT nID)
{
#ifdef UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

    // try fixed buffer first (to avoid wasting space in the heap)
    TCHAR szTemp[256];
    int nCount = sizeof(szTemp) / sizeof(szTemp[0]);
    int nLen   = ::LoadString(hInst, nID, szTemp, nCount);

    if (nCount - nLen > CHAR_FUDGE)
        *this = szTemp;

    else
    {
        // try buffer size of 512, then larger size until entire string is retrieved
        LPTSTR  pszBuffer = NULL;
        int nSize = 256;

        do
        {
            nSize += 256;
            delete[] pszBuffer;
            pszBuffer = new TCHAR[nSize];
            if (!pszBuffer)
            {
                return false; // Memory alloc failed.
            }

            nLen = ::LoadString(hInst, nID, pszBuffer, nSize);
        } while (nSize - nLen <= CHAR_FUDGE);

        *this = pszBuffer;
        delete[] pszBuffer;
    }

    return (nLen > 0);
}


#ifndef UNICODE

/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * ANSI only:  Extracts a string from a stream in Unicode format, then
 * converts it to ANSI.
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, tstring& str)
{
    USES_CONVERSION;

    std::wstring wstr;
    stm >> wstr;
    str = W2CA (wstr.data());

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * ANSI only:  Inserts a tstring into a stream in Unicode format.
 *--------------------------------------------------------------------------*/

IStream& operator<< (IStream& stm, const tstring& str)
{
    USES_CONVERSION;
    return (stm << std::wstring (A2W (str.data())));
}

#endif // UNICODE




/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::CStringTableStringBase
 *
 *
 *--------------------------------------------------------------------------*/

CStringTableStringBase::CStringTableStringBase (IStringTablePrivate* pstp)
    :   m_spStringTable (pstp),
        m_id            (eNoValue)
{
}

CStringTableStringBase::CStringTableStringBase (const CStringTableStringBase& other)
    :   m_spStringTable (other.m_spStringTable),
        m_id            (eNoValue)
{
    Assign (other);
}

CStringTableStringBase::CStringTableStringBase (
    IStringTablePrivate*    pstp,
    const tstring&          str)
    :   m_spStringTable (pstp),
        m_id            (eNoValue),
        m_str           (str)
{
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::operator=
 *
 *
 *--------------------------------------------------------------------------*/

CStringTableStringBase& CStringTableStringBase::operator= (const CStringTableStringBase& other)
{
    if (&other != this)
    {
        RemoveFromStringTable();
        Assign (other);
    }

    return (*this);
}

CStringTableStringBase& CStringTableStringBase::operator= (const tstring& str)
{
    /*
     * string table operations are relatively expensive, so a string
     * comparision before we do any string table stuff is warranted
     */
    if (m_str != str)
    {
        RemoveFromStringTable();

        /*
         * copy the text, but delay committing to the string table
         */
        m_str = str;
    }

    return (*this);
}

CStringTableStringBase& CStringTableStringBase::operator= (LPCTSTR psz)
{
    return (operator= (tstring (psz)));
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::Assign
 *
 *
 *--------------------------------------------------------------------------*/

void CStringTableStringBase::Assign (const CStringTableStringBase& other)
{
    ASSERT (m_id == eNoValue);

    /*
     * copy the other's value
     */
    m_str = other.m_str;

    /*
     * if the source string is already committed to
     * the string table, this one should be, too
     */
    if (other.m_id != eNoValue)
        CommitToStringTable ();
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::~CStringTableStringBase
 *
 *
 *--------------------------------------------------------------------------*/

CStringTableStringBase::~CStringTableStringBase ()
{
    RemoveFromStringTable();
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::CommitToStringTable
 *
 * Attaches the current string to the given string table
 *--------------------------------------------------------------------------*/

MMC_STRING_ID CStringTableStringBase::CommitToStringTable () const
{
    /*
     * Commit the string if:
     *
     * 1. the string's not already in the string table, and
     * 2. it's not empty, and
     * 3. we have a string table
     */
    if ((m_id == eNoValue) && !m_str.empty() && (m_spStringTable != NULL))
    {
        USES_CONVERSION;
        m_spStringTable->AddString (T2CW (m_str.data()), &m_id, NULL);
    }

    return (m_id);
}


/*+-------------------------------------------------------------------------*
 * CStringTableStringBase::RemoveFromStringTable
 *
 * Detaches the current string from the current string table.
 *--------------------------------------------------------------------------*/

void CStringTableStringBase::RemoveFromStringTable () const
{
    /*
     * if we have a string ID from the current string table, delete it
     */
    if (m_id != eNoValue)
    {
        /*
         * shouldn't be removing a string from a string table unless
         * we have already added it (and therefore obtained an interface)
         */
        ASSERT (m_spStringTable != NULL);

        m_spStringTable->DeleteString (m_id, NULL);
        m_id = eNoValue;
    }
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 *
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, CStringTableStringBase& str)
{
    str.RemoveFromStringTable();

    stm >> str.m_id;

    if (str.m_id != CStringTableStringBase::eNoValue)
    {
        try
        {
            USES_CONVERSION;
            HRESULT hr;
            ULONG cch;

            if (str.m_spStringTable == NULL)
                _com_issue_error (E_NOINTERFACE);

            hr = str.m_spStringTable->GetStringLength (str.m_id, &cch, NULL);
            THROW_ON_FAIL (hr);

            // allow for NULL terminator
            cch++;

            std::auto_ptr<WCHAR> spszText (new (std::nothrow) WCHAR[cch]);
            LPWSTR pszText = spszText.get();

            if (pszText == NULL)
                _com_issue_error (E_OUTOFMEMORY);

            hr = str.m_spStringTable->GetString (str.m_id, cch, pszText, NULL, NULL);
            THROW_ON_FAIL (hr);

            str.m_str = W2T (pszText);
        }
        catch (_com_error& err)
        {
            ASSERT (false && "Caught _com_error");
            str.m_id = CStringTableStringBase::eNoValue;
            str.m_str.erase();
            throw;
        }
    }
    else
        str.m_str.erase();

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 *
 *--------------------------------------------------------------------------*/

IStream& operator<< (IStream& stm, const CStringTableStringBase& str)
{
    str.CommitToStringTable();

#ifdef DBG
    /*
     * make sure CommitToStringTable really committed
     */
    if (str.m_id != CStringTableStringBase::eNoValue)
    {
        WCHAR sz[256];
        ASSERT (str.m_spStringTable != NULL);
        HRESULT hr = str.m_spStringTable->GetString (str.m_id, countof(sz), sz, NULL, NULL);

        ASSERT (SUCCEEDED(hr) && "Persisted a CStringTableString to a stream that's not in the string table");
    }
#endif

    stm << str.m_id;

    return (stm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\xmlbase.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <hlink.h>
#include <dispex.h>
#include "mshtml.h"
#include "msxml.h"
#include <winnls.h>
#include "atlbase.h" // USES_CONVERSION
#include "dbg.h"
#include "..\inc\cstr.h"
#include "macros.h"
#include <comdef.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <map>
#include <list>
#include <vector>
#include "mmcdebug.h"
#include "mmcerror.h"
#include "..\inc\xmlbase.h"
#include "countof.h"
#include <commctrl.h>
#include "picon.h"
#include "base64.h"
#include "strings.h"
#include "autoptr.h"
#include <shlobj.h>
#include "zlib.h"
#include "xmlicon.h"

SC ScEncodeBinary(CComBSTR& bstrResult, const CXMLBinary& binSrc);
SC ScDecodeBinary(const CComBSTR& bstrSource, CXMLBinary *pBinResult);
SC ScSaveXMLDocumentToString(CXMLDocument& xmlDocument, std::wstring& strResult);

// Traces
#ifdef DBG
CTraceTag tagXMLCompression(TEXT("Console Files"), TEXT("Compression"));
#endif


//############################################################################
//############################################################################
//
//  helper classes used in this file
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CXMLBinaryValue
 *
 * PURPOSE: Persists the contents of XMLValue on binary storage
 *          It's a simle wrapper needed to inform CPersistor about
 *          values wish to be persisted on Binary storage
 *          [see comment "CONCEPT OF BINARY STORAGE" in "xmbase.h"]
 *
 *+-------------------------------------------------------------------------*/
class CXMLBinaryValue : public CXMLObject
{
    CXMLValue m_xval;
public:
    CXMLBinaryValue(CXMLValue xval) : m_xval(xval) {}
    virtual LPCTSTR GetXMLType() { return m_xval.GetTypeName(); }
    virtual void Persist(CPersistor &persistor)
    {
        persistor.PersistContents (m_xval);
    }
    virtual bool    UsesBinaryStorage() { return true; }
};

//############################################################################
//############################################################################
//
//  Implementation of class CXMLElementCollection
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CXMLElementCollection::get_count
 *
 * PURPOSE: // returns count of elements in the collection
 *
 * PARAMETERS:
 *    long *plLength    [out] - count of the elements
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElementCollection::get_count(long *plCount)
{
    DECLARE_SC(sc, TEXT("CXMLElementCollection::get_count"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    sc = m_sp->get_length(plCount);
    if (sc)
        sc.Throw();
}


/***************************************************************************\
 *
 * METHOD:  CXMLElementCollection::item
 *
 * PURPOSE: wraps item method from IXMLDOMNodeList
 *
 * PARAMETERS:
 *    VARIANT Var1          [in] parameter #1
 *    VARIANT Var2          [in] parameter #2
 *    CXMLElement *pElem    [out] resulting element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElementCollection::item(LONG lIndex, CXMLElement *pElem)
{
    DECLARE_SC(sc, TEXT("CXMLElementCollection::item"));

    // check params
    sc = ScCheckPointers(pElem);
    if (sc)
        sc.Throw();

    // init ret val
    *pElem = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spNode;
    sc = m_sp->get_item(lIndex , &spNode);
    if(sc)
        sc.Throw();

    // return the object
    *pElem = CXMLElement(spNode);
}

//############################################################################
//############################################################################
//
//  Implementation of class CXMLElement
//
//############################################################################
//############################################################################
/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_tagName
 *
 * PURPOSE: returns tag name of the element
 *
 * PARAMETERS:
 *    CStr &strTagName  [out] element's name
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_tagName(CStr &strTagName)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_tagName"));

    USES_CONVERSION;

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR bstr;
    sc = spEl->get_tagName(&bstr);
    if(sc)
        sc.Throw();
    strTagName=OLE2T(bstr);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_parent
 *
 * PURPOSE: returns parent element
 *
 * PARAMETERS:
 *    CXMLElement * pParent - [out] parent element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_parent(CXMLElement * pParent)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_parent"));

    // parameter check
    sc = ScCheckPointers(pParent);
    if (sc)
        sc.Throw();

    // init return value
    *pParent = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spParent;
    sc = m_sp->get_parentNode(&spParent);
    if(sc)
        sc.Throw();

    *pParent = CXMLElement(spParent);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::setAttribute
 *
 * PURPOSE: assigns attribute to the element
 *
 * PARAMETERS:
 *    const CStr &strPropertyName       - attribute name
 *    const CComBSTR &bstrPropertyValue - attribute value
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::setAttribute(const CStr &strPropertyName, const CComBSTR &bstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CXMLElement::setAttribute"));

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR bstrPropertyName (strPropertyName);
    CComVariant varPropertyValue(bstrPropertyValue);
    sc = spEl->setAttribute(bstrPropertyName, varPropertyValue);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::getAttribute
 *
 * PURPOSE: gets attribute from element
 *
 * PARAMETERS:
 *    const CStr &strPropertyName   - [in] attribute name
 *    CComBSTR &bstrPropertyValue   - [out] attribute value
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
bool
CXMLElement::getAttribute(const CStr &strPropertyName,       CComBSTR &bstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CXMLElement::getAttribute"));

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR    bstrPropertyName (strPropertyName);
    CComVariant varPropertyValue;
    sc = spEl->getAttribute(bstrPropertyName, &varPropertyValue);
    if(sc) // no resuls cannot be read either
        sc.Throw();

    if (sc.ToHr() == S_FALSE)
        return false;

    // check if we've got the expected value type
    if ( varPropertyValue.vt != VT_BSTR )
        sc.Throw( E_UNEXPECTED );

    bstrPropertyValue = varPropertyValue.bstrVal;

    return true;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::removeAttribute
 *
 * PURPOSE: removes attribute from the elament
 *
 * PARAMETERS:
 *    const CStr &strPropertyName   - [in] atrtibute name
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::removeAttribute(const CStr &strPropertyName)
{
    DECLARE_SC(sc, TEXT("CXMLElement::removeAttribute"));

    // get the element
    CComQIPtr<IXMLDOMElement> spEl;
    spEl = m_sp;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(spEl, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComBSTR    bstrPropertyName (strPropertyName);
    sc = spEl->removeAttribute(bstrPropertyName);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_children
 *
 * PURPOSE: returns collection of children which belong to element
 *
 * PARAMETERS:
 *    CXMLElementCollection *pChildren - [out] collection
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_children(CXMLElementCollection *pChildren)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_children"));

    sc = ScCheckPointers(pChildren);
    if (sc)
        sc.Throw();

    // init ret value
    *pChildren = CXMLElementCollection();
    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNodeList> spChildren;
    sc = m_sp->get_childNodes(&spChildren);
    if(sc)
        sc.Throw();

    // return the object
    *pChildren = CXMLElementCollection(spChildren);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_type
 *
 * PURPOSE: returns the type of the element
 *
 * PARAMETERS:
 *    long *plType  - [out] element's type
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_type(DOMNodeType *pType)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_type"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    sc = m_sp->get_nodeType(pType);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::get_text
 *
 * PURPOSE: retrieves contents of the text element
 *          NOTE: it only works for text elements!
 *
 * PARAMETERS:
 *    CComBSTR &bstrContent - storage for resulting string
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::get_text(CComBSTR &bstrContent)
{
    DECLARE_SC(sc, TEXT("CXMLElement::get_text"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    bstrContent.Empty();
    sc = m_sp->get_text(&bstrContent);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::addChild
 *
 * PURPOSE: adds the new child element to current element
 *
 * PARAMETERS:
 *    CXMLElement& rChildElem   [in] element to become a child
 *    long lIndex               [in] index for new element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::addChild(CXMLElement& rChildElem)
{
    DECLARE_SC(sc, TEXT("CXMLElement::addChild"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spCreated;
    sc = m_sp->appendChild(rChildElem.m_sp, &spCreated);
    if(sc)
        sc.Throw();

    rChildElem.m_sp = spCreated;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::removeChild
 *
 * PURPOSE: removes child element
 *
 * PARAMETERS:
 *    CXMLElement& rChildElem   - [in] child to remove
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLElement::removeChild(CXMLElement& rChildElem)
{
    DECLARE_SC(sc, TEXT("CXMLElement::removeChild"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNode> spRemoved;
    sc = m_sp->removeChild(rChildElem.m_sp, &spRemoved);
    if(sc)
        sc.Throw();

    rChildElem.m_sp = spRemoved;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::GetTextIndent
 *
 * PURPOSE: returns indentation for the child element \ closing tag
 *          Indentation is calulated by element depth in the tree
 *
 * PARAMETERS:
 *    CComBSTR& bstrIndent   [out] string conatining required indent
 *    bool bForAChild       [in]  if the indent is for a child
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
bool CXMLElement::GetTextIndent(CComBSTR& bstrIndent, bool bForAChild)
{
    DECLARE_SC(sc, TEXT("CXMLElement::GetTextIndent"));

    const size_t nIdentStep = 2;

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    // initialize the result
    bstrIndent.Empty();


    CComPtr<IXMLDOMNode> spNext;
    CComPtr<IXMLDOMNode> spParent;

    // calculate node depth
    int nNodeDepth = 0;
    spNext = m_sp;
    while ( S_OK == spNext->get_parentNode(&spParent) && spParent != NULL)
    {
        ++nNodeDepth;
        spNext = spParent;
        spParent.Release();
    }

    // no indent for topmost things
    if (nNodeDepth < 1)
        return false;

    // do not count root node - not ours
    --nNodeDepth;

    // child is indented more
    if (bForAChild)
        ++nNodeDepth;

    if (bForAChild)
    {
        // it may already have indent for the closing tag (if its' not the first element)
        // than we just need a little increase

        // see if the we have child elements added;
        CXMLElementCollection colChildren;
        get_children(&colChildren);

        // count all elements
        long nChildren = 0;
        if (!colChildren.IsNull())
            colChildren.get_count(&nChildren);

        // we will have at least 2 for normal elements
        // since the indent (text element) will be added prior to the first one
        if (nChildren > 1)
        {
            bstrIndent = std::wstring( nIdentStep, ' ' ).c_str();
            return true;
        }
    }

    std::wstring strResult(nIdentStep * (nNodeDepth) + 1/*for new line*/, ' ');
    // new line for each (1st) new item
    strResult[0] = '\n';
    bstrIndent = strResult.c_str();

    return true;
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::replaceChild
 *
 * PURPOSE: replaces the element with the new on
 *
 * PARAMETERS:
 *    CXMLElement& rNewChildElem    [in] new element
 *    CXMLElement& rOldChildElem    [in/out] old element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLElement::replaceChild(CXMLElement& rNewChildElem, CXMLElement& rOldChildElem)
{
    DECLARE_SC(sc, TEXT("CXMLElement::replaceChild"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    // forward to MSXML
    CComPtr<IXMLDOMNode> spRemoved;
    sc = m_sp->replaceChild(rNewChildElem.m_sp, rOldChildElem.m_sp, &spRemoved);
    if (sc)
        sc.Throw();

    rOldChildElem = CXMLElement(spRemoved);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::getNextSibling
 *
 * PURPOSE: returns sibling to this element
 *
 * PARAMETERS:
 *    CXMLElement * pNext [out] sibling element
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CXMLElement::getNextSibling(CXMLElement * pNext)
{
    DECLARE_SC(sc, TEXT("CXMLElement::getNextSibling"));

    // parameter check;
    sc = ScCheckPointers(pNext);
    if (sc)
        sc.Throw();

    // initialization
    *pNext = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    // forward to MSXML
    CComPtr<IXMLDOMNode> spNext;
    sc = m_sp->get_nextSibling(&spNext);
    if (sc)
        sc.Throw();

    *pNext = CXMLElement(spNext);
}

/***************************************************************************\
 *
 * METHOD:  CXMLElement::getChildrenByName
 *
 * PURPOSE: returns children by specified name
 *
 * PARAMETERS:
 *    LPTCSTR szTagName                 - [in] tag name
 *    CXMLElementCollection *pChildren  - [out] collection
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLElement::getChildrenByName(LPCTSTR szTagName, CXMLElementCollection *pChildren)
{
    DECLARE_SC(sc, TEXT("CXMLElement::getChildrenByName"));

    sc = ScCheckPointers(pChildren);
    if (sc)
        sc.Throw();

    // init ret value
    *pChildren = CXMLElementCollection();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMNodeList> spChildren;
    sc = m_sp->selectNodes(CComBSTR(szTagName), &spChildren);
    if(sc)
        sc.Throw();

    // return the object
    *pChildren = CXMLElementCollection(spChildren);
}

/*+-------------------------------------------------------------------------*
 *
 * CXMLElement::put_text
 *
 * PURPOSE: Per IXMLDOMNode
 *
 * PARAMETERS:
 *    BSTR  bstrValue :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CXMLElement::put_text(BSTR bstrValue)
{
    DECLARE_SC(sc, TEXT("CXMLElement::put_text"));

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    sc = m_sp->put_text(bstrValue);
    if(sc)
        sc.Throw();
}


//############################################################################
//############################################################################
//
//  Implementation of class CXMLDocument
//
//  These are documented in the Platform SDK.
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::get_root
 *
 * PURPOSE: returns root element of the document
 *
 * PARAMETERS:
 *    CXMLElement *pElem
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLDocument::get_root(CXMLElement *pElem)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::get_root"));

    // parameter check
    sc = ScCheckPointers(pElem);
    if (sc)
        sc.Throw();

    // init ret value
    *pElem = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComPtr<IXMLDOMElement> spElem;
    sc = m_sp->get_documentElement(&spElem);
    if(sc)
        sc.Throw();

    *pElem = CXMLElement(spElem);
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::createElement
 *
 * PURPOSE: creates new element in XML document
 *
 * PARAMETERS:
 *    NODE_TYPE type       - type of the element requested
 *    CIXMLElement *pElem  - resulting element
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CXMLDocument::createElement(DOMNodeType type, BSTR bstrTag, CXMLElement *pElem)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::createElement"));

    // parameter check
    sc = ScCheckPointers(pElem);
    if (sc)
        sc.Throw();

    // init ret val
    *pElem = CXMLElement();

    // check if we have the interface pointer to forward the call
    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    if (type == NODE_ELEMENT)
    {
        CComPtr<IXMLDOMElement> spElem;
        sc = m_sp->createElement(bstrTag, &spElem);
        if(sc)
            sc.Throw();

        *pElem = CXMLElement(spElem);
    }
    else if (type == NODE_TEXT)
    {
        CComPtr<IXMLDOMText> spText;
        sc = m_sp->createTextNode(bstrTag, &spText);
        if(sc)
            sc.Throw();

        *pElem = CXMLElement(spText);
    }
    else
    {
        sc.Throw(E_UNEXPECTED);
    }
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::CreateBinaryStorage
 *
 * PURPOSE: Creates XML element to be used for subsequent persist operations
 *          the object informs Persistor if it wants to be saved as binary data.
 *          If so, only reference will be saved in original place of the object
 *
 * PARAMETERS:
 *    const CStr &strElementType        - type of the element
 *    LPCTSTR szElementName             - name of the element
*
* RETURNS:
*
\***************************************************************************/
void
CXMLDocument::CreateBinaryStorage()
{
    DECLARE_SC(sc, TEXT("CXMLDocument::CreateBinaryStorage"));

    // check if it is attachment is not a doubled
    if (!m_XMLElemBinaryStorage.IsNull())
        sc.Throw(E_UNEXPECTED);

    CXMLElement elemRoot;
    get_root(&elemRoot);

    // create persistor on parent element
    CPersistor persistorParent(*this, elemRoot);
    persistorParent.SetLoading(false);
    CPersistor persistorStor(persistorParent, XML_TAG_BINARY_STORAGE, NULL);

    m_XMLElemBinaryStorage = persistorStor.GetCurrentElement();
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::LocateBinaryStorage
 *
 * PURPOSE: Locates XML element to be used for subsequent persist operations
 *          the object informs Persistor if it wants to be saved as binary data.
 *          If so, only reference will be saved in original place of the object
 *
 * PARAMETERS:
 *    const CStr &strElementType        - type of the element
 *    LPCTSTR szElementName             - name of the element
*
* RETURNS:
*
\***************************************************************************/
void
CXMLDocument::LocateBinaryStorage()
{
    DECLARE_SC(sc, TEXT("CXMLDocument::LocateBinaryStorage"));

    // check if it is attachment is not a doubled
    if (!m_XMLElemBinaryStorage.IsNull())
        sc.Throw(E_UNEXPECTED);

    CXMLElement elemRoot;
    get_root(&elemRoot);

    // create persistor on parent element
    CPersistor persistorParent(*this, elemRoot);
    persistorParent.SetLoading(true);
    CPersistor persistorStor(persistorParent, XML_TAG_BINARY_STORAGE, NULL);
    // find the element
    m_XMLElemBinaryStorage = persistorStor.GetCurrentElement();
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::CommitBinaryStorage
 *
 * PURPOSE: makes binary storage the last element in the collection
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
void
CXMLDocument::CommitBinaryStorage()
{
    DECLARE_SC(sc, TEXT("CXMLDocument::CommitBinaryStorage"));

    if (m_XMLElemBinaryStorage.IsNull())
        sc.Throw(E_UNEXPECTED);

    CXMLElement elemRoot;
    get_root(&elemRoot);

    // get the next siblings
    CXMLElement elNext;
    m_XMLElemBinaryStorage.getNextSibling(&elNext);

    // drag itself and the next element (indent text) to the end
    elemRoot.removeChild(m_XMLElemBinaryStorage);  // remove element

    // the element was padded to have proper indentation - need to remove it
    DOMNodeType elType = NODE_INVALID;
    while (!elNext.IsNull() && (elNext.get_type(&elType), elType == NODE_TEXT))
    {
        CXMLElement elNext2;
        elNext.getNextSibling(&elNext2);

        elemRoot.removeChild(elNext);  // remove element (that was just an indent)
        elNext = elNext2;
    }

    // create persistor on parent element
    CPersistor persistorParent(*this, elemRoot);
    persistorParent.SetLoading(false);
    // create the new binary storage
    CPersistor persistorStor(persistorParent, XML_TAG_BINARY_STORAGE, NULL);

    // replace the current element with the one which hass all the binary storage
    elemRoot.replaceChild(m_XMLElemBinaryStorage, persistorStor.GetCurrentElement());

    m_XMLElemBinaryStorage = NULL;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScCoCreate
 *
 * PURPOSE:     (co)creates new xml document. puts charset and version
 *
 * PARAMETERS:
 *    LPCTSTR lpstrCharSet - charset (NULL - use default)
 *    CXMLDocument& doc    - created document
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScCoCreate(bool bPutHeader)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScCoCreate"));

    // cannot use this on co-created doc!
    if (m_sp)
        return sc = E_UNEXPECTED;

    // Create an empty XML document
    sc = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                            IID_IXMLDOMDocument, (void**)&m_sp);
    if(sc)
        return sc;

    m_sp->put_preserveWhiteSpace(-1);

    try
    {
        CXMLElement elemDoc = m_sp;

        // put the document version
        if (bPutHeader)
        {
            // valid document must have a top element - add the dummy one
            WCHAR szVersion[] = L"<?xml version=\"1.0\"?>\n<DUMMY/>";

            // load
            sc = ScLoad(szVersion);
            if (sc)
                return sc;

            // we can now strip the dummy el.
            CXMLElement elemRoot;
            get_root(&elemRoot);
            elemDoc.removeChild(elemRoot);
            if (sc)
                return sc;
        }

    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }
    catch(...)
    {
        // what else could it be? - no memory
        sc = E_OUTOFMEMORY;
        return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScLoad
 *
 * PURPOSE: lods XML document from given IStream
 *
 * PARAMETERS:
 *    IStream *pStream      [in] - stream to load from
 *    bool bSilentOnErrors  [in] - do not trace if open fails
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScLoad(IStream *pStream, bool bSilentOnErrors /*= false*/ )
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScLoad"));

    // check params
    sc = ScCheckPointers(pStream);
    if (sc)
        return sc;

    // get the interface
    IPersistStreamInitPtr spPersistStream = m_sp;
    sc = ScCheckPointers(spPersistStream, E_UNEXPECTED);
    if (sc)
        return sc;

    // load (do not trace the error - it may be that the old console
    // is attempted to load - mmc will revert to old format after this failure)
    SC sc_no_trace = spPersistStream->Load(pStream);
    if ( sc_no_trace )
    {
        if ( !bSilentOnErrors )
            sc = sc_no_trace;
        return sc_no_trace;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScLoad
 *
 * PURPOSE: lods XML document from given string
 *
 * PARAMETERS:
 *    LPCWSTR strSource  [in] - string to load from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScLoad(LPCWSTR strSource)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScLoad"));

    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        return sc;

    CComBSTR bstrSource(strSource);
    VARIANT_BOOL  bOK;

    sc = m_sp->loadXML(bstrSource, &bOK);
    if (sc)
        return sc;

    if (bOK != VARIANT_TRUE)
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScSaveToFile
 *
 * PURPOSE: saves xml document to given stream
 *
 * PARAMETERS:
 *    LPCTSTR lpcstrFileName  - [in] file to save to
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScSaveToFile(LPCTSTR lpcstrFileName)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScSaveToFile"));

    // check params
    sc = ScCheckPointers(lpcstrFileName);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    CComVariant var(lpcstrFileName);
    sc = m_sp->save(var);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLDocument::ScSave
 *
 * PURPOSE: saves xml document to given string
 *
 * PARAMETERS:
 *    CComBSTR &bstrResult  - [out] string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLDocument::ScSave(CComBSTR &bstrResult)
{
    DECLARE_SC(sc, TEXT("CXMLDocument::ScSave"));

    sc = ScCheckPointers(m_sp, E_NOINTERFACE);
    if (sc)
        sc.Throw();

    bstrResult.Empty();
    sc = m_sp->get_xml(&bstrResult);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScSaveToString
 *
 * PURPOSE: saves XML object to string (in raw UNICODE or UTF-8 fromat)
 *
 * PARAMETERS:
 *    tstring *pString  - resulting string
 *    bool bPutHeader   - whether to put xml header info
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/

SC CXMLObject::ScSaveToString(std::wstring *pString, bool bPutHeader /*= false*/)
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScSaveToString"));

    // check parameter
    sc = ScCheckPointers(pString);
    if (sc)
        return sc;

    //initialize output
    pString->erase();

    // Create an empty XML document
    CXMLDocument xmlDocument;
    sc = xmlDocument.ScCoCreate(bPutHeader);
    if(sc)
        return sc;

    // persist the contents
    try
    {
        CXMLElement elemDoc = xmlDocument;

        CPersistor persistor(xmlDocument, elemDoc);
        persistor.SetLoading(false);
        persistor.EnableValueSplit(false); // disable split (no string table, no binary storage)
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    // dump it to the string
    sc = ScSaveXMLDocumentToString(xmlDocument, *pString);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScSaveToDocument
 *
 * PURPOSE: saves XML object to file as XML document
 *
 * PARAMETERS:
 *    CXMLDocument& xmlDocument - xmlDocument to save to
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLObject::ScSaveToDocument( CXMLDocument& xmlDocument )
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScSaveToDocument"));

    // Create an empty XML document
    sc = xmlDocument.ScCoCreate(true/*bPutHeader*/);
    if(sc)
        return sc;

    // persist the contents
    try
    {
        CXMLElement elemDoc = xmlDocument;

        CPersistor persistor(xmlDocument, elemDoc);
        persistor.SetLoading(false);
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScLoadFromString
 *
 * PURPOSE: loads XML object from data stored in string
 *
 * PARAMETERS:
 *    LPCTSTR lpcwstrSource
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLObject::ScLoadFromString(LPCWSTR lpcwstrSource, PersistorMode mode)
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScLoadFromString"));

    // check parameter
    sc = ScCheckPointers(lpcwstrSource);
    if (sc)
        return sc;

    // Create an empty XML document
    CXMLDocument xmlDocument;
    sc = xmlDocument.ScCoCreate(false/*bPutHeader*/);
    if(sc)
        return sc;

    sc = xmlDocument.ScLoad(lpcwstrSource);
    if(sc)
        return sc;

    // persist the contents
    try
    {
        CPersistor persistor(xmlDocument, CXMLElement(xmlDocument));
        persistor.SetLoading(true);
        persistor.SetMode(mode);
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLObject::ScLoadFromDocument
 *
 * PURPOSE: loads XML object from xml document saved as file
 *
 * PARAMETERS:
 *    CXMLDocument& xmlDocument - xml document to read from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLObject::ScLoadFromDocument( CXMLDocument& xmlDocument )
{
    DECLARE_SC(sc, TEXT("CXMLObject::ScLoadFromDocument"));

    // persist the contents
    try
    {
        CPersistor persistor(xmlDocument, CXMLElement(xmlDocument));
        persistor.SetLoading(true);
        persistor.Persist(*this);
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }


    return sc;
}

//############################################################################
//############################################################################
//
//  Implementation of class CPersistor
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CPersistor::CommonConstruct
 *
 * PURPOSE: common constructor, not to be used from outside.
 *          provided as common place for member initialization
 *          all the constructors should call it prior to doing anything specific.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
void CPersistor::CommonConstruct()
{
    // smart pointers are initialized by their constructors
    ASSERT (m_XMLElemCurrent.IsNull());
    ASSERT (m_XMLDocument.IsNull());

    m_bIsLoading = false;
    m_bLockedOnChild = false;
    m_dwModeFlags = persistorModeDefault; // the default mode.
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::BecomeAChildOf
 *
 * PURPOSE: Initialization (second part of construction) of a child persistor
 *          All members, inherited from the parent persistor, are initialized here
 *
 * PARAMETERS:
 *    CPersistor &persistorParent   - [in] (to be) parent persistor of current persistor
 *    CXMLElement elem              - [in] element on which current persistor is based
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CPersistor::BecomeAChildOf(CPersistor &persistorParent, CXMLElement elem)
{
    DECLARE_SC(sc, TEXT("CPersistor::BecomeAChildOf"));

    // assign the element
    m_XMLElemCurrent = elem;

    // we do not inherit m_bLockedOnChild from parent!!!
    m_bLockedOnChild = false;

    // inherited members are copied here
    m_XMLDocument = persistorParent.GetDocument();
    m_bIsLoading  = persistorParent.m_bIsLoading;
    m_dwModeFlags = persistorParent.m_dwModeFlags;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::CPersistor
 *
 * PURPOSE: construct a persistor from a parent persistor.
 *          this creates a new XML element with the given name,
 *          and everything persisted to the new persistor
 *          is persisted under this element.
 *
 * PARAMETERS:
 *    CPersistor &persistorParent       - parent persistor
 *    const CStr &strElementType        - element type [element tag in XML file]
 *    LPCTSTR szElementName             - "Name" attribute [optional]
 *
\***************************************************************************/
CPersistor::CPersistor(CPersistor &persistorParent, const CStr &strElementType, LPCTSTR szElementName /*= NULL*/)
{
    // initialize using common constructor
    CommonConstruct();

    CXMLElement elem;
    if (persistorParent.IsStoring())
        elem = persistorParent.AddElement(strElementType, szElementName);
    else if (persistorParent.m_bLockedOnChild)
    {
        // if we already have the child located - just take it from parent!
        // plus recheck to see it XML document actually has such an element
        elem = persistorParent.CheckCurrentElement(strElementType, szElementName);
    }
    else
        elem = persistorParent.GetElement(strElementType, szElementName);

    // construct child persistor on elem
    BecomeAChildOf(persistorParent, elem);
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::CPersistor
 *
 * PURPOSE: creates new persistor for XML document
 *
 * PARAMETERS:
 *    IXMLDocument * pDocument  - document
 *    CXMLElement &rElemCurrent - root element for persistor
 *
\***************************************************************************/
CPersistor::CPersistor(CXMLDocument &document, CXMLElement& rElemCurrent)
{
    // initialize using common constructor
    CommonConstruct();
    m_XMLDocument = document;
    m_XMLElemCurrent = rElemCurrent;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::CPersistor
 *
 * PURPOSE: Creates new persistor based on parent an supplied element
 *
 * PARAMETERS:
 *    const CPersistor &other       - parent persistor
 *    CXMLElement &rElemCurrent     - root element for persistor
 *    bool bLockedOnChild           - if new persistor should be a fake parent
 *                                    to be used to create persistors
 *
\***************************************************************************/
CPersistor::CPersistor(CPersistor &other, CXMLElement& rElemCurrent, bool bLockedOnChild /*= false*/)
{
    // initialize using common constructor
    CommonConstruct();

    // inherit...
    BecomeAChildOf(other, rElemCurrent);

    // this prevents locating the element on load (assuming the persistor is on element already)
    // used to load items for collections
    m_bLockedOnChild = bLockedOnChild;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::Persist
 *
 * PURPOSE: persists XML object
 *
 * PARAMETERS:
 *    LPCTSTR lpstrName     - "Name" attribute for element [optional = NULL]
 *    CXMLObject & object   - object to persist
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CPersistor::Persist(CXMLObject & object, LPCTSTR lpstrName /*= NULL*/)
{
    DECLARE_SC(sc, TEXT("CPersistor::Persist"));

    // persist w/o splitting if saved to string
    if (!object.UsesBinaryStorage() || !FEnableValueSplit())
    {
        // ordinary object;
        CPersistor persistorNew(*this,object.GetXMLType(),lpstrName);
        object.Persist(persistorNew);
    }
    else
    {
        // this element should be split in 2 places
        // see comment "CONCEPT OF BINARY STORAGE" in "xmbase.h"

        CXMLElement elemBinStorage = GetDocument().GetBinaryStorage();
        if (elemBinStorage.IsNull())
            sc.Throw(E_UNEXPECTED);

        // get elements enumeration in binaries
        CXMLElementCollection colChildren;
        elemBinStorage.getChildrenByName(XML_TAG_BINARY, &colChildren);

        long nChildren = 0;

        if (!colChildren.IsNull())
            colChildren.get_count(&nChildren);

        int iReffIndex = nChildren;

        // save reference instead of contents
        CPersistor persistorNew(*this, object.GetXMLType(), lpstrName);
        persistorNew.PersistAttribute(XML_ATTR_BINARY_REF_INDEX, iReffIndex);

        // persist the object
        CPersistor persistorBinaries(*this, elemBinStorage);
        // locate/create the element [cannot reuse constructor since we have collection here]
        CXMLElement elem;
        if (IsLoading())
        {
            // locate the element
            elem = persistorBinaries.GetElement(XML_TAG_BINARY, object.GetBinaryEntryName(), iReffIndex );
        }
        else
        {
            // storing - just create sub-persistor
            elem = persistorBinaries.AddElement(XML_TAG_BINARY, object.GetBinaryEntryName());
        }
        CPersistor persistorThisBinary(persistorBinaries, elem);

        // start from new line
        if (IsStoring())
        {
            persistorThisBinary.AddTextElement(CComBSTR(L"\n"));
        }

        object.Persist(persistorThisBinary);

        // new line after contents
        if (IsStoring())
        {
            CComBSTR bstrIndent;
            if (persistorThisBinary.GetCurrentElement().GetTextIndent(bstrIndent, false /*bForAChild*/))
                persistorThisBinary.AddTextElement(bstrIndent);
        }
    }
}


/***************************************************************************\
 *
 * METHOD:  CPersistor::Persist
 *
 * PURPOSE: persists XML value as stand-alone object
 *
 * PARAMETERS:
 *    CXMLValue xval        - value to persist
 *    LPCTSTR name          - "Name" attribute for element [optional = NULL]
*
* RETURNS:
*    void
*
\***************************************************************************/
void
CPersistor::Persist(CXMLValue xval, LPCTSTR name /*= NULL*/)
{
    if (xval.UsesBinaryStorage())
    {
        // binary value to be saved to Binary storage.
        // see comment "CONCEPT OF BINARY STORAGE" in "xmbase.h"
        // wrap it into special object, which handles it and pass to Perist method
        CXMLBinaryValue val(xval);
        Persist(val, name);
    }
    else
    {
        // standard value, persist as ordinary element
        CPersistor   persistorNew(*this,xval.GetTypeName(),name);
        persistorNew.PersistContents(xval);
    }
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistAttribute
 *
 * PURPOSE: Persists attribute
 *
 * PARAMETERS:
 *    LPCTSTR name                  - Name of attribute
 *    CXMLValue xval                - Value of attribute
 *    const XMLAttributeType type   - type of attribute [ required/ optional ]
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CPersistor::PersistAttribute(LPCTSTR name, CXMLValue xval, const XMLAttributeType type /*= attr_required*/)
{
    DECLARE_SC(sc, TEXT("CPersistor::PersistAttribute"));

    if(IsLoading())
    {
        CComBSTR bstrPropertyValue;
        bool bValueSupplied = GetCurrentElement().getAttribute(name, bstrPropertyValue);

        if (bValueSupplied)
        {
            sc = xval.ScReadFromBSTR(bstrPropertyValue);
            if (sc)
                sc.Throw(E_FAIL);
        }
        else if (type != attr_optional)
            sc.Throw(E_FAIL);
    }
    else    // IsStoring
    {
        CComBSTR bstr; // must be empty!
        sc = xval.ScWriteToBSTR(&bstr);
        if (sc)
            sc.Throw();
        GetCurrentElement().setAttribute(name, bstr);
    }

}


/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistContents
 *
 * PURPOSE: perists XMLValues as a contents of xml element
 *          <this_element>persisted_contents</this_element>
 *          to be used insted of PersistAttribute where apropriate
 *
 * PARAMETERS:
 *    CXMLValue xval    - value to persist as contents of the element
 *
 * NOTE:    element cannot have both value-as-contents and sub-elements
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void
CPersistor::PersistContents(CXMLValue xval)
{
    DECLARE_SC(sc, TEXT("CPersistor::PersistContents"));

    if (IsStoring())
    {
        CComBSTR bstr; // must be empty!
        sc = xval.ScWriteToBSTR(&bstr);
        if (sc)
            sc.Throw();

        AddTextElement(bstr);
    }
    else
    {
        CComBSTR bstrPropertyValue;
        GetTextElement(bstrPropertyValue);

        sc = xval.ScReadFromBSTR(bstrPropertyValue);
        if (sc)
            sc.Throw();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::AddElement
 *
 * PURPOSE: Creates a new element below this element with the specified name.
 *          All persistence to the new persistor will write underneath this
 *          new element.
 *
 * PARAMETERS:
 *    const       CStr :
 *    CPersistor& persistorNew :
 *
 * RETURNS:
 *    CXMLElement - created child element
 *
 *+-------------------------------------------------------------------------*/
CXMLElement
CPersistor::AddElement(const CStr &strElementType, LPCTSTR szElementName)
{
    DECLARE_SC(sc, TEXT("CPersistor::AddElement"));

    CXMLElement elem;
    GetDocument().createElement(NODE_ELEMENT, CComBSTR(strElementType), &elem);

    CComBSTR bstrIndent;
    if (GetCurrentElement().GetTextIndent(bstrIndent, true /*bForAChild*/))
        AddTextElement(bstrIndent);

    GetCurrentElement().addChild(elem);  // add the new element to the end.

    if (szElementName)
    {
        CPersistor persistorNew(*this, elem);
        persistorNew.SetName(szElementName);
    }

    // sub element was added - that means this element will have a closing tag
    // add the indent for it in advance
    if (GetCurrentElement().GetTextIndent(bstrIndent, false /*bForAChild*/))
        AddTextElement(bstrIndent);

    return elem;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::AddTextElement
 *
 * PURPOSE: creates new element of type "text"
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CXMLElement - created child element
 *
\***************************************************************************/
void
CPersistor::AddTextElement(BSTR bstrData)
{
    DECLARE_SC(sc, TEXT("CPersistor::AddTextElement"));

    CXMLElement elem;
    GetDocument().createElement(NODE_TEXT, bstrData, &elem);
    GetCurrentElement().addChild(elem);  // add the new element to the end.
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::GetElement
 *
 * PURPOSE: Retrievs child element of the current element with the specified type [and name].
 *          All persistence to the new persistor will read underneath this element.
 *
 * PARAMETERS:
 *    const CStr& strElementType  : type name of the element
 *    LPCTSTR szElementName       : name of the element or NULL if doesn't matter
 *    int iIndex                  : index of the element [optional = -1]
 *
 * RETURNS:
 *    CXMLElement   - resulting new element
 *
 *+-------------------------------------------------------------------------*/
CXMLElement
CPersistor::GetElement(const CStr &strElementType, LPCTSTR szElementName, int iIndex /*= -1*/ )
{
    DECLARE_SC(sc, TEXT("CPersistor::GetElement"));
    CXMLElement elem;

    CXMLElementCollection colChildren;
    GetCurrentElement().getChildrenByName(strElementType, &colChildren);

    long nChildren = 0;

    if (!colChildren.IsNull())
        colChildren.get_count(&nChildren);

    if (nChildren == 0)
        sc.Throw(E_FAIL);

    long nChild = 0;
    if (iIndex >= 0)
    {
        // limit iteration to one loop, if we have index supplied
        nChild = iIndex;
        nChildren = iIndex + 1;
    }
    for (; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            if (szElementName)
            {
                CPersistor temp(*this,el);
                CStr strName(temp.GetName());
                if (0 != strName.CompareNoCase(szElementName))
                    continue;
            }
            elem = el;
            break;
        }
    }

    if(elem.IsNull())
        sc.Throw(E_FAIL);

    return elem;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::GetTextElement
 *
 * PURPOSE: Gets text element attached to the new element
 *          NOTE: returned CPersistor may have current element equal NULL -
 *                this should indicate to caller that the contents is empty
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CXMLElement   - resulting new element
 *
\***************************************************************************/
void
CPersistor::GetTextElement(CComBSTR &bstrData)
{
    DECLARE_SC(sc, TEXT("CPersistor::GetTextElement"));

    bstrData = L"";

    CXMLElement elem;

    CXMLElementCollection colChildren;
    GetCurrentElement().get_children(&colChildren);

    long nChildren = 0;

    if (!colChildren.IsNull())
        colChildren.get_count(&nChildren);

    if (nChildren == 0)
        return; // no text element means "there is no contents"

    for (long nChild = 0; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            DOMNodeType lType = NODE_INVALID;
            el.get_type(&lType);
            if (lType == NODE_TEXT)
            {
                elem = el;
                break;
            }
        }
    }

    if (elem.IsNull())
        return;

    elem.get_text(bstrData);
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::HasElement
 *
 * PURPOSE: checks if persistor has a specified element
 *
 * PARAMETERS:
 *    const       CStr& strElementType  : type name of the element
 *    LPCTSTR szElementName             : name of the element or NULL if doesn't matter
 *
 * RETURNS:
 *    bool       true == requested element exist
 *
 *+-------------------------------------------------------------------------*/
bool
CPersistor::HasElement(const CStr &strElementType, LPCTSTR szElementName)
{
    DECLARE_SC(sc, TEXT("CPersistor::HasElement"));

    if(GetCurrentElement().IsNull())
        sc.Throw(E_POINTER);

    CXMLElementCollection colChildren;
    GetCurrentElement().getChildrenByName(strElementType, &colChildren);

    if (colChildren.IsNull())
        return false;

    long nChildren = 0;
    colChildren.get_count(&nChildren);

    if (nChildren == 0)
        return false;

    for (long nChild = 0; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            if (szElementName)
            {
                CPersistor temp(*this,el);
                CStr strName(temp.GetName());
                if (0 != strName.CompareNoCase(szElementName))
                    continue;
            }
            return true;
        }
    }

    return false;
}

/*+-------------------------------------------------------------------------*
 *
 * CPersistor::CheckCurrentElement
 *
 * PURPOSE: Checks if current element is of specified type [and name]
 *          used to check collection elements
 *
 * PARAMETERS:
 *    const     CStr& strElementType    : type name of the element
 *    LPCTSTR   szElementName           : name of the element or NULL if doesn't matter
 *
 * RETURNS:
 *    CXMLElement   - pointer to current element
 *
 *+-------------------------------------------------------------------------*/
CXMLElement
CPersistor::CheckCurrentElement(const CStr &strElementType, LPCTSTR szElementName)
{
    DECLARE_SC(sc, TEXT("CPersistor::CheckCurrentElement"));

    CXMLElement elem = GetCurrentElement();

    if(elem.IsNull())
        sc.Throw(E_POINTER);

    CStr strTagName;
    elem.get_tagName(strTagName);
    if (0 != strTagName.CompareNoCase(strElementType))
        sc.Throw(E_FAIL);

    if (szElementName)
    {
        CPersistor temp(*this, elem);
        CStr strName(temp.GetName());
        if (0 != strName.CompareNoCase(szElementName))
            sc.Throw(E_FAIL);
    }

    return elem;
}

void
CPersistor::SetName(const CStr &strName)
{
    DECLARE_SC(sc, TEXT("CPersistor::SetName"));
    CStr _strName = strName;
    ASSERT(IsStoring());
    PersistAttribute(XML_ATTR_NAME, _strName);
}

CStr
CPersistor::GetName()
{
    DECLARE_SC(sc, TEXT("CPersistor::GetName"));
    CStr _strName;
    ASSERT(IsLoading());
    // just return empty string if there is no name
    PersistAttribute(XML_ATTR_NAME, _strName, attr_optional);
    return _strName;
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistString
 *
 * PURPOSE: persists stringtable string
 *
 * PARAMETERS:
 *    const CStr &strTag            - tag name for the new element
 *    CStringTableStringBase &str   - string to persist
 *    LPCTSTR lpstrName             - name [optional]
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CPersistor::PersistString(LPCTSTR lpstrName, CStringTableStringBase &str)
{
    DECLARE_SC(sc, TEXT("CPersistor::PersistString"));

    USES_CONVERSION;

    CPersistor subPersistor(*this, XML_TAG_STRING_TABLE_STRING, lpstrName);
    if (subPersistor.IsLoading())
    {
        str.m_id = CStringTableStringBase::eNoValue;
        str.m_str.erase();

        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_ID, str.m_id, attr_optional);
        if (str.m_id != CStringTableStringBase::eNoValue)
        {

            sc = ScCheckPointers(str.m_spStringTable);
            if (sc)
                sc.Throw();

            ULONG cch = 0;
            sc = str.m_spStringTable->GetStringLength (str.m_id, &cch, NULL);
            if (sc)
                sc.Throw();

            // allow for NULL terminator
            cch++;
            std::auto_ptr<WCHAR> spszText (new (std::nothrow) WCHAR[cch]);
            LPWSTR pszText = spszText.get();

            sc = ScCheckPointers(pszText,E_OUTOFMEMORY);
            if (sc)
                sc.Throw();

            sc = str.m_spStringTable->GetString (str.m_id, cch, pszText, NULL, NULL);
            if (sc)
                sc.Throw();

            str.m_str = W2T (pszText);

            return;
        }
        std::wstring text;
        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_VALUE, text, attr_optional);
        str.m_str = W2CT(text.c_str());
        return;
    }

    str.CommitToStringTable();
    if (FEnableValueSplit() && str.m_id != CStringTableStringBase::eNoValue)
    {
#ifdef DBG
        /*
         * make sure CommitToStringTable really committed
         */
        if (str.m_id != CStringTableStringBase::eNoValue)
        {
            WCHAR sz[256];
            ASSERT (str.m_spStringTable != NULL);
            HRESULT hr = str.m_spStringTable->GetString (str.m_id, countof(sz), sz, NULL, NULL);
            ASSERT (SUCCEEDED(hr) && "Persisted a CStringTableString to a stream that's not in the string table");
        }
#endif
        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_ID, str.m_id);
    }
    else
    {
        if (str.m_id == CStringTableStringBase::eNoValue)
            str.m_str.erase();
        subPersistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_VALUE, str.m_str);
    }
}

/***************************************************************************\
 *
 * METHOD:  CPersistor::PersistAttribute
 *
 * PURPOSE: special method to persist bitflags
 *
 * PARAMETERS:
 *    LPCTSTR name          [in] name of the flags
 *    CXMLBitFlags& flags   [in] flags to persist
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CPersistor::PersistAttribute(LPCTSTR name, CXMLBitFlags& flags )
{
    flags.PersistMultipleAttributes(name, *this);
}

//############################################################################
//############################################################################
//
//  Implementation of class XMLPoint
//
//############################################################################
//############################################################################
XMLPoint::XMLPoint(const CStr &strObjectName, POINT &point)
:m_strObjectName(strObjectName), m_point(point)
{
}

/*+-------------------------------------------------------------------------*
 *
 * XMLPoint::Persist
 *
 * PURPOSE: Persists an XMLPoint to a persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
XMLPoint::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLPoint::Persist"));
    if (persistor.IsStoring())
        persistor.SetName(m_strObjectName);
    persistor.PersistAttribute(XML_ATTR_POINT_X, m_point.x);
    persistor.PersistAttribute(XML_ATTR_POINT_Y, m_point.y);
}

//############################################################################
//############################################################################
//
//  Implementation of class XMLRect
//
//############################################################################
//############################################################################
XMLRect::XMLRect(const CStr strObjectName, RECT &rect)
:m_strObjectName(strObjectName), m_rect(rect)
{
}

void
XMLRect::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLRect::Persist"));
    if (persistor.IsStoring())
        persistor.SetName(m_strObjectName);
    persistor.PersistAttribute(XML_ATTR_RECT_TOP,       m_rect.top);
    persistor.PersistAttribute(XML_ATTR_RECT_BOTTOM,    m_rect.bottom);
    persistor.PersistAttribute(XML_ATTR_RECT_LEFT,      m_rect.left);
    persistor.PersistAttribute(XML_ATTR_RECT_RIGHT,     m_rect.right);
}

//############################################################################
//############################################################################
//
//  Implementation of class CXMLValue
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CXMLValue::GetTypeName
 *
 * PURPOSE: returns tag name (usually type name) to be used as element tag
 *          when value is persisted as element via CPersistor.Persist(val)
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    LPCTSTR    - tag name
 *
\***************************************************************************/
LPCTSTR CXMLValue::GetTypeName() const
{
    switch(m_type)
    {
    case XT_I4 :        return XML_TAG_VALUE_LONG;
    case XT_UI4 :       return XML_TAG_VALUE_ULONG;
    case XT_UI1 :       return XML_TAG_VALUE_BYTE;
    case XT_I2 :        return XML_TAG_VALUE_SHORT;
    case XT_DW :        return XML_TAG_VALUE_DWORD;
    case XT_BOOL :      return XML_TAG_VALUE_BOOL;
    case XT_CPP_BOOL :  return XML_TAG_VALUE_BOOL;
    case XT_UINT :      return XML_TAG_VALUE_UINT;
    case XT_INT  :      return XML_TAG_VALUE_INT;
    case XT_STR :       return XML_TAG_VALUE_CSTR;
    case XT_WSTR :      return XML_TAG_VALUE_WSTRING;
    case XT_GUID :      return XML_TAG_VALUE_GUID;
    case XT_BINARY :    return XML_TAG_VALUE_BIN_DATA;
    case XT_EXTENSION:  return m_val.pExtension->GetTypeName();
    default:            return XML_TAG_VALUE_UNKNOWN;
    }
}


/***************************************************************************\
 *
 * METHOD:  CXMLValue::ScWriteToBSTR
 *
 * PURPOSE: Converts an XML value to a bstring.
 *          internally uses WCHAR buffer on the stack for the conversion of integer
 *          types.
 *
 * PARAMETERS:
 *    BSTR * pbstr  - [out] resulting string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLValue::ScWriteToBSTR (BSTR * pbstr) const
{
    DECLARE_SC(sc, TEXT("CXMLValue::ScWriteToBSTR"));

    // check parameter
    sc = ScCheckPointers(pbstr);
    if (sc)
        return sc;

    // initialize
    *pbstr = NULL;

    WCHAR szBuffer[40];
    CComBSTR bstrResult;
    USES_CONVERSION;

    switch(m_type)
    {
    case XT_I4:  //LONG
        swprintf(szBuffer, L"%d\0", *m_val.pL);
        bstrResult = szBuffer;
        break;

    case XT_UI4:  //LONG
        swprintf(szBuffer, L"%u\0", *m_val.pUl);
        bstrResult = szBuffer;
        break;

    case XT_UI1: //BYTE
        swprintf(szBuffer, L"0x%02.2x\0", (int)*m_val.pByte);
        bstrResult = szBuffer;
        break;

    case XT_I2:  //SHORT
        swprintf(szBuffer, L"%d\0", (int)*m_val.pS);
        bstrResult = szBuffer;
        break;

    case XT_DW:  //DWORD
        swprintf(szBuffer, L"0x%04.4x\0", *m_val.pDw);
        bstrResult = szBuffer;
        break;

    case XT_BOOL://BOOL: can either print true/false
        bstrResult = ( *m_val.pBOOL ? XML_VAL_BOOL_TRUE : XML_VAL_BOOL_FALSE );
        break;

    case XT_CPP_BOOL://bool: can either print true/false
        bstrResult = ( *m_val.pbool ? XML_VAL_BOOL_TRUE : XML_VAL_BOOL_FALSE );
        break;

    case XT_UINT:  //UINT
        swprintf(szBuffer, L"%u\0", *m_val.pUint);
        bstrResult = szBuffer;
        break;

    case XT_INT:  //UINT
        swprintf(szBuffer, L"%d\0", *m_val.pInt);
        bstrResult = szBuffer;
        break;

    case XT_STR: //CStr
        bstrResult = T2COLE(static_cast<LPCTSTR>(*m_val.pStr));
        break;

    case XT_WSTR: //wstring
        bstrResult = m_val.pWStr->c_str();
        break;

    case XT_TSTR: //tstring
        bstrResult = T2COLE(m_val.pTStr->c_str());
        break;

    case XT_GUID: //GUID
        {
            LPOLESTR sz;
            StringFromCLSID(*m_val.pGuid, &sz);
            bstrResult = sz;
            CoTaskMemFree(sz);
        }
        break;

    case XT_BINARY:
        sc = ScEncodeBinary(bstrResult, *m_val.pXmlBinary);
        if (sc)
            return sc;

        break;

    case XT_EXTENSION:
        sc = m_val.pExtension->ScWriteToBSTR (&bstrResult);
        if (sc)
            return sc;

        break;

    default:
        //ASSERT(0 && "Should not come here!!");
        return sc = E_NOTIMPL;
    }

    *pbstr = bstrResult.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLValue::ScReadFromBSTR
 *
 * PURPOSE: Converts a string an XML value
 *
 * PARAMETERS:
 *    const BSTR bstr - [in] string to be read
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLValue::ScReadFromBSTR(const BSTR bstr)
{
    DECLARE_SC(sc, TEXT("CXMLValue::ScReadFromBSTR"));

    LPCOLESTR olestr = bstr;
    if (olestr == NULL)     // make sure we always have a valid pointer
        olestr = L"";       // in case of NULL we use own empty string

    USES_CONVERSION;
    switch(m_type)
    {
    case XT_I4:  //LONG
        *m_val.pL = wcstol(olestr,NULL,10);
        break;

    case XT_UI4:  //LONG
        *m_val.pUl = wcstoul(olestr,NULL,10);
        break;

    case XT_UI1: //BYTE
        *m_val.pByte = static_cast<BYTE>(wcstol(olestr,NULL,10));
        break;

    case XT_I2:  //SHORT
        *m_val.pS = static_cast<SHORT>(wcstol(olestr,NULL,10));
        break;

    case XT_DW:  //DWORD
        *m_val.pDw = wcstoul(olestr,NULL,10);
        break;

    case XT_BOOL://BOOL: can either be true/false
        *m_val.pBOOL = (0 == _wcsicmp(olestr, T2CW(XML_VAL_BOOL_TRUE)));
        break;

    case XT_CPP_BOOL://bool: can either be true/false
        *m_val.pbool = (0 == _wcsicmp(olestr, T2CW(XML_VAL_BOOL_TRUE)));
        break;

    case XT_UINT:  //UINT
        *m_val.pUint = wcstoul(olestr,NULL,10);
        break;

    case XT_INT:  //UINT
        *m_val.pInt = wcstol(olestr,NULL,10);
        break;

    case XT_STR: //CStr
        *m_val.pStr = OLE2CT(olestr);
        break;

    case XT_WSTR: //CString
        *m_val.pWStr = olestr;
        break;

    case XT_TSTR: //tstring
        *m_val.pTStr = OLE2CT(olestr);
        break;

    case XT_GUID: //GUID
        sc = CLSIDFromString(const_cast<LPOLESTR>(olestr), m_val.pGuid);
        if (sc)
            return sc;

        break;

    case XT_BINARY:
        sc = ScDecodeBinary(olestr, m_val.pXmlBinary);
        if (sc)
            return sc;

        break;

    case XT_EXTENSION:
        sc = m_val.pExtension->ScReadFromBSTR(bstr);
        if (sc)
            return sc;

        break;

    default:
        //ASSERT(0 && "Should not come here!!");
        return sc = E_NOTIMPL;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: XMLListCollectionBase::Persist
 *
 * PURPOSE: implements persisting of list contents from XML file
 *          iterates child elements calling virtual mem. OnNewElement for each
 *
 * PARAMETERS:
 *    CPersistor& persistorNew          : persistor object
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void XMLListCollectionBase::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLListCollectionBase::Persist"));
    ASSERT(persistor.IsLoading());

    CXMLElementCollection colChildren;
    persistor.GetCurrentElement().get_children(&colChildren);

    if (colChildren.IsNull())
    {
        // no children -> we are done!
        return;
    }

    long nChildren = 0;
    colChildren.get_count(&nChildren);

    for (long nChild = 0; nChild < nChildren; nChild++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            DOMNodeType lType = NODE_INVALID;
            el.get_type(&lType);

            if (lType == NODE_ELEMENT)
            {
                CPersistor persistorNewLocked(persistor, el, true);
                OnNewElement(persistorNewLocked);
            }
        }
    }
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: XMLMapCollectionBase::Persist
 *
 * PURPOSE: implements persisting of map contents from XML file
 *          iterates child elements calling virtual mem. OnNewElement for each pair
 *
 * PARAMETERS:
 *    CPersistor& persistorNew          : persistor object
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void XMLMapCollectionBase::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("XMLMapCollectionBase::Persist"));
    ASSERT(persistor.IsLoading());

    CXMLElementCollection colChildren;
    persistor.GetCurrentElement().get_children(&colChildren);

    if (colChildren.IsNull())
    {
        // no children -> we are done!
        return;
    }

    long nChildren = 0;
    colChildren.get_count(&nChildren);

    // collect all elements of proper type
    std::vector<CXMLElement> vecChilds;

    for (long nChild = 0; nChild < nChildren; nChild ++)
    {
        CXMLElement el;
        colChildren.item(nChild, &el);

        if (!el.IsNull())
        {
            DOMNodeType lType = NODE_INVALID;
            el.get_type(&lType);

            if (lType == NODE_ELEMENT)
                vecChilds.push_back(el);
        }
    }


    for (nChild = 0; nChild + 1 < vecChilds.size(); nChild += 2)
    {
        CXMLElement el(vecChilds[nChild]);
        CXMLElement el2(vecChilds[nChild+1]);

        CPersistor persistorNew1(persistor, el, true);
        CPersistor persistorNew2(persistor, el2, true);
        OnNewElement(persistorNew1,persistorNew2);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * ScEncodeBinary
 *
 * PURPOSE: converts data to encoded format for xml
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC - error code
 *
 *+-------------------------------------------------------------------------*/
static SC ScEncodeBinary(CComBSTR& bstrResult, const CXMLBinary& binSrc)
{
    DECLARE_SC(sc, TEXT("ScEncodeBinary"));

    // initialize
    bstrResult.Empty();

    // nothing if binary is zero size...
    if (binSrc.GetSize() == 0)
        return sc;

    // line length for the binary data. maximum allowed by base64 per line is 76
    const int   line_len = 76;
    // symbols to be placed as terminators of each line
    const WCHAR line_end[] = { 0x0d, 0x0a };
    DWORD dwBytesLeft = binSrc.GetSize();
    // space required for encription
    DWORD dwCount = (dwBytesLeft*8+5)/6;
    // ... plus up to three '='
    dwCount += (4 - dwCount%4) & 0x03;
    // allow space for white_spaces inerted and terminating zero
    dwCount += (dwCount / line_len)*countof(line_end) + 1;

    BOOL bOk = SysReAllocStringLen(&bstrResult,NULL,dwCount);
    if (bOk != TRUE || (LPOLESTR)bstrResult == NULL)
        return sc = E_OUTOFMEMORY;

    LPOLESTR pstrResult = bstrResult;
    *pstrResult = 0;

    if (!dwBytesLeft)
        return sc; // emty seq? - we are done

    const BYTE *pData = NULL;
    sc = binSrc.ScLockData((const void **)&pData);
    if (sc)
        return sc;

    sc = ScCheckPointers(pData, E_UNEXPECTED);
    if(sc)
        return sc;

    DWORD dwCharsStored = 0;
    while (dwBytesLeft)
    {
        base64_table::encode(pData, dwBytesLeft, pstrResult);
        dwCharsStored += 4;
        if (0 == (dwCharsStored % line_len) && dwBytesLeft)
            for (int i = 0; i < countof(line_end); i++)
                *pstrResult++ = line_end[i];
    }

    // terminate
    *pstrResult = 0;

    sc = binSrc.ScUnlockData();
    if (sc)
        sc.TraceAndClear();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScDecodeBinary
 *
 * PURPOSE: converts encoded data back to image
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
static SC ScDecodeBinary(const CComBSTR& bstrSource, CXMLBinary *pBinResult)
{
    DECLARE_SC(sc, TEXT("ScDecodeBinary"));

    DWORD  dwCount = bstrSource.Length();
    DWORD  dwSize = (dwCount*6+7)/8;

    sc = ScCheckPointers(pBinResult);
    if (sc)
        return sc;

    sc = pBinResult->ScFree(); // ignore the error here
    if (sc)
        sc.TraceAndClear();

    if (!dwSize) // no data? - good
        return sc;

    sc = pBinResult->ScAlloc(dwSize);
    if(sc)
        return sc;

    CXMLBinaryLock sLock(*pBinResult);

    BYTE *pData = NULL;
    sc = sLock.ScLock(&pData);
    if(sc)
        return sc;

    // recheck
    sc = ScCheckPointers(pData, E_UNEXPECTED);
    if (sc)
        return sc;

    BYTE * const pDataStart = pData;

    LPOLESTR pInput = bstrSource;

    while(base64_table::decode(pInput, pData));

    sc = sLock.ScUnlock();
    if (sc)
        sc.TraceAndClear();

    DWORD dwDataDecoded = pData - pDataStart;

    // fix data size , if required

    if (dwDataDecoded != dwSize)
    {
        if (dwDataDecoded == 0)
            sc = pBinResult->ScFree();
        else
            sc = pBinResult->ScRealloc(dwDataDecoded);

        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStorage::ScInitialize
 *
 * PURPOSE: Initializes object. Creates new storage if does not have one
 *
 * PARAMETERS:
 *    bool& bCreatedNewOne  [out] - created new stream
 *
 * RETURNS:
 *    SC    - result code.
 *
\***************************************************************************/
SC CXML_IStorage::ScInitialize(bool& bCreatedNewOne)
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScInitialize"));

    // short cut if initialized oalready
    if (m_Storage != NULL)
    {
        bCreatedNewOne = false;
        return sc;
    }

    bCreatedNewOne = true;

    // create the ILockBytes
    sc = CreateILockBytesOnHGlobal(NULL, TRUE, &m_LockBytes);
    if(sc)
        return sc;

    // create the IStorage
    sc = StgCreateDocfileOnILockBytes( m_LockBytes, 
                                       STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                       0, &m_Storage);
    if(sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStorage::ScInitializeFrom
 *
 * PURPOSE: Initializes object. copies contents from provided source
 *
 * PARAMETERS:
 *    IStorage *pSource [in] initial contents of the storage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStorage::ScInitializeFrom( IStorage *pSource )
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScInitializeFrom"));

    // parameter check
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // init empty
    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize(bCreatedNewOne);
    if (sc)
        return sc;

    ASSERT( m_Storage != NULL );

    // copy contents
    sc = pSource->CopyTo( 0, NULL, NULL, m_Storage );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStorage::ScGetIStorage
 *
 * PURPOSE: returns pointer to maintained storage.
 *
 * PARAMETERS:
 *    IStorage **ppStorage [out] pointer to the storage
 *
 * RETURNS:
 *    SC    - result code. 
 *
\***************************************************************************/
SC CXML_IStorage::ScGetIStorage( IStorage **ppStorage )
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScGetIStorage"));

    // parameter check
    sc = ScCheckPointers( ppStorage );
    if (sc)
        return sc;

    // init out parameter
    *ppStorage = NULL;

    // make sure we have storage - initialize
    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    // recheck if the member is set
    sc = ScCheckPointers ( m_Storage, E_UNEXPECTED );
    if (sc)
        return sc;

    // return the pointer
    *ppStorage = m_Storage;
    (*ppStorage)->AddRef();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: CXML_IStorage::ScRequestSave
 *
 * PURPOSE: asks snapin to save using snapin's IPersistStorage
 *
 *+-------------------------------------------------------------------------*/
SC
CXML_IStorage::ScRequestSave( IPersistStorage * pPersistStorage )
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::ScRequestSave"));

    bool bCreatedNewOne = false;
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers( m_Storage, E_UNEXPECTED );
    if (sc)
        return sc;

    sc = pPersistStorage->Save(m_Storage, !bCreatedNewOne);
    if(sc)
        return sc;

    sc = pPersistStorage->SaveCompleted(NULL);
    // we were always passing a storage in MMC 1.2, so some of the
    // snapins did not expect it to be NULL (which is correct value when
    // storage does not change)
    // to be able to save such snapins we need to to ignore this error
    // see bug 96344
    if (sc == SC(E_INVALIDARG))
    {
		#ifdef DBG
            m_dbg_Data.TraceErr(_T("IPersistStorage::SaveCompleted"), _T("legal argument NULL passed to snapin, but error returned"));
		#endif

        sc = pPersistStorage->SaveCompleted(m_Storage);
    }

    if(sc)
        return sc;

    // commit the changes - this ensures everything is in HGLOBAL
    sc = m_Storage->Commit( STGC_DEFAULT );
    if(sc)
        return sc;

#ifdef DBG
    if (S_FALSE != pPersistStorage->IsDirty())
        m_dbg_Data.TraceErr(_T("IPersistStorage"), _T("Reports 'IsDirty' right after 'Save'"));
#endif // #ifdef DBG

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * m_Storage: CXML_IStorage::Persist
 *
 * PURPOSE: dumps data to HGLOBAL and persists
 *
 *+-------------------------------------------------------------------------*/
void
CXML_IStorage::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CXML_IStorage::Persist"));

    if (persistor.IsStoring())
    {
        bool bCreatedNewOne = false; // not used here
        sc = ScInitialize( bCreatedNewOne );
        if (sc)
            sc.Throw();

        HANDLE hStorage = NULL;
        sc = GetHGlobalFromILockBytes(m_LockBytes, &hStorage);
        if(sc)
            sc.Throw();

        STATSTG statstg;
        ZeroMemory(&statstg, sizeof(statstg));

        sc = m_LockBytes->Stat(&statstg, STATFLAG_NONAME);
        if (sc)
            sc.Throw();

        CXMLBinary binInitial;
        binInitial.Attach(hStorage, statstg.cbSize.LowPart);

        // persist the contents
        persistor.PersistContents(binInitial);

        return; // done
    }

    //--- Loading ---
    CXMLAutoBinary binLoaded;
    persistor.PersistContents(binLoaded);

    // Need to recreate storage...
    ASSERT(persistor.IsLoading()); // should not reallocate else!!
    m_LockBytes = NULL;

    ULARGE_INTEGER new_size = { binLoaded.GetSize(), 0 };
    sc = CreateILockBytesOnHGlobal(binLoaded.GetHandle(), TRUE, &m_LockBytes);
    if(sc)
        sc.Throw();

    // control transferred to ILockBytes
    binLoaded.Detach();

    sc = m_LockBytes->SetSize(new_size);
    if(sc)
        sc.Throw();

    sc = StgOpenStorageOnILockBytes(m_LockBytes, NULL , STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                    NULL, 0, &m_Storage);
    if(sc)
        sc.Throw();
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScInitialize
 *
 * PURPOSE: initializes object. creates empty stream if does not have one
 *
 * PARAMETERS:
 *    bool& bCreatedNewOne  [out] - created new stream
 *
 * RETURNS:
 *    SC    - result code. 
 *
\***************************************************************************/
SC CXML_IStream::ScInitialize( bool& bCreatedNewOne )
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScInitialize"));

    if (m_Stream != NULL)
    {
        bCreatedNewOne = false;
        return sc;
    }

    bCreatedNewOne = true;

    sc = CreateStreamOnHGlobal( NULL, TRUE, &m_Stream);
    if(sc)
        return sc;

    const ULARGE_INTEGER zero_size = {0,0};
    sc = m_Stream->SetSize(zero_size);
    if(sc)
        return sc;

    sc = ScSeekBeginning();
    if(sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScInitializeFrom
 *
 * PURPOSE: Initializes object. Copies contents from provided source
 *
 * PARAMETERS:
 *    IStream *pSource [in] initial contents of the stream
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStream::ScInitializeFrom( IStream *pSource )
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScInitializeFrom"));

    // parameter check
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // initialize empty
    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    ASSERT( m_Stream != NULL );

    // reset stream pointer
    sc = ScSeekBeginning();
    if(sc)
        return sc;

    // copy contents from source
    STATSTG statstg;
    sc = pSource->Stat(&statstg, STATFLAG_NONAME);
    if (sc)
       return sc;

    // copy contents
    ULARGE_INTEGER cbRead;
    ULARGE_INTEGER cbWritten;
    sc = pSource->CopyTo( m_Stream, statstg.cbSize, &cbRead, &cbWritten );
    if (sc)
       return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScSeekBeginning
 *
 * PURPOSE: resets stream pointer to the beginning of the stream
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStream::ScSeekBeginning()
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScSeekBeginning"));
    
    LARGE_INTEGER null_offset = { 0, 0 };
    sc = m_Stream->Seek(null_offset, STREAM_SEEK_SET, NULL);
    if(sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXML_IStream::ScGetIStream
 *
 * PURPOSE: returns the pointer to maintained stream
 *
 * PARAMETERS:
 *    IStream **ppStream
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXML_IStream::ScGetIStream( IStream **ppStream )
{
    DECLARE_SC(sc, TEXT("CXML_IStream::ScGetIStream"));

    // parameter check
    sc = ScCheckPointers( ppStream );
    if (sc)
        return sc;

    // init out parameter
    *ppStream = NULL;

    bool bCreatedNewOne = false; // not used here
    sc = ScInitialize( bCreatedNewOne );
    if (sc)
        return sc;

    sc = ScSeekBeginning();
    if (sc)
        return sc;

    // recheck if the member is set
    sc = ScCheckPointers ( m_Stream, E_UNEXPECTED );
    if (sc)
        return sc;
    
    *ppStream = m_Stream;
    (*ppStream)->AddRef();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: CXML_IStream::Persist
 *
 * PURPOSE: persist data of maintained IStream
 *
 * NOTE: Object may point to another Stream after this method
 *
 *+-------------------------------------------------------------------------*/
void
CXML_IStream::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CXML_IStream::Persist"));

    if (persistor.IsStoring())
    {
        bool bCreatedNewOne = false; // not used here
        sc = ScInitialize( bCreatedNewOne );
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(m_Stream, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        HANDLE hStream = NULL;
        sc = GetHGlobalFromStream( m_Stream, &hStream );
        if(sc)
            sc.Throw();

        STATSTG statstg;
        ZeroMemory(&statstg, sizeof(statstg));

        sc = m_Stream->Stat(&statstg, STATFLAG_NONAME);
        if (sc)
            sc.Throw();

        CXMLBinary binInitial;
        binInitial.Attach(hStream, statstg.cbSize.LowPart);

        // persist the contents
        persistor.PersistContents(binInitial);

        return; // done
    }

    //--- Loading ---
    CXMLAutoBinary binLoaded;
    persistor.PersistContents(binLoaded);

    // Need to recreate stream...
    ULARGE_INTEGER new_size = { binLoaded.GetSize(), 0 };
    sc = CreateStreamOnHGlobal(binLoaded.GetHandle(), TRUE, &m_Stream);
    if(sc)
        sc.Throw();

    // control transferred to IStream
    binLoaded.Detach();

    sc = m_Stream->SetSize(new_size);
    if(sc)
        sc.Throw();

    // reset stream pointer
    sc = ScSeekBeginning();
    if(sc)
        sc.Throw();
}

/***************************************************************************\
| trace support helper for CHK builds
\***************************************************************************/
#ifdef DBG
void CXML_IStream::DBG_TraceNotResettingDirty(LPCSTR strIntfName)
{
    USES_CONVERSION;
    tstring inft = A2CT(strIntfName); // get the name of interface
    inft.erase(inft.begin(), inft.begin() + strlen("struct "));  // cut the 'struct' off

    m_dbg_Data.TraceErr(inft.c_str(), _T("Reports 'IsDirty' right after 'Save'"));
}
#endif

/*+-------------------------------------------------------------------------*
 *
 * METHOD: CXMLPersistableIcon::Persist
 *
 * PURPOSE: persists icon contents
 *
 *+-------------------------------------------------------------------------*/

void CXMLPersistableIcon::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CXMLPersistableIcon::Persist"));

    persistor.PersistAttribute(XML_ATTR_ICON_INDEX, m_Icon.m_Data.m_nIndex);
    CStr strIconFile = m_Icon.m_Data.m_strIconFile.c_str();
    persistor.PersistAttribute(XML_ATTR_ICON_FILE, strIconFile);
    m_Icon.m_Data.m_strIconFile = strIconFile;

    CXMLIcon iconLarge (XML_ATTR_CONSOLE_ICON_LARGE);
    CXMLIcon iconSmall (XML_ATTR_CONSOLE_ICON_SMALL);

	if (persistor.IsStoring())
	{
		iconLarge = m_Icon.m_icon32;
		iconSmall = m_Icon.m_icon16;
	}

    // keep this order intact to allow icon lookup by shellext
    persistor.Persist (iconLarge, XML_NAME_ICON_LARGE);
    persistor.Persist (iconSmall, XML_NAME_ICON_SMALL);

	if (persistor.IsLoading())
	{
		m_Icon.m_icon32 = iconLarge;
		m_Icon.m_icon16 = iconSmall;
	}
}


/*+-------------------------------------------------------------------------*
 *
 * FUNCTION: ScReadDataFromFile
 *
 * PURPOSE: reads file data to global memory
 *
 *+-------------------------------------------------------------------------*/
static SC ScReadDataFromFile(LPCTSTR strName, CXMLBinary *pBinResult)
{
    DECLARE_SC(sc, TEXT("ScReadDataFromFile"));

    // check parameter
    sc = ScCheckPointers(pBinResult);
    if (sc)
        return sc;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    // try to open existing file
    hFile = CreateFile(strName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    // check if we are unable to get to the file
    if (hFile == INVALID_HANDLE_VALUE)
    {
        sc.FromWin32(GetLastError());
        return sc;
    }

    // see how large the file is
    ULARGE_INTEGER cbCurrSize;
    cbCurrSize.LowPart = GetFileSize(hFile,&cbCurrSize.HighPart);
    if (cbCurrSize.HighPart != 0 || (LONG)(cbCurrSize.LowPart) < 0) // limiting to 2GB
    {
        sc = E_UNEXPECTED;
        goto CleanUpAndExit;
    }

    if (!cbCurrSize.LowPart)
    {
        // empty file. ok at this point
        goto CleanUpAndExit;
    }

    sc = pBinResult->ScAlloc(cbCurrSize.LowPart);
    if (sc)
        goto CleanUpAndExit;

    { // scoping for vars

        // no the time to do some reading
        DWORD dwRead = 0;
        BOOL bRead = FALSE;

        CXMLBinaryLock sLock(*pBinResult); // will unlock in destructor

        LPVOID pData = NULL;
        sc = sLock.ScLock(&pData);
        if (sc)
            goto CleanUpAndExit;

        sc = ScCheckPointers(pData,E_OUTOFMEMORY);
        if (sc)
            goto CleanUpAndExit;

        bRead = ReadFile(hFile,pData,cbCurrSize.LowPart,&dwRead,NULL);
        if (!bRead)
        {
            sc.FromLastError();
            goto CleanUpAndExit;
        }
        else if (dwRead != cbCurrSize.LowPart)
        {
            // something strange
            sc = E_UNEXPECTED;
            goto CleanUpAndExit;
        }
    } // scoping for vars

CleanUpAndExit:

    CloseHandle(hFile);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * FUNCTION: ScSaveXMLDocumentToString
 *
 * PURPOSE: stores contents of XML document into the string
 *
 *+-------------------------------------------------------------------------*/
SC ScSaveXMLDocumentToString(CXMLDocument& xmlDocument, std::wstring& strResult)
{
    DECLARE_SC(sc, TEXT("ScSaveXMLDocumentToString"));

    try
    {
        CComBSTR bstrResult;
        sc =  xmlDocument.ScSave(bstrResult);
        if (sc)
            return sc;

        // allocate and copy string
        strResult = bstrResult;

        // now remove all the \n and \r characters
        tstring::size_type pos;
        while ((pos = strResult.find_first_of(L"\n\r")) != strResult.npos)
            strResult.erase(pos, 1);

    }
    catch(...)
    {
        sc = E_OUTOFMEMORY;
        return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 * CXMLVariant::Persist
 *
 * Persists a CXMLVariant to/from an XML persistor.
 *--------------------------------------------------------------------------*/

#define ValNamePair(x) { x, L#x }

struct VARTYPE_MAP
{
    VARENUM vt;
    LPCWSTR pszName;
};

void CXMLVariant::Persist (CPersistor &persistor)
{
    DECLARE_SC (sc, _T("CXMLVariant::Persist"));

    static const VARTYPE_MAP TypeMap[] =
    {
        ValNamePair (VT_EMPTY),
        ValNamePair (VT_NULL),
        ValNamePair (VT_I2),
        ValNamePair (VT_I4),
        ValNamePair (VT_R4),
        ValNamePair (VT_R8),
        ValNamePair (VT_CY),
        ValNamePair (VT_DATE),
        ValNamePair (VT_BSTR),
        ValNamePair (VT_ERROR),
//      ValNamePair (VT_BOOL),      VT_BOOL is handled as a special case
        ValNamePair (VT_DECIMAL),
        ValNamePair (VT_I1),
        ValNamePair (VT_UI1),
        ValNamePair (VT_UI2),
        ValNamePair (VT_UI4),
        ValNamePair (VT_INT),
        ValNamePair (VT_UINT),
    };

    std::wstring strValue, strType;

    /*
     * storing?
     */
    if (persistor.IsStoring())
    {
        /*
         * can't store variants that aren't "simple" (i.e. by-ref, array, etc.)
         */
        if (!IsPersistable())
            (sc = E_FAIL).Throw();

        /*
         * special case for VT_BOOL
         */
        if (V_VT(this) == VT_BOOL)
        {
            strValue = (V_BOOL(this) == VARIANT_FALSE) ? L"False" : L"True";
            strType  = L"VT_BOOL";
        }
        else
        {
            /*
             * we can only VARIANTs that can be converted to text
             */
            CComVariant varPersist;
            sc = varPersist.ChangeType (VT_BSTR, this);
            if (sc)
                sc.Throw();

            /*
             * find the name for the type we're persisting
             */
            for (int i = 0; i < countof (TypeMap); i++)
            {
                if (V_VT(this) == TypeMap[i].vt)
                    break;
            }

            /*
             * unrecognized type that's convertible to string?
             */
            if (i >= countof (TypeMap))
                (sc = E_FAIL).Throw();

            /*
             * set the values that'll get saved
             */
            strValue = V_BSTR(&varPersist);
            strType  = TypeMap[i].pszName;
        }
    }

    /*
     * put to/get from the persistor
     */
    persistor.PersistAttribute (XML_ATTR_VARIANT_VALUE, strValue);
    persistor.PersistAttribute (XML_ATTR_VARIANT_TYPE,  strType);

    /*
     * loading?
     */
    if (persistor.IsLoading())
    {
        /*
         * clear out the current contents
         */
        Clear();

        /*
         * special case for VT_BOOL
         */
        if (strType == L"VT_BOOL")
        {
            V_VT  (this) = VT_BOOL;
            V_BOOL(this) = (_wcsicmp (strValue.data(), L"False")) ? VARIANT_FALSE : VARIANT_TRUE;
        }

        else
        {
            /*
             * find the VARIANT type in our map so we can convert back
             * to the right type
             */
            for (int i = 0; i < countof (TypeMap); i++)
            {
                if (strType == TypeMap[i].pszName)
                    break;
            }

            /*
             * unrecognized type that's convertible to string?
             */
            if (i >= countof (TypeMap))
                (sc = E_FAIL).Throw();

            /*
             * convert from string back to the original type
             */
            CComVariant varPersisted (strValue.data());
            sc = ChangeType (TypeMap[i].vt, &varPersisted);
            if (sc)
                sc.Throw();

        }
    }
}


/***************************************************************************\
 *
 * METHOD:  CXMLEnumeration::ScReadFromBSTR
 *
 * PURPOSE: reads value from BSTR and evaluates (decodes) it
 *
 * PARAMETERS:
 *    const BSTR bstr - [in] string containing the value
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLEnumeration::ScReadFromBSTR(const BSTR bstr)
{
    DECLARE_SC(sc, TEXT("CXMLEnumeration::ScReadFromBSTR"));

    // parameter check. (null BSTR is legal, but we do not support empty values either)
    sc = ScCheckPointers(bstr);
    if (sc)
        return sc;

    // convert to TSTRING
    USES_CONVERSION;
    LPCTSTR strInput = OLE2CT(bstr);

    // find a match in the mapping array
    for (size_t idx = 0; idx < m_count; idx ++)
    {
        if ( 0 == _tcscmp(strInput, m_pMaps[idx].m_literal) )
        {
            // found! set enum to proper value
            m_rVal = static_cast<enum_t>(m_pMaps[idx].m_enum);
            return sc;
        }
    }
    // didn't find? - too bad
    return sc = E_INVALIDARG;
}

/***************************************************************************\
 *
 * METHOD:  CXMLEnumeration::ScWriteToBSTR
 *
 * PURPOSE: Strores (prints) value into BSTR to be used in XML document
 *
 * PARAMETERS:
 *    BSTR * pbstr [out] resulting string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLEnumeration::ScWriteToBSTR (BSTR * pbstr ) const
{
    DECLARE_SC(sc, TEXT("CXMLEnumeration::ScWriteToBSTR"));

    // parameter check
    sc = ScCheckPointers(pbstr);
    if (sc)
        return sc;

    // initialization
    *pbstr = NULL;

    // find string representation for enum
    for (size_t idx = 0; idx < m_count; idx ++)
    {
        if ( m_pMaps[idx].m_enum == (UINT)m_rVal )
        {
            // found! - return it
            *pbstr = CComBSTR(m_pMaps[idx].m_literal).Detach();
            return sc;
        }
    }

    // didn't find? - too bad
    return sc = E_INVALIDARG;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBitFlags::PersistMultipleAttributes
 *
 * PURPOSE: perists bitflags as separate attributes. These are stored as
 *          attributes of the PARENT object, using the names specified in the
 *          name map. Any unknown flags are stored in an attribute
 *          specified by the name parameter, in numerical form.
 *
 * PARAMETERS:
 *    LPCTSTR name          [in] flag name (used only for not recognized flags)
 *    CPersistor &persistor [in] persistor to perform operation on
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLBitFlags::PersistMultipleAttributes(LPCTSTR name, CPersistor &persistor)
{
    // temporaries
    UINT uiValToSave = persistor.IsStoring() ? m_rVal : 0;
    UINT uiValLoaded = 0;

    // iterate thru all the entries in the map
    for (size_t idx = 0; idx < m_count; idx ++)
    {
        UINT uiMask = m_pMaps[idx].m_enum;

        // we do only care about true flags - any nonzero value.
        if (!uiMask)
            continue;

        // initialize the value properly for storing
        // when loading (it will remain the same if attribute isn't found)
        bool bValue = false;
        if ( (uiValToSave & uiMask) == uiMask )
        {
            bValue = true;
            uiValToSave &= ~uiMask; // since we have taken care of this, remove the bits.
                                    // anything left over is saved numerically (see below)
        }

        // do not store "false" values - they are useless
        bool bNeedsPersisting = persistor.IsLoading() || bValue;

        if (bNeedsPersisting)
            persistor.PersistAttribute( m_pMaps[idx].m_literal, CXMLBoolean(bValue), attr_optional );

        uiValLoaded |= bValue ? uiMask : 0;
    }

    /* If there are any flags which do not have a corresponding text version,
       these are persisted using the original name of the attribute, with the numerical
       value of the flags*/
    UINT uiValTheRest = uiValToSave;
    bool bNeedsPersisting = persistor.IsLoading() || (uiValTheRest != 0);
    if (bNeedsPersisting)
        persistor.PersistAttribute( name, uiValTheRest, attr_optional );

    uiValLoaded |= uiValTheRest;

    if (persistor.IsLoading())
        m_rVal = uiValLoaded;
}


/***************************************************************************\
 *
 * METHOD:  CXMLBinary::CXMLBinary
 *
 * PURPOSE: default constructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CXMLBinary::CXMLBinary() :
m_Handle(NULL),
m_Size(0),
m_Locks(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::CXMLBinary
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *    HGLOBAL handle - handle to attach to
 *    size_t size    - real size of data
 *
\***************************************************************************/
CXMLBinary::CXMLBinary(HGLOBAL handle, size_t size) :
m_Handle(handle),
m_Size(size),
m_Locks(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::Attach
 *
 * PURPOSE: Attaches object to allocated data. Will free the data it already has
 *
 * PARAMETERS:
 *    HGLOBAL handle - handle to attach to
 *    size_t size    - real size of data
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLBinary::Attach(HGLOBAL handle, size_t size)
{
    DECLARE_SC(sc, TEXT("CXMLBinary::Attach"));

    sc = ScFree();
    if (sc)
        sc.TraceAndClear();

    ASSERT(m_Handle == NULL && m_Size == 0 && m_Locks == 0);
    m_Handle = handle;
    m_Size = size;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::Detach
 *
 * PURPOSE: transfers control to the caller
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HGLOBAL    - handle of allocated memory
 *
\***************************************************************************/
HGLOBAL CXMLBinary::Detach()
{
    HGLOBAL ret = m_Handle;
    m_Handle = NULL;
    m_Size = 0;
    m_Locks = 0;
    return ret;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::GetSize
 *
 * PURPOSE: returns the size of binary data
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    size_t    - size
 *
\***************************************************************************/
size_t  CXMLBinary::GetSize()   const
{
    return m_Size;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::GetHandle
 *
 * PURPOSE: returns handle to allocated memory (NULL if size is zero)
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HGLOBAL    - handle
 *
\***************************************************************************/
HGLOBAL CXMLBinary::GetHandle() const
{
    return m_Handle;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScAlloc
 *
 * PURPOSE: allocates the memory for binary data. Previosly allocated date will
 *          be fred.
 *
 * NOTE:    0 in general is a valid size, GetHandle will return NULL in that case
 *          ScLock however will fail
 *
 * PARAMETERS:
 *    size_t size   - new size of binary data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScAlloc(size_t size, bool fZeroInit /* =false */)
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScAlloc"));

    if (size == 0) // use ScFree to free the data
        return sc = E_INVALIDARG;

    sc = ScFree();
    if (sc)
        sc.TraceAndClear();

    ASSERT(m_Handle == NULL && m_Size == 0 && m_Locks == 0);

	DWORD dwFlags = GMEM_MOVEABLE;
	if (fZeroInit)
		dwFlags |= GMEM_ZEROINIT;

    m_Handle = GlobalAlloc(dwFlags, size);
    if (!m_Handle)
        return sc.FromLastError(), sc;

    m_Size = size;
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScRealloc
 *
 * PURPOSE: reallocates the data. If data is present it will be coppied over
 *
 * PARAMETERS:
 *    size_t new_size   - new binary data size
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScRealloc(size_t new_size, bool fZeroInit /* =false */)
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScRealloc"));

    if (new_size == 0) // use ScFree to fre the data
        return sc = E_INVALIDARG;

    if (m_Size == 0)  // use Alloc to allocate new data
        return sc = E_UNEXPECTED;

    ASSERT(m_Handle != NULL && m_Locks == 0);

    if (m_Handle == NULL)
        return sc = E_UNEXPECTED;

    HGLOBAL hgNew = GlobalReAlloc(m_Handle, new_size, fZeroInit ? GMEM_ZEROINIT : 0);
    if (!hgNew)
        return sc.FromLastError(), sc;

    m_Handle = hgNew;
    m_Size = new_size;
    m_Locks = 0;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScUnlock
 *
 * PURPOSE: Remove one lock from binary data
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScUnlockData() const
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScUnlockData()"));

    ASSERT(m_Handle != NULL && m_Locks != 0);

    if (!m_Locks || m_Handle == NULL)
        return sc = E_UNEXPECTED;

    GlobalUnlock(m_Handle);
    --m_Locks;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::Free
 *
 * PURPOSE: Frees data asociated with the object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
SC CXMLBinary::ScFree()
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScFree"));

    while(m_Locks)
    {
        sc = ScUnlockData();
        if (sc)
            sc.TraceAndClear();
    }

    if (m_Handle)
        GlobalFree(m_Handle);

    Detach(); // null the handle, etc.

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinary::ScLockData
 *
 * PURPOSE: Helper function used frol ScLock templates
 *
 * PARAMETERS:
 *    const void **ppData
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinary::ScLockData(const void **ppData) const
{
    DECLARE_SC(sc, TEXT("CXMLBinary::ScLockData"));

    // paramter check
    sc = ScCheckPointers(ppData);
    if (sc)
        return sc;

    // initialization
    *ppData = NULL;

    // data allocated?
    if (!m_Handle)
        return sc = E_POINTER;

    // lock
    *ppData = GlobalLock(m_Handle);

    // recheck
    if (*ppData == NULL)
        return sc.FromLastError(), sc;

    ++m_Locks; // keep count of locks

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::CXMLBinaryLock
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *    CXMLBinary& binary - object to perform locking on
 *
\***************************************************************************/
CXMLBinaryLock::CXMLBinaryLock(CXMLBinary& binary) :
m_rBinary(binary),
m_bLocked(false)
{
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::~CXMLBinaryLock
 *
 * PURPOSE: destructor; also removes existing lock
 *
 * PARAMETERS:
 *
\***************************************************************************/
CXMLBinaryLock::~CXMLBinaryLock()
{
    DECLARE_SC(sc, TEXT("CXMLBinaryLock::~CXMLBinaryLock"));

    if (m_bLocked)
    {
        sc = ScUnlock();
        if (sc)
            sc.TraceAndClear();
    }
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::ScLockWorker
 *
 * PURPOSE: type-insensitive lock method (helper)
 *
 * PARAMETERS:
 *    void **ppData - pointer to locked data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinaryLock::ScLockWorker(void **ppData)
{
    DECLARE_SC(sc, TEXT("CXMLBinaryLock::ScLockWorker"));

        if (m_bLocked)
            return sc = E_UNEXPECTED;

        sc = m_rBinary.ScLockData(reinterpret_cast<void**>(ppData));
        if (sc)
            return sc;

        m_bLocked = true;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CXMLBinaryLock::ScUnlock
 *
 * PURPOSE: removes the lock
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CXMLBinaryLock::ScUnlock()
{
    DECLARE_SC(sc, TEXT("ScUnlock"));

    if (!m_bLocked)
        return sc = E_UNEXPECTED;

    sc = m_rBinary.ScUnlockData();
    if (sc)
        return sc;

    m_bLocked = false;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  ScGetConsoleFileChecksum
 *
 * PURPOSE: inspects the contents and validates if it looks like valid XML document
 *
 * PARAMETERS:
 *    LPCTSTR   lpszPathName - [in] path to the document
 *    bool&     bXmlBased    - [out] true if file is xml based
 *    tstring&  pstrFileCRC  - [out] crc for the file
 *
 * RETURNS:
 *    SC - error or validation result (S_OK / S_FALSE)
 *
\***************************************************************************/
SC ScGetConsoleFileChecksum(LPCTSTR lpszPathName, tstring&  strFileCRC)
{
    DECLARE_SC(sc, TEXT("ScGetConsoleFileChecksum"));

    // parameter check
    sc = ScCheckPointers(lpszPathName);
    if (sc)
        return sc;

    // init out parameters;
    strFileCRC.erase();

    // open the file
    CAutoWin32Handle shFile( CreateFile(lpszPathName, GENERIC_READ, FILE_SHARE_READ,
                                        NULL, OPEN_EXISTING, 0, NULL) );

    if ( !shFile.IsValid() )
        return sc.FromLastError();

    // we are sure here the sizeHi is zero. mapping should fail else
    DWORD dwLenHi = 0;
    DWORD dwLen = GetFileSize(shFile, &dwLenHi);

    if ( dwLenHi != 0 )
        return sc = E_OUTOFMEMORY;

    // allocate memory for whole file
    CAutoArrayPtr<BYTE> spData( new BYTE[dwLen] );
    if ( spData == NULL )
        return sc = E_OUTOFMEMORY;

    // read the file into the memory
    DWORD dwRead = 0;
    if ( TRUE != ReadFile( shFile, spData, dwLen, &dwRead, NULL ) )
        return sc.FromLastError();

    // assert all the data was read
    if ( dwRead != dwLen )
        return sc = E_UNEXPECTED;

    // calculate the crc
    ULONG init_crc = 0; /*initial crc - do not change this, or you will have different
                        checksums calculated - thus existing user data discarded */

    ULONG crc = crc32( init_crc, spData, dwLen );

    // convert
    TCHAR buff[20] = {0};
    strFileCRC = _ultot(crc, buff, 10 /*radix*/);

    // done
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScOpenDocAsStructuredStorage
 *
 * PURPOSE: Opens the file and reads the contents into the memory
 *          returns the pointer to memory based IStorage
 *
 * PARAMETERS:
 *    LPCTSTR lpszPathName [in] - file name
 *    IStorage **ppStorage [out] - pointer to IStorage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScOpenDocAsStructuredStorage(LPCTSTR lpszPathName, IStorage **ppStorage)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScOpenDocAsStructuredStorage"));

    // check out parameter
    sc = ScCheckPointers(ppStorage);
    if (sc)
        return sc;

    // init out parameter
    *ppStorage = NULL;

    // check in parameter
    sc = ScCheckPointers(lpszPathName);
    if (sc)
        return sc;

    CAutoWin32Handle hFile(CreateFile(lpszPathName, GENERIC_READ, FILE_SHARE_READ,
                                      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    if (!hFile.IsValid())
        return sc.FromLastError();

    // get file data
    ULARGE_INTEGER cbFileSize;
    cbFileSize.LowPart = GetFileSize(hFile, &cbFileSize.HighPart);

    // will not handle files bigger than 2Gb
    if (cbFileSize.HighPart)
        return E_UNEXPECTED;

    // alocate memory blob and read the data
    CXMLAutoBinary binData;
    if (cbFileSize.LowPart)
    {
        // allocate
        sc = binData.ScAlloc(cbFileSize.LowPart);
        if (sc)
            return sc;

        // get pointer to data
        CXMLBinaryLock lock(binData);
        BYTE *pData = NULL;
        sc = lock.ScLock(&pData);
        if (sc)
            return sc;

        // read file contents
        DWORD dwBytesRead = 0;
        BOOL bOK = ReadFile(hFile, pData, cbFileSize.LowPart, &dwBytesRead, NULL);
        if (!bOK)
            return sc.FromLastError();
        else if (cbFileSize.LowPart != dwBytesRead)
            return sc = E_UNEXPECTED;
    }

    // create lockbytes
    ILockBytesPtr spLockBytes;
    sc = CreateILockBytesOnHGlobal(binData.GetHandle(), TRUE, &spLockBytes);
    if(sc)
        return sc;

    // ILockBytes took control over HGLOBAL block, detach from it
    binData.Detach();

    // set correct size for data
    sc = spLockBytes->SetSize(cbFileSize);
    if(sc)
        return sc;

    // ask ole to open storage for client
    const DWORD grfMode = STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE;
    sc = StgOpenStorageOnILockBytes(spLockBytes, NULL, grfMode, NULL, 0, ppStorage);
    if(sc)
        return sc;

    // done...
    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScGetUserDataFolder
 *
 * PURPOSE: Calculates location (dir) for user data folder
 *
 * PARAMETERS:
 *    tstring& strUserDataFolder [out] - user data folder path
 *    * for instance 'E:\Documents and Settings\John\Application Data\Microsoft\MMC' *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScGetUserDataFolder(tstring& strUserDataFolder)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScGetUserDataFolder"));

    // init out parameter
    strUserDataFolder.erase();

    // get owner for error boxes
    HWND hwndOwner = IsWindowVisible(sc.GetHWnd()) ? sc.GetHWnd() : NULL;

    // get shell folder
    TCHAR szFolderPath[_MAX_PATH] = {0};
    BOOL bOK = SHGetSpecialFolderPath(hwndOwner, szFolderPath, CSIDL_APPDATA, TRUE/*fCreate*/);
    if ( !bOK )
        return sc = E_FAIL;

    // return the path;
    strUserDataFolder = szFolderPath;
    strUserDataFolder += _T('\\');
    strUserDataFolder += g_szUserDataSubFolder;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScGetUserDataPath
 *
 * PURPOSE: Calculates location (dir) for user data file by given original console path
 *
 * PARAMETERS:
 *    LPCTSTR lpstrOriginalPath [in] - original console path
 *    * for instance 'c:\my consoles\my_tool.msc' *
 *    tstring& strUserDataPath  [out] - user data file path
 *    * for instance 'E:\Documents and Settings\John\Application Data\Microsoft\MMC\my_tool.msc' *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScGetUserDataPath(LPCTSTR lpstrOriginalPath, tstring& strUserDataPath)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScGetUserDataPath"));

    // parameter check
    sc = ScCheckPointers(lpstrOriginalPath);
    if ( sc )
        return sc;

    // init out parameter
    strUserDataPath.erase();

    // get only the filename from the path
    LPCTSTR lpstrOriginalFileName = _tcsrchr( lpstrOriginalPath, _T('\\') );
    if ( lpstrOriginalFileName == NULL )
        lpstrOriginalFileName = lpstrOriginalPath;
    else
        ++lpstrOriginalFileName;

    // skip whitespaces
    while ( *lpstrOriginalFileName && _istspace(*lpstrOriginalFileName) )
        ++lpstrOriginalFileName;

    // check if the name is non-empty
    if ( !*lpstrOriginalFileName )
        return sc = E_INVALIDARG;

    // get folder
    sc = ScGetUserDataFolder(strUserDataPath);
    if (sc)
        return sc;

    // ensure mmc folder exists
    DWORD dwFileAtts = ::GetFileAttributes( strUserDataPath.c_str() );
    if ( 0 == ( dwFileAtts & FILE_ATTRIBUTE_DIRECTORY ) || (DWORD)-1 == dwFileAtts )
    {
        // create the directory
        if ( !CreateDirectory( strUserDataPath.c_str(), NULL ) )
            return sc.FromLastError();
    }

    // get the length of the file
    int iFileNameLen = _tcslen( lpstrOriginalFileName );
    int iConsoleExtensionLen = _tcslen( g_szDEFAULT_CONSOLE_EXTENSION );

    // subtract 'msc' extension if such was added
    if ( iFileNameLen > iConsoleExtensionLen ) 
    {
        if ( 0 == _tcsicmp( g_szDEFAULT_CONSOLE_EXTENSION, lpstrOriginalFileName + iFileNameLen - iConsoleExtensionLen ) )
        {
            iFileNameLen -= (iConsoleExtensionLen - 1); // will add the dot to prevent assumming the different extension
                                                        // so that a.b.msc won't have b extension after msc is removed 
        }
    }

    strUserDataPath += _T('\\');
    strUserDataPath.append( lpstrOriginalFileName, iFileNameLen ); // excludes .msc extension

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFilePersistor::GetBinaryCollection
 *
 * PURPOSE: Returns a handle to the collection of Binary elements in the specified
 *          document
 *
 * PARAMETERS:
 *    CXMLDocument&          xmlDocument : [in]: the specified console file document
 *    CXMLElementCollection& colBinary :  [out]: the collection
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleFilePersistor::GetBinaryCollection(CXMLDocument& xmlDocument, CXMLElementCollection&  colBinary)
{
    // get the root elements of the source and the destination documents
    CPersistor persistorRoot        (xmlDocument,         CXMLElement(xmlDocument        ));

    // set the navigation to loading
    persistorRoot.SetLoading(true);

    // navigate to the MMC_ConsoleFile node
    CPersistor persistorConsole        (persistorRoot,         XML_TAG_MMC_CONSOLE_FILE);

    // navigate to the binary storage node
    CPersistor persistorBinaryStorage        (persistorConsole,         XML_TAG_BINARY_STORAGE);

    // get the collection of binary objects
    persistorBinaryStorage        .GetCurrentElement().getChildrenByName(XML_TAG_BINARY, &colBinary);
}

/*+-------------------------------------------------------------------------*
 *
 * CompareStrings
 *
 * PURPOSE: Does a whitespace-insensitive, but case-SENSITIVE comparison
 *          of the two strings.
 *
 * PARAMETERS:
 *    CComBSTR&  bstr1 :
 *    CComBSTR & bstr2 :
 *
 * RETURNS:
 *    static bool : true if match. else false
 *
 *+-------------------------------------------------------------------------*/
static bool
CompareStrings(CComBSTR& bstr1, CComBSTR &bstr2)
{
    UINT length1 = bstr1.Length();
    UINT length2 = bstr2.Length();

    // the current indexes
    UINT i1 = 0;
    UINT i2 = 0;

    bool bEnd1 = false; // is the first string over?
    bool bEnd2 = false; // is the second string over?

    BSTR sz1 = bstr1;
    BSTR sz2 = bstr2;

    // either both should be null or neither should be
    if( (NULL == sz1) && (NULL==sz2) )
        return true;

    if( (NULL == sz1) || (NULL==sz2) )
        return false;

    // compare the strings
    while( (!bEnd1) || (!bEnd2) )
    {
        WCHAR ch1 = sz1[i1];
        WCHAR ch2 = sz2[i2];

        // 1. get the next non-whitespace char of the first string
        if (i1 == length1)
            bEnd1 = true;
        else
        {
            if(iswspace(ch1))
            {
                ++i1;
                continue;
            }
        }

        // 2. get the next non-whitespace char of the second string
        if (i2 == length2)
            bEnd2 = true;
        else
        {
            if(iswspace(ch2))
            {
                ++i2;
                continue;
            }
        }

        // 3. if either of the strings have ended, break. Taken care of below.
        if(bEnd1 || bEnd2)
            break;

        // 4. compare the characters (must be a case sensitive comparison)
        if(ch1 != ch2)
            return false;

        // 5. increment the counters
        ++i1;
        ++i2;
    }

    // both strings should have ended together for a match
    if(bEnd1 && bEnd2)
        return true;

    return false;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFilePersistor::ScCompressUserStateFile
 *
 * PURPOSE: Compresses the user-state console file to avoid redundancies. Most of a
 *          console file's size is in the binary elements. These are also usually the
 *          least likely to change in user mode. For instance, the console file icons
 *          and console task icons cannot be changed in user mode.
 *
 *          Therefore, the compression algorithm iterates through all <BINARY> elements
 *          in the user state file, and looks for matches in the original console file.
 *          If a <BINARY> element has the same contents as a <BINARY> element in the
 *          original console file, the contents are replaced by a SourceIndex attribute
 *          that gives the index of the matching <BINARY> element in the source.
 *          This usually results in a >80% reduction of user state file size.
 *
 * PARAMETERS:
 *    LPCTSTR        szConsoleFilePath : [IN]: the (authored) console file path
 *    CXMLDocument & xmlDocument : [IN/OUT]: The user state document, which is compressed
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleFilePersistor::ScCompressUserStateFile(LPCTSTR szConsoleFilePath, CXMLDocument & xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScCompressUserStateFile"));

    sc = ScCheckPointers(szConsoleFilePath);
    if(sc)
        return sc;

    CXMLDocument xmlDocumentOriginal; // the original file
    sc = xmlDocumentOriginal.ScCoCreate( false/*bPutHeader*/ ); // initialize it.
    if(sc)
        return sc;

    sc = /*CConsoleFilePersistor::*/ScLoadXMLDocumentFromFile(xmlDocumentOriginal, szConsoleFilePath, true /*bSilentOnErrors*/);
    if(sc)
    {
        // ignore the error - this just means that original console is not 
        // an XML based - we are not able to compress it - not an error
        sc.Clear();
        return sc;
    }

    try
    {
        // get the collection of Binary tags
        CXMLElementCollection colBinaryOrignal, colBinary;
        GetBinaryCollection(xmlDocumentOriginal, colBinaryOrignal);
        GetBinaryCollection(xmlDocument,         colBinary);

        long cItemsOriginal = 0;
        long cItems         = 0;

        colBinaryOrignal.get_count(&cItemsOriginal);
        colBinary       .get_count(&cItems);

        // look for matches
        for(int i = 0; i< cItems; i++)
        {
            CXMLElement elemBinary = NULL;
            colBinary.item(i, &elemBinary); // get the i'th Binary element in the dest. file
            CComBSTR bstrBinary;
            elemBinary.get_text(bstrBinary);

            for(int j = 0; j< cItemsOriginal; j++)
            {
                CXMLElement elemBinaryOriginal = NULL;
                colBinaryOrignal.item(j, &elemBinaryOriginal); // get the j'th Binary element in the dest. file
                CComBSTR bstrBinaryOriginal;
                elemBinaryOriginal.get_text(bstrBinaryOriginal);

                // compare
                if(CompareStrings(bstrBinaryOriginal, bstrBinary))
                {
                    // yahoo!! compress.
                    Trace(tagXMLCompression, TEXT("Found match!"));

                    // 1. nuke the contents
                    elemBinary.put_text(NULL); // NULL is a valid value for a BSTR

                    CStr strValue;
                    strValue.Format(TEXT("%d"), j);

                    // 2. set the contents
                    elemBinary.setAttribute(XML_ATTR_SOURCE_INDEX, CComBSTR(strValue));

                    // done.
                    break;
                }
            }
        }
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }



    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFilePersistor::ScUncompressUserStateFile
 *
 * PURPOSE: Uncompresses user data files that were compressed by ScCompressUserStateFile.
 *          Applies the compression algorithm in reverse.
 *
 * PARAMETERS:
 *    CXMLDocument & xmlDocumentOriginal :
 *    CXMLDocument&  xmlDocument :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleFilePersistor::ScUncompressUserStateFile(CXMLDocument &xmlDocumentOriginal, CXMLDocument& xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScUncompressUserStateFile"));

    try
    {
        // get the collection of Binary tags
        CXMLElementCollection colBinaryOrignal, colBinary;
        GetBinaryCollection(xmlDocumentOriginal, colBinaryOrignal);
        GetBinaryCollection(xmlDocument,         colBinary);

        long cItems         = 0;

        colBinary       .get_count(&cItems);

        // decompress each item in colBinary
        for(int i = 0; i< cItems; i++)
        {
            CXMLElement elemBinary = NULL;
            colBinary.item(i, &elemBinary); // get the i'th Binary element in the dest. file

            CComBSTR bstrSourceIndex;

            if(elemBinary.getAttribute(XML_ATTR_SOURCE_INDEX, bstrSourceIndex))
            {
                int j = _wtoi(bstrSourceIndex);

                CXMLElement elemBinaryOriginal;
                colBinaryOrignal.item(j, &elemBinaryOriginal); // get the j'th Binary element in the dest. file
                CComBSTR bstrBinaryOriginal;
                elemBinaryOriginal.get_text(bstrBinaryOriginal);

                // replace the destination binary contents (which should be empty) with the original.
                elemBinary.put_text(bstrBinaryOriginal);

                // don't need to delete the SourceIndex attribute because the xmlDocument is thrown away after reading it in.
            }
        }
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScLoadConsole
 *
 * PURPOSE: Loads the mmc console from file
 *
 * PARAMETERS:
 *    LPCTSTR lpstrConsolePath      [in] path, where the console resides.
 *    bool& bXmlBased               [out] whether document is XML-based
 *    CXMLDocument& xmlDocument     [out] xmlDocument containing data (only if xml-Based)
 *    IStorage **ppStorage          [out] storage containing data(only if non xml-Based)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScLoadConsole(LPCTSTR lpstrConsolePath, bool& bXmlBased,
                                        CXMLDocument& xmlDocument, IStorage **ppStorage)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScLoadConsole"));

    // parameter check
    sc = ScCheckPointers(lpstrConsolePath, ppStorage);
    if (sc)
        return sc;

    // init out parameters
    bXmlBased = false;
    *ppStorage = NULL;

    // Create an empty XML document
    CXMLDocument xmlOriginalDoc;
    sc = xmlOriginalDoc.ScCoCreate(false/*bPutHeader*/);
    if(sc)
        return sc;

    //  inspect original console file by trying to load XML document
    bool bOriginalXmlBased = false;
    sc = ScLoadXMLDocumentFromFile(xmlOriginalDoc, lpstrConsolePath, true /*bSilentOnErrors*/);
    if( !sc.IsError() )
        bOriginalXmlBased = true;

    sc.Clear(); // ignore the error - assume it is not XML based

    // test it is not a user data which is being opened - cannot be so!
    if ( bOriginalXmlBased )
    {
        try
        {
            // construct persistor
            CPersistor persistor(xmlOriginalDoc, CXMLElement(xmlOriginalDoc));
            persistor.SetLoading(true);

            // navigate to CRC storage
            CPersistor persistorConsole( persistor, XML_TAG_MMC_CONSOLE_FILE );
            if ( persistorConsole.HasElement(XML_TAG_ORIGINAL_CONSOLE_CRC, NULL) )
                return sc = E_UNEXPECTED;
        }
        catch(SC sc_thrown)
        {
            return sc = sc_thrown;
        }
    }

    tstring strFileCRC;
    sc = ScGetConsoleFileChecksum( lpstrConsolePath, strFileCRC );
    if (sc)
        return sc;

    // store data to be used for saving
    m_strFileCRC = strFileCRC;
    m_bCRCValid = true;

    // get the path to user data
    tstring strUserDataPath;
    sc = ScGetUserDataPath( lpstrConsolePath, strUserDataPath);
    if (sc)
        return sc;

    // go get the user data
    bool bValidUserData = false;
    sc = ScGetUserData( strUserDataPath, strFileCRC, bValidUserData, xmlDocument );
    if (sc)
    {
        // don't fail - trace only - missing user data not a reason to fail loading
        bValidUserData = false;
        sc.TraceAndClear();
    }

    // user data loaded?
    if (bValidUserData)
    {

        // uncompress the user data if the original was XML
        if(bOriginalXmlBased)
        {
            sc = ScUncompressUserStateFile(xmlOriginalDoc, xmlDocument);
            if(sc)
                return sc;
        }

        // done, just return the staff
        bXmlBased = true; // user data always is XML
        // pxmlDocument is already updated by ScGetUserData
        return sc;
    }

    // no luck with user data, lets load the original file

    // XML contents
    if ( bOriginalXmlBased )
    {
        // return the data
        bXmlBased = true;
        xmlDocument = xmlOriginalDoc;

        return sc;
    }

    // old, ole-storage based file:
    sc = ScOpenDocAsStructuredStorage( lpstrConsolePath, ppStorage );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScGetUserData
 *
 * PURPOSE: inspects if user data matches console file, loads the xml document if it does
 *
 * PARAMETERS:
 *    tstring& strUserDataConsolePath   [in] - path to the user data
 *    const tstring& strFileCRC,        [in] - crc of original console file
 *    bool& bValid                      [out] - if user data is valid
 *    CXMLDocument& xmlDocument         [out] - loaded document (only if valid)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScGetUserData(const tstring& strUserDataConsolePath, const tstring& strFileCRC,
                                        bool& bValid, CXMLDocument& xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScGetUserData"));

    // assume invalid initially
    bValid = false;

    // check if user file exist
    DWORD dwFileAtts = ::GetFileAttributes( strUserDataConsolePath.c_str() );

    // if file is missing dwFileAtts will be -1, so bValidUserData will be eq. to false
    bool bValidUserData = ( ( dwFileAtts & FILE_ATTRIBUTE_DIRECTORY ) == 0 );
    if ( !bValidUserData )
        return sc;

    // Create an empty XML document
    CXMLDocument xmlDoc;
    sc = xmlDoc.ScCoCreate( false/*bPutHeader*/ );
    if(sc)
        return sc;

    // upload the data
    sc = ScLoadXMLDocumentFromFile( xmlDoc, strUserDataConsolePath.c_str() );
    if(sc)
        return sc;

    // get the CRC
    try
    {
        CPersistor persistor(xmlDoc, CXMLElement(xmlDoc));
        persistor.SetLoading(true);

        // navigate to CRC storage
        CPersistor persistorConsole( persistor, XML_TAG_MMC_CONSOLE_FILE );
        CPersistor persistorCRC( persistorConsole, XML_TAG_ORIGINAL_CONSOLE_CRC );

        tstring strCRC;
        persistorCRC.PersistContents(strCRC);

        // valid if CRC matches
        if ( strCRC == strFileCRC )
        {
            // return the document
            bValid = true;

            xmlDocument = xmlDoc;
        }
    }
    catch(SC sc_thrown)
    {
        return sc = sc_thrown;
    }

    return sc;
}



/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScSaveConsole
 *
 * PURPOSE: Saves console to file
 *
 * PARAMETERS:
 *    LPCTSTR lpstrConsolePath          [in] - console file path
 *    bool bForAuthorMode               [in] - if console was authored
 *    const CXMLDocument& xmlDocument   [in] - document conatining data to be saved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScSaveConsole(LPCTSTR lpstrConsolePath, bool bForAuthorMode, const CXMLDocument& xmlDocument)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScSaveConsole"));

    // parameter check
    sc = ScCheckPointers( lpstrConsolePath );
    if (sc)
        return sc;

    // sanity check - if saving in user mode, have to be loaded from file.
    // To save in user mode CRC of the original document must be known.
    // It is calculated on loading, but seems like loading was never done.
    if ( !bForAuthorMode && !m_bCRCValid )
        return sc = E_UNEXPECTED;

    // prepare data for save
    tstring         strDestinationFile( lpstrConsolePath );
    CXMLDocument    xmlDocumentToSave( xmlDocument );

    // need to modify slightly if saving just the user data
    if ( !bForAuthorMode )
    {
        // get user data file path
        sc = ScGetUserDataPath( lpstrConsolePath, strDestinationFile );
        if (sc)
            return sc;

        // optimize the file to be saved, to remove redundancies
        sc = ScCompressUserStateFile(lpstrConsolePath, xmlDocumentToSave);
        if(sc)
            return sc;

        // add crc to the document
        try
        {
            CPersistor persistor(xmlDocumentToSave, CXMLElement(xmlDocumentToSave));
            persistor.SetLoading(true); // navigate like 'loading'

            // navigate to CRC storage
            CPersistor persistorConsole( persistor, XML_TAG_MMC_CONSOLE_FILE );

            // create the crc record
            persistorConsole.SetLoading(false);
            CPersistor persistorCRC( persistorConsole, XML_TAG_ORIGINAL_CONSOLE_CRC );

            // save data
            persistorCRC.PersistContents( m_strFileCRC );
        }
        catch(SC sc_thrown)
        {
            return sc = sc_thrown;
        }
    }

    // save document contents
    sc = xmlDocumentToSave.ScSaveToFile( strDestinationFile.c_str() );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CConsoleFilePersistor::ScLoadXMLDocumentFromFile
 *
 * PURPOSE: reads CXMLDocument contents from file
 *
 * PARAMETERS:
 *    CXMLDocument& xmlDocument [out] document to be receive contents
 *    LPCTSTR szFileName        [in]  source file name
 *    bool bSilentOnErrors      [in]  if true - does not trace opennning errors
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CConsoleFilePersistor::ScLoadXMLDocumentFromFile(CXMLDocument& xmlDocument, LPCTSTR szFileName, bool bSilentOnErrors /*= false*/)
{
    DECLARE_SC(sc, TEXT("CConsoleFilePersistor::ScLoadXMLDocumentFromFile"));

    // read data
    CXMLAutoBinary binData;
    sc = ScReadDataFromFile(szFileName, &binData);
    if (sc)
        return sc;

    // create stream - NOTE it will take care of HGLOBAL if succeeds
    IStreamPtr spStream;
    sc = CreateStreamOnHGlobal(binData.GetHandle(), TRUE, &spStream);
    if (sc)
        return sc;

    const ULARGE_INTEGER new_size = { binData.GetSize(), 0 };
    binData.Detach(); // not the owner anymore (IStream took ownership)

    sc = ScCheckPointers(spStream, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spStream->SetSize(new_size);
    if (sc)
        return sc;

    // load data (do not trace by default - it is used to inspect the document as well)
    SC sc_no_trace = xmlDocument.ScLoad(spStream, bSilentOnErrors);
    if(sc_no_trace)
    {
        if ( !bSilentOnErrors )
            sc = sc_no_trace;
        return sc_no_trace;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\viewset.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      viewset.cpp
 *
 *  Contents:  Implements CViewSettings.
 *
 *  History:   21-April-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/
#include "stgio.h"
#include "stddbg.h"
#include "macros.h"
#include <comdef.h>
#include "serial.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include "ndmgr.h"
#include <string>
#include "atlbase.h"
#include "cstr.h"
#include "xmlbase.h"
#include "resultview.h"
#include "viewset.h"
#include "countof.h"


CViewSettings::CViewSettings()
: m_ulViewMode(0), m_guidTaskpad(GUID_NULL),
  m_dwRank(-1), m_bInvalid(FALSE), m_dwMask(0)
{
}


bool
CViewSettings::IsViewModeValid()    const
{
    return ( (m_RVType.HasList()) &&
             (m_dwMask & VIEWSET_MASK_VIEWMODE) );
}

bool
CViewSettings::operator == (const CViewSettings& viewSettings)
{
    if (m_dwMask != viewSettings.m_dwMask)
    {
        return false;
    }

    if (IsViewModeValid() &&
        (m_ulViewMode != viewSettings.m_ulViewMode) )
    {
        return false;
    }

    if (IsTaskpadIDValid() &&
        (m_guidTaskpad != viewSettings.m_guidTaskpad))
    {
        return false;
    }

    if (IsResultViewTypeValid() &&
        (m_RVType != viewSettings.m_RVType))
    {
        return false;
    }

    return true;
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScInitialize
//
//  Synopsis:    Private member to read 1.2 console files and init
//               the object.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScInitialize(bool  bViewTypeValid, const VIEW_TYPE& viewType, const long lViewOptions, const wstring& wstrViewName)
{
    DECLARE_SC(sc, _T("CViewSettings::ScInitialize"));

    LPOLESTR pViewName = NULL;
    if (wstrViewName.length() > 0)
    {
        pViewName = (LPOLESTR) CoTaskMemAlloc( (wstrViewName.length() + 1) * sizeof(OLECHAR) );
        wcscpy(pViewName, wstrViewName.data());
    }

	sc = m_RVType.ScInitialize(pViewName, lViewOptions);
	if (sc)
		return sc;

	SetResultViewTypeValid( bViewTypeValid );

	if ( bViewTypeValid )
	{
		// Now put these data in CViewSettings.
		switch(viewType)
		{
		case VIEW_TYPE_OCX:
		case VIEW_TYPE_WEB:
			break;

		case VIEW_TYPE_DEFAULT:
			// What is this?
			ASSERT(FALSE);
			break;

		case VIEW_TYPE_LARGE_ICON:
			m_ulViewMode = MMCLV_VIEWSTYLE_ICON;
			SetViewModeValid();
			break;

		case VIEW_TYPE_SMALL_ICON:
			m_ulViewMode = MMCLV_VIEWSTYLE_SMALLICON;
			SetViewModeValid();
			break;

		case VIEW_TYPE_REPORT:
			m_ulViewMode = MMCLV_VIEWSTYLE_REPORT;
			SetViewModeValid();
			break;

		case VIEW_TYPE_LIST:
			m_ulViewMode = MMCLV_VIEWSTYLE_LIST;
			SetViewModeValid();
			break;

		case VIEW_TYPE_FILTERED:
			m_ulViewMode = MMCLV_VIEWSTYLE_FILTERED;
			SetViewModeValid();
			break;

		default:
			// Should never come here.
			ASSERT(FALSE);
			break;
		}
	}

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Reads the given version of CViewSettings from stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - version of CColumnSortInfo to be read.
//
//                          The format is :
//                              VIEW_TYPE
//                              View Options
//                              String (If VIEW_TYPE is OCX or Web).
//
//--------------------------------------------------------------------
HRESULT CViewSettings::ReadSerialObject(IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume unknown version

    if  ( (4 <= nVersion))
    {
        try
        {
            VIEW_TYPE viewType;
            long      lViewOptions;

            // ugly hackery required to extract directly into an enum
            stm >> *((int *) &viewType);
            stm >> lViewOptions;

            wstring wstrViewName;

            if( (VIEW_TYPE_OCX==viewType) || (VIEW_TYPE_WEB==viewType) )
                stm >> wstrViewName;

            if(2<=nVersion)             // taskpads were added in version 2 of this object.
            {
                stm >> m_guidTaskpad;
                SetTaskpadIDValid(GUID_NULL != m_guidTaskpad);
            }

            if (3<=nVersion)
                stm >> m_dwRank;

            DWORD dwMask = 0;
			bool bViewTypeValid = true;
            if (4 <= nVersion)
			{
                stm >> dwMask;

				const DWORD MMC12_VIEWSET_MASK_TYPE        = 0x0001;
				bViewTypeValid = ( dwMask & MMC12_VIEWSET_MASK_TYPE );
			}

            hr = ScInitialize(bViewTypeValid, viewType, lViewOptions, wstrViewName).ToHr();
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CViewSettings::Persist
//
//  Synopsis:   persist to / from XML document.
//
//  Arguments:  [persistor]  - target or source.
//
//--------------------------------------------------------------------
void CViewSettings::Persist(CPersistor& persistor)
{
    // First Load or Save the mask. (Mask tells which members are valid).

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedMasks[] =
    {
        { VIEWSET_MASK_VIEWMODE,        XML_BITFLAG_VIEWSET_MASK_VIEWMODE },
        { VIEWSET_MASK_RVTYPE,          XML_BITFLAG_VIEWSET_MASK_RVTYPE },
        { VIEWSET_MASK_TASKPADID,       XML_BITFLAG_VIEWSET_MASK_TASKPADID },
    };

    // create wrapper to persist flag values as strings
    CXMLBitFlags maskPersistor(m_dwMask, mappedMasks, countof(mappedMasks));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_MASK, maskPersistor);

    if (IsTaskpadIDValid())
        persistor.Persist(m_guidTaskpad);

    if (IsViewModeValid())
    {
        // define the table to map enumeration values to strings
        static const EnumLiteral mappedModes[] =
        {
            { MMCLV_VIEWSTYLE_ICON,         XML_ENUM_LV_STYLE_ICON },
            { MMCLV_VIEWSTYLE_SMALLICON,    XML_ENUM_LV_STYLE_SMALLICON },
            { MMCLV_VIEWSTYLE_LIST,         XML_ENUM_LV_STYLE_LIST },
            { MMCLV_VIEWSTYLE_REPORT,       XML_ENUM_LV_STYLE_REPORT },
            { MMCLV_VIEWSTYLE_FILTERED,     XML_ENUM_LV_STYLE_FILTERED },
        };

        // create wrapper to persist flag values as strings
        CXMLEnumeration modePersistor(m_ulViewMode, mappedModes, countof(mappedModes));
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_VIEW_SETNGS_VIEW_MODE, modePersistor);
    }

    if (IsResultViewTypeValid())
        // Call CResultViewType to persist itself.
        persistor.Persist(m_RVType);

    bool bPeristRank = true;
    if (persistor.IsLoading())
        m_dwRank = (DWORD)-1; // make sure it's initialized if fails to load
    else
        bPeristRank = (m_dwRank != (DWORD)-1); // persist only if is used

    if (bPeristRank)
        persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_RANK, m_dwRank, attr_optional);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScGetViewMode
//
//  Synopsis:    Gets the view mode in list view.
//
//  Arguments:   [ulViewMode] - New view mode.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScGetViewMode (ULONG& ulViewMode)
{
    SC sc;

    if (!IsViewModeValid())
        return (sc = E_FAIL);

    ulViewMode = m_ulViewMode;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScSetViewMode
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScSetViewMode (const ULONG ulViewMode)
{
    SC sc;

    m_ulViewMode = ulViewMode;
    SetViewModeValid();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScGetTaskpadID
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScGetTaskpadID (GUID& guidTaskpad)
{
    SC sc;

    if (! IsTaskpadIDValid())
        return (sc = E_FAIL);

    guidTaskpad = m_guidTaskpad;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScSetTaskpadID
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScSetTaskpadID (const GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CViewSettings::ScSetTaskpadID"));

    m_guidTaskpad = guidTaskpad;
	SetTaskpadIDValid(true);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScGetResultViewType
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScGetResultViewType (CResultViewType& rvt)
{
    SC sc;

    if (! IsResultViewTypeValid())
        return (sc = E_FAIL);

    rvt = m_RVType;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettings::ScSetResultViewType
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettings::ScSetResultViewType (const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CViewSettings::ScSetResultViewType"));

    m_RVType = rvt;
    SetResultViewTypeValid();

    // ResultViewType changes, if new result-pane contains list use
    // current view mode if one exists else invalidate view mode data.
	if (!rvt.HasList())
	    SetViewModeValid(false);

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\xmlicon.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlicon.cpp
 *
 *  Contents:  Implementation file for CXMLIcon
 *
 *  History:   26-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "xmlicon.h"
#include "xmlimage.h"
#include <atlapp.h>
#include <atlgdi.h>


/*+-------------------------------------------------------------------------*
 * ScGetIconSize
 *
 * Returns the width/height of a given icon (the width and height of icons
 * are always equal).
 *--------------------------------------------------------------------------*/

SC ScGetIconSize (HICON hIcon, int& nIconSize)
{
	DECLARE_SC (sc, _T("ScGetIconSize"));

	ICONINFO ii;
	if (!GetIconInfo (hIcon, &ii))
		return (sc.FromLastError());

	/*
	 * GetIconInfo creates bitmaps that we're responsible for deleting;
	 * attach the bitmaps to smart objects so cleanup is assured
	 */
	WTL::CBitmap bmMask  = ii.hbmMask;
	WTL::CBitmap bmColor = ii.hbmColor;

	/*
	 * get the dimensions of the mask bitmap (don't use the color bitmap,
	 * since that's not present for monochrome icons)
	 */
	BITMAP bmData;
	if (!bmMask.GetBitmap (bmData))
		return (sc.FromLastError());

	nIconSize = bmData.bmWidth;
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CXMLIcon::Persist
 *
 * Saves/loads a CXMLIcon to a CPersistor.
 *--------------------------------------------------------------------------*/

void CXMLIcon::Persist (CPersistor &persistor)
{
	DECLARE_SC (sc, _T("CXMLIcon::Persist"));

	CXMLImageList iml;

	try
	{
		if (persistor.IsStoring())
		{
			ASSERT (operator HICON() != NULL);

			/*
			 * find out how big the icon is
			 */
			int cxIcon;
			sc = ScGetIconSize (*this, cxIcon);
			if (sc)
				sc.Throw();

			/*
			 * create an imagelist to accomodate it
			 */
			if (!iml.Create (cxIcon, cxIcon, ILC_COLOR16 | ILC_MASK, 1, 1))
				sc.FromLastError().Throw();

			/*
			 * add the icon to the imagelist
			 */
			if (iml.AddIcon(*this) == -1)
				sc.FromLastError().Throw();
		}

		iml.Persist (persistor);

		if (persistor.IsLoading())
		{
			/*
			 * extract the icon from the imagelist
			 */
			Attach (iml.GetIcon (0));
		}
	}
	catch (...)
	{
		/*
		 * WTL::CImageList doesn't auto-destroy its HIMAGELIST, so we have to do it manually
		 */
		iml.Destroy();
		throw;
	}

	/*
	 * WTL::CImageList doesn't auto-destroy its HIMAGELIST, so we have to do it manually
	 */
	iml.Destroy();
}


/*+-------------------------------------------------------------------------*
 * CXMLIcon::GetBinaryEntryName
 *
 * Returns the name to be attached to this CXMLIcon's entry in the XML
 * binary data collection.
 *--------------------------------------------------------------------------*/

LPCTSTR CXMLIcon::GetBinaryEntryName()			
{
	if (m_strBinaryEntryName.empty())
		return (NULL);

	return (m_strBinaryEntryName.data());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\util.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       util.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7/8/1996   RaviR   Created
//
//____________________________________________________________________________

#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"
#include <Atlbase.h>
#include <winnls.h>
#include "tstring.h"
#include "strings.h"

#define MMC_ATL ::ATL
#include <atlbase.h>
using namespace MMC_ATL;

/* define these ourselves until they're defined properly in commctrl.h */
#ifndef ILP_DOWNLEVEL
#define ILP_NORMAL          0           // Writes or reads the stream using new sematics for this version of comctl32
#define ILP_DOWNLEVEL       1           // Write or reads the stream using downlevel sematics.

WINCOMMCTRLAPI HRESULT WINAPI ImageList_ReadEx(DWORD dwFlags, LPSTREAM pstm, REFIID riid, PVOID* ppv);
WINCOMMCTRLAPI HRESULT WINAPI ImageList_WriteEx(HIMAGELIST himl, DWORD dwFlags, LPSTREAM pstm);
#endif


ULONG _ttoul(LPTSTR psz)
{
    ULONG ul;

    for (ul = 0; *psz != TEXT('\0'); ++psz)
    {
        ul = ul * 10 + (*psz - TEXT('0'));
    }

    return ul;
}


WORD I_SplitModuleAndResourceID(LPCTSTR szBuf)
{
    WORD wID = (WORD)-1;

    // String must be in the form "module, res_id"

    for (TCHAR *ptc = (TCHAR *)szBuf;
         *ptc != TEXT('\0') && *ptc != TEXT(',');
         ptc++);

    // If no comma - return
    if (*ptc != TEXT(','))
        return wID;

    *ptc = TEXT('\0');

    ++ptc;

    while (*ptc == TEXT(' ') && *ptc != TEXT('\0'))
    {
        ++ptc;
    }

    // If it does not have a res_id break.
    if (*ptc == TEXT('\0'))
        return wID;

    // Get the res-id
    wID = (WORD)_ttoul(ptc);

    return wID;
}


BOOL
I_GetStrFromModule(
    LPCTSTR     pszModule,
    ULONG       ulMsgNo,
    CStr        &strBuf)
{
    TCHAR       szBuf[512];
    ULONG       cchBuf = 512;

    HINSTANCE hinst = LoadLibraryEx(pszModule, NULL,
                                    LOAD_LIBRARY_AS_DATAFILE);
    if (hinst)
    {
        LANGID lidUser = LANGIDFROMLCID(GetUserDefaultLCID());

        DWORD cChars = ::FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                            (HMODULE)hinst,
                            ulMsgNo,
                            lidUser,
                            szBuf,
                            cchBuf,
                            NULL);

        FreeLibrary(hinst);

        if (cChars != 0)
        {
            strBuf = szBuf;
            return TRUE;
        }
    }

    //Dbg(DEB_USER1, _T("I_GetStringFromModule failed<%dL>\n"), GetLastError());

    return FALSE;
}

HICON I_GetHicon(LPCTSTR pszModule, ULONG ulId)
{
    HICON hIcon = NULL;

    HINSTANCE hinst = LoadLibraryEx(pszModule, NULL,
                                    LOAD_LIBRARY_AS_DATAFILE);
    if (hinst)
    {
        hIcon = LoadIcon(hinst, MAKEINTRESOURCE(ulId));

        FreeLibrary(hinst);
    }

    return hIcon;
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDupString
//
//  Synopsis:   Allocates memory & duplicates a given string.
//
//  Arguments:  [lpszIn]   -- IN the string to duplicate.
//
//  Returns:    The duplicated string. Throws exception if out of memory.
//
//+---------------------------------------------------------------------------

LPTSTR NewDupString(LPCTSTR lpszIn)
{
    register ULONG len = lstrlen(lpszIn) + 1;

    TCHAR * lpszOut = new TCHAR[len];
    if (lpszOut == NULL)
        return NULL;

    CopyMemory(lpszOut, lpszIn, len * sizeof(TCHAR));

    return lpszOut;
}


//+---------------------------------------------------------------------------
//
//  Function:   CoTaskDupString
//
//  Synopsis:   Allocates memory & duplicates a given string.
//
//  Arguments:  [lpszIn]   -- IN the string to duplicate.
//
//  Returns:    The duplicated string. Throws exception if out of memory.
//
//+---------------------------------------------------------------------------
// Tony
LPSTR CoTaskDupString(LPCSTR lpszIn)
{
    if (lpszIn == NULL)
        return NULL;

    ULONG cbTemp = (strlen(lpszIn) + 1) * sizeof(*lpszIn);
    LPSTR lpszOut = (LPSTR) CoTaskMemAlloc(cbTemp);

    if (lpszOut != NULL)
        CopyMemory(lpszOut, lpszIn, cbTemp);

    return (lpszOut);
}

LPWSTR CoTaskDupString(LPCWSTR lpszIn)
{
    if (lpszIn == NULL)
        return NULL;

    ULONG cbTemp = (wcslen(lpszIn) + 1) * sizeof(*lpszIn);
    LPWSTR lpszOut = (LPWSTR) CoTaskMemAlloc(cbTemp);

    if (lpszOut != NULL)
        CopyMemory(lpszOut, lpszIn, cbTemp);

    return (lpszOut);
}

//+---------------------------------------------------------------------------
//
//  Function:   GUIDToString
//              GUIDFromString
//
//  Synopsis:   Converts between GUID& and CStr
//
//  Returns:    FALSE for invalid string, or CMemoryException
//
//+---------------------------------------------------------------------------

HRESULT GUIDToCStr(CStr& str, const GUID& guid)
{
    LPOLESTR lpolestr = NULL;
    HRESULT hr = StringFromIID( guid, &lpolestr );
    if (FAILED(hr))
    {
        //TRACE("GUIDToString error %ld\n", hr);
        return hr;
    }
    else
    {
        str = lpolestr;
        CoTaskMemFree(lpolestr);
    }
    return hr;
}

HRESULT GUIDFromCStr(const CStr& str, GUID* pguid)
{
    USES_CONVERSION;

    HRESULT hr = IIDFromString( T2OLE( const_cast<LPTSTR>((LPCTSTR)str) ), pguid );
    if (FAILED(hr))
    {
        //TRACE("GUIDFromString error %ld\n", hr);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoesFileExist
//
//  Synopsis:   Determines if the specified file exists. The file path may
//              include environment variables.
//
//  Returns:    TRUE/FALSE
//
//+---------------------------------------------------------------------------

BOOL DoesFileExist(LPCTSTR pszFilePath)
{
    TCHAR szExpandedPath[MAX_PATH];

    DWORD dwCnt = ExpandEnvironmentStrings(pszFilePath, szExpandedPath, MAX_PATH);
    if (dwCnt == 0 || dwCnt > MAX_PATH)
        return FALSE;

    return (::GetFileAttributes(szExpandedPath) != 0xffffffff);
}


/*+-------------------------------------------------------------------------*
 *
 * GetHelpFile
 *
 * PURPOSE: Returns a path to the help file
 *
 * RETURNS:
 *    static LPCTSTR
 *
 *+-------------------------------------------------------------------------*/
LPCTSTR GetHelpFile()
{
    static const TCHAR NEW_HELP_FILE_STR[] = _T("%windir%\\Help\\MMC_DLG.HLP");
    static const TCHAR OLD_HELP_FILE_STR[] = _T("%windir%\\Help\\MMC.HLP");

    static LPCTSTR pszHelpFile = NULL;

    // See if help file is present. Check new name first, then old name.
    // This is done because the old help file may be overwritten by
    // an MMC 1.0 installation (see NT bug 299590)

    if (pszHelpFile == NULL)
    {
        if (DoesFileExist(NEW_HELP_FILE_STR))
        {
            pszHelpFile = NEW_HELP_FILE_STR;
        }
        else if (DoesFileExist(OLD_HELP_FILE_STR))
        {
            pszHelpFile = OLD_HELP_FILE_STR;
        }
        else
        {
            // if neither file is present, then use the new file name.
            // This will let WinHelp display an error message indicating
            // that the file is missing and needs to be installed.
            pszHelpFile = NEW_HELP_FILE_STR;
        }
    }

    return pszHelpFile;
}

//+---------------------------------------------------------------------------
//
//  Function:   HelpWmHelp
//
//  Synopsis:   Calls WinHelp with the ID passed to display help
//
//  Returns:    none
//
//+---------------------------------------------------------------------------

void HelpWmHelp(LPHELPINFO pHelpInfo, const DWORD* pHelpIDs)
{
     if (pHelpInfo != NULL)
    {
        if (pHelpInfo->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            ASSERT(pHelpIDs != NULL);
            if (pHelpIDs)
            {
                ::WinHelp((HWND)pHelpInfo->hItemHandle, GetHelpFile(),
                          HELP_WM_HELP, (ULONG_PTR)(LPVOID)pHelpIDs);

            }
        }
    }
}

/*+-------------------------------------------------------------------------*
 *
 * HelpContextMenuHelp
 *
 * PURPOSE: Handle context menu help. Invoked when the user right-clicks
 *          on a dialog item and selects "What's this?"
 *
 * PARAMETERS:
 *    HWND       hWnd :
 *    ULONG_PTR  p :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void HelpContextMenuHelp(HWND hWnd, ULONG_PTR p)
{
    ::WinHelp (hWnd, GetHelpFile(), HELP_CONTEXTMENU, p);
}

/*+-------------------------------------------------------------------------*
 * InflateFont
 *
 * Inflates a LOGFONT by the a given number of points
 *--------------------------------------------------------------------------*/

bool InflateFont (LOGFONT* plf, int nPointsToGrowBy)
{
    if (nPointsToGrowBy != 0)
    {
        HDC hdc = GetWindowDC (NULL);

        if (hdc == NULL)
            return (FALSE);

        int nLogPixelsY = GetDeviceCaps (hdc, LOGPIXELSY);
        int nPoints     = -MulDiv (plf->lfHeight, 72, nLogPixelsY);
        nPoints        += nPointsToGrowBy;
        plf->lfHeight   = -MulDiv (nPoints, nLogPixelsY, 72);

        ReleaseDC (NULL, hdc);
    }

    return (true);
}

//+-------------------------------------------------------------------
//
//  Member:     GetTBBtnTextAndStatus
//
// Synopsis:   Helper routine to get one/two part button text resource.
//
//  Arguments:  [hInst]       - Instance handle.
//              [nID]         - String resource id.
//              [ppszButton]  - Button text.
//              [ppszToolTip] - Button status text.
//
//  Note:       Uses MFC CString.
//
//  Returns:    bool
//
//--------------------------------------------------------------------
bool GetTBBtnTextAndStatus(HINSTANCE hInst, int nID, std::wstring& szButton, std::wstring& szToolTip)
{
    USES_CONVERSION;

    CStr str;
    str.LoadString(hInst, nID);
    ASSERT(!str.IsEmpty());

    if (str.IsEmpty())
        return false;

    int iPos = str.Find(_T('\n'));
    if (-1 != iPos)
    {
        // Two strings. First from 0 to iPos-1
        // and second from iPos+1 to end.
        szButton = T2CW((LPCTSTR)str.Left(iPos));
        szToolTip = T2CW((LPCTSTR)str.Right(str.GetLength() - iPos - 1));
    }
    else
    {
        // Only one string. Use this for both text and status.
        szButton = T2CW((LPCTSTR)str);
        szToolTip = szButton;
    }

    return true;
}


#ifdef DBG

/*+-------------------------------------------------------------------------*
 * DrawOnDesktop
 *
 * Draws a bitmap, icon, or imagelist to a specific location on the desktop.
 *--------------------------------------------------------------------------*/

void DrawOnDesktop (HBITMAP hbm, int x, int y)
{
	HDC hdcDesktop = GetWindowDC (NULL);
	HDC hdcMem = CreateCompatibleDC (NULL);

	BITMAP bm;
	GetObject ((HGDIOBJ) hbm, sizeof(bm), &bm);
	HGDIOBJ hbmOld = SelectObject (hdcMem, (HGDIOBJ) hbm);
	BitBlt (hdcDesktop, x, y, bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);
	SelectObject (hdcMem, hbmOld);

	DeleteDC  (hdcMem);
	ReleaseDC (NULL, hdcDesktop);
}


void DrawOnDesktop (HICON hIcon, int x, int y)
{
	HDC hdcDesktop = GetWindowDC (NULL);
	DrawIconEx (hdcDesktop, x, y, hIcon, 0, 0, 0, NULL, DI_NORMAL);
	ReleaseDC (NULL, hdcDesktop);
}


void DrawOnDesktop (HIMAGELIST himl, int x, int y, int iImage /*=-1*/)
{
	HDC hdcDesktop = GetWindowDC (NULL);

	/*
	 * draw all images?
	 */
	if (iImage == -1)
	{
		int cImages = ImageList_GetImageCount (himl);
		int cxImage, cyImage;
		ImageList_GetIconSize (himl, &cxImage, &cyImage);

		for (int i = 0; i < cImages; i++, x += cxImage)
		{
			ImageList_Draw (himl, i, hdcDesktop, x, y, ILD_NORMAL);
		}
	}
	else
	{
		/*
		 * draw a specific image
		 */
		ImageList_Draw (himl, iImage, hdcDesktop, x, y, ILD_NORMAL);
	}

	ReleaseDC (NULL, hdcDesktop);
}

#endif	// DBG


/*+-------------------------------------------------------------------------*
 * StripTrailingWhitespace
 *
 * Removes the whitespace at the end of the input string.  Returns a pointer
 * the the beginning of the string.
 *--------------------------------------------------------------------------*/

LPTSTR StripTrailingWhitespace (LPTSTR pszStart)
{
    for (LPTSTR pch = pszStart + _tcslen(pszStart) - 1; pch > pszStart; pch--)
    {
        /*
         * if this isn't a whitespace character, terminate just after this position
         */
        if (!_istspace (*pch))
        {
            *++pch = 0;
            break;
        }
    }

    return (pszStart);
}

/***************************************************************************\
 *
 * METHOD:  PrivateSetLayout
 *
 * PURPOSE: Wrapper to invoke GDI function when it is available,
 *			but not to depend on its availability
 *
 * PARAMETERS:
 *    HDC hdc
 *    DWORD dwLayout
 *
 * RETURNS:
 *    DWORD    - previous layout, GDI_ERROR on error
 *
\***************************************************************************/
DWORD PrivateSetLayout( HDC hdc, DWORD dwLayout )
{
	// static pointer to function
	static BOOL (WINAPI* pfnSetLayout)(HDC, DWORD) = NULL;
	static bool bTriedToGetFunction = false;

	if ( !bTriedToGetFunction )
	{
		bTriedToGetFunction = true;
		HINSTANCE hmodGdi = GetModuleHandle (_T("Gdi32.dll"));

		if (hmodGdi != NULL)
			(FARPROC&)pfnSetLayout = GetProcAddress (hmodGdi, "SetLayout");
	}

    if (pfnSetLayout == NULL)
		return GDI_ERROR;

	return (*pfnSetLayout)(hdc, dwLayout);
}

/***************************************************************************\
 *
 * METHOD:  PrivateGetLayout
 *
 * PURPOSE: Wrapper to invoke GDI function when it is available,
 *			but not to depend on its availability
 *
 * PARAMETERS:
 *    HDC hdc
 *
 * RETURNS:
 *    DWORD    - layout, 0 if function not found
 *
\***************************************************************************/
DWORD PrivateGetLayout( HDC hdc )
{
	// static pointer to function
	static BOOL (WINAPI* pfnGetLayout)(HDC) = NULL;
	static bool bTriedToGetFunction = false;

	if ( !bTriedToGetFunction )
	{
		bTriedToGetFunction = true;
		HINSTANCE hmodGdi = GetModuleHandle (_T("Gdi32.dll"));

		if (hmodGdi != NULL)
			(FARPROC&)pfnGetLayout = GetProcAddress (hmodGdi, "GetLayout");
	}

    if (pfnGetLayout == NULL)
		return 0; // at least not LAYOUT_RTL

	return (*pfnGetLayout)(hdc);
}


/*+-------------------------------------------------------------------------*
 * IsWhistler
 *
 * Returns true if we're running on Whistler or higher, false otherwise.
 *--------------------------------------------------------------------------*/
bool IsWhistler ()
{
	static bool fFirstTime = true;
	static bool fWhistler  = false;

	if (fFirstTime)
	{
		fFirstTime = false;

		OSVERSIONINFO vi;
		vi.dwOSVersionInfoSize = sizeof(vi);
		GetVersionEx (&vi);

		fWhistler = (vi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
					((vi.dwMajorVersion >  5) ||
					 (vi.dwMajorVersion == 5) && (vi.dwMinorVersion >= 1));
	}

	return (fWhistler);
}


/*+-------------------------------------------------------------------------*
 * WriteCompatibleImageList
 *
 * Writes an imagelist to a stream in a format that's guaranteed to be
 * compatible with comctl32 version 5 imagelists.
 *--------------------------------------------------------------------------*/
HRESULT WriteCompatibleImageList (HIMAGELIST himl, IStream* pstm)
{
	/*
	 * If we're running on Whistler, we might be trying to write a v6
	 * imagelist.  Try to write it in a v5-compatible format with
	 * ImageList_WriteEx.
	 */
	if (IsWhistler())
	{
		/*
		 * ImageList_WriteEx will return E_NOINTERFACE if we're actually
		 * writing a v5 imagelist, in which case we want to write with
		 * ImageList_Write.  In any other case (success or failure), we
		 * just want to return.
		 */
		HRESULT hr = ImageList_WriteEx (himl, ILP_DOWNLEVEL, pstm);
		if (hr != E_NOINTERFACE)
			return (hr);
	}

	/*
	 * if we get here, we have a v5 imagelist -- just write it
	 */
	return (ImageList_Write (himl, pstm));
}


/*+-------------------------------------------------------------------------*
 * ReadCompatibleImageList
 *
 * Reads an imagelist from a stream that's in version 5 format.
 *--------------------------------------------------------------------------*/
HRESULT ReadCompatibleImageList (IStream* pstm, HIMAGELIST& himl)
{
	HRESULT hr = S_OK;

	/*
	 * init the out parameter
	 */
	himl = NULL;

	/*
	 * If we're running on Whistler, we're trying to create a v6
	 * imagelist from the stream.  Do it in a v5-compatible manner
	 * with ImageList_ReadEx.
	 */
	if (IsWhistler())
	{
		/*
		 * HACK:  We have to query ImageList_ReadEx for IID_IImageList -- the
		 * one defined by the shell, not the one defined by MMC.  If we
		 * just refer to "IID_IImageList" in the code here, we'll get MMC's
		 * version, not the shell's.  The right way to fix it is to rename
		 * the shell's IImageList interface (since MMC's interface was defined
		 * and published first), but that's not going to happen.
		 *
		 * We'll hardcode the IID's value in a string here and convert it
		 * to an IID on the fly.  Ugh.
		 */
		IID iidShellImageList = {0};
		hr = CLSIDFromString (L"{46eb5926-582e-4017-9fdf-e8998daa0950}", &iidShellImageList);
		if (FAILED (hr))
			return (hr);

		/*
		 * ImageList_ReadEx will return E_NOINTERFACE if we're actually
		 * writing a v5 imagelist, in which case we want to write with
		 * ImageList_Write.  In any other case (success or failure), we
		 * just want to return.
		 */
		IUnknownPtr spUnk;
		hr = ImageList_ReadEx (ILP_DOWNLEVEL, pstm, iidShellImageList, (void**) &spUnk);
		if (FAILED (hr))
			return (hr);

		/*
		 * The IUnknown *is* the HIMAGELIST.  Don't release it here,
		 * ImageList_Destroy will take care of it.
		 */
		himl = reinterpret_cast<HIMAGELIST>(spUnk.Detach());
	}
	else
	{
		/*
		 * non-Whistler, just read it normally
		 */
		himl = ImageList_Read (pstm);

		/*
		 * If the read failed, get the last error.  Just in case ImageList_Read
		 * didn't set the last error, make sure we return a failure code.
		 */
		if (himl == NULL)
		{
			hr = HRESULT_FROM_WIN32 (GetLastError());
			if (!FAILED (hr))
				hr = E_FAIL;
		}
	}

	return (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     MmcDownlevelActivateActCtx
//
//  Synopsis:   Calls ActivateActCtx to set the activation context to V5
//              common controls. This is needed before calling into snapins
//              so that snapin created windows are not themed accidentally.
//
//              The snapin can theme its windows by calling appropriate
//              fusion apis while calling create-window.
//
// Description:
//              When MMC calls into the snapin if the last winproc which
//              received a window message is themed and will result in a
//              call to snapin then we will call the snapin in themed
//              context. If snapin creates & displays any UI then it will
//              be themed. This function is to de-activate the theming
//              before calling the snapin.
//
//  Arguments:
//              [hActCtx]    - 	See ActivateActCtx API details
//              [pulCookie]  -  See ActivateActCtx API details
//
//  Returns:    BOOL, TRUE if we could de-activate V6 context and switch to V5 context
//                         or if we are in V5 context (W2K, Win95, Win98...)
//                    FALSE if ActivateActCtx returns failure.
//
//--------------------------------------------------------------------
BOOL WINAPI MmcDownlevelActivateActCtx(HANDLE hActCtx, ULONG_PTR* pulCookie) 
{
    typedef BOOL (WINAPI* PFN)(HANDLE hActCtx, ULONG_PTR* pulCookie);
    static PFN s_pfn;
    static DWORD s_dwError;

    if (s_pfn == NULL && s_dwError == 0)
        if ((s_pfn = (PFN)GetProcAddress(GetModuleHandleA("Kernel32.dll"), "ActivateActCtx")) == NULL)
            s_dwError = (GetLastError() == NO_ERROR) ? ERROR_INTERNAL_ERROR : GetLastError();

    if (s_pfn != NULL)
        return s_pfn(hActCtx, pulCookie);

    SetLastError(s_dwError);

	if (s_dwError == ERROR_PROC_NOT_FOUND)
		return TRUE;

    return FALSE;
}


//+-------------------------------------------------------------------
//
//  Member:     MmcDownlevelDeactivateActCtx
//
//  Synopsis:   Calls DeactivateActCtx to restore the activation context.
//              This is needed after calling into snapins, so that
//              if we called from themed context then it is restored.
//
// Description:
//              When MMC calls into the snapin if the last winproc which
//              received a window message is themed and will result in a
//              call to snapin then we will call the snapin in themed
//              context. If snapin creates & displays any UI then it will
//              be themed. This function is to de-activate the theming
//              before calling the snapin.
//
//  Arguments:
//              [dwFlags]   -  See DeactivateActCtx API details
//              [ulCookie]  -  See DeactivateActCtx API details
//
//  Returns:    None
//
//--------------------------------------------------------------------
VOID WINAPI MmcDownlevelDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie) 
{
    typedef VOID (WINAPI* PFN)(DWORD dwFlags, ULONG_PTR ulCookie);
    static PFN s_pfn;
    static BOOL s_fInited;

    if (!s_fInited)
        s_pfn = (PFN)GetProcAddress(GetModuleHandleA("Kernel32.dll"), "DeactivateActCtx");

    s_fInited = TRUE;

    if (s_pfn != NULL)
        s_pfn(dwFlags, ulCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\xmlimage.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlimage.cpp
 *
 *  Contents:  Implementation file for CXMLImageList
 *
 *  History:   10-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "xmlimage.h"
#include "util.h"


/*+-------------------------------------------------------------------------*
 * CXMLImageList::Persist
 *
 * Saves/loads a CXMLImageList to a CPersistor.
 *--------------------------------------------------------------------------*/

void CXMLImageList::Persist (CPersistor &persistor)
{
	DECLARE_SC (sc, _T("CXMLImageList::Persist"));

    // try to get IStream first, to avoid cleanup if it fails [and throws] (audriusz)
    CXML_IStream xmlStream;

    if (persistor.IsStoring())
    {
        ASSERT (!IsNull());

		/*
		 * write the imagelist to the stream
		 */
        IStreamPtr spStream;
        sc = xmlStream.ScGetIStream( &spStream );
        if (sc)
            sc.Throw();

        sc = WriteCompatibleImageList (m_hImageList, spStream);
        if (sc)
            sc.Throw();
    }

    xmlStream.Persist (persistor);

    if (persistor.IsLoading())
    {
		/*
		 * get rid of the imagelist that's there, if any
		 */
		Destroy();
		ASSERT (IsNull());

		/*
		 * reconstitute the imagelist from the stream
		 */
        IStreamPtr spStream;
        sc = xmlStream.ScGetIStream( &spStream );
        if (sc)
            sc.Throw();

        sc = ReadCompatibleImageList (spStream, m_hImageList);
        if (sc)
            sc.Throw();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helputil.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Oct 02 14:40:10 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HelpUtil.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HelpUtil_h__
#define __HelpUtil_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpUtilities_FWD_DEFINED__
#define __IVsHelpUtilities_FWD_DEFINED__
typedef interface IVsHelpUtilities IVsHelpUtilities;
#endif 	/* __IVsHelpUtilities_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IVsHelpUtilities_INTERFACE_DEFINED__
#define __IVsHelpUtilities_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpUtilities
 * at Thu Oct 02 14:40:10 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac9-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpUtilities : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BuildFullPathName( 
            /* [in] */ LPCOLESTR pszHelpFileName,
            /* [out] */ BSTR __RPC_FAR *bstrHelpFullPathName,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpUtilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpUtilities __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpUtilities __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpUtilities __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BuildFullPathName )( 
            IVsHelpUtilities __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszHelpFileName,
            /* [out] */ BSTR __RPC_FAR *bstrHelpFullPathName,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IVsHelpUtilitiesVtbl;

    interface IVsHelpUtilities
    {
        CONST_VTBL struct IVsHelpUtilitiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpUtilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpUtilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpUtilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpUtilities_BuildFullPathName(This,pszHelpFileName,bstrHelpFullPathName,dwReserved)	\
    (This)->lpVtbl -> BuildFullPathName(This,pszHelpFileName,bstrHelpFullPathName,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpUtilities_BuildFullPathName_Proxy( 
    IVsHelpUtilities __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszHelpFileName,
    /* [out] */ BSTR __RPC_FAR *bstrHelpFullPathName,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpUtilities_BuildFullPathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpUtilities_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helpsys.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Wed Nov 19 15:26:49 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HelpSys.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HelpSys_h__
#define __HelpSys_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpSystem_FWD_DEFINED__
#define __IVsHelpSystem_FWD_DEFINED__
typedef interface IVsHelpSystem IVsHelpSystem;
#endif 	/* __IVsHelpSystem_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_HelpSys_0000
 * at Wed Nov 19 15:26:49 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


typedef /* [v1_enum] */ 
enum _VHS_COMMANDS
    {	VHS_Default	= 0,
	VHS_NoErrorMessages	= 0x8,
	VHS_UseBrowser	= 0x1,
	VHS_UseHelp	= 0x2,
	VHS_Localize	= 0x4
    }	VHS_COMMAND;



extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0000_v0_0_s_ifspec;

#ifndef __IVsHelpSystem_INTERFACE_DEFINED__
#define __IVsHelpSystem_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpSystem
 * at Wed Nov 19 15:26:49 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac0-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearch( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ALinkSearch( 
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearchDlg( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FullTextSearchDlg( 
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentURL( 
            /* [out] */ BSTR __RPC_FAR *ppszURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromURL( 
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromIdentifier( 
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD Id,
            /* [in] */ const DWORD Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ActivateHelpSystem( 
            /* [in] */ const DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpSystem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpSystem __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeywordSearch )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ALinkSearch )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeywordSearchDlg )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FullTextSearchDlg )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentURL )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *ppszURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromURL )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromIdentifier )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD Id,
            /* [in] */ const DWORD Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ActivateHelpSystem )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ const DWORD dwFlags);
        
        END_INTERFACE
    } IVsHelpSystemVtbl;

    interface IVsHelpSystem
    {
        CONST_VTBL struct IVsHelpSystemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpSystem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpSystem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpSystem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpSystem_KeywordSearch(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearch(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_ALinkSearch(This,pszALink,dwFlags,dwReserved)	\
    (This)->lpVtbl -> ALinkSearch(This,pszALink,dwFlags,dwReserved)

#define IVsHelpSystem_KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)	\
    (This)->lpVtbl -> FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)

#define IVsHelpSystem_GetCurrentURL(This,ppszURL)	\
    (This)->lpVtbl -> GetCurrentURL(This,ppszURL)

#define IVsHelpSystem_DisplayTopicFromURL(This,pszURL,Command)	\
    (This)->lpVtbl -> DisplayTopicFromURL(This,pszURL,Command)

#define IVsHelpSystem_DisplayTopicFromIdentifier(This,pszFile,Id,Command)	\
    (This)->lpVtbl -> DisplayTopicFromIdentifier(This,pszFile,Id,Command)

#define IVsHelpSystem_ActivateHelpSystem(This,dwFlags)	\
    (This)->lpVtbl -> ActivateHelpSystem(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearch_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ALinkSearch_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszALink,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_ALinkSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearchDlg_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_FullTextSearchDlg_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszQuery,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_FullTextSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_GetCurrentURL_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *ppszURL);


void __RPC_STUB IVsHelpSystem_GetCurrentURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromURL_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszURL,
    /* [in] */ const DWORD Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromIdentifier_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFile,
    /* [in] */ const DWORD Id,
    /* [in] */ const DWORD Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ActivateHelpSystem_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ const DWORD dwFlags);


void __RPC_STUB IVsHelpSystem_ActivateHelpSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpSystem_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_HelpSys_0136
 * at Wed Nov 19 15:26:49 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SVsHelpService IID_IVsHelpSystem
#define SID_SHelpService IID_IVsHelpSystem

enum VsHelpErrors
    {	VSHELP_E_HTMLHELP_UNKNOWN	= 0x80000000 | 4 << 16 | 0x1000,
	VSHELP_E_COLLECTIONDOESNOTEXIST	= 0x80000000 | 4 << 16 | 0x1001,
	VSHELP_E_COLLECTIONNOTREGISTERED	= 0x80000000 | 4 << 16 | 0x1002,
	VSHELP_E_REGISTRATION	= 0x80000000 | 4 << 16 | 0x1003,
	VSHELP_E_PREFERREDCOLLECTION	= 0x80000000 | 4 << 16 | 0x1004
    };


extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HelpSys_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helpsvcs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Oct 02 14:40:12 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HELPSVCS.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __HelpSvcs_h__
#define __HelpSvcs_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __VsHelpServices_FWD_DEFINED__
#define __VsHelpServices_FWD_DEFINED__

#ifdef __cplusplus
typedef class VsHelpServices VsHelpServices;
#else
typedef struct VsHelpServices VsHelpServices;
#endif /* __cplusplus */

#endif 	/* __VsHelpServices_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "helpsys.h"
#include "helpinit.h"
#include "helputil.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __VsHelpServices_LIBRARY_DEFINED__
#define __VsHelpServices_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: VsHelpServices
 * at Thu Oct 02 14:40:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_VsHelpServices;

EXTERN_C const CLSID CLSID_VsHelpServices;

#ifdef __cplusplus

class DECLSPEC_UUID("854d7ac5-bc3d-11d0-b421-00a0c90f9dc4")
VsHelpServices;
#endif
#endif /* __VsHelpServices_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\devbin\htmlhelp\v6\idl\include\helpinit.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Oct 02 14:40:08 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HelpInit.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HelpInit_h__
#define __HelpInit_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpInit_FWD_DEFINED__
#define __IVsHelpInit_FWD_DEFINED__
typedef interface IVsHelpInit IVsHelpInit;
#endif 	/* __IVsHelpInit_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IVsHelpInit_INTERFACE_DEFINED__
#define __IVsHelpInit_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpInit
 * at Thu Oct 02 14:40:08 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac3-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpInit : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOwner( 
            /* [in] */ const HWND hwndOwner) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadUIResources( 
            /* [in] */ LCID lcidResources) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCollection( 
            /* [in] */ LPCOLESTR pszCollectionPathname,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetApplicationHelpDirectory( 
            /* [in] */ LPCOLESTR pszHelpDirectory,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetApplicationHelpLCID( 
            /* [in] */ LCID lcidCollection,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpInit __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOwner )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ const HWND hwndOwner);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadUIResources )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LCID lcidResources);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCollection )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszCollectionPathname,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationHelpDirectory )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszHelpDirectory,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationHelpLCID )( 
            IVsHelpInit __RPC_FAR * This,
            /* [in] */ LCID lcidCollection,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IVsHelpInitVtbl;

    interface IVsHelpInit
    {
        CONST_VTBL struct IVsHelpInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpInit_SetOwner(This,hwndOwner)	\
    (This)->lpVtbl -> SetOwner(This,hwndOwner)

#define IVsHelpInit_LoadUIResources(This,lcidResources)	\
    (This)->lpVtbl -> LoadUIResources(This,lcidResources)

#define IVsHelpInit_SetCollection(This,pszCollectionPathname,dwReserved)	\
    (This)->lpVtbl -> SetCollection(This,pszCollectionPathname,dwReserved)

#define IVsHelpInit_SetApplicationHelpDirectory(This,pszHelpDirectory,dwReserved)	\
    (This)->lpVtbl -> SetApplicationHelpDirectory(This,pszHelpDirectory,dwReserved)

#define IVsHelpInit_SetApplicationHelpLCID(This,lcidCollection,dwReserved)	\
    (This)->lpVtbl -> SetApplicationHelpLCID(This,lcidCollection,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetOwner_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ const HWND hwndOwner);


void __RPC_STUB IVsHelpInit_SetOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_LoadUIResources_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LCID lcidResources);


void __RPC_STUB IVsHelpInit_LoadUIResources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetCollection_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszCollectionPathname,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpInit_SetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetApplicationHelpDirectory_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszHelpDirectory,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpInit_SetApplicationHelpDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpInit_SetApplicationHelpLCID_Proxy( 
    IVsHelpInit __RPC_FAR * This,
    /* [in] */ LCID lcidCollection,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpInit_SetApplicationHelpLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpInit_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\core\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.3, July 9th, 1998

  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.3"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\setup\vbsnapcleanup\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$O\amc.res: ..\..\types\idl\websnk.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98\inc\ad98.h ===
//=--------------------------------------------------------------------------=
// AD98.H
//=--------------------------------------------------------------------------=
// Copyright (c) 1997-1998, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
// ActiveX[tm] Designer interfaces that are new for 1998.
//=--------------------------------------------------------------------------=
#ifndef _AD98_H_
#define _AD98_H_

#include "designer.h"

//=--------------------------------------------------------------------------=
// DesignerFeatures
//=--------------------------------------------------------------------------=
#define DESIGNERFEATURE_CANBEPUBLIC             0x00000001
#define DESIGNERFEATURE_MUSTBEPUBLIC            0x00000002
#define DESIGNERFEATURE_CANCREATE               0x00000004
#define DESIGNERFEATURE_PREDECLAREDID           0x00000008
#define DESIGNERFEATURE_DONTSITE                0x00000010
#define DESIGNERFEATURE_REGISTRATION            0x00000020
#define DESIGNERFEATURE_INPROCONLY              0x00000040
#define DESIGNERFEATURE_DELAYEVENTSINKING       0x00000080
#define DESIGNERFEATURE_NOTIFYBEFORERUN         0x00000100
#define DESIGNERFEATURE_NOTIFYAFTERRUN          0x00000200
#define DESIGNERFEATURE_STARTUPINFO             0x00000400

//=--------------------------------------------------------------------------=
// CATID_DesignerStatus
//=--------------------------------------------------------------------------=
DEFINE_GUID(CATID_DesignerFeatures, 0x3831d1b0, 0xef3a, 0x11d0, 0x94, 0xce, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);


//=--------------------------------------------------------------------------=
// Designer Ambients Property
//
//   DISPID_AMBIENT_CLSID     - CLSID of public designer object
//   DISPID_AMBIENT_SAVDEMODE - Ambient indicating where the designer is
//      being saved:
//          DESIGNERSAVEMODE_NORMAL     (user's project file),
//          DESIGNERSAVEMODE_EXE        (EXE or DLL file), 
//          DESIGNERSAVEMODE_TEMPORARY  (temp file for running in the IDE)
//      The value of this ambient property is valid only during the call
//      to IPersist[Stream|PropertyBag|etc.]::Save on the designer.
//=--------------------------------------------------------------------------=
#define DISPID_AMBIENT_CLSID                   (-740)
#define DISPID_AMBIENT_SAVEMODE                (-741)
#define DISPID_AMBIENT_PROGID                  (-742)
#define DISPID_AMBIENT_PROJECTDIRECTORY        (-743)
#define DISPID_AMBIENT_BUILDDIRECTORY          (-744)
#define DISPID_AMBIENT_INTERACTIVE             (-745)

#define DESIGNERSAVEMODE_NORMAL                 0
#define DESIGNERSAVEMODE_EXE                    1
#define DESIGNERSAVEMODE_TEMPORARY              2


//=--------------------------------------------------------------------------=
// IDesignerRegistration
//=--------------------------------------------------------------------------=

#define DESIGNERREGFLAG_INPROCSERVER    0x00000001
#define DESIGNERREGFLAG_LOCALSERVER     0x00000002

// DESIGNERREGINFO
typedef struct tagDESIGNERREGINFO
{
    ULONG     cb;
    DWORD     dwFlags;
    LPCOLESTR pszProgID;
    CLSID     clsid;
    GUID      guidTypeLib;
    WORD      wVerMajor;
    WORD      wVerMinor;
    BYTE *    rgbRegInfo;
} DESIGNERREGINFO;

// 48d36f82-e8c2-11d0-94c4-00a0c91110ed
DEFINE_GUID(IID_IDesignerRegistration, 0x48d36f82, 0xe8c2, 0x11d0, 0x94, 0xc4, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#undef  INTERFACE
#define INTERFACE IDesignerRegistration

DECLARE_INTERFACE_(IDesignerRegistration, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerRegistration
    STDMETHOD(GetRegistrationInfo)(THIS_ BYTE** ppbRegInfo, ULONG* pcbRegInfo) PURE;
};

//=--------------------------------------------------------------------------=
// IDesignerDebugging
//=--------------------------------------------------------------------------=

#define DESIGNERSTARTUPINFO_URL     0x00000001
#define DESIGNERSTARTUPINFO_EXE     0x00000002

typedef struct tagDESIGNERSTARTUPINFO
{
    ULONG cb;
    DWORD dwStartupFlags;
    BSTR  bstrStartupData;
} DESIGNERSTARTUPINFO;

// 48d36f83-e8c2-11d0-94c4-00a0c91110ed
DEFINE_GUID(IID_IDesignerDebugging, 0x48d36f83, 0xe8c2, 0x11d0, 0x94, 0xc4, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#undef  INTERFACE
#define INTERFACE IDesignerDebugging

DECLARE_INTERFACE_(IDesignerDebugging, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerDebugging methods
    STDMETHOD(BeforeRun)(LPVOID FAR* ppvData) PURE;
    STDMETHOD(AfterRun)(LPVOID pvData) PURE;
    STDMETHOD(GetStartupInfo)(THIS_ DESIGNERSTARTUPINFO * pStartupInfo) PURE;
};

//=--------------------------------------------------------------------------=
// CF_CLSID, CF_DESIGNERTOOLBOXITEM, and CF_CLSIDCLASSNAME
//=--------------------------------------------------------------------------=
#ifndef CF_CLSID
#define CF_CLSID                "CLSID"
#endif
#define CF_DESIGNERTOOLBOXITEM  "DesignerToolboxItem"
#define CF_CLSIDCLASSNAME	"ClsdIdClassName"

//=--------------------------------------------------------------------------=
// IDesignerToolbox
//=--------------------------------------------------------------------------=

// 48d36f85-e8c2-11d0-94c4-00a0c91110ed
DEFINE_GUID(IID_IDesignerToolbox, 0x48d36f85, 0xe8c2, 0x11d0, 0x94, 0xc4, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#undef  INTERFACE
#define INTERFACE IDesignerToolbox

DECLARE_INTERFACE_(IDesignerToolbox, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerToolbox methods
    STDMETHOD(IsSupported)(THIS_ IDataObject* pdo) PURE;
    STDMETHOD(ItemPicked)(THIS_ IDataObject* pdo) PURE;
    STDMETHOD(GetControlsInUse)(THIS_ DWORD * pcControls, CLSID ** prgClsid) PURE;
};

//=--------------------------------------------------------------------------=
// IDesignerToolboxSite
//=--------------------------------------------------------------------------=

// 06d1e0a0-fc81-11d0-94dd-00a0c91110ed
DEFINE_GUID(IID_IDesignerToolboxSite, 0x06d1e0a0, 0xfc81, 0x11d0, 0x94, 0xdd, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#define SID_DesignerToolboxSite IID_IDesignerToolboxSite

#undef  INTERFACE
#define INTERFACE IDesignerToolboxSite

DECLARE_INTERFACE_(IDesignerToolboxSite, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerToolboxSite methods
    STDMETHOD(GetData)(THIS_ IDataObject** ppdo) PURE;
    STDMETHOD(OnItemPicked)(THIS) PURE;
    STDMETHOD(AddControl)(THIS_ REFCLSID rclsid) PURE;
};


//=--------------------------------------------------------------------------=
// IDesignerProgrammability
//=--------------------------------------------------------------------------=

// 06d1e0a1-fc81-11d0-94dd-00a0c91110ed
DEFINE_GUID(IID_IDesignerProgrammability, 0x06d1e0a1, 0xfc81, 0x11d0, 0x94, 0xdd, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

#define SID_DesignerProgrammability IID_IDesignerProgrammability

#undef  INTERFACE
#define INTERFACE IDesignerProgrammability

DECLARE_INTERFACE_(IDesignerProgrammability, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDesignerProgrammability methods
    STDMETHOD(IsValidIdentifier)(THIS_ LPCOLESTR pszId) PURE;
    STDMETHOD(IsValidEventName)(THIS_ LPCOLESTR pszEvent) PURE;
    STDMETHOD(MakeValidIdentifier)(THIS_ LPCOLESTR pszId, LPOLESTR * ppszValidId) PURE;
};

//=--------------------------------------------------------------------------=
// IActiveDesignerRuntimeSite
//=--------------------------------------------------------------------------=
DEFINE_GUID(IID_IActiveDesignerRuntimeSite, 0xcf2abba0, 0x9450, 0x11d1, 0x89, 0x34, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x49);

#undef  INTERFACE
#define INTERFACE IActiveDesignerRuntimeSite

DECLARE_INTERFACE_(IActiveDesignerRuntimeSite, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    STDMETHOD(GetAdviseSink)(THIS_ MEMBERID memid, IUnknown ** ppunkSink) PURE;
};

//=--------------------------------------------------------------------------=
// IActiveDesignerRuntime
//=--------------------------------------------------------------------------=
DEFINE_GUID(IID_IActiveDesignerRuntime, 0xcf2abba1, 0x9450, 0x11d1, 0x89, 0x34, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x49);

#undef  INTERFACE
#define INTERFACE IActiveDesignerRuntime

DECLARE_INTERFACE_(IActiveDesignerRuntime, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IActiveDesignerRuntime
    STDMETHOD(SetSite)(THIS_ IActiveDesignerRuntimeSite * pSite) PURE;
};

#endif // _AD98_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98\inc\designer.h ===
//=--------------------------------------------------------------------------=
// Designer.H
//=--------------------------------------------------------------------------=
// Copyright (c) 1988-1996, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
// just about everything you might find useful in an ActiveX[tm] Designer.
//
#ifndef _DESIGNER_H_


// CATID for Designers
//
// {4EB304D0-7555-11cf-A0C2-00AA0062BE57}
DEFINE_GUID(CATID_Designer, 0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// IActiveDesigner
//
// {51AAE3E0-7486-11cf-A0C2-00AA0062BE57}
DEFINE_GUID(IID_IActiveDesigner, 0x51aae3e0, 0x7486, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);


#undef  INTERFACE
#define INTERFACE IActiveDesigner

DECLARE_INTERFACE_(IActiveDesigner, IUnknown)
{
	// IUnknown methods
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IActiveDesigner methods
	//
	STDMETHOD(GetRuntimeClassID)(THIS_ CLSID *pclsid) PURE;
	STDMETHOD(GetRuntimeMiscStatusFlags)(THIS_ DWORD *pdwMiscFlags) PURE;
	STDMETHOD(QueryPersistenceInterface)(THIS_ REFIID riidPersist) PURE;
	STDMETHOD(SaveRuntimeState)(THIS_ REFIID riidPersist, REFIID riidObjStgMed, void *pObjStgMed) PURE;
	STDMETHOD(GetExtensibilityObject)(THIS_ IDispatch **ppvObjOut) PURE;
};


//-------------------------------------------------------------------------
//  IServiceProvider Interface
//    This interface is implemented by an object that wish to provide "services"
//
//-------------------------------------------------------------------------
#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__
#ifndef __IServiceProvider_INTERFACE_DEFINED
#define __IServiceProvider_INTERFACE_DEFINED

// { 6d5140c1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IServiceProvider, 0x6d5140c1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IServiceProvider
DECLARE_INTERFACE_(IServiceProvider, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_
                /* [in]  */ REFGUID rsid,
                /* [in]  */ REFIID iid,
                /* [out] */ void ** ppvObj) PURE;
};

#endif // __IServiceProvider_INTERFACE_DEFINED
#endif // __IServiceProvider_INTERFACE_DEFINED__



//-------------------------------------------------------------------------
//  SCodeNavigate Service.
//    This service let's an extended object show the code module
//    behind it.
//
//  interfaces implemented:
//    ICodeNavigate
//    ICodeNavigate2
//-------------------------------------------------------------------------

// { 6d5140c4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ICodeNavigate, 0x6d5140c4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SCodeNavigate IID_ICodeNavigate

#undef  INTERFACE
#define INTERFACE  ICodeNavigate
DECLARE_INTERFACE_(ICodeNavigate, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICodeNavigate methods ***
    STDMETHOD(DisplayDefaultEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName) PURE;
};

// { 2702ad60-3459-11d1-88fd-00a0c9110049 }
DEFINE_GUID(IID_ICodeNavigate2, 0x2702ad60, 0x3459, 0x11d1, 0x88, 0xfd, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x49);

#undef  INTERFACE
#define INTERFACE  ICodeNavigate2
DECLARE_INTERFACE_(ICodeNavigate2, ICodeNavigate)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICodeNavigate methods ***
    STDMETHOD(DisplayDefaultEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName) PURE;

    // *** ICodeNavigate2 methods ***
    STDMETHOD(DisplayEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName, LPCOLESTR lpstrEventName) PURE;
};


//-------------------------------------------------------------------------
//  STrackSelection Service
//    This service is used by the host to help designer track the
//    currently selected object in the host
//
//  interfaces implemented:
//    ITrackSelection
//-------------------------------------------------------------------------
#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2

#define SELOBJS_ACTIVATE_WINDOW   1

// { 6d5140c6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ISelectionContainer, 0x6d5140c6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  ISelectionContainer
DECLARE_INTERFACE_(ISelectionContainer, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ISelectionContainer methods ***
    STDMETHOD(CountObjects)(THIS_
                /* [in]  */ DWORD dwFlags, 
                /* [out] */ ULONG * pc) PURE;
    STDMETHOD(GetObjects)(THIS_
              /* [in]  */ DWORD dwFlags, 
              /* [in]  */ ULONG cObjects,
              /* [out] */ IUnknown **apUnkObjects) PURE;
    STDMETHOD(SelectObjects)(THIS_
              /* [in] */ ULONG cSelect,
              /* [in] */ IUnknown **apUnkSelect,
              /* [in] */ DWORD dwFlags) PURE;
};

// { 6d5140c5-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ITrackSelection, 0x6d5140c5, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_STrackSelection IID_ITrackSelection

#undef  INTERFACE
#define INTERFACE  ITrackSelection
DECLARE_INTERFACE_(ITrackSelection, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ITrackSelection methods ***
    STDMETHOD(OnSelectChange)(THIS_ 
                  /* [in] */ ISelectionContainer * pSC) PURE;
};

//-------------------------------------------------------------------------
//  SProfferTypelib Service
//    this service allows components and hosts to allow
//    them to add typelibs to the project
//
//  interfaces implemented:
//    IProfferTypelib
//-------------------------------------------------------------------------

// { 718cc500-0a76-11cf-8045-00aa006009fa }
DEFINE_GUID(IID_IProfferTypeLib, 0x718cc500, 0x0A76, 0x11cf, 0x80, 0x45, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SProfferTypeLib IID_IProfferTypeLib

#define CONTROLTYPELIB	                            (0x00000001)

#undef  INTERFACE
#define INTERFACE  IProfferTypeLib
DECLARE_INTERFACE_(IProfferTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferTypelib methods ***
    STDMETHOD(ProfferTypeLib)(THIS_ 
              /* [in]  */ REFGUID guidTypeLib,
              /* [in]  */ UINT    uVerMaj,
              /* [in]  */ UINT    uVerMin,
              /* [in]  */ DWORD   dwFlags) PURE;
};

// { 468cfb80-b4f9-11cf-80dd-00aa00614895 }
DEFINE_GUID(IID_IProvideDynamicClassInfo, 0x468cfb80, 0xb4f9, 0x11cf, 0x80, 0xdd, 0x00, 0xaa, 0x00, 0x61, 0x48, 0x95);

#undef  INTERFACE
#define INTERFACE  IProvideDynamicClassInfo
DECLARE_INTERFACE_(IProvideDynamicClassInfo, IProvideClassInfo)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProvideDynamicClassInfo ***
    STDMETHOD(GetDynamicClassInfo)(THIS_ ITypeInfo ** ppTI, DWORD * pdwCookie) PURE;
    STDMETHOD(FreezeShape)(void) PURE;
};


//-------------------------------------------------------------------------
//  SApplicationObject Service
//    Host applications proffer their application [add-in model] object as
//    this service.
//    Various objects implement the "Application" property by returning 
//    this service.
//      
//-------------------------------------------------------------------------

// { 0c539790-12e4-11cf-b661-00aa004cd6d8 }
DEFINE_GUID(SID_SApplicationObject, 0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8);

#define _DESIGNER_H_
#endif // _DESIGNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\autoobj.cpp ===
//=--------------------------------------------------------------------------=
// AutomationObject.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.
//
#include "pch.h"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "StdEnum.H"


// for ASSERT and FAIL
//
SZTHISFILE

// private function prototypes
//
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyConnectData(void *, const void *, DWORD);

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObject::CAutomationObject 
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable
)
: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
    m_fLoadedTypeInfo = FALSE;

#ifdef MDAC_BUILD
    m_pTypeLibId = g_pLibid;
#endif
}


//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=
// "I have a rendezvous with Death, At some disputed barricade"
// - Alan Seeger (1888-1916)
//
// Notes:
//
CAutomationObject::~CAutomationObject ()
{
    // if we loaded up a type info, release our count on the globally stashed
    // type infos, and release if it becomes zero.
    //
    if (m_fLoadedTypeInfo) {

        // we have to crit sect this since it's possible to have more than
        // one thread partying with this object.
        //
        ENTERCRITICALSECTION1(&g_CriticalSection);
        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
        CTYPEINFOOFOBJECT(m_ObjectType)--;

        // if we're the last one, free that sucker!
        //
        if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
            PTYPEINFOOFOBJECT(m_ObjectType)->Release();
            PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
        }
        LEAVECRITICALSECTION1(&g_CriticalSection);
    }

    return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObject::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    ASSERT(ppvObjOut, "controlling Unknown should be checking this!");

    // start looking for the guids we support, namely IDispatch, and the
    //
    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
        *ppvObjOut = (void *)(IDispatch *)m_pvInterface;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }

    // just get our parent class to process it from here on out.
    //
    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//    UINT *            - [out] the number of interfaces supported.
//
// Output:
//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfoCount
(
    UINT *pctinfo
)
{
    // arg checking
    //
    if (!pctinfo)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.
    //
    *pctinfo = 1;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//    UINT              - [in]  the type information they'll want returned
//    LCID              - [in]  the LCID of the type info we want
//    ITypeInfo **      - [out] the new type info object.
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, etc.
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    DWORD       dwPathLen;
    char        szDllPath[MAX_PATH];
    HRESULT     hr;
    ITypeLib   *pTypeLib;
    ITypeInfo **ppTypeInfo =NULL;

    // arg checking
    //
    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load the sucker.
        //
    #ifdef MDAC_BUILD
        hr = LoadRegTypeLib(*m_pTypeLibId, (USHORT)VERSIONOFOBJECT(m_ObjectType),
                            (USHORT)VERSIONMINOROFOBJECT(m_ObjectType),
                            LANG_NEUTRAL, &pTypeLib);
    #else
        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType),
                            (USHORT)VERSIONMINOROFOBJECT(m_ObjectType),
                            LANG_NEUTRAL, &pTypeLib);
    #endif

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.
        //
        if (FAILED(hr)) {

            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
            hr = LoadTypeLib(pwsz, &pTypeLib);
            CLEANUP_ON_FAILURE(hr);
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.
        //
        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        CLEANUP_ON_FAILURE(hr);

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the non dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        CLEANUP_ON_FAILURE(hr);

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

  CleanUp:
    LEAVECRITICALSECTION1(&g_CriticalSection);
    return hr;
}



//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//    REFIID            - [in]  must be IID_NULL
//    OLECHAR **        - [in]  array of names to map.
//    UINT              - [in]  count of names in the array.
//    LCID              - [in]  LCID on which to operate
//    DISPID *          - [in]  place to put the corresponding DISPIDs.
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//                        DISP_E_UNKNOWNLCID
//
// Notes:
//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//      and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cNames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // use the standard provided routines to do all the work for us.
    //
    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//    DISPID            - [in]  identifies the member we're working with.
//    REFIID            - [in]  must be IID_NULL.
//    LCID              - [in]  language we're working under
//    USHORT            - [in]  flags, propput, get, method, etc ...
//    DISPPARAMS *      - [in]  array of arguments.
//    VARIANT *         - [out] where to put result, or NULL if they don't care.
//    EXCEPINFO *       - [out] filled in in case of exception
//    UINT *            - [out] where the first argument with an error is.
//
// Output:
//    HRESULT           - tonnes of them.
//
// Notes:
//    
STDMETHODIMP CAutomationObject::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // Clear exceptions
    //
    SetErrorInfo(0L, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.
    //
    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();
    return hr;

}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// See also the version of Exception() that takes a resource ID instead
// of the actual string for the error message.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    LPWSTR           - [in] the text of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    LPWSTR wszException,
    DWORD   dwHelpContextID
)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    WCHAR   wszTmp[256];
    HRESULT hr;


    // first get the createerrorinfo object.
    //
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hr)) return hrExcep;
    
    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));    

    // set up some default information on it.
    //
    hr = pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
    ASSERT(SUCCEEDED(hr), "Unable to set GUID of error");
    hr = pCreateErrorInfo->SetHelpFile(HELPFILEOFOBJECT(m_ObjectType) ? wszHelpFile : NULL);
    ASSERT(SUCCEEDED(hr), "Uable to set help file of error");
    hr = pCreateErrorInfo->SetHelpContext(dwHelpContextID);
    ASSERT(SUCCEEDED(hr), "Unable to set help context of error");
    hr = pCreateErrorInfo->SetDescription(wszException);
    ASSERT(SUCCEEDED(hr), "Unable to set description of error");

    // load in the source
    //
    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
    hr = pCreateErrorInfo->SetSource(wszTmp);
    ASSERT(SUCCEEDED(hr), "Unable to set source name of error");

    // now set the Error info up with the system
    //
    hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
    CLEANUP_ON_FAILURE(hr);

    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

  CleanUp:
    pCreateErrorInfo->Release();
    return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// See also the version of Exception() that takes the actual string of the
// error message instead of a resource ID.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    WORD             - [in] the RESOURCE ID of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    WORD    idException,
    DWORD   dwHelpContextID
)
{
    char szTmp[256];
    WCHAR wszTmp[256];
    int cch;

    // load in the actual error string value.  max of 256.
    //
    cch = LoadString(GetResourceHandle(), idException, szTmp, 256);
    ASSERT(cch != 0, "Resource string for exception not found");
    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
    return Exception(hrExcep, wszTmp, dwHelpContextID);
}


//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//    REFIID        - [in] the interface we want the answer for.
//
// Output:
//    HRESULT       - S_OK = Yes, S_FALSE = No.
//
// Notes:
//
HRESULT CAutomationObject::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    // see if it's the interface for the type of object that we are.
    //
    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
        return S_OK;

    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetResourceHandle    [helper]
//=--------------------------------------------------------------------------=
// virtual routine to get the resource handle.  virtual, so that inheriting
// objects, such as COleControl can use theirs instead, which goes and gets
// the Host's version ...
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CAutomationObject::GetResourceHandle
(
    void
)
{
    return ::GetResourceHandle();
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                      CAutomationObjectWEvents                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CAutomationObjectWEvents
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObjectWEvents::CAutomationObjectWEvents
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable
)
: CAutomationObject(pUnkOuter, ObjType, pVTable),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)

{
    // not much to do yet.
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::~CAutomationObjectWEvents
//=--------------------------------------------------------------------------=
// virtual destructor
//
// Notes:
//
CAutomationObjectWEvents::~CAutomationObjectWEvents()
{
    // homey don't play that
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::InternalQueryInterface
//=--------------------------------------------------------------------------=
// our internal query interface routine.  we only add IConnectionPtContainer
// on top of CAutomationObject
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObjectWEvents::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    // we only add one interface
    //
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPointContainer)) {
        *ppvObjOut = (IConnectionPointContainer *)this;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }

    // just get our parent class to process it from here on out.
    //
    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//    REFIID              - [in]  interfaces they want
//    IConnectionPoint ** - [out] where the cp should go
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::FindConnectionPoint
(
    REFIID             riid,
    IConnectionPoint **ppConnectionPoint
)
{
    CHECK_POINTER(ppConnectionPoint);

    // we support the event interface, and IDispatch for it, and we also
    // support IPropertyNotifySink.
    //
    if ((ISVALIDEVENTIID(m_ObjectType) && DO_GUIDS_MATCH(riid, EVENTIIDOFOBJECT(m_ObjectType))) || 
	 DO_GUIDS_MATCH(riid, IID_IDispatch))
        *ppConnectionPoint = &m_cpEvents;
    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
        *ppConnectionPoint = &m_cpPropNotify;
    else
        return E_NOINTERFACE;

    // generic post-processing.
    //
    (*ppConnectionPoint)->AddRef();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::EnumConnectionPoints    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//    IEnumConnectionPoints **    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::EnumConnectionPoints
(
    IEnumConnectionPoints **ppEnumConnectionPoints
)
{
    IConnectionPoint **rgConnectionPoints;

    CHECK_POINTER(ppEnumConnectionPoints);

    // HeapAlloc an array of connection points [since our standard enum
    // assumes this and HeapFree's it later ]
    //
    rgConnectionPoints = (IConnectionPoint **)CtlHeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2);
    RETURN_ON_NULLALLOC(rgConnectionPoints);

    // we support the event interface for this dude as well as IPropertyNotifySink
    //
    rgConnectionPoints[0] = &m_cpEvents;
    rgConnectionPoints[1] = &m_cpPropNotify;

    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) New CStandardEnum(IID_IEnumConnectionPoints,
                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                                CopyAndAddRefObject);
    if (!*ppEnumConnectionPoints) {
        CtlHeapFree(g_hHeap, 0, rgConnectionPoints);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::m_pObject
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//    CAutomationObjectWEvents *
//
// Notes:
//
inline CAutomationObjectWEvents *CAutomationObjectWEvents::CConnectionPoint::m_pObject
(
    void
)
{
    return (CAutomationObjectWEvents *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                          ? offsetof(CAutomationObjectWEvents, m_cpEvents)
                                          : offsetof(CAutomationObjectWEvents, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        *ppvObjOut = (IConnectionPoint *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::AddRef
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CAutomationObjectWEvents::CConnectionPoint::AddRef
(
    void
)
{
    return m_pObject()->ExternalAddRef();
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::Release
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CAutomationObjectWEvents::CConnectionPoint::Release
(
    void
)
{
    return m_pObject()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//    IID *        - [out] interface we support.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::GetConnectionInterface
(
    IID *piid
)
{
    if (m_bType == SINK_TYPE_EVENT && ISVALIDEVENTIID(m_pObject()->m_ObjectType))	
	*piid = EVENTIIDOFOBJECT(m_pObject()->m_ObjectType);
    else
        *piid = IID_IPropertyNotifySink;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//    IConnectionPointContainer **ppCPC
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::GetConnectionPointContainer
(
    IConnectionPointContainer **ppCPC
)
{
    return m_pObject()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//    IUnknown *        - [in]  guy who wants to be advised.
//    DWORD *           - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::Advise
(
    IUnknown *pUnk,
    DWORD    *pdwCookie
)
{
    HRESULT    hr = E_FAIL;
    void      *pv;

    CHECK_POINTER(pdwCookie);

    // first, make sure everybody's got what they thinks they got
    //
    if (m_bType == SINK_TYPE_EVENT) 
    {
        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find
        // connection point on IDispatch, and they just happened to also support
        // the Event IID, we'd advise on that.  this is not awesome, but will
        // prove entirely acceptable short term.
        //
	ASSERT(hr == E_FAIL, "Somebody has changed our assumption that hr is initialized to E_FAIL");
	if (ISVALIDEVENTIID(m_pObject()->m_ObjectType))
	    hr = pUnk->QueryInterface(EVENTIIDOFOBJECT(m_pObject()->m_ObjectType), &pv);

        if (FAILED(hr))
            hr = pUnk->QueryInterface(IID_IDispatch, &pv);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
    }

    RETURN_ON_FAILURE(hr);

    // finally, add the sink.  it's now been cast to the correct type and has
    // been AddRef'd.
    //
    return AddSink(pv, pdwCookie);
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//    void *        - [in]  the sink to add. it's already been addref'd
//    DWORD *       - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CAutomationObjectWEvents::CConnectionPoint::AddSink
(
    void  *pv,
    DWORD *pdwCookie
)
{
    IUnknown **rgUnkNew;
    int        i = 0;

    // we optimize the case where there is only one sink to not allocate
    // any storage.  turns out very rarely is there more than one.
    //
    switch (m_cSinks) {

        case 0:
            ASSERT(!m_rgSinks, "this should be null when there are no sinks");
            m_rgSinks = (IUnknown **)pv;
            break;

        case 1:
            // go ahead and do the initial allocation.  we'll get 8 at a time
            //
            rgUnkNew = (IUnknown **)CtlHeapAlloc(g_hHeap, 0, 8 * sizeof(IUnknown *));
            RETURN_ON_NULLALLOC(rgUnkNew);
            rgUnkNew[0] = (IUnknown *)m_rgSinks;
            rgUnkNew[1] = (IUnknown *)pv;
            m_rgSinks = rgUnkNew;
            break;

        default:
            // if we're out of sinks, then we have to increase the size
            // of the array
            //
            if (!(m_cSinks & 0x7)) {
                rgUnkNew = (IUnknown **)CtlHeapReAlloc(g_hHeap, 0, m_rgSinks, (m_cSinks + 8) * sizeof(IUnknown *));
                RETURN_ON_NULLALLOC(rgUnkNew);
                m_rgSinks = rgUnkNew;
            } else
                rgUnkNew = m_rgSinks;

            rgUnkNew[m_cSinks] = (IUnknown *)pv;
            break;
    }

    *pdwCookie = (DWORD)pv;
    m_cSinks++;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//    DWORD        - [in]  the cookie we gave 'em.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::Unadvise
(
    DWORD dwCookie
)
{
    IUnknown *pUnk;
    int       x;

    if (!dwCookie)
        return S_OK;

    // see how many sinks we've currently got, and deal with things based
    // on that.
    //
    switch (m_cSinks) {
        case 1:
            // it's the only sink.  make sure the ptrs are the same, and
            // then free things up
            //
            if ((DWORD)m_rgSinks != dwCookie)
                return CONNECT_E_NOCONNECTION;
            m_rgSinks = NULL;
            break;

        case 2:
            // there are two sinks.  go back down to one sink scenario
            //
            if ((DWORD)m_rgSinks[0] != dwCookie && (DWORD)m_rgSinks[1] != dwCookie)
                return CONNECT_E_NOCONNECTION;

            pUnk = ((DWORD)m_rgSinks[0] == dwCookie)
                   ? m_rgSinks[1]
                   : ((DWORD)m_rgSinks[1] == dwCookie) ? m_rgSinks[0] : NULL;

            if (!pUnk) return CONNECT_E_NOCONNECTION;

            CtlHeapFree(g_hHeap, 0, m_rgSinks);
            m_rgSinks = (IUnknown **)pUnk;
            break;

        default:
            // there are more than two sinks.  just clean up the hole we've
            // got in our array now.
            //
            for (x = 0; x < m_cSinks; x++) {
                if ((DWORD)m_rgSinks[x] == dwCookie)
                    break;
            }
            if (x == m_cSinks) return CONNECT_E_NOCONNECTION;
            if (x < m_cSinks - 1) 
                memcpy(&(m_rgSinks[x]), &(m_rgSinks[x + 1]), (m_cSinks -1 - x) * sizeof(IUnknown *));
            else
                m_rgSinks[x] = NULL;
            break;
    }


    // we're happy
    //
    m_cSinks--;
    ((IUnknown *)dwCookie)->Release();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP CAutomationObjectWEvents::CConnectionPoint::EnumConnections
(
    IEnumConnections **ppEnumOut
)
{
    CONNECTDATA *rgConnectData = NULL;
    int i;

    if (m_cSinks) {
        // allocate some memory big enough to hold all of the sinks.
        //
        rgConnectData = (CONNECTDATA *)CtlHeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA));
        RETURN_ON_NULLALLOC(rgConnectData);

        // fill in the array
        //
        if (m_cSinks == 1) {
            rgConnectData[0].pUnk = (IUnknown *)m_rgSinks;
            rgConnectData[0].dwCookie = (DWORD)m_rgSinks;
        } else {
            // loop through all available sinks.
            //
            for (i = 0; i < m_cSinks; i++) {
                rgConnectData[i].pUnk = m_rgSinks[i];
                rgConnectData[i].dwCookie = (DWORD)m_rgSinks[i];
            }
        }
    }

    // create yon enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)New CStandardEnum(IID_IEnumConnections,
                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyConnectData);
    if (!*ppEnumOut) {
        CtlHeapFree(g_hHeap, 0, rgConnectData);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
CAutomationObjectWEvents::CConnectionPoint::~CConnectionPoint ()
{
    int x;

    // clean up some memory stuff
    //
    if (!m_cSinks)
        return;
    else if (m_cSinks == 1)
        ((IUnknown *)m_rgSinks)->Release();
    else {
        for (x = 0; x < m_cSinks; x++)
            QUICK_RELEASE(m_rgSinks[x]);
        CtlHeapFree(g_hHeap, 0, m_rgSinks);
    }
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//    DISPID            - [in] event to fire.
//    DISPPARAMS        - [in]
//
// Notes:
//
void CAutomationObjectWEvents::CConnectionPoint::DoInvoke
(
    DISPID      dispid,
    DISPPARAMS *pdispparams
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //
    if (m_cSinks == 0)
        return;
    else if (m_cSinks == 1)
        ((IDispatch *)m_rgSinks)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
    else
        for (iConnection = 0; iConnection < m_cSinks; iConnection++)
            ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//    DISPID            - [in] dude that changed.
//
// Output:
//    none
//
// Notes:
//
void CAutomationObjectWEvents::CConnectionPoint::DoOnChanged
(
    DISPID dispid
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        return;
    else if (m_cSinks == 1)
        ((IPropertyNotifySink *)m_rgSinks)->OnChanged(dispid);
    else
        for (iConnection = 0; iConnection < m_cSinks; iConnection++)
            ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//    DISPID             - [in] dispid user wants to change.
//
// Output:
//    BOOL               - false means you cant
//
// Notes:
//
BOOL CAutomationObjectWEvents::CConnectionPoint::DoOnRequestEdit
(
    DISPID dispid
)
{
    HRESULT hr;
    int     iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        hr = S_OK;
    else if (m_cSinks == 1)
        hr =((IPropertyNotifySink *)m_rgSinks)->OnRequestEdit(dispid);
    else {
        for (iConnection = 0; iConnection < m_cSinks; iConnection++) {
            hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
            if (hr != S_OK) break;
        }
    }

    return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.  handles arbitrary number of arguments.
//
// Parameters:
//    EVENTINFO *        - [in] struct that describes the event.
//    ...                - arguments to the event
//
// Output:
//    none
//
// Notes:
//    - use stdarg's va_* macros.
//
void __cdecl CAutomationObjectWEvents::FireEvent
(
    EVENTINFO *pEventInfo,
    ...
)
{
    va_list    valist;
    DISPPARAMS dispparams;
    VARIANT    rgvParameters[MAX_ARGS];
    VARIANT   *pv;
    VARTYPE    vt;
    int        iParameter;
    int        cbSize;

    ASSERT(pEventInfo->cParameters <= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry.");

    va_start(valist, pEventInfo);

    // copy the Parameters into the rgvParameters array.  make sure we reverse
    // them for automation
    //
    pv = &(rgvParameters[pEventInfo->cParameters - 1]);
    for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

        // CONSIDER: are we properly handling all vartypes, e.g., VT_DECIMAL
        vt = pEventInfo->rgTypes[iParameter];

        // if it's a by value variant, then just copy the whole
        // dang thing
        //
        if (vt == VT_VARIANT)
            *pv = va_arg(valist, VARIANT);
        else {
            // copy the vt and the data value.
            //
            pv->vt = vt;
            if (vt & VT_BYREF)
                cbSize = sizeof(void *);
            else
                cbSize = g_rgcbDataTypeSize[vt];

            // small optimization -- we can copy 2/4 bytes over quite
            // quickly.
            //
            if (cbSize == sizeof(short))
                V_I2(pv) = va_arg(valist, short);
            else if (cbSize == 4) {
                if (vt == VT_R4)
                    V_R4(pv) = va_arg(valist, float);
                else
                    V_I4(pv) = va_arg(valist, long);
            }
            else {
                // copy over 8 bytes
                //
                ASSERT(cbSize == 8, "don't recognize the type!!");
                if ((vt == VT_R8) || (vt == VT_DATE)) 
                    V_R8(pv) = va_arg(valist, double);
                else
                    V_CY(pv) = va_arg(valist, CURRENCY);
            }
        }

        pv--;
    }

    // fire the event
    //
    dispparams.rgvarg = rgvParameters;
    dispparams.cArgs = pEventInfo->cParameters;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cNamedArgs = 0;

    m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

    va_end(valist);
}

//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size, ignored, since it's always 4
//
// Notes:
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((IUnknown **)pDest) = *((IUnknown **)pSource);
    ADDREF_OBJECT(*((IUnknown **)pDest));
}

//=--------------------------------------------------------------------------=
// CopyConnectData
//=--------------------------------------------------------------------------=
// copies over a connectdata structure and addrefs the pointer
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size
//
// Notes:
//
void WINAPI CopyConnectData
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((CONNECTDATA *)pDest) = *((const CONNECTDATA *)pSource);
    ADDREF_OBJECT(((CONNECTDATA *)pDest)->pUnk);
}

#ifdef DEBUG

//=--------------------------------------------------------------------------=
// DebugVerifyData1Guids [helper]
//=--------------------------------------------------------------------------=
// Given an array of match Data1_ #define and interface guid values, this
// function validates that all entries match.
//
void DebugVerifyData1Guids(GUIDDATA1_COMPARE *pGuidData1_Compare)
{
	while(pGuidData1_Compare->dwData1a)
	{
		ASSERT(pGuidData1_Compare->pdwData1b, "Data1 pointer is NULL");
		ASSERT(pGuidData1_Compare->dwData1a == *pGuidData1_Compare->pdwData1b, 
				"Data1_ #define value doesn't match interface guid value");

		pGuidData1_Compare++;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\setup\vbsnapcleanup\vbsnapcleanup.cpp ===
#include <windows.h>
#include <tchar.h>
#include <atlbase.h>
#include <atlimpl.cpp>

#define CLSID_LENGTH   256
#define MAX_PATH_LEN   2048

const CHAR  g_MMCVBSnapinsKey[] = "Software\\Microsoft\\Visual Basic\\6.0\\SnapIns";
const CHAR  g_MMCKey[]          = "Software\\Microsoft\\MMC";
const CHAR  g_SnapIns[]         = "SnapIns";
const CHAR  g_NodeTypes[]       = "NodeTypes";

// Remove the MMC VB snapin entries from the registry
int __cdecl main(int argc, char* argv[])
{
    HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
        return 0;

    BOOL bOleInitialized = TRUE;

    do
    {
        // Open HKLM\Software\Microsoft\Visual Basic\6.0\SnapIns.
        LONG lRetVal = 0;
        ATL::CRegKey regVBSnapinsKey;
        lRetVal = regVBSnapinsKey.Open(HKEY_LOCAL_MACHINE, g_MMCVBSnapinsKey, KEY_READ);

        // If no VB Snapins then return.
        if (ERROR_SUCCESS != lRetVal)
            break;

        ATL::CRegKey regCLSIDKey;
        lRetVal = regCLSIDKey.Open(HKEY_CLASSES_ROOT, "CLSID");
        ATLASSERT(ERROR_SUCCESS == lRetVal);
        if (ERROR_SUCCESS != lRetVal)
            break;

        ATL::CRegKey regMMCKey;
        // Open the other required keys.
        lRetVal = regMMCKey.Open(HKEY_LOCAL_MACHINE, g_MMCKey, KEY_READ | KEY_WRITE);
        // If MMC Key remove VB Snapins key.
        if (ERROR_SUCCESS != lRetVal)
        {
            // BUGBUG
            break;
        }

        // Enumerate the regVBSnapinsKey, this yields NodeTypeGuid key with
        // default value as snapin class id.
        CHAR  szNodeType[CLSID_LENGTH];
        CHAR  szClsid[CLSID_LENGTH];
        DWORD dwLength;

        for (DWORD dwIndex = 0; TRUE; dwIndex++)
        {
            lRetVal = RegEnumKeyEx( (HKEY)regVBSnapinsKey, 0, szNodeType, &dwLength, NULL, NULL, NULL, NULL);
            if ( (lRetVal == ERROR_NO_MORE_ITEMS) ||
                 (lRetVal != ERROR_SUCCESS) )
                 break;

            // Got the NodeTypeGuid value, now open that key.
            ATL::CRegKey regTempKey;
            lRetVal = regTempKey.Open((HKEY)regVBSnapinsKey, szNodeType, KEY_READ);
            if (ERROR_SUCCESS != lRetVal)
                continue;

            // Read the default value (Snapin CLSID).
			dwLength = CLSID_LENGTH;
            lRetVal = regTempKey.QueryValue(szClsid, NULL, &dwLength);
            if (ERROR_SUCCESS != lRetVal)
                continue;


#if 0 // Disable this code for this release
			// Now we have the snapin class id
			// Find the inproc server, Load it and call its DllUnRegisterServer
			lRetVal = regTempKey.Open((HKEY) regCLSIDKey, szClsid, KEY_READ);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

			lRetVal = regTempKey.Open((HKEY) regTempKey,  TEXT("InprocServer32"), KEY_READ);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

			TCHAR szPath[MAX_PATH_LEN];
			dwLength = MAX_PATH_LEN;
			lRetVal = regTempKey.QueryValue(szPath, NULL, &dwLength);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

			HINSTANCE hInstance = LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
			if (hInstance && bOleInitialized)
			{
				HRESULT (STDAPICALLTYPE* lpDllEntryPoint)(void);
				(FARPROC&) lpDllEntryPoint = GetProcAddress(hInstance, "DllUnregisterServer");
				if (lpDllEntryPoint)
					hr = (*lpDllEntryPoint)();

				FreeLibrary(hInstance);
			}
#endif // #if 0

            // Now we have snapin class id and nodetype guid. Delete them under mmc key.
            lRetVal = regTempKey.Open((HKEY) regMMCKey, g_NodeTypes);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;

            regTempKey.RecurseDeleteKey(szNodeType);

            lRetVal = regTempKey.Open((HKEY) regMMCKey, g_SnapIns);
            ATLASSERT(ERROR_SUCCESS == lRetVal);
            if (ERROR_SUCCESS != lRetVal)
                continue;
            regTempKey.RecurseDeleteKey(szClsid);
            regCLSIDKey.RecurseDeleteKey(szClsid);

            // Finally delete the key under enumerator
            regVBSnapinsKey.RecurseDeleteKey(szNodeType);
        }
    } while ( FALSE );

	if (bOleInitialized)
        CoUninitialize();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98\inc\objext.h ===
//+------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  
//  File:       objext.h
//  
//  Contents:   header file for Object Extensions interfaces
//  
//-------------------------------------------------------------------------

#ifndef __OBJEXT_H
#define __OBJEXT_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#include "Designer.H"

///////////////////////////////////////////////////////////////////////////
//
// forward declares
//
///////////////////////////////////////////////////////////////////////////

#define IClassDesigner IDocumentSite
#define IID_IClassDesigner IID_IDocumentSite

///////////////////////////////////////////////////////////////////////////
//
// Object Extension Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  IServiceProvider Interface
//    This interface is implemented by an object that wish to provide "services"
//
//-------------------------------------------------------------------------
#ifndef __IServiceProvider_INTERFACE_DEFINED
#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED
#define __IServiceProvider_INTERFACE_DEFINED__


// { 6d5140c1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IServiceProvider, 0x6d5140c1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IServiceProvider
DECLARE_INTERFACE_(IServiceProvider, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_
                /* [in]  */ REFGUID rsid,
                /* [in]  */ REFIID iid,
                /* [out] */ void ** ppvObj) PURE;
};

#endif // __IServiceProvider_INTERFACE_DEFINED__
#endif // __IServiceProvider_INTERFACE_DEFINED


//-------------------------------------------------------------------------
//  IDocumentSite Interface
//    This interface is implemented by a document object that can be customized
//
//-------------------------------------------------------------------------

// { 94A0F6F1-10BC-11d0-8D09-00A0C90F2732 }
DEFINE_GUID(IID_IDocumentSite, 0x94a0f6f1, 0x10bc, 0x11d0, 0x8d, 0x09, 0x00, 0xa0, 0xc9, 0x0f, 0x27, 0x32);

typedef DWORD ACTFLAG;
#define ACT_DEFAULT 0x00000000
#define ACT_SHOW    0x00000001

#undef  INTERFACE
#define INTERFACE  IDocumentSite
DECLARE_INTERFACE_(IDocumentSite, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IDocumentSite methods ***
    STDMETHOD(SetSite)(THIS_
               /* [in]  */ IServiceProvider * pSP) PURE;
    STDMETHOD(GetSite)(THIS_
               /* [out] */ IServiceProvider** ppSP) PURE;
    STDMETHOD(GetCompiler)(THIS_
               /* [in]  */ REFIID iid,
               /* [out] */ void **ppvObj) PURE;
    STDMETHOD(ActivateObject)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(IsObjectShowable)(THIS) PURE;
};


///////////////////////////////////////////////////////////////////////////
//
// Standard Services and Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  SLicensedClassManager
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILicensedClassManager
//-------------------------------------------------------------------------
// { 6d5140d0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IRequireClasses
DECLARE_INTERFACE_(IRequireClasses, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRequireClasses methods ***
    STDMETHOD(CountRequiredClasses)(THIS_
                    /* [out] */ ULONG * pcClasses ) PURE;
    STDMETHOD(GetRequiredClasses)(THIS_
                  /* [in]  */ ULONG index,
                  /* [out] */ CLSID * pclsid ) PURE;
};

// { 6d5140d4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILicensedClassManager, 0x6d5140d4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLicensedClassManager  IID_ILicensedClassManager

#undef  INTERFACE
#define INTERFACE  ILicensedClassManager
DECLARE_INTERFACE_(ILicensedClassManager, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILicensedClassManager methods ***
    STDMETHOD(OnChangeInRequiredClasses)(THIS_
                     /* [in] */ IRequireClasses *pRequireClasses) PURE;
};

//-------------------------------------------------------------------------
//  SCreateExtendedTypeLib Service
//    This service is used by components to create a typelib
//    describing controls merged with their extender
//
//  interfaces implemented:
//    ICreateExtendedTypeLib
//-------------------------------------------------------------------------
// { 6d5140d6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IExtendedTypeLib, 0x6d5140d6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SExtendedTypeLib IID_IExtendedTypeLib

#undef  INTERFACE
#define INTERFACE  IExtendedTypeLib
DECLARE_INTERFACE_(IExtendedTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IExtendedTypeLib ***
    STDMETHOD(CreateExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;

    STDMETHOD(AddRefExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD	   dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;
    STDMETHOD(AddRefExtendedTypeLibOfClsid)(THIS_
                     /* [in]  */ REFCLSID rclsidControl,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeInfo **pptinfo) PURE;
    STDMETHOD(SetExtenderInfo)(THIS_ 
		     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved) PURE;
};

//-------------------------------------------------------------------------
//  SLocalRegistry Service
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILocalRegistry
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILocalRegistry, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLocalRegistry IID_ILocalRegistry

#undef  INTERFACE
#define INTERFACE  ILocalRegistry
DECLARE_INTERFACE_(ILocalRegistry, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILocalRegistry methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ CLSID      clsid,     
                  /* [in]  */ IUnknown * punkOuter,
                  /* [in]  */ REFIID     riid,
                  /* [in]  */ DWORD      dwFlags,
                  /* [out] */ void **    ppvObj ) PURE;
    STDMETHOD(GetTypeLibOfClsid)(THIS_
                 /* [in]  */ CLSID       clsid,
                 /* [out] */ ITypeLib ** ptlib ) PURE;
    STDMETHOD(GetClassObjectOfClsid)(THIS_
                     /* [in]  */ REFCLSID clsid,
                                 /* [in]  */ DWORD    dwClsCtx,
                     /* [in]  */ LPVOID   lpReserved,
                     /* [in]  */ REFIID   riid,
                     /* [out] */ void **  ppcClassObject ) PURE;
};

//-------------------------------------------------------------------------
//  IUIElement interface
//    components can implement services to allow external control of pieces 
//    of their UI by implementing this interface
//
//-------------------------------------------------------------------------
// { 759d0500-d979-11ce-84ec-00aa00614f3e }
DEFINE_GUID(IID_IUIElement, 0x759d0500, 0xd979, 0x11ce, 0x84, 0xec, 0x00, 0xaa, 0x00, 0x61, 0x4f, 0x3e);

#undef  INTERFACE
#define INTERFACE  IUIElement
DECLARE_INTERFACE_(IUIElement, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IUIElement methods ****
    STDMETHOD(Show)(THIS) PURE;
    STDMETHOD(Hide)(THIS) PURE;
    STDMETHOD(IsVisible)(THIS) PURE;
};

//-------------------------------------------------------------------------
//  SProfferService Service
//    VBA provides this service to it's components and hosts to allow
//    them to dynamically provide services.
//
//  interfaces implemented:
//    IProfferService
//-------------------------------------------------------------------------

// {CB728B20-F786-11ce-92AD-00AA00A74CD0}
DEFINE_GUID(IID_IProfferService, 0xcb728b20, 0xf786, 0x11ce, 0x92, 0xad, 0x0, 0xaa, 0x0, 0xa7, 0x4c, 0xd0);
#define SID_SProfferService IID_IProfferService

#undef  INTERFACE
#define INTERFACE  IProfferService
DECLARE_INTERFACE_(IProfferService, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferService methods ***
    STDMETHOD(ProfferService)(THIS_ 
                  /* [in]  */ REFGUID rguidService,
                  /* [in]  */ IServiceProvider * psp,
                  /* [out] */ DWORD *pdwCookie) PURE;

    STDMETHOD(RevokeService)(THIS_ /* [in]  */ DWORD dwCookie) PURE;
};

// {4D07FC10-F931-11ce-B001-00AA006884E5}
DEFINE_GUID(IID_ICategorizeProperties, 0x4d07fc10, 0xf931, 0x11ce, 0xb0, 0x1, 0x0, 0xaa, 0x0, 0x68, 0x84, 0xe5);

// NOTE : CATID should no longer be used.  Use PROPCAT instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new typedef.
#ifdef OBJEXT_OLD_CATID
typedef int CATID;
#else
typedef int PROPCAT;
#endif

#undef  INTERFACE
#define INTERFACE  ICategorizeProperties
DECLARE_INTERFACE_(ICategorizeProperties, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICategorizeProperties ***
    STDMETHOD(MapPropertyToCategory)(THIS_ 
                                     /* [in]  */ DISPID dispid,
                                     /* [out] */ PROPCAT* ppropcat) PURE;
    STDMETHOD(GetCategoryName)(THIS_
                               /* [in]  */ PROPCAT propcat, 
                               /* [in]  */ LCID lcid,
                               /* [out] */ BSTR* pbstrName) PURE;
};

typedef ICategorizeProperties FAR* LPCATEGORIZEPROPERTIES;

// category ID: negative values are 'standard' categories,  positive are control-specific
// Note! This is a temporary list!
#ifdef OBJEXT_OLD_CATID
// NOTE : The following #defines should no longer be used.  Use PROPCAT_ instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new #defines.
#define CI_Nil -1
#define CI_Misc -2
#define CI_Font -3
#define CI_Position -4
#define CI_Appearance -5
#define CI_Behavior -6
#define CI_Data -7
#define CI_List -8
#define CI_Text -9
#define CI_Scale -10
#define CI_DDE -11
#else
#define PROPCAT_Nil -1
#define PROPCAT_Misc -2
#define PROPCAT_Font -3
#define PROPCAT_Position -4
#define PROPCAT_Appearance -5
#define PROPCAT_Behavior -6
#define PROPCAT_Data -7
#define PROPCAT_List -8
#define PROPCAT_Text -9
#define PROPCAT_Scale -10
#define PROPCAT_DDE -11
#endif

//
//  Extra interfaces (chrisz)
//

//+-------------------------------------------------------------------------
//
//  Help service. (robbear)
//
//--------------------------------------------------------------------------

#define HELPINFO_WHATS_THIS_MODE_ON     1

// { 6d5140c7-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(SID_SHelp, 0x6d5140c7, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

// { 6d5140c8-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IHelp, 0x6d5140c8, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IHelp
DECLARE_INTERFACE_(IHelp, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IHelp methods ***
    STDMETHOD(GetHelpFile) (THIS_ BSTR * pbstr) PURE;
    STDMETHOD(GetHelpInfo) (THIS_ DWORD * pdwHelpInfo) PURE;
    STDMETHOD(ShowHelp) (THIS_
                         LPOLESTR szHelp,
                         UINT fuCommand,
                         DWORD dwHelpContext) PURE;
};

#endif // __OBJEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\classf.h ===
//=--------------------------------------------------------------------------=
// AutoCF.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _AUTOCF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _AUTOCF_H_
#endif // _AUTOCF_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlembed.cpp ===
//=--------------------------------------------------------------------------=
// ControlEmbedding.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl
//
#include "pch.h"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "StdEnum.H"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// all controls support the following in-place verbs at an absolute minimum.
//
#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
    { OLEIVERB_SHOW,            0, 0, 0},
    { OLEIVERB_HIDE,            0, 0, 0},
    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
    { OLEIVERB_PRIMARY,         0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000
//
const VERBINFO ovProperties =
    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
    { OLEIVERB_UIACTIVATE, 0, 0, 0};


//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo    (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//    CONTROLINFO *        - [in]  where to put said information
//
// Output:
//    HRESULT              - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetControlInfo
(
    CONTROLINFO *pControlInfo
)
{
    CHECK_POINTER(pControlInfo);

    // certain hosts have a bug in which it doesn't initialize the cb in the
    // CONTROLINFO structure, so we can only assert on that here.
    //
    ASSERT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

    // NOTE: control writers should override this routine if they want to
    // return accelerator information in their control.
    //
    pControlInfo->hAccel = NULL;
    pControlInfo->cAccel = NULL;
    pControlInfo->dwFlags = 0; //joejo - Vegas #VBE9106 uninitialized dwFlags

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic    [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.  default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//    LPMSG                - [in] message for this mnemonic
//
// Output:
//    HRESULT              - S_OK, E_POINTER
//
// Notes:
//
STDMETHODIMP COleControl::OnMnemonic
(
    LPMSG pMsg
)
{
    // OVERRIDE: default implementation is to just activate our control.  
    // user can override if they want more interesting behaviour.
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange    [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//    DISPID            - [in] dispid of the property that changed.
//
// Output:
//    HRESULT           - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnAmbientPropertyChange
(
    DISPID dispid
)
{
    // if we're being told about a change in mode [design/run] then
    // remember that so our stashing of mode will update itself
    // correctly
    //
    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
        m_fModeFlagValid = FALSE;

    if (dispid == DISPID_AMBIENT_LOCALEID || dispid == DISPID_UNKNOWN)
    {
      ENTERCRITICALSECTION1(&g_CriticalSection);  // Should be a crit sect around this.
      g_fHaveLocale = FALSE;	// Cause the lcid to be re-browsed when its needed
      LEAVECRITICALSECTION1(&g_CriticalSection);
    }

    // just pass this on to the derived control and see if they want
    // to do anything with it.
    //
    AmbientPropertyChanged(dispid);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents    [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//    - we maintain an internal count of freezes versus thaws.
//
STDMETHODIMP COleControl::FreezeEvents
(
    BOOL fFreeze
)
{
    // OVERRIDE: by default, we don't care.  user can override if they want to.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetClientSite
(
    IOleClientSite *pClientSite
)
{
    // make sure we free up all site pointers we're holding on to!  otherwise,
    // we can run into problems during aggregation
    //
    RELEASE_OBJECT(m_pClientSite);
    RELEASE_OBJECT(m_pControlSite);
    RELEASE_OBJECT(m_pSimpleFrameSite);

    // store away the new client site
    //
    m_pClientSite = pClientSite;

    // if we've actually got one, then get some other interfaces we want to keep
    // around, and keep a handle on it
    //
    if (m_pClientSite) {
        m_pClientSite->AddRef();
        m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
            m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
    } else {
        // if they're telling us to clear our site pointers, go and release
        // everything else as well
        //
        RELEASE_OBJECT(m_pInPlaceSite);
        RELEASE_OBJECT(m_pInPlaceSiteWndless);
        RELEASE_OBJECT(m_pDispAmbient);
    }

    // now get the user to clear out/re-establish the pointers they want
    //
    return OnSetClientSite();
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//    IOleClientSite **        - [out]
//
// Output:
//    HRESULT                  - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetClientSite
(
    IOleClientSite **ppClientSite
)
{
    CHECK_POINTER(ppClientSite);

    *ppClientSite = m_pClientSite;
    ADDREF_OBJECT(*ppClientSite);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames    [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//    LPCOLESTR        - [in] name of container application
//    LPCOLESTR        - [in] name of container document
//
// Output:
//    HRESULT          - S_OK
//
// Notes:
//    - we don't care about this
//
STDMETHODIMP COleControl::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObject
)
{
    // we don't care about these
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//    DWORD             - [in] indicates whether to save the object before closing
//
// Output:
//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED
//
// Notes:
//
STDMETHODIMP COleControl::Close
(
    DWORD dwSaveOption
)
{
    HRESULT hr;

    if (m_fInPlaceActive) {
        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
    }

    // handle the save flag.
    //
    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
        if (m_pClientSite) m_pClientSite->SaveObject();
        if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//    DWORD                - [in] which moniker is being set
//    IMoniker *           - [in] the moniker
//
// Output:
//    HRESULT              - S_OK, E_FAIL
//
// Notes:
//    - we don't support monikers.
//
STDMETHODIMP COleControl::SetMoniker
(
    DWORD     dwWhichMoniker,
    IMoniker *pMoniker
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//    DWORD            - [in]  how it's assigned
//    DWORD            - [in]  which moniker
//    IMoniker **      - [out] duh.
//
// Output:
//    HRESULT          - E_NOTIMPL
//
// Notes:
//    - we don't support monikers
//
STDMETHODIMP COleControl::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppMonikerOut
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData    [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//    IDataObject*    - [in] data object with the data
//    BOOL            - [in] how object is created
//    DWORD           - reserved
//
// Output:
//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't have data object support
//
STDMETHODIMP COleControl::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//    DWORD          - reserved
//    IDataObject ** - [out] data object for this control
//
// Output:
//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    *ppDataObject = NULL;        // be a good neighbour
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//    LONG             - [in]  verb to be performed
//    LPMSG            - [in]  event that invoked the verb
//    IOleClientSite * - [in]  the controls active client site
//    LONG             - [in]  reserved
//    HWND             - [in]  handle of window containing the object.
//    LPCRECT          - [in]  pointer to objects's display rectangle
//
// Output:
//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                       OLE_CLASSDIFF, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    HRESULT hr;

    switch (lVerb) {
      case OLEIVERB_SHOW:
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
        return InPlaceActivate(lVerb);

      case OLEIVERB_HIDE:
        UIDeactivate();
        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE);
        return S_OK;

      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
      // turns out that the CDK and certain hosts expect this to show the
      // properties instead.  Users can change what this verb does at will.
      //
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
        {
        int iPage;		
        CLSID *prgPropPages;

		// Only allow the Property Page to be displayed in design-mode.
		//
		if (!DesignMode())
				return S_OK;

        // show the frame ourselves if the host can't.
        //
        if (m_pControlSite) {
            hr = m_pControlSite->ShowPropertyFrame();
            if (hr != E_NOTIMPL)
                return hr;
        }

        IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

        // Allocate an array of CLSIDs
        //
        prgPropPages = (CLSID *) CtlHeapAlloc(g_hHeap, 0, CPROPPAGESOFCONTROL(m_ObjectType) * sizeof(CLSID));		
        if (!prgPropPages)
            return E_OUTOFMEMORY;

        // Copy the CLSIDs pointed to by the array of CLSID pointers to
        // an array of CLSIDs.  This conversion is necessary since OleCreatePropertyFrame
        // expects a pointer to an array of CLSIDs.  CPROPPAGESOFCONTROL(index) returns
        // a pointer to an array of CLSID pointers.
        //
        for (iPage = 0; iPage < CPROPPAGESOFCONTROL(m_ObjectType); iPage++)
            prgPropPages[iPage] = *((PPROPPAGESOFCONTROL(m_ObjectType))[iPage]);

        ModalDialog(TRUE);
        ENTERCRITICALSECTION1(&g_CriticalSection);  // This is for g_lcidLocale.
        hr = OleCreatePropertyFrame(GetActiveWindow(),
                            GetSystemMetrics(SM_CXSCREEN) / 2,
                            GetSystemMetrics(SM_CYSCREEN) / 2,
                            pwsz,
                            1,
                            &pUnk,
                            CPROPPAGESOFCONTROL(m_ObjectType),
                            prgPropPages,
                            g_lcidLocale,
                            NULL, NULL);
        LEAVECRITICALSECTION1(&g_CriticalSection);

        ModalDialog(FALSE);
        CtlHeapFree(g_hHeap, 0, prgPropPages);

        return hr;
        }

      default:
        // if it's a derived-control defined verb, pass it on to them
        //
        if (lVerb > 0) {
            hr = DoCustomVerb(lVerb);

            if (hr == OLEOBJ_S_INVALIDVERB) {
                // unrecognised verb -- just do the primary verb and
                // activate the sucker.
                //
                hr = InPlaceActivate(OLEIVERB_PRIMARY);
                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
            } else
                return hr;
        } else {
            // it's a verb we don't implement.
            //
            return E_NOTIMPL;
        }
        break;
    }

    // dead code
    FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs    [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//    IEnumOleVERB **    - [out] new enumerator.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::EnumVerbs
(
    IEnumOLEVERB **ppEnumVerbs
)
{
    int cVerbs;
    OLEVERB *rgVerbs, *pVerb;

    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
    BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

    // count up all the verbs
    //
    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
             + (fHasProperties ? 1 : 0) + cVerbExtra;

    // if there aren't any, this suddenly gets really easy !
    //
    if (cVerbs == 0)
        return OLEOBJ_E_NOVERBS;

    // HeapAlloc some storage for these dudes so that we can pass them on to
    // the standard enumerator!
    //
    if (! (rgVerbs = (OLEVERB *)CtlHeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB))))
        return E_OUTOFMEMORY;
  
    // start copying over verbs.  first, the in-place guys
    //
    pVerb = rgVerbs;
    if (fCanInPlace) {
        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
        pVerb += CINPLACEVERBS;
      }

    if (fCanUIActivate)
        memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

    // if their control has properties, copy that over now.
    //
    if (fHasProperties) {
        memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
        pVerb++;
    }

    // finally, any custom verbs!
    //
    if (cVerbExtra) {
        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
    }

    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) New CStandardEnum(IID_IEnumOLEVERB,
                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
    if (!*ppEnumVerbs)
        return E_OUTOFMEMORY;

    // this forces us to go and look for the Localized DLLs.  This is necessary here
    // because the CopyOleVerb will get information from localized resources, but
    // will only use the global GetResourceHandle, which only uses the global value
    // for the LCID.  This turns out to not be a big performance hit, since this
    // function is typically only called in design mode, and we stash this value.
    //
    GetResourceHandle();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.
//
// Output:
//    HRESULT            - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::Update
(
    void
)
{
    // nothing to do!!!
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate    [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.
//
// Output:
//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE
//
// Notes:
//
STDMETHODIMP COleControl::IsUpToDate
(
    void
)
{
    // we're always up to date
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//    CLSID *      - [in] where to put the CLSID
//
// Output:
//    HRESULT      - S_OK, E_FAIL
//
// Notes:
//
STDMETHODIMP COleControl::GetUserClassID
(
    CLSID *pclsid
)
{
    // this is the same as IPersist::GetClassID
    //
    return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//    DWORD        - [in]  specifies the form of the type name.
//    LPOLESTR *   - [out] where to put user type
//
// Output:
//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::GetUserType
(
    DWORD     dwFormOfType,
    LPOLESTR *ppszUserType
)
{
    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//    DWORD            - [in] which form or 'aspect'  is to be displayed.
//    SIZEL *          - [in] size limit for the control.
//
// Output:
//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::SetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *psizel
)
{
    SIZEL sl, slOld;
    RECT  rect;
    BOOL  f;


    if (dwDrawAspect & DVASPECT_CONTENT) {

	// Call to OnPosRectChange may cause our extents to be set again.  Accept the extents if this happens.
	//
	if (m_fChangingExtents)
	    return S_OK;    

	m_fChangingExtents = TRUE;

        // change the units to pixels, and resize the control.
        //
        HiMetricToPixel(psizel, &sl);

        // first call the user version.  if they return FALSE, they want
        // to keep their current size
        //	
        slOld = m_Size;
        f = OnSetExtent(&sl);
        if (f)			
            m_Size = sl;      /// Note: subclassing control may change the passed in &sl extents				

        if (slOld.cx != m_Size.cx || slOld.cy != m_Size.cy)
            m_fDirty = TRUE;

        // set things up with our HWND if we've got one.
        //
        if (!m_pInPlaceSiteWndless) 
		{
            if (m_fInPlaceActive) 
			{
    
                // theoretically, one should not need to call OnPosRectChange
                // here, but there appear to be a few host related issues that
                // will make us keep it here.  we won't, however, both with
                // windowless ole controls, since they are all new hosts who
                // should know better
                //
				if (m_hwnd) 
				{

					rect = m_rcLocation;
			
					rect.right = rect.left + m_Size.cx;
					rect.bottom = rect.top + m_Size.cy;
					GetInPlaceSite()->OnPosRectChange(&rect);  // May cause container to call our SetObjectRects
				}
	                    
            } 
			else if (m_hwnd) 
			{
                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            } 
			else 
			{
                ViewChanged();
            }
        }

		if (!m_fInPlaceActive)
		{
			// Due to trident, we need to call RequestNewObjectLayout
			// here so we visually display our new extents.

			if (m_pClientSite)
				m_pClientSite->RequestNewObjectLayout();
		}

	m_fChangingExtents = FALSE;

        // return code depending on whether or not user accepted given
        // size
        //
        return (f) ? S_OK : E_FAIL;

    } else {
        // we don't support any other aspects.
        //
        return DV_E_DVASPECT;
    }

    // dead code
    FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//    DWORD            - [in] aspect
//    SIZEL *          - [in] where to put results
//
// Output:
//    S_OK, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *pSizeLOut
)
{

    if (dwDrawAspect & DVASPECT_CONTENT) {
        PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//    IAdviseSink *     - [in]  advise sink of calling object
//    DWORD             - [out] cookie
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::Advise
(
    IAdviseSink *pAdviseSink,
    DWORD       *pdwConnection
)
{
    HRESULT hr;

    // if we haven't yet created a standard advise holder object, do so
    // now
    //
    if (!m_pOleAdviseHolder) {
        hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
        RETURN_ON_FAILURE(hr);
    }

    // just get it to do the work for us!
    //
    return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//    DWORD         - [in] connection cookie
//
// Output:
//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION
//
// Notes:
//
STDMETHODIMP COleControl::Unadvise
(
    DWORD dwConnection
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
        CONNECT_E_NOCONNECTION;
    }

    return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//    IEnumSTATDATA **    - [out] where to put enumerator
//
// Output:
//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::EnumAdvise
(
    IEnumSTATDATA **ppEnumOut
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody Called EnumAdvise without setting up any connections");
        *ppEnumOut = NULL;
        return E_FAIL;
    }

    return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//    DWORD         - [in]  aspect desired
//    DWORD *       - [out] where to put the bits.
//
// Output:
//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//
STDMETHODIMP COleControl::GetMiscStatus
(
    DWORD  dwAspect,
    DWORD *pdwStatus
)
{
    CHECK_POINTER(pdwStatus);

    if (dwAspect == DVASPECT_CONTENT) {
        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme    [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//    LOGPALETTE *     - [in] new palette
//
// Output:
//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't care.
//
STDMETHODIMP COleControl::SetColorScheme
(
    LOGPALETTE *pLogpal
)
{
    // OVERRIDE: control writers can use this if they want to
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//    HWND *        - [out] where to return window handle.
//
// Output:
//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//    - this routine has slightly different semantics for windowless controls
//
STDMETHODIMP COleControl::GetWindow
(
    HWND *phwnd
)
{
    // if we're windowles, then we want to return E_FAIL for this so hosts
    // know we're windowless.  we'll also fail if we're not in-place active
    //
    if (m_pInPlaceSiteWndless || !m_fInPlaceActive)
        return E_FAIL;

    // otherwise, just return our outer window.
    //
    *phwnd = GetOuterWindow();

    return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//    BOOL            - [in] whether or not to enter help mode.
//
// Output:
//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::ContextSensitiveHelp
(
    BOOL fEnterMode
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//    LONG         - [in] the verb that caused us to activate
//
// Output:
//    HRESULT
//
// Notes:
//    - this is spaghetti code at it's worst.  effectively, we have to
//      be able to handle three types of site pointers -- IOleInPlaceSIte,
//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//      pretty.
//
HRESULT COleControl::InPlaceActivate
(
    LONG lVerb
)
{
    BOOL f;
    SIZEL sizel;
    IOleInPlaceSiteEx *pIPSEx = NULL;
    HRESULT hr;
    BOOL    fNoRedraw = FALSE;
    HWND    hwndParent;

    // if we don't have a client site, then there's not much to do.
    //
    if (!m_pClientSite)
        return S_OK;

    // get an InPlace site pointer.
    //
    if (!GetInPlaceSite()) {

        // if they want windowless support, then we want IOleInPlaceSiteWindowless
        //
        if (FCONTROLISWINDOWLESS(m_ObjectType))
            m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

        // if we're not able to do windowless siting, then we'll just get an
        // IOleInPlaceSite pointer.
        //
        if (!m_pInPlaceSiteWndless) {
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            RETURN_ON_FAILURE(hr);
        }
    }

    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
    // activation.  if we're windowless, we've already got it, else we need to
    // try and get it
    //
    if (m_pInPlaceSiteWndless) {
        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
        pIPSEx->AddRef();
    } else
        m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

    // if we're not already active, go and do it.
    //
    if (!m_fInPlaceActive || !m_fInPlaceVisible) {
        OLEINPLACEFRAMEINFO InPlaceFrameInfo;
        RECT rcPos, rcClip;
	BOOL fJustSetPosition  = m_fInPlaceActive;

        // if we have a windowless site, see if we can go in-place windowless
        // active
        //
        hr = S_FALSE;

	if (fJustSetPosition)
		hr = S_OK;
        else if (m_pInPlaceSiteWndless) {
            hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
            CLEANUP_ON_FAILURE(hr);

            // if they refused windowless, we'll try windowed
            //
            if (S_OK != hr) {
                ASSERT(m_pInPlaceSite == NULL, "In-place site is non-NULL.  We're gonna leak.");
                RELEASE_OBJECT(m_pInPlaceSiteWndless);
                hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
                CLEANUP_ON_FAILURE(hr);
            }
        }

        // just try regular windowed in-place activation
        //
        if (hr != S_OK) {
            hr = m_pInPlaceSite->CanInPlaceActivate();
            if (hr != S_OK) {
                hr = (FAILED(hr)) ? E_FAIL : hr;
                goto CleanUp;
            }
        }

	if (!fJustSetPosition)
	{
		// if we are here, then we have permission to go in-place active.
		// now, announce our intentions to actually go ahead and do this.
		//
		hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
			       : m_pInPlaceSite->OnInPlaceActivate();
		CLEANUP_ON_FAILURE(hr);

		// if we're here, we're ready to go in-place active.  we just need
		// to set up some flags, and then create the window [if we have
		// one]
		//
		m_fInPlaceActive = TRUE;
	}

	// In VB4, the position could have been changed while we
	// were invisible, so if we were already InPlaceActive but not visible
	// we need to get our size.
	// REVIEW: Is this much of a performance hit? Is there a way to tell
	// we've been resized in this case?

        // we need to get some information about our location in the parent
        // window, as well as some information about the parent
        //
        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        hr = GetInPlaceSite()->GetWindow(&hwndParent);
        if (SUCCEEDED(hr))
        {

#ifdef MDAC_BUILD
#if 0 
            //	hack fix for MDAC 8536 & 8738. 
            //	To be used if VB doesn't/can't fix the real bug(s); hwndParent (or it's parent) is not sized properly.
            //	Unfortunately, this code also affects the hf grid. If we need to add a virtual function bool ResizeParentBeforeCreation() 
            //	to COleControl (it should return false) and to the de.
            if ( ResizeParentBeforeCreation() )
            {
	            SIZE parent_size = m_Size;
	            if ( HWND grandparent = GetParent(hwndParent) )
	            {
		            RECT grandparent_bounds;
		            GetClientRect(grandparent,&grandparent_bounds);
		            parent_size.cx = grandparent_bounds.right;
		            parent_size.cy = grandparent_bounds.bottom;
	            }
	            if ( parent_size.cx > 0 && parent_size.cy > 0 )
	            {
		            SetWindowPos(hwndParent,NULL,0,0,parent_size.cx,parent_size.cy,SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
	            }
            }
#endif
#endif

          if(m_pInPlaceFrame)
            RELEASE_OBJECT(m_pInPlaceFrame);

          if(m_pInPlaceUIWindow)
            RELEASE_OBJECT(m_pInPlaceUIWindow);

          hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
        }
        CLEANUP_ON_FAILURE(hr);

        // make sure we'll display ourselves in the correct location with the correct size
        //
        sizel.cx = rcPos.right - rcPos.left;
        sizel.cy = rcPos.bottom - rcPos.top;
        f = OnSetExtent(&sizel);
        if (f) m_Size = sizel;
        SetObjectRects(&rcPos, &rcClip);

        // finally, create our window if we have to!
        //
	if (!fJustSetPosition && 
		!m_pInPlaceSiteWndless) {
    
            SetInPlaceParent(hwndParent);

            // create the window, and display it.  die horribly if we couldnt'
            //
            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
                hr = E_FAIL;
                goto CleanUp;
            }

            // finally, tell the host of this
            //
            if (m_pClientSite)
                m_pClientSite->ShowObject();
        }
    }

    // don't need this any more
    //
    RELEASE_OBJECT(pIPSEx);

    // if we're not inplace visible yet, do so now.
    //
    if (!m_fInPlaceVisible)
        SetInPlaceVisible(TRUE);

    // if we weren't asked to UIActivate, then we're done.
    //
    if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
        return S_OK;

    // if we're not already UI active, do sow now.
    //
    if (!m_fUIActive) {
        m_fUIActive = TRUE;

        // inform the container of our intent
        //
        GetInPlaceSite()->OnUIActivate();

        // take the focus  [which is what UI Activation is all about !]
        //
        SetFocus(TRUE);

        // set ourselves up in the host.
        //
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

        // we have to explicitly say we don't wany any border space.
        //
        m_pInPlaceFrame->SetBorderSpace(NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetBorderSpace(NULL);
    }

    // be-de-be-de-be-de that's all folks!
    //
    return S_OK;

  CleanUp:
    // something catastrophic happened 